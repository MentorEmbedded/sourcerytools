Index: src/vsip/opt/simd/threshold.hpp
===================================================================
--- src/vsip/opt/simd/threshold.hpp	(revision 0)
+++ src/vsip/opt/simd/threshold.hpp	(revision 0)
@@ -0,0 +1,211 @@
+/* Copyright (c) 2007 by CodeSourcery.  All rights reserved.
+
+   This file is available for license from CodeSourcery, Inc. under the terms
+   of a commercial license and under the GPL.  It is not part of the VSIPL++
+   reference implementation and is not available under the BSD license.
+*/
+/** @file    vsip/opt/simd/threshold.hpp
+    @author  Assem Salama
+    @date    2007-05-02
+    @brief   VSIPL++ Library: SIMD threshold operation.
+
+*/
+
+#ifndef VSIP_OPT_SIMD_THRESHOLD_HPP
+#define VSIP_OPT_SIMD_THRESHOLD_HPP
+
+#include <vsip/opt/simd/simd.hpp>
+#include <vsip/core/metaprogramming.hpp>
+
+/***********************************************************************
+  Definitions
+***********************************************************************/
+
+namespace vsip
+{
+namespace impl
+{
+namespace simd
+{
+
+// Define value_types for which threshold is optimized.
+//  - float
+//  - double
+
+template <typename T,
+	  bool     IsSplit>
+struct Is_algorithm_supported<T, IsSplit, Alg_threshold>
+{
+  static bool const value =
+    Simd_traits<T>::is_accel &&
+    (Type_equal<T, float>::value ||
+     Type_equal<T, double>::value);
+};
+
+
+
+// Class for threshold
+
+template <typename T,
+	  bool     Is_vectorized>
+struct Simd_threshold;
+
+
+// Simd function to do threshold only when K is 0
+template <typename T>
+void simd_thresh0(T* Z, T* A, T* B, int n)
+{
+  typedef Simd_traits<T>                         simd;
+  typedef Simd_traits<int>                       simdi;
+  typedef typename simd::simd_type               simd_type;
+  typedef typename simdi::simd_type              simd_itype;
+
+  simd::enter();
+
+  while (n >= simd::vec_size)
+  {
+    n -= simd::vec_size;
+
+    simd_type A_v    = simd::load(A);
+    simd_type B_v    = simd::load(B);
+    simd_itype mask  = simd_itype(simd::gt(A_v,B_v));
+    simd_itype nmask = simdi::bnot(mask);
+    simd_itype res   = simdi::band(simd_itype(A_v),nmask);
+    simd::store(Z,simd_type(res));
+
+    A += simd::vec_size;
+    B += simd::vec_size;
+    Z += simd::vec_size;
+  }
+
+  simd::exit();
+}
+
+// Simd function to do threshold only when K is not 0
+template <typename T>
+void simd_thresh(T* Z, T* A, T* B, T k, int n)
+{
+  typedef Simd_traits<T>                         simd;
+  typedef Simd_traits<int>                       simdi;
+  typedef typename simd::simd_type               simd_type;
+  typedef typename simdi::simd_type              simd_itype;
+
+  simd::enter();
+
+  simd_type k_v    = simd::load_scalar_all(k);
+
+  while (n >= simd::vec_size)
+  {
+    n -= simd::vec_size;
+
+    simd_type A_v    = simd::load(A);
+    simd_type B_v    = simd::load(B);
+    simd_itype mask  = simd_itype(simd::gt(A_v,B_v));
+    mask             = simdi::band(mask,simd_itype(k_v));
+    simd_itype nmask = simdi::bnot(mask);
+    simd_itype res   = simdi::band(simd_itype(A_v),nmask);
+    simd::store(Z,simd_type(res));
+
+    A += simd::vec_size;
+    B += simd::vec_size;
+    Z += simd::vec_size;
+  }
+
+  simd::exit();
+}
+
+
+// Generic, non-vectorized implementation of threshold
+
+template <typename T>
+struct Simd_threshold<T, false>
+{
+  static void exec(T* Z, T* A, T* B, T k, int n)
+  {
+    while (n)
+    {
+      if(*A > *B) *Z = *A;
+      else *Z = k;
+      A++;B++;Z++;
+      n--;
+    }
+  }
+};
+
+// vectorized version
+
+template <typename T>
+struct Simd_threshold<T, true>
+{
+  static void exec(T* Z, T* A, T* B, T k, int n)
+  {
+    typedef Simd_traits<T>                         simd;
+    typedef Simd_traits<int>                       simdi;
+    typedef typename simd::simd_type               simd_type;
+    typedef typename simdi::simd_type              simd_itype;
+
+    // handle mis-aligned vectors
+    if (simd::alignment_of(A) != simd::alignment_of(B) ||
+	simd::alignment_of(Z) != simd::alignment_of(A))
+    {
+      Simd_threshold<T,false>::exec(Z,A,B,k,n);
+      return;
+    }
+
+    // clean up initial unaligned values
+    while (simd::alignment_of(A) != 0)
+    {
+      if(*A > *B) *Z = *A;
+      else *Z = k;
+      A++;B++;Z++;
+      n--;
+    }
+  
+    if (n == 0) return;
+
+
+    if(k != T(0)) {
+      simd_thresh0(Z,A,B,n);
+    } else {
+      simd_thresh(Z,A,B,k,n);
+    }
+
+    // handle last bits
+    while(n)
+    {
+      if(*A > *B) *Z = *A;
+      else *Z = k;
+      A++;B++;Z++;
+      n--;
+    }
+
+  }
+};
+
+// Depending on VSIP_IMPL_LIBSIMD_INLINE macro, either provide these
+// functions inline, or provide non-inline functions in the libvsip.a.
+
+#if VSIP_IMPL_INLINE_LIBSIMD
+
+template <typename T>
+inline void 
+threshold(T* Z, T* A, T* B, T k, int n)
+{
+  static bool const Is_vectorized =
+    Is_algorithm_supported<T, false, Alg_threshold>::value;
+  Simd_threshold<T, Is_vectorized>::exec(Z,A,B,k,n);
+}
+
+#else
+
+template <typename T>
+inline void 
+threshold(T* Z, T* A, T* B, T k, int n);
+
+#endif
+
+} // namespace vsip::impl::simd
+} // namespace vsip::impl
+} // namespace vsip
+
+#endif
Index: src/vsip/opt/simd/simd.hpp
===================================================================
--- src/vsip/opt/simd/simd.hpp	(revision 165174)
+++ src/vsip/opt/simd/simd.hpp	(working copy)
@@ -998,6 +998,7 @@
 struct Alg_vbor;
 struct Alg_vbxor;
 struct Alg_vbnot;
+struct Alg_threshold;
 
 template <typename T,
 	  bool     IsSplit,
Index: src/vsip/opt/simd/eval_generic.hpp
===================================================================
--- src/vsip/opt/simd/eval_generic.hpp	(revision 165174)
+++ src/vsip/opt/simd/eval_generic.hpp	(working copy)
@@ -37,6 +37,7 @@
 #include <vsip/opt/simd/rscvmul.hpp>
 #include <vsip/opt/simd/vgt.hpp>
 #include <vsip/opt/simd/vlogic.hpp>
+#include <vsip/opt/simd/threshold.hpp>
 
 /***********************************************************************
   Declarations
@@ -602,9 +603,79 @@
   }
 };
 
+/***********************************************************************
+  threshold: vector threshold operator
+  ite(A > B, A, k)
+***********************************************************************/
 
+template <typename DstBlock,
+          typename T,
+	  typename Block1,
+	  typename Block2>
+struct Serial_expr_evaluator<
+  1, DstBlock,
 
+  Ternary_expr_block<1, ite_functor,
+    Binary_expr_block<1u, gt_functor,
+                      Block1, T,
+		      Block2, T> const, bool,
+    Block1, T,
+    Scalar_block<1,T>, T> const,
 
+    Simd_builtin_tag>
+                      
+{
+
+  typedef Ternary_expr_block<1, ite_functor,
+    Binary_expr_block<1u, gt_functor,
+                      Block1, T,
+		      Block2, T> const, bool,
+    Block1, T,
+    Scalar_block<1,T>, T> SrcBlock;
+
+
+  static char const* name() { return "Expr_SIMD_threshold"; }
+
+  typedef typename Adjust_layout_dim<
+    1, typename Block_layout<DstBlock>::layout_type>::type
+  dst_lp;
+  typedef typename Adjust_layout_dim<
+    1, typename Block_layout<Block1>::layout_type>::type
+  a_lp;
+  typedef typename Adjust_layout_dim<
+    1, typename Block_layout<Block2>::layout_type>::type
+  b_lp;
+
+  static bool const ct_valid = 
+    simd::Is_algorithm_supported<T, false, simd::Alg_threshold>::value;
+  
+  static bool rt_valid(DstBlock& dst, SrcBlock const& src)
+  {
+    // check if all data is unit stride
+    Ext_data<DstBlock, dst_lp>     ext_dst(dst,              SYNC_OUT);
+    Ext_data<Block1,   a_lp>       ext_a(src.first().left(), SYNC_IN);
+    Ext_data<Block2,   b_lp>       ext_b(src.first().right(),SYNC_IN);
+    return(ext_dst.stride(0) == 1 &&
+           ext_a.stride(0) == 1 &&
+	   ext_b.stride(0) == 1 &&
+	   // make sure (A > B, A, k)
+	   (src.first.left() == src.second()));
+  }
+
+  static void exec(DstBlock& dst, SrcBlock const& src)
+  {
+    Ext_data<DstBlock, dst_lp>     ext_dst(dst,              SYNC_OUT);
+    Ext_data<Block1,   a_lp>       ext_a(src.first().left(), SYNC_IN);
+    Ext_data<Block2,   b_lp>       ext_b(src.first().right(),SYNC_IN);
+
+    simd::threshold(ext_dst.data(), ext_a.data(), ext_b.data(),
+                    src.third().value(), ext_dst.size());
+  }
+};
+
+
+
+
 } // namespace vsip::impl
 } // namespace vsip
 
Index: src/vsip/opt/simd/threshold.cpp
===================================================================
--- src/vsip/opt/simd/threshold.cpp	(revision 0)
+++ src/vsip/opt/simd/threshold.cpp	(revision 0)
@@ -0,0 +1,51 @@
+/* Copyright (c) 2007 by CodeSourcery.  All rights reserved.
+
+   This file is available for license from CodeSourcery, Inc. under the terms
+   of a commercial license and under the GPL.  It is not part of the VSIPL++
+   reference implementation and is not available under the BSD license.
+*/
+/** @file    vsip/opt/simd/threshold.cpp
+    @author  Assem Salama
+    @date    2007-05-02
+    @brief   VSIPL++ Library: SIMD threshold
+
+*/
+
+/***********************************************************************
+  Included Files
+***********************************************************************/
+
+#include <vsip/opt/simd/threshold.hpp>
+
+
+
+/***********************************************************************
+  Definitions
+***********************************************************************/
+
+namespace vsip
+{
+namespace impl
+{
+namespace simd
+{
+
+#if !VSIP_IMPL_INLINE_LIBSIMD
+
+template <typename T>
+void 
+threshold(T* Z, T* A, T* B, T k, int n)
+{
+  static bool const Is_vectorized =
+    Is_algorithm_supported<T, false, Alg_threshold>::value;
+  Simd_threshold<T, Is_vectorized>::exec(Z,A,B,k,n);
+}
+
+template void threshold(float* Z, float* A, float* B, float k, int n);
+template void threshold(double* Z, double* A, double* B, double k, int n);
+
+#endif
+
+}
+}
+}
