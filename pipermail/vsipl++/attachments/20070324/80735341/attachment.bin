Index: benchmarks/maxval.cpp
===================================================================
--- benchmarks/maxval.cpp	(revision 165174)
+++ benchmarks/maxval.cpp	(working copy)
@@ -21,15 +21,19 @@
 #include <vsip/random.hpp>
 #include <vsip/selgen.hpp>
 #include <vsip/opt/profile.hpp>
+#include <vsip/core/metaprogramming.hpp>
+#include <vsip/selgen.hpp>
 
 #include <vsip_csl/test.hpp>
 #include "loop.hpp"
 
+#include "maxval.hpp"
+
 using namespace vsip;
 using namespace vsip_csl;
 
-
-template <typename T>
+template <typename T,
+          typename MapT = Local_map>
 struct t_maxval1
 {
   char* what() { return "t_maxval_vector"; }
@@ -40,24 +44,93 @@
 
   void operator()(length_type size, length_type loop, float& time)
   {
-    Vector<T>   view(size, T());
-    T           val = T();
-    Index<1>    idx;
+    using namespace vsip::impl;
 
+    typedef Dense<1,T,row1_type,MapT>                               block_type;
+
+    create_test_vector_helper<MapT,Vector,float,Dense<1,T,row1_type,MapT> >
+      ctvh(size);
+
+    T                      val = T();
+    Index<1>               idx;
+
     Rand<T>     gen(0, 0);
 
     if (init_ == 0)
-      view = gen.randu(size);
+      ctvh.assign_view(gen.randu(size));
     else if (init_ == 1)
-      view = ramp(T(0), T(1), size);
+      ctvh.assign_view(ramp(T(0), T(1), size));
     else if (init_ == 2)
-      view = ramp(T(size-1), T(-1), size);
+      ctvh.assign_view(ramp(T(size-1), T(-1), size));
+   
+    vsip::impl::profile::Timer t1;
     
+    t1.start();
+    for (index_type l=0; l<loop; ++l)
+      val = maxval(ctvh.view, idx);
+    t1.stop();
+
+    if (init_ == 1)
+    {
+      test_assert(equal(val, T(size-1)));
+      test_assert(idx == size-1);
+    }
+    else if (init_ == 2)
+    {
+      test_assert(equal(val, T(size-1)));
+      test_assert(idx == 0);
+    }
+    
+    time = t1.delta();
+  }
+
+  void diag()
+  {
+  }
+
+  t_maxval1(int init) : init_(init) {}
+
+  int init_;
+};
+
+template <typename T,
+          typename MapT = Local_map,
+	  typename Tag = impl::Cvsip_tag>
+struct t_maxval2
+{
+  char* what() { return "t_maxval_vector"; }
+  int ops_per_point(length_type)  { return 1; }
+  int riob_per_point(length_type) { return sizeof(T); }
+  int wiob_per_point(length_type) { return 0; }
+  int mem_per_point(length_type)  { return 1*sizeof(T); }
+
+  void operator()(length_type size, length_type loop, float& time)
+  {
+    using namespace vsip::impl;
+
+    typedef Dense<1,T,row1_type,MapT>                               block_type;
+    typedef reduction_op_eval<Max_value,T,block_type,1,Tag> eval;
+
+    create_test_vector_helper<MapT,Vector,float,Dense<1,T,row1_type,MapT> >
+      ctvh(size);
+
+    T                      val = T();
+    Index<1>               idx;
+
+    Rand<T>     gen(0, 0);
+
+    if (init_ == 0)
+      ctvh.assign_view(gen.randu(size));
+    else if (init_ == 1)
+      ctvh.assign_view(ramp(T(0), T(1), size));
+    else if (init_ == 2)
+      ctvh.assign_view(ramp(T(size-1), T(-1), size));
+   
     vsip::impl::profile::Timer t1;
     
     t1.start();
     for (index_type l=0; l<loop; ++l)
-      val = vsip::maxval(view, idx);
+      eval::exec(val, ctvh.view.block(), idx);
     t1.stop();
 
     if (init_ == 1)
@@ -74,6 +147,10 @@
     time = t1.delta();
   }
 
+  void diag()
+  {
+  }
+
   t_maxval1(int init) : init_(init) {}
 
   int init_;
@@ -96,6 +173,12 @@
   case  1: loop(t_maxval1<float>(0)); break;
   case  2: loop(t_maxval1<float>(1)); break;
   case  3: loop(t_maxval1<float>(2)); break;
+  case  4: loop(t_maxval2<float,Map<>,impl::Parallel_tag>(0)); break;
+  case  5: loop(t_maxval2<float,Map<>,impl::Parallel_tag>(1)); break;
+  case  6: loop(t_maxval2<float,Map<>,impl::Parallel_tag>(2)); break;
+  case  7: loop(t_maxval2<float,Map<>,impl::Cvsip_tag>(0)); break;
+  case  8: loop(t_maxval2<float,Map<>,impl::Cvsip_tag>(1)); break;
+  case  9: loop(t_maxval2<float,Map<>,impl::Cvsip_tag>(2)); break;
   default: return 0;
   }
   return 1;
Index: benchmarks/maxval.hpp
===================================================================
--- benchmarks/maxval.hpp	(revision 0)
+++ benchmarks/maxval.hpp	(revision 0)
@@ -0,0 +1,101 @@
+/* Copyright (c) 2006 by CodeSourcery.  All rights reserved.
+
+   This file is available for license from CodeSourcery, Inc. under the terms
+   of a commercial license and under the GPL.  It is not part of the VSIPL++
+   reference implementation and is not available under the BSD license.
+*/
+/** @file    benchmarks/maxval.hpp
+    @author  Assem Salama
+    @date    2006-07-22
+    @brief   VSIPL++ Library: Helper file for maxval benchmark
+
+*/
+#ifndef BENCHMARKS_MAXVAL_HPP
+#define BENCHMARKS_MAXVAL_HPP
+
+using namespace vsip::impl;
+using namespace vsip;
+
+// Make a structure to run maxval based on tag.
+template <template <typename> class ReduceT,
+	  typename T,
+          typename Block,
+	  dimension_type dim,
+          typename Tag>
+struct reduction_op_eval<ReduceT,T,Block,dim,Tag>
+{
+  typedef typename Block_layout<Block>::order_type order_type;
+  typedef impl::Evaluator<Op_reduce_idx<ReduceT>,
+		      typename ReduceT<T>::result_type,
+		      impl::Op_list_3<Block const&,
+                                      Index<dim>&,
+                                      order_type>,
+                      Tag> evaluator;
+
+  static void exec(T& r, Block const& a, Index<dim>& idx)
+  {
+    evaluator::exec(r,a,idx,order_type());
+  }
+};
+
+// structure to help us create test vectors
+template <typename MapT,
+          template <typename,typename> class ViewT,
+	  typename T,
+	  typename Block>
+struct create_test_vector_helper {};
+
+// override for when destination is a local view
+template<template <typename,typename> class ViewT,
+         typename T,
+	 typename Block>
+struct create_test_vector_helper<Local_map,ViewT,T,Block>
+{
+  typedef ViewT<T,Block> dst_view;
+
+  // because this is a local to local, we do a normal assign
+  template <typename ViewT1>
+  void assign_view(ViewT1 sv)
+  { view=sv; };
+
+  // the constructor is very simple too
+  create_test_vector_helper(length_type size) : view(size) {};
+
+  dst_view view;
+
+
+};
+
+// override for when destination is a distributed view
+template<template <typename,typename> class ViewT,
+         typename T,
+	 typename Block>
+struct create_test_vector_helper<Map<>,ViewT,T,Block>
+{
+  static dimension_type const dim = ViewT<T,Block>::dim;
+  typedef Dense<dim,T,typename Row_major<dim>::type, Map<> > dst_block;
+  typedef ViewT<T,dst_block>                 dst_view;
+
+  template <typename ViewT1>
+  void assign_view(ViewT1 sv)
+  {
+    // processor 0 will distribute data to all other procs
+    Vector<processor_type> pvec_in(1); pvec_in(0) = processor_set()(0);
+    Map<>                  root_map(pvec_in);
+    dst_block              root_block(sv.size(),root_map);
+    dst_view               root_view(root_block);
+
+    // Ok, now move the vector to the distributed view
+    assign_local(root_view,sv);
+    view = root_view;
+
+  };
+
+  create_test_vector_helper(length_type size) :
+    view(size, Map<>(num_processors())) {};
+
+  dst_view view;
+
+};
+
+#endif // BENCHMARKS_MAXVAL_HPP
Index: src/vsip/core/reductions/reductions_idx.hpp
===================================================================
--- src/vsip/core/reductions/reductions_idx.hpp	(revision 165174)
+++ src/vsip/core/reductions/reductions_idx.hpp	(working copy)
@@ -24,6 +24,7 @@
 #  include <vsip/core/cvsip/eval_reductions_idx.hpp>
 #endif
 #if !VSIP_IMPL_REF_IMPL
+#include <vsip/opt/reductions/par_reductions.hpp>
 #  ifdef VSIP_IMPL_HAVE_SAL
 #    include <vsip/opt/sal/eval_reductions.hpp>
 #  endif
@@ -413,7 +414,8 @@
 		impl::Op_list_3<typename ViewT::block_type const&,
                                 Index<ViewT::dim>&,
                                 order_type>,
-		typename Make_type_list<Cvsip_tag, Mercury_sal_tag,
+		typename Make_type_list<Parallel_tag,
+		                        Cvsip_tag, Mercury_sal_tag,
                                         Generic_tag>::type>
         ::exec(r, v.block(), idx, order_type());
 #endif
Index: src/vsip/core/parallel/support.hpp
===================================================================
--- src/vsip/core/parallel/support.hpp	(revision 165174)
+++ src/vsip/core/parallel/support.hpp	(working copy)
@@ -434,7 +434,25 @@
 /***********************************************************************
   global_from_local_index
 ***********************************************************************/
+/// Determine BLOCKS's global index corresponding to local index L_IDX
 
+template <typename Block, dimension_type Dim>
+inline
+Index<Dim>
+global_from_local_index_blk(
+  Block const&             b,
+  Index<Dim> const& l_idx)
+{
+  Index<Dim> g_idx;
+
+  for (dimension_type d=0; d<Dim; ++d)
+    g_idx[d] = 
+      b.map().impl_global_from_local_index(d, b.map().subblock(), l_idx[d]);
+
+  return g_idx;
+}
+
+
 /// Determine VIEW's global index corresponding to local index L_IDX
 /// of subblock SB.
 
Index: src/vsip/opt/reductions/par_reductions.hpp
===================================================================
--- src/vsip/opt/reductions/par_reductions.hpp	(revision 0)
+++ src/vsip/opt/reductions/par_reductions.hpp	(revision 0)
@@ -0,0 +1,173 @@
+/* Copyright (c) 2007 by CodeSourcery.  All rights reserved. */
+
+/** @file    vsip/core/reductions/par_reductions.hpp
+    @author  Assem Salama
+    @date    2007-03-14
+    @brief   VSIPL++ Library: Parallel index reduction functions.
+	     [math.fns.reductidx].
+
+*/
+
+#ifndef VSIP_OPT_REDUCTIONS_PAR_REDUCTIONS_HPP
+#define VSIP_OPT_REDUCTIONS_PAR_REDUCTIONS_HPP
+
+#include <vsip/support.hpp>
+#include <vsip/vector.hpp>
+#include <vsip/matrix.hpp>
+#include <vsip/tensor.hpp>
+
+
+namespace vsip
+{
+
+namespace impl
+{
+
+template <template <typename> class ReduceT,
+          typename                  T,
+          dimension_type            dim,
+	  typename                  Block>
+inline T
+reduce_idx_blk(Block& b, Index<dim>& idx)
+{
+  T r;
+  typedef typename Block_layout<Block>::order_type
+		order_type;
+
+  General_dispatch<
+		impl::Op_reduce_idx<ReduceT>,
+		typename ReduceT<T>::result_type,
+		impl::Op_list_3<Block const&,
+                                Index<dim>&,
+                                order_type>,
+		typename Make_type_list<Cvsip_tag, Mercury_sal_tag,
+                                        Generic_tag>::type>
+        ::exec(r, b, idx, order_type());
+
+  return r;
+}
+
+
+template<template <typename> class ReduceT,
+         typename T,
+         typename Block, dimension_type dim>
+inline T
+generic_par_idx_op(Block& a, Index<dim>& idx)
+{
+  typedef Map<Block_dist>                          map_type;
+  typedef Dense<1,T,row1_type,Map<> >              block_type;
+  typedef Dense<1,Index<dim>,row1_type,Map<> >     block_idx_type;
+  typedef Dense<1,T,row1_type,Global_map<1> >          g_block_type;
+  typedef Dense<1,Index<dim>,row1_type,Global_map<1> > g_block_idx_type;
+  typedef Vector<T,block_type>                     vect_type;
+  typedef Vector<Index<dim>,block_idx_type>        vect_idx_type;
+  Index<dim>                                       my_res_idx;
+  Index<dim>                                       my_g_res_idx;
+  Index<1>                                         global_res_idx;
+  T                                                global_res;
+
+  Vector<processor_type> a_proc_set       = a.map().processor_set();
+
+  // We will make two vectors, results, and results_idx. Results will hold
+  // the result of the reduction of each processor. The reults_idx will
+  // hold the index of the reduction of each processor.
+  Map<>                                   map(a_proc_set,a_proc_set.size());
+  vect_type                               results(a_proc_set.size(),map);
+  vect_idx_type                           results_idx(a_proc_set.size(),map);
+
+  if(a.map().subblock() != no_subblock) 
+  {
+    results.local().put(0,
+      reduce_idx_blk<ReduceT,T>(get_local_block(a),my_res_idx));
+    my_g_res_idx = global_from_local_index_blk(a,my_res_idx);
+    results_idx.local().put(0,my_g_res_idx);
+  }
+
+
+  // Ok, now, perform the same reduction on the local results
+
+  // first, make a vector with a global map that contains all the results
+  Vector<T,g_block_type>                  global_results(a_proc_set.size());
+  Vector<Index<dim>,g_block_idx_type>     global_results_idx(a_proc_set.size());
+  // do broadcast
+  global_results     = results;
+  global_results_idx = results_idx;
+
+  global_res = reduce_idx_blk<ReduceT,T>
+      (global_results.block(),global_res_idx);
+  idx = global_results_idx.get(global_res_idx[0]);
+
+  return global_res;
+
+}
+
+/***********************************************************************
+  Parallel evaluators.
+***********************************************************************/
+
+template <template <typename> class ReduceT,
+          dimension_type            dim,
+          typename                  OrderT>
+struct Reduction_idx_supported
+{ static bool const value = false; };
+
+// All suppored reductions here
+template <dimension_type dim, typename OrderT>
+struct Reduction_idx_supported<Max_value, dim, OrderT>
+{ static bool const value = true; };
+
+template <dimension_type dim, typename OrderT>
+struct Reduction_idx_supported<Min_value, dim, OrderT>
+{ static bool const value = true; };
+
+template <dimension_type dim, typename OrderT>
+struct Reduction_idx_supported<Max_mag_value, dim, OrderT>
+{ static bool const value = true; };
+
+template <dimension_type dim, typename OrderT>
+struct Reduction_idx_supported<Min_mag_value, dim, OrderT>
+{ static bool const value = true; };
+
+template <dimension_type dim, typename OrderT>
+struct Reduction_idx_supported<Max_magsq_value, dim, OrderT>
+{ static bool const value = true; };
+
+template <dimension_type dim, typename OrderT>
+struct Reduction_idx_supported<Min_magsq_value, dim, OrderT>
+{ static bool const value = true; };
+
+
+/**********************************************************************
+* Parallel evaluators for index returning reductions
+**********************************************************************/
+
+template <template <typename> class ReduceT,
+          typename                  T,
+	  typename                  Block,
+	  typename                  OrderT,
+	  dimension_type            Dim >
+struct Evaluator<Op_reduce_idx<ReduceT>, T,
+		 Op_list_3<Block const&, Index<Dim>&, OrderT>,
+		 Parallel_tag>
+{
+  static bool const ct_valid = 
+    !Is_local_map<typename Block::map_type>::value &&
+    Reduction_idx_supported<ReduceT,
+                            Dim,
+			    OrderT>::value;
+
+  static bool rt_valid(T&, Block const&, Index<Dim>&, OrderT)
+  { return true; };
+
+  static void exec(T& r, Block const& a, Index<Dim>& idx, OrderT)
+  {
+    r = generic_par_idx_op<ReduceT,T>(a, idx);
+
+  }
+};
+
+
+} // namesapce vsip::impl
+} // namespace vsip
+
+#endif // VSIP_CORE_REDUCTIONS_PAR_REDUCTIONS_HPP
