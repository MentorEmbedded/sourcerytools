Index: src/vsip/math.hpp
===================================================================
RCS file: /home/cvs/Repository/vpp/src/vsip/math.hpp,v
retrieving revision 1.10
diff -c -p -r1.10 math.hpp
*** src/vsip/math.hpp	13 Sep 2005 16:39:45 -0000	1.10
--- src/vsip/math.hpp	19 Sep 2005 20:54:48 -0000
***************
*** 28,33 ****
--- 28,34 ----
  #include <vsip/impl/fns_userelt.hpp>
  #include <vsip/impl/reductions.hpp>
  #include <vsip/impl/reductions-idx.hpp>
+ #include <vsip/impl/matvec.hpp>
  #include <vsip/impl/matvec-prod.hpp>
  
  
Index: src/vsip/impl/matvec.hpp
===================================================================
RCS file: src/vsip/impl/matvec.hpp
diff -N src/vsip/impl/matvec.hpp
*** /dev/null	1 Jan 1970 00:00:00 -0000
--- src/vsip/impl/matvec.hpp	19 Sep 2005 20:54:48 -0000
***************
*** 0 ****
--- 1,181 ----
+ /* Copyright (c) 2005 by CodeSourcery, LLC.  All rights reserved. */
+ 
+ /** @file    vsip/impl/matvec.hpp
+     @author  Don McCoy
+     @date    2005-09-18
+     @brief   VSIPL++ Library: [math.matvec]
+ 
+     Matrix and Vector Operations 
+ */
+ 
+ #ifndef VSIP_IMPL_MATVEC_HPP
+ #define VSIP_IMPL_MATVEC_HPP
+ 
+ /***********************************************************************
+   Included Files
+ ***********************************************************************/
+ 
+ #include <vsip/vector.hpp>
+ #include <vsip/matrix.hpp>
+ 
+ 
+ namespace vsip
+ {
+ 
+ namespace impl
+ {
+ // vector-vector product.
+ template <typename T0,
+ 	  typename T1,
+ 	  typename T2,
+ 	  typename Block0,
+ 	  typename Block1>
+ void
+ generic_prod(
+   const_Vector<T0, Block0> a,
+   const_Vector<T1, Block1> b,
+   T2 &r)
+ {
+   assert(a.size() == b.size());
+ 
+   for ( index_type i = 0; i < a.size(); ++i )
+     r += a.get(i) * b.get(i);
+ }
+ 
+ // vector-vector kron
+ template <typename T0,
+           typename T1,
+           typename T2,
+           typename Block1,
+           typename Block2>
+ const_Matrix<typename Promotion<T0, typename Promotion<T1, T2>::type>::type>
+ kron( T0 alpha, Vector<T1, Block1> v, Vector<T2, Block2> w)
+     VSIP_NOTHROW
+ {
+   typedef Matrix<typename Promotion<T0, 
+     typename Promotion<T1, T2>::type>::type> return_type;
+   return_type r( v.size(), w.size(), alpha );
+ 
+   for ( index_type i = v.size(); i-- > 0; )
+     for ( index_type j = w.size(); j-- > 0; )
+       r.put( i, j, r.get( i, j ) * v.get(i) * w.get(j) );
+ 
+   return r;
+ }
+ 
+ // matrix-matrix kron
+ template <typename T0,
+           typename T1,
+           typename T2,
+           typename Block1,
+           typename Block2>
+ const_Matrix<typename Promotion<T0, typename Promotion<T1, T2>::type>::type>
+ kron( T0 alpha, Matrix<T1, Block1> v, Matrix<T2, Block2> w)
+     VSIP_NOTHROW
+ {
+   typedef Matrix<typename Promotion<T0, 
+     typename Promotion<T1, T2>::type>::type> return_type;
+   const length_type row_size = v.size(0) * w.size(0);
+   const length_type col_size = v.size(1) * w.size(1);
+ 
+   return_type r( row_size, col_size );
+   for ( index_type i = v.size(0); i-- > 0; )
+     for ( index_type j = w.size(0); j-- > 0; )
+       for ( index_type k = v.size(1); k-- > 0; )
+         for ( index_type l = w.size(1); l-- > 0; ) {
+           T0 val = alpha * v.get(i,k) * w.get(j,l);
+           r.put( j + (i * w.size(0)), l + (k * w.size(1)), val );
+         }
+ 
+   return r;
+ }
+ 
+ } // namespace impl
+ 
+ 
+ 
+ /***********************************************************************
+   Functions
+ ***********************************************************************/
+ 
+ // dot products  [math.matvec.dot]
+ 
+ /// cvjdot
+ template <typename T0, typename T1, typename Block0, typename Block1>
+ typename Promotion<complex<T0>, complex<T1> >::type
+ cvjdot(
+   const_Vector<complex<T0>, Block0> v,
+   const_Vector<complex<T1>, Block1> w) VSIP_NOTHROW
+ {
+   typedef typename Promotion<complex<T0>, complex<T1> >::type return_type;
+   
+   return_type r(0);
+   impl::generic_prod( v, conj(w), r );
+ 
+   return r;
+ }
+ 
+ /// dot
+ template <typename T0, typename T1, typename Block0, typename Block1>
+ typename Promotion<T0, T1>::type
+ dot(
+   const_Vector<T0, Block0> v,
+   const_Vector<T1, Block1> w) VSIP_NOTHROW
+ {
+   typedef typename Promotion<T0, T1>::type return_type;
+ 
+   return_type r(0);
+   impl::generic_prod( v, w, r );
+ 
+   return r;
+ }
+  
+  
+ // Transpositions  [math.matvec.transpose]
+ 
+ /// transpose
+ template <typename T, typename Block>
+ typename const_Matrix<T, Block>::transpose_type
+ trans(const_Matrix<T, Block> m) VSIP_NOTHROW
+ {
+   return m.transpose();
+ }
+ 
+ /// conjugate transpose
+ template <typename T, typename Block>
+ typename impl::Unary_func_view<impl::conj_functor,
+   typename const_Matrix<complex<T>,
+   Block>::transpose_type>::result_type
+ herm(const_Matrix<complex<T>, Block> m) VSIP_NOTHROW
+ {
+   typedef typename const_Matrix<complex<T>, Block>::transpose_type 
+     transpose_type;
+   typedef impl::Unary_func_view<impl::conj_functor, transpose_type> 
+     functor_type;
+ 
+   return functor_type::apply(m.transpose());
+ } 
+ 
+ 
+ // Kronecker tensor product  [math.matvec.kron]
+ 
+ /// kronecker product
+ template <typename T0,
+           typename T1,
+           typename T2,
+           template <typename, typename> class const_View,
+           typename Block1,
+           typename Block2>
+ const_Matrix<typename Promotion<T0, typename Promotion<T1, T2>::type>::type>
+ kron( T0 alpha, const_View<T1, Block1> v, const_View<T2, Block2> w )
+     VSIP_NOTHROW
+ {
+   return impl::kron( alpha, v, w );
+ }
+ 
+ 
+ 
+ 
+ } // namespace vsip
+ 
+ #endif
Index: tests/matvec.cpp
===================================================================
RCS file: tests/matvec.cpp
diff -N tests/matvec.cpp
*** /dev/null	1 Jan 1970 00:00:00 -0000
--- tests/matvec.cpp	19 Sep 2005 20:54:48 -0000
***************
*** 0 ****
--- 1,59 ----
+ /* Copyright (c) 2005 by CodeSourcery, LLC.  All rights reserved. */
+ 
+ /** @file    tests/matvec.cpp
+     @author  Don McCoy
+     @date    2005-09-19
+     @brief   VSIPL++ Library: Unit tests for [math.matvec]
+ */
+ 
+ /***********************************************************************
+   Included Files
+ ***********************************************************************/
+ 
+ #include <cassert>
+ #include <iostream>
+ 
+ #include <vsip/initfin.hpp>
+ #include <vsip/support.hpp>
+ #include <vsip/matrix.hpp>
+ #include <vsip/math.hpp>
+ 
+ #include "test.hpp"
+ #include "output.hpp"
+ 
+ using namespace std;
+ using namespace vsip;
+ 
+ 
+ 
+ 
+ /***********************************************************************
+   Main
+ ***********************************************************************/
+ 
+ 
+ int
+ main(int argc, char** argv)
+ {
+   vsipl init(argc, argv);
+ 
+ 
+   // Test Matrix-Matrix Kronecker
+ 
+   Matrix<scalar_f>
+     matrix_m( 2, 3, static_cast<scalar_f>(7.0) );
+   Matrix<scalar_f>
+     matrix_n( 4, 5, static_cast<scalar_f>(11.0) );
+   Matrix<>
+     kron_mn(kron (static_cast<scalar_f>(2.0), matrix_m, matrix_n));
+ 
+   assert( kron_mn.size(0) == 2 * 4 );
+   assert( kron_mn.size(1) == 3 * 5 );
+ 
+   for ( index_type a = 2 * 4; a-- > 0; )
+     for ( index_type b = 3 * 5; b-- > 0; )
+       assert( equal( kron_mn.get( a, b ),
+                 static_cast<scalar_f>(7 * 11 * 2.0) ) );
+ 
+   return 0;
+ }
