
Index: configure.ac
===================================================================
RCS file: /home/cvs/Repository/vpp/configure.ac,v
retrieving revision 1.49
diff -c -p -r1.49 configure.ac
*** configure.ac	14 Nov 2005 15:00:42 -0000	1.49
--- configure.ac	28 Nov 2005 07:59:21 -0000
*************** int main(int, char **)
*** 597,604 ****
      LDFLAGS=$save_LDFLAGS
    else
      AC_SUBST(VSIP_IMPL_HAVE_SAL, 1)
!     AC_DEFINE_UNQUOTED(VSIP_IMPL_HAVE_SAL, $vsipl_sal_h_name,
!     [The name of the header to include for the SAL interface, with <> quotes.])
    fi
  
  fi
--- 597,604 ----
      LDFLAGS=$save_LDFLAGS
    else
      AC_SUBST(VSIP_IMPL_HAVE_SAL, 1)
!     AC_DEFINE_UNQUOTED(VSIP_IMPL_HAVE_SAL, 1,
!       [Define to set whether or not to use Mercury's SAL library.])
    fi
  
  fi
Index: src/vsip/impl/sal.hpp
===================================================================
RCS file: /home/cvs/Repository/vpp/src/vsip/impl/sal.hpp,v
retrieving revision 1.2
diff -c -p -r1.2 sal.hpp
*** src/vsip/impl/sal.hpp	15 Nov 2005 21:01:27 -0000	1.2
--- src/vsip/impl/sal.hpp	28 Nov 2005 07:59:21 -0000
***************
*** 14,19 ****
--- 14,20 ----
    Included Files
  ***********************************************************************/
  
+ #include <iostream>
  #include <complex>
  #include <sal.h>
  
***************
*** 23,28 ****
--- 24,30 ----
  #include <vsip/impl/expr_binary_block.hpp>
  #include <vsip/impl/expr_operations.hpp>
  #include <vsip/impl/extdata.hpp>
+ #include <sal.h>
  
  /***********************************************************************
    Declarations
*************** void vdiv(std::pair<double*, double*> co
*** 362,367 ****
--- 364,397 ----
            length_type len);
  
  
+ // convolution functions
+ 
+ #define VSIP_IMPL_SAL_CONV( T, SAL_T, SALFCN, STRIDE_X ) \
+ inline void                            \
+ conv( T *filter, int f_as, int M,      \
+       T *input,  int i_as, int N,      \
+       T *output, int o_as )            \
+ {                                      \
+   SALFCN(                              \
+     (SAL_T *) &input[0],      /* input vector, length of A >= N+p-1 */ \
+     i_as * STRIDE_X,          /* address stride for A               */ \
+     (SAL_T *) &filter[M - 1], /* input filter                       */ \
+     -1 * f_as * STRIDE_X,     /* address stride for B               */ \
+     (SAL_T *) &output[0],     /* output vector                      */ \
+     o_as * STRIDE_X,          /* address stride for C               */ \
+     N,                        /* real output count                  */ \
+     M,                        /* filter length (vector B)           */ \
+     0                         /* ESAL flag                          */ \
+   );                                   \
+ }
+ 
+ VSIP_IMPL_SAL_CONV( float,          float,   convx,  1 );
+ VSIP_IMPL_SAL_CONV( complex<float>, COMPLEX, cconvx, 2 );
+ 
+ 
+ 
+ 
+ 
  template <template <typename, typename> class Operator,
  	  typename DstBlock,
  	  typename LBlock,
Index: src/vsip/impl/signal-conv-sal.hpp
===================================================================
RCS file: src/vsip/impl/signal-conv-sal.hpp
diff -N src/vsip/impl/signal-conv-sal.hpp
*** /dev/null	1 Jan 1970 00:00:00 -0000
--- src/vsip/impl/signal-conv-sal.hpp	28 Nov 2005 07:59:21 -0000
***************
*** 0 ****
--- 1,373 ----
+ /* Copyright (c) 2005 by CodeSourcery, LLC.  All rights reserved. */
+ 
+ /** @file    vsip/impl/signal-conv-sal.hpp
+     @author  Don McCoy
+     @date    2005-11-18
+     @brief   VSIPL++ Library: Convolution class implementation using SAL.
+ */
+ 
+ #ifndef VSIP_IMPL_SIGNAL_CONV_SAL_HPP
+ #define VSIP_IMPL_SIGNAL_CONV_SAL_HPP
+ 
+ /***********************************************************************
+   Included Files
+ ***********************************************************************/
+ 
+ #include <vsip/support.hpp>
+ #include <vsip/domain.hpp>
+ #include <vsip/vector.hpp>
+ #include <vsip/matrix.hpp>
+ #include <vsip/impl/domain-utils.hpp>
+ #include <vsip/impl/signal-types.hpp>
+ #include <vsip/impl/profile.hpp>
+ #include <vsip/impl/signal-conv-common.hpp>
+ #include <vsip/impl/sal.hpp>
+ 
+ 
+ 
+ /***********************************************************************
+   Declarations
+ ***********************************************************************/
+ 
+ namespace vsip
+ {
+ 
+ namespace impl
+ {
+ 
+ template <>
+ struct Is_conv_impl_avail<Mercury_sal_tag, float>
+ {
+   static bool const value = true;
+ };
+ 
+ template <>
+ struct Is_conv_impl_avail<Mercury_sal_tag, std::complex<float> >
+ {
+   static bool const value = true;
+ };
+ 
+ 
+ // These help enforce limits on the length of the kernel
+ // when using SAL, which differ for complex values
+ template <typename T>
+ struct Max_kernel_length
+ {
+   static length_type const value = 0;
+ };
+ 
+ template <>
+ struct Max_kernel_length<float>
+ {
+   static length_type const value = 36;
+ };
+ 
+ template <>
+ struct Max_kernel_length<std::complex<float> >
+ {
+   static length_type const value = 17;
+ };
+ 
+ 
+ /// Specialize Convolution_impl for using SAL.
+ 
+ template <template <typename, typename> class ConstViewT,
+ 	  symmetry_type       Symm,
+ 	  support_region_type Supp,
+ 	  typename            T,
+ 	  unsigned            n_times,
+           alg_hint_type       a_hint>
+ class Convolution_impl<ConstViewT, Symm, Supp, T, n_times, a_hint,
+ 		       Mercury_sal_tag>
+ {
+   static dimension_type const dim = impl::Dim_of_view<ConstViewT>::dim;
+ 
+   // Compile-time constants.
+ public:
+   static symmetry_type const       symmtry = Symm;
+   static support_region_type const supprt  = Supp;
+ 
+   // Constructors, copies, assignments, and destructors.
+ public:
+   template <typename Block>
+   Convolution_impl(
+     ConstViewT<T, Block> filter_coeffs,
+     Domain<dim> const&   input_size,
+     length_type          decimation)
+     VSIP_THROW((std::bad_alloc));
+ 
+   Convolution_impl(Convolution_impl const&) VSIP_NOTHROW;
+   Convolution_impl& operator=(Convolution_impl const&) VSIP_NOTHROW;
+   ~Convolution_impl() VSIP_NOTHROW;
+ 
+   // Accessors.
+ public:
+   Domain<dim> const& kernel_size() const VSIP_NOTHROW  { return kernel_size_; }
+   Domain<dim> const& filter_order() const VSIP_NOTHROW { return kernel_size_; }
+   Domain<dim> const& input_size() const VSIP_NOTHROW   { return input_size_; }
+   Domain<dim> const& output_size() const VSIP_NOTHROW  { return output_size_; }
+   symmetry_type symmetry() const VSIP_NOTHROW          { return Symm; }
+   support_region_type support() const VSIP_NOTHROW     { return Supp; }
+   length_type decimation() const VSIP_NOTHROW          { return decimation_; }
+ 
+   float impl_performance(char* what) const
+   {
+     if      (!strcmp(what, "in_ext_cost"))
+     {
+       return pm_in_ext_cost_;
+     }
+     else if (!strcmp(what, "out_ext_cost"))
+     {
+       return pm_out_ext_cost_;
+     }
+     else if (!strcmp(what, "non-opt-calls"))
+     {
+       return pm_non_opt_calls_;
+     }
+     return 0.f;
+   }
+ 
+   // Implementation functions.
+ protected:
+   template <typename Block0,
+ 	    typename Block1>
+   void
+   convolve(const_Vector<T, Block0>,
+ 	   Vector<T, Block1>)
+     VSIP_NOTHROW;
+ 
+   template <typename Block0,
+ 	    typename Block1>
+   void
+   convolve(const_Matrix<T, Block0>,
+ 	   Matrix<T, Block1>)
+     VSIP_NOTHROW;
+ 
+   typedef vsip::impl::Layout<1, row1_type, vsip::impl::Stride_unit, vsip::impl::Cmplx_inter_fmt> layout_type;
+   typedef Vector<T> coeff_view_type;
+   typedef impl::Ext_data<typename coeff_view_type::block_type, layout_type> c_ext_type;
+ 
+   // Member data.
+ private:
+   coeff_view_type coeff_;
+   c_ext_type      coeff_ext_;
+   T*              pcoeff_;
+ 
+   Domain<dim>     kernel_size_;
+   Domain<dim>     input_size_;
+   Domain<dim>     output_size_;
+   T*              in_buffer_;
+   T*              out_buffer_;
+   length_type     decimation_;
+ 
+   int             pm_non_opt_calls_;
+   size_t          pm_in_ext_cost_;
+   size_t          pm_out_ext_cost_;
+ };
+ 
+ 
+ 
+ /***********************************************************************
+   Definitions
+ ***********************************************************************/
+ 
+ /// Construct a convolution object.
+ 
+ template <template <typename, typename> class ConstViewT,
+ 	  symmetry_type                       Symm,
+ 	  support_region_type                 Supp,
+ 	  typename                            T,
+ 	  unsigned                            n_times,
+           alg_hint_type                       a_hint>
+ template <typename Block>
+ Convolution_impl<ConstViewT, Symm, Supp, T, n_times, a_hint, Mercury_sal_tag>::
+ Convolution_impl(
+   ConstViewT<T, Block> filter_coeffs,
+   Domain<dim> const&   input_size,
+   length_type          decimation)
+ VSIP_THROW((std::bad_alloc))
+   : coeff_      (conv_kernel<coeff_view_type>(Symm, filter_coeffs)),
+     coeff_ext_  (coeff_.block(), impl::SYNC_IN),
+     pcoeff_     (coeff_ext_.data()),
+     kernel_size_(impl::view_domain(coeff_)),
+     input_size_ (input_size),
+     output_size_(impl::conv_output_size(Supp, kernel_size_, input_size,
+ 					decimation)),
+     decimation_ (decimation),
+     pm_non_opt_calls_ (0)
+ {
+   in_buffer_  = new T[input_size_.size()];
+   if (in_buffer_ == NULL)
+     VSIP_IMPL_THROW(std::bad_alloc());
+ 
+   out_buffer_ = new T[output_size_.size()];
+   if (out_buffer_ == NULL)
+   {
+     delete[] in_buffer_;
+     VSIP_IMPL_THROW(std::bad_alloc());
+   }
+ }
+ 
+ 
+ 
+ /// Destroy a SAL Convolution_impl object.
+ 
+ template <template <typename, typename> class ConstViewT,
+ 	  symmetry_type                       Symm,
+ 	  support_region_type                 Supp,
+ 	  typename                            T,
+ 	  unsigned                            n_times,
+           alg_hint_type                       a_hint>
+ Convolution_impl<ConstViewT, Symm, Supp, T, n_times, a_hint, Mercury_sal_tag>::
+ ~Convolution_impl()
+   VSIP_NOTHROW
+ {
+   delete[] out_buffer_;
+   delete[] in_buffer_;
+ }
+ 
+ 
+ 
+ // Perform 1-D convolution.
+ 
+ template <template <typename, typename> class ConstViewT,
+ 	  symmetry_type       Symm,
+ 	  support_region_type Supp,
+ 	  typename            T,
+ 	  unsigned            n_times,
+           alg_hint_type       a_hint>
+ template <typename Block0,
+ 	  typename Block1>
+ void
+ Convolution_impl<ConstViewT, Symm, Supp, T, n_times, a_hint, Mercury_sal_tag>::
+ convolve(
+   const_Vector<T, Block0> in,
+   Vector<T, Block1>       out)
+ VSIP_NOTHROW
+ {
+   length_type const M = this->coeff_.size(0);
+   length_type const N = this->input_size_[0].size();
+   length_type const P = this->output_size_[0].size();
+ 
+   assert(P == out.size());
+ 
+   typedef vsip::impl::Ext_data<Block0> in_ext_type;
+   typedef vsip::impl::Ext_data<Block1> out_ext_type;
+ 
+   in_ext_type  in_ext (in.block(),  vsip::impl::SYNC_IN,  in_buffer_);
+   out_ext_type out_ext(out.block(), vsip::impl::SYNC_OUT, out_buffer_);
+ 
+   pm_in_ext_cost_  += in_ext.cost();
+   pm_out_ext_cost_ += out_ext.cost();
+ 
+   T* pin    = in_ext.data();
+   T* pout   = out_ext.data();
+ 
+   stride_type s_in  = in_ext.stride(0);
+   stride_type s_out = out_ext.stride(0);
+   stride_type s_coeff = coeff_.block().impl_stride(1, 0);
+ 
+   assert( Max_kernel_length<T>::value != 0 );
+   if ( (M <= Max_kernel_length<T>::value) && (decimation_ == 1) ) 
+   {
+     // SAL only does the minimum convolution
+     if (Supp == support_full)
+     {
+       impl::sal::conv( pcoeff_, s_coeff, M, 
+                        pin, s_in, N, 
+                        pout + (M - 1) * s_out, s_out );
+ 
+       // fill in missing values
+       for ( int n = 0; n < M - 1; ++n )
+       {
+         pout[n * s_out] = T();
+         for ( int k = 0; k < M; ++k )
+           if ( (n >= k) && (n - k < N) )
+             pout[n * s_out] += pcoeff_[k * s_coeff] * pin[(n - k) * s_in];
+       }
+       for ( int n = N; n < N + M - 1; ++n )
+       {
+         pout[n * s_out] = T();
+         for ( int k = 0; k < M; ++k )
+           if ( (n >= k) && (n - k < N) )
+             pout[n * s_out] += pcoeff_[k * s_coeff] * pin[(n - k) * s_in];
+       }
+     }
+     else if (Supp == support_same)
+     {
+       impl::sal::conv( pcoeff_, s_coeff, M, 
+                        pin, s_in, N - (M - M/2), 
+                        pout + (M - M/2 - 1) * s_out, s_out );
+ 
+       // fill in missing values
+       for ( int n = 0; n < M/2; ++n )
+       {
+         pout[n * s_out] = T();
+         for ( int k = 0; k < M; ++k )
+           if ( (n + M/2 >= k) && (n + M/2 - k < N) )
+             pout[n * s_out] += pcoeff_[k * s_coeff] * pin[(n + M/2 - k) * s_in];
+       }
+       for ( int n = N - (M - M/2); n < N; ++n )
+       {
+         pout[n * s_out] = T();
+         for ( int k = 0; k < M; ++k )
+           if ( (n + M/2 >= k) && (n + M/2 - k < N) )
+             pout[n * s_out] += pcoeff_[k * s_coeff] * pin[(n + M/2 - k) * s_in];
+       }
+     }
+     else // (Supp == support_min)
+     {
+       impl::sal::conv( pcoeff_, s_coeff, M, 
+                        pin, s_in, N - (M - 1), 
+                        pout, s_out );
+     }
+   }
+   else // ( M > Max_kernel_length<T> )
+   {
+     if (Supp == support_full)
+     {
+       pm_non_opt_calls_++;
+       conv_full<T>(pcoeff_, M, pin, N, s_in, pout, P, s_out, decimation_);
+     }
+     else if (Supp == support_same)
+     {
+       pm_non_opt_calls_++;
+       conv_same<T>(pcoeff_, M, pin, N, s_in, pout, P, s_out, decimation_);
+     }
+     else // (Supp == support_min)
+     {
+       pm_non_opt_calls_++;
+       conv_min<T>(pcoeff_, M, pin, N, s_in, pout, P, s_out, decimation_);
+     }
+   }
+ 
+ }
+ 
+ 
+ 
+ // Perform 2-D convolution.
+ 
+ template <template <typename, typename> class ConstViewT,
+ 	  symmetry_type                       Symm,
+ 	  support_region_type                 Supp,
+ 	  typename                            T,
+ 	  unsigned                            n_times,
+           alg_hint_type                       a_hint>
+ template <typename Block0,
+ 	  typename Block1>
+ void
+ Convolution_impl<ConstViewT, Symm, Supp, T, n_times, a_hint, Mercury_sal_tag>::
+ convolve(
+   const_Matrix<T, Block0> in,
+   Matrix<T, Block1>       out)
+ VSIP_NOTHROW
+ {
+   VSIP_IMPL_THROW(vsip::impl::unimplemented(
+ 		    "Convolution_impl<... Mercury_sal_tag> does not support Matrix"));
+ }
+ 
+ } // namespace vsip::impl
+ 
+ } // namespace vsip
+ 
+ #endif // VSIP_IMPL_SIGNAL_CONV_EXT_HPP
Index: src/vsip/impl/signal-conv.hpp
===================================================================
RCS file: /home/cvs/Repository/vpp/src/vsip/impl/signal-conv.hpp,v
retrieving revision 1.10
diff -c -p -r1.10 signal-conv.hpp
*** src/vsip/impl/signal-conv.hpp	26 Sep 2005 20:11:05 -0000	1.10
--- src/vsip/impl/signal-conv.hpp	28 Nov 2005 07:59:21 -0000
***************
*** 27,32 ****
--- 27,36 ----
  #  include <vsip/impl/signal-conv-ipp.hpp>
  #endif
  
+ #if VSIP_IMPL_HAVE_SAL
+ #  include <vsip/impl/signal-conv-sal.hpp>
+ #endif
+ 
  
  
  /***********************************************************************
*************** namespace vsip
*** 39,50 ****
  namespace impl
  {
  
  template <typename T>
  struct Choose_conv_impl
  {
    typedef typename
    ITE_Type<Is_conv_impl_avail<Intel_ipp_tag, T>::value,
! 	   As_type<Intel_ipp_tag>, As_type<Generic_tag> >::type type;
  };
  
  } // namespace impl
--- 43,59 ----
  namespace impl
  {
  
+ 
  template <typename T>
  struct Choose_conv_impl
  {
    typedef typename
    ITE_Type<Is_conv_impl_avail<Intel_ipp_tag, T>::value,
! 	   As_type<Intel_ipp_tag>, 
!            ITE_Type<Is_conv_impl_avail<Mercury_sal_tag, T>::value,
!                     As_type<Mercury_sal_tag>, 
!                     As_type<Generic_tag> >
!           >::type type;
  };
  
  } // namespace impl
Index: tests/convolution.cpp
===================================================================
RCS file: /home/cvs/Repository/vpp/tests/convolution.cpp,v
retrieving revision 1.6
diff -c -p -r1.6 convolution.cpp
*** tests/convolution.cpp	5 Oct 2005 11:41:03 -0000	1.6
--- tests/convolution.cpp	28 Nov 2005 07:59:21 -0000
***************
*** 10,16 ****
    Included Files
  ***********************************************************************/
  
- #include <iostream>
  #include <cassert>
  
  #include <vsip/vector.hpp>
--- 10,15 ----
*************** test_conv_nonsym(
*** 134,139 ****
--- 133,212 ----
  
  
  
+ /// Test convolution for non-unit strides.
+ 
+ template <typename            T,
+           support_region_type support>
+ void
+ test_conv_nonunit_stride(
+   length_type N,
+   length_type M,
+   stride_type stride)
+ {
+   symmetry_type const         symmetry = nonsym;
+   length_type const           D = 1; // decimation
+ 
+   typedef Convolution<const_Vector, symmetry, support, T> conv_type;
+   typedef typename Vector<T>::subview_type vector_subview_type;
+ 
+   length_type const P = expected_output_size(support, M, N, D);
+ 
+   Vector<T> kernel(M, T());
+ 
+   Rand<T> rgen(0);
+   kernel = rgen.randu(M);
+ 
+   conv_type conv(kernel, Domain<1>(N), D);
+ 
+   assert(conv.symmetry() == symmetry);
+   assert(conv.support()  == support);
+ 
+   assert(conv.kernel_size().size()  == M);
+   assert(conv.filter_order().size() == M);
+   assert(conv.input_size().size()   == N);
+   assert(conv.output_size().size()  == P);
+ 
+ 
+   Vector<T> in_base(N * stride);
+   Vector<T> out_base(P * stride, T(100));
+ 
+   vector_subview_type  in =  in_base( Domain<1>(0, stride, N) );
+   vector_subview_type out = out_base( Domain<1>(0, stride, P) );
+ 
+   for (index_type i=0; i<N; ++i)
+     in(i) = T(i);
+ 
+   conv(in, out);
+ 
+ 
+   int shift = expected_shift(support, M, D);
+   Vector<T> sub(M);
+ 
+   // Check result
+   for (index_type i=0; i<P; ++i)
+   {
+     sub = T();
+     index_type pos = i*D + shift;
+ 
+     if (pos+1 < M)
+       sub(Domain<1>(0, 1, pos+1)) = in(Domain<1>(pos, -1, pos+1));
+     else if (pos >= N)
+     {
+       index_type start = pos - N + 1;
+       sub(Domain<1>(start, 1, M-start)) = in(Domain<1>(N-1, -1, M-start));
+     }
+     else
+       sub = in(Domain<1>(pos, -1, M));
+       
+     T val = out(i);
+     T chk = dot(kernel, sub);
+ 
+     assert(equal(val, chk));
+   }
+ }
+ 
+ 
+ 
  /// Test general 1-D convolution.
  
  template <typename            T,
*************** cases_nonsym(length_type size)
*** 249,254 ****
--- 322,346 ----
  
  
  
+ // Run a set of convolutions for given type and size
+ //   (using vectors with strides other than one).
+ 
+ template <typename T>
+ void
+ cases_nonunit_stride(length_type size)
+ {
+   test_conv_nonunit_stride<T, support_min>(size, 4, 3);
+   test_conv_nonunit_stride<T, support_min>(size, 5, 2);
+ 
+   test_conv_nonunit_stride<T, support_full>(size, 4, 3);
+   test_conv_nonunit_stride<T, support_full>(size, 5, 2);
+ 
+   test_conv_nonunit_stride<T, support_same>(size, 4, 3);
+   test_conv_nonunit_stride<T, support_same>(size, 5, 2);
+ }
+ 
+ 
+ 
  // Run a set of convolutions for given type, symmetry, input size, coeff size
  // and decmiation.
  
*************** cases(bool rand)
*** 326,331 ****
--- 418,425 ----
      cases_nonsym<T>(size+3);
      cases_nonsym<T>(2*size);
  
+     cases_nonunit_stride<T>(size);
+ 
      cases_conv<T, nonsym>(size,      8,  1, rand);
      cases_conv<T, nonsym>(2*size,    7,  2, rand);
      cases_conv<T, nonsym>(size+4,    6,  3, rand);
