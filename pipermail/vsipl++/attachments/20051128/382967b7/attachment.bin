
Index: src/vsip/impl/matvec.hpp
===================================================================
RCS file: /home/cvs/Repository/vpp/src/vsip/impl/matvec.hpp,v
retrieving revision 1.7
diff -c -p -r1.7 matvec.hpp
*** src/vsip/impl/matvec.hpp	15 Nov 2005 21:01:27 -0000	1.7
--- src/vsip/impl/matvec.hpp	29 Nov 2005 04:18:54 -0000
*************** cumsum(
*** 485,490 ****
--- 485,531 ----
  }
  
  
+ template <typename T0,
+           typename T1,
+           typename T2,
+           typename T3,
+           typename Block0,
+           typename Block1>
+ T1
+ modulate(
+   const_Vector<T0, Block0> v,
+   T1 nu,
+   T2 phi,
+   Vector<complex<T3>, Block1> w)
+     VSIP_NOTHROW
+ {
+   // Requires: The only specializations which must be supported are those 
+   // having T0, T1, T2, and T3 all scalar f or alternatively T0 the same 
+   // as cscalar f and T1, T2, and T3 all scalar f.
+ 
+   assert(v.size() == w.size());
+   assert((Type_equal<typename impl::Scalar_of<T0>::type, T3>::value));
+   assert((Type_equal<T1, T3>::value));
+   assert((Type_equal<T2, T3>::value));
+ 
+   // Effects: For 0 <= i < v.size(), w.get(i) has a value equaling 
+   // the product of v.get(i) and the exponential of the product of 
+   // j (sqrt(-1)) and i * nu + phi
+ 
+   for ( index_type i = v.size(); i-- > 0; )
+   {
+     complex<T3> phase( 0, i * nu + phi );
+     w.put(i, v.get(i) * exp(phase));
+   }
+ 
+   // Returns: v.size() * nu + phi (the phase needed for processing
+   // a series frame by frame)
+ 
+   return v.size() * nu + phi;
+ }
+ 
+ 
+ 
  } // namespace impl
  
  
*************** cumsum(
*** 667,672 ****
--- 708,730 ----
    impl::cumsum<d>(v, w);
  }
  
+ /// modulate
+ template <typename T0,
+           typename T1,
+           typename T2,
+           typename T3,
+           typename Block0,
+           typename Block1>
+ T1
+ modulate(
+   const_Vector<T0, Block0> v,
+   T1 nu,
+   T2 phi,
+   Vector<complex<T3>, Block1> w)
+     VSIP_NOTHROW
+ {
+   return impl::modulate(v, nu, phi, w);
+ }
  
  } // namespace vsip
  
Index: tests/matvec.cpp
===================================================================
RCS file: /home/cvs/Repository/vpp/tests/matvec.cpp,v
retrieving revision 1.4
diff -c -p -r1.4 matvec.cpp
*** tests/matvec.cpp	11 Nov 2005 00:07:59 -0000	1.4
--- tests/matvec.cpp	29 Nov 2005 04:18:55 -0000
*************** using namespace vsip;
*** 31,36 ****
--- 31,94 ----
  ***********************************************************************/
  
  
+ // Error metric between two Vectors
+ 
+ template <typename T1,
+ 	  typename T2,
+ 	  typename Block1,
+ 	  typename Block2>
+ double
+ error_db(
+   const_Vector<T1, Block1> v1,
+   const_Vector<T2, Block2> v2)
+ {
+   double refmax = 0.0;
+   double maxsum = -250;
+   double sum;
+ 
+   Index<1> idx;
+ 
+   refmax = maxval(magsq(v1), idx);
+ 
+   for (index_type i=0; i<v1.size(); ++i)
+   {
+     double val = magsq(v1.get(i) - v2.get(i));
+ 
+     if (val < 1.e-20)
+       sum = -201.;
+     else
+       sum = 10.0 * log10(val/(2.0*refmax));
+ 
+     if (sum > maxsum)
+       maxsum = sum;
+   }
+ 
+   return maxsum;
+ }
+ 
+ 
+ // Error metric between two Matrices
+ 
+ template <typename T1,
+ 	  typename T2,
+ 	  typename Block1,
+ 	  typename Block2>
+ double
+ error_db(
+   const_Matrix<T1, Block1> v1,
+   const_Matrix<T2, Block2> v2)
+ {
+   double maxsum = -250;
+   for (unsigned i = 0; i < v1.size(0); ++i)
+   {
+     double sum = error_db(v1.row(i), v2.row(i));
+     if (sum > maxsum)
+       maxsum = sum;
+   }
+   return maxsum;
+ }
+ 
+ 
  template <typename T>
  void
  Check_gem_results( Matrix<T> actual, Matrix<T> expected )
*************** Test_cumsum()
*** 336,341 ****
--- 394,427 ----
  }  
  
  
+ template <typename T0,
+           typename T3>
+ void
+ Test_modulate( const length_type m )
+ {
+   index_type rows = 2;
+   Matrix<T0> v(rows, m);
+   Matrix<complex<T3> > w(rows, m, complex<float>());
+   Matrix<complex<T3> > r(rows, m);
+ 
+   T3 nu = M_PI / 2;
+   T3 phi = 0.123;
+   T3 phase = phi;
+ 
+   randm(v);
+ 
+   for ( index_type i = 0; i < rows; ++i )
+   {
+     phase = vsip::modulate(v.row(i), nu, phase, w.row(i));
+ 
+     for ( index_type j = 0; j < m; ++j )
+       r.put( i, j, v.get(i, j) * exp(complex<T3>(0, (i * m + j) * nu + phi)) );
+   }
+ 
+   assert( error_db(r, w) < -100 );
+ }
+ 
+ 
  template <typename T>
  void
  Test_outer( T alpha, const length_type m, const length_type n )
*************** Test_outer( T alpha, const length_type m
*** 364,369 ****
--- 450,463 ----
  }
  
  
+ template <typename T>
+ void
+ modulate_cases( const length_type m )
+ {
+   Test_modulate<T,          T>( m );
+   Test_modulate<complex<T>, T>( m );
+ }
+ 
  
  
  /***********************************************************************
*************** main(int argc, char** argv)
*** 411,416 ****
--- 505,514 ----
    
    Test_cumsum();
  
+   modulate_cases<float>(10);
+   modulate_cases<double>(32);
+   modulate_cases<long double>(16);
+ 
    Test_outer<float>( static_cast<float>(M_PI), 3, 3 );
    Test_outer<float>( static_cast<float>(M_PI), 5, 7 );
    Test_outer<float>( static_cast<float>(M_PI), 7, 5 );
