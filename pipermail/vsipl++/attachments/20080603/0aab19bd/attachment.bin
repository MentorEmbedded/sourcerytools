Index: src/vsip/core/signal/freqswap.hpp
===================================================================
--- src/vsip/core/signal/freqswap.hpp	(revision 210366)
+++ src/vsip/core/signal/freqswap.hpp	(working copy)
@@ -16,6 +16,10 @@
 #include <vsip/support.hpp>
 #include <vsip/vector.hpp>
 #include <vsip/matrix.hpp>
+#include <vsip/core/domain_utils.hpp>
+#ifndef VSIP_IMPL_REF_IMPL
+# include <vsip/opt/expr/return_block.hpp>
+#endif
 
 
 /***********************************************************************
@@ -28,133 +32,222 @@
 namespace impl
 {
 
-template <typename T,
-          typename Block>
-const_Vector<T, Block> 
-freqswap( const_Vector<T, Block> a )
+template <typename B, dimension_type D = B::dim> class Freqswap_functor;
+
+template <typename B>
+class Freqswap_functor<B, 1>
 {
-  typedef Vector<T, Block> return_type;
-  return_type r( a.size() );
+public:
 
-  // Returns: If const_View is const_Vector, a const_Vector with the
-  // two halves of source swapped.  Given an odd-length, the left 
-  // half has one more value than the right-half.
+  typedef typename B::map_type map_type;
 
-  // equiv. to r[i] = a[(M/2 + i) mod M],  where i = 0 --> M - 1
+  typedef Freqswap_functor<typename Distributed_local_block<B>::type, 1>
+		local_type;
 
-  length_type const M = a.size();
+  Freqswap_functor(B const &in) : in_(in) {}
 
-  index_type ii = M / 2;  // destination index
-  index_type ia = M % 2;  // adjustment to get source index
-  for ( index_type i = 0; i < M / 2; i++ )
+  length_type size(dimension_type block_dim, dimension_type d) const
   {
-    r.put( ii, a.get( i       ) );
-    r.put(  i, a.get( ii + ia ) );
-    ++ii;
+    assert(block_dim == 1);
+    return in_.size(block_dim, d);
   }
+  length_type size() const { return in_.size();}
 
-  // if odd, fill in the last row/column(s)
-  if ( M % 2 )
+  template <typename B1>
+  void apply(B1 &out) const
   {
-    index_type i = M / 2;
-    index_type ii = M - 1;
-    r.put( ii, a.get( i ) );
+    // equiv. to r[i] = a[(M/2 + i) mod M],  where i = 0 --> M - 1
+
+    length_type const M = in_.size();
+
+    index_type const ia = M % 2;  // adjustment to get source index
+    for (index_type i = 0, ii = M / 2; i < M / 2; ++i, ++ii)
+    {
+      // Be careful to allow 'out' to alias 'in'
+      typename B::value_type tmp = in_.get(ii + ia);
+      out.put(ii, in_.get(i));
+      out.put(i, tmp);
+    }
+
+    // if odd, fill in the last row/column(s)
+    if (ia)
+    {
+      index_type i = M / 2;
+      index_type ii = M - 1;
+      out.put(ii, in_.get(i));
+    }
   }
 
-  return r;
-}
+  map_type const& map() const { return in_.map();}
 
+private:
+  B const &in_;
+};
 
-
-template <typename T,
-          typename Block>
-const_Matrix<T, Block> 
-freqswap( const_Matrix<T, Block> a )
+template <typename B>
+class Freqswap_functor<B, 2>
 {
-  typedef Matrix<T, Block> return_type;
-  return_type r( a.size(0), a.size(1) );
+public:
 
-  // Returns: If const_View is const_Matrix, a const_Matrix with the 
-  // upper left and lower right quadrants of source swapped. Given an 
-  // odd-length, the left half has one more value than the right-half.
+  typedef typename B::map_type map_type;
 
-  // equiv. to r[i,j] = a[(M/2 + i) mod M,(N/2 + i) mod N], 
-  //   where i = 0 --> M - 1 and j = 0 --> N - 1
+  typedef Freqswap_functor<typename Distributed_local_block<B>::type, 2>
+		local_type;
 
-  length_type const M = a.size(0);
-  length_type const N = a.size(1);
+  Freqswap_functor(B const & in) : in_(in) {}
 
-  index_type ii = M / 2;  // destination index
-  index_type ia = M % 2;  // adjustment to get source index
-  for ( index_type i = 0; i < M / 2; i++ )
+  length_type size(dimension_type block_dim, dimension_type d) const
   {
-    index_type jj = N / 2;
-    index_type ja = N % 2;
-    for ( index_type j = 0; j < N / 2; j++ )
-    {
-      r.put( ii, jj, a.get( i      , j       ) );
-      r.put(  i,  j, a.get( ii + ia, jj + ja ) );
-      r.put( ii,  j, a.get( i      , jj + ja ) );
-      r.put(  i, jj, a.get( ii + ia, j       ) );
-      ++jj;
-    }
-    ++ii;
+    assert(block_dim == 2);
+    return in_.size(block_dim, d);
   }
+  length_type size() const { return in_.size();}
 
-  // if odd, fill in the last row/column(s)
-  if ( M % 2 )
+  template <typename B1>
+  void apply(B1 & out) const
   {
-    index_type i = M / 2;
-    index_type ii = M - 1;
-    index_type jj = N / 2;
-    index_type ja = N % 2;
-    for ( index_type j = 0; j < N / 2; j++ )
+    // equiv. to out[i,j] = in[(M/2 + i) mod M,(N/2 + i) mod N], 
+    //   where i = 0 --> M - 1 and j = 0 --> N - 1
+
+    length_type const M = in_.size(2, 0);
+    length_type const N = in_.size(2, 1);
+
+    index_type const ia = M % 2;  // adjustment to get source index
+    for (index_type i = 0, ii = M / 2; i < M / 2; ++i, ++ii)
     {
-      r.put( ii, jj, a.get( i, j       ) );
-      r.put( ii,  j, a.get( i, jj + ja ) );
-      ++jj;
+      index_type const ja = N % 2;
+      for (index_type j = 0, jj = N / 2; j < N / 2; ++j, ++jj)
+      {
+        typename B::value_type tmp = in_.get(ii + ia, jj + ja);
+        out.put(ii, jj, in_.get(i, j));
+        out.put(i, j, tmp);
+        tmp = in_.get(ii + ia, j);
+        out.put(ii, j, in_.get(i, jj + ja));
+        out.put(i, jj, tmp);
+      }
     }
-  }
-  if ( N % 2 )
-  {
-    index_type j = N / 2;
-    index_type jj = N - 1;
-    index_type ii = M / 2;
-    index_type ia = M % 2;
-    for ( index_type i = 0; i < M / 2; i++ )
+
+    // if odd, fill in the last row/column(s)
+    if (ia)
     {
-      r.put( ii, jj, a.get( i      , j ) );
-      r.put(  i, jj, a.get( ii + ia, j ) );
-      ++ii;
+      index_type i = M / 2;
+      index_type ii = M - 1;
+      index_type ja = N % 2;
+      for (index_type j = 0, jj = N / 2; j < N / 2; ++j, ++jj)
+      {
+        out.put(ii, jj, in_.get(i, j));
+        out.put(ii,  j, in_.get(i,jj + ja));
+      }
     }
+    if (N % 2)
+    {
+      index_type j = N / 2;
+      index_type jj = N - 1;
+      index_type ia = M % 2;
+      for (index_type i = 0, ii = M / 2; i < M / 2; ++i, ++ii)
+      {
+        out.put(ii, jj, in_.get(i      , j));
+        out.put( i, jj, in_.get(ii + ia, j));
+      }
+    }
+    if (M % 2 && N % 2) out.put(M - 1, N - 1, in_.get(M / 2, N / 2));
   }
-  if ( (M % 2) && (N % 2) )
-    r.put( M - 1, N - 1, a.get( M / 2, N / 2 ) );
 
-  return r;
+  map_type const& map() const { return in_.map();}
+
+private:
+  B const &in_;
+};
+
+template <typename B>
+struct Freqswap
+{
+#ifndef VSIP_IMPL_REF_IMPL
+  typedef Return_expr_block<B::dim,
+                            typename B::value_type,
+                            Freqswap_functor<B> >
+    block_type;
+  typedef typename B::value_type value_type;
+  typedef typename View_of_dim<B::dim, value_type, block_type const>::type view_type;
+#else
+  typedef Dense<B::dim, typename B::value_type> block_type;
+  typedef typename B::value_type value_type;
+  typedef typename View_of_dim<B::dim, value_type, block_type>::type view_type;
+#endif
+
+  static view_type 
+  create(typename View_of_dim<B::dim, value_type, B>::const_type v)
+  {
+    Freqswap_functor<B> func(v.block());
+#ifndef VSIP_IMPL_REF_IMPL
+    block_type return_block(func);
+    return view_type(return_block);
+#else
+    view_type result(v);
+    func.apply(result.block());
+    return result;
+#endif
+  }
+};
+
+template <typename CombineT, typename BlockT>
+struct Combine_return_type<CombineT, Freqswap_functor<BlockT> const>
+{
+  typedef Freqswap_functor<BlockT> const tree_type;
+  typedef tree_type type;
+};
+
+template <typename CombineT, typename BlockT>
+struct Combine_return_type<CombineT, Freqswap_functor<BlockT> >
+{
+  typedef Freqswap_functor<BlockT> const tree_type;
+  typedef tree_type type;
+};
+
+template <typename CombineT, typename BlockT>
+typename Combine_return_type<CombineT, Freqswap_functor<BlockT> >::type
+apply_combine(CombineT const& combine, Freqswap_functor<BlockT> const& rf)
+{
+  typedef 
+    typename Combine_return_type<CombineT, Freqswap_functor<BlockT> >::type
+    rf_type;
+
+  return rf_type(apply_combine(combine, rf.in_block()),
+		 rf.backend(), rf.workspace());
 }
 
-} // namespace impl
+template <typename VisitorT, typename BlockT>
+void
+apply_leaf(VisitorT const& visitor, Freqswap_functor<BlockT> const& rf)
+{
+  apply_leaf(visitor, rf.in_block());
+}
 
+template <dimension_type MapDim, typename MapT, typename BlockT>
+struct Is_par_same_map<MapDim, MapT, Freqswap_functor<BlockT> const>
+{
+  typedef Freqswap_functor<BlockT> const rf_type;
 
+  static bool value(MapT const& map, rf_type& rf)
+  {
+    return Is_par_same_map<MapDim, MapT, BlockT>::value(map, rf.in_block());
+  }
+};
 
+} // namespace impl
 
 /// Swaps halves of a vector, or quadrants of a matrix, to remap zero 
 /// frequencies from the origin to the middle.
 
 template <template <typename, typename> class const_View,
           typename T,
-          typename Block>
-const_View<T, Block>
-freqswap(const_View<T, Block> source)
-    VSIP_NOTHROW
+          typename B>
+typename impl::Freqswap<B>::view_type
+freqswap(const_View<T, B> in) VSIP_NOTHROW
 {
-  return impl::freqswap( source );
+  return impl::Freqswap<B>::create(in);
 }
 
-
-
-
 } // namespace vsip
 
 #endif // VSIP_CORE_SIGNAL_FREQSWAP_HPP
