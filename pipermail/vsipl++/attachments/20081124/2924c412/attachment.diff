Index: src/vsip/core/reductions/reductions.hpp
===================================================================
--- src/vsip/core/reductions/reductions.hpp	(revision 229176)
+++ src/vsip/core/reductions/reductions.hpp	(working copy)
@@ -21,17 +21,17 @@
 #include <vsip/tensor.hpp>
 #include <vsip/core/reductions/functors.hpp>
 #include <vsip/core/parallel/services.hpp>
-#include <vsip/core/general_evaluator.hpp>
 #include <vsip/core/impl_tags.hpp>
-#if VSIP_IMPL_HAVE_CVSIP
-#  include <vsip/core/cvsip/eval_reductions.hpp>
-#endif
+#include <vsip/core/dispatch.hpp>
 #if !VSIP_IMPL_REF_IMPL
-#  include <vsip/opt/general_dispatch.hpp>
+#  include <vsip/opt/dispatch.hpp>
 #  ifdef VSIP_IMPL_HAVE_SAL
 #    include <vsip/opt/sal/eval_reductions.hpp>
 #  endif
 #endif
+#if VSIP_IMPL_HAVE_CVSIP
+#  include <vsip/core/cvsip/eval_reductions.hpp>
+#endif
 
 
 
@@ -45,17 +45,28 @@
 namespace impl
 {
 
+namespace dispatcher
+{
+
 /***********************************************************************
   Generic evaluators.
 ***********************************************************************/
 
-// Generic evaluator for vector reductions.
+#ifndef VSIP_IMPL_REF_IMPL
+template<template <typename> class ReduceT>
+struct List<Op_reduce<ReduceT> >
+{
+  typedef Make_type_list<Cvsip_tag, Mercury_sal_tag, Generic_tag>::type type;
+};
+#endif
 
+
+/// Generic evaluator for vector reductions.
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, row1_type, Int_type<1> >, Generic_tag>
+struct Evaluator<Op_reduce<ReduceT>, Generic_tag, 
+                 void(T&, Block const&, row1_type, Int_type<1>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, row1_type, Int_type<1>)
@@ -79,13 +90,12 @@
 };
 
 
-
+/// Generic evaluator for matrix reductions (tuple<0, 1, 2>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, row2_type, Int_type<2> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce<ReduceT>, Generic_tag,
+                 void(T&, Block const&, row2_type, Int_type<2>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, row2_type, Int_type<2>)
@@ -112,13 +122,12 @@
 };
 
 
-
+/// Generic evaluator for matrix reductions (tuple<2, 1, 0>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, col2_type, Int_type<2> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce<ReduceT>, Generic_tag,
+                 void(T&, Block const&, col2_type, Int_type<2>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, col2_type, Int_type<2>)
@@ -145,13 +154,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<0, 1, 2>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, tuple<0, 1, 2>, Int_type<3> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce<ReduceT>, Generic_tag,
+                 void(T&, Block const&, tuple<0, 1, 2>, Int_type<3>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, tuple<0, 1, 2>, Int_type<3>)
@@ -179,13 +187,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<0, 2, 1>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, tuple<0, 2, 1>, Int_type<3> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce<ReduceT>, Generic_tag,
+                 void(T&, Block const&, tuple<0, 2, 1>, Int_type<3>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, tuple<0, 2, 1>, Int_type<3>)
@@ -213,13 +220,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<1, 0, 2>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, tuple<1, 0, 2>, Int_type<3> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce<ReduceT>, Generic_tag,
+                 void(T&, Block const&, tuple<1, 0, 2>, Int_type<3>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, tuple<1, 0, 2>, Int_type<3>)
@@ -247,13 +253,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<1, 2, 0>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, tuple<1, 2, 0>, Int_type<3> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce<ReduceT>, Generic_tag,
+                 void(T&, Block const&, tuple<1, 2, 0>, Int_type<3>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, tuple<1, 2, 0>, Int_type<3>)
@@ -281,13 +286,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<2, 0, 1>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, tuple<2, 0, 1>, Int_type<3> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce<ReduceT>, Generic_tag,
+                 void(T&, Block const&, tuple<2, 0, 1>, Int_type<3>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, tuple<2, 0, 1>, Int_type<3>)
@@ -315,13 +319,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<2, 1, 0>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, tuple<2, 1, 0>, Int_type<3> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce<ReduceT>, Generic_tag,
+                 void(T&, Block const&, tuple<2, 1, 0>, Int_type<3>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, tuple<2, 1, 0>, Int_type<3>)
@@ -371,12 +374,13 @@
   { return true; }
 };
 
+
 template <typename                  T,
 	  typename                  Block,
 	  typename                  OrderT,
 	  int                       Dim>
-struct Evaluator<Op_reduce<Mean_value>, T,
-		 Op_list_3<Block const&, OrderT, Int_type<Dim> >, Parallel_tag>
+struct Evaluator<Op_reduce<Mean_value>, Parallel_tag,
+                 void(T&, Block const&, OrderT, Int_type<Dim>)>
   : Par_reduction_eval_base<Mean_value, T, Block, OrderT, Dim>
 {
   static void exec(T& r, Block const& a, OrderT, Int_type<Dim>)
@@ -389,14 +393,12 @@
     typedef Mean_value<VT>                                      reduce_type;
     typedef typename Block::map_type                            map_type;
 
-    impl::General_dispatch<
-		impl::Op_reduce<Sum_value>,
-		typename Sum_value<VT>::result_type,
-		impl::Op_list_3<local_block_type const&,
-		                order_type,
-		                dim_type>,
-                typename Make_type_list<Mercury_sal_tag, Generic_tag>::type>
-	::exec(l_r, get_local_block(a), order_type(), dim_type());
+    dispatch<Op_reduce<Sum_value>, void,
+             typename Sum_value<VT>::result_type&,
+             local_block_type const&,
+             order_type,
+             dim_type>
+      (l_r, get_local_block(a), order_type(), dim_type());
 
     if (!Type_equal<map_type, Global_map<Block::dim> >::value)
 	r = a.map().impl_comm().allreduce(reduce_type::rtype, l_r);
@@ -413,8 +415,8 @@
 	  typename                  Block,
 	  typename                  OrderT,
 	  int                       Dim>
-struct Evaluator<Op_reduce<Mean_magsq_value>, T,
-		 Op_list_3<Block const&, OrderT, Int_type<Dim> >, Parallel_tag>
+struct Evaluator<Op_reduce<Mean_magsq_value>, Parallel_tag,
+                 void(T&, Block const&, OrderT, Int_type<Dim>)>
   : Par_reduction_eval_base<Mean_magsq_value, T, Block, OrderT, Dim>
 {
   static void exec(T& r, Block const& a, OrderT, Int_type<Dim>)
@@ -427,14 +429,12 @@
     typedef Mean_magsq_value<VT>                                reduce_type;
     typedef typename Block::map_type                            map_type;
 
-    impl::General_dispatch<
-		impl::Op_reduce<Sum_magsq_value>,
-		typename Sum_magsq_value<VT>::result_type,
-		impl::Op_list_3<local_block_type const&,
-		                order_type,
-		                dim_type>,
-                typename Make_type_list<Mercury_sal_tag, Generic_tag>::type>
-	::exec(l_r, get_local_block(a), order_type(), dim_type());
+    dispatch<Op_reduce<Sum_magsq_value>, void,
+             typename Sum_magsq_value<VT>::result_type&,
+             local_block_type const&,
+             order_type,
+             dim_type>
+      (l_r, get_local_block(a), order_type(), dim_type());
 
     if (!Type_equal<map_type, Global_map<Block::dim> >::value)
       r = a.map().impl_comm().allreduce(reduce_type::rtype, l_r);
@@ -446,14 +446,13 @@
 };
 
 
-
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block,
 	  typename                  OrderT,
 	  int                       Dim>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, OrderT, Int_type<Dim> >, Parallel_tag>
+struct Evaluator<Op_reduce<ReduceT>, Parallel_tag, 
+                 void(T&, Block const&, OrderT, Int_type<Dim>)>
   : Par_reduction_eval_base<ReduceT, T, Block, OrderT, Dim>
 {
   static void exec(T& r, Block const& a, OrderT, Int_type<Dim>)
@@ -466,14 +465,12 @@
     typedef ReduceT<VT>                                         reduce_type;
     typedef typename Block::map_type                            map_type;
 
-    impl::General_dispatch<
-		impl::Op_reduce<ReduceT>,
-		typename ReduceT<VT>::result_type,
-		impl::Op_list_3<local_block_type const&,
-		                order_type,
-		                dim_type>,
-                typename Make_type_list<Mercury_sal_tag, Generic_tag>::type>
-	::exec(l_r, get_local_block(a), order_type(), dim_type());
+    dispatch<Op_reduce<ReduceT>, void,
+             typename ReduceT<VT>::result_type&,
+	     local_block_type const&,
+             order_type,
+             dim_type>
+      (l_r, get_local_block(a), order_type(), dim_type());
 
     if (!Type_equal<map_type, Global_map<Block::dim> >::value)
       r = a.map().impl_comm().allreduce(ReduceT<T>::rtype, l_r);
@@ -483,38 +480,36 @@
 };
 #endif
 
+} // namespace vsip::impl::dispatcher
 
 
+
 template <template <typename> class ReduceT,
 	  typename                  ViewT>
 typename ReduceT<typename ViewT::value_type>::result_type
 reduce(ViewT v)
 {
   typedef typename ViewT::value_type T;
-  typename ReduceT<T>::result_type r;
-
+  typedef typename ReduceT<T>::result_type result_type;
+  typedef typename ViewT::block_type block_type;
   typedef typename Block_layout<typename ViewT::block_type>::order_type
-		order_type;
-  typedef Int_type<ViewT::dim>                   dim_type;
+    order_type;
+  typedef Int_type<ViewT::dim> dim_type;
 
+  result_type r;
+
 #if VSIP_IMPL_REF_IMPL
-  Evaluator<    Op_reduce<ReduceT>,
-                typename ReduceT<T>::result_type,
-		impl::Op_list_3<typename ViewT::block_type const&,
-		                order_type,
-                                Int_type<ViewT::dim> >,
-                Cvsip_tag>
-        ::exec(r, v.block(), order_type(), dim_type());
+  dispatcher::Evaluator<dispatcher::Op_reduce<ReduceT>, Cvsip_tag, 
+    void(result_type&, block_type const&, order_type, dim_type)>::
+    exec(r, v.block(), order_type(), dim_type());
 #else
-  impl::General_dispatch<
-		impl::Op_reduce<ReduceT>,
-		typename ReduceT<T>::result_type,
-		impl::Op_list_3<typename ViewT::block_type const&,
-		                order_type,
-                                Int_type<ViewT::dim> >,
-                typename Make_type_list<Parallel_tag, Cvsip_tag,
-		                        Mercury_sal_tag, Generic_tag>::type>
-        ::exec(r, v.block(), order_type(), dim_type());
+
+  typedef dispatcher::Make_type_list<Parallel_tag, Cvsip_tag, Mercury_sal_tag, 
+    Generic_tag>::type list_type;
+
+  dispatcher::Dispatcher<dispatcher::Op_reduce<ReduceT>, 
+    void(result_type&, block_type const&, order_type, dim_type), list_type>::
+    dispatch(r, v.block(), order_type(), dim_type());
 #endif
 
   return r;
Index: src/vsip/core/reductions/functors.hpp
===================================================================
--- src/vsip/core/reductions/functors.hpp	(revision 229176)
+++ src/vsip/core/reductions/functors.hpp	(working copy)
@@ -36,11 +36,12 @@
 
 // Evaluator OpTag for value reductions.
 
+namespace dispatcher
+{
 template <template <typename> class ReduceT>
 struct Op_reduce;
+}
 
-
-
 template <typename T>
 struct All_true
 {
@@ -248,6 +249,7 @@
   static bool done(accum_type) { return false; }
 };
 
+//} // namespace vsip::impl::dispatcher
 
 
 /***********************************************************************
@@ -256,11 +258,13 @@
 
 // Evaluator OpTag for reductions returning index.
 
+namespace dispatcher
+{
 template <template <typename> class ReduceT>
 struct Op_reduce_idx;
+}
 
 
-
 template <typename T>
 class Max_value
 {
Index: src/vsip/core/reductions/reductions_idx.hpp
===================================================================
--- src/vsip/core/reductions/reductions_idx.hpp	(revision 229176)
+++ src/vsip/core/reductions/reductions_idx.hpp	(working copy)
@@ -20,15 +20,17 @@
 #include <vsip/matrix.hpp>
 #include <vsip/tensor.hpp>
 #include <vsip/core/reductions/functors.hpp>
-#if VSIP_IMPL_HAVE_CVSIP
-#  include <vsip/core/cvsip/eval_reductions_idx.hpp>
-#endif
+#include <vsip/core/dispatch.hpp>
 #if !VSIP_IMPL_REF_IMPL
+#  include <vsip/opt/dispatch.hpp>
 #  include <vsip/opt/reductions/par_reductions.hpp>
 #  ifdef VSIP_IMPL_HAVE_SAL
 #    include <vsip/opt/sal/eval_reductions.hpp>
 #  endif
 #endif
+#if VSIP_IMPL_HAVE_CVSIP
+#  include <vsip/core/cvsip/eval_reductions_idx.hpp>
+#endif
 
 
 
@@ -42,17 +44,29 @@
 namespace impl
 {
 
+namespace dispatcher
+{
+
 /***********************************************************************
   Generic evaluators.
 ***********************************************************************/
 
-// Generic evaluator for vector reductions.
+#ifndef VSIP_IMPL_REF_IMPL
+template<template <typename> class ReduceT>
+struct List<Op_reduce_idx<ReduceT> >
+{
+  typedef Make_type_list<Parallel_tag, Cvsip_tag, Mercury_sal_tag,
+    Generic_tag>::type type;
+};
+#endif
 
+
+/// Generic evaluator for vector reductions.
 template <template <typename> class ReduceT,
-	  typename                  T,
+          typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<1>&, row1_type>, Generic_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Generic_tag,
+                 void(T&, Block const&, Index<1>&, row1_type)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, Index<1>&, row1_type)
@@ -75,14 +89,12 @@
 };
 
 
-
-// Generic evaluator for matrix reductions.
-
+/// Generic evaluator for matrix reductions (tuple<0, 1, 2>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<2>&, row2_type>, Generic_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Generic_tag,
+                 void(T&, Block const&, Index<2>&, row2_type)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, Index<2>&, row2_type)
@@ -112,12 +124,12 @@
 };
 
 
-
+/// Generic evaluator for matrix reductions (tuple<2, 1, 0>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<2>&, col2_type>, Generic_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Generic_tag,
+                 void(T&, Block const&, Index<2>&, col2_type)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, Index<2>&, col2_type)
@@ -147,13 +159,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<0, 1, 2>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<3>&, tuple<0, 1, 2> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Generic_tag,
+                 void(T&, Block const&, Index<3>&, tuple<0, 1, 2>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, Index<3>&, tuple<0, 1, 2>)
@@ -187,13 +198,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<0, 2, 1>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<3>&, tuple<0, 2, 1> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Generic_tag,
+                 void(T&, Block const&, Index<3>&, tuple<0, 2, 1>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, Index<3>&, tuple<0, 2, 1>)
@@ -227,13 +237,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<1, 0, 2>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<3>&, tuple<1, 0, 2> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Generic_tag,
+                 void(T&, Block const&, Index<3>&, tuple<1, 0, 2>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, Index<3>&, tuple<1, 0, 2>)
@@ -267,13 +276,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<1, 2, 0>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<3>&, tuple<1, 2, 0> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Generic_tag,
+                 void(T&, Block const&, Index<3>&, tuple<1, 2, 0>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, Index<3>&, tuple<1, 2, 0>)
@@ -307,13 +315,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<2, 0, 1>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<3>&, tuple<2, 0, 1> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Generic_tag,
+                 void(T&, Block const&, Index<3>&, tuple<2, 0, 1>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, Index<3>&, tuple<2, 0, 1>)
@@ -347,13 +354,12 @@
 };
 
 
-
+/// Generic evaluator for tensor reductions (tuple<2, 1, 0>).
 template <template <typename> class ReduceT,
 	  typename                  T,
 	  typename                  Block>
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<3>&, tuple<2, 1, 0> >,
-		 Generic_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Generic_tag,
+                 void(T&, Block const&, Index<3>&, tuple<2, 1, 0>)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(T&, Block const&, Index<3>&, tuple<2, 1, 0>)
@@ -386,6 +392,7 @@
   }
 };
 
+} // namespace vsip::impl::dispatcher
 
 
 template <template <typename> class ReduceT,
@@ -394,36 +401,29 @@
 reduce_idx(ViewT v, Index<ViewT::dim>& idx)
 {
   typedef typename ViewT::value_type T;
-  typename ReduceT<T>::result_type r;
-
+  typedef typename ReduceT<T>::result_type result_type;
+  typedef typename ViewT::block_type block_type;
+  typedef Index<ViewT::dim> index_type;
   typedef typename Block_layout<typename ViewT::block_type>::order_type
 		order_type;
 
+  result_type r;
+
 #if VSIP_IMPL_REF_IMPL
-  Evaluator<    Op_reduce_idx<ReduceT>,
-		typename ReduceT<T>::result_type,
-		impl::Op_list_3<typename ViewT::block_type const&,
-                                Index<ViewT::dim>&,
-                                order_type>,
-                Cvsip_tag>
-        ::exec(r, v.block(), idx, order_type());
+  dispatcher::Evaluator<dispatcher::Op_reduce_idx<ReduceT>, Cvsip_tag,
+    void(result_type&, block_type const&, index_type&, order_type)>::
+    exec(r, v.block(), idx, order_type());
 #else
-  impl::General_dispatch<
-		impl::Op_reduce_idx<ReduceT>,
-		typename ReduceT<T>::result_type,
-		impl::Op_list_3<typename ViewT::block_type const&,
-                                Index<ViewT::dim>&,
-                                order_type>,
-		typename Make_type_list<Parallel_tag,
-		                        Cvsip_tag, Mercury_sal_tag,
-                                        Generic_tag>::type>
-        ::exec(r, v.block(), idx, order_type());
+
+  dispatch<dispatcher::Op_reduce_idx<ReduceT>, void,
+    result_type&, block_type const&, index_type&, order_type>
+    (r, v.block(), idx, order_type());
 #endif
 
   return r;
 }
 
-} // namespace impl
+} // namespace vsip::impl
 	     
 
 
Index: src/vsip/core/cvsip/eval_reductions_idx.hpp
===================================================================
--- src/vsip/core/cvsip/eval_reductions_idx.hpp	(revision 229176)
+++ src/vsip/core/cvsip/eval_reductions_idx.hpp	(working copy)
@@ -14,12 +14,14 @@
 /***********************************************************************
   Included Files
 ***********************************************************************/
+#include <iostream>
+#include <typeinfo>
 
 extern "C" {
 #include <vsip.h>
 }
 
-#include <vsip/core/general_evaluator.hpp>
+#include <vsip/core/dispatch.hpp>
 #include <vsip/core/impl_tags.hpp>
 #include <vsip/core/coverage.hpp>
 #include <vsip/core/static_assert.hpp>
@@ -136,6 +138,8 @@
 } // namespace vsip::impl::cvsip
 
 
+namespace dispatcher
+{
 
 /***********************************************************************
   Evaluators.
@@ -146,9 +150,8 @@
 	  typename                  Block,
 	  typename                  OrderT,
 	  dimension_type            Dim>
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<Dim>&, OrderT>,
-		 Cvsip_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Cvsip_tag,
+                 void(T&, Block const&, Index<Dim>&, OrderT)>
 {
   typedef typename Block::value_type value_type;
 
@@ -163,13 +166,15 @@
     typedef typename Proper_type_of<Block>::type block_type;
     Ext_data_dist<block_type, SYNC_IN> ext(blk);
     cvsip::View_from_ext<Dim, value_type> view(ext);
-    
+
     r = cvsip::Reduce_idx_class<ReduceT, Dim, value_type>::exec(
 		view.view_.ptr(),
 		idx);
   }
 };
 
+} // namespace vsip::impl::dispatcher
+
 } // namespace vsip::impl
 } // namespace vsip
 
Index: src/vsip/core/cvsip/eval_reductions.hpp
===================================================================
--- src/vsip/core/cvsip/eval_reductions.hpp	(revision 229176)
+++ src/vsip/core/cvsip/eval_reductions.hpp	(working copy)
@@ -22,7 +22,7 @@
 vsip_scalar_vi vsip_vsumval_bl(vsip_vview_bl const* a);
 }
 
-#include <vsip/core/general_evaluator.hpp>
+#include <vsip/core/dispatch.hpp>
 #include <vsip/core/impl_tags.hpp>
 #include <vsip/core/coverage.hpp>
 #include <vsip/core/static_assert.hpp>
@@ -151,14 +151,16 @@
   Evaluators.
 ***********************************************************************/
 
+namespace dispatcher
+{
+
 template <template <typename> class ReduceT,
           typename                  T,
 	  typename                  Block,
 	  typename                  OrderT,
 	  int                       Dim>
-struct Evaluator<Op_reduce<ReduceT>, T,
-		 Op_list_3<Block const&, OrderT, Int_type<Dim> >,
-		 Cvsip_tag>
+struct Evaluator<Op_reduce<ReduceT>, Cvsip_tag,
+                 void(T&, Block const&, OrderT, Int_type<Dim>)>
 {
   typedef typename Block::value_type value_type;
 
@@ -178,6 +180,8 @@
   }
 };
 
+} // namespace vsip::impl::dispatcher
+
 } // namespace vsip::impl
 } // namespace vsip
 
Index: src/vsip/core/general_evaluator.hpp
===================================================================
--- src/vsip/core/general_evaluator.hpp	(revision 229176)
+++ src/vsip/core/general_evaluator.hpp	(working copy)
@@ -1,67 +0,0 @@
-/* Copyright (c) 2005 by CodeSourcery, LLC.  All rights reserved. */
-
-/** @file    vsip/opt/general_dispatch.hpp
-    @author  Jules Bergmann
-    @date    2006-12-07
-    @brief   VSIPL++ Library: Dispatch harness that allows various
-             implementations to be bound to a particular operation.
-*/
-
-#ifndef VSIP_CORE_GENERAL_EVALUATOR_HPP
-#define VSIP_CORE_GENERAL_EVALUATOR_HPP
-
-/***********************************************************************
-  Declarations
-***********************************************************************/
-
-namespace vsip
-{
-namespace impl
-{
-
-// Operation Tags.
-//
-// Each operation (dot-product, matrix-matrix product, etc) has a 
-// unique operation tag.
-
-struct Op_prod_vv_dot;    // vector-vector dot-product
-struct Op_prod_vv_outer;  // vector-vector outer-product
-struct Op_prod_mm;        // matrix-matrix product
-struct Op_prod_mm_conj;   // matrix-matrix conjugate product
-struct Op_prod_mv;        // matrix-vector product
-struct Op_prod_vm;        // vector-matrix product
-struct Op_prod_gemp;      // generalized matrix-matrix product
-
-
-
-// Wrapper class to describe scalar return-type.
-
-template <typename T> struct Return_scalar {};
-
-
-
-// Wrapper classes to capture list of operand types.
-
-template <typename Block1>                  struct Op_list_1 {};
-template <typename Block1, typename Block2> struct Op_list_2 {};
-template <typename T0, typename T1, typename T2> struct Op_list_3 {};
-template <typename T0, typename Block1, 
-          typename Block2, typename T3>     struct Op_list_4 {};
-
-
-
-// General evaluator class.
-
-template <typename OpTag,
-	  typename DstType,
-	  typename SrcType,
-	  typename ImplTag>
-struct Evaluator
-{
-  static bool const ct_valid = false;
-};
-
-} // namespace vsip::impl
-} // namespace vsip
-
-#endif // VSIP_CORE_GENERAL_EVALUATOR_HPP
Index: src/vsip/opt/sal/eval_reductions.hpp
===================================================================
--- src/vsip/opt/sal/eval_reductions.hpp	(revision 229176)
+++ src/vsip/opt/sal/eval_reductions.hpp	(working copy)
@@ -23,7 +23,7 @@
   Included Files
 ***********************************************************************/
 
-#include <vsip/opt/general_dispatch.hpp>
+#include <vsip/opt/dispatch.hpp>
 #include <vsip/core/reductions/functors.hpp>
 #include <vsip/opt/sal/eval_util.hpp>
 #include <vsip/opt/sal/reductions.hpp>
@@ -82,34 +82,36 @@
   Evaluators for reduction functions
 ***********************************************************************/
 
-#define VSIP_IMPL_SAL_REDUCT(OP, SALFCN)				\
-template <typename T,							\
-	  typename Block>						\
-struct Evaluator<Op_reduce<OP>, T,					\
-		 Op_list_3<Block const&, row1_type, Int_type<1> >,	\
-		 Mercury_sal_tag>					\
-{									\
-  typedef typename Block::map_type                        map_type;	\
-  typedef typename sal::Effective_value_type<Block>::type eff_t;	\
-									\
-  static bool const ct_valid = 						\
-    !Is_expr_block<Block>::value &&					\
-     Is_local_map<map_type>::value &&					\
-     sal::Is_reduct_supported<OP, eff_t>::value &&			\
-     Ext_data_cost<Block>::value == 0;					\
-									\
-  static bool rt_valid(T&, Block const&, row1_type, Int_type<1>)	\
-  { return true; }							\
-									\
-  static void exec(T& r, Block const& blk, row1_type, Int_type<1>)	\
-  {									\
-    sal::Ext_wrapper<Block> ext(blk, SYNC_IN);				\
-									\
-    SALFCN(								\
-      typename sal::Ext_wrapper<Block>::sal_type(ext),			\
-      r,								\
-      blk.size());							\
-  }									\
+namespace dispatcher
+{
+
+#define VSIP_IMPL_SAL_REDUCT(OP, SALFCN)                                \
+template <typename T,                                                   \
+          typename Block>                                               \
+struct Evaluator<Op_reduce<OP>, Mercury_sal_tag,                        \
+                 void(T&, Block const&, row1_type, Int_type<1>)>        \
+{                                                                       \
+  typedef typename Block::map_type                        map_type;     \
+  typedef typename sal::Effective_value_type<Block>::type eff_t;        \
+                                                                        \
+  static bool const ct_valid =                                          \
+    !Is_expr_block<Block>::value &&                                     \
+     Is_local_map<map_type>::value &&                                   \
+     sal::Is_reduct_supported<OP, eff_t>::value &&                      \
+     Ext_data_cost<Block>::value == 0;                                  \
+                                                                        \
+  static bool rt_valid(T&, Block const&, row1_type, Int_type<1>)        \
+  { return true; }                                                      \
+                                                                        \
+  static void exec(T& r, Block const& blk, row1_type, Int_type<1>)      \
+  {                                                                     \
+    sal::Ext_wrapper<Block> ext(blk, SYNC_IN);                          \
+                                                                        \
+    SALFCN(                                                             \
+      typename sal::Ext_wrapper<Block>::sal_type(ext),                  \
+      r,                                                                \
+      blk.size());                                                      \
+  }                                                                     \
 };
 
 VSIP_IMPL_SAL_REDUCT(Sum_value,        sal::sumval)
@@ -123,37 +125,36 @@
   Evaluators for reduction-idx functions
 ***********************************************************************/
 
-#define VSIP_IMPL_SAL_REDUCT_IDX(OP, SALFCN)				\
-template <typename T,							\
-	  typename Block>						\
-struct Evaluator<Op_reduce_idx<OP>, T,					\
-		 Op_list_3<Block const&, Index<1>&, row1_type>,		\
-		 Mercury_sal_tag>					\
-{									\
-  typedef typename Block::map_type                        map_type;	\
-  typedef typename sal::Effective_value_type<Block>::type eff_t;	\
-									\
-  static bool const ct_valid = 						\
-    !Is_expr_block<Block>::value &&					\
-     Is_local_map<map_type>::value &&					\
-     sal::Is_reduct_supported<OP, eff_t>::value &&			\
-     Ext_data_cost<Block>::value == 0;					\
-									\
-  static bool rt_valid(T&, Block const&, Index<1>&, row1_type)		\
-  { return true; }							\
-									\
-  static void exec(T& r, Block const& blk, Index<1>& idx, row1_type)	\
-  {									\
-    sal::Ext_wrapper<Block> ext(blk, SYNC_IN);				\
-									\
-    int i;								\
-    SALFCN(								\
-      typename sal::Ext_wrapper<Block>::sal_type(ext),			\
-      r,								\
-      i,								\
-      blk.size());							\
-    idx = Index<1>(i);							\
-  }									\
+#define VSIP_IMPL_SAL_REDUCT_IDX(OP, SALFCN)                            \
+template <typename T,                                                   \
+          typename Block>                                               \
+struct Evaluator<Op_reduce_idx<OP>, Mercury_sal_tag,                    \
+                 void(T&, Block const&, Index<1>&, row1_type)>          \
+{                                                                       \
+  typedef typename Block::map_type                        map_type;     \
+  typedef typename sal::Effective_value_type<Block>::type eff_t;        \
+                                                                        \
+  static bool const ct_valid =                                          \
+    !Is_expr_block<Block>::value &&                                     \
+     Is_local_map<map_type>::value &&                                   \
+     sal::Is_reduct_supported<OP, eff_t>::value &&                      \
+     Ext_data_cost<Block>::value == 0;                                  \
+                                                                        \
+  static bool rt_valid(T&, Block const&, Index<1>&, row1_type)          \
+  { return true; }                                                      \
+                                                                        \
+  static void exec(T& r, Block const& blk, Index<1>& idx, row1_type)    \
+  {                                                                     \
+    sal::Ext_wrapper<Block> ext(blk, SYNC_IN);                          \
+                                                                        \
+    int i;                                                              \
+    SALFCN(                                                             \
+      typename sal::Ext_wrapper<Block>::sal_type(ext),                  \
+      r,                                                                \
+      i,                                                                \
+      blk.size());                                                      \
+    idx = Index<1>(i);                                                  \
+  }                                                                     \
 };
 
 VSIP_IMPL_SAL_REDUCT_IDX(Max_value, sal::maxval)
@@ -164,6 +165,8 @@
 
 #undef VSIP_IMPL_SAL_REDUCT_IDX
 
+} // namespace vsip::impl::dispatcher
+
 } // namespace vsip::impl
 } // namespace vsip
 
Index: src/vsip/opt/reductions/par_reductions.hpp
===================================================================
--- src/vsip/opt/reductions/par_reductions.hpp	(revision 229176)
+++ src/vsip/opt/reductions/par_reductions.hpp	(working copy)
@@ -31,6 +31,9 @@
 namespace impl
 {
 
+namespace dispatcher
+{
+
 template <template <typename> class ReduceT>
 struct ReduceOp { typedef Op_reduce_idx<ReduceT> reduce_op; };
 
@@ -41,6 +44,17 @@
 struct ReduceOp<Max_magsq_value >
   { typedef Op_reduce_idx<Max_value> reduce_op; };
 
+
+template<template <typename> class ReduceT>
+struct List<ReduceOp<ReduceT> >
+{
+  typedef Make_type_list<Cvsip_tag, Mercury_sal_tag,
+    Generic_tag>::type type;
+};
+
+} // namespace vsip::impl::dispatcher
+
+
 template <typename                  ReduceT,
           typename                  T,
           dimension_type            Dim,
@@ -49,18 +63,15 @@
 reduce_idx_blk(Block const& b, Index<Dim>& idx)
 {
   T r;
-  typedef typename Block_layout<Block>::order_type
-		order_type;
+  typedef typename Block_layout<Block>::order_type order_type;
+  typedef dispatcher::Make_type_list<Cvsip_tag, 
+    Mercury_sal_tag, Generic_tag>::type list_type;
 
-  General_dispatch<
-		ReduceT,
-		T,
-		impl::Op_list_3<Block const&,
-                                Index<Dim>&,
-                                order_type>,
-		typename Make_type_list<Cvsip_tag, Mercury_sal_tag,
-                                        Generic_tag>::type>
-        ::exec(r, b, idx, order_type());
+  dispatcher::Dispatcher<
+    ReduceT,
+    void(T&, Block const&, Index<Dim>&, order_type),
+    list_type>::
+  dispatch(r, b, idx, order_type());
 
   return r;
 }
@@ -97,7 +108,7 @@
   if(a.map().subblock() != no_subblock) 
   {
     typename ReduceT<T>::result_type result = 
-      reduce_idx_blk<Op_reduce_idx<ReduceT>,typename ReduceT<T>::result_type>
+      reduce_idx_blk<dispatcher::Op_reduce_idx<ReduceT>,typename ReduceT<T>::result_type>
         (get_local_block(a),my_res_idx);
     results.local().put(0,result);
     my_g_res_idx = global_from_local_index_blk(a,my_res_idx);
@@ -114,7 +125,7 @@
   global_results     = results;
   global_results_idx = results_idx;
 
-  global_res = reduce_idx_blk<typename ReduceOp<ReduceT>::reduce_op,
+  global_res = reduce_idx_blk<typename dispatcher::ReduceOp<ReduceT>::reduce_op,
                               typename ReduceT<T>::result_type>
       (global_results.block(),global_res_idx);
   idx = global_results_idx.get(global_res_idx[0]);
@@ -159,14 +170,16 @@
 * Parallel evaluator for index returning reductions
 **********************************************************************/
 
+namespace dispatcher
+{
+
 template <template <typename> class ReduceT,
           typename                  T,
 	  typename                  Block,
 	  typename                  OrderT,
 	  dimension_type            Dim >
-struct Evaluator<Op_reduce_idx<ReduceT>, T,
-		 Op_list_3<Block const&, Index<Dim>&, OrderT>,
-		 Parallel_tag>
+struct Evaluator<Op_reduce_idx<ReduceT>, Parallel_tag, 
+                 void(T&, Block const&, Index<Dim>&, OrderT)>
 {
   static bool const ct_valid = 
     !Is_local_map<typename Block::map_type>::value &&
@@ -180,12 +193,12 @@
   static void exec(T& r, Block const& a, Index<Dim>& idx, OrderT)
   {
     r = generic_par_idx_op<ReduceT,T>(a, idx);
-
   }
 };
 
+} // namespace vsip::impl::dispatcher
 
-} // namesapce vsip::impl
+} // namespace vsip::impl
 } // namespace vsip
 
 #endif // VSIP_OPT_REDUCTIONS_PAR_REDUCTIONS_HPP
Index: src/vsip/opt/general_dispatch.hpp
===================================================================
--- src/vsip/opt/general_dispatch.hpp	(revision 229176)
+++ src/vsip/opt/general_dispatch.hpp	(working copy)
@@ -1,307 +0,0 @@
-/* Copyright (c) 2005, 2006 by CodeSourcery.  All rights reserved.
-
-   This file is available for license from CodeSourcery, Inc. under the terms
-   of a commercial license and under the GPL.  It is not part of the VSIPL++
-   reference implementation and is not available under the BSD license.
-*/
-/** @file    vsip/opt/general_dispatch.hpp
-    @author  Jules Bergmann
-    @date    2005-10-10
-    @brief   VSIPL++ Library: Dispatch harness that allows various
-             implementations to be bound to a particular operation.
-*/
-
-#ifndef VSIP_OPT_GENERAL_DISPATCH_HPP
-#define VSIP_OPT_GENERAL_DISPATCH_HPP
-
-#if VSIP_IMPL_REF_IMPL
-# error "vsip/opt files cannot be used as part of the reference impl."
-#endif
-
-/***********************************************************************
-  Included Files
-***********************************************************************/
-
-#include <vsip/core/config.hpp>
-#include <vsip/core/type_list.hpp>
-#include <vsip/core/impl_tags.hpp>
-#include <vsip/core/general_evaluator.hpp>
-
-
-
-/***********************************************************************
-  Declarations
-***********************************************************************/
-
-namespace vsip
-{
-namespace impl
-{
-
-template <typename OpTag>
-struct Dispatch_order
-{
-  typedef typename Make_type_list<
-    Cml_tag, Blas_tag, Mercury_sal_tag, Cvsip_tag, Generic_tag 
-    >::type type;
-};
-
-
-
-/***********************************************************************
-  General_dispatch - primary definition and common specializations
-***********************************************************************/
-
-/// Serial_dispatch_helper dispatches the evaluation of an expression along
-/// a type list of potential backends.
-/// Whether a given backend is actually used depends on its compile-time
-/// and run-time validity checks.
-template <typename OpTag,
-	  typename DstType,
-	  typename SrcType,
-	  typename TagList = typename Dispatch_order<OpTag>::type,
-	  typename Tag = typename TagList::first,
-	  typename Rest = typename TagList::rest,
-	  typename EvalExpr = Evaluator<OpTag, DstType, SrcType, Tag>,
-	  bool CtValid = EvalExpr::ct_valid>
-struct General_dispatch;
-
-
-
-/// In case the compile-time check fails, we continue the search
-/// directly at the next entry in the type list.
-template <typename OpTag,
-	  typename DstType,
-	  typename SrcType,
-	  typename TagList,
-	  typename Tag,
-	  typename Rest,
-	  typename EvalExpr>
-struct General_dispatch<OpTag, DstType, SrcType, TagList, Tag, Rest, EvalExpr,
-			false>
-  : General_dispatch<OpTag, DstType, SrcType, Rest>
-{};
-
-
-
-/***********************************************************************
-  General_dispatch - 2-op scalar return specializations
-***********************************************************************/
-
-/// In case the compile-time check passes, we decide at run-time whether
-/// or not to use this backend.
-template <typename OpTag,
-	  typename T,
-	  typename Block1,
-	  typename Block2,
-	  typename TagList,
-	  typename Tag,
-	  typename Rest,
-	  typename EvalExpr>
-struct General_dispatch<OpTag, Return_scalar<T>, Op_list_2<Block1, Block2>,
-			TagList, Tag, Rest, EvalExpr, true>
-{
-  static T exec(Block1 const& op1, Block2 const& op2)
-  {
-    if (EvalExpr::rt_valid(op1, op2))
-      return EvalExpr::exec(op1, op2);
-    else
-      return General_dispatch<OpTag, Return_scalar<T>,
-			      Op_list_2<Block1, Block2>,
-			      Rest>::exec(op1, op2);
-  }
-};
-
-
-
-/// Terminator. Instead of passing on to the next element
-/// it aborts the program. It is a program error to define
-/// callback lists that can't handle a given expression.
-template <typename OpTag,
-	  typename T,
-	  typename Block1,
-	  typename Block2,
-	  typename TagList,
-	  typename Tag,
-	  typename EvalExpr>
-struct General_dispatch<OpTag, Return_scalar<T>, Op_list_2<Block1, Block2>,
-			TagList, Tag, None_type, EvalExpr, true>
-{
-  static T exec(Block1 const& op1, Block2 const& op2)
-  {
-    if (EvalExpr::rt_valid(op1, op2))
-      return EvalExpr::exec(op1, op2);
-    else
-      VSIP_IMPL_THROW(impl::unimplemented("General_dispatch failed"));
-  }
-};
-
-
-
-/***********************************************************************
-  General_dispatch - 2-op block return specializations
-***********************************************************************/
-
-/// In case the compile-time check passes, we decide at run-time whether
-/// or not to use this backend.
-template <typename OpTag,
-	  typename DstBlock,
-	  typename Block1,
-	  typename Block2,
-	  typename TagList,
-	  typename Tag,
-	  typename Rest,
-	  typename EvalExpr>
-struct General_dispatch<OpTag, DstBlock, Op_list_2<Block1, Block2>,
-                       TagList, Tag, Rest, EvalExpr, true>
-{
-  static void exec(DstBlock& res, Block1 const& op1, Block2 const& op2)
-  {
-    if (EvalExpr::rt_valid(res, op1, op2))
-      EvalExpr::exec(res, op1, op2);
-    else
-      General_dispatch<OpTag, DstBlock, Op_list_2<Block1, Block2>, Rest>
-		::exec(res, op1, op2);
-  }
-};
-
-
-
-/// Terminator. Instead of passing on to the next element
-/// it aborts the program. It is a program error to define
-/// callback lists that can't handle a given expression.
-template <typename OpTag,
-	  typename DstBlock,
-	  typename Block1,
-	  typename Block2,
-	  typename TagList,
-	  typename Tag,
-	  typename EvalExpr>
-struct General_dispatch<OpTag, DstBlock, Op_list_2<Block1, Block2>,
-			TagList, Tag, None_type, EvalExpr, true>
-{
-  static void exec(DstBlock& res, Block1 const& op1, Block2 const& op2)
-  {
-    if (EvalExpr::rt_valid(res, op1, op2))
-      EvalExpr::exec(res, op1, op2);
-    else
-      assert(0);
-  }
-};
-
-
-
-/***********************************************************************
-  General_dispatch - 3-op block return specialization, one parameter
-***********************************************************************/
-
-/// In case the compile-time check passes, we decide at run-time whether
-/// or not to use this backend.
-template <typename OpTag,
-	  typename DstBlock,
-          typename T0,
-	  typename T1,
-	  typename T2,
-	  typename TagList,
-	  typename Tag,
-	  typename Rest,
-	  typename EvalExpr>
-struct General_dispatch<OpTag, DstBlock, Op_list_3<T0, T1, T2>,
-                       TagList, Tag, Rest, EvalExpr, true>
-{
-  static void exec(DstBlock& res, T0 op0, T1 op1, T2 op2)
-  {
-    if (EvalExpr::rt_valid(res, op0, op1, op2))
-      EvalExpr::exec(res, op0, op1, op2);
-    else
-      General_dispatch<OpTag, DstBlock, Op_list_3<T0, T1, T2>, Rest>
-		::exec(res, op0, op1, op2);
-  }
-};
-
-
-
-/// Terminator. Instead of passing on to the next element
-/// it aborts the program. It is a program error to define
-/// callback lists that can't handle a given expression.
-template <typename OpTag,
-	  typename DstBlock,
-          typename T0,
-	  typename T1,
-	  typename T2,
-	  typename TagList,
-	  typename Tag,
-	  typename EvalExpr>
-struct General_dispatch<OpTag, DstBlock, Op_list_3<T0, T1, T2>,
-			TagList, Tag, None_type, EvalExpr, true>
-{
-  static void exec(DstBlock& res, T0 op0, T1 op1, T2 op2)
-  {
-    if (EvalExpr::rt_valid(res, op0, op1, op2))
-      EvalExpr::exec(res, op0, op1, op2);
-    else
-      assert(0);
-  }
-};
-
-
-
-/***********************************************************************
-  General_dispatch - 2-op block return specialization, two parameters
-***********************************************************************/
-
-/// In case the compile-time check passes, we decide at run-time whether
-/// or not to use this backend.
-template <typename OpTag,
-	  typename DstBlock,
-          typename T0,
-	  typename Block1,
-	  typename Block2,
-          typename T3,
-	  typename TagList,
-	  typename Tag,
-	  typename Rest,
-	  typename EvalExpr>
-struct General_dispatch<OpTag, DstBlock, Op_list_4<T0, Block1, Block2, T3>,
-                       TagList, Tag, Rest, EvalExpr, true>
-{
-  static void exec(DstBlock& res, T0 param1, Block1 const& op1, Block2 const& op2, T3 param2)
-  {
-    if (EvalExpr::rt_valid(res, param1, op1, op2, param2))
-      EvalExpr::exec(res, param1, op1, op2, param2);
-    else
-      General_dispatch<OpTag, DstBlock, Op_list_4<T0, Block1, Block2, T3>, Rest>
-		::exec(res, param1, op1, op2, param2);
-  }
-};
-
-
-
-/// Terminator. Instead of passing on to the next element
-/// it aborts the program. It is a program error to define
-/// callback lists that can't handle a given expression.
-template <typename OpTag,
-	  typename DstBlock,
-          typename T0,
-	  typename Block1,
-	  typename Block2,
-          typename T3,
-	  typename TagList,
-	  typename Tag,
-	  typename EvalExpr>
-struct General_dispatch<OpTag, DstBlock, Op_list_4<T0, Block1, Block2, T3>,
-			TagList, Tag, None_type, EvalExpr, true>
-{
-  static void exec(DstBlock& res, T0 param1, Block1 const& op1, Block2 const& op2, T0 param2)
-  {
-    if (EvalExpr::rt_valid(res, param1, op1, op2, param2))
-      EvalExpr::exec(res, param1, op1, op2, param2);
-    else
-      VSIP_IMPL_THROW(impl::unimplemented("General_dispatch failed"));
-  }
-};
-
-} // namespace vsip::impl
-} // namespace vsip
-
-#endif // VSIP_IMPL_GENERAL_DISPATCH_HPP
