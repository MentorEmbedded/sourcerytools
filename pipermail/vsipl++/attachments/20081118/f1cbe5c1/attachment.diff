Index: src/vsip/core/cvsip/matvec.hpp
===================================================================
--- src/vsip/core/cvsip/matvec.hpp	(revision 225932)
+++ src/vsip/core/cvsip/matvec.hpp	(working copy)
@@ -22,10 +22,12 @@
 extern "C" {
 #include <vsip.h>
 }
+
 namespace vsip
 {
 namespace impl
 {
+
 namespace cvsip
 {
 
@@ -158,67 +160,77 @@
 
 } // namespace vsip::impl::cvsip
 
+namespace dispatcher
+{
+
 template <typename T,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_vv_dot, Return_scalar<T>, Op_list_2<Block1, Block2>,
-                 Cvsip_tag>
+          typename Block0,
+          typename Block1>
+struct Evaluator<Op_prod_vv_dot, Cvsip_tag,
+                 T(Block0 const&, Block1 const&)>
 {
   typedef cvsip::Op_traits<T> traits;
 
+  // Note: C-VSIPL backends set ct_valid to false if the block types don't 
+  // allow direct data access (i.e. Ext_data_cost > 0), which occurs when
+  // an operator like conj() is used (see cvjdot()).  This prevents this
+  // evaluator from being used if invoked through the normal dispatch 
+  // mechanism.  For the reference implementation, we call the backend 
+  // explicitly, which is ok, since the Ext_data handles the layout 
+  // adjustments.
+
   static bool const ct_valid = 
     traits::valid &&
+    Type_equal<T, typename Block0::value_type>::value &&
     Type_equal<T, typename Block1::value_type>::value &&
-    Type_equal<T, typename Block2::value_type>::value &&
     // check that direct access is supported
-    Ext_data_cost<Block1>::value == 0 &&
-    Ext_data_cost<Block2>::value == 0;
+    Ext_data_cost<Block0>::value == 0 &&
+    Ext_data_cost<Block1>::value == 0;
 
-  static bool rt_valid(Block1 const&, Block2 const&) { return true;}
+  static bool rt_valid(Block0 const&, Block1 const&) { return true;}
 
-  static T exec(Block1 const& a, Block2 const& b)
+  static T exec(Block0 const& a, Block1 const& b)
   {
     VSIP_IMPL_COVER_FCN("Op_prod_vv_dot/cvsip", exec);
     assert(a.size(1, 0) == b.size(1, 0));
 
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_b(const_cast<Block2&>(b));
+    Ext_data<Block0 const> ext_a(a);
+    Ext_data<Block1 const> ext_b(b);
     cvsip::View<1, T> aview(ext_a.data(), 0, ext_a.stride(0), a.size(1, 0));
     cvsip::View<1, T> bview(ext_b.data(), 0, ext_b.stride(0), b.size(1, 0));
     return traits::dot(aview.ptr(), bview.ptr());
   }
 };
 
+
 template <typename T,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_vv_dot, Return_scalar<std::complex<T> >,
-                 Op_list_2<Block1, 
-                           Unary_expr_block<1, conj_functor,
-                                            Block2, std::complex<T> > const>,
-                 Cvsip_tag>
+          typename Block0,
+          typename Block1>
+struct Evaluator<Op_prod_vv_dot, Cvsip_tag,
+                 std::complex<T>(Block0 const&, 
+                   Unary_expr_block<1, conj_functor, Block1, std::complex<T> > const&)>
 {
   typedef cvsip::Op_traits<std::complex<T> > traits;
-  typedef Unary_expr_block<1, conj_functor, Block2, complex<T> > block2_type;
+  typedef Unary_expr_block<1, conj_functor, Block1, std::complex<T> > block1_type;
 
   static bool const ct_valid = 
     traits::valid &&
+    Type_equal<complex<T>, typename Block0::value_type>::value &&
     Type_equal<complex<T>, typename Block1::value_type>::value &&
-    Type_equal<complex<T>, typename Block2::value_type>::value &&
     // check that direct access is supported
-    Ext_data_cost<Block1>::value == 0 &&
-    Ext_data_cost<Block2>::value == 0;
+    Ext_data_cost<Block0>::value == 0 &&
+    Ext_data_cost<Block1>::value == 0;
 
-  static bool rt_valid(Block1 const&, block2_type const&)
+  static bool rt_valid(Block0 const&, block1_type const&)
   { return true; }
 
-  static complex<T> exec(Block1 const& a, block2_type const& b)
+  static complex<T> exec(Block0 const& a, block1_type const& b)
   {
     VSIP_IMPL_COVER_FCN("Op_prod_vv_dot(conj)/cvsip", exec);
     assert(a.size(1, 0) == b.size(1, 0));
 
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_b(const_cast<Block2&>(b.op()));
+    Ext_data<Block0 const> ext_a(a);
+    Ext_data<Block1 const> ext_b(b.op());
     cvsip::View<1, std::complex<T> >
       aview(ext_a.data(), 0, ext_a.stride(0), a.size(1, 0));
     cvsip::View<1, std::complex<T> >
@@ -227,13 +239,13 @@
   }
 };
 
+
 template <typename T,
           typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_vv_outer, Block0,
-		 Op_list_3<T, Block1 const&, Block2 const&>,
-                 Cvsip_tag>
+struct Evaluator<Op_prod_vv_outer, Cvsip_tag,
+                 void(Block0&, T, Block1 const&, Block2 const&)>
 {
   typedef cvsip::Op_traits<T> traits;
 
@@ -259,8 +271,8 @@
     assert(b.size(1, 0) == r.size(2, 1));
 
     Ext_data<Block0> ext_r(r);
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_b(const_cast<Block2&>(b));
+    Ext_data<Block1 const> ext_a(a);
+    Ext_data<Block2 const> ext_b(b);
 
     cvsip::View<1, T> aview(ext_a.data(), 0, ext_a.stride(0), a.size(1, 0));
     cvsip::View<1, T> bview(ext_b.data(), 0, ext_b.stride(0), b.size(1, 0));
@@ -275,7 +287,8 @@
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_vm, Block0, Op_list_2<Block1, Block2>, Cvsip_tag>
+struct Evaluator<Op_prod_vm, Cvsip_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
   typedef cvsip::Op_traits<T> traits;
@@ -299,8 +312,8 @@
     assert(x.size(1, 0) == a.size(2, 0));
 
     Ext_data<Block0> ext_y(y);
-    Ext_data<Block1> ext_x(const_cast<Block1&>(x));
-    Ext_data<Block2> ext_a(const_cast<Block2&>(a));
+    Ext_data<Block1 const> ext_x(x);
+    Ext_data<Block2 const> ext_a(a);
 
     cvsip::View<1, T> yview(ext_y.data(), 0, ext_y.stride(0), y.size(1, 0));
     cvsip::View<1, T> xview(ext_x.data(), 0, ext_x.stride(0), x.size(1, 0));
@@ -315,7 +328,8 @@
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_mv, Block0, Op_list_2<Block1, Block2>, Cvsip_tag>
+struct Evaluator<Op_prod_mv, Cvsip_tag, 
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
   typedef typename Block_layout<Block1>::order_type order1_type;
@@ -340,8 +354,8 @@
     assert(x.size(1, 0) == a.size(2, 1));
 
     Ext_data<Block0> ext_y(y);
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_x(const_cast<Block2&>(x));
+    Ext_data<Block1 const> ext_a(a);
+    Ext_data<Block2 const> ext_x(x);
 
     cvsip::View<1, T> yview(ext_y.data(), 0, ext_y.stride(0), y.size(1, 0));
     cvsip::View<2, T> aview(ext_a.data(), 0,
@@ -356,7 +370,8 @@
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_mm, Block0, Op_list_2<Block1, Block2>, Cvsip_tag>
+struct Evaluator<Op_prod_mm, Cvsip_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
   typedef cvsip::Op_traits<T> traits;
@@ -377,8 +392,8 @@
   {
     VSIP_IMPL_COVER_FCN("Op_prod_mm/cvsip", exec);
     Ext_data<Block0> ext_c(c);
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_b(const_cast<Block2&>(b));
+    Ext_data<Block1 const> ext_a(a);
+    Ext_data<Block2 const> ext_b(b);
 
     cvsip::View<2, T> cview(ext_c.data(), 0,
                             ext_c.stride(0), c.size(2, 0),
@@ -397,8 +412,8 @@
           typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_gemp, Block0, Op_list_4<T, Block1, Block2, T>,
-                 Cvsip_tag>
+struct Evaluator<Op_prod_gemp, Cvsip_tag,
+                 void(Block0&, T, Block1 const&, Block2 const&, T)>
 {
   typedef cvsip::Op_traits<T> traits;
 
@@ -419,8 +434,8 @@
   {
     VSIP_IMPL_COVER_FCN("Op_prod_gemp/cvsip", exec);
     Ext_data<Block0> ext_c(c);
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_b(const_cast<Block2&>(b));
+    Ext_data<Block1 const> ext_a(a);
+    Ext_data<Block2 const> ext_b(b);
 
     cvsip::View<2, T> cview(ext_c.data(), 0,
                             ext_c.stride(0), c.size(2, 0),
@@ -435,6 +450,8 @@
   }
 };
 
+} // namespace vsip::impl::dispatcher
+
 } // namespace vsip::impl
 } // namespace vsip
 
Index: src/vsip/core/dispatch.hpp
===================================================================
--- src/vsip/core/dispatch.hpp	(revision 0)
+++ src/vsip/core/dispatch.hpp	(revision 0)
@@ -0,0 +1,56 @@
+/* Copyright (c) 2008 by CodeSourcery.  All rights reserved. */
+
+/** @file    vsip/core/dispatch.hpp
+    @author  Don McCoy
+    @date    2008-11-17
+    @brief   VSIPL++ Library: Dispatcher harness definitions needed
+               only for building the reference implementation (see
+               vsip/opt/dispatch.hpp for the actual dispatcher).
+*/
+
+#ifndef VSIP_CORE_DISPATCH_HPP
+#define VSIP_CORE_DISPATCH_HPP
+
+
+/***********************************************************************
+  Declarations
+***********************************************************************/
+
+namespace vsip
+{
+namespace impl
+{
+namespace dispatcher
+{
+
+
+/// Define the operation-specific Evaluator signature.
+template <typename O, typename R = void> 
+struct Signature
+{
+  // The default signature is useful for a compile-time check only,
+  // as there are no arguments to inspect at runtime.
+  typedef R(type)();
+};
+
+
+/// An Evaluator determines whether an Operation can be performed
+/// with a particular backend.
+///
+///   O: Operation tag
+///   B: Backend tag
+///   S: Signature
+template <typename O,
+          typename B,
+          typename S = typename Signature<O>::type>
+struct Evaluator
+{
+  static bool const ct_valid = false;
+};
+
+
+} // namespace vsip::impl::dispatcher
+} // namespace vsip::impl
+} // namespace vsip
+
+#endif // VSIP_CORE_DISPATCH_HPP
Index: src/vsip/core/matvec_prod.hpp
===================================================================
--- src/vsip/core/matvec_prod.hpp	(revision 225932)
+++ src/vsip/core/matvec_prod.hpp	(working copy)
@@ -44,13 +44,24 @@
 namespace impl
 {
 
-// Generic evaluator for matrix-matrix products.
+namespace dispatcher
+{
 
+#ifndef VSIP_IMPL_REF_IMPL
+template<>
+struct List<Op_prod_mm>
+{
+  typedef Make_type_list<Cml_tag, Blas_tag, Mercury_sal_tag, 
+    Cvsip_tag, Generic_tag>::type type;
+};
+#endif
+
+/// Generic evaluator for matrix-matrix products.
 template <typename Block0,
 	  typename Block1,
 	  typename Block2>
-struct Evaluator<Op_prod_mm, Block0, Op_list_2<Block1, Block2>,
-		 Generic_tag>
+struct Evaluator<Op_prod_mm, Generic_tag, 
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(Block0&, Block1 const&, Block2 const&)
@@ -74,46 +85,21 @@
 };
 
 
-
-/// Matrix-matrix product.
-
-template <typename T0,
-	  typename T1,
-	  typename T2,
-	  typename Block0,
-	  typename Block1,
-	  typename Block2>
-void
-generic_prod(
-  const_Matrix<T0, Block0> a,
-  const_Matrix<T1, Block1> b,
-  Matrix<T2, Block2>       r)
+#ifndef VSIP_IMPL_REF_IMPL
+template<>
+struct List<Op_prod_mm_conj>
 {
-  typedef Op_list_2<Block0, Block1> signature_type;
-
-  assert(r.size(0) == a.size(0));
-  assert(r.size(1) == b.size(1));
-  assert(a.size(1) == b.size(0));
-
-#ifdef VSIP_IMPL_REF_IMPL
-  Evaluator<Op_prod_mm, Block2, signature_type, Cvsip_tag>
-    ::exec(r.block(), a.block(), b.block());
-#else
-  General_dispatch<Op_prod_mm, Block2, signature_type>
-    ::exec(r.block(), a.block(), b.block());
+  typedef Make_type_list<Cml_tag, Blas_tag, Mercury_sal_tag, 
+    Cvsip_tag, Generic_tag>::type type;
+};
 #endif
-}
 
-
-
-
-// Generic evaluator for matrix-matrix conjugate products.
-
+/// Generic evaluator for matrix-matrix conjugate products.
 template <typename Block0,
 	  typename Block1,
 	  typename Block2>
-struct Evaluator<Op_prod_mm_conj, Block0, Op_list_2<Block1, Block2>,
-		 Generic_tag>
+struct Evaluator<Op_prod_mm_conj, Generic_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(Block0&, Block1 const&, Block2 const&)
@@ -137,44 +123,58 @@
 };
 
 
+#ifndef VSIP_IMPL_REF_IMPL
+template<>
+struct List<Op_prod_mv>
+{
+  typedef Make_type_list<Cml_tag, Blas_tag, Mercury_sal_tag, 
+    Cvsip_tag, Generic_tag>::type type;
+};
+#endif
 
-/// Matrix-matrix conjugate product.
-
-template <typename T0,
-	  typename T1,
-	  typename T2,
-	  typename Block0,
+/// Generic evaluator for matrix-vector products.
+template <typename Block0,
 	  typename Block1,
 	  typename Block2>
-void
-generic_prodj(
-  const_Matrix<T0, Block0> a,
-  const_Matrix<T1, Block1> b,
-  Matrix<T2, Block2>       r)
+struct Evaluator<Op_prod_mv, Generic_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
-  typedef Op_list_2<Block0, Block1> signature_type;
+  static bool const ct_valid = true;
+  static bool rt_valid(Block0&, Block1 const&, Block2 const&)
+  { return true; }
 
-  assert(r.size(0) == a.size(0));
-  assert(r.size(1) == b.size(1));
-  assert(a.size(1) == b.size(0));
+  static void exec(Block0& r, Block1 const& a, Block2 const& b)
+  {
+    typedef typename Block0::value_type RT;
 
-#ifdef VSIP_IMPL_REF_IMPL
-  impl::generic_prod(a, conj(b), r);
-#else
-  General_dispatch<Op_prod_mm_conj, Block2, signature_type>
-    ::exec(r.block(), a.block(), b.block());
-#endif
-}
+    for (index_type i=0; i<r.size(1, 0); ++i)
+    {
+      RT sum = RT();
+      for (index_type k=0; k<a.size(2, 1); ++k)
+      {
+        sum += a.get(i, k) * b.get(k);
+      }
+      r.put(i, sum);
+    }
+  }
+};
 
 
+#ifndef VSIP_IMPL_REF_IMPL
+template<>
+struct List<Op_prod_vm>
+{
+  typedef Make_type_list<Cml_tag, Blas_tag, Mercury_sal_tag, 
+    Cvsip_tag, Generic_tag>::type type;
+};
+#endif
 
-// Generic evaluator for matrix-vector products.
-
+/// Generic evaluator for vector-matrix products.
 template <typename Block0,
 	  typename Block1,
 	  typename Block2>
-struct Evaluator<Op_prod_mv, Block0, Op_list_2<Block1, Block2>,
-		 Generic_tag>
+struct Evaluator<Op_prod_vm, Generic_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(Block0&, Block1 const&, Block2 const&)
@@ -184,21 +184,22 @@
   {
     typedef typename Block0::value_type RT;
 
-    for (index_type i=0; i<r.size(1, 0); ++i)
+    for (index_type i=0; i<r.size(); ++i)
     {
       RT sum = RT();
-      for (index_type k=0; k<a.size(2, 1); ++k)
+      for (index_type k=0; k<b.size(2, 0); ++k)
       {
-        sum += a.get(i, k) * b.get(k);
+        sum += a.get(k) * b.get(k, i);
       }
       r.put(i, sum);
     }
   }
 };
 
+} // namespace vsip::impl::dispatcher
 
-/// Matrix-vector product.
 
+/// Generic matrix-matrix product.
 template <typename T0,
 	  typename T1,
 	  typename T2,
@@ -208,57 +209,87 @@
 void
 generic_prod(
   const_Matrix<T0, Block0> a,
-  const_Vector<T1, Block1> b,
-  Vector<T2, Block2>       r)
+  const_Matrix<T1, Block1> b,
+  Matrix<T2, Block2>       r)
 {
   typedef Op_list_2<Block0, Block1> signature_type;
 
-  assert(r.size() == a.size(0));
-  assert(a.size(1) == b.size());
+  assert(r.size(0) == a.size(0));
+  assert(r.size(1) == b.size(1));
+  assert(a.size(1) == b.size(0));
 
 #ifdef VSIP_IMPL_REF_IMPL
-  Evaluator<Op_prod_mv, Block2, signature_type, Cvsip_tag>
-    ::exec(r.block(), a.block(), b.block());
+  dispatcher::Evaluator<dispatcher::Op_prod_mm, Cvsip_tag,
+    void(Block2&, Block0 const&, Block1 const&)>::exec
+    (r.block(), a.block(), b.block());
 #else
-  General_dispatch<Op_prod_mv, Block2, signature_type>
-    ::exec(r.block(), a.block(), b.block());
+  impl::dispatch<dispatcher::Op_prod_mm, void,
+    Block2&, Block0 const&, Block1 const&>
+    (r.block(), a.block(), b.block());
 #endif
 }
 
 
+/// Generic matrix-matrix conjugate product.
+template <typename T0,
+	  typename T1,
+	  typename T2,
+	  typename Block0,
+	  typename Block1,
+	  typename Block2>
+void
+generic_prodj(
+  const_Matrix<T0, Block0> a,
+  const_Matrix<T1, Block1> b,
+  Matrix<T2, Block2>       r)
+{
+  typedef Op_list_2<Block0, Block1> signature_type;
 
+  assert(r.size(0) == a.size(0));
+  assert(r.size(1) == b.size(1));
+  assert(a.size(1) == b.size(0));
 
-// Generic evaluator for vector-matrix products.
+#ifdef VSIP_IMPL_REF_IMPL
+  impl::generic_prod(a, conj(b), r);
+#else
+  impl::dispatch<dispatcher::Op_prod_mm_conj, void,
+    Block2&, Block0 const&, Block1 const&>
+    (r.block(), a.block(), b.block());
+#endif
+}
 
-template <typename Block0,
+
+/// Generic matrix-vector product.
+template <typename T0,
+	  typename T1,
+	  typename T2,
+	  typename Block0,
 	  typename Block1,
 	  typename Block2>
-struct Evaluator<Op_prod_vm, Block0, Op_list_2<Block1, Block2>,
-		 Generic_tag>
+void
+generic_prod(
+  const_Matrix<T0, Block0> a,
+  const_Vector<T1, Block1> b,
+  Vector<T2, Block2>       r)
 {
-  static bool const ct_valid = true;
-  static bool rt_valid(Block0&, Block1 const&, Block2 const&)
-  { return true; }
+  typedef Op_list_2<Block0, Block1> signature_type;
 
-  static void exec(Block0& r, Block1 const& a, Block2 const& b)
-  {
-    typedef typename Block0::value_type RT;
+  assert(r.size() == a.size(0));
+  assert(a.size(1) == b.size());
 
-    for (index_type i=0; i<r.size(); ++i)
-    {
-      RT sum = RT();
-      for (index_type k=0; k<b.size(2, 0); ++k)
-      {
-        sum += a.get(k) * b.get(k, i);
-      }
-      r.put(i, sum);
-    }
-  }
-};
+#ifdef VSIP_IMPL_REF_IMPL
+  dispatcher::Evaluator<dispatcher::Op_prod_mv, Cvsip_tag,
+    void(Block2&, Block0 const&, Block1 const&)>::exec
+    (r.block(), a.block(), b.block());
+#else
+  impl::dispatch<dispatcher::Op_prod_mv, void,
+    Block2&, Block0 const&, Block1 const&>
+    (r.block(), a.block(), b.block());
+#endif
+}
 
 
-/// Vector-matrix product.
-
+/// Generic vector-matrix product.
 template <typename T0,
 	  typename T1,
 	  typename T2,
@@ -277,11 +308,13 @@
   assert(a.size() == b.size(0));
 
 #ifdef VSIP_IMPL_REF_IMPL
-  Evaluator<Op_prod_vm, Block2, signature_type, Cvsip_tag>
-    ::exec(r.block(), a.block(), b.block());
+  dispatcher::Evaluator<dispatcher::Op_prod_vm, Cvsip_tag,
+    void(Block2&, Block0 const&, Block1 const&)>::exec
+    (r.block(), a.block(), b.block());
 #else
-  General_dispatch<Op_prod_vm, Block2, signature_type>
-    ::exec(r.block(), a.block(), b.block());
+  impl::dispatch<dispatcher::Op_prod_vm, void,
+    Block2&, Block0 const&, Block1 const&>
+    (r.block(), a.block(), b.block());
 #endif
 }
 
@@ -290,7 +323,6 @@
 
 
 /// Matrix-matrix product dispatch.
-
 template <typename T0,
 	  typename T1,
 	  typename Block0,
@@ -310,9 +342,7 @@
 }
 
 
-
 /// Matrix-vector product dispatch.
-
 template <typename T0,
 	  typename T1,
 	  typename Block0,
@@ -332,9 +362,7 @@
 }
 
 
-
 /// Vector-Matrix product dispatch.
-
 template <typename T0,
 	  typename T1,
 	  typename Block0,
@@ -354,9 +382,7 @@
 }
 
 
-
 /// [3x3] Matrix-matrix product dispatch.
-
 template <typename T0,
 	  typename T1,
 	  typename Block0,
@@ -379,7 +405,6 @@
 
 
 /// [3x3] Matrix-vector product dispatch.
-
 template <typename T0,
 	  typename T1,
 	  typename Block0,
@@ -401,9 +426,7 @@
 }
 
 
-
 /// [4x4] Matrix-matrix product dispatch.
-
 template <typename T0,
 	  typename T1,
 	  typename Block0,
@@ -425,9 +448,7 @@
 }
 
 
-
 /// [4x4] Matrix-vector product dispatch.
-
 template <typename T0,
 	  typename T1,
 	  typename Block0,
@@ -449,9 +470,7 @@
 }
 
 
-
 /// Matrix-Matrix (with hermitian) product dispatch.
-
 template <typename T0,
           typename T1,
           typename Block0,
@@ -473,7 +492,6 @@
 
 
 /// Matrix-Matrix (with complex conjugate) product dispatch.
-
 template <typename T0,
           typename T1,
           typename Block0,
@@ -495,7 +513,6 @@
 
 
 /// Matrix-Matrix (with transpose) product dispatch.
-
 template <typename T0,
           typename T1,
           typename Block0,
Index: src/vsip/core/matvec.hpp
===================================================================
--- src/vsip/core/matvec.hpp	(revision 225932)
+++ src/vsip/core/matvec.hpp	(working copy)
@@ -19,8 +19,10 @@
 #include <vsip/matrix.hpp>
 #include <vsip/core/promote.hpp>
 #include <vsip/core/fns_elementwise.hpp>
+#include <vsip/core/dispatch.hpp>
+#include <vsip/core/impl_tags.hpp>
 #ifndef VSIP_IMPL_REF_IMPL
-# include <vsip/opt/general_dispatch.hpp>
+# include <vsip/opt/dispatch.hpp>
 # ifdef VSIP_IMPL_CBE_SDK
 #  include <vsip/opt/cbe/cml/matvec.hpp>
 # endif
@@ -39,21 +41,28 @@
 
 namespace vsip
 {
-
 namespace impl
 {
+namespace dispatcher
+{
 
 
+#ifndef VSIP_IMPL_REF_IMPL
+template<>
+struct List<Op_prod_vv_outer>
+{
+  typedef Make_type_list<Cml_tag, Blas_tag, Mercury_sal_tag, 
+    Cvsip_tag, Generic_tag>::type type;
+};
+#endif
 
-// Generic evaluator for outer product
-
+/// Generic evaluator for outer product
 template <typename T1,
 	  typename Block0,
 	  typename Block1,
 	  typename Block2>
-struct Evaluator<Op_prod_vv_outer, Block0,
-		 Op_list_3<T1, Block1 const&, Block2 const&>,
-		 Generic_tag>
+struct Evaluator<Op_prod_vv_outer, Generic_tag,
+                 void(Block0&, T1, Block1 const&, Block2 const&)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(Block0&, T1, Block1 const&, Block2 const&) 
@@ -71,14 +80,13 @@
   }
 };
 
-
+/// Generic evaluator for outer product (with conjugate)
 template <typename T1,
 	  typename Block0,
 	  typename Block1,
 	  typename Block2>
-struct Evaluator<Op_prod_vv_outer, Block0,
-		 Op_list_3<std::complex<T1>, Block1 const&, Block2 const&>,
-		 Generic_tag>
+struct Evaluator<Op_prod_vv_outer, Generic_tag,
+                 void(Block0&, std::complex<T1>, Block1 const&, Block2 const&)>
 {
   static bool const ct_valid = true;
   static bool rt_valid(Block0&, std::complex<T1>, Block1 const&, Block2 const&) 
@@ -97,8 +105,87 @@
 };
 
 
-// Outer product dispatch
 
+#ifndef VSIP_IMPL_REF_IMPL
+template<>
+struct List<Op_prod_vv_dot>
+{
+  typedef Make_type_list<Cml_tag, Blas_tag, Mercury_sal_tag, 
+    Cvsip_tag, Generic_tag>::type type;
+};
+#endif
+
+/// Generic evaluator for vector-vector dot-product.
+template <typename T,
+	  typename Block0,
+	  typename Block1>
+struct Evaluator<Op_prod_vv_dot, Generic_tag,
+                 T(Block0 const&, Block1 const&)>
+{
+  static bool const ct_valid = true;
+  static bool rt_valid(Block0 const&, Block1 const&) { return true; }
+
+  static T exec(Block0 const& a, Block1 const& b)
+  {
+    assert(a.size(1, 0) == b.size(1, 0));
+
+    T r = T();
+    for ( index_type i = 0; i < a.size(); ++i )
+      r += a.get(i) * b.get(i);
+    return r;
+  }
+};
+
+
+#ifndef VSIP_IMPL_REF_IMPL
+template<>
+struct List<Op_prod_gemp>
+{
+  typedef Make_type_list<Cml_tag, Blas_tag, Mercury_sal_tag, 
+    Cvsip_tag, Generic_tag>::type type;
+};
+#endif
+
+/// Generic evaluator for general product
+template <typename T1,
+	  typename T2,
+	  typename Block0,
+	  typename Block1,
+	  typename Block2>
+struct Evaluator<Op_prod_gemp, Generic_tag,
+                 void(Block0&, T1, Block1 const&, Block2 const&, T2)>
+{
+  static bool const ct_valid = true;
+  static bool rt_valid(Block0&, T1, Block1 const&, Block2 const&, T2) 
+    { return true; }
+
+  static void exec(Block0& c, T1 alpha, Block1 const& a, 
+    Block2 const& b, T2 beta)
+  {
+    assert( a.size(2, 0) == c.size(2, 0) );
+    assert( b.size(2, 1) == c.size(2, 1) );
+    assert( a.size(2, 1) == b.size(2, 0) );  
+    
+    // c(i,j) = alpha * a(i) * b(j) + beta * c(i,j)
+    for ( index_type i = a.size(2, 0); i-- > 0; )
+    {
+      for ( index_type j = b.size(2, 1); j-- > 0; )
+      {
+        T1 dot = T1();
+        for ( index_type k = 0; k < a.size(2, 1); ++k )
+          dot += a.get(i, k) * b.get(k, j);
+
+        c.put(i, j, alpha * dot + beta * c.get(i, j));
+      }
+    }
+  }
+};
+
+} // namespace dispatcher
+
+
+
+/// Outer product dispatch
 template <typename T0,
 	  typename T1,
 	  typename T2,
@@ -114,44 +201,21 @@
 {
   assert(r.size(0) == a.size());
   assert(r.size(1) == b.size());
-  typedef Op_list_3<T0, Block0 const&, Block1 const&> signature_type;
 #ifdef VSIP_IMPL_REF_IMPL
-  Evaluator<Op_prod_vv_outer, Block2, signature_type, Cvsip_tag>
-    ::exec(r.block(), alpha, a.block(), b.block());
+  dispatcher::Evaluator<dispatcher::Op_prod_vv_outer, Cvsip_tag, 
+    void(Block2&, T0, Block0 const&, Block1 const&)>::exec
+    (r.block(), alpha, a.block(), b.block());
 #else
-  General_dispatch<Op_prod_vv_outer, Block2, signature_type>
-    ::exec(r.block(), alpha, a.block(), b.block());
+  impl::dispatch<dispatcher::Op_prod_vv_outer, void,
+    Block2&, T0, Block0 const&, Block1 const&>
+    (r.block(), alpha, a.block(), b.block());
 #endif
 }
 
 
-// Generic evaluator for vector-vector dot-product.
-
-template <typename T,
-	  typename Block1,
-	  typename Block2>
-struct Evaluator<Op_prod_vv_dot, Return_scalar<T>, Op_list_2<Block1, Block2>,
-		 Generic_tag>
-{
-  static bool const ct_valid = true;
-  static bool rt_valid(Block1 const&, Block2 const&) { return true; }
-
-  static T exec(Block1 const& a, Block2 const& b)
-  {
-    assert(a.size(1, 0) == b.size(1, 0));
-
-    T r = T();
-    for ( index_type i = 0; i < a.size(); ++i )
-      r += a.get(i) * b.get(i);
-    return r;
-  }
-};
-
-
 // Dot product dispatch.  This is intentionally not named 'dot' to avoid
 // conflicting with vsip::dot, which shares the same signature, forcing
 // the user to resolve the call themselves.
-
 template <typename T0, typename T1, typename Block0, typename Block1>
 typename Promotion<T0, T1>::type
 impl_dot(
@@ -159,24 +223,22 @@
   const_Vector<T1, Block1> w) VSIP_NOTHROW
 {
   typedef typename Promotion<T0, T1>::type return_type;
-  typedef Op_list_2<Block0, Block1> signature_type;
-
   return_type r(0);
 
 #ifdef VSIP_IMPL_REF_IMPL
-  r = Evaluator<Op_prod_vv_dot, Return_scalar<return_type>, signature_type, Cvsip_tag>
-    ::exec(v.block(), w.block());
+  r = dispatcher::Evaluator<dispatcher::Op_prod_vv_dot, Cvsip_tag,
+    return_type(Block0 const&, Block1 const&) >::exec
+    (v.block(), w.block());
 #else
-  r = General_dispatch<Op_prod_vv_dot, 
-                       Return_scalar<return_type>, signature_type>
-    ::exec(v.block(), w.block());
+  r = impl::dispatch<dispatcher::Op_prod_vv_dot, return_type,
+    Block0 const&, Block1 const&>
+    (v.block(), w.block());
 #endif
   return r;
 };
 
 
-
-// vector-vector kron
+/// Generic vector-vector kron
 template <typename T0,
           typename T1,
           typename T2,
@@ -197,7 +259,7 @@
   return r;
 }
 
-// matrix-matrix kron
+/// Generic matrix-matrix kron
 template <typename T0,
           typename T1,
           typename T2,
@@ -226,44 +288,7 @@
 }
 
 
-// Generic evaluator for general product
-
-template <typename T1,
-	  typename T2,
-	  typename Block0,
-	  typename Block1,
-	  typename Block2>
-struct Evaluator<Op_prod_gemp, Block0, Op_list_4<T1, Block1, Block2, T2>,
-		 Generic_tag>
-{
-  static bool const ct_valid = true;
-  static bool rt_valid(Block0&, T1, Block1 const&, Block2 const&, T2) 
-    { return true; }
-
-  static void exec(Block0& c, T1 alpha, Block1 const& a, 
-    Block2 const& b, T2 beta)
-  {
-    assert( a.size(2, 0) == c.size(2, 0) );
-    assert( b.size(2, 1) == c.size(2, 1) );
-    assert( a.size(2, 1) == b.size(2, 0) );  
-    
-    // c(i,j) = alpha * a(i) * b(j) + beta * c(i,j)
-    for ( index_type i = a.size(2, 0); i-- > 0; )
-    {
-      for ( index_type j = b.size(2, 1); j-- > 0; )
-      {
-        T1 dot = T1();
-        for ( index_type k = 0; k < a.size(2, 1); ++k )
-          dot += a.get(i, k) * b.get(k, j);
-
-        c.put(i, j, alpha * dot + beta * c.get(i, j));
-      }
-    }
-  }
-};
-
-/// General matrix product
-
+/// General matrix product dispatch
 template <typename T0,
 	  typename T1,
 	  typename T2,
@@ -276,22 +301,21 @@
   T0 alpha, const_Matrix<T1, Block1> a,
   const_Matrix<T2, Block2> b, T0 beta, Matrix<T4, Block4> c) 
 {
-  typedef Op_list_4<T0, Block1, Block2, T0> signature_type;
-
   assert(c.size(0) == a.size(0));
   assert(c.size(1) == b.size(1));
 
 #ifdef VSIP_IMPL_REF_IMPL
-  Evaluator<Op_prod_gemp, Block4, signature_type, Cvsip_tag>
-    ::exec(c.block(), alpha, a.block(), b.block(), beta);
+  dispatcher::Evaluator<dispatcher::Op_prod_gemp, Cvsip_tag,
+    void(Block4&, T0, Block1 const&, Block2 const&, T0)>::exec
+    (c.block(), alpha, a.block(), b.block(), beta);
 #else
-  General_dispatch<Op_prod_gemp, Block4, signature_type>
-    ::exec(c.block(), alpha, a.block(), b.block(), beta);
+  impl::dispatch<dispatcher::Op_prod_gemp, void,
+    Block4&, T0, Block1 const&, Block2 const&, T0> 
+    (c.block(), alpha, a.block(), b.block(), beta);
 #endif
 }
 
-
-
+/// General matrix sum
 template <typename T0, typename T1, typename T3, typename T4,
   typename Block1, typename Block4>
 void 
@@ -304,8 +328,6 @@
 
 
 
-
-
 /// Class to perform transpose or hermetian (conjugate-transpose),
 /// depending on value type.
 
@@ -353,13 +375,13 @@
 
 
 
-// generalized class used to invoke the correct matrix operator
+/// Generalized class used to invoke the correct matrix operator
 template <mat_op_type OpT,
           typename    T,
           typename    Block>
 struct Apply_mat_op;
 
-// partial specializations:
+/// 'No transpose' matrix operator
 template <typename T,
           typename Block>
 struct Apply_mat_op<mat_ntrans, T, Block>
@@ -373,6 +395,7 @@
     }
 };
 
+/// 'Transpose' matrix operator
 template <typename T,
           typename Block>
 struct Apply_mat_op<mat_trans, T, Block>
@@ -386,6 +409,7 @@
     }
 };
 
+/// 'Hermitian' matrix operator for non-complex types (results in transpose)
 template <typename T,
           typename Block>
 struct Apply_mat_op<mat_herm, T, Block>
@@ -399,6 +423,8 @@
     }
 };
 
+/// 'Hermitian' matrix operator for complex types (results in conjugate 
+/// transpose)
 template <typename T,
           typename Block>
 struct Apply_mat_op<mat_herm, complex<T>, Block>
@@ -416,6 +442,7 @@
     }
 };
 
+/// 'Conjugate' matrix operator for non-complex types (results in identity)
 template <typename T,
           typename Block>
 struct Apply_mat_op<mat_conj, T, Block>
@@ -429,6 +456,7 @@
     }
 };
 
+/// 'Conjugate' matrix operator for complex types
 template <typename T,
           typename Block>
 struct Apply_mat_op<mat_conj, complex<T>, Block>
@@ -445,7 +473,7 @@
 };
 
 
-// convenience function to use Apply_mat_op:
+/// Convenience function to use matrix operator classes
 template <mat_op_type OpT,
           typename    T,
           typename    Block>
@@ -456,7 +484,7 @@
 }
 
 
-
+/// Generic cumulative vector sum
 template <dimension_type d,
           typename T0,
           typename T1,
@@ -483,7 +511,7 @@
   }
 }
 
-
+/// Generic cumulative matrix sum
 template <dimension_type d,
           typename T0,
           typename T1,
@@ -531,6 +559,7 @@
 }
 
 
+/// Generic modulation of a vector by a complex frequency
 template <typename T0,
           typename T1,
           typename T2,
@@ -570,8 +599,6 @@
   return v.size() * nu + phi;
 }
 
-
-
 } // namespace impl
 
 
@@ -580,8 +607,9 @@
   Functions
 ***********************************************************************/
 
-// dot products  [math.matvec.dot]
 
+/// dot products  [math.matvec.dot]
+
 /// dot
 template <typename T0, typename T1, typename Block0, typename Block1>
 typename Promotion<T0, T1>::type
@@ -589,8 +617,8 @@
   const_Vector<T0, Block0> v,
   const_Vector<T1, Block1> w) VSIP_NOTHROW
 {
+#if VSIP_IMPL_PROFILER & VSIP_IMPL_PROFILE_MASK_MATVEC
   typedef typename Promotion<T0, T1>::type result_type;
-#if VSIP_IMPL_PROFILER & VSIP_IMPL_PROFILE_MASK_MATVEC
   impl::profile::Scope<impl::profile::matvec> scope
     (impl::matvec::Description<result_type>::tag("dot", impl::extent(v)),
      impl::matvec::Op_count_dot<result_type>::value(impl::extent(v)) );
@@ -599,7 +627,6 @@
 }
 
 
-
 /// cvjdot
 template <typename T0, typename T1, typename Block0, typename Block1>
 typename Promotion<complex<T0>, complex<T1> >::type
@@ -607,8 +634,8 @@
   const_Vector<complex<T0>, Block0> v,
   const_Vector<complex<T1>, Block1> w) VSIP_NOTHROW
 {
+#if VSIP_IMPL_PROFILER & VSIP_IMPL_PROFILE_MASK_MATVEC
   typedef typename Promotion<T0, T1>::type result_type;
-#if VSIP_IMPL_PROFILER & VSIP_IMPL_PROFILE_MASK_MATVEC
   impl::profile::Scope<impl::profile::matvec> scope
     (impl::matvec::Description<result_type>::tag("cvjdot", impl::extent(v)),
      impl::matvec::Op_count_cvjdot<result_type>::value(impl::extent(v)));
@@ -617,8 +644,7 @@
 }
 
  
- 
-// Transpositions  [math.matvec.transpose]
+/// Transpositions  [math.matvec.transpose]
 
 /// transpose
 template <typename T, typename Block>
@@ -653,7 +679,7 @@
 } 
 
 
-// Kronecker tensor product  [math.matvec.kron]
+/// Kronecker tensor product  [math.matvec.kron]
 
 /// kronecker product
 template <typename T0,
@@ -666,9 +692,9 @@
 kron( T0 alpha, const_View<T1, Block1> v, const_View<T2, Block2> w )
     VSIP_NOTHROW
 {
+#if VSIP_IMPL_PROFILER & VSIP_IMPL_PROFILE_MASK_MATVEC
   typedef typename Promotion<T0, typename Promotion<T1, T2>::type
     >::type result_type;
-#if VSIP_IMPL_PROFILER & VSIP_IMPL_PROFILE_MASK_MATVEC
   impl::profile::Scope<impl::profile::matvec> scope
     (impl::matvec::Description<result_type>::tag("kron", impl::extent(v), 
                                                  impl::extent(w)),
@@ -679,7 +705,7 @@
 }
 
 
-// Outer product [math.matvec.outer]
+/// Outer product [math.matvec.outer]
 
 /// outer product of two scalar vectors
 template <typename T0,
@@ -708,7 +734,7 @@
 }
 
 
-// Generalized Matrix operations [math.matvec.gem]
+/// Generalized Matrix operations [math.matvec.gem]
 
 /// generalized matrix product
 template <mat_op_type OpA,
@@ -739,6 +765,7 @@
 #endif
 
   // equivalent to C = alpha * OpA(A) * OpB(B) + beta * C
+
   impl::gemp( alpha, 
               impl::apply_mat_op<OpA>(A), 
               impl::apply_mat_op<OpB>(B),
@@ -772,7 +799,7 @@
 }
 
 
-// Miscellaneous functions [math.matvec.misc]
+/// Miscellaneous functions [math.matvec.misc]
 
 /// cumulative sum
 template <dimension_type d,
Index: src/vsip/core/impl_tags.hpp
===================================================================
--- src/vsip/core/impl_tags.hpp	(revision 225932)
+++ src/vsip/core/impl_tags.hpp	(working copy)
@@ -56,6 +56,26 @@
 
 struct Opt_tag {};		// Optimized Tag.
 
+
+namespace dispatcher
+{
+
+// Operation Tags.
+//
+// Each operation (dot-product, matrix-matrix product, etc) has a 
+// unique operation tag.
+
+struct Op_prod_vv_dot;    // vector-vector dot-product
+struct Op_prod_vv_outer;  // vector-vector outer-product
+struct Op_prod_mm;        // matrix-matrix product
+struct Op_prod_mm_conj;   // matrix-matrix conjugate product
+struct Op_prod_mv;        // matrix-vector product
+struct Op_prod_vm;        // vector-matrix product
+struct Op_prod_gemp;      // generalized matrix-matrix product
+
+
+} // namespace vsip::impl::dispatcher
+
 } // namespace vsip::impl
 } // namespace vsip
 
Index: src/vsip/opt/sal/eval_misc.hpp
===================================================================
--- src/vsip/opt/sal/eval_misc.hpp	(revision 225932)
+++ src/vsip/opt/sal/eval_misc.hpp	(working copy)
@@ -18,7 +18,7 @@
   Included Files
 ***********************************************************************/
 
-#include <vsip/opt/general_dispatch.hpp>
+#include <vsip/opt/dispatch.hpp>
 #include <vsip/opt/sal/bindings.hpp>
 
 
@@ -48,17 +48,18 @@
 namespace impl
 {
 
+namespace dispatcher
+{
+
 #if VSIP_IMPL_SAL_USE_MAT_MUL
 
-// SAL evaluator for vector-vector outer product
-
+/// Mercury SAL evaluator for outer product
 template <typename T1,
           typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_vv_outer, Block0,
-		 Op_list_3<T1, Block1 const&, Block2 const&>,
-                 Mercury_sal_tag>
+struct Evaluator<Op_prod_vv_outer, Mercury_sal_tag,
+                 void(Block0&, T1, Block1 const&, Block2 const&)>
 {
   static bool const ct_valid = 
     impl::sal::Sal_traits<T1>::valid &&
@@ -130,13 +131,13 @@
 };
 
 
+/// Mercury SAL evaluator for outer product (with conjugate)
 template <typename T1,
           typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_vv_outer, Block0, 
-                 Op_list_3<std::complex<T1>, Block1 const&, Block2 const&>,
-                 Mercury_sal_tag>
+struct Evaluator<Op_prod_vv_outer, Mercury_sal_tag,
+                 void(Block0&, std::complex<T1>, Block1 const&, Block2 const&)>
 {
   typedef typename Block_layout<Block0>::complex_type complex0_type;
   typedef typename Block_layout<Block1>::complex_type complex1_type;
@@ -221,36 +222,34 @@
 #endif // VSIP_IMPL_SAL_USE_MAT_MUL
 
 
-
-// SAL evaluator for vector-vector dot-product (non-conjugated).
-
+/// Mercury SAL evaluator for vector-vector dot-product.
 template <typename T,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_vv_dot, Return_scalar<T>, Op_list_2<Block1, Block2>,
-                 Mercury_sal_tag>
+          typename Block0,
+          typename Block1>
+struct Evaluator<Op_prod_vv_dot, Mercury_sal_tag,
+                 T(Block0 const&, Block1 const&)>
 {
-  typedef typename Block_layout<Block1>::complex_type complex1_type;
-  typedef typename Block_layout<Block2>::complex_type complex2_type;
+  typedef typename Block_layout<Block0>::complex_type complex1_type;
+  typedef typename Block_layout<Block1>::complex_type complex2_type;
 
   static bool const ct_valid = 
     impl::sal::Sal_traits<T>::valid &&
+    Type_equal<T, typename Block0::value_type>::value &&
     Type_equal<T, typename Block1::value_type>::value &&
-    Type_equal<T, typename Block2::value_type>::value &&
     // check that direct access is supported
+    Ext_data_cost<Block0>::value == 0 &&
     Ext_data_cost<Block1>::value == 0 &&
-    Ext_data_cost<Block2>::value == 0 &&
     // check complex layout is consistent
     Type_equal<complex1_type, complex2_type>::value;
 
-  static bool rt_valid(Block1 const&, Block2 const&) { return true; }
+  static bool rt_valid(Block0 const&, Block1 const&) { return true; }
 
-  static T exec(Block1 const& a, Block2 const& b)
+  static T exec(Block0 const& a, Block1 const& b)
   {
     assert(a.size(1, 0) == b.size(1, 0));
 
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_b(const_cast<Block2&>(b));
+    Ext_data<Block0> ext_a(const_cast<Block0&>(a));
+    Ext_data<Block1> ext_b(const_cast<Block1&>(b));
 
     T r = sal::dot( a.size(1, 0),
                     ext_a.data(), ext_a.stride(0),
@@ -267,11 +266,9 @@
 template <typename T,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_vv_dot, Return_scalar<complex<T> >,
-                 Op_list_2<Block1, 
-                           Unary_expr_block<1, impl::conj_functor,
-                                            Block2, complex<T> > const>,
-                 Mercury_sal_tag>
+struct Evaluator<Op_prod_vv_dot, Mercury_sal_tag,
+                 std::complex<T>(Block1 const&, 
+                   Unary_expr_block<1, conj_functor, Block2, std::complex<T> > const&)>
 {
   typedef typename Block_layout<Block1>::complex_type complex1_type;
   typedef typename Block_layout<Block2>::complex_type complex2_type;
@@ -313,13 +310,12 @@
 
 #if VSIP_IMPL_SAL_USE_MAT_MUL
 
-// SAL evaluator for matrix-vector product
-
+/// Mercury SAL evaluator for matrix-vector products.
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_mv, Block0, Op_list_2<Block1, Block2>,
-                 Mercury_sal_tag>
+struct Evaluator<Op_prod_mv, Mercury_sal_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
 
@@ -393,13 +389,12 @@
 };
 
 
-// SAL evaluator for vector-matrix product
-
+/// Mercury SAL evaluator for vector-matrix products.
 template <typename Block0,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_vm, Block0, Op_list_2<Block1, Block2>,
-                 Mercury_sal_tag>
+	  typename Block1,
+	  typename Block2>
+struct Evaluator<Op_prod_vm, Mercury_sal_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
 
@@ -473,13 +468,12 @@
 };
 
 
-// SAL evaluator for matrix-matrix products.
-
+/// Mercury SAL evaluator for matrix-matrix products.
 template <typename Block0,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_mm, Block0, Op_list_2<Block1, Block2>,
-                 Mercury_sal_tag>
+	  typename Block1,
+	  typename Block2>
+struct Evaluator<Op_prod_mm, Mercury_sal_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
 
@@ -567,13 +561,12 @@
 
 #else // !VSIP_IMPL_SAL_USE_MAT_MUL
 
-// SAL evaluator for matrix-vector product
-
+/// Mercury SAL evaluator for matrix-vector products.
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_mv, Block0, Op_list_2<Block1, Block2>,
-                 Mercury_sal_tag>
+struct Evaluator<Op_prod_mv, Mercury_sal_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
 
@@ -644,13 +637,12 @@
 };
 
 
-// SAL evaluator for vector-matrix product
-
+/// Mercury SAL evaluator for vector-matrix products.
 template <typename Block0,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_vm, Block0, Op_list_2<Block1, Block2>,
-                 Mercury_sal_tag>
+	  typename Block1,
+	  typename Block2>
+struct Evaluator<Op_prod_vm, Mercury_sal_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
 
@@ -721,13 +713,12 @@
 };
 
 
-// SAL evaluator for matrix-matrix products.
-
+/// Mercury SAL evaluator for matrix-matrix products.
 template <typename Block0,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_mm, Block0, Op_list_2<Block1, Block2>,
-                 Mercury_sal_tag>
+	  typename Block1,
+	  typename Block2>
+struct Evaluator<Op_prod_mm, Mercury_sal_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
 
@@ -853,15 +844,14 @@
 
 #if VSIP_IMPL_SAL_USE_MAT_MUL
 
-// SAL evaluator for generalized matrix-matrix products.
-
+/// Mercury SAL evaluator for general product
 template <typename T1,
-          typename T2,
-          typename Block0,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_gemp, Block0, Op_list_4<T1, Block1, Block2, T2>,
-                 Mercury_sal_tag>
+	  typename T2,
+	  typename Block0,
+	  typename Block1,
+	  typename Block2>
+struct Evaluator<Op_prod_gemp, Mercury_sal_tag,
+                 void(Block0&, T1, Block1 const&, Block2 const&, T2)>
 {
   typedef typename Block0::value_type T;
 
@@ -979,6 +969,7 @@
 #endif // VSIP_IMPL_SAL_USE_MAT_MUL
 
 
+} // namespace vsip::impl::dispatcher
 
 } // namespace vsip::impl
 
Index: src/vsip/opt/dispatch.hpp
===================================================================
--- src/vsip/opt/dispatch.hpp	(revision 225932)
+++ src/vsip/opt/dispatch.hpp	(working copy)
@@ -22,9 +22,9 @@
 ***********************************************************************/
 
 #include <vsip/support.hpp>
+#include <vsip/core/dispatch.hpp>
 
 
-
 /***********************************************************************
   Declarations
 ***********************************************************************/
@@ -68,29 +68,7 @@
   typedef None_type type;
 };
 
-//. Define the operation-specific Evaluator signature.
-template <typename O, typename R = void> 
-struct Signature
-{
-  // The default signature is useful for a compile-time check only,
-  // as there are no arguments to inspect at runtime.
-  typedef R(type)();
-};
 
-//. An Evaluator determines whether an Operation can be performed
-//. with a particular backend.
-//.
-//.   O: Operation tag
-//.   B: Backend tag
-//.   S: Signature
-template <typename O,
-          typename B,
-          typename S = typename Signature<O>::type>
-struct Evaluator
-{
-  static bool const ct_valid = false;
-};
-
 //. Provide an operation-specific backend list.
 template <typename O> struct List;
 
Index: src/vsip/opt/cbe/cml/matvec.hpp
===================================================================
--- src/vsip/opt/cbe/cml/matvec.hpp	(revision 225932)
+++ src/vsip/opt/cbe/cml/matvec.hpp	(working copy)
@@ -21,7 +21,7 @@
   Included Files
 ***********************************************************************/
 
-#include <vsip/opt/general_dispatch.hpp>
+#include <vsip/opt/dispatch.hpp>
 #include <vsip/opt/cbe/cml/prod.hpp>
 #include <vsip/opt/cbe/cml/traits.hpp>
 
@@ -36,39 +36,40 @@
 namespace impl
 {
 
+namespace dispatcher 
+{
 
 /// CML evaluator for vector dot products (non-conjugated)
-
 template <typename T,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_vv_dot, Return_scalar<T>, Op_list_2<Block1, Block2>,
-                 Cml_tag>
+          typename Block0,
+          typename Block1>
+struct Evaluator<Op_prod_vv_dot, Cml_tag,
+                 T(Block0 const&, Block1 const&)>
 {
-  typedef typename Block_layout<Block1>::complex_type complex1_type;
-  typedef typename Block_layout<Block2>::complex_type complex2_type;
+  typedef typename Block_layout<Block0>::complex_type complex1_type;
+  typedef typename Block_layout<Block1>::complex_type complex2_type;
 
   static bool const ct_valid = 
     // check that CML supports this data type and/or layout
+    impl::cml::Cml_supports_block<Block0>::valid &&
     impl::cml::Cml_supports_block<Block1>::valid &&
-    impl::cml::Cml_supports_block<Block2>::valid &&
     // check that all data types are equal
+    Type_equal<T, typename Block0::value_type>::value &&
     Type_equal<T, typename Block1::value_type>::value &&
-    Type_equal<T, typename Block2::value_type>::value &&
     // check that direct access is supported
+    Ext_data_cost<Block0>::value == 0 &&
     Ext_data_cost<Block1>::value == 0 &&
-    Ext_data_cost<Block2>::value == 0 &&
     // check complex layout is consistent
-    Is_split_block<Block1>::value == Is_split_block<Block2>::value;
+    Is_split_block<Block0>::value == Is_split_block<Block1>::value;
 
-  static bool rt_valid(Block1 const&, Block2 const&) { return true; }
+  static bool rt_valid(Block0 const&, Block1 const&) { return true; }
 
-  static T exec(Block1 const& a, Block2 const& b)
+  static T exec(Block0 const& a, Block1 const& b)
   {
     assert(a.size(1, 0) == b.size(1, 0));
 
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_b(const_cast<Block2&>(b));
+    Ext_data<Block0> ext_a(const_cast<Block0&>(a));
+    Ext_data<Block1> ext_b(const_cast<Block1&>(b));
 
     T r = T();
     cml::dot( ext_a.data(), ext_a.stride(0),
@@ -80,47 +81,43 @@
 };
 
 
-
 /// CML evaluator for vector dot products (conjugated)
-
 template <typename T,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_vv_dot, Return_scalar<complex<T> >,
-                 Op_list_2<Block1, 
-                           Unary_expr_block<1, impl::conj_functor,
-                                            Block2, complex<T> > const>,
-                 Cml_tag>
+          typename Block0,
+          typename Block1>
+struct Evaluator<Op_prod_vv_dot, Cml_tag,
+                 std::complex<T>(Block0 const&, 
+                   Unary_expr_block<1, conj_functor, Block1, std::complex<T> > const&)>
 {
-  typedef typename Block_layout<Block1>::complex_type complex1_type;
-  typedef typename Block_layout<Block2>::complex_type complex2_type;
+  typedef typename Block_layout<Block0>::complex_type complex1_type;
+  typedef typename Block_layout<Block1>::complex_type complex2_type;
 
   static bool const ct_valid = 
     // check that CML supports this data type and/or layout
+    impl::cml::Cml_supports_block<Block0>::valid &&
     impl::cml::Cml_supports_block<Block1>::valid &&
-    impl::cml::Cml_supports_block<Block2>::valid &&
     // check that types are complex
+    Is_complex<typename Block0::value_type>::value &&
     Is_complex<typename Block1::value_type>::value &&
-    Is_complex<typename Block2::value_type>::value &&
     // check that direct access is supported
+    Ext_data_cost<Block0>::value == 0 &&
     Ext_data_cost<Block1>::value == 0 &&
-    Ext_data_cost<Block2>::value == 0 &&
     // check complex layout is consistent
-    Is_split_block<Block1>::value == Is_split_block<Block2>::value;
+    Is_split_block<Block0>::value == Is_split_block<Block1>::value;
 
   static bool rt_valid(
-    Block1 const&, 
-    Unary_expr_block<1, impl::conj_functor, Block2, complex<T> > const&)
+    Block0 const&, 
+    Unary_expr_block<1, impl::conj_functor, Block1, complex<T> > const&)
   { return true; }
 
   static complex<T> exec(
-    Block1 const& a, 
-    Unary_expr_block<1, impl::conj_functor, Block2, complex<T> > const& b)
+    Block0 const& a, 
+    Unary_expr_block<1, impl::conj_functor, Block1, complex<T> > const& b)
   {
     assert(a.size(1, 0) == b.size(1, 0));
 
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_b(const_cast<Block2&>(b.op()));
+    Ext_data<Block0> ext_a(const_cast<Block0&>(a));
+    Ext_data<Block1> ext_b(const_cast<Block1&>(b.op()));
 
     complex<T> r = complex<T>();
     cml::dotc( ext_a.data(), ext_a.stride(0),
@@ -133,14 +130,12 @@
 
 
 /// CML evaluator for outer products
-
 template <typename T1,
           typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_vv_outer, Block0,
-		 Op_list_3<T1, Block1 const&, Block2 const&>,
-                 Cml_tag>
+struct Evaluator<Op_prod_vv_outer, Cml_tag,
+                 void(Block0&, T1, Block1 const&, Block2 const&)>
 {
   typedef typename Block_layout<Block0>::order_type order0_type;
 
@@ -201,9 +196,8 @@
           typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_vv_outer, Block0,
-		 Op_list_3<std::complex<T1>, Block1 const&, Block2 const&>,
-                 Cml_tag>
+struct Evaluator<Op_prod_vv_outer, Cml_tag,
+                 void(Block0&, std::complex<T1>, Block1 const&, Block2 const&)>
 {
   typedef typename Block_layout<Block0>::order_type order0_type;
 
@@ -260,14 +254,12 @@
 };
 
 
-
 /// CML evaluator for matrix-vector products
-
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_mv, Block0, Op_list_2<Block1, Block2>,
-                 Cml_tag>
+struct Evaluator<Op_prod_mv, Cml_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
   typedef typename Block_layout<Block1>::order_type order1_type;
@@ -336,12 +328,11 @@
 
 
 /// CML evaluator for vector-matrix products
-
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_vm, Block0, Op_list_2<Block1, Block2>,
-                 Cml_tag>
+struct Evaluator<Op_prod_vm, Cml_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
   typedef typename Block_layout<Block2>::order_type order2_type;
@@ -409,14 +400,12 @@
 };
 
 
-
 /// CML evaluator for matrix-matrix products
-
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_mm, Block0, Op_list_2<Block1, Block2>,
-                 Cml_tag>
+struct Evaluator<Op_prod_mm, Cml_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
   typedef typename Block_layout<Block0>::order_type order0_type;
@@ -496,12 +485,11 @@
 
 
 /// CML evaluator for matrix-matrix conjugate products
-
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_mm_conj, Block0, Op_list_2<Block1, Block2>,
-                 Cml_tag>
+struct Evaluator<Op_prod_mm_conj, Cml_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
   typedef typename Block_layout<Block0>::order_type order0_type;
@@ -580,6 +568,8 @@
 };
 
 
+} // namespace vsip::impl::dispatcher
+
 } // namespace vsip::impl
 
 } // namespace vsip
Index: src/vsip/opt/lapack/matvec.hpp
===================================================================
--- src/vsip/opt/lapack/matvec.hpp	(revision 225932)
+++ src/vsip/opt/lapack/matvec.hpp	(working copy)
@@ -22,7 +22,7 @@
   Included Files
 ***********************************************************************/
 
-#include <vsip/opt/general_dispatch.hpp>
+#include <vsip/opt/dispatch.hpp>
 #include <vsip/opt/lapack/bindings.hpp>
 
 
@@ -33,19 +33,18 @@
 
 namespace vsip
 {
-
 namespace impl
 {
+namespace dispatcher
+{
 
-// BLAS evaluator for vector-vector outer product
-
+/// BLAS evaluator for vector-vector outer product
 template <typename T1,
 	  typename Block0,
 	  typename Block1,
 	  typename Block2>
-struct Evaluator<Op_prod_vv_outer, Block0,
-		 Op_list_3<T1, Block1 const&, Block2 const&>,
-		 Blas_tag>
+struct Evaluator<Op_prod_vv_outer, Blas_tag,
+                 void(Block0&, T1, Block1 const&, Block2 const&)>
 {
   static bool const ct_valid = 
     impl::blas::Blas_traits<T1>::valid &&
@@ -109,9 +108,8 @@
 	  typename Block0,
 	  typename Block1,
 	  typename Block2>
-struct Evaluator<Op_prod_vv_outer, Block0, 
-                 Op_list_3<std::complex<T1>, Block1 const&, Block2 const&>,
-		 Blas_tag>
+struct Evaluator<Op_prod_vv_outer, Blas_tag,
+                 void(Block0&, std::complex<T1>, Block1 const&, Block2 const&)>
 {
   static bool const ct_valid = 
     impl::blas::Blas_traits<std::complex<T1> >::valid &&
@@ -187,33 +185,32 @@
 };
 
 
-// BLAS evaluator for vector-vector dot-product (non-conjugated).
-
+/// BLAS evaluator for vector-vector dot-product (non-conjugated).
 template <typename T,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_vv_dot, Return_scalar<T>, Op_list_2<Block1, Block2>,
-                 Blas_tag>
+          typename Block0,
+          typename Block1>
+struct Evaluator<Op_prod_vv_dot, Blas_tag,
+                 T(Block0 const&, Block1 const&)>
 {
   static bool const ct_valid = 
     impl::blas::Blas_traits<T>::valid &&
+    Type_equal<T, typename Block0::value_type>::value &&
     Type_equal<T, typename Block1::value_type>::value &&
-    Type_equal<T, typename Block2::value_type>::value &&
     // check that direct access is supported
+    Ext_data_cost<Block0>::value == 0 &&
     Ext_data_cost<Block1>::value == 0 &&
-    Ext_data_cost<Block2>::value == 0 &&
     // check that format is interleaved.
-    !Is_split_block<Block1>::value &&
-    !Is_split_block<Block2>::value;
+    !Is_split_block<Block0>::value &&
+    !Is_split_block<Block1>::value;
 
-  static bool rt_valid(Block1 const&, Block2 const&) { return true; }
+  static bool rt_valid(Block0 const&, Block1 const&) { return true; }
 
-  static T exec(Block1 const& a, Block2 const& b)
+  static T exec(Block0 const& a, Block1 const& b)
   {
     assert(a.size(1, 0) == b.size(1, 0));
 
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_b(const_cast<Block2&>(b));
+    Ext_data<Block0> ext_a(const_cast<Block0&>(a));
+    Ext_data<Block1> ext_b(const_cast<Block1&>(b));
 
     T r = blas::dot(a.size(1, 0),
                     ext_a.data(), ext_a.stride(0),
@@ -224,42 +221,38 @@
 };
 
 
-
-// BLAS evaluator for vector-vector dot-product (conjugated).
-
+/// BLAS evaluator for vector-vector dot-product (conjugated).
 template <typename T,
-          typename Block1,
-          typename Block2>
-struct Evaluator<Op_prod_vv_dot, Return_scalar<complex<T> >,
-                 Op_list_2<Block1, 
-                           Unary_expr_block<1, impl::conj_functor,
-                                            Block2, complex<T> > const>,
-                 Blas_tag>
+          typename Block0,
+          typename Block1>
+struct Evaluator<Op_prod_vv_dot, Blas_tag,
+                 std::complex<T>(Block0 const&, 
+                   Unary_expr_block<1, conj_functor, Block1, std::complex<T> > const&)>
 {
   static bool const ct_valid = 
     impl::blas::Blas_traits<complex<T> >::valid &&
+    Type_equal<complex<T>, typename Block0::value_type>::value &&
     Type_equal<complex<T>, typename Block1::value_type>::value &&
-    Type_equal<complex<T>, typename Block2::value_type>::value &&
     // check that direct access is supported
+    Ext_data_cost<Block0>::value == 0 &&
     Ext_data_cost<Block1>::value == 0 &&
-    Ext_data_cost<Block2>::value == 0 &&
     // check that format is interleaved.
-    !Is_split_block<Block1>::value &&
-    !Is_split_block<Block2>::value;
+    !Is_split_block<Block0>::value &&
+    !Is_split_block<Block1>::value;
 
   static bool rt_valid(
-    Block1 const&, 
-    Unary_expr_block<1, impl::conj_functor, Block2, complex<T> > const&)
+    Block0 const&, 
+    Unary_expr_block<1, impl::conj_functor, Block1, complex<T> > const&)
   { return true; }
 
   static complex<T> exec(
-    Block1 const& a, 
-    Unary_expr_block<1, impl::conj_functor, Block2, complex<T> > const& b)
+    Block0 const& a, 
+    Unary_expr_block<1, impl::conj_functor, Block1, complex<T> > const& b)
   {
     assert(a.size(1, 0) == b.size(1, 0));
 
-    Ext_data<Block1> ext_a(const_cast<Block1&>(a));
-    Ext_data<Block2> ext_b(const_cast<Block2&>(b.op()));
+    Ext_data<Block0> ext_a(const_cast<Block0&>(a));
+    Ext_data<Block1> ext_b(const_cast<Block1&>(b.op()));
 
     return blas::dotc(a.size(1, 0),
                       ext_b.data(), ext_b.stride(0),
@@ -271,13 +264,12 @@
 };
 
 
-
-// BLAS evaluator for matrix-vector product
+/// BLAS evaluator for matrix-vector product
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_mv, Block0, Op_list_2<Block1, Block2>,
-                 Blas_tag>
+struct Evaluator<Op_prod_mv, Blas_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
 
@@ -361,12 +353,12 @@
 };
 
 
-// BLAS evaluator for vector-matrix product
+/// BLAS evaluator for vector-matrix product
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_vm, Block0, Op_list_2<Block1, Block2>,
-                 Blas_tag>
+struct Evaluator<Op_prod_vm, Blas_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
 
@@ -451,13 +443,12 @@
 };
 
 
-// BLAS evaluator for matrix-matrix products.
-
+/// BLAS evaluator for matrix-matrix products.
 template <typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_mm, Block0, Op_list_2<Block1, Block2>,
-                 Blas_tag>
+struct Evaluator<Op_prod_mm, Blas_tag,
+                 void(Block0&, Block1 const&, Block2 const&)>
 {
   typedef typename Block0::value_type T;
 
@@ -561,15 +552,14 @@
 };
 
 
-// BLAS evaluator for generalized matrix-matrix products.
-
+/// BLAS evaluator for generalized matrix-matrix products.
 template <typename T1,
 	  typename T2,
 	  typename Block0,
           typename Block1,
           typename Block2>
-struct Evaluator<Op_prod_gemp, Block0, Op_list_4<T1, Block1, Block2, T2>,
-                 Blas_tag>
+struct Evaluator<Op_prod_gemp, Blas_tag,
+                 void(Block0&, T1, Block1 const&, Block2 const&, T2)>
 {
   typedef typename Block0::value_type T;
 
@@ -663,10 +653,8 @@
 };
 
 
-
-
+} // namespace vsip::impl::dispatcher
 } // namespace vsip::impl
-
 } // namespace vsip
 
 #endif // VSIP_OPT_LAPACK_MATVEC_HPP
Index: tests/matvec.cpp
===================================================================
--- tests/matvec.cpp	(revision 225932)
+++ tests/matvec.cpp	(working copy)
@@ -117,9 +117,7 @@
 void
 Check_gem_results( Matrix<T> actual, Matrix<T> expected )
 {
-  for ( index_type row = 0; row < actual.size(0); ++row )
-    for ( index_type col = 0; col < actual.size(1); ++col )
-      test_assert( equal( actual.get(row, col), expected.get(row, col) ) );
+  test_assert( error_db(actual, expected) < -100 );
 }
 
 
