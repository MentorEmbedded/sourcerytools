Index: ChangeLog
===================================================================
--- ChangeLog	(revision 148934)
+++ ChangeLog	(working copy)
@@ -1,3 +1,18 @@
+2006-09-11  Stefan Seefeld  <stefan@codesourcery.com>
+
+	* configure.ac: Fix handling of 'mpicxx -show'; add --with-qmtest.
+	* GNUmakefile.in: Define QMTEST variable.
+	* tests/GNUmakefile.inc.in: Use it.
+	* src/vsip/impl/fns_elementwise.hpp: Fix for icl.
+	* src/vsip/impl/signal-iir.hpp: Add missing include.
+	* src/vsip/impl/layout.hpp: Make Rt_allocated_storage non-copyable.
+	* src/vsip/impl/rt_extdata.hpp: Avoid temporary copy (and fix bug).
+	* src/vsip/impl/inttypes.hpp: Add our own fixed-size integral types.
+	* src/vsip_csl/matlab_file.cpp: Use them.
+	* src/vsip_csl/matlab_file.hpp: Likewise.
+	* src/vsip_csl/matlab.hpp: Likewise.
+	* src/vsip_csl/matlab_bin_formatter.hpp: Likewises.
+	
 2006-09-07  Stefan Seefeld  <stefan@codesourcery.com>
 
 	* src/vsip/support.hpp: Define VSIP_HAS_EXCEPTIONS appropriately when
Index: src/vsip/impl/signal-iir.hpp
===================================================================
--- src/vsip/impl/signal-iir.hpp	(revision 148934)
+++ src/vsip/impl/signal-iir.hpp	(working copy)
@@ -15,8 +15,8 @@
 
 #include <vsip/support.hpp>
 #include <vsip/impl/signal-types.hpp>
+#include <vsip/impl/profile.hpp>
 
-
 #if (VSIP_IMPL_PROFILER & VSIP_IMPL_PROFILER_SIGNAL)
 #define VSIP_IMPL_PROFILING_FEATURE_ENABLED   1
 #else
Index: src/vsip/impl/layout.hpp
===================================================================
--- src/vsip/impl/layout.hpp	(revision 148934)
+++ src/vsip/impl/layout.hpp	(working copy)
@@ -19,8 +19,8 @@
 #include <vsip/impl/length.hpp>
 #include <vsip/impl/aligned_allocator.hpp>
 #include <vsip/impl/metaprogramming.hpp>
+#include <vsip/impl/noncopyable.hpp>
 
-
 /***********************************************************************
   Declarations
 ***********************************************************************/
@@ -1261,7 +1261,7 @@
 // Allocated storage, with complex format determined at run-time.
 
 template <typename T>
-class Rt_allocated_storage
+class Rt_allocated_storage : Non_copyable
 {
   // Compile-time values and types.
 public:
@@ -1345,11 +1345,6 @@
     }
   }
 
-  // Fast-path Constructor for unused object.
-  Rt_allocated_storage(empty_layout_type)
-    : state_ (no_data)
-  {}
-
   Rt_allocated_storage(length_type     size,
 		       rt_complex_type cformat,
 		       type            buffer = type())
Index: src/vsip/impl/inttypes.hpp
===================================================================
--- src/vsip/impl/inttypes.hpp	(revision 0)
+++ src/vsip/impl/inttypes.hpp	(revision 0)
@@ -0,0 +1,75 @@
+/* Copyright (c) 2006 by CodeSourcery, Inc.  All rights reserved. */
+
+/** @file    vsip/impl/inttypes.hpp
+    @author  Stefan Seefeld
+    @date    2006-09-11
+    @brief   VSIPL++ CodeSourcery Library: Fixed-size integral type definitions.
+*/
+
+#ifndef VSIP_IMPL_INTTYPES_HPP
+#define VSIP_IMPL_INTTYPES_HPP
+
+#include <vsip/impl/config.hpp>
+
+#if HAVE_STDINT_H
+# include <stdint.h>
+#endif
+
+namespace vsip
+{
+namespace impl
+{
+#if HAVE_STDINT_H
+  typedef int8_t int8_type;
+  typedef uint8_t uint8_type;
+  typedef int16_t int16_type;
+  typedef uint16_t uint16_type;
+  typedef int32_t int32_type;
+  typedef uint32_t uint32_type;
+  typedef uint64_t uint64_type;
+#else
+
+# if SIZEOF_CHAR == 1
+  typedef signed char int8_type;
+  typedef unsigned char uint8_type;
+# else
+#  error "No 8-bit integer type"
+# endif
+
+# if SIZEOF_SHORT == 2
+  typedef short int16_type;
+  typedef unsigned short uint16_type;
+# elif SIZEOF_INT == 2
+  typedef int int16_type;
+  typedef unsigned int uint16_type;
+# else
+#  error "No 16-bit integer type"
+# endif
+
+# if SIZEOF_SHORT == 4
+  typedef unsigned short uint32_type;
+  typedef short int32_type;
+# elif SIZEOF_INT == 4
+  typedef unsigned int uint32_type;
+  typedef int int32_type;
+# elif SIZEOF_LONG == 4
+  typedef unsigned long uint32_type;
+  typedef long int32_type;
+# else
+#  error "No 32-bit integer type"
+# endif
+
+# if SIZEOF_INT == 8
+  typedef int uint64_type;
+# elif SIZEOF_LONG == 8
+  typedef long uint64_type;
+# elif SIZEOF_LONG_LONG == 8
+  typedef long long uint64_type;
+# else
+#  error "No 64-bit integer type"
+# endif
+#endif 
+}
+}
+
+#endif
Index: src/vsip/impl/fns_elementwise.hpp
===================================================================
--- src/vsip/impl/fns_elementwise.hpp	(revision 148934)
+++ src/vsip/impl/fns_elementwise.hpp	(working copy)
@@ -170,7 +170,7 @@
 { return Dispatch_op_##fname<LView<T1, Block1>,                           \
                              RView<T2, Block2> >::apply(t1, t2);}
 
-#if (defined(__GNUC__) && __GNUC__ < 4) || defined(__ghs__)
+#if (defined(__GNUC__) && __GNUC__ < 4) || defined(__ghs__) || defined(__ICL)
 # define VSIP_IMPL_BINARY_OPERATOR(op, fname)                             \
 VSIP_IMPL_BINARY_OPERATOR_ONE(op, fname)
 #else
Index: src/vsip/impl/rt_extdata.hpp
===================================================================
--- src/vsip/impl/rt_extdata.hpp	(revision 148934)
+++ src/vsip/impl/rt_extdata.hpp	(working copy)
@@ -326,9 +326,7 @@
 		Applied_layout<Rt_layout<Dim> >(empty_layout) :
 		Applied_layout<Rt_layout<Dim> >(
 		  rtl, extent<dim>(blk), sizeof(value_type))),
-    storage_   (use_direct_ ?
-		storage_type(empty_layout) :
-		storage_type(app_layout_.total_size(), rtl.complex, buffer))
+    storage_(use_direct_ ? 0 : app_layout_.total_size(), rtl.complex, buffer)
   {}
 
   ~Rt_low_level_data_access()
Index: src/vsip_csl/matlab_file.cpp
===================================================================
--- src/vsip_csl/matlab_file.cpp	(revision 148934)
+++ src/vsip_csl/matlab_file.cpp	(working copy)
@@ -26,7 +26,7 @@
     std::istream::off_type temp_offset = 0;
     std::istream::pos_type temp_pos = is_.tellg();
     is_.seekg(temp_offset,std::ios::end);
-    length_ = static_cast<uint32_t>(is_.tellg());
+    length_ = static_cast<vsip::impl::uint32_type>(is_.tellg());
     is_.seekg(temp_pos);
   }
   view_header_.swap_bytes = matlab_header_.endian == ('I' << 8|'M');
Index: src/vsip_csl/matlab_file.hpp
===================================================================
--- src/vsip_csl/matlab_file.hpp	(revision 148934)
+++ src/vsip_csl/matlab_file.hpp	(working copy)
@@ -119,7 +119,7 @@
     Matlab_view_header view_header_;
     bool read_data_;
     bool end_of_file_;
-    uint32_t length_;
+    vsip::impl::uint32_type length_;
 
 };
 
@@ -134,6 +134,14 @@
 	  template <typename,typename> class View>
 void Matlab_file::read_view(View<T,Block0> view, iterator  &iter)
 {
+  typedef vsip::impl::int8_type int8_type;
+  typedef vsip::impl::uint8_type uint8_type;
+  typedef vsip::impl::int16_type int16_type;
+  typedef vsip::impl::uint16_type uint16_type;
+  typedef vsip::impl::int32_type int32_type;
+  typedef vsip::impl::uint32_type uint32_type;
+  typedef vsip::impl::uint64_type uint64_type;
+
   typedef typename vsip::impl::Scalar_of<T>::type scalar_type;
   vsip::dimension_type v_dim = vsip::impl::Dim_of_view<View>::dim;
   Matlab_view_header *header = *iter;
@@ -191,51 +199,67 @@
             sizeof(temp_data_element));
 
     // should we swap this field?
-    matlab::swap<int32_t>(&(temp_data_element.type),swap_value);
-    matlab::swap<uint32_t>(&(temp_data_element.size),swap_value);
+    matlab::swap<int32_type>(&(temp_data_element.type),swap_value);
+    matlab::swap<uint32_type>(&(temp_data_element.size),swap_value);
 
 
     // Because we don't know how the data was stored, we need to instantiate
     // generic_reader which can read a type and cast into a different one
     if(temp_data_element.type == matlab::miINT8) 
     {
-      if(i==0)matlab::read<int8_t,r_v>(*is,subview::real(view),swap_value);
-      else    matlab::read<int8_t,i_v>(*is,subview::imag(view),swap_value);
+      if(i==0)
+        matlab::read<int8_type, r_v>(*is, subview::real(view), swap_value);
+      else
+        matlab::read<int8_type, i_v>(*is, subview::imag(view), swap_value);
     }
     else if(temp_data_element.type == matlab::miUINT8) 
     {
-      if(i==0)matlab::read<uint8_t,r_v>(*is,subview::real(view),swap_value);
-      else    matlab::read<uint8_t,i_v>(*is,subview::imag(view),swap_value);
+      if(i==0)
+        matlab::read<uint8_type, r_v>(*is, subview::real(view), swap_value);
+      else
+        matlab::read<uint8_type, i_v>(*is, subview::imag(view), swap_value);
     }
     else if(temp_data_element.type == matlab::miINT16) 
     {
-      if(i==0)matlab::read<int16_t,r_v>(*is,subview::real(view),swap_value);
-      else    matlab::read<int16_t,i_v>(*is,subview::imag(view),swap_value);
+      if(i==0)
+        matlab::read<int16_type, r_v>(*is, subview::real(view), swap_value);
+      else   
+        matlab::read<int16_type, i_v>(*is, subview::imag(view), swap_value);
     }
     else if(temp_data_element.type == matlab::miUINT16) 
-    {
-      if(i==0)matlab::read<uint16_t,r_v>(*is,subview::real(view),swap_value);
-      else    matlab::read<uint16_t,i_v>(*is,subview::imag(view),swap_value);
+      {
+      if(i==0)
+        matlab::read<uint16_type, r_v>(*is, subview::real(view), swap_value);
+      else
+        matlab::read<uint16_type, i_v>(*is, subview::imag(view), swap_value);
     }
     else if(temp_data_element.type == matlab::miINT32) 
     {
-      if(i==0)matlab::read<int32_t,r_v>(*is,subview::real(view),swap_value);
-      else    matlab::read<int32_t,i_v>(*is,subview::imag(view),swap_value);
+      if(i==0)
+        matlab::read<int32_type, r_v>(*is, subview::real(view), swap_value);
+      else
+        matlab::read<int32_type, i_v>(*is, subview::imag(view), swap_value);
     }
     else if(temp_data_element.type == matlab::miUINT32) 
     {
-      if(i==0)matlab::read<uint32_t,r_v>(*is,subview::real(view),swap_value);
-      else    matlab::read<uint32_t,i_v>(*is,subview::imag(view),swap_value);
+      if(i==0)
+        matlab::read<uint32_type, r_v>(*is, subview::real(view), swap_value);
+      else
+        matlab::read<uint32_type, i_v>(*is, subview::imag(view), swap_value);
     }
     else if(temp_data_element.type == matlab::miSINGLE) 
-    {
-      if(i==0)matlab::read<float,r_v>(*is,subview::real(view),swap_value);
-      else    matlab::read<float,i_v>(*is,subview::imag(view),swap_value);
+      {
+      if(i==0)
+        matlab::read<float, r_v>(*is, subview::real(view), swap_value);
+      else
+        matlab::read<float, i_v>(*is, subview::imag(view), swap_value);
     }
     else
     {
-      if(i==0)matlab::read<double,r_v>(*is,subview::real(view),swap_value);
-      else    matlab::read<double,i_v>(*is,subview::imag(view),swap_value);
+      if(i==0)
+        matlab::read<double, r_v>(*is, subview::real(view), swap_value);
+      else
+        matlab::read<double, i_v>(*is, subview::imag(view), swap_value);
     }
 
   }
Index: src/vsip_csl/matlab.hpp
===================================================================
--- src/vsip_csl/matlab.hpp	(revision 148934)
+++ src/vsip_csl/matlab.hpp	(working copy)
@@ -1,13 +1,13 @@
 #ifndef VSIP_CSL_MATLAB_HPP
 #define VSIP_CSL_MATLAB_HPP
 
-#include <stdint.h>
-#include <iostream>
 #include <vsip/support.hpp>
 #include <vsip/impl/metaprogramming.hpp>
 #include <vsip/impl/fns_elementwise.hpp>
 #include <vsip/impl/length.hpp>
 #include <vsip/impl/domain-utils.hpp>
+#include <vsip/impl/inttypes.hpp>
+#include <iostream>
 
 namespace vsip_csl
 {
@@ -16,8 +16,8 @@
 {
   struct data_element
   {
-    int32_t type;
-    uint32_t size;
+    vsip::impl::int32_type type;
+    vsip::impl::uint32_type size;
   };
 
   template <vsip::dimension_type Dim>
@@ -25,13 +25,14 @@
   {
     data_element header;
     data_element array_flags_header;
-    uint32_t array_flags[2];
+    vsip::impl::uint32_type array_flags[2];
     data_element dim_header;
-    uint32_t dim[Dim + Dim%2];//the dim has to be aligned to an 8 byte boundary
+    // The dimension has to be aligned to an 8 byte boundary.
+    vsip::impl::uint32_type dim[Dim + Dim%2];
     data_element array_name_header;
   };
 
-  // helper struct to get the imaginary part of a view.
+  // Helper struct to get the imaginary part of a view.
   template <typename ViewT,
             bool IsComplex =
 	      vsip::impl::Is_complex<typename ViewT::value_type>::value>
@@ -113,19 +114,21 @@
   {
     if(swap_bytes)
     {
+      typedef vsip::impl::int32_type int32_type;
+      typedef vsip::impl::uint32_type uint32_type;
       // swap all fields
-      Swap_value<int32_t,true>::swap(&(header.header.type));
-      Swap_value<uint32_t,true>::swap(&(header.header.size));
-      Swap_value<int32_t,true>::swap(&(header.array_flags_header.type));
-      Swap_value<uint32_t,true>::swap(&(header.array_flags_header.size));
-      Swap_value<int32_t,true>::swap(&(header.dim_header.type));
-      Swap_value<uint32_t,true>::swap(&(header.dim_header.size));
-      Swap_value<int32_t,true>::swap(&(header.array_name_header.type));
-      Swap_value<uint32_t,true>::swap(&(header.array_name_header.size));
+      Swap_value<int32_type,true>::swap(&(header.header.type));
+      Swap_value<uint32_type,true>::swap(&(header.header.size));
+      Swap_value<int32_type,true>::swap(&(header.array_flags_header.type));
+      Swap_value<uint32_type,true>::swap(&(header.array_flags_header.size));
+      Swap_value<int32_type,true>::swap(&(header.dim_header.type));
+      Swap_value<uint32_type,true>::swap(&(header.dim_header.size));
+      Swap_value<int32_type,true>::swap(&(header.array_name_header.type));
+      Swap_value<uint32_type,true>::swap(&(header.array_name_header.size));
       for(vsip::index_type i=0;i<dim;i++)
-        Swap_value<uint32_t,true>::swap(&(header.dim[i]));
+        Swap_value<uint32_type,true>::swap(&(header.dim[i]));
       for(vsip::index_type i=0;i<2;i++)
-        Swap_value<uint32_t,true>::swap(&(header.array_flags[i]));
+        Swap_value<uint32_type,true>::swap(&(header.array_flags[i]));
     }
   }
 
@@ -186,7 +189,7 @@
     char description[116];
     char subsyt_data[8];
     char version[2];
-    uint16_t endian;
+    vsip::impl::uint16_type endian;
   };
 
   // constants for matlab binary format
@@ -231,56 +234,56 @@
   struct Matlab_header_traits<1, true, true> // char
   { 
     static int const value_type = miINT8;
-    static uint8_t const class_type = mxINT8_CLASS; 
+    static vsip::impl::uint8_type const class_type = mxINT8_CLASS; 
   };
 
   template <>
   struct Matlab_header_traits<1, false, true> // unsigned char
   { 
     static int const value_type = miUINT8;
-    static uint8_t const class_type = mxUINT8_CLASS; 
+    static vsip::impl::uint8_type const class_type = mxUINT8_CLASS; 
   };
 
   template <>
   struct Matlab_header_traits<2, true, true> // short
   { 
     static int const value_type = miINT16;
-    static uint8_t const class_type = mxINT16_CLASS; 
+    static vsip::impl::uint8_type const class_type = mxINT16_CLASS; 
   };
 
   template <>
   struct Matlab_header_traits<2, false, true> // unsigned short
   { 
     static int const value_type = miUINT16;
-    static uint8_t const class_type = mxUINT16_CLASS; 
+    static vsip::impl::uint8_type const class_type = mxUINT16_CLASS; 
   };
 
   template <>
   struct Matlab_header_traits<4, true, true> // int
   { 
     static int const value_type= miINT32;
-    static uint8_t const class_type= mxINT32_CLASS;
+    static vsip::impl::uint8_type const class_type= mxINT32_CLASS;
   };
 
   template <>
   struct Matlab_header_traits<4, false, true> // unsigned int
   { 
     static int const value_type= miUINT32;
-    static uint8_t const class_type= mxUINT32_CLASS;
+    static vsip::impl::uint8_type const class_type= mxUINT32_CLASS;
   };
 
   template <>
   struct Matlab_header_traits<4, true, false> // float
   { 
     static int const value_type= miSINGLE;
-    static uint8_t const class_type= mxSINGLE_CLASS;
+    static vsip::impl::uint8_type const class_type= mxSINGLE_CLASS;
   };
 
   template <>
   struct Matlab_header_traits<8, true, false> // double
   { 
     static int const value_type= miDOUBLE;
-    static uint8_t const class_type= mxDOUBLE_CLASS;
+    static vsip::impl::uint8_type const class_type= mxDOUBLE_CLASS;
   };
 
   // matlab desired layouts
Index: src/vsip_csl/matlab_bin_formatter.hpp
===================================================================
--- src/vsip_csl/matlab_bin_formatter.hpp	(revision 148934)
+++ src/vsip_csl/matlab_bin_formatter.hpp	(working copy)
@@ -9,15 +9,14 @@
 #ifndef VSIP_CSL_MATLAB_BIN_FORMATTER_HPP
 #define VSIP_CSL_MATLAB_BIN_FORMATTER_HPP
 
-#include <stdint.h>
-#include <string>
-#include <limits>
 #include <vsip_csl/matlab.hpp>
 #include <vsip/impl/fns_scalar.hpp>
 #include <vsip/impl/fns_elementwise.hpp>
 #include <vsip/impl/metaprogramming.hpp>
 #include <vsip/impl/view_traits.hpp>
 #include <vsip/impl/extdata.hpp>
+#include <string>
+#include <limits>
 
 namespace vsip_csl
 {
@@ -32,7 +31,7 @@
     // description
     std::string description;
     std::string version;
-    uint16_t endian;
+    vsip::impl::uint16_type endian;
 
   };
 
@@ -53,13 +52,13 @@
 
   struct Matlab_view_header
   {
-    bool        swap_bytes;
-    char        array_name[128];
-    bool        is_complex;
-    uint8_t     class_type;
-    uint32_t    num_dims;
-    uint32_t    dims[3]; // max dimensions
-    std::istream::pos_type next_header;
+    bool                    swap_bytes;
+    char                    array_name[128];
+    bool                    is_complex;
+    vsip::impl::uint8_type  class_type;
+    vsip::impl::uint32_type num_dims;
+    vsip::impl::uint32_type dims[3]; // max dimensions
+    std::istream::pos_type  next_header;
   };
 
 
@@ -254,8 +253,8 @@
   Matlab_view_header      &h)
 {
 
-  uint32_t array_flags[2];
-  uint32_t dims[3];
+  vsip::impl::uint32_type array_flags[2];
+  vsip::impl::uint32_type dims[3];
   matlab::data_element temp_element;
   bool swap_bytes;
   typedef vsip::index_type index_type;
@@ -266,7 +265,7 @@
 
   // header
   is.read(reinterpret_cast<char*>(&temp_element),sizeof(temp_element));
-  matlab::swap<uint32_t>(&(temp_element.size),swap_bytes);
+  matlab::swap<vsip::impl::uint32_type>(&(temp_element.size),swap_bytes);
   // store the file position of next header
   {
     std::istream::pos_type curr_pos = is.tellg();
@@ -276,23 +275,23 @@
 
   // array_flags
   is.read(reinterpret_cast<char*>(&temp_element),sizeof(temp_element));
-  matlab::swap<uint32_t>(&(temp_element.size),swap_bytes);
+  matlab::swap<vsip::impl::uint32_type>(&(temp_element.size),swap_bytes);
   if(temp_element.size > 8)
     VSIP_IMPL_THROW(std::runtime_error(
       "Lenght of array flags is too large"));
   is.read(reinterpret_cast<char*>(&array_flags),temp_element.size);
   for(index_type i=0;i<temp_element.size/4;i++)
-    matlab::swap<uint32_t>(&(dims[i]),swap_bytes);
+    matlab::swap<vsip::impl::uint32_type>(&(dims[i]),swap_bytes);
 
   // read dimensions
   is.read(reinterpret_cast<char*>(&temp_element),sizeof(temp_element));
-  matlab::swap<uint32_t>(&(temp_element.size),swap_bytes);
+  matlab::swap<vsip::impl::uint32_type>(&(temp_element.size),swap_bytes);
   if(temp_element.size > 12)
     VSIP_IMPL_THROW(std::runtime_error(
       "Lenght of dims is too large"));
   is.read(reinterpret_cast<char*>(&dims),temp_element.size);
   for(index_type i=0;i<temp_element.size/4;i++)
-    matlab::swap<uint32_t>(&(dims[i]),swap_bytes);
+    matlab::swap<vsip::impl::uint32_type>(&(dims[i]),swap_bytes);
 
   // read padding
   for(length_type i=0;i< ((8-temp_element.size)&0x7);i++)
@@ -307,8 +306,8 @@
 
   // read array name
   is.read(reinterpret_cast<char*>(&temp_element),sizeof(temp_element));
-  matlab::swap<int32_t>(&(temp_element.type),swap_bytes);
-  matlab::swap<uint32_t>(&(temp_element.size),swap_bytes);
+  matlab::swap<vsip::impl::int32_type>(&(temp_element.type),swap_bytes);
+  matlab::swap<vsip::impl::uint32_type>(&(temp_element.size),swap_bytes);
   if(temp_element.type & 0xffff0000)
   {
     // array name is short
@@ -352,7 +351,7 @@
   typedef typename subview::realview_type r_v;
   typedef typename subview::imagview_type i_v;
   vsip::dimension_type v_dim = vsip::impl::Dim_of_view<View>::dim;
-  uint16_t endian = mbf.header.endian;
+  vsip::impl::uint16_type endian = mbf.header.endian;
   bool swap_value;
 
   if(endian == ('I'<<8 | 'M')) swap_value = true;
@@ -425,51 +424,91 @@
             sizeof(temp_data_element));
 
     // should we swap this field?
-    matlab::swap<int32_t>(&(temp_data_element.type),swap_value);
-    matlab::swap<uint32_t>(&(temp_data_element.size),swap_value);
+    matlab::swap<vsip::impl::int32_type>(&(temp_data_element.type),swap_value);
+    matlab::swap<vsip::impl::uint32_type>(&(temp_data_element.size),swap_value);
 
 
     // Because we don't know how the data was stored, we need to instantiate
     // generic_reader which can read a type and cast into a different one
     if(temp_data_element.type == matlab::miINT8) 
     {
-      if(i==0)matlab::read<int8_t,r_v>(is,subview::real(mbf.view),swap_value);
-      else    matlab::read<int8_t,i_v>(is,subview::imag(mbf.view),swap_value);
+      if(i==0)
+        matlab::read<vsip::impl::int8_type, r_v>(is,
+                                                 subview::real(mbf.view),
+                                                 swap_value);
+      else
+        matlab::read<vsip::impl::int8_type, i_v>(is,
+                                                 subview::imag(mbf.view),
+                                                 swap_value);
     }
     else if(temp_data_element.type == matlab::miUINT8) 
     {
-      if(i==0)matlab::read<uint8_t,r_v>(is,subview::real(mbf.view),swap_value);
-      else    matlab::read<uint8_t,i_v>(is,subview::imag(mbf.view),swap_value);
+      if(i==0)
+        matlab::read<vsip::impl::uint8_type, r_v>(is,
+                                                  subview::real(mbf.view),
+                                                  swap_value);
+      else  
+        matlab::read<vsip::impl::uint8_type, i_v>(is,
+                                                  subview::imag(mbf.view),
+                                                  swap_value);
     }
     else if(temp_data_element.type == matlab::miINT16) 
     {
-      if(i==0)matlab::read<int16_t,r_v>(is,subview::real(mbf.view),swap_value);
-      else    matlab::read<int16_t,i_v>(is,subview::imag(mbf.view),swap_value);
+      if(i==0)
+        matlab::read<vsip::impl::int16_type, r_v>(is,
+                                                  subview::real(mbf.view),
+                                                  swap_value);
+      else
+        matlab::read<vsip::impl::int16_type, i_v>(is,
+                                                  subview::imag(mbf.view),
+                                                  swap_value);
     }
     else if(temp_data_element.type == matlab::miUINT16) 
     {
-      if(i==0)matlab::read<uint16_t,r_v>(is,subview::real(mbf.view),swap_value);
-      else    matlab::read<uint16_t,i_v>(is,subview::imag(mbf.view),swap_value);
+      if(i==0)
+        matlab::read<vsip::impl::uint16_type, r_v>(is,
+                                                   subview::real(mbf.view),
+                                                   swap_value);
+      else
+        matlab::read<vsip::impl::uint16_type, i_v>(is,
+                                                   subview::imag(mbf.view),
+                                                   swap_value);
     }
     else if(temp_data_element.type == matlab::miINT32) 
     {
-      if(i==0)matlab::read<int32_t,r_v>(is,subview::real(mbf.view),swap_value);
-      else    matlab::read<int32_t,i_v>(is,subview::imag(mbf.view),swap_value);
+      if(i==0)
+        matlab::read<vsip::impl::int32_type, r_v>(is,
+                                                  subview::real(mbf.view),
+                                                  swap_value);
+      else
+        matlab::read<vsip::impl::int32_type, i_v>(is,
+                                                  subview::imag(mbf.view),
+                                                  swap_value);
     }
     else if(temp_data_element.type == matlab::miUINT32) 
     {
-      if(i==0)matlab::read<uint32_t,r_v>(is,subview::real(mbf.view),swap_value);
-      else    matlab::read<uint32_t,i_v>(is,subview::imag(mbf.view),swap_value);
+      if(i==0)
+        matlab::read<vsip::impl::uint32_type, r_v>(is,
+                                                   subview::real(mbf.view),
+                                                   swap_value);
+      else
+        matlab::read<vsip::impl::uint32_type, i_v>(is,
+                                                   subview::imag(mbf.view),
+                                                   swap_value);
     }
     else if(temp_data_element.type == matlab::miSINGLE) 
     {
-      if(i==0)matlab::read<float,r_v>(is,subview::real(mbf.view),swap_value);
-      else    matlab::read<float,i_v>(is,subview::imag(mbf.view),swap_value);
+      if(i==0)
+        matlab::read<float, r_v>(is, subview::real(mbf.view), swap_value);
+      else
+        matlab::read<float, i_v>(is, subview::imag(mbf.view), swap_value);
     }
     else
     {
-      if(i==0)matlab::read<double,r_v>(is,subview::real(mbf.view),swap_value);
-      else    matlab::read<double,i_v>(is,subview::imag(mbf.view),swap_value);
+      if(i==0)
+        matlab::read<double, r_v>(is, subview::real(mbf.view), swap_value);
+      else
+        matlab::read<double, i_v>(is, subview::imag(mbf.view), swap_value);
     }
 
   }
Index: GNUmakefile.in
===================================================================
--- GNUmakefile.in	(revision 148934)
+++ GNUmakefile.in	(working copy)
@@ -100,6 +100,8 @@
 OBJEXT := @OBJEXT@
 # The extension for archives.
 LIBEXT := @LIBEXT@
+# The QMTest command to use for testing.
+QMTEST := @QMTEST@
 
 ### Parallelization ###
 
Index: tests/GNUmakefile.inc.in
===================================================================
--- tests/GNUmakefile.inc.in	(revision 148934)
+++ tests/GNUmakefile.inc.in	(working copy)
@@ -37,10 +37,10 @@
 ########################################################################
 
 $(tests_cxx_exes): %$(EXEEXT): %.$(OBJEXT) $(libs)
-	$(CXX) $(LDFLAGS) -o $@ $< -Llib -l$(SVPP_LIBRARY) $(LIBS)
+	$(link_app)
 
 check::	$(libs) $(tests_qmtest_extensions)
-	cd tests; qmtest run $(tests_run_ident) $(tests_ids); \
+	cd tests; $(QMTEST) run $(tests_run_ident) $(tests_ids); \
           result=$$?; test $$tmp=0 || $$tmp=2
 
 installcheck:: $(tests_qmtest_extensions)
@@ -52,7 +52,7 @@
           sed -e "s|@PAR_SERVICE_@|`$(tests_pkgconfig) --variable=par_service`|" \
           > tests/context-installed
 	cd tests; \
-          qmtest run -C context-installed $(tests_run_ident) \
+          $(QMTEST) run -C context-installed $(tests_run_ident) \
             -o results$(suffix).qmr $(tests_ids); \
           result=$$?; test $$tmp=0 || $$tmp=2
 
Index: configure.ac
===================================================================
--- configure.ac	(revision 148934)
+++ configure.ac	(working copy)
@@ -311,6 +311,13 @@
       [Set 1 to enable eval_dense_expr evaluator, set 0 to disable.])
 
 
+AC_ARG_WITH(qmtest,
+  AS_HELP_STRING([--with-qmtest=QMTEST], [Provide the command to run QMTest.]),
+  ,
+  [with_qmtest="qmtest"]) 
+
+AC_SUBST(QMTEST, $with_qmtest)
+ 
 #
 # Put libs directory int INT_LDFLAGS:
 #
@@ -378,6 +385,11 @@
 AC_SUBST(LIBEXT)
 
 AC_LANG(C++)
+AC_CHECK_SIZEOF(char)
+AC_CHECK_SIZEOF(short)
+AC_CHECK_SIZEOF(int)
+AC_CHECK_SIZEOF(long)
+AC_CHECK_SIZEOF(long long)
 
 # assign cflags to CLAPACK_CFLAGS if the user didn't use --with-clapack-cflags
 if test "$CLAPACK_CFLAGS" == "no"; then
@@ -940,12 +952,11 @@
     esac
 
     if test "$check_mpicxx" == "yes"; then
-
 changequote(<<, >>)dnl
     MPI_CPPFLAGS="$MPI_CPPFLAGS\
-                  `$MPICXX -c conftest.cc | sed -e \"s|^[^ \t]*||\"\
-                                                -e \"s|-DHAVE_MPI_CXX||\"\
-                                                -e \"s|-c conftest.cc[ \t]*$||\"`"
+                  `$MPICXX -c | sed -e \"s|^[^ \t]*||\"\
+                                    -e \"s|-DHAVE_MPI_CXX||\"\
+                                    -e \"s|-c[ \t]*||\"`"
     MPI_LIBS="$MPI_LIBS `$MPICXX | sed -e \"s|^[^ \t]*||\"\
                                        -e \"s|-DHAVE_MPI_CXX||\"`"
 changequote([, ])dnl
