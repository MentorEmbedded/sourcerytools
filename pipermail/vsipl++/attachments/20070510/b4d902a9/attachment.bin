Index: src/vsip/opt/simd/threshold.hpp
===================================================================
--- src/vsip/opt/simd/threshold.hpp	(revision 0)
+++ src/vsip/opt/simd/threshold.hpp	(revision 0)
@@ -0,0 +1,214 @@
+/* Copyright (c) 2007 by CodeSourcery.  All rights reserved.
+
+   This file is available for license from CodeSourcery, Inc. under the terms
+   of a commercial license and under the GPL.  It is not part of the VSIPL++
+   reference implementation and is not available under the BSD license.
+*/
+/** @file    vsip/opt/simd/threshold.hpp
+    @author  Assem Salama
+    @date    2007-05-02
+    @brief   VSIPL++ Library: SIMD threshold operation.
+
+*/
+
+#ifndef VSIP_OPT_SIMD_THRESHOLD_HPP
+#define VSIP_OPT_SIMD_THRESHOLD_HPP
+
+#include <vsip/opt/simd/simd.hpp>
+#include <vsip/core/metaprogramming.hpp>
+
+/***********************************************************************
+  Definitions
+***********************************************************************/
+
+namespace vsip
+{
+namespace impl
+{
+namespace simd
+{
+
+// Define value_types for which threshold is optimized.
+//  - float
+//  - double
+
+template <typename T,
+	  bool     IsSplit>
+struct Is_algorithm_supported<T, IsSplit, Alg_threshold>
+{
+  static bool const value =
+    Simd_traits<T>::is_accel &&
+    (Type_equal<T, float>::value ||
+     Type_equal<T, double>::value);
+};
+
+
+
+// Class for threshold
+
+template <typename T,
+	  bool     Is_vectorized>
+struct Simd_threshold;
+
+
+// Simd function to do threshold only when K is 0
+template <typename T>
+int simd_thresh0(T* Z, T* A, T* B, int n)
+{
+  typedef Simd_traits<T>                         simd;
+  typedef Simd_traits<int>                       simdi;
+  typedef typename simd::simd_type               simd_type;
+  typedef typename simdi::simd_type              simd_itype;
+
+  simd::enter();
+
+  while (n >= simd::vec_size)
+  {
+    n -= simd::vec_size;
+
+    simd_type A_v    = simd::load(A);
+    simd_type B_v    = simd::load(B);
+    simd_itype mask  = simd_itype(simd::gt(A_v,B_v));
+    simd_itype res   = simdi::band(simd_itype(A_v),mask);
+    simd::store(Z,simd_type(res));
+
+    A += simd::vec_size;
+    B += simd::vec_size;
+    Z += simd::vec_size;
+  }
+
+  simd::exit();
+
+  return n;
+}
+
+// Simd function to do threshold only when K is not 0
+template <typename T>
+int simd_thresh(T* Z, T* A, T* B, T k, int n)
+{
+  typedef Simd_traits<T>                         simd;
+  typedef Simd_traits<int>                       simdi;
+  typedef typename simd::simd_type               simd_type;
+  typedef typename simdi::simd_type              simd_itype;
+
+  simd::enter();
+
+  simd_type k_v    = simd::load_scalar_all(k);
+
+  while (n >= simd::vec_size)
+  {
+    n -= simd::vec_size;
+
+    simd_type A_v      = simd::load(A);
+    simd_type B_v      = simd::load(B);
+    simd_itype mask    = simd_itype(simd::gt(A_v,B_v));
+    simd_itype nmask   = simdi::bnot(mask);
+    simd_itype xor_val = simdi::bxor(simd_itype(A_v),simd_itype(k_v));
+    simd_itype and_val = simdi::band(xor_val,nmask);
+    simd_itype res     = simdi::bxor(simd_itype(A_v),and_val);
+    simd::store(Z,simd_type(res));
+
+    A += simd::vec_size;
+    B += simd::vec_size;
+    Z += simd::vec_size;
+  }
+
+  simd::exit();
+
+  return n;
+}
+
+
+// Generic, non-vectorized implementation of threshold
+
+template <typename T>
+struct Simd_threshold<T, false>
+{
+  static void exec(T* Z, T* A, T* B, T k, int n)
+  {
+    while (n)
+    {
+      if(*A > *B) *Z = *A;
+      else *Z = k;
+      A++;B++;Z++;
+      n--;
+    }
+  }
+};
+
+// vectorized version
+
+template <typename T>
+struct Simd_threshold<T, true>
+{
+  static void exec(T* Z, T* A, T* B, T k, int n)
+  {
+    typedef Simd_traits<T>                         simd;
+    typedef Simd_traits<int>                       simdi;
+    typedef typename simd::simd_type               simd_type;
+    typedef typename simdi::simd_type              simd_itype;
+
+    // handle mis-aligned vectors
+    if (simd::alignment_of(A) != simd::alignment_of(B) ||
+	simd::alignment_of(Z) != simd::alignment_of(A))
+    {
+      Simd_threshold<T,false>::exec(Z,A,B,k,n);
+      return;
+    }
+
+    // clean up initial unaligned values
+    while (simd::alignment_of(A) != 0)
+    {
+      if(*A > *B) *Z = *A;
+      else *Z = k;
+      A++;B++;Z++;
+      n--;
+    }
+  
+    if (n == 0) return;
+
+    if(k != T(0)) {
+      n = simd_thresh(Z,A,B,k,n);
+    } else {
+      n = simd_thresh0(Z,A,B,n);
+    }
+
+    // handle last bits
+    while(n)
+    {
+      if(*A > *B) *Z = *A;
+      else *Z = k;
+      A++;B++;Z++;
+      n--;
+    }
+
+  }
+};
+
+// Depending on VSIP_IMPL_LIBSIMD_INLINE macro, either provide these
+// functions inline, or provide non-inline functions in the libvsip.a.
+
+#if VSIP_IMPL_INLINE_LIBSIMD
+
+template <typename T>
+inline void 
+threshold(T* Z, T* A, T* B, T k, int n)
+{
+  static bool const Is_vectorized =
+    Is_algorithm_supported<T, false, Alg_threshold>::value;
+  Simd_threshold<T, Is_vectorized>::exec(Z,A,B,k,n);
+}
+
+#else
+
+template <typename T>
+void 
+threshold(T* Z, T* A, T* B, T k, int n);
+
+#endif
+
+} // namespace vsip::impl::simd
+} // namespace vsip::impl
+} // namespace vsip
+
+#endif
Index: src/vsip/opt/simd/simd.hpp
===================================================================
--- src/vsip/opt/simd/simd.hpp	(revision 165174)
+++ src/vsip/opt/simd/simd.hpp	(working copy)
@@ -998,6 +998,7 @@
 struct Alg_vbor;
 struct Alg_vbxor;
 struct Alg_vbnot;
+struct Alg_threshold;
 
 template <typename T,
 	  bool     IsSplit,
Index: src/vsip/opt/simd/expr_evaluator.hpp
===================================================================
--- src/vsip/opt/simd/expr_evaluator.hpp	(revision 165174)
+++ src/vsip/opt/simd/expr_evaluator.hpp	(working copy)
@@ -143,6 +143,51 @@
   }
 };
 
+template <dimension_type                         D,
+	  template <typename, typename,typename> class O,
+	  typename                               Block1, typename Type1,
+	  typename                               Block2, typename Type2,
+	  typename                               Block3, typename Type3>
+struct Proxy_factory<Ternary_expr_block<D, O,
+  Block1,Type1,Block2,Type2,Block3,Type3> const>
+{
+  typedef Ternary_access_traits<typename Proxy_factory<Block1>::proxy_type,
+                                typename Proxy_factory<Block2>::proxy_type,
+                                typename Proxy_factory<Block3>::proxy_type,
+		 	        O> 
+    access_traits;
+
+  typedef Ternary_expr_block<D, O, Block1,Type1,Block2,Type2,Block3,Type3>
+    SrcBlock;
+
+  typedef Proxy<access_traits> proxy_type;
+  static bool const ct_valid = 
+    Ternary_operator_map<Type1, O>::is_supported &&
+    Proxy_factory<Block1>::ct_valid &&
+    Proxy_factory<Block2>::ct_valid &&
+    Proxy_factory<Block3>::ct_valid;
+
+  static bool 
+  rt_valid(SrcBlock const &b)
+  {
+    return Proxy_factory<Block1>::rt_valid(b.first()) &&
+           Proxy_factory<Block2>::rt_valid(b.second()) &&
+           Proxy_factory<Block2>::rt_valid(b.third());
+  }
+  static proxy_type
+  create(SrcBlock const &b)
+  {
+    typename Proxy_factory<Block1>::proxy_type b1p =
+      Proxy_factory<Block1>::create(b.first());
+    typename Proxy_factory<Block2>::proxy_type b2p =
+      Proxy_factory<Block2>::create(b.second());
+    typename Proxy_factory<Block3>::proxy_type b3p =
+      Proxy_factory<Block3>::create(b.third());
+
+    return proxy_type(b1p,b2p,b3p);
+  }
+};
+
 } // namespace vsip::impl::simd
 
 template <typename LB,
Index: src/vsip/opt/simd/eval_generic.hpp
===================================================================
--- src/vsip/opt/simd/eval_generic.hpp	(revision 165174)
+++ src/vsip/opt/simd/eval_generic.hpp	(working copy)
@@ -37,6 +37,7 @@
 #include <vsip/opt/simd/rscvmul.hpp>
 #include <vsip/opt/simd/vgt.hpp>
 #include <vsip/opt/simd/vlogic.hpp>
+#include <vsip/opt/simd/threshold.hpp>
 
 /***********************************************************************
   Declarations
@@ -602,9 +603,79 @@
   }
 };
 
+/***********************************************************************
+  threshold: vector threshold operator
+  ite(A > B, A, k)
+***********************************************************************/
 
+template <typename DstBlock,
+          typename T,
+	  typename Block1,
+	  typename Block2>
+struct Serial_expr_evaluator<
+  1, DstBlock,
 
+  Ternary_expr_block<1, ite_functor,
+    Binary_expr_block<1u, gt_functor,
+                      Block1, T,
+		      Block2, T> const, bool,
+    Block1, T,
+    Scalar_block<1,T>, T> const,
 
+    Simd_builtin_tag>
+                      
+{
+
+  typedef Ternary_expr_block<1, ite_functor,
+    Binary_expr_block<1u, gt_functor,
+                      Block1, T,
+		      Block2, T> const, bool,
+    Block1, T,
+    Scalar_block<1,T>, T> SrcBlock;
+
+
+  static char const* name() { return "Expr_SIMD_threshold"; }
+
+  typedef typename Adjust_layout_dim<
+    1, typename Block_layout<DstBlock>::layout_type>::type
+  dst_lp;
+  typedef typename Adjust_layout_dim<
+    1, typename Block_layout<Block1>::layout_type>::type
+  a_lp;
+  typedef typename Adjust_layout_dim<
+    1, typename Block_layout<Block2>::layout_type>::type
+  b_lp;
+
+  static bool const ct_valid = 
+    simd::Is_algorithm_supported<T, false, simd::Alg_threshold>::value;
+  
+  static bool rt_valid(DstBlock& dst, SrcBlock const& src)
+  {
+    // check if all data is unit stride
+    Ext_data<DstBlock, dst_lp>     ext_dst(dst,              SYNC_OUT);
+    Ext_data<Block1,   a_lp>       ext_a(src.first().left(), SYNC_IN);
+    Ext_data<Block2,   b_lp>       ext_b(src.first().right(),SYNC_IN);
+    return(ext_dst.stride(0) == 1 &&
+           ext_a.stride(0) == 1 &&
+	   ext_b.stride(0) == 1);// &&
+	   // make sure (A > B, A, k)
+	   //(&(src.first().left()) == &(src.second())));
+  }
+
+  static void exec(DstBlock& dst, SrcBlock const& src)
+  {
+    Ext_data<DstBlock, dst_lp>     ext_dst(dst,              SYNC_OUT);
+    Ext_data<Block1,   a_lp>       ext_a(src.first().left(), SYNC_IN);
+    Ext_data<Block2,   b_lp>       ext_b(src.first().right(),SYNC_IN);
+
+    simd::threshold(ext_dst.data(), ext_a.data(), ext_b.data(),
+                    src.third().value(), ext_dst.size());
+  }
+};
+
+
+
+
 } // namespace vsip::impl
 } // namespace vsip
 
Index: src/vsip/opt/simd/expr_iterator.hpp
===================================================================
--- src/vsip/opt/simd/expr_iterator.hpp	(revision 165174)
+++ src/vsip/opt/simd/expr_iterator.hpp	(working copy)
@@ -72,8 +72,19 @@
 {
   // The general case, in particular binary functors, are not supported.
   static bool const is_supported = false;
+  typedef T value_type;
+  typedef T return_type;
 };
 
+template <typename T,                                      // type
+          template <typename, typename, typename> class O> // operator
+struct Ternary_operator_map
+{
+  // The general case, in particular ternary functors, are not supported.
+  static bool const is_supported = false;
+};
+
+
 template <typename T>
 struct Binary_operator_map<T, op::Add>
 {
@@ -114,6 +125,45 @@
   { return Simd_traits<T>::div(left, right);}
 };
 
+// Binary operators that return different type than type of operands
+template <typename T>
+struct Binary_operator_map<T, gt_functor>
+{
+  typedef typename Simd_traits<int>::simd_type simd_itype;
+  typedef typename Simd_traits<T>::simd_type   simd_type;
+  typedef int                           return_type;
+  typedef T                             value_type;
+
+  static bool const is_supported = true;
+  static simd_itype 
+  apply(simd_type const &left, simd_type const &right)
+  { 
+    simd_itype mask = simd_itype(Simd_traits<T>::gt(left, right));
+    return mask;
+  }
+};
+
+// Support for ite
+template <typename T>
+struct Ternary_operator_map<T, ite_functor>
+{
+  typedef Simd_traits<T>                       simd;
+  typedef typename simd::simd_type             simd_type;
+  typedef Simd_traits<int>                     simdi;
+  typedef typename simdi::simd_type            simd_itype;
+
+  static bool const is_supported = true;
+  static simd_type
+  apply(simd_itype const& mask, simd_type const& a, simd_type const& k)
+  {
+    simd_itype nmask        = simdi::bnot(mask);
+    simd_itype xor_val      = simdi::bxor(simd_itype(a),simd_itype(k));
+    simd_itype and_val      = simdi::band(xor_val,nmask);
+    simd_itype res          = simdi::bxor(and_val,simd_itype(a));
+    return simd_type(res);
+  }
+};
+
 // Access trait for direct access to contiguous aligned memory.
 template <typename T> struct Direct_access_traits 
 {
@@ -164,10 +214,21 @@
 	  template <typename, typename> class O> // operator
 struct Binary_access_traits
 {
-  typedef typename Type_equal<typename L::value_type,
-			      typename R::value_type>::type value_type;
+  //typedef typename Type_equal<typename L::value_type,
+  //			      typename R::value_type>::type value_type;
+  typedef Binary_operator_map<typename L::value_type,O> bin_op;
+
+  typedef typename bin_op::value_type  value_type;
+  typedef typename bin_op::return_type return_type;
 };
 
+template <typename P1, typename P2, typename P3,
+          template <typename,typename,typename> class O>
+struct Ternary_access_traits
+{
+  typedef typename P1::value_type value_type;
+};
+
 template <typename T> class Proxy;
 
 // Optimized proxy for direct SIMD access to block data, i.e. the data
@@ -266,15 +327,17 @@
 {
 public:
   typedef Binary_access_traits<L, R, O> access_traits;
-  typedef typename access_traits::value_type value_type;
-  typedef typename Simd_traits<value_type>::simd_type simd_type;
+  typedef typename access_traits::value_type  value_type;
+  typedef typename access_traits::return_type return_type;
+  typedef typename Simd_traits<value_type>::simd_type  simd_type;
+  typedef typename Simd_traits<return_type>::simd_type simd_ret_type;
 
   Proxy(L const &l, R const &r) : left_(l), right_(r) {}
 
   L const &left() const { return left_;}
   R const &right() const { return right_;}
 
-  simd_type load() const 
+  simd_ret_type load() const 
   {
     simd_type l = left_.load();
     simd_type r = right_.load();
@@ -405,6 +468,45 @@
   CD right_;
 };
 
+// Proxy for ternary access traits for ite functor
+template <typename A, typename B, typename C>
+class Proxy<Ternary_access_traits<A,B,C,ite_functor> >
+{
+  typedef typename A::access_traits                   access_traits;
+  typedef typename access_traits::value_type          value_type;
+  typedef typename Simd_traits<value_type>::simd_type simd_type;
+
+public:
+  Proxy(A const &a, B const &b, C const &c)
+    : a_(a), b_(b), c_(c) {}
+
+  simd_type load() const 
+  {
+    typedef typename A::access_traits::return_type return_type;
+    typedef typename A::access_traits::value_type  value_type;
+    typedef typename Simd_traits<return_type>::simd_type simd_ret_type;
+    typedef typename Simd_traits<value_type>::simd_type  simd_val_type;
+    
+    simd_ret_type a_ret  = a_.load(); // this is the mask
+    simd_val_type  b     = b_.load(); // if true
+    simd_val_type  c     = c_.load(); // if false
+    // apply the mask
+    return Ternary_operator_map<value_type,ite_functor>::apply(a_ret,b,c);
+  }
+
+  void increment(length_type n = 1)
+  {
+    a_.increment(n);
+    b_.increment(n);
+    c_.increment(n);
+  }
+
+private:
+  A a_;
+  B b_;
+  C c_;
+};
+
 template <typename T>
 struct Iterator
 {
Index: src/vsip/opt/simd/threshold.cpp
===================================================================
--- src/vsip/opt/simd/threshold.cpp	(revision 0)
+++ src/vsip/opt/simd/threshold.cpp	(revision 0)
@@ -0,0 +1,51 @@
+/* Copyright (c) 2007 by CodeSourcery.  All rights reserved.
+
+   This file is available for license from CodeSourcery, Inc. under the terms
+   of a commercial license and under the GPL.  It is not part of the VSIPL++
+   reference implementation and is not available under the BSD license.
+*/
+/** @file    vsip/opt/simd/threshold.cpp
+    @author  Assem Salama
+    @date    2007-05-02
+    @brief   VSIPL++ Library: SIMD threshold
+
+*/
+
+/***********************************************************************
+  Included Files
+***********************************************************************/
+
+#include <vsip/opt/simd/threshold.hpp>
+
+
+
+/***********************************************************************
+  Definitions
+***********************************************************************/
+
+namespace vsip
+{
+namespace impl
+{
+namespace simd
+{
+
+#if !VSIP_IMPL_INLINE_LIBSIMD
+
+template <typename T>
+void 
+threshold(T* Z, T* A, T* B, T k, int n)
+{
+  static bool const Is_vectorized =
+    Is_algorithm_supported<T, false, Alg_threshold>::value;
+  Simd_threshold<T, Is_vectorized>::exec(Z,A,B,k,n);
+}
+
+template void threshold(float* Z, float* A, float* B, float k, int n);
+template void threshold(double* Z, double* A, double* B, double k, int n);
+
+#endif
+
+}
+}
+}
