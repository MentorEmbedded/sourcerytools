Index: benchmarks/vramp.cpp
===================================================================
--- benchmarks/vramp.cpp	(revision 0)
+++ benchmarks/vramp.cpp	(revision 0)
@@ -0,0 +1,93 @@
+/* Copyright (c) 2007 by CodeSourcery.  All rights reserved.
+
+   This file is available for license from CodeSourcery, Inc. under the terms
+   of a commercial license and under the GPL.  It is not part of the VSIPL++
+   reference implementation and is not available under the BSD license.
+*/
+/** @file    benchmarks/vramp.cpp
+    @author  Assem Salama
+    @date    2007-04-05
+    @brief   VSIPL++ Library: Benchmark for ramp
+
+*/
+
+/***********************************************************************
+  Included Files
+***********************************************************************/
+
+#include <vsip/initfin.hpp>
+#include <vsip/support.hpp>
+#include <vsip/math.hpp>
+#include <vsip/random.hpp>
+#include <vsip/selgen.hpp>
+
+#include <vsip_csl/test.hpp>
+#include "loop.hpp"
+
+
+using namespace vsip;
+using namespace vsip_csl;
+
+#include "vramp.hpp"
+
+template <int test_num,
+          typename T,
+          typename MapT = Local_map>
+struct t_vramp
+{
+  char* what() { return "t_vramp"; }
+  int ops_per_point(length_type)  { return 1; }
+  int riob_per_point(length_type) { return sizeof(T); }
+  int wiob_per_point(length_type) { return 0; }
+  int mem_per_point(length_type)  { return 1*sizeof(T); }
+
+  void operator()(length_type size, length_type loop, float& time)
+  {
+    using namespace vsip::impl;
+
+    typedef Dense<1,T,row1_type,MapT>    block_type;
+
+    MapT                                 map = Create_map<MapT>::exec();
+    Vector<T,block_type>                 view(size,map);
+
+    vsip::impl::profile::Timer t1;
+    
+    t1.start();
+    for (index_type l=0; l<loop; ++l)
+      do_test<test_num>::exec(view,size);
+    t1.stop();
+
+    time = t1.delta();
+  }
+
+  void diag()
+  {
+  }
+
+};
+
+
+
+
+void
+defaults(Loop1P&)
+{
+}
+
+
+
+int
+test(Loop1P& loop, int what)
+{
+  switch (what)
+  {
+  case  1: loop(t_vramp<1,float,Local_map>());      break;
+  case  2: loop(t_vramp<1,float,Map<> >());         break;
+  case  3: loop(t_vramp<1,float,Global_map<1> >()); break;
+  case  4: loop(t_vramp<2,float,Local_map>());      break;
+  case  5: loop(t_vramp<2,float,Map<> >());         break;
+  case  6: loop(t_vramp<2,float,Global_map<1> >()); break;
+  default: return 0;
+  }
+  return 1;
+}
Index: benchmarks/vramp.hpp
===================================================================
--- benchmarks/vramp.hpp	(revision 0)
+++ benchmarks/vramp.hpp	(revision 0)
@@ -0,0 +1,70 @@
+/* Copyright (c) 2007 by CodeSourcery.  All rights reserved.
+
+   This file is available for license from CodeSourcery, Inc. under the terms
+   of a commercial license and under the GPL.  It is not part of the VSIPL++
+   reference implementation and is not available under the BSD license.
+*/
+/** @file    benchmarks/vramp.hpp
+    @author  Assem Salama
+    @date    2007-04-05
+    @brief   VSIPL++ Library: Header file for benchark of ramp function
+*/
+
+#ifndef BENCHMARKS_VRAMP_HPP
+#define BENCHMARKS_VRAMP_HPP
+
+// A structure to help in the creation of maps.
+template <typename MapT,
+          dimension_type Dim = 1>
+struct Create_map;
+
+template <>
+struct Create_map<Local_map>
+{
+  static Local_map exec() { return Local_map(); }
+};
+
+template <>
+struct Create_map<Map<> >
+{
+  static Map<>  exec() { return Map<>(num_processors()); }
+};
+
+template <dimension_type dim>
+struct Create_map<Global_map<dim> >
+{
+  static Global_map<dim>  exec() { return Global_map<dim>(); }
+};
+
+
+template <int test_num>
+struct do_test;
+
+
+// declare all tests here
+
+// TEST1: A simple assignment, view = ramp
+template <>
+struct do_test<1>
+{
+  template <typename ViewT>
+  static void exec(ViewT& view, length_type size) 
+    { typedef typename ViewT::value_type T; view = ramp(T(0),T(1),size); }
+};
+
+// TEST2: An assignment using put
+template <>
+struct do_test<2>
+{
+  template <typename ViewT>
+  static void exec(ViewT& view, length_type size) 
+    { 
+      typedef typename ViewT::value_type T;
+      T val = T(0);
+      index_type i;
+      for(i=0;i<size;i++) view.local().put(i,val++);
+    }
+
+};
+
+#endif
