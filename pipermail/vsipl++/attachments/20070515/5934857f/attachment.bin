Index: src/vsip/opt/simd/simd.hpp
===================================================================
--- src/vsip/opt/simd/simd.hpp	(revision 165174)
+++ src/vsip/opt/simd/simd.hpp	(working copy)
@@ -167,6 +167,9 @@
   static simd_type gt(simd_type const& v1, simd_type const& v2)
   { return (v1 > v2) ? simd_type(1) : simd_type(0); }
 
+  static simd_type lt(simd_type const& v1, simd_type const& v2)
+  { return (v1 < v2) ? simd_type(1) : simd_type(0); }
+
   static simd_type pack(simd_type const&, simd_type const&)
   { assert(0); }
 
@@ -246,6 +249,9 @@
   static bool_simd_type gt(simd_type const& v1, simd_type const& v2)
   { return vec_cmpgt(v1, v2); }
 
+  static bool_simd_type lt(simd_type const& v1, simd_type const& v2)
+  { return vec_cmplt(v1, v2); }
+
   static void enter() {}
   static void exit()  {}
 };
@@ -300,6 +306,9 @@
   static bool_simd_type gt(simd_type const& v1, simd_type const& v2)
   { return vec_cmpgt(v1, v2); }
 
+  static bool_simd_type lt(simd_type const& v1, simd_type const& v2)
+  { return vec_cmplt(v1, v2); }
+
   static pack_simd_type pack(simd_type const& v1, simd_type const& v2)
   { return vec_pack(v1, v2); }
 
@@ -357,6 +366,9 @@
   static bool_simd_type gt(simd_type const& v1, simd_type const& v2)
   { return vec_cmpgt(v1, v2); }
 
+  static bool_simd_type lt(simd_type const& v1, simd_type const& v2)
+  { return vec_cmplt(v1, v2); }
+
   static pack_simd_type pack(simd_type const& v1, simd_type const& v2)
   { return vec_pack(v1, v2); }
 
@@ -426,6 +438,9 @@
   static bool_simd_type gt(simd_type const& v1, simd_type const& v2)
   { return vec_cmpgt(v1, v2); }
 
+  static bool_simd_type lt(simd_type const& v1, simd_type const& v2)
+  { return vec_cmplt(v1, v2); }
+
   static simd_type real_from_interleaved(simd_type const& v1,
 					 simd_type const& v2)
   { return zero(); /* return _mm_shuffle_ps(v1, v2, 0x88); */ }
@@ -728,6 +743,9 @@
   static simd_type gt(simd_type const& v1, simd_type const& v2)
   { return _mm_cmpgt_ps(v1, v2); }
 
+  static simd_type lt(simd_type const& v1, simd_type const& v2)
+  { return _mm_cmplt_ps(v1, v2); }
+
   static int sign_mask(simd_type const& v1)
   { return _mm_movemask_ps(v1); }
 
@@ -813,6 +831,9 @@
   static simd_type gt(simd_type const& v1, simd_type const& v2)
   { return _mm_cmpgt_pd(v1, v2); }
 
+  static simd_type lt(simd_type const& v1, simd_type const& v2)
+  { return _mm_cmplt_pd(v1, v2); }
+
   static int sign_mask(simd_type const& v1)
   { return _mm_movemask_pd(v1); }
 
@@ -998,6 +1019,7 @@
 struct Alg_vbor;
 struct Alg_vbxor;
 struct Alg_vbnot;
+struct Alg_threshold;
 
 template <typename T,
 	  bool     IsSplit,
Index: src/vsip/opt/simd/threshold.hpp
===================================================================
--- src/vsip/opt/simd/threshold.hpp	(revision 171195)
+++ src/vsip/opt/simd/threshold.hpp	(working copy)
@@ -15,6 +15,7 @@
 #define VSIP_OPT_SIMD_THRESHOLD_HPP
 
 #include <vsip/opt/simd/simd.hpp>
+#include <vsip/opt/simd/expr_iterator.hpp>
 #include <vsip/core/metaprogramming.hpp>
 
 /***********************************************************************
@@ -47,19 +48,22 @@
 // Class for threshold
 
 template <typename T,
+          template <typename,typename> class O,
 	  bool     Is_vectorized>
 struct Simd_threshold;
 
 
 // Simd function to do threshold only when K is 0
-template <typename T>
+template <template <typename,typename> class O,
+          typename T>
 int
-simd_thresh0(T* Z, T const* A, T const* B, int const n)
+simd_thresh0(T* Z, T const* A, T const* B, int n)
 {
   typedef Simd_traits<T>                         simd;
   typedef Simd_traits<int>                       simdi;
   typedef typename simd::simd_type               simd_type;
   typedef typename simdi::simd_type              simd_itype;
+  typedef Binary_operator_map<T,O>               bin_op;
 
   // make sure A,B,Z are same alignment
   assert(simd::alignment_of(A) == simd::alignment_of(B) &&
@@ -73,7 +77,7 @@
 
     simd_type A_v    = simd::load(A);
     simd_type B_v    = simd::load(B);
-    simd_itype mask  = simd_itype(simd::gt(A_v,B_v));
+    simd_itype mask  = simd_itype(bin_op::apply(A_v,B_v));
     simd_itype res   = simdi::band(simd_itype(A_v),mask);
     simd::store(Z,simd_type(res));
 
@@ -88,14 +92,16 @@
 }
 
 // Simd function to do threshold only when K is not 0
-template <typename T>
+template <template <typename,typename> class O,
+          typename T>
 int
-simd_thresh(T* Z, T const* A, T const* B, T const k, int const n)
+simd_thresh(T* Z, T const* A, T const* B, T const k, int n)
 {
   typedef Simd_traits<T>                         simd;
   typedef Simd_traits<int>                       simdi;
   typedef typename simd::simd_type               simd_type;
   typedef typename simdi::simd_type              simd_itype;
+  typedef Binary_operator_map<T,O>               bin_op;
 
   // make sure A,B,Z are same alignment
   assert(simd::alignment_of(A) == simd::alignment_of(B) &&
@@ -111,7 +117,7 @@
 
     simd_type A_v      = simd::load(A);
     simd_type B_v      = simd::load(B);
-    simd_itype mask    = simd_itype(simd::gt(A_v,B_v));
+    simd_itype mask    = simd_itype(bin_op::apply(A_v,B_v));
     simd_itype nmask   = simdi::bnot(mask);
     simd_itype xor_val = simdi::bxor(simd_itype(A_v),simd_itype(k_v));
     simd_itype and_val = simdi::band(xor_val,nmask);
@@ -131,14 +137,15 @@
 
 // Generic, non-vectorized implementation of threshold
 
-template <typename T>
-struct Simd_threshold<T, false>
+template <typename T,
+          template <typename,typename> class O>
+struct Simd_threshold<T, O, false>
 {
   static void exec(T* Z, T* A, T* B, T k, int n)
   {
     while (n)
     {
-      if(*A > *B) *Z = *A;
+      if(O<T,T>::apply(*A,*B)) *Z = *A;
       else *Z = k;
       A++;B++;Z++;
       n--;
@@ -148,8 +155,9 @@
 
 // vectorized version
 
-template <typename T>
-struct Simd_threshold<T, true>
+template <typename T,
+          template <typename,typename> class O>
+struct Simd_threshold<T, O, true>
 {
   static void exec(T* Z, T* A, T* B, T k, int n)
   {
@@ -162,14 +170,14 @@
     if (simd::alignment_of(A) != simd::alignment_of(B) ||
 	simd::alignment_of(Z) != simd::alignment_of(A))
     {
-      Simd_threshold<T,false>::exec(Z,A,B,k,n);
+      Simd_threshold<T,O,false>::exec(Z,A,B,k,n);
       return;
     }
 
     // clean up initial unaligned values
     while (simd::alignment_of(A) != 0)
     {
-      if(*A > *B) *Z = *A;
+      if(O<T,T>::apply(*A,*B)) *Z = *A;
       else *Z = k;
       A++;B++;Z++;
       n--;
@@ -178,15 +186,15 @@
     if (n == 0) return;
 
     if(k != T(0)) {
-      n = simd_thresh(Z,A,B,k,n);
+      n = simd_thresh<O>(Z,A,B,k,n);
     } else {
-      n = simd_thresh0(Z,A,B,n);
+      n = simd_thresh0<O>(Z,A,B,n);
     }
 
     // handle last bits
     while(n)
     {
-      if(*A > *B) *Z = *A;
+      if(O<T,T>::apply(*A,*B)) *Z = *A;
       else *Z = k;
       A++;B++;Z++;
       n--;
@@ -200,18 +208,21 @@
 
 #if VSIP_IMPL_INLINE_LIBSIMD
 
-template <typename T>
+template <template <typename,typename> class O,
+          typename T>
 inline void 
 threshold(T* Z, T* A, T* B, T k, int n)
 {
   static bool const Is_vectorized =
-    Is_algorithm_supported<T, false, Alg_threshold>::value;
-  Simd_threshold<T, Is_vectorized>::exec(Z,A,B,k,n);
+    Is_algorithm_supported<T, false, Alg_threshold>::value &&
+    Binary_operator_map<T,O>::is_supported;
+  Simd_threshold<T, O, Is_vectorized>::exec(Z,A,B,k,n);
 }
 
 #else
 
-template <typename T>
+template <template <typename,typename> class O,
+          typename T>
 void 
 threshold(T* Z, T* A, T* B, T k, int n);
 
Index: src/vsip/opt/simd/expr_evaluator.hpp
===================================================================
--- src/vsip/opt/simd/expr_evaluator.hpp	(revision 165174)
+++ src/vsip/opt/simd/expr_evaluator.hpp	(working copy)
@@ -143,6 +143,51 @@
   }
 };
 
+template <dimension_type                         D,
+	  template <typename, typename,typename> class O,
+	  typename                               Block1, typename Type1,
+	  typename                               Block2, typename Type2,
+	  typename                               Block3, typename Type3>
+struct Proxy_factory<Ternary_expr_block<D, O,
+  Block1,Type1,Block2,Type2,Block3,Type3> const>
+{
+  typedef Ternary_access_traits<typename Proxy_factory<Block1>::proxy_type,
+                                typename Proxy_factory<Block2>::proxy_type,
+                                typename Proxy_factory<Block3>::proxy_type,
+		 	        O> 
+    access_traits;
+
+  typedef Ternary_expr_block<D, O, Block1,Type1,Block2,Type2,Block3,Type3>
+    SrcBlock;
+
+  typedef Proxy<access_traits> proxy_type;
+  static bool const ct_valid = 
+    Ternary_operator_map<Type1, O>::is_supported &&
+    Proxy_factory<Block1>::ct_valid &&
+    Proxy_factory<Block2>::ct_valid &&
+    Proxy_factory<Block3>::ct_valid;
+
+  static bool 
+  rt_valid(SrcBlock const &b)
+  {
+    return Proxy_factory<Block1>::rt_valid(b.first()) &&
+           Proxy_factory<Block2>::rt_valid(b.second()) &&
+           Proxy_factory<Block2>::rt_valid(b.third());
+  }
+  static proxy_type
+  create(SrcBlock const &b)
+  {
+    typename Proxy_factory<Block1>::proxy_type b1p =
+      Proxy_factory<Block1>::create(b.first());
+    typename Proxy_factory<Block2>::proxy_type b2p =
+      Proxy_factory<Block2>::create(b.second());
+    typename Proxy_factory<Block3>::proxy_type b3p =
+      Proxy_factory<Block3>::create(b.third());
+
+    return proxy_type(b1p,b2p,b3p);
+  }
+};
+
 } // namespace vsip::impl::simd
 
 template <typename LB,
Index: src/vsip/opt/simd/eval_generic.hpp
===================================================================
--- src/vsip/opt/simd/eval_generic.hpp	(revision 171195)
+++ src/vsip/opt/simd/eval_generic.hpp	(working copy)
@@ -38,6 +38,7 @@
 #include <vsip/opt/simd/vgt.hpp>
 #include <vsip/opt/simd/vlogic.hpp>
 #include <vsip/opt/simd/threshold.hpp>
+#include <vsip/opt/simd/expr_iterator.hpp>
 
 /***********************************************************************
   Declarations
@@ -606,17 +607,21 @@
 /***********************************************************************
   threshold: vector threshold operator
   ite(A > B, A, k)
+  ite(A < B, A, k)
+  ite(A <= B, A, k)
+  ite(A >= B, A, k)
 ***********************************************************************/
 
 template <typename DstBlock,
           typename T,
 	  typename Block1,
-	  typename Block2>
+	  typename Block2,
+	  template <typename,typename> class O>
 struct Serial_expr_evaluator<
   1, DstBlock,
 
   Ternary_expr_block<1, ite_functor,
-    Binary_expr_block<1u, gt_functor,
+    Binary_expr_block<1u, O,
                       Block1, T,
 		      Block2, T> const, bool,
     Block1, T,
@@ -627,7 +632,7 @@
 {
 
   typedef Ternary_expr_block<1, ite_functor,
-    Binary_expr_block<1u, gt_functor,
+    Binary_expr_block<1u, O,
                       Block1, T,
 		      Block2, T> const, bool,
     Block1, T,
@@ -658,8 +663,10 @@
     return(ext_dst.stride(0) == 1 &&
            ext_a.stride(0) == 1 &&
 	   ext_b.stride(0) == 1 &&
-	   // make sure (A > B, A, k)
-	   (&(src.first().left()) == &(src.second())));
+	   // make sure (A op B, A, k)
+	   (&(src.first().left()) == &(src.second())) &&
+	   // make sure op is supported
+	   simd::Binary_operator_map<T,O>::is_supported);
   }
 
   static void exec(DstBlock& dst, SrcBlock const& src)
@@ -668,8 +675,8 @@
     Ext_data<Block1,   a_lp>       ext_a(src.first().left(), SYNC_IN);
     Ext_data<Block2,   b_lp>       ext_b(src.first().right(),SYNC_IN);
 
-    simd::threshold(ext_dst.data(), ext_a.data(), ext_b.data(),
-                    src.third().value(), ext_dst.size());
+    simd::threshold<O>(ext_dst.data(), ext_a.data(), ext_b.data(),
+                       src.third().value(), ext_dst.size());
   }
 };
 
Index: src/vsip/opt/simd/expr_iterator.hpp
===================================================================
--- src/vsip/opt/simd/expr_iterator.hpp	(revision 165174)
+++ src/vsip/opt/simd/expr_iterator.hpp	(working copy)
@@ -23,6 +23,7 @@
 ***********************************************************************/
 
 #include <vsip/support.hpp>
+#include <vsip/core/fns_elementwise.hpp>
 #include <vsip/opt/simd/simd.hpp>
 #include <vsip/core/expr/operations.hpp>
 #include <vsip/core/metaprogramming.hpp>
@@ -72,8 +73,19 @@
 {
   // The general case, in particular binary functors, are not supported.
   static bool const is_supported = false;
+  typedef T value_type;
+  typedef T return_type;
 };
 
+template <typename T,                                      // type
+          template <typename, typename, typename> class O> // operator
+struct Ternary_operator_map
+{
+  // The general case, in particular ternary functors, are not supported.
+  static bool const is_supported = false;
+};
+
+
 template <typename T>
 struct Binary_operator_map<T, op::Add>
 {
@@ -114,6 +126,53 @@
   { return Simd_traits<T>::div(left, right);}
 };
 
+// Binary operators that return different type than type of operands
+#define VSIP_OPT_DECL_BINARY_OP(FCN,O) \
+template <typename T> \
+struct Binary_operator_map<T, O> \
+{ \
+  typedef typename Simd_traits<int>::simd_type simd_itype; \
+  typedef typename Simd_traits<T>::simd_type   simd_type;  \
+  typedef int                           return_type;       \
+  typedef T                             value_type;        \
+                                                           \
+  static bool const is_supported = true;                   \
+  static inline simd_itype                                 \
+  apply(simd_type const &left, simd_type const &right)     \
+  {                                                        \
+    simd_itype mask = simd_itype(Simd_traits<T>::FCN(left, right)); \
+    return mask;                                           \
+  }                                                        \
+};
+
+VSIP_OPT_DECL_BINARY_OP(gt,  gt_functor)
+VSIP_OPT_DECL_BINARY_OP(lt,  lt_functor)
+//VSIP_OPT_DECL_BINARY_OP(ge,  ge_functor)
+//VSIP_OPT_DECL_BINARY_OP(le,  le_functor)
+
+#undef VSIP_OPT_DECL_BINARY_OP
+
+// Support for ite
+template <typename T>
+struct Ternary_operator_map<T, ite_functor>
+{
+  typedef Simd_traits<T>                       simd;
+  typedef typename simd::simd_type             simd_type;
+  typedef Simd_traits<int>                     simdi;
+  typedef typename simdi::simd_type            simd_itype;
+
+  static bool const is_supported = true;
+  static simd_type
+  apply(simd_itype const& mask, simd_type const& a, simd_type const& k)
+  {
+    simd_itype nmask        = simdi::bnot(mask);
+    simd_itype xor_val      = simdi::bxor(simd_itype(a),simd_itype(k));
+    simd_itype and_val      = simdi::band(xor_val,nmask);
+    simd_itype res          = simdi::bxor(and_val,simd_itype(a));
+    return simd_type(res);
+  }
+};
+
 // Access trait for direct access to contiguous aligned memory.
 template <typename T> struct Direct_access_traits 
 {
@@ -164,10 +223,21 @@
 	  template <typename, typename> class O> // operator
 struct Binary_access_traits
 {
-  typedef typename Type_equal<typename L::value_type,
-			      typename R::value_type>::type value_type;
+  //typedef typename Type_equal<typename L::value_type,
+  //			      typename R::value_type>::type value_type;
+  typedef Binary_operator_map<typename L::value_type,O> bin_op;
+
+  typedef typename bin_op::value_type  value_type;
+  typedef typename bin_op::return_type return_type;
 };
 
+template <typename P1, typename P2, typename P3,
+          template <typename,typename,typename> class O>
+struct Ternary_access_traits
+{
+  typedef typename P1::value_type value_type;
+};
+
 template <typename T> class Proxy;
 
 // Optimized proxy for direct SIMD access to block data, i.e. the data
@@ -266,15 +336,17 @@
 {
 public:
   typedef Binary_access_traits<L, R, O> access_traits;
-  typedef typename access_traits::value_type value_type;
-  typedef typename Simd_traits<value_type>::simd_type simd_type;
+  typedef typename access_traits::value_type  value_type;
+  typedef typename access_traits::return_type return_type;
+  typedef typename Simd_traits<value_type>::simd_type  simd_type;
+  typedef typename Simd_traits<return_type>::simd_type simd_ret_type;
 
   Proxy(L const &l, R const &r) : left_(l), right_(r) {}
 
   L const &left() const { return left_;}
   R const &right() const { return right_;}
 
-  simd_type load() const 
+  simd_ret_type load() const 
   {
     simd_type l = left_.load();
     simd_type r = right_.load();
@@ -405,6 +477,45 @@
   CD right_;
 };
 
+// Proxy for ternary access traits for ite functor
+template <typename A, typename B, typename C>
+class Proxy<Ternary_access_traits<A,B,C,ite_functor> >
+{
+  typedef typename A::access_traits                   access_traits;
+  typedef typename access_traits::value_type          value_type;
+  typedef typename Simd_traits<value_type>::simd_type simd_type;
+
+public:
+  Proxy(A const &a, B const &b, C const &c)
+    : a_(a), b_(b), c_(c) {}
+
+  simd_type load() const 
+  {
+    typedef typename A::access_traits::return_type return_type;
+    typedef typename A::access_traits::value_type  value_type;
+    typedef typename Simd_traits<return_type>::simd_type simd_ret_type;
+    typedef typename Simd_traits<value_type>::simd_type  simd_val_type;
+    
+    simd_ret_type a_ret  = a_.load(); // this is the mask
+    simd_val_type  b     = b_.load(); // if true
+    simd_val_type  c     = c_.load(); // if false
+    // apply the mask
+    return Ternary_operator_map<value_type,ite_functor>::apply(a_ret,b,c);
+  }
+
+  void increment(length_type n = 1)
+  {
+    a_.increment(n);
+    b_.increment(n);
+    c_.increment(n);
+  }
+
+private:
+  A a_;
+  B b_;
+  C c_;
+};
+
 template <typename T>
 struct Iterator
 {
Index: src/vsip/opt/simd/threshold.cpp
===================================================================
--- src/vsip/opt/simd/threshold.cpp	(revision 171195)
+++ src/vsip/opt/simd/threshold.cpp	(working copy)
@@ -32,18 +32,28 @@
 
 #if !VSIP_IMPL_INLINE_LIBSIMD
 
-template <typename T>
+template <template <typename,typename> class O,
+          typename T>
 void 
 threshold(T* Z, T* A, T* B, T k, int n)
 {
   static bool const Is_vectorized =
-    Is_algorithm_supported<T, false, Alg_threshold>::value;
-  Simd_threshold<T, Is_vectorized>::exec(Z,A,B,k,n);
+    Is_algorithm_supported<T, false, Alg_threshold>::value &&
+    Binary_operator_map<T,O>::is_supported;
+  Simd_threshold<T, O, Is_vectorized>::exec(Z,A,B,k,n);
 }
 
-template void threshold(float* Z, float* A, float* B, float k, int n);
-template void threshold(double* Z, double* A, double* B, double k, int n);
+#define VSIP_OPT_DECL_THRESH(O) \
+template void threshold<O>(float* Z, float* A, float* B, float k, int n); \
+template void threshold<O>(double* Z, double* A, double* B, double k, int n);
 
+VSIP_OPT_DECL_THRESH(gt_functor)
+VSIP_OPT_DECL_THRESH(lt_functor)
+//VSIP_OPT_DECL_THRESH(ge_functor)
+//VSIP_OPT_DECL_THRESH(le_functor)
+
+#undef VSIP_OPT_DECL_THRESH
+
 #endif
 
 }
