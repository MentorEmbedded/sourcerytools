Index: src/vsip/impl/simd/simd.hpp
===================================================================
--- src/vsip/impl/simd/simd.hpp	(revision 146933)
+++ src/vsip/impl/simd/simd.hpp	(working copy)
@@ -1,6 +1,6 @@
 /* Copyright (c) 2006 by CodeSourcery, LLC.  All rights reserved. */
 
-/** @file    vsip/impl/simd.hpp
+/** @file    vsip/impl/simd/simd.hpp
     @author  Jules Bergmann
     @date    2006-01-25
     @brief   VSIPL++ Library: SIMD traits.
@@ -32,8 +32,6 @@
 #include <complex>
 #include <cassert>
 
-
-
 /***********************************************************************
   Definitions
 ***********************************************************************/
@@ -142,6 +140,10 @@
   static simd_type div(simd_type const& v1, simd_type const& v2)
   { return v1 / v2; }
 
+  static simd_type fma(simd_type const& v1, simd_type const& v2,
+		       simd_type const& v3)
+  { return v1 * v2 + v3; }
+
   static simd_type band(simd_type const& v1, simd_type const& v2)
   { return v1 & v2; }
 
@@ -409,6 +411,10 @@
   static simd_type mul(simd_type const& v1, simd_type const& v2)
   { return vec_madd(v1, v2, zero()); }
 
+  static simd_type fma(simd_type const& v1, simd_type const& v2,
+		       simd_type const& v3)
+  { assert(0); return v1; } // FIXME: need to be implemented.
+
   static bool_simd_type gt(simd_type const& v1, simd_type const& v2)
   { return vec_cmpgt(v1, v2); }
 
@@ -657,6 +663,7 @@
 
 
 
+// SSE - float vector
 template <>
 struct Simd_traits<float> {
   typedef float		value_type;
@@ -706,6 +713,10 @@
   static simd_type div(simd_type const& v1, simd_type const& v2)
   { return _mm_div_ps(v1, v2); }
 
+  static simd_type fma(simd_type const& v1, simd_type const& v2,
+		       simd_type const& v3)
+  { return add(mul(v1,v2),v3); }
+
   static simd_type gt(simd_type const& v1, simd_type const& v2)
   { return _mm_cmpgt_ps(v1, v2); }
 
@@ -737,6 +748,7 @@
 
 
 #if defined(__SSE2__)
+// SSE2 - double vector
 template <>
 struct Simd_traits<double> {
   typedef double	value_type;
@@ -786,6 +798,10 @@
   static simd_type div(simd_type const& v1, simd_type const& v2)
   { return _mm_div_pd(v1, v2); }
 
+  static simd_type fma(simd_type const& v1, simd_type const& v2,
+		       simd_type const& v3)
+  { return add(mul(v1,v2),v3); }
+
   static simd_type gt(simd_type const& v1, simd_type const& v2)
   { return _mm_cmpgt_pd(v1, v2); }
 
@@ -817,8 +833,150 @@
 #endif
 #endif
 
+template <typename T>
+struct Simd_traits<std::complex<T> > 
+{
+  typedef Simd_traits<T> base_traits;
 
+  typedef typename Simd_traits<T>::simd_type base_simd_type;
 
+  typedef std::complex<T> value_type;
+  struct simd_type
+  {
+    base_simd_type r;
+    base_simd_type i;
+  };
+   
+  static int const  vec_size  = Simd_traits<T>::vec_size;
+  static bool const is_accel  = Simd_traits<T>::is_accel;
+  static int  const alignment = Simd_traits<T>::alignment;
+
+  static intptr_t alignment_of(value_type const* addr)
+  { return (intptr_t)addr & (alignment - 1); }
+
+  static simd_type zero()
+  {
+    simd_type t = { Simd_traits<T>::zero(), Simd_traits<T>::zero() };
+    return t;
+  }
+
+  static simd_type load(value_type const* addr)
+  {
+    base_simd_type v0 = Simd_traits<T>::load(((T const*)addr)+0);
+    base_simd_type v1 = Simd_traits<T>::load(((T const*)addr)+vec_size);
+    simd_type t = 
+      {
+	Simd_traits<T>::real_from_interleaved(v0, v1),
+	Simd_traits<T>::imag_from_interleaved(v0, v1)
+      };
+    return t;
+  }
+
+  static simd_type load_scalar(value_type value)
+  {
+    simd_type t =
+      {
+	Simd_traits<T>::load_scalar(value.real()),
+	Simd_traits<T>::load_scalar(value.imag())
+      };
+    return t;
+  }
+
+  static simd_type load_scalar_all(value_type value)
+  {
+    simd_type t =
+      {
+	Simd_traits<T>::load_scalar_all(value.real()),
+	Simd_traits<T>::load_scalar_all(value.imag())
+      };
+    return t;
+  }
+
+  static void store(value_type* addr, simd_type const& vec)
+  {
+    base_simd_type v0 = Simd_traits<T>::interleaved_lo_from_split(vec.r,vec.i);
+    base_simd_type v1 = Simd_traits<T>::interleaved_hi_from_split(vec.r,vec.i);
+    Simd_traits<T>::store(((T*)addr)+0,        v0);
+    Simd_traits<T>::store(((T*)addr)+vec_size, v1);
+  }
+
+  static void store_stream(value_type* addr, simd_type const& vec)
+  { store(addr, vec); }
+
+  static simd_type add(simd_type const& v1, simd_type const& v2)
+  {
+    simd_type t =
+      {
+	Simd_traits<T>::add(v1.r, v2.r),
+	Simd_traits<T>::add(v1.i, v2.i)
+      };
+    return t;
+  }
+
+  static simd_type sub(simd_type const& v1, simd_type const& v2)
+  {
+    simd_type t =
+      {
+	Simd_traits<T>::sub(v1.r, v2.r),
+	Simd_traits<T>::sub(v1.i, v2.i)
+      };
+    return t;
+  }
+
+  static simd_type mul(simd_type const& v1, simd_type const& v2)
+  {
+    base_simd_type rr = Simd_traits<T>::mul(v1.r, v2.r);
+    base_simd_type ii = Simd_traits<T>::mul(v1.i, v2.i);
+    base_simd_type r  = Simd_traits<T>::sub(rr, ii);
+    base_simd_type ri = Simd_traits<T>::mul(v1.r, v2.i);
+    base_simd_type ir = Simd_traits<T>::mul(v1.i, v2.r);
+    base_simd_type i  = Simd_traits<T>::add(ri, ir);
+
+    simd_type t = { r, i };
+    return t;
+  }
+
+  static simd_type div(simd_type const& v1, simd_type const& v2)
+  {
+    base_simd_type rr = Simd_traits<T>::mul(v1.r,v2.r);
+    base_simd_type ii = Simd_traits<T>::mul(v1.i,v2.i);
+    base_simd_type ri = Simd_traits<T>::mul(v1.i,v2.r);
+    base_simd_type ir = Simd_traits<T>::mul(v1.r,v2.i);
+    base_simd_type n = Simd_traits<T>::add(Simd_traits<T>::mul(v2.r,v2.r),
+					   Simd_traits<T>::mul(v2.i,v2.i));
+    base_simd_type r = Simd_traits<T>::div(Simd_traits<T>::add(rr,ii),n);
+    base_simd_type i = Simd_traits<T>::div(Simd_traits<T>::sub(ri, ir),n);
+
+    simd_type t = { r, i };
+    return t;
+  }
+
+  static simd_type fma(simd_type const& v1, simd_type const& v2,
+		       simd_type const& v3)
+  { return add(mul(v1, v2), v3);}
+  // No gt.
+  // No sign_mask
+
+  static simd_type extend(simd_type const& v)
+  {
+    simd_type t =
+      {
+	Simd_traits<T>::extend(v.r),
+	Simd_traits<T>::extend(v.i)
+      };
+    return t;
+  }
+
+  // This type *is* complex:
+  //  - no real_from_interleaved
+  //  - no imag_from_interleaved
+  //  - no interleaved_lo_from_split
+  //  - no interleaved_hi_from_split
+
+  static void enter() { Simd_traits<T>::enter(); }
+  static void exit()  { Simd_traits<T>::exit(); }
+};
+
 struct Alg_none;
 struct Alg_vadd;
 struct Alg_vmul;
Index: src/vsip/impl/simd/expr_evaluator.hpp
===================================================================
--- src/vsip/impl/simd/expr_evaluator.hpp	(revision 146933)
+++ src/vsip/impl/simd/expr_evaluator.hpp	(working copy)
@@ -40,7 +40,8 @@
 {
   typedef Direct_access_traits<typename BlockT::value_type> access_traits;
   typedef Proxy<access_traits> proxy_type;
-  static bool const ct_valid = Ext_data_cost<BlockT>::value == 0;
+  static bool const ct_valid = Ext_data_cost<BlockT>::value == 0 &&
+    !Is_split_block<BlockT>::value;
 
   static bool 
   rt_valid(BlockT const &b)
@@ -142,9 +143,15 @@
     // Check that direct access is possible.
     Ext_data_cost<LB>::value == 0 &&
     simd::Proxy_factory<RB>::ct_valid &&
+    // Only allow float, double, complex<float>, and complex<double> at this time.
+    (Type_equal<typename Scalar_of<typename LB::value_type>::type, float>::value ||
+     Type_equal<typename Scalar_of<typename LB::value_type>::type, double>::value) &&
     // Make sure both sides have the same type.
-    Type_equal<typename LB::value_type, typename RB::value_type>::value;
+    Type_equal<typename LB::value_type, typename RB::value_type>::value &&
+    // Make sure the left side is not a complex split block.
+    !Is_split_block<LB>::value;
 
+
   static bool rt_valid(LB& lhs, RB const& rhs)
   {
     Ext_data<LB> dda(lhs, SYNC_OUT);
@@ -162,17 +169,56 @@
     length_type const vec_size =
       simd::Simd_traits<typename LB::value_type>::vec_size;
     Ext_data<LB> dda(lhs, SYNC_OUT);
-    length_type size = dda.size(0) / vec_size;
+    length_type const size = dda.size(0);
+    length_type n = size;
     simd::Proxy<WAT> lp(dda.data());
+    simd::Proxy<EAT> rp(simd::Proxy_factory<RB>::create(rhs));
+#if 0
+    // simple iterator-based loop. It has the most concise syntax,
+    // but generates suboptimal code with gcc 3.4
     simd::Iterator<WAT> li(lp);
     // Map the expression block to an expression iterator and loop.
-    simd::Iterator<EAT> ri(simd::Proxy_factory<RB>::create(rhs));
-    while (size--) *li++ = *ri++;
+    simd::Iterator<EAT> ri(rp);
+    while (n >= vec_size)
+    {
+      *li = *ri;
+      n -= vec_size;
+      ++li;
+      ++ri;
+    }
+#elif 0 
+    // iterator-based loop, partially unrolled. This performs a
+    // little better than the above, but still contains overhead
+    // due to the iterator abstraction with gcc 3.4.
+    simd::Iterator<WAT> li1(lp);
+    simd::Iterator<WAT> li2 = li1 + 1;
+    // Map the expression block to an expression iterator and loop.
+    simd::Iterator<EAT> ri1(rp);
+    simd::Iterator<EAT> ri2 = ri1 + 1;
+    while (n >= 2*vec_size)
+    {
+      n -= 2*vec_size;
+      *li1 = *ri1;
+      *li2 = *ri2;
+      li1 += 2;
+      li2 += 2;
+      ri1 += 2;
+      ri2 += 2;
+    }
+#else
+    // loop using proxy interface. This generates the best code
+    // with gcc 3.4 (with gcc 4.1 the difference to the first case
+    // above is negligible).
+    while (n >= vec_size)
+    {
+      lp.store(rp.load());
+      n -= vec_size;
+      lp.increment();
+      rp.increment();
+    }
+#endif
     // Process the remainder, using simple loop fusion.
-    size = dda.size(0);
-    length_type remainder = size % vec_size;
-    for (index_type i = size - remainder; i != size; ++i)
-      lhs.put(i, rhs.get(i));
+    for (index_type i = size - n; i != size; ++i) lhs.put(i, rhs.get(i));
   }
 };
 
Index: src/vsip/impl/simd/expr_iterator.hpp
===================================================================
--- src/vsip/impl/simd/expr_iterator.hpp	(revision 146933)
+++ src/vsip/impl/simd/expr_iterator.hpp	(working copy)
@@ -34,7 +34,7 @@
 	  template <typename> class O> // operator
 struct Unary_operator_map
 {
-  // The general case, in particular binary functors, are not supported.
+  // The general case, in particular unary functors, are not supported.
   static bool const is_supported = false;
 };
 
@@ -175,7 +175,7 @@
 
   simd_type load() const { return Simd_traits<value_type>::load(ptr_);}
 
-  void increment() { ptr_ += Simd_traits<value_type>::vec_size;}
+  void increment(length_type n = 1) { ptr_ += n * Simd_traits<value_type>::vec_size;}
 
 private:
   value_type const *ptr_;
@@ -204,7 +204,7 @@
   store(simd_type const &value) 
   { Simd_traits<value_type>::store(ptr_, value);}
 
-  void increment() { ptr_ += Simd_traits<value_type>::vec_size;}
+  void increment(length_type n = 1) { ptr_ += n * Simd_traits<value_type>::vec_size;}
 
 private:
   value_type *ptr_;
@@ -222,7 +222,7 @@
   simd_type load() const 
   { return Simd_traits<value_type>::load_scalar_all(value_);}
 
-  void increment() {}
+  void increment(length_type) {}
 
 private:
   value_type value_;
@@ -245,7 +245,7 @@
     return Unary_operator_map<value_type, O>::apply(op);
   }
 
-  void increment() { op_.increment();}
+  void increment(length_type n = 1) { op_.increment(n);}
 
 private:
   ProxyT op_;
@@ -263,6 +263,9 @@
 
   Proxy(L const &l, R const &r) : left_(l), right_(r) {}
 
+  L const &left() const { return left_;}
+  R const &right() const { return right_;}
+
   simd_type load() const 
   {
     simd_type l = left_.load();
@@ -270,10 +273,10 @@
     return Binary_operator_map<value_type, O>::apply(l, r);
   }
 
-  void increment()
+  void increment(length_type n = 1)
   {
-    left_.increment();
-    right_.increment();
+    left_.increment(n);
+    right_.increment(n);
   }
 
 private:
@@ -281,6 +284,119 @@
   R right_;
 };
 
+// Proxy for ternary 'multiply-add' expression (a * b + c)
+template <typename A, typename B, typename C>
+class Proxy<Binary_access_traits<Proxy<Binary_access_traits<A, B, op::Mult> >,
+				 C, op::Add> >
+{
+public:
+  typedef Proxy<Binary_access_traits<A, B, op::Mult> > AB;
+  typedef Binary_access_traits<AB, C, op::Add> access_traits;
+  typedef typename access_traits::value_type value_type;
+  typedef typename Simd_traits<value_type>::simd_type simd_type;
+
+  Proxy(AB const &left, C const &right)
+    : left_(left), right_(right) {}
+
+  AB const &left() const { return left_;}
+  C const &right() const { return right_;}
+
+  simd_type load() const 
+  {
+    simd_type a = left_.left().load();
+    simd_type b = left_.right().load();
+    simd_type c = right_.load();
+    return Simd_traits<value_type>::fma(a, b, c);
+  }
+
+  void increment(length_type n = 1)
+  {
+    left_.increment(n);
+    right_.increment(n);
+  }
+
+private:
+  AB left_;
+  C right_;
+};
+
+// Proxy for ternary 'add-multiply' expression (a + b * c)
+template <typename A, typename B, typename C>
+class Proxy<Binary_access_traits<A,
+				 Proxy<Binary_access_traits<B, C, op::Mult> >,
+				 op::Add> >
+{
+public:
+  typedef Proxy<Binary_access_traits<B, C, op::Mult> > BC;
+  typedef Binary_access_traits<A, BC, op::Add> access_traits;
+  typedef typename access_traits::value_type value_type;
+  typedef typename Simd_traits<value_type>::simd_type simd_type;
+
+  Proxy(A const &left, BC const &right)
+    : left_(left), right_(right) {}
+
+  A const &left() const { return left_;}
+  BC const &right() const { return right_;}
+
+  simd_type load() const 
+  {
+    simd_type a = left_.load();
+    simd_type b = right_.left().load();
+    simd_type c = right_.right().load();
+    return Simd_traits<value_type>::fma(b, c, a);
+  }
+
+  void increment(length_type n = 1)
+  {
+    left_.increment(n);
+    right_.increment(n);
+  }
+
+private:
+  A left_;
+  BC right_;
+};
+
+// Proxy for quaternary 'add-multiply' expression (a * b + c * d)
+// (needed for disambiguation).
+template <typename A, typename B, typename C, typename D>
+class Proxy<Binary_access_traits<Proxy<Binary_access_traits<A, B, op::Mult> >,
+				 Proxy<Binary_access_traits<C, D, op::Mult> >,
+				 op::Add> >
+{
+public:
+  typedef Proxy<Binary_access_traits<A, B, op::Mult> > AB;
+  typedef Proxy<Binary_access_traits<C, D, op::Mult> > CD;
+  typedef Binary_access_traits<AB, CD, op::Add> access_traits;
+  typedef typename access_traits::value_type value_type;
+  typedef typename Simd_traits<value_type>::simd_type simd_type;
+
+  Proxy(AB const &left, CD const &right)
+    : left_(left), right_(right) {}
+
+  AB const &left() const { return left_;}
+  CD const &right() const { return right_;}
+
+  simd_type load() const 
+  {
+    // Implement 'a * b + c * d' as '(a*b) + c * d'.
+    simd_type ab = left_.load();
+    simd_type c = right_.left().load();
+    simd_type d = right_.right().load();
+    return Simd_traits<value_type>::fma(c, d, ab);
+  }
+
+  void increment(length_type n = 1)
+  {
+    left_.increment(n);
+    right_.increment(n);
+  }
+
+private:
+  AB left_;
+  CD right_;
+};
+
 template <typename T>
 struct Iterator
 {
@@ -290,13 +406,23 @@
   bool operator!= (Iterator const &i) const { return !(*this==i);}
   Proxy<T> &operator* () { return cursor_;}
   Proxy<T> *operator-> () { return &cursor_;}
-  Iterator operator++() { cursor_.increment(); return *this;}
+  Iterator &operator++() { cursor_.increment(); return *this;}
   Iterator operator++(int) { Iterator i(*this); cursor_.increment(); return i;}
+  Iterator &operator+=(length_type n) { cursor_.increment(n); return *this;}
 
 private:
   Proxy<T> cursor_;
 };
 
+template <typename T>
+inline Iterator<T> 
+operator+(Iterator<T> const i, length_type n) 
+{
+  Iterator<T> r(i);
+  r += n;
+  return r;
+}
+
 } // namespace vsip::impl::simd
 } // namespace vsip::impl
 } // namespace vsip
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 146933)
+++ ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2006-08-17  Stefan Seefeld  <stefan@codesourcery.com>
+
+	* src/vsip/impl/simd/simd.hpp: Add support for complex types, fma.
+	* src/vsip/impl/simd/expr_evaluator.hpp: Optimizations.
+	* src/vsip/impl/simd/expr_iterator.hpp: Add support for ternary fma.
+	* tests/QMTest/vpp_database.py: Mask '.svn' directories.
+
 2006-08-14  Jules Bergmann  <jules@codesourcery.com>
 
 	* src/vsip/impl/expr_serial_dispatch_fwd.hpp (Serial_dispatch_helper):
Index: tests/QMTest/vpp_database.py
===================================================================
--- tests/QMTest/vpp_database.py	(revision 146933)
+++ tests/QMTest/vpp_database.py	(working copy)
@@ -82,7 +82,7 @@
         dirname = os.path.join(self.GetRoot(), directory)
         return [subdir for subdir in dircache.listdir(dirname)
                 if (os.path.isdir(os.path.join(dirname, subdir)) and
-                    subdir not in ('data', 'CVS', 'QMTest'))]
+                    subdir not in ('data', 'CVS', '.svn', 'QMTest'))]
 
 
     def GetIds(self, kind, directory = "", scan_subdirs = 1):
