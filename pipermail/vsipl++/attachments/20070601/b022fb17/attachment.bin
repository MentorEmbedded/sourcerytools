Index: src/vsip/opt/simd/simd.hpp
===================================================================
--- src/vsip/opt/simd/simd.hpp	(revision 171547)
+++ src/vsip/opt/simd/simd.hpp	(working copy)
@@ -233,10 +233,12 @@
 {
   typedef signed char                     value_type;
   typedef __vector signed char            simd_type;
+  typedef __vector unsigned char          perm_simd_type;
   typedef __vector VSIP_IMPL_AV_BOOL char bool_simd_type;
    
   static int  const vec_size   = 16;
   static bool const is_accel   = true;
+  static bool const has_perm   = true;
   static int  const alignment  = 16;
 
   static unsigned int  const scalar_pos = VSIP_IMPL_SCALAR_POS(vec_size);
@@ -261,7 +263,13 @@
     __vector unsigned char sh = vec_lvsl(0, (value_type*)addr);
     return vec_perm(x0, x1, sh);
   }
+  
+  static perm_simd_type shift_for_addr(value_type* addr)
+  { return vec_lvsl(0, addr);
 
+  static simd_type perm(simd_type x0, simd_type x1, perm_simd_type sh)
+  { return vec_perm(x0, x1, sh); }
+
   static simd_type load_scalar(value_type value)
   {
     union
@@ -322,11 +330,13 @@
 {
   typedef signed short                value_type;
   typedef __vector signed short       simd_type;
+  typedef __vector unsigned char      perm_simd_type;
   typedef __vector VSIP_IMPL_AV_BOOL short bool_simd_type;
   typedef __vector signed char        pack_simd_type;
    
   static int const  vec_size = 8;
   static bool const is_accel = true;
+  static bool const has_perm = true;
   static int  const alignment = 16;
 
   static unsigned int  const scalar_pos = VSIP_IMPL_SCALAR_POS(vec_size);
@@ -350,6 +360,12 @@
     return vec_perm(x0, x1, sh);
   }
 
+  static perm_simd_type shift_for_addr(value_type* addr)
+  { return vec_lvsl(0, addr);
+
+  static simd_type perm(simd_type x0, simd_type x1, perm_simd_type sh)
+  { return vec_perm(x0, x1, sh); }
+
   static simd_type load_scalar(value_type value)
   {
     union
@@ -413,11 +429,13 @@
 {
   typedef signed int                     value_type;
   typedef __vector signed int            simd_type;
+  typedef __vector unsigned char         perm_simd_type;
   typedef __vector VSIP_IMPL_AV_BOOL int bool_simd_type;
   typedef __vector signed short          pack_simd_type;
    
   static int const  vec_size = 4;
   static bool const is_accel = true;
+  static bool const has_perm = true;
   static int  const alignment = 16;
 
   static unsigned int  const scalar_pos = VSIP_IMPL_SCALAR_POS(vec_size);
@@ -441,6 +459,12 @@
     return vec_perm(x0, x1, sh);
   }
 
+  static perm_simd_type shift_for_addr(value_type* addr)
+  { return vec_lvsl(0, addr);
+
+  static simd_type perm(simd_type x0, simd_type x1, perm_simd_type sh)
+  { return vec_perm(x0, x1, sh); }
+
   static simd_type load_scalar(value_type value)
   {
     union
@@ -504,10 +528,12 @@
 {
   typedef float                          value_type;
   typedef __vector float                 simd_type;
+  typedef __vector unsigned char         perm_simd_type;
   typedef __vector VSIP_IMPL_AV_BOOL int bool_simd_type;
    
   static int  const vec_size = 4;
   static bool const is_accel = true;
+  static bool const has_perm = true;
   static int  const alignment = 16;
 
   static unsigned int  const scalar_pos = VSIP_IMPL_SCALAR_POS(vec_size);
@@ -531,6 +557,12 @@
     return vec_perm(x0, x1, sh);
   }
 
+  static perm_simd_type shift_for_addr(value_type* addr)
+  { return vec_lvsl(0, addr);
+
+  static simd_type perm(simd_type x0, simd_type x1, perm_simd_type sh)
+  { return vec_perm(x0, x1, sh); }
+
   static simd_type load_scalar(value_type value)
   {
 #if __ghs__
@@ -631,6 +663,7 @@
    
   static int const  vec_size   = 16;
   static bool const is_accel   = true;
+  static bool const has_perm   = false;
   static int  const alignment  = 16;
   static unsigned int  const scalar_pos = 0;
 
@@ -691,6 +724,7 @@
    
   static int const  vec_size   = 8;
   static bool const is_accel   = true;
+  static bool const has_perm   = false;
   static int  const alignment  = 16;
   static unsigned int  const scalar_pos = 0;
 
@@ -792,6 +826,7 @@
    
   static int const  vec_size   = 4;
   static bool const is_accel   = true;
+  static bool const has_perm   = false;
   static int  const alignment  = 16;
   static unsigned int  const scalar_pos = 0;
 
@@ -879,6 +914,7 @@
    
   static int const  vec_size   = 4;
   static bool const is_accel   = true;
+  static bool const has_perm   = false;
   static int  const alignment  = 16;
   static unsigned int  const scalar_pos = 0;
 
@@ -977,6 +1013,7 @@
    
   static int const  vec_size   = 2;
   static bool const is_accel   = true;
+  static bool const has_perm   = false;
   static int  const alignment  = 16;
   static unsigned int  const scalar_pos = 0;
 
@@ -1085,6 +1122,7 @@
    
   static int const  vec_size  = Simd_traits<T>::vec_size;
   static bool const is_accel  = Simd_traits<T>::is_accel;
+  static bool const has_perm  = Simd_traits<T>::has_perm;
   static int  const alignment = Simd_traits<T>::alignment;
 
   static intptr_t alignment_of(value_type const* addr)
Index: src/vsip/opt/simd/expr_evaluator.hpp
===================================================================
--- src/vsip/opt/simd/expr_evaluator.hpp	(revision 171353)
+++ src/vsip/opt/simd/expr_evaluator.hpp	(working copy)
@@ -43,11 +43,11 @@
 namespace simd
 {
 
-template <typename BlockT>
+template <typename BlockT, bool A>
 struct Proxy_factory
 {
   typedef Direct_access_traits<typename BlockT::value_type> access_traits;
-  typedef Proxy<access_traits> proxy_type;
+  typedef Proxy<access_traits, A> proxy_type;
   typedef typename Adjust_layout_dim<
                      1, typename Block_layout<BlockT>::layout_type>::type
 		layout_type;
@@ -60,9 +60,11 @@
   {
     Ext_data<BlockT, layout_type> dda(b, SYNC_IN);
     return dda.stride(0) == 1 && 
-      Simd_traits<typename BlockT::value_type>::alignment_of(dda.data()) == 0;
+      (!A ||
+       !Simd_traits<typename BlockT::value_type>::alignment_of(dda.data()));
   }
-  static proxy_type 
+
+  static proxy_type
   create(BlockT const &b) 
   {
     Ext_data<BlockT, layout_type> dda(b, SYNC_IN);
@@ -70,75 +72,111 @@
   }
 };
 
-template <typename T>
-struct Proxy_factory<Scalar_block<1, T> >
+template <typename T, bool A>
+struct Proxy_factory<Scalar_block<1, T>, A>
 {
   typedef Scalar_access_traits<T> access_traits;
-  typedef Proxy<access_traits> proxy_type;
+  typedef Proxy<access_traits, A> proxy_type;
   static bool const ct_valid = true;
 
   static bool 
-  rt_valid(Scalar_block<1, T> const &) { return true;}
-  static proxy_type 
-  create(Scalar_block<1, T> const &b) { return proxy_type(b.value());}
+  rt_valid(Scalar_block<1, T> const &) {return true;}
+
+  static proxy_type
+  create(Scalar_block<1, T> const &b) 
+  {
+    return proxy_type(b.value());
+  }
 };
 
 template <dimension_type D,
 	  template <typename> class O,
 	  typename B,
-	  typename T>
-struct Proxy_factory<Unary_expr_block<D, O, B, T> const>
+	  typename T,
+	  bool A>
+struct Proxy_factory<Unary_expr_block<D, O, B, T> const, A>
 {
-  typedef Unary_access_traits<typename Proxy_factory<B>::proxy_type, O>
+  typedef 
+    Unary_access_traits<typename Proxy_factory<B,A>::proxy_type, O>
     access_traits;
-  typedef Proxy<access_traits> proxy_type;
+  typedef Proxy<access_traits,A> proxy_type;
   static bool const ct_valid = Unary_operator_map<T, O>::is_supported;
 
   static bool 
   rt_valid(Unary_expr_block<D, O, B, T> const &b)
   {
-    return Proxy_factory<B>::rt_valid(b.op());
+    return Proxy_factory<B, A>::rt_valid(b.op());
   }
+
   static proxy_type
   create(Unary_expr_block<D, O, B, T> const &b)
   {
-    return proxy_type(Proxy_factory<B>::create(b.op()));
+    return proxy_type(Proxy_factory<B, A>::create(b.op()));
   }
 };
 
+// This proxy is specialized for unaligned blocks. If the user specifies
+// ualigned(block), this is a hint to switch to an unaligned proxy.
+template <dimension_type D,
+	  typename B,
+	  typename T,
+	  bool A>
+struct Proxy_factory<Unary_expr_block<D, unaligned_functor, B, T> const, A>
+{
+  typedef typename Proxy_factory<B, false>::access_traits access_traits;
+  typedef Proxy<access_traits,false> proxy_type;
+  static bool const ct_valid = Proxy_factory<B,false>::ct_valid;
+
+
+  static bool 
+  rt_valid(Unary_expr_block<D, unaligned_functor, B, T> const &b)
+  {
+    return Proxy_factory<B, false>::rt_valid(b.op());
+  }
+
+  static proxy_type
+  create(Unary_expr_block<D, unaligned_functor, B, T> const &b)
+  {
+    return proxy_type(Proxy_factory<B, false>::create(b.op()));
+  }
+};
 template <dimension_type                D,
 	  template <typename, typename> class O,
 	  typename                      LB,
 	  typename                      LT,
 	  typename                      RB,
-	  typename                      RT>
-struct Proxy_factory<Binary_expr_block<D, O, LB, LT, RB, RT> const>
+	  typename                      RT,
+	  bool A>
+struct Proxy_factory<Binary_expr_block<D, O, LB, LT, RB, RT> const, A>
 {
-  typedef Binary_access_traits<typename Proxy_factory<LB>::proxy_type,
-			       typename Proxy_factory<RB>::proxy_type, O> 
+  typedef
+    Binary_access_traits<typename Proxy_factory<LB, A>::proxy_type,
+			 typename Proxy_factory<RB, A>::proxy_type, O> 
     access_traits;
-  typedef Proxy<access_traits> proxy_type;
+  typedef Proxy<access_traits, A> proxy_type;
   static bool const ct_valid = 
     Type_equal<typename LB::value_type, LT>::value &&
     Type_equal<typename RB::value_type, RT>::value &&
     Type_equal<LT, RT>::value &&
     Binary_operator_map<LT, O>::is_supported &&
-    Proxy_factory<LB>::ct_valid &&
-    Proxy_factory<RB>::ct_valid;
+    Proxy_factory<LB, A>::ct_valid &&
+    Proxy_factory<RB, A>::ct_valid;
 
   static bool 
   rt_valid(Binary_expr_block<D, O, LB, LT, RB, RT> const &b)
   {
-    return Proxy_factory<LB>::rt_valid(b.left()) &&
-      Proxy_factory<RB>::rt_valid(b.right());
+    return Proxy_factory<LB, A>::rt_valid(b.left()) &&
+      Proxy_factory<RB, A>::rt_valid(b.right());
   }
+
   static proxy_type
   create(Binary_expr_block<D, O, LB, LT, RB, RT> const &b)
   {
-    typename Proxy_factory<LB>::proxy_type lp =
-      Proxy_factory<LB>::create(b.left());
-    typename Proxy_factory<RB>::proxy_type rp =
-      Proxy_factory<RB>::create(b.right());
+    typename Proxy_factory<LB, A>::proxy_type lp =
+      Proxy_factory<LB, A>::create(b.left());
+    typename Proxy_factory<RB, A>::proxy_type rp =
+      Proxy_factory<RB, A>::create(b.right());
+
     return proxy_type(lp, rp);
   }
 };
@@ -147,42 +185,44 @@
 	  template <typename, typename,typename> class O,
 	  typename                               Block1, typename Type1,
 	  typename                               Block2, typename Type2,
-	  typename                               Block3, typename Type3>
+	  typename                               Block3, typename Type3,
+	  bool A>
 struct Proxy_factory<Ternary_expr_block<D, O,
-  Block1,Type1,Block2,Type2,Block3,Type3> const>
+  Block1,Type1,Block2,Type2,Block3,Type3> const, A>
 {
-  typedef Ternary_access_traits<typename Proxy_factory<Block1>::proxy_type,
-                                typename Proxy_factory<Block2>::proxy_type,
-                                typename Proxy_factory<Block3>::proxy_type,
+  typedef Ternary_access_traits<typename Proxy_factory<Block1, A>::proxy_type,
+                                typename Proxy_factory<Block2, A>::proxy_type,
+                                typename Proxy_factory<Block3, A>::proxy_type,
 		 	        O> 
     access_traits;
 
   typedef Ternary_expr_block<D, O, Block1,Type1,Block2,Type2,Block3,Type3>
     SrcBlock;
 
-  typedef Proxy<access_traits> proxy_type;
+  typedef Proxy<access_traits, A> proxy_type;
   static bool const ct_valid = 
     Ternary_operator_map<Type1, O>::is_supported &&
-    Proxy_factory<Block1>::ct_valid &&
-    Proxy_factory<Block2>::ct_valid &&
-    Proxy_factory<Block3>::ct_valid;
+    Proxy_factory<Block1, A>::ct_valid &&
+    Proxy_factory<Block2, A>::ct_valid &&
+    Proxy_factory<Block3, A>::ct_valid;
 
   static bool 
   rt_valid(SrcBlock const &b)
   {
-    return Proxy_factory<Block1>::rt_valid(b.first()) &&
-           Proxy_factory<Block2>::rt_valid(b.second()) &&
-           Proxy_factory<Block3>::rt_valid(b.third());
+    return Proxy_factory<Block1, A>::rt_valid(b.first()) &&
+           Proxy_factory<Block2, A>::rt_valid(b.second()) &&
+           Proxy_factory<Block3, A>::rt_valid(b.third());
   }
+
   static proxy_type
   create(SrcBlock const &b)
   {
-    typename Proxy_factory<Block1>::proxy_type b1p =
-      Proxy_factory<Block1>::create(b.first());
-    typename Proxy_factory<Block2>::proxy_type b2p =
-      Proxy_factory<Block2>::create(b.second());
-    typename Proxy_factory<Block3>::proxy_type b3p =
-      Proxy_factory<Block3>::create(b.third());
+    typename Proxy_factory<Block1, A>::proxy_type
+      b1p = Proxy_factory<Block1, A>::create(b.first());
+    typename Proxy_factory<Block2, A>::proxy_type
+      b2p = Proxy_factory<Block2, A>::create(b.second());
+    typename Proxy_factory<Block3, A>::proxy_type
+      b3p = Proxy_factory<Block3, A>::create(b.third());
 
     return proxy_type(b1p,b2p,b3p);
   }
@@ -190,6 +230,9 @@
 
 } // namespace vsip::impl::simd
 
+
+// This evaluator is for aligned data only.
+// Look at Simd_unaligned_loop_fusion_tag for unaligned data.
 template <typename LB,
 	  typename RB>
 struct Serial_expr_evaluator<1, LB, RB, Simd_loop_fusion_tag>
@@ -205,7 +248,7 @@
     simd::Simd_traits<typename LB::value_type>::is_accel &&
     // Check that direct access is possible.
     Ext_data_cost<LB>::value == 0 &&
-    simd::Proxy_factory<RB>::ct_valid &&
+    simd::Proxy_factory<RB, true>::ct_valid &&
     // Only allow float, double, complex<float>, and complex<double> at this time.
     (Type_equal<typename Scalar_of<typename LB::value_type>::type, float>::value ||
      Type_equal<typename Scalar_of<typename LB::value_type>::type, double>::value) &&
@@ -221,20 +264,24 @@
     return (dda.stride(0) == 1 &&
 	    simd::Simd_traits<typename LB::value_type>::
 	      alignment_of(dda.data()) == 0 &&
-	    simd::Proxy_factory<RB>::rt_valid(rhs));
+	    simd::Proxy_factory<RB, true>::rt_valid(rhs));
   }
 
   static void exec(LB& lhs, RB const& rhs)
   {
     typedef typename simd::LValue_access_traits<typename LB::value_type> WAT;
-    typedef typename simd::Proxy_factory<RB>::access_traits EAT;
+    typedef typename simd::Proxy_factory<RB, true>::access_traits EAT;
+    typedef typename simd::Proxy_factory<RB, true>::proxy_type proxy_type;
+
     length_type const vec_size =
       simd::Simd_traits<typename LB::value_type>::vec_size;
     Ext_data<LB, layout_type> dda(lhs, SYNC_OUT);
+
+    simd::Proxy<WAT,true> lp(dda.data());
+    proxy_type rp(simd::Proxy_factory<RB,true>::create(rhs));
+
     length_type const size = dda.size(0);
     length_type n = size;
-    simd::Proxy<WAT> lp(dda.data());
-    simd::Proxy<EAT> rp(simd::Proxy_factory<RB>::create(rhs));
 #if 0
     // simple iterator-based loop. It has the most concise syntax,
     // but generates suboptimal code with gcc 3.4
@@ -285,6 +332,110 @@
 };
 
 
+// This evaluator is for unaligned data. Any time any of the blocks are
+// unaligned, we use this evalutator. Basically, in the evaluator list, this
+// evaluator is right after the aligned evaluator and rt_valid determines
+// which one to use.
+template <typename LB,
+	  typename RB>
+struct Serial_expr_evaluator<1, LB, RB, Simd_unaligned_loop_fusion_tag>
+{
+  typedef typename Adjust_layout_dim<
+                     1, typename Block_layout<LB>::layout_type>::type
+		layout_type;
+
+  static char const* name() { return "Expr_SIMD_Unaligned_Loop"; }
+  
+  static bool const ct_valid =
+    // Is SIMD supported at all ?
+    simd::Simd_traits<typename LB::value_type>::is_accel &&
+    // Check that direct access is possible.
+    Ext_data_cost<LB>::value == 0 &&
+    simd::Proxy_factory<RB, false>::ct_valid &&
+    // Only allow float, double, complex<float>,
+    // and complex<double> at this time.
+    (Type_equal<typename Scalar_of<typename LB::value_type>::type, float>::value ||
+     Type_equal<typename Scalar_of<typename LB::value_type>::type, double>::value) &&
+    // Make sure both sides have the same type.
+    Type_equal<typename LB::value_type, typename RB::value_type>::value &&
+    // Make sure the left side is not a complex split block.
+    !Is_split_block<LB>::value;
+
+
+  static bool rt_valid(LB& lhs, RB const& rhs)
+  {
+    Ext_data<LB, layout_type> dda(lhs, SYNC_OUT);
+    return (dda.stride(0) == 1 &&
+	    simd::Simd_traits<typename LB::value_type>::
+	      alignment_of(dda.data()) == 0 &&
+	    simd::Proxy_factory<RB, false>::rt_valid(rhs));
+  }
+
+  static void exec(LB& lhs, RB const& rhs)
+  {
+    typedef typename simd::LValue_access_traits<typename LB::value_type> WAT;
+    typedef typename simd::Proxy_factory<RB, false>::access_traits EAT;
+
+    length_type const vec_size =
+      simd::Simd_traits<typename LB::value_type>::vec_size;
+    Ext_data<LB, layout_type> dda(lhs, SYNC_OUT);
+
+    simd::Proxy<WAT,false> lp(dda.data());
+    simd::Proxy<EAT,false> rp(simd::Proxy_factory<RB,false>::create(rhs));
+
+    length_type const size = dda.size(0);
+    length_type n = size;
+#if 0
+    // simple iterator-based loop. It has the most concise syntax,
+    // but generates suboptimal code with gcc 3.4
+    simd::Iterator<WAT> li(lp);
+    // Map the expression block to an expression iterator and loop.
+    simd::Iterator<EAT> ri(rp);
+    while (n >= vec_size)
+    {
+      *li = *ri;
+      n -= vec_size;
+      ++li;
+      ++ri;
+    }
+#elif 0 
+    // iterator-based loop, partially unrolled. This performs a
+    // little better than the above, but still contains overhead
+    // due to the iterator abstraction with gcc 3.4.
+    simd::Iterator<WAT> li1(lp);
+    simd::Iterator<WAT> li2 = li1 + 1;
+    // Map the expression block to an expression iterator and loop.
+    simd::Iterator<EAT> ri1(rp);
+    simd::Iterator<EAT> ri2 = ri1 + 1;
+    while (n >= 2*vec_size)
+    {
+      n -= 2*vec_size;
+      *li1 = *ri1;
+      *li2 = *ri2;
+      li1 += 2;
+      li2 += 2;
+      ri1 += 2;
+      ri2 += 2;
+    }
+#else
+    // loop using proxy interface. This generates the best code
+    // with gcc 3.4 (with gcc 4.1 the difference to the first case
+    // above is negligible).
+
+    while (n >= vec_size)
+    {
+      lp.store(rp.load());
+      n -= vec_size;
+      lp.increment();
+      rp.increment();
+    }
+#endif
+    // Process the remainder, using simple loop fusion.
+    for (index_type i = size - n; i != size; ++i) lhs.put(i, rhs.get(i));
+  }
+};
+
+
 } // namespace vsip::impl
 } // namespace vsip
 
Index: src/vsip/opt/simd/expr_iterator.hpp
===================================================================
--- src/vsip/opt/simd/expr_iterator.hpp	(revision 171353)
+++ src/vsip/opt/simd/expr_iterator.hpp	(working copy)
@@ -244,12 +244,73 @@
   typedef typename P1::value_type value_type;
 };
 
-template <typename T> class Proxy;
+template <typename T,
+          bool has_perm = Simd_traits<T>::has_perm>
+struct Simd_unaligned_loader;
 
+template <typename T>
+struct Simd_unaligned_loader<T, true>
+{
+  typedef Simd_traits<T>                 simd;
+  typedef typename simd::simd_type       simd_type;
+  typedef typename simd::perm_simd_type  perm_simd_type;
+  typedef typename simd::value_type      value_type;
+
+  Simd_unaligned_loader(value_type const* ptr) : ptr_unaligned_(ptr) 
+  {
+    ptr_aligned_    = (simd_type*)((intptr_t)ptr & ~(simd::alignment-1));
+
+    x0_  = simd::load((value_type*)ptr_aligned_);
+    x1_  = simd::load((value_type*)(ptr_aligned_+simd::vec_size));
+    sh_  = simd::shift_for_addr(ptr_unaligned_);
+  }
+
+  simd_type load() const
+  { return simd::perm(x0_, x1_, sh_); }
+
+  void increment(length_type n = 1)
+  {
+    ptr_unaligned_ += n * Simd_traits<value_type>::vec_size;
+    ptr_aligned_   += n;
+  
+    // update x0
+    x0_ = (n == 1)? x1_:simd::load((value_type*)ptr_aligned_);
+
+    // update x1
+    x1_ = simd::load((value_type*)(ptr_aligned_+simd::vec_size));
+  }
+
+  value_type const*            ptr_unaligned_;
+  simd_type const*             ptr_aligned_;
+  simd_type                    x0_;
+  simd_type                    x1_;
+  perm_simd_type               sh_;
+
+};
+
+template <typename T>
+struct Simd_unaligned_loader<T, false>
+{
+  typedef Simd_traits<T>            simd;
+  typedef typename simd::simd_type  simd_type;
+  typedef typename simd::value_type value_type;
+
+  Simd_unaligned_loader(value_type const* ptr) : ptr_unaligned_(ptr) {}
+
+  simd_type load() const { return simd::load_unaligned(ptr_unaligned_); }
+
+  void increment(length_type n = 1)
+  { ptr_unaligned_ += n * Simd_traits<value_type>::vec_size; }
+
+  value_type const*            ptr_unaligned_;
+};
+
+template <typename T, bool IsAligned> class Proxy;
+
 // Optimized proxy for direct SIMD access to block data, i.e. the data
 // is contiguous (unit stride) and correctly aligned.
 template <typename T>
-class Proxy<Direct_access_traits<T> >
+class Proxy<Direct_access_traits<T>,true >
 {
 public:
   typedef T value_type;
@@ -259,16 +320,38 @@
 
   simd_type load() const { return Simd_traits<value_type>::load(ptr_);}
 
-  void increment(length_type n = 1) { ptr_ += n * Simd_traits<value_type>::vec_size;}
+  void increment(length_type n = 1)
+  { ptr_ += n * Simd_traits<value_type>::vec_size;}
 
 private:
   value_type const *ptr_;
 };
 
+template <typename T>
+class Proxy<Direct_access_traits<T>,false >
+{
+public:
+  typedef T value_type;
+  typedef Simd_traits<value_type>                     simd;
+  typedef typename simd::simd_type                    simd_type;
+
+  Proxy(value_type const *ptr) : simd_loader_(ptr) {}
+
+  simd_type load() const
+  { return simd_loader_.load(); }
+
+  void increment(length_type n = 1) 
+  { simd_loader_.increment(n); }
+
+private:
+  Simd_unaligned_loader<T>      simd_loader_;
+};
+
+
 // Optimized proxy for direct SIMD access to writable block data, i.e. 
 // the data is contiguous (unit stride) and correctly aligned.
-template <typename T>
-class Proxy<LValue_access_traits<T> >
+template <typename T, bool IsAligned>
+class Proxy<LValue_access_traits<T>,IsAligned >
 {
 public:
   typedef T value_type;
@@ -276,7 +359,7 @@
 
   Proxy(value_type *ptr) : ptr_(ptr) {}
   template <typename T1>
-  Proxy operator = (Proxy<T1> const &o) 
+  Proxy operator = (Proxy<T1,IsAligned> const &o) 
   {
     store(o.load());
     return *this;
@@ -294,8 +377,8 @@
   value_type *ptr_;
 };
 
-template <typename T>
-class Proxy<Scalar_access_traits<T> >
+template <typename T, bool IsAligned>
+class Proxy<Scalar_access_traits<T>, IsAligned>
 {
 public:
   typedef T value_type;
@@ -313,8 +396,8 @@
 };
 
 // Proxy for unary expressions.
-template <typename ProxyT, template <typename> class O>
-class Proxy<Unary_access_traits<ProxyT, O> >
+template <typename ProxyT, template <typename> class O, bool IsAligned>
+class Proxy<Unary_access_traits<ProxyT, O>, IsAligned>
 {
 public:
   typedef Unary_access_traits<ProxyT, O> access_traits;
@@ -337,8 +420,9 @@
 
 // Proxy for binary expressions. The two proxy operands L and R are 
 // combined using binary operator O.
-template <typename L, typename R, template <typename, typename> class O>
-class Proxy<Binary_access_traits<L, R, O> >
+template <typename L, typename R, template <typename, typename> class O,
+          bool IsAligned>
+class Proxy<Binary_access_traits<L, R, O>, IsAligned>
 {
 public:
   typedef Binary_access_traits<L, R, O> access_traits;
@@ -371,12 +455,13 @@
 };
 
 // Proxy for ternary 'multiply-add' expression (a * b + c)
-template <typename A, typename B, typename C>
-class Proxy<Binary_access_traits<Proxy<Binary_access_traits<A, B, op::Mult> >,
-				 C, op::Add> >
+template <typename A, typename B, typename C, bool IsAligned>
+class Proxy<Binary_access_traits<
+               Proxy<Binary_access_traits<A, B, op::Mult>, IsAligned>,
+               C, op::Add>, IsAligned>
 {
 public:
-  typedef Proxy<Binary_access_traits<A, B, op::Mult> > AB;
+  typedef Proxy<Binary_access_traits<A, B, op::Mult>, IsAligned> AB;
   typedef Binary_access_traits<AB, C, op::Add> access_traits;
   typedef typename access_traits::value_type value_type;
   typedef typename Simd_traits<value_type>::simd_type simd_type;
@@ -407,13 +492,13 @@
 };
 
 // Proxy for ternary 'add-multiply' expression (a + b * c)
-template <typename A, typename B, typename C>
+template <typename A, typename B, typename C, bool IsAligned>
 class Proxy<Binary_access_traits<A,
-				 Proxy<Binary_access_traits<B, C, op::Mult> >,
-				 op::Add> >
+		Proxy<Binary_access_traits<B, C, op::Mult>, IsAligned>,
+		op::Add>, IsAligned>
 {
 public:
-  typedef Proxy<Binary_access_traits<B, C, op::Mult> > BC;
+  typedef Proxy<Binary_access_traits<B, C, op::Mult>, IsAligned> BC;
   typedef Binary_access_traits<A, BC, op::Add> access_traits;
   typedef typename access_traits::value_type value_type;
   typedef typename Simd_traits<value_type>::simd_type simd_type;
@@ -445,14 +530,15 @@
 
 // Proxy for quaternary 'add-multiply' expression (a * b + c * d)
 // (needed for disambiguation).
-template <typename A, typename B, typename C, typename D>
-class Proxy<Binary_access_traits<Proxy<Binary_access_traits<A, B, op::Mult> >,
-				 Proxy<Binary_access_traits<C, D, op::Mult> >,
-				 op::Add> >
+template <typename A, typename B, typename C, typename D, bool IsAligned>
+class Proxy<Binary_access_traits<
+	Proxy<Binary_access_traits<A, B, op::Mult>, IsAligned>,
+	Proxy<Binary_access_traits<C, D, op::Mult>, IsAligned>,
+	op::Add>, IsAligned>
 {
 public:
-  typedef Proxy<Binary_access_traits<A, B, op::Mult> > AB;
-  typedef Proxy<Binary_access_traits<C, D, op::Mult> > CD;
+  typedef Proxy<Binary_access_traits<A, B, op::Mult>, IsAligned> AB;
+  typedef Proxy<Binary_access_traits<C, D, op::Mult>, IsAligned> CD;
   typedef Binary_access_traits<AB, CD, op::Add> access_traits;
   typedef typename access_traits::value_type value_type;
   typedef typename Simd_traits<value_type>::simd_type simd_type;
@@ -485,8 +571,9 @@
 
 // Proxy for ternary access traits
 template <typename A, typename B, typename C,
-          template <typename,typename,typename> class O>
-class Proxy<Ternary_access_traits<A,B,C,O> >
+          template <typename,typename,typename> class O,
+	  bool IsAligned>
+class Proxy<Ternary_access_traits<A,B,C,O>, IsAligned>
 {
   typedef typename A::access_traits                   access_traits;
   typedef typename access_traits::value_type          value_type;
@@ -523,6 +610,7 @@
   C c_;
 };
 
+/*
 template <typename T>
 struct Iterator
 {
@@ -548,6 +636,7 @@
   r += n;
   return r;
 }
+*/
 
 } // namespace vsip::impl::simd
 } // namespace vsip::impl
Index: src/vsip/core/fns_elementwise.hpp
===================================================================
--- src/vsip/core/fns_elementwise.hpp	(revision 165174)
+++ src/vsip/core/fns_elementwise.hpp	(working copy)
@@ -373,6 +373,20 @@
 VSIP_IMPL_UNARY_DISPATCH(impl_imag)
 VSIP_IMPL_UNARY_FUNCTION(impl_imag)
 
+// This unary operator gives a hint to the compiler that this block is
+// unaligned
+template <typename T>
+struct unaligned_functor
+{
+  typedef T result_type;
+  static char const* name() { return "unaligned"; }                
+  static result_type apply(T t) { return t;}
+  result_type operator()(T t) const { return apply(t);}
+};
+
+VSIP_IMPL_UNARY_DISPATCH(unaligned)
+VSIP_IMPL_UNARY_FUNCTION(unaligned)
+
 /***********************************************************************
   Binary Functions
 ***********************************************************************/
