Index: src/vsip/impl/simd/simd.hpp
===================================================================
--- src/vsip/impl/simd/simd.hpp	(revision 145525)
+++ src/vsip/impl/simd/simd.hpp	(working copy)
@@ -103,7 +103,7 @@
   static intptr_t alignment_of(value_type const* addr)
   { return (intptr_t)addr & (alignment - 1); }
 
-  static simd_type load(value_type* addr)
+  static simd_type load(value_type const* addr)
   { return *addr; }
 
   static void store(value_type* addr, simd_type const& vec)
@@ -115,6 +115,9 @@
   static simd_type mul(simd_type const& v1, simd_type const& v2)
   { return v1 * v2; }
 
+  static simd_type div(simd_type const& v1, simd_type const& v2)
+  { return v1 / v2; }
+
   static void enter() {}
   static void exit()  {}
 };
@@ -134,7 +137,7 @@
   static intptr_t alignment_of(value_type const* addr)
   { return (intptr_t)addr & (alignment - 1); }
 
-   static simd_type load(value_type* addr) {
+   static simd_type load(value_type const* addr) {
       vector short res;
       res = vec_ld(0, (short*)addr);
       return res;
@@ -170,7 +173,7 @@
   static simd_type zero()
   { return _mm_setzero_si128(); }
 
-  static simd_type load(value_type* addr)
+  static simd_type load(value_type const* addr)
   { return _mm_load_si128((simd_type*)addr); }
 
   static simd_type load_scalar(value_type value)
@@ -237,7 +240,7 @@
   static simd_type zero()
   { return _mm_setzero_ps(); }
 
-  static simd_type load(value_type* addr)
+  static simd_type load(value_type const* addr)
   { return _mm_load_ps(addr); }
 
   static simd_type load_scalar(value_type value)
@@ -268,6 +271,9 @@
   static simd_type mul(simd_type const& v1, simd_type const& v2)
   { return _mm_mul_ps(v1, v2); }
 
+  static simd_type div(simd_type const& v1, simd_type const& v2)
+  { return _mm_div_ps(v1, v2); }
+
   static simd_type extend(simd_type const& v)
   { return _mm_shuffle_ps(v, v, 0x00); }
 
@@ -308,7 +314,7 @@
   static simd_type zero()
   { return _mm_setzero_pd(); }
 
-  static simd_type load(value_type* addr)
+  static simd_type load(value_type const* addr)
   { return _mm_load_pd(addr); }
 
   static simd_type load_scalar(value_type value)
@@ -339,6 +345,9 @@
   static simd_type mul(simd_type const& v1, simd_type const& v2)
   { return _mm_mul_pd(v1, v2); }
 
+  static simd_type div(simd_type const& v1, simd_type const& v2)
+  { return _mm_div_pd(v1, v2); }
+
   static simd_type extend(simd_type const& v)
   { return _mm_shuffle_pd(v, v, 0x0); }
 
Index: src/vsip/impl/simd/expr_evaluator.hpp
===================================================================
--- src/vsip/impl/simd/expr_evaluator.hpp	(revision 0)
+++ src/vsip/impl/simd/expr_evaluator.hpp	(revision 0)
@@ -0,0 +1,175 @@
+/* Copyright (c) 2006 by CodeSourcery, Inc.  All rights reserved. */
+
+/** @file    vsip/impl/simd/expr_evaluator.hpp
+    @author  Stefan Seefeld
+    @date    2006-07-25
+    @brief   VSIPL++ Library: SIMD expression evaluator logic.
+
+*/
+
+#ifndef VSIP_IMPL_SIMD_EXPR_EVALUATOR_HPP
+#define VSIP_IMPL_SIMD_EXPR_EVALUATOR_HPP
+
+/***********************************************************************
+  Included Files
+***********************************************************************/
+
+#include <vsip/support.hpp>
+#include <vsip/impl/simd/simd.hpp>
+#include <vsip/impl/simd/expr_iterator.hpp>
+#include <vsip/impl/expr_operations.hpp>
+#include <vsip/impl/expr_unary_block.hpp>
+#include <vsip/impl/expr_binary_block.hpp>
+#include <vsip/impl/metaprogramming.hpp>
+#include <vsip/impl/extdata.hpp>
+#include <vsip/impl/expr_serial_evaluator.hpp>
+
+/***********************************************************************
+  Definitions
+***********************************************************************/
+
+namespace vsip
+{
+namespace impl
+{
+namespace simd
+{
+
+template <typename B>
+struct Proxy_factory
+{
+  typedef Direct_access_traits<typename B::value_type> access_traits;
+  typedef Proxy<access_traits> proxy_type;
+  static bool const ct_valid = true;
+
+  static bool 
+  rt_valid(B const &b)
+  {
+    Ext_data<B> dda(b, SYNC_IN);
+    return dda.stride(0) == 1 && 
+      Simd_traits<typename B::value_type>::alignment_of(dda.data()) == 0;
+  }
+  static proxy_type 
+  create(B const &b) 
+  {
+    Ext_data<B> dda(b, SYNC_IN);
+    return proxy_type(dda.data());
+  }
+};
+
+template <typename T>
+struct Proxy_factory<Scalar_block<1, T> >
+{
+  typedef Scalar_access_traits<T> access_traits;
+  typedef Proxy<access_traits> proxy_type;
+  static bool const ct_valid = true;
+
+  static bool 
+  rt_valid(Scalar_block<1, T> const &) { return true;}
+  static proxy_type 
+  create(Scalar_block<1, T> const &b) { return proxy_type(b.value());}
+};
+
+template <dimension_type D,
+	  template <typename> class O,
+	  typename B,
+	  typename T>
+struct Proxy_factory<Unary_expr_block<D, O, B, T> const>
+{
+  typedef Unary_access_traits<typename Proxy_factory<B>::proxy_type, O>
+    access_traits;
+  typedef Proxy<access_traits> proxy_type;
+  static bool const ct_valid = Unary_operator_map<T, O>::is_supported;
+
+  static bool 
+  rt_valid(Unary_expr_block<D, O, B, T> const &b)
+  {
+    return Proxy_factory<B>::rt_valid(b.op());
+  }
+  static proxy_type
+  create(Unary_expr_block<D, O, B, T> const &b)
+  {
+    return proxy_type(Proxy_factory<B>::create(b.op()));
+  }
+};
+
+template <dimension_type                D,
+	  template <typename, typename> class O,
+	  typename                      LB,
+	  typename                      LT,
+	  typename                      RB,
+	  typename                      RT>
+struct Proxy_factory<Binary_expr_block<D, O, LB, LT, RB, RT> const>
+{
+  typedef Binary_access_traits<typename Proxy_factory<LB>::proxy_type,
+			       typename Proxy_factory<RB>::proxy_type, O> 
+    access_traits;
+  typedef Proxy<access_traits> proxy_type;
+  static bool const ct_valid = Type_equal<typename LB::value_type, LT>::value &&
+                               Type_equal<typename RB::value_type, RT>::value &&
+                               Type_equal<LT, RT>::value &&
+                               Binary_operator_map<LT, O>::is_supported &&
+			       Proxy_factory<LB>::ct_valid &&
+                               Proxy_factory<RB>::ct_valid;
+
+  static bool 
+  rt_valid(Binary_expr_block<D, O, LB, LT, RB, RT> const &b)
+  {
+    return Proxy_factory<LB>::rt_valid(b.left()) &&
+      Proxy_factory<RB>::rt_valid(b.right());
+  }
+  static proxy_type
+  create(Binary_expr_block<D, O, LB, LT, RB, RT> const &b)
+  {
+    typename Proxy_factory<LB>::proxy_type lp = Proxy_factory<LB>::create(b.left());
+    typename Proxy_factory<RB>::proxy_type rp = Proxy_factory<RB>::create(b.right());
+    return proxy_type(lp, rp);
+  }
+};
+
+} // namespace vsip::impl::simd
+
+template <typename LB,
+	  typename RB>
+struct Serial_expr_evaluator<1, LB, RB, Simd_tag>
+{
+  static bool const ct_valid =
+    // Is SIMD supported at all ?
+    simd::Simd_traits<typename LB::value_type>::is_accel &&
+    // Check that direct access is possible.
+    Ext_data_cost<LB>::value == 0 &&
+    simd::Proxy_factory<RB>::ct_valid;
+
+  static bool rt_valid(LB& lhs, RB const& rhs)
+  {
+    Ext_data<LB> dda(lhs, SYNC_OUT);
+    return (dda.stride(0) == 1 &&
+	    simd::Simd_traits<typename LB::value_type>::
+	      alignment_of(dda.data()) == 0 &&
+	    simd::Proxy_factory<RB>::rt_valid(rhs));
+  }
+  
+  static void exec(LB& lhs, RB const& rhs)
+  {
+    typedef typename simd::LValue_access_traits<typename LB::value_type> WAT;
+    typedef typename simd::Proxy_factory<RB>::access_traits EAT;
+    length_type const vec_size = simd::Simd_traits<typename LB::value_type>::vec_size;
+    Ext_data<LB> dda(lhs, SYNC_OUT);
+    length_type size = dda.size(0) / vec_size;
+    simd::Proxy<WAT> lp(dda.data());
+    simd::Iterator<WAT> li(lp);
+    // Map the expression block to an expression iterator and loop.
+    simd::Iterator<EAT> ri(simd::Proxy_factory<RB>::create(rhs));
+    while (size--) *li++ = *ri++;
+    // Process the remainder, using simple loop fusion.
+    size = dda.size(0);
+    length_type remainder = size % vec_size;
+    for (index_type i = size - remainder; i != size; ++i) lhs.put(i, rhs.get(i));
+  }
+};
+
+
+} // namespace vsip::impl
+} // namespace vsip
+
+#endif
Index: src/vsip/impl/simd/expr_iterator.hpp
===================================================================
--- src/vsip/impl/simd/expr_iterator.hpp	(revision 0)
+++ src/vsip/impl/simd/expr_iterator.hpp	(revision 0)
@@ -0,0 +1,276 @@
+/* Copyright (c) 2006 by CodeSourcery, Inc.  All rights reserved. */
+
+/** @file    vsip/impl/simd/expr_iterator.hpp
+    @author  Stefan Seefeld
+    @date    2006-07-18
+    @brief   VSIPL++ Library: SIMD expression iterators.
+
+*/
+
+#ifndef VSIP_IMPL_SIMD_EXPR_ITERATOR_HPP
+#define VSIP_IMPL_SIMD_EXPR_ITERATOR_HPP
+
+/***********************************************************************
+  Included Files
+***********************************************************************/
+
+#include <vsip/support.hpp>
+#include <vsip/impl/simd/simd.hpp>
+#include <vsip/impl/expr_operations.hpp>
+#include <vsip/impl/metaprogramming.hpp>
+
+/***********************************************************************
+  Definitions
+***********************************************************************/
+
+namespace vsip
+{
+namespace impl
+{
+namespace simd
+{
+
+template <typename T, template <typename> class O> 
+struct Unary_operator_map
+{
+  // The general case, in particular binary functors, are not supported.
+  static bool const is_supported = false;
+};
+
+template <typename T> 
+struct Unary_operator_map<T, op::Plus>
+{
+  typedef typename Simd_traits<T>::simd_type simd_type;
+  static bool const is_supported = true;
+  static simd_type 
+  apply(simd_type const &op)
+  { return Simd_traits<T>::add(Simd_traits<T>::zero(), op);}
+};
+
+template <typename T> 
+struct Unary_operator_map<T, op::Minus>
+{
+  typedef typename Simd_traits<T>::simd_type simd_type;
+  static bool const is_supported = true;
+  static simd_type 
+  apply(simd_type const &op)
+  { return Simd_traits<T>::sub(Simd_traits<T>::zero(), op);}
+};
+
+template <typename T, template <typename, typename> class O> 
+struct Binary_operator_map
+{
+  // The general case, in particular binary functors, are not supported.
+  static bool const is_supported = false;
+};
+
+template <typename T>
+struct Binary_operator_map<T, op::Add>
+{
+  typedef typename Simd_traits<T>::simd_type simd_type;
+  static bool const is_supported = true;
+  static simd_type 
+  apply(simd_type const &left, simd_type const &right)
+  { return Simd_traits<T>::add(left, right);}
+};
+
+template <typename T>
+struct Binary_operator_map<T, op::Sub>
+{
+  typedef typename Simd_traits<T>::simd_type simd_type;
+  static bool const is_supported = true;
+  static simd_type 
+  apply(simd_type const &left, simd_type const &right)
+  { return Simd_traits<T>::sub(left, right);}
+};
+
+template <typename T>
+struct Binary_operator_map<T, op::Mult>
+{
+  typedef typename Simd_traits<T>::simd_type simd_type;
+  static bool const is_supported = true;
+  static simd_type 
+  apply(simd_type const &left, simd_type const &right)
+  { return Simd_traits<T>::mul(left, right);}
+};
+
+template <typename T>
+struct Binary_operator_map<T, op::Div>
+{
+  typedef typename Simd_traits<T>::simd_type simd_type;
+  static bool const is_supported = true;
+  static simd_type 
+  apply(simd_type const &left, simd_type const &right)
+  { return Simd_traits<T>::div(left, right);}
+};
+
+// Access trait for direct access to contiguous aligned memory.
+template <typename T> struct Direct_access_traits { typedef T value_type;};
+
+// Access trait for direct lvalue access to contiguous aligned memory.
+template <typename T> struct LValue_access_traits { typedef T value_type;};
+
+// Access trait for unaccelerated access. Either non-contiguous or not aligned.
+template <typename T> struct Indirect_access_traits { typedef T value_type;};
+
+// Access trait for scalar blocks.
+template <typename T> struct Scalar_access_traits { typedef T value_type;};
+
+template <typename T> struct Complex_inter_access_traits { typedef T value_type;};
+template <typename T> struct Complex_split_access_traits { typedef T value_type;};
+
+// Access trait for unary expressions.
+template <typename T, template <typename> class O>
+struct Unary_access_traits
+{
+  typedef T value_type;
+};
+
+// Access trait for binary expressions. Both operands have the same value_type.
+// TODO: Support (T, std::complex<T>) and (std::complex<T>, T) binary operations.
+template <typename L, typename R, template <typename, typename> class O>
+struct Binary_access_traits
+{
+  typedef typename Type_equal<typename L::value_type,
+			      typename R::value_type>::type value_type;
+};
+
+template <typename T> class Proxy;
+
+// Optimized proxy for direct SIMD access to block data, i.e. the data
+// is contiguous (unit stride) and correctly aligned.
+template <typename T>
+class Proxy<Direct_access_traits<T> >
+{
+public:
+  typedef T value_type;
+  typedef typename Simd_traits<value_type>::simd_type simd_type;
+
+  Proxy(value_type const *ptr) : ptr_(ptr) {}
+
+  simd_type load() const { return Simd_traits<value_type>::load(ptr_);}
+
+  void increment() { ptr_ += Simd_traits<value_type>::vec_size;}
+
+private:
+  value_type const *ptr_;
+};
+
+// Optimized proxy for direct SIMD access to writable block data, i.e. the data
+// is contiguous (unit stride) and correctly aligned.
+template <typename T>
+class Proxy<LValue_access_traits<T> >
+{
+public:
+  typedef T value_type;
+  typedef typename Simd_traits<value_type>::simd_type simd_type;
+
+  Proxy(value_type *ptr) : ptr_(ptr) {}
+  template <typename T1>
+  Proxy operator = (Proxy<T1> const &o) 
+  {
+    store(o.load());
+    return *this;
+  }
+
+  simd_type load() const { return Simd_traits<value_type>::load(ptr_);}
+  void store(simd_type const &value) { Simd_traits<value_type>::store(ptr_, value);}
+
+  void increment() { ptr_ += Simd_traits<value_type>::vec_size;}
+
+private:
+  value_type *ptr_;
+};
+
+template <typename T>
+class Proxy<Scalar_access_traits<T> >
+{
+public:
+  typedef T value_type;
+  typedef typename Simd_traits<value_type>::simd_type simd_type;
+
+  Proxy(value_type value) : value_(value) {}
+
+  simd_type load() const 
+  { return Simd_traits<value_type>::load_scalar_all(value_);}
+
+  void increment() {}
+
+private:
+  value_type value_;
+};
+
+// Proxy for unary expressions.
+template <typename T, template <typename> class O>
+class Proxy<Unary_access_traits<T, O> >
+{
+public:
+  typedef Unary_access_traits<T, O> access_traits;
+  typedef typename access_traits::value_type value_type;
+  typedef typename Simd_traits<value_type>::simd_type simd_type;
+
+  Proxy(Proxy<T> const &o) : op_(o) {}
+
+  simd_type load() const 
+  {
+    simd_type op = op_.load();
+    return Unary_operator_map<value_type, O>::apply(op);
+  }
+
+  void increment() { op_.increment();}
+
+private:
+  Proxy<T> op_;
+};
+
+// Proxy for binary expressions. The two proxy operands L and R are combined
+// using binary operator O.
+template <typename L, typename R, template <typename, typename> class O>
+class Proxy<Binary_access_traits<L, R, O> >
+{
+public:
+  typedef Binary_access_traits<L, R, O> access_traits;
+  typedef typename access_traits::value_type value_type;
+  typedef typename Simd_traits<value_type>::simd_type simd_type;
+
+  Proxy(L const &l, R const &r) : left_(l), right_(r) {}
+
+  simd_type load() const 
+  {
+    simd_type l = left_.load();
+    simd_type r = right_.load();
+    return Binary_operator_map<value_type, O>::apply(l, r);
+  }
+
+  void increment()
+  {
+    left_.increment();
+    right_.increment();
+  }
+
+private:
+  L left_;
+  R right_;
+};
+
+template <typename T>
+struct Iterator
+{
+public:
+  Iterator(Proxy<T> const &c) : cursor_(c) {}
+  bool operator== (Iterator const &i) const { return cursor_ == i.cursor_;}
+  bool operator!= (Iterator const &i) const { return !(*this==i);}
+  Proxy<T> &operator* () { return cursor_;}
+  Proxy<T> *operator-> () { return &cursor_;}
+  Iterator operator++() { cursor_.increment(); return *this;}
+  Iterator operator++(int) { Iterator i(*this); cursor_.increment(); return i;}
+
+private:
+  Proxy<T> cursor_;
+};
+
+} // namespace vsip::impl::simd
+} // namespace vsip::impl
+} // namespace vsip
+
+#endif
Index: src/vsip/impl/expr_serial_dispatch.hpp
===================================================================
--- src/vsip/impl/expr_serial_dispatch.hpp	(revision 145525)
+++ src/vsip/impl/expr_serial_dispatch.hpp	(working copy)
@@ -28,7 +28,7 @@
 #endif
 
 #ifdef VSIP_IMPL_HAVE_SIMD_GENERIC
-#  include <vsip/impl/simd/eval-generic.hpp>
+#  include <vsip/impl/simd/expr_evaluator.hpp>
 #endif
 #ifdef VSIP_IMPL_HAVE_SIMD_3DNOWEXT
 #  include <vsip/impl/simd/eval-simd-3dnowext.hpp>
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 145526)
+++ ChangeLog	(working copy)
@@ -1,3 +1,11 @@
+2006-07-26  Stefan Seefeld  <stefan@codesourcery.com>
+
+	* src/vsip/impl/simd/simd.hpp: Make load() argument const, add div().
+	* src/vsip/impl/simd/expr_iterator.hpp: New file.
+	* src/vsip/impl/simd/expr_evaluator.hpp: New file.
+	* src/vsip/impl/expr_serial_dispatch.hpp: Use new evaluator.
+	
+
 2006-07-21  Stefan Seefeld  <stefan@codesourcery.com>
 
 	* doc/GNUmakefile.inc.in: Add xml dependencies and convenience targets.
