<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [c++-pthreads]  Re: FW: RE: Re: I'm Lost
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:c%2B%2B-pthreads%40codesourcery.com?Subject=Re%3A%20%5Bc%2B%2B-pthreads%5D%20%20Re%3A%20FW%3A%20RE%3A%20Re%3A%20I%27m%20Lost&In-Reply-To=%3C440CC9B6.4010502%40hp.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000537.html">
   <LINK REL="Next"  HREF="000539.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[c++-pthreads]  Re: FW: RE: Re: I'm Lost</H1>
    <B>Dave Butenhof</B> 
    <A HREF="mailto:c%2B%2B-pthreads%40codesourcery.com?Subject=Re%3A%20%5Bc%2B%2B-pthreads%5D%20%20Re%3A%20FW%3A%20RE%3A%20Re%3A%20I%27m%20Lost&In-Reply-To=%3C440CC9B6.4010502%40hp.com%3E"
       TITLE="[c++-pthreads]  Re: FW: RE: Re: I'm Lost">david.butenhof at hp.com
       </A><BR>
    <I>Mon Mar  6 23:45:58 UTC 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000537.html">[c++-pthreads]  Re: FW: RE: Re: I'm Lost
</A></li>
        <LI>Next message: <A HREF="000539.html">[c++-pthreads]  Re: FW: RE: Re: I'm Lost
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#538">[ date ]</a>
              <a href="thread.html#538">[ thread ]</a>
              <a href="subject.html#538">[ subject ]</a>
              <a href="author.html#538">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>David Abrahams wrote:
&gt;<i> Dave Butenhof &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/c++-pthreads">david.butenhof at hp.com</A>&gt; writes:
</I>&gt;<i>   
</I>&gt;&gt;<i> Absolutely. There was a strong sub-faction in POSIX that can be
</I>&gt;&gt;<i> loosely characterized as &quot;academics&quot; who were determined to try to
</I>&gt;&gt;<i> prevent constructs that might be misused. 
</I>&gt;&gt;<i>     
</I>&gt;<i> You mean, like, computers?
</I>&gt;<i>   
</I>OK, that's the laugh for today. Yeah, well, that's certainly what you 
get if you take it too far to the extreme.
&gt;&gt;<i> It's why the realtime people didn't get pthread_abort() to force
</I>&gt;&gt;<i> termination without cleanup, why you can't suspend a thread, or
</I>&gt;&gt;<i> &quot;force unlock&quot; a mutex that might have been abandoned, and so
</I>&gt;&gt;<i> forth. 
</I>&gt;&gt;<i>     
</I>&gt;<i> Oh, too bad.
</I>&gt;<i>   
</I>Yes and no. There's a line, somewhere, between something that's 
reasonably usable by some set of people to solve real problems, even if 
it can be easily and destructively misused by others; and something that 
makes a fun toy for a few researchers but is virtually impossible to use 
correctly or safely in real code. A lot of the argument hinges on where 
to draw that line; it's almost never &quot;cut and dried&quot;.
&gt;&gt;<i> If cancellation can't be finalized, nobody can accidentally
</I>&gt;&gt;<i> finalize it; and that's great if you don't trust anyone to know when
</I>&gt;&gt;<i> it SHOULD be finalized. I started out as something of an &quot;academic&quot;
</I>&gt;&gt;<i> in this sense and evolved into a pramatist... if someone thinks they
</I>&gt;&gt;<i> need it, and they're right, don't keep them from doing it.  And if
</I>&gt;&gt;<i> they're WRONG, it's their problem, not yours. ;-) Portable Java GC
</I>&gt;&gt;<i> would have been a lot easier had POSIX included suspend/resume; and
</I>&gt;&gt;<i> does it really matter that nearly anyone else who used it would be
</I>&gt;&gt;<i> breaking their application? Well, it all depends on your point of
</I>&gt;&gt;<i> view...
</I>&gt;&gt;<i>     
</I>&gt;<i> I don't know about that suspend/resume, but I don't think legitimate
</I>&gt;<i> cases where finalization is needed are nearly so rare as you describe
</I>&gt;<i> cases where suspend/resume is needed to be.
</I>&gt;<i>   
</I>Probably. I probably also got carried away with the analogy, because the 
amount of detail was largely irrelevant in this forum.
&gt;&gt;&gt;<i> A ctor that does catch(...) without rethrow is almost always badly
</I>&gt;&gt;&gt;<i> designed at best.  There was unfortunate advice going around for many
</I>&gt;&gt;&gt;<i> years that you shouldn't throw from ctors, but that's exactly wrong:
</I>&gt;&gt;&gt;<i> ctors that throw allow the establishment of strong invariants, and
</I>&gt;&gt;&gt;<i> programming without them is much harder.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On the other hand, stopping exceptions in dtors is absolutely the
</I>&gt;&gt;&gt;<i> right thing to do.
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> Yes, I may have said that backwards. As I've said before, although I use 
</I>&gt;&gt;<i> C++, it's not a &quot;native language&quot; for me, and a lot of this is based on 
</I>&gt;&gt;<i> opinions others have strongly stated 
</I>&gt;&gt;<i>     
</I>&gt;<i> It wouldn't surprise me a bit if others had strongly stated ctors
</I>&gt;<i> shouldn't throw. It used to be the advice in Stroustrup's books.
</I>&gt;<i>   
</I>And often I think it makes sense to construct a viable object even in 
the face of errors, and restrict the behavior of the object later.
&gt;&gt;<i> rather than my own knowledge or experience. Another reason,
</I>&gt;&gt;<i> incidentally, for not trying to come down too hard on one side or
</I>&gt;&gt;<i> the other where language concerns might trump &quot;threading&quot; concerns.
</I>&gt;&gt;<i>     
</I>&gt;&gt;&gt;&gt;<i> and they have some legitimate concerns about common C++ language
</I>&gt;&gt;&gt;&gt;<i> patterns that might pretty much prevent a cancel from ever doing
</I>&gt;&gt;&gt;&gt;<i> what a cancel should do.
</I>&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;&gt;<i> Really, legitimate concerns? I can't think of any recommended
</I>&gt;&gt;&gt;<i> patterns that would act that way.
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> Hmm. OK. That's interesting. Well, you're the C++ expert here. ;-)
</I>&gt;&gt;<i>     
</I>&gt;<i> None other than, &quot;prevent exceptions from leaking across language
</I>&gt;<i> boundaries.&quot;  But if you don't do that, your program is broken anyway.
</I>&gt;<i>   
</I>Well, non-exception-savvy languages, sure. But (OK, perhaps a VMS bias 
here) I think all languages on a platform should have a common exception 
model that interoperates cleanly when stack frames are interleaved. 
Certainly if you're interleaved for Java, or Ada, you should be able to 
have an exception propagate through and unwind, run destructors (or Ada 
finally clauses), etc., with no problems. And where ISO C is extended 
for exception semantics (e.g., VMS, Tru64, Windows...), C can join the club.

Sigh. The best thing about the abandoned effort to build an Itanium ABI 
for the Single UNIX Specification was that we'd succeeded in extracting 
the specification of a C++ exception runtime as the beginning of a 
standard cross platform and cross language common exception runtime.
&gt;&gt;&gt;<i> You don't find the idea that exception-safe code implies cancel-safe
</I>&gt;&gt;&gt;<i> code technically compelling?  I don't think that's an emotional issue.
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> Well, yes, I do, 
</I>&gt;&gt;<i>     
</I>&gt;<i> find it technically compelling, or think it's an emotional issue
</I>&gt;<i>   
</I>What I meant was the former. However the fact that I, or you, find it 
technically compelling doesn't make it right, and certainly doesn't mean 
everyone will agree. And historically the disagreement has indeed been 
emotional. So, both are accurate.
&gt;&gt;<i> because cancel was always intended to be &quot;just&quot; an exception that
</I>&gt;&gt;<i> happened to be thrown from another thread. But then, nothing is ever
</I>&gt;&gt;<i> that simple; the asynchronous nature required controls like
</I>&gt;&gt;<i> cancelability type and state. 
</I>&gt;&gt;<i>     
</I>&gt;<i> &quot;Asynchronous nature?&quot;
</I>&gt;<i>
</I>&gt;<i> I haven't even been considering asynchronous cancellation as it's
</I>&gt;<i> completely untenable to write anything but the most restricted code
</I>&gt;<i> that could work in the face of async cancellation.
</I>&gt;<i>   
</I>Ah, but cancellation is basically asynchronous with respect to the 
receiving thread. Even though we deliver the exception only at defined 
synchronous points, the cancellation request can arrive at any instant. 
This is mostly relevant when you talk about blocking behavior -- that a 
blocking operation can be interrupted anywhere in the middle IS 
asynchronous.

&quot;Deferred&quot; cancelability converts that asynchronous interrupt into a 
synchronous exception, though the definition of the blocking operation 
as a cancellation point. So the cancelled thread doesn't necessarily see 
the exception as &quot;asynchronous&quot; (it called a function, and got back an 
exception); but that doesn't change the fact that it really was 
asynchronous all the same.

But I don't mean it in anything like the sense of &quot;asynchronous 
cancelability mode&quot;, where the exception can be raised (cancel 
delivered) at any arbitrary point. Asynchronous cancelability was 
invented for use in tight compute-bound loops, and intended to be 
unusable anywhere else. It's one of the things we thought reasonable at 
the time but that I've since become convinced should have been on the 
other side of the &quot;too unsafe and rarely useful to be standardized&quot; line.
&gt;&gt;<i> C++ exceptions are synchronous and non-interrupting. (The latter a
</I>&gt;&gt;<i> consequence of the former, really.)  One of the main advantages of
</I>&gt;&gt;<i> cancellation is that it can break through an extended blocking
</I>&gt;&gt;<i> operation; 
</I>&gt;&gt;<i>     
</I>&gt;<i> If you make all blocking operations cancellation points you can do
</I>&gt;<i> that anyway.  No?
</I>&gt;<i>   
</I>That's the intent...
&gt;&gt;<i> but that's unavoidably an extra condition over &quot;exception-safety&quot;.
</I>&gt;&gt;<i> Cancel-safe has to mean something more unless we drop
</I>&gt;&gt;<i> interruptibility. If we drop it, then cancel-safety is just
</I>&gt;&gt;<i> exception-safety but loses much of its value in controlling
</I>&gt;&gt;<i> application responsiveness.
</I>&gt;&gt;<i>     
</I>&gt;<i> You lost me.  I think async cancel safety should be thought of as a
</I>&gt;<i> separate level of design.
</I>&gt;<i>   
</I>Um, OK; I'm not sure where I lost you. I'm not talking about 
asynchronous cancelability. I personally don't think C++ should even 
briefly entertain the notion of any support for that.

However, when cancellation is enabled, any blocking call (or any 
method/operator that makes or might make a blocking call, like &quot;cout&lt;&lt;&quot;, 
might raise an exception. Not all code will be prepared to handle that, 
and much shouldn't be; it's important to be able to disable 
cancelability dynamically over critical scopes. It's not like most 
exceptions where the conditions for an exception are generally static; 
it could happen at any time for reasons the current thread cannot 
possibly anticipate. It's asynchronous simply because it's external and 
independent. Also, where a normal exception means &quot;something's wrong and 
I can't continue on this code path&quot;, cancellation means sometime subtly 
different -- &quot;I've been asked not to&quot; rather than &quot;I can't&quot;; but if you 
must, you may. ;-)

Therefore we have cancelability state to managed scoped local control 
over when the thread can respond to cancellation requests. (An obvious 
candidate, in C++, for guard objects.)
&gt;&gt;<i> In any case, though, I wasn't suggesting that you need to convince
</I>&gt;&gt;<i> me.  I'm saying there are diverse and strongly held positions that
</I>&gt;&gt;<i> somehow need to be unified in order to get consensus on any
</I>&gt;&gt;<i> proposal. I think that I'm the least of your worries. ;-)
</I>&gt;&gt;<i>     
</I>&gt;<i> Not that you have any obligation to do so, but it might be easier if
</I>&gt;<i> you would recognize the weight your opinion carries.  That might mean
</I>&gt;<i> learning enough about C++ to form a definite opinion.  That's, at
</I>&gt;<i> least, what I've tried to do with threading.
</I>&gt;<i>   
</I>I'm not ignorant of C++, and I'm much less ignorant than I was 2 years 
ago when I started working with C++ and STL on a regular basis. Still, I 
am not steeped in the history and tradition of C++ as I am in threads, 
and probably never will be. More than that, while I have an 
authoritative voice on the POSIX working group and in the community, I'm 
not involved with the C++ committee and have no time or management 
support to get involved; and I won't put myself in the position of being 
an outside expert in some other area pretending to tell the C++ 
committee what it must (or even should) do. I will happily say that as a 
thread expert and C++ dabbler, this is what seems to make sense to me; 
but I reject any aura of authority in the C++ side of semantics and syntax.

However my statement above wasn't in any way related to my tradition of 
C++ deference. I was merely stating that I've seen many opinions (other 
than mine) that will need to be resolved or accommodated to make a standard.
&gt;&gt;&gt;&gt;<i> Someone needs to propose and champion &quot;the great exception
</I>&gt;&gt;&gt;&gt;<i> compromise&quot;; but if that's to be me I don't yet have the faintest
</I>&gt;&gt;&gt;&gt;<i> germ of a notion what it might be. So I sure hope it's going to be
</I>&gt;&gt;&gt;&gt;<i> someone else. ;-)
</I>&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;&gt;<i> If &quot;finalized cancellation exceptions result in a new throw at the
</I>&gt;&gt;&gt;<i> next cancellation point&quot; isn't enough of a compromise, it isn't going
</I>&gt;&gt;&gt;<i> to be me either, because I'm out of new ideas.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Okay, how about this one: we count the number of times the
</I>&gt;&gt;&gt;<i> cancellation is discarded.  The cancelling thread can specify the
</I>&gt;&gt;&gt;<i> number of discards to tolerate, where the default is infinite.  After
</I>&gt;&gt;&gt;<i> that, at the next cancellation point all pthread cancellation handlers
</I>&gt;&gt;&gt;<i> (but not dtors or catch blocks) are run and the thread is terminated.
</I>&gt;&gt;&gt;<i> Heck, at that point I don't care what happens; you're gambling anyway.
</I>&gt;&gt;&gt;<i> Run all the dtors and catch blocks for all I care.
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> I do NOT favor any model where &quot;dtor/catch&quot; and &quot;cancellation handler&quot; 
</I>&gt;&gt;<i> don't mean the same thing.
</I>&gt;&gt;<i>     
</I>&gt;<i> Like I said, I don't care at that point.  A forced cancellation is a
</I>&gt;<i> big gamble.  If &quot;you&quot; want to roll the dice, it's your funeral.
</I>&gt;<i>   
</I>&gt;&gt;<i> I don't think the count is tenable either because although it always 
</I>&gt;&gt;<i> feels tempting to add a control dial, it doesn't solve any actual 
</I>&gt;&gt;<i> problem if there's nobody who can know to what value the dial should be 
</I>&gt;&gt;<i> set. 
</I>&gt;&gt;<i>     
</I>&gt;<i> Which is why I backed off to the simpler model below.
</I>&gt;<i>   
</I>&gt;&gt;<i> If &quot;canceled&quot; state persists when the exception is discarded, then 
</I>&gt;&gt;<i> cancel is something different from just &quot;an exception&quot;; 
</I>&gt;&gt;<i>     
</I>&gt;<i> It already was something different.  The state needed to be stored
</I>&gt;<i> somewhere until the next cancellation point.  This just says that the
</I>&gt;<i> state persists until otherwise specified.
</I>&gt;<i>   
</I>&gt;&gt;<i> which is too bad, but perhaps inevitable. You can't just catch it
</I>&gt;&gt;<i> and continue -- you need to somehow also reset that state to recover
</I>&gt;&gt;<i> your workgroup thread that's serially running RPC requests (or
</I>&gt;&gt;<i> Python code, whatever). 
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> We could do something awful, like have catch-cancellation-by-value
</I>&gt;<i> cause the state to be reset, while catch(...) and
</I>&gt;<i> catch-cancellation-by-reference don't.  That would preserve the
</I>&gt;<i> convenience, at least.
</I>&gt;<i>   
</I>Um, yeah; I suppose it would. But I agree more strongly about the 
&quot;awful&quot;. ;-)
&gt;&gt;<i> A lot of people have suggested various ways of making cancel-pending
</I>&gt;&gt;<i> persist after the exception is launched; that's not necessarily
</I>&gt;&gt;<i> &quot;wrong&quot;, but it isn't &quot;simple&quot; either 
</I>&gt;&gt;<i> and somehow it doesn't feel
</I>&gt;&gt;<i> right to me.
</I>&gt;&gt;<i>     
</I>&gt;<i> It's simpler, by most measures I can think of, than resetting the
</I>&gt;<i> state upon throwing.
</I>&gt;<i>   
</I>&gt;&gt;&gt;<i> A simpler approach might be to have two kinds of exception: &quot;forced&quot;
</I>&gt;&gt;&gt;<i> and finalizable.  At least then we can say that exception-safe code
</I>&gt;&gt;&gt;<i> implies finalizable cancellation safety.  Then &quot;forced&quot; synchronous
</I>&gt;&gt;&gt;<i> cancellation can do whatever people desire.  I personally think it
</I>&gt;&gt;&gt;<i> will become a useless appendage sort of like C++ exception
</I>&gt;&gt;&gt;<i> specifications, but at least evolution will take care of it.  And if
</I>&gt;&gt;&gt;<i> I'm wrong, evolution will wilt my finalizable cancellations.
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> Is this the &quot;unwind&quot; vs &quot;exception&quot; idea? (Where &quot;unwind&quot; is like a new 
</I>&gt;&gt;<i> sort of 'throw' that triggers dtors but can't be caught/finalized.) Or 
</I>&gt;&gt;<i> something different...?
</I>&gt;&gt;<i>     
</I>&gt;<i> No, I wasn't suggesting anything that couldn't be caught.  I was just
</I>&gt;<i> suggesting an exception that couldn't be stopped.  It could throw
</I>&gt;<i> itself in its dtor (not that I'm advocating it, but it might satisfy
</I>&gt;<i> the &quot;other side&quot;), for example.
</I>&gt;<i>   
</I>The POSIX model where cancel propagates inexorably to thread termination 
is an inherently flawed compromise; but simply the best we could do 
within the context of ISO C and POSIX APIs. OUR implementation always 
allowed finalization, via C++ catch(...), our ISO C &quot;CATCH_ALL&quot; 
extensions, or whatever other language syntax might fit.

I really wouldn't want to propagate this restriction to C++.
&gt;<i> In fact, a general mechanism like:
</I>&gt;<i>
</I>&gt;<i>    cancel( thread_id, exception_object );
</I>&gt;<i>
</I>&gt;<i> is possible, where &quot;cancel&quot; really means throw a copy of the given
</I>&gt;<i> exception object when the specified thread reaches the next
</I>&gt;<i> cancellation point.
</I>&gt;<i>
</I>&gt;<i> We could call it 
</I>&gt;<i>
</I>&gt;<i>    throw_synchronously( thread_id, exception_object );
</I>&gt;<i>    
</I>&gt;<i> instead, if &quot;cancel&quot; really means forced execution to too many people.
</I>&gt;<i>   
</I>That's actually where we started out in CMA. Resolving down to a single 
pre-defined exception was partly a matter of simplicity, but also 
represented a basic thread model that &quot;a thread is simple; it's an 
asynchronous procedure call within the context of an application, not an 
independent application&quot;. In any case where you would need to 
distinguish between two separate interrupt conditions, the functions 
stimulated by those separate interrupts should have been assigned to 
separate threads and therefore only one exception is needed.

While this made a lot of sense at the time, we were in a very academic 
and theoretical phase, and there was not that great a body of threaded 
code in 1987 -- and none using anything closely resembling the thread 
model we were inventing and that became the principal influence for 
POSIX. SRC's Firefly/Modula-3 had &quot;alert&quot;, but it was so much simpler as 
to be a distinct variety of beast.

One advantage, though, of the single cancel exception, is that it's 
universal. When you asynchronously issue a cancel request for a thread, 
you can't really know what code is executing: your's, STL, some other 
shared library, etc. Cancel means the same to all of them, and either is 
supported with commonly agreed semantics or will be ignored (by 
disabling cancellation in critical scopes). Once you start firing off 
your own arbitrary exceptions, though, anything might happen because 
half the time the exceptions won't belong anywhere in the call tree 
that's active at the time they arrive.

Which brings us back to the &quot;academic&quot; resolution: if an exception means 
distinct things in different call trees, those call trees should be 
distinct threads and only one universal exception is necessary. ;-)
-------------- next part --------------
A non-text attachment was scrubbed...
Name: david.butenhof.vcf
Type: text/x-vcard
Size: 476 bytes
Desc: not available
URL: &lt;<A HREF="http://sourcerytools.com/pipermail/c++-pthreads/attachments/20060306/dd909ceb/attachment.vcf">http://sourcerytools.com/pipermail/c++-pthreads/attachments/20060306/dd909ceb/attachment.vcf</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000537.html">[c++-pthreads]  Re: FW: RE: Re: I'm Lost
</A></li>
	<LI>Next message: <A HREF="000539.html">[c++-pthreads]  Re: FW: RE: Re: I'm Lost
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#538">[ date ]</a>
              <a href="thread.html#538">[ thread ]</a>
              <a href="subject.html#538">[ subject ]</a>
              <a href="author.html#538">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/c++-pthreads">More information about the c++-pthreads
mailing list</a><br>
</body></html>
