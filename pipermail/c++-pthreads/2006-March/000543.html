<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [c++-pthreads]  Re: FW: RE: Re: I'm Lost
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:c%2B%2B-pthreads%40codesourcery.com?Subject=Re%3A%20%5Bc%2B%2B-pthreads%5D%20%20Re%3A%20FW%3A%20RE%3A%20Re%3A%20I%27m%20Lost&In-Reply-To=%3Cur75d3y90.fsf%40boost-consulting.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000540.html">
   <LINK REL="Next"  HREF="000541.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[c++-pthreads]  Re: FW: RE: Re: I'm Lost</H1>
    <B>David Abrahams</B> 
    <A HREF="mailto:c%2B%2B-pthreads%40codesourcery.com?Subject=Re%3A%20%5Bc%2B%2B-pthreads%5D%20%20Re%3A%20FW%3A%20RE%3A%20Re%3A%20I%27m%20Lost&In-Reply-To=%3Cur75d3y90.fsf%40boost-consulting.com%3E"
       TITLE="[c++-pthreads]  Re: FW: RE: Re: I'm Lost">dave at boost-consulting.com
       </A><BR>
    <I>Wed Mar  8 12:40:59 UTC 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000540.html">[c++-pthreads]  Re: FW: RE: Re: I'm Lost
</A></li>
        <LI>Next message: <A HREF="000541.html">[c++-pthreads]  Re: FW: RE: Re: I'm Lost
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#543">[ date ]</a>
              <a href="thread.html#543">[ thread ]</a>
              <a href="subject.html#543">[ subject ]</a>
              <a href="author.html#543">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Dave Butenhof &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/c++-pthreads">david.butenhof at hp.com</A>&gt; writes:

&gt;<i> Perhaps I'm worried about thought models and implementation while you're 
</I>&gt;<i> concerned with appearance. Both views are certainly valid within certain 
</I>&gt;<i> domains.
</I>
I don't know what you meant by &quot;appearance,&quot; but I'm concerned exactly
with thought models.  From the point of view of all the things one has
to think about to decide how cancellation exceptions will act, whether
it's possible to handle them correctly, etc., the fact that they are
ultimately initiated by asynchronous events is totally irrelevant.
They could just as easily be triggered by reading from stdin at each
cancellation point to decide whether to throw.  So I'd prefer to keep
the conversation simple.  If you'd rather be precise and talk about
asynchronous cancellation while always mentioning synchronous
exceptions as a response in the same breath, that's fine with me.  in
this context, though, it's more confusing than necessary, especially
If you don't mention synchronous exceptions in the same breath (note
that you confused me).

&gt;<i> &quot;Asynchronous cancelability type&quot; is (at least potentially) an 
</I>&gt;<i> asynchronous EXCEPTION in response to an asynchronous event, while 
</I>&gt;<i> &quot;deferred cancelability type&quot; is a synchronous (deferred) exception in 
</I>&gt;<i> response to the same asynchronous event. 
</I>
If you insist.  

&gt;<i> Does that help?
</I>
I don't think it helps in this conversation, but suit yourself; we now
understand each other.

&gt;&gt;&gt;<i> However, when cancellation is enabled, any blocking call (or any
</I>&gt;&gt;&gt;<i> method/operator that makes or might make a blocking call, like
</I>&gt;&gt;&gt;<i> &quot;cout&lt;&lt;&quot;, might raise an exception. Not all code will be prepared to
</I>&gt;&gt;&gt;<i> handle that, and much shouldn't be; it's important to be able to
</I>&gt;&gt;&gt;<i> disable cancelability dynamically over critical scopes. It's not
</I>&gt;&gt;&gt;<i> like most exceptions where the conditions for an exception are
</I>&gt;&gt;&gt;<i> generally static; it could happen at any time for reasons the
</I>&gt;&gt;&gt;<i> current thread cannot possibly anticipate.
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i> That's exactly like most exceptions (c.f. out-of-memory).  Usually
</I>&gt;&gt;<i> conditions whose reasons can be anticipated can be effectively tested
</I>&gt;&gt;<i> and become preconditions or simply should be reported by other means.
</I>&gt;&gt;<i>   
</I>&gt;<i> Sometimes. Exceptions are great for &quot;out of band&quot; notifications that may 
</I>&gt;<i> not be intended for the direct caller; they can be picked up with full 
</I>&gt;<i> state, and without additional mechanism, by anyone along the call path 
</I>&gt;<i> who cares.
</I>
I know that.  I did say &quot;most,&quot; didn't I?  

To get things back on track, your assertion was that the reasons for
most exceptions can be anticipated.  I'm not _precisely_ sure what you
meant by &quot;reasons ... anticipated,&quot; but I think I have a pretty good
idea, and my assertion was that most exceptions are in fact just like
that, making this particular aspect of asynchrony uninteresting as a
distinction.

&gt;&gt;&gt;<i> and I'm much less ignorant than I was 2 years ago when I started
</I>&gt;&gt;&gt;<i> working with C++ and STL on a regular basis. Still, I am not steeped
</I>&gt;&gt;&gt;<i> in the history and tradition of C++ as I am in threads, and probably
</I>&gt;&gt;&gt;<i> never will be. More than that, while I have an authoritative voice
</I>&gt;&gt;&gt;<i> on the POSIX working group and in the community, I'm not involved
</I>&gt;&gt;&gt;<i> with the C++ committee and have no time or management support to get
</I>&gt;&gt;&gt;<i> involved; and I won't put myself in the position of being an outside
</I>&gt;&gt;&gt;<i> expert in some other area pretending to tell the C++ committee what
</I>&gt;&gt;&gt;<i> it must (or even should) do.
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i> I don't think you should.  There are other areas where you could make
</I>&gt;&gt;<i> a big difference, though, like the ISO committee for C++/POSIX binding
</I>&gt;&gt;<i> Mr. Drepper is now running.
</I>&gt;&gt;<i>   
</I>&gt;<i> &quot;ISO committee&quot; is rather a strong description; it's a simple mailing 
</I>&gt;<i> list that's hoping to gain some preliminary consensus towards 
</I>&gt;<i> constructing a formal proposal to request permission to develop a 
</I>&gt;<i> charter and start a working group with the intent of building a proposal 
</I>&gt;<i> for a binding. 
</I>
That wasn't my impression, but maybe I misinterpreted the announcement
I saw.

  The IEEE, Portable Applications Standard Committee, has just
  approved the formation of a &quot;C++ Bindings Study Group&quot; to
  investigate providing C++ bindings to the current POSIX Standard,
  IEEE Std 1003.1.  If the group concludes that C++ bindings should be
  done, they will generate a request to IEEE PASC for project approval
  to develop a POSIX C++ bindings specification.  The group is to
  report its findings to to PASC either by March 31, 2007, or within
  12 months of it's first meeting, whichever comes first.  The group
  will be chaired by Ulrich Drepper of Red Hat (<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/c++-pthreads">drepper at redhat.com</A>).

OK, it's a study group.  Slightly more than a mailing list, but hardly
a committee.  I guess I'm just alarmist.

&gt;<i> But, yeah, OK, fine. ;-)
</I>
OK, thanks.

&gt;&gt;&gt;&gt;<i> No, I wasn't suggesting anything that couldn't be caught.  I was just
</I>&gt;&gt;&gt;&gt;<i> suggesting an exception that couldn't be stopped.  It could throw
</I>&gt;&gt;&gt;&gt;<i> itself in its dtor (not that I'm advocating it, but it might satisfy
</I>&gt;&gt;&gt;&gt;<i> the &quot;other side&quot;), for example.
</I>&gt;&gt;&gt;&gt;<i>       
</I>&gt;&gt;&gt;<i> The POSIX model where cancel propagates inexorably to thread
</I>&gt;&gt;&gt;<i> termination is an inherently flawed compromise; but simply the best
</I>&gt;&gt;&gt;<i> we could do within the context of ISO C and POSIX APIs. OUR
</I>&gt;&gt;&gt;<i> implementation always allowed finalization, via C++ catch(...), our
</I>&gt;&gt;&gt;<i> ISO C &quot;CATCH_ALL&quot; extensions, or whatever other language syntax
</I>&gt;&gt;&gt;<i> might fit.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I really wouldn't want to propagate this restriction to C++.
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i> Be clear, I'm not talking about a restriction.  If you ask it to throw
</I>&gt;&gt;<i> something normal, it's finalizable in the normal way.  This is a way
</I>&gt;&gt;<i> for the _cancelling_ thread to say, &quot;I know what I'm doing; the author
</I>&gt;&gt;<i> of the thread I'm cancelling doesn't.  Force it to be killed at the
</I>&gt;&gt;<i> next cancellation point.&quot;
</I>&gt;&gt;<i>   
</I>&gt;<i> The whole concept of cancellation is exactly that the TARGET thread, not 
</I>&gt;<i> the cancelling thread, knows what it's doing and should control the 
</I>&gt;<i> cleanup and termination entirely. 
</I>
Believe me, I agree.  You said we had to look for compromises, so
that's what I was doing.

&gt;<i> Without explicit synchronization, the cancelling thread can't know
</I>&gt;<i> what it's doing and whether a forced abort is appropriate or
</I>&gt;<i> safe. And if it has enough synchronization to know that, there are
</I>&gt;<i> far better ways to gain a cooperative termination than cancellation.
</I>
Sure.

&gt;&gt;&gt;<i> One advantage, though, of the single cancel exception, is that it's
</I>&gt;&gt;&gt;<i> universal. When you asynchronously issue a cancel request for a
</I>&gt;&gt;&gt;<i> thread, you can't really know what code is executing: your's, STL,
</I>&gt;&gt;&gt;<i> some other shared library, etc. Cancel means the same to all of
</I>&gt;&gt;&gt;<i> them, and either is supported with commonly agreed semantics or
</I>&gt;&gt;&gt;<i> will be ignored (by disabling cancellation in critical
</I>&gt;&gt;&gt;<i> scopes). Once you start firing off your own arbitrary exceptions,
</I>&gt;&gt;&gt;<i> though, anything might happen because half the time the exceptions
</I>&gt;&gt;&gt;<i> won't belong anywhere in the call tree that's active at the time
</I>&gt;&gt;&gt;<i> they arrive.
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i> That's not the way most exception-safe code works.  It goes to the
</I>&gt;&gt;<i> reason that exception-specifications are a failure: the particular
</I>&gt;&gt;<i> type of exception that propagates out of a throwing function makes
</I>&gt;&gt;<i> almost no difference to anyone.  The type only becomes important where
</I>&gt;&gt;<i> errors are reported, or where exceptions are translated -- either to
</I>&gt;&gt;<i> other exception types or, for example, to error return codes that can
</I>&gt;&gt;<i> propagate through other languages.  So the danger of injecting an
</I>&gt;&gt;<i> arbitrary exception type into existing code (especially libraries,
</I>&gt;&gt;<i> which are very often exception-neutral) is very very low.
</I>&gt;&gt;<i>   
</I>&gt;<i> That's an intriguing statement. I'll need to think about that some.
</I>&gt;<i>
</I>&gt;<i> I've certainly always thought that exception specifications were little 
</I>&gt;<i> more than a trap into which people could mire themselves as deeply as 
</I>&gt;<i> they like. So maybe that means I agree. I'm not sure. ;-)
</I>&gt;<i>
</I>&gt;<i> I guess I'd have to agree that the danger of injecting another exception 
</I>&gt;<i> type is low. And mostly due to the fact that C++ has no &quot;root exception 
</I>&gt;<i> type&quot; onto which could be grafted some minimal universal state 
</I>
It has a de-facto root type: std::exception.

&gt;<i> (an architected status code space, like VMS condition codes, a
</I>&gt;<i> descriptive string, etc.) so that nobody would need an anonymous and
</I>&gt;<i> semantic-free catch(...) just to be sure nothing slipped past.
</I>
When you have a root type, catching that is practically anonymous and
semantic-free.  It doesn't make much difference in practice.

&gt;&gt;&gt;<i> Which brings us back to the &quot;academic&quot; resolution: if an exception
</I>&gt;&gt;&gt;<i> means distinct things in different call trees, those call trees
</I>&gt;&gt;&gt;<i> should be distinct threads and only one universal exception is
</I>&gt;&gt;&gt;<i> necessary. ;-)
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i> I think you might be missing the point.  I am proposing the
</I>&gt;&gt;<i> generalized 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   thread_throw( thread_id, exception_object )
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> function so that those who wish to hang themselves with homegrown
</I>&gt;&gt;<i> unstoppable exception types can do so without forcing the standard to
</I>&gt;&gt;<i> sanction the use of unstoppable exceptions by providing any kind of
</I>&gt;&gt;<i> &quot;forced cancellation.&quot;  If &quot;the other side&quot; has A WAY to force
</I>&gt;&gt;<i> cancellation, maybe they won't insist it has to be THE WAY.  I know,
</I>&gt;&gt;<i> wishful thinking :)
</I>&gt;&gt;<i>   
</I>&gt;<i> I'm not sure how sanctioning generalized unstoppable exceptions 
</I>
I said I'm not sanctioning such a thing.  You can build one today in
standard C++ (it throws a copy of itself from its destructor), so
there's no need.  And of course we can't stop people from building
them.

&gt;<i> is going to mollify anyone opposed to an unstoppable variety of a
</I>&gt;<i> specific exception.
</I>
Huh?  Did you really mean &quot;UNstoppable?&quot;  IIUC, you and I are both
opposed to unstoppable thread cancellation.  Are you saying you would
need to be mollified in order to accept it, even if it's only
available by hand-writing a very strange exception type?

&gt;<i> At best, cancel becomes a subset of cross-thread throw with 
</I>&gt;<i> specialized additional deferral semantics. 
</I>
Additional?  I'm lost again.  There is no workable cross-thread throw
without deferral.  Anything else is an asynchronous exception.

&gt;<i> And if you're generalizing the unstoppable exception, 
</I>
Generalizing?

&gt;<i> I don't quite see how it makes sense not to generalize the deferral,
</I>&gt;<i> and now cancel really is just a specific predefined exception that
</I>&gt;<i> can be thrown like any other exception.  That's not necessarily bad;
</I>&gt;<i> I just don't see how it's a compromise. (A compromise needs to make
</I>&gt;<i> BOTH sides equally unhappy, not just one side!)
</I>
The compromise I'm proposing makes it possible to generate an
unstoppable cancellation (bad for us) while making it ugly and
unnatural to do so (bad for &quot;the other side&quot;).

-- 
Dave Abrahams
Boost Consulting
www.boost-consulting.com

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000540.html">[c++-pthreads]  Re: FW: RE: Re: I'm Lost
</A></li>
	<LI>Next message: <A HREF="000541.html">[c++-pthreads]  Re: FW: RE: Re: I'm Lost
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#543">[ date ]</a>
              <a href="thread.html#543">[ thread ]</a>
              <a href="subject.html#543">[ subject ]</a>
              <a href="author.html#543">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/c++-pthreads">More information about the c++-pthreads
mailing list</a><br>
</body></html>
