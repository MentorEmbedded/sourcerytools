<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Pooma Manual: Array and Domain Chapter
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Pooma%20Manual%3A%20Array%20and%20Domain%20Chapter&In-Reply-To=%3C20020115095319.A8680%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000883.html">
   <LINK REL="Next"  HREF="000886.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Pooma Manual: Array and Domain Chapter</H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Pooma%20Manual%3A%20Array%20and%20Domain%20Chapter&In-Reply-To=%3C20020115095319.A8680%40codesourcery.com%3E"
       TITLE="Pooma Manual: Array and Domain Chapter">oldham at codesourcery.com
       </A><BR>
    <I>Tue Jan 15 17:53:19 UTC 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="000883.html">Patch: Remove Non-Existent 'Index' From Comments
</A></li>
        <LI>Next message: <A HREF="000886.html">Manual Patch: DynamicArrays and Part of Engines
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#885">[ date ]</a>
              <a href="thread.html#885">[ thread ]</a>
              <a href="subject.html#885">[ subject ]</a>
              <a href="author.html#885">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch finishes the first draft of the Array and Domain chapter of
the Pooma manual.

2002-Jan-15  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

	* arrays.xml: New file containing the Array and Domain chapter.
	* concepts.xml: Add glossary links to &quot;index&quot; entry.
	* manual.xml: Replace &quot;bookCap&quot; entity with &quot;bookcap&quot;.  Add &quot;dim&quot;,
	&quot;domaintemplate&quot;, and &quot;float&quot; entities.  Move Array (and Domain)
	chapter to new file 'arrays.xml'.

Applied to	mainline
Approved by	me!

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: arrays.xml
===================================================================
RCS file: arrays.xml
diff -N arrays.xml
*** /dev/null	Fri Mar 23 21:37:44 2001
--- arrays.xml	Tue Jan 15 17:48:34 2002
***************
*** 0 ****
--- 1,1738 ----
+   &lt;chapter id=&quot;arrays&quot;&gt;
+    &lt;title&gt;&array; Containers&lt;/title&gt;
+ 
+    &lt;para&gt;A container is a class holding objects.  &array;s are one of
+    the two most widely used &pooma; containers since they model the
+    mathematical concept of mapping indices from domains to values.
+    &pooma; &array;s extend built-in &cc; arrays by supporting a wider
+    variety of domains, automatically handling memory allocations, and
+    supporting first-class status.  For example, they may be used as
+    operands and in assignments.  In this chapter, we introduce the
+    concept of containers, the mathematical concept of arrays, and the
+    &pooma; concept for &array;s.  Before illustrating how to declare
+    &array;s, we introduce &domain;s, which specify the sets of
+    indices.  After describing how to declare the various types of
+    &domain;s, we describe how to declare and use &array;s.  This is
+    illustrated in a &amp;doof2d; implementation using &array;s.  We end
+    with a description of their implementation.&lt;/para&gt;
+ 
+ 
+    &lt;section id=&quot;arrays-containers&quot;&gt;
+     &lt;title&gt;Containers&lt;/title&gt;
+ 
+     &lt;para&gt;A &lt;glossterm
+     linkend=&quot;glossary-container&quot;&gt;&lt;firstterm&gt;container class
+     expression&lt;/firstterm&gt;&lt;/glossterm&gt; is a class with the main
+     purpose of holding objects.  These stored objects, called
+     &lt;glossterm linkend=&quot;glossary-container_value&quot;&gt;&lt;firstterm&gt;container
+     values&lt;/firstterm&gt;&lt;/glossterm&gt; or more simply
+     &lt;quote&gt;values&lt;/quote&gt; or elements&lt;quote&gt;&lt;/quote&gt;, may be accessed
+     and changed, usually using indices.  &lt;quote&gt;Container
+     class&lt;/quote&gt; is usually abbreviated
+     &lt;quote&gt;container&lt;/quote&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;The six &pooma; containers can be categorized into two
+     groups.  Mathematical containers include &tensor;s, &matrix;s, and
+     &vector;s, modeling tensors, matrices, and vectors, respectively.
+     Storage containers include &array;s, &dynamicarray;s, and
+     &field;s.  In this chapter, we focus on simplest of these:
+     &array;s.  The other containers will be described in subsequent
+     chapters.&lt;/para&gt;
+ 
+     &lt;para&gt;&c;&nbsp;has built-in arrays, and the &cc; Standard Library
+     provides &lt;type&gt;map&lt;/type&gt;s, &lt;type&gt;vector&lt;/type&gt;s,
+     &lt;type&gt;stack&lt;/type&gt;s, and other containers, but the &pooma;
+     containers better model scientific computing concepts and provide
+     more functionality.  They automatically handle memory allocation
+     and deallocation and can be used in expressions and on the
+     left-hand side of assignments.  Since &pooma; containers separate
+     the container concepts of accessing and using values from storing
+     values, value storage can be optimized to specific needs.  For
+     example, if most of an &array;'s values are known to be the same
+     most of the time, a compressible engine can be used.  Whenever all
+     the array's values are the same, it stores only one value.  At
+     other times, it stores all the values.  Engines will be discussed
+     in &lt;xref linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;arrays-arrays&quot;&gt;
+     &lt;title&gt;&array;s&lt;/title&gt;
+ 
+     &lt;para&gt;Mathematically, an array maps indices from a domain to
+     values.  Usually, the domain consists of a one-dimensional
+     integral interval or it may be multidimensional.  &pooma;'s
+     &array; container class implements this idea.  Given an index,
+     i.e., a position in an &array;'s &domain;, it returns the associated
+     value, either by returning a stored value or by computing it.  The
+     use of indices, which are usually integral tuples but need not be
+     zero-based or even consist of all possible integral tuples in a
+     multidimensional range.  Using indices permits constant-time
+     access to values although computing a particular value may require
+     significant time.&lt;/para&gt;
+ 
+     &lt;para&gt;&pooma; &array;s are &lt;glossterm
+     linkend=&quot;glossary-first_class&quot;&gt;first-class
+     types&lt;firstterm&gt;&lt;/firstterm&gt;&lt;/glossterm&gt; so they can be used more
+     widely than built-in &cc; arrays.  For example, &array;s can be
+     used as operands and in assignment statements.  The statement
+     &lt;statement&gt;a = a + b;&lt;/statement&gt; adds corresponding elements of
+     &array;s &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt;, assigning
+     the sums to the &array; &lt;varname&gt;a&lt;/varname&gt;.  The statement
+     treats each array as one object, rather than requiring the use of
+     one or more loops to access individual values.  Data-parallel
+     statements are further discussed in &lt;xref
+     linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt;.  &array;s also handle their own
+     memory allocation and deallocation.  For example, the &array;
+     declaration &lt;statement&gt;Array&lt;2, double, Brick&gt;
+     a(vertDomain)&lt;/statement&gt; creates an
+     &array;&nbsp;&lt;varname&gt;a&lt;/varname&gt;, allocating whatever memory it
+     needs.  When &lt;varname&gt;a&lt;/varname&gt; goes out of scope, it and its
+     memory is automatically deallocated.  Automatic memory allocation
+     and deallocation also eases copying.  As we mentioned above, an
+     &array;'s &engine; stores or computes its values so it, not the
+     &array; itself, is responsible for memory allocation and
+     deallocation.  Fortunately, this distinction is usually hidden
+     from the &pooma; user.&lt;/para&gt;
+ 
+     &lt;para&gt;Individual &array; values can be accessed using parentheses,
+     not square brackets, as for &cc; arrays.  For example,
+     &lt;statement&gt;a(3,4)&lt;/statement&gt; yields the value at position (3,4)
+     of &lt;varname&gt;a&lt;/varname&gt;'s two-dimensional domain.&lt;/para&gt;
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;arrays-domains&quot;&gt;
+     &lt;title&gt;&domain;s&lt;/title&gt;
+ 
+     &lt;para&gt;A &lt;glossterm
+     linkend=&quot;glossary-domain&quot;&gt;&lt;firstterm&gt;domain&lt;/firstterm&gt;&lt;/glossterm&gt;
+     specifies the set of points on which an &array; can define values.
+     These indices are the arguments placed within parentheses when
+     selecting particular values, as described previously.  A domain
+     supported both by &array;s and by built-in &cc; arrays is an
+     interval [0,n-1] of integers containing all integers {0, 1, 2,
+     &hellip;, n-1}.  For &cc;, every integer in the interval must be
+     included, and the minimum index must be zero.  &pooma; expands the
+     set of permissible domains to support intervals with nonzero
+     minimal indices and strides and by adding other choices.&lt;/para&gt;
+ 
+     &lt;para&gt;In &pooma;, &domain;s implement domains.  There are four
+     different categories:
+      &lt;variablelist&gt;
+       &lt;varlistentry&gt;
+        &lt;term&gt;&loc;&lt;/term&gt;
+        &lt;listitem&gt;
+ 	&lt;para&gt;&domain; with a single point.&lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/varlistentry&gt;
+       &lt;varlistentry&gt;
+        &lt;term&gt;&interval;&lt;/term&gt;
+        &lt;listitem&gt;
+ 	&lt;para&gt;&domain; with an integral interval [a,b].&lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/varlistentry&gt;
+       &lt;varlistentry&gt;
+        &lt;term&gt;&range;&lt;/term&gt;
+        &lt;listitem&gt;
+ 	&lt;para&gt;&domain; with an integral interval [a,b] and an integral
+ 	stride&nbsp;s indicating the gap between indices: {a, a+s,
+ 	a+2s, &hellip;, b}.&lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/varlistentry&gt;
+       &lt;varlistentry&gt;
+        &lt;term&gt;&grid;&lt;/term&gt;
+        &lt;listitem&gt;
+ 	&lt;para&gt;&domain; with an ascending or descending sequence of
+ 	integral values.  The sequence elements must be individually
+ 	specified.&lt;/para&gt;
+        &lt;/listitem&gt;
+       &lt;/varlistentry&gt;
+      &lt;/variablelist&gt;
+     One-dimensional and multidimensional versions of each categories
+     are supported.  A multidimensional &domain; consists of the direct
+     product of one-dimensional &domain;s.  For example, the first
+     dimension of a two-dimensional interval [0,3]x[2,9] is the
+     interval&nbsp;[0,3], and its second dimension is the
+     interval&nbsp;[2,9].  Its indices are ordered pairs such as (0,2),
+     (0,3), (1,2), (1,9), and&nbsp;(3,7).&lt;/para&gt;
+ 
+     &lt;para&gt;Many domains can be represented using domain triplets.  A
+     &lt;glossterm linkend=&quot;glossary-domain_triplet&quot;&gt;&lt;firstterm&gt;domain
+     triplet&lt;/firstterm&gt;&lt;/glossterm&gt;
+     [&lt;varname&gt;begin&lt;/varname&gt;:&lt;varname&gt;end&lt;/varname&gt;:&lt;varname&gt;stride&lt;/varname&gt;]
+     represents the mathematical set {begin, begin + stride, begin +
+     2stride, &hellip;, end}, where &lt;varname&gt;end&lt;/varname&gt; is in the
+     set only if it equals &lt;varname&gt;begin&lt;/varname&gt; plus some integral
+     multiple of &lt;varname&gt;stride&lt;/varname&gt;.  If the
+     &lt;varname&gt;stride&lt;/varname&gt; is negative, its beginning index
+     &lt;varname&gt;begin&lt;/varname&gt; should at least be as large as
+     &lt;varname&gt;end&lt;/varname&gt; if the interval is to be nonempty.  The
+     stride can be zero only if &lt;varname&gt;begin&lt;/varname&gt; and
+     &lt;varname&gt;end&lt;/varname&gt; are equal.  There are lots of ways to
+     represent an empty interval, e.g., [1:0:1] and [23,34,-1], and
+     &pooma; will accept them, but they are all equivalent.  The domain
+     triplet notation is easily extended to multiple dimensions by
+     separating different dimension's intervals with commas.  For
+     example, [2:4:2,6:4:-2] contains (2,6), (2,4), (4,6),
+     and&nbsp;(4,4).&lt;/para&gt;
+ 
+     &lt;para&gt;All the &domain; categories listed above except &grid; can be
+     represented using domain triplet notation.  Since the triplet
+     [7:7:1] represents {7}, or more simply&nbsp;7, it can also
+     represent &lt;statement&gt;Loc&lt;1&gt;(7)&lt;/statement&gt;.  Multidimensional
+     &loc;s are similarly represented.  For example,
+     [0:0:1,10:10:1,2:2:1] represents
+     &lt;statement&gt;Loc&lt;3&gt;(0,10,2)&lt;/statement&gt;, but it is frequently
+     abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
+     [a:b:1], while a &range; has specific stride&nbsp;s:
+     [a:b:s].&lt;/para&gt;
+ 
+     &lt;para&gt;&domain;s can be constructed by combining &domain;s of smaller
+     dimension.  For example, since a two-dimensional &interval; is the
+     direct product of two one-dimensional &interval;s, it can be
+     specified using two one-dimensional &interval;s.  For example,
+     &lt;statement&gt;Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
+     Interval&lt;1&gt;(4,5))&lt;/statement&gt; creates a [2:3:1,4:5:1]
+     &domain;.  The resulting dimensionality equals the sum of the
+     components' dimensions.  For example, a four-dimension &loc; can
+     be specified using three- and one-dimension &loc;s or using four
+     one-dimension &loc;s.  If fewer dimensions than the created
+     object's dimensionality, the last dimensions are unspecified and
+     uninitialized.  &loc;s, &interval;s, &range;s, and &grid;s can all
+     be composed from smaller similar components.&lt;/para&gt;
+ 
+     &lt;para&gt;A &domain; can be composed from smaller components with
+     different types.  A &loc; object can be constructed from other
+     &loc; objects and integers.  &interval;s, &range;s, and &grid;s
+     can be constructed using any of these types, &loc;s, and integers.
+     For example, &lt;statement&gt;Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2),
+     Interval&lt;1&gt;(3,5))&lt;/statement&gt; uses a two-dimensional &loc;
+     and a one-dimensional &interval; to create a [1:1:1,2:2:1,3:5:1]
+     &domain;.  During creation of a &domain;, the type of each object
+     is changed to the &domain;'s type.  In the example,
+     &lt;statement&gt;Loc&lt;2&gt;(1,2)&lt;/statement&gt; is first converted to an
+     &interval;.&lt;/para&gt;
+ 
+     &lt;para&gt;&domain;s can participate in some arithmetic and comparison
+     operations.  For example, a &domain;'s triplet can be shifted two
+     units to the right by adding two.  Multiplying a &domain; by two
+     multiplies its triplet's beginnings, endings, and strides by two.
+     &pooma; users rarely need to compare &domain;s, but we describe
+     operating with the less-than operator on &interval;s.  &interval;
+     &lt;varname&gt;d1&lt;/varname&gt; &lt; &interval; &lt;varname&gt;d2&lt;/varname&gt; if the
+     length of &lt;varname&gt;d1's&lt;/varname&gt; interval is less than
+     &lt;varname&gt;d2&lt;/varname&gt;'s or, if equal, its beginning value is
+     smaller.  &domain; arithmetic is frequently used with data-parallel
+     statements and container views.  These will be discussed in &lt;xref
+     linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt; and &lt;xref
+     linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;The current &pooma; implementation supports &domain;s with
+     dimensionality between one and seven, inclusive.  Since most
+     scientific computations use one, two, or three dimensions, this is
+     usually sufficient.  If more dimensions are needed, they can be
+     added to the source code.&lt;/para&gt;
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;arrays-domains_declarations&quot;&gt;
+     &lt;title&gt;Declaring &domain;s&lt;/title&gt;
+ 
+     &lt;para&gt;Since &domain;s are mainly used to declare container
+     domains, we focus on declaring &domain;s.  Arithmetic operations
+     with &domain;s are described in &lt;xref
+     linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;All &domain; declarations require a dimension template
+     parameter&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  This positive integer
+     specifies the number of dimensions, i.e., rank, of the &domain; and
+     determines the length of the tuples for points in the &domain;.  For
+     example, a three-dimensional &domain; contains ordered triples,
+     while a one-dimensional &domain; contains singletons, or just
+     integers.  Multidimensional &domain;s are just the direct products
+     of one-dimensional &domain;s so the techniques for declaring
+     one-dimensional &domain;s carry over to multi-dimensional
+     ones.&lt;/para&gt;
+ 
+     &lt;para&gt;To declare a &domain;, one must include the
+     &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; header
+     file.  However, most &pooma; programs declare &domain;s to use them
+     when constructing containers.  The container header files
+     automatically include &lt;filename
+     class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; so no explicit
+     inclusion is usually necessary.&lt;/para&gt;
+ 
+     &lt;section id=&quot;arrays-domains_declarations-loc&quot;&gt;
+      &lt;title&gt;&loc;s&lt;/title&gt;
+ 
+      &lt;para&gt;A &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt; is a &domain; with just a single
+      &lt;varname&gt;&dim;&lt;/varname&gt;-dimensional point.  Although it is
+      infrequently used as a container's domain, it is used to refer to
+      a single point within another domain.  Its beginning and ending
+      points are the same, and its stride is one.  One-dimensional
+      &loc;s and integers are frequently interchanged.&lt;/para&gt;
+ 
+      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-loc-one_d_table&quot;&gt;
+       &lt;title&gt;Declaring One-Dimensional &loc;s&lt;/title&gt;
+      
+       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+        &lt;thead&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;constructor&lt;/entry&gt;
+ 	 &lt;entry&gt;result&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/thead&gt;
+        &lt;tfoot&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
+ 	 &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
+ 	 &lt;entry&gt;&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tfoot&gt;
+        &lt;tbody&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;points to zero.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an uninitialized &locone;, to be assigned a value later.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &locone; with the integer converted from &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &locone; with the integer converted from
+ 	 &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
+ 	 &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &locone; with the integer converted from
+ 	 &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
+ 	 &lt;varname&gt;t1&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt; is
+ 	 ignored.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tbody&gt;
+       &lt;/tgroup&gt;
+      &lt;/table&gt;
+ 
+      &lt;para&gt;Constructors for one-dimensional &loc;s appear in &lt;xref
+      linkend=&quot;arrays-domains_declarations-loc-one_d_table&quot;&gt;&lt;/xref&gt;.
+      The empty constructor yields the zero point.  The constructor
+      taking a &lt;type&gt;Pooma::Init&lt;/type&gt; object does not initialize the
+      resulting &loc; to any particular value.  Presumably, the value
+      will be assigned later.  For small &domain;s such as &loc;s, the
+      time savings from not initializing is small, but the
+      functionality is still available.  The constructor taking one
+      argument with type&nbsp;&lt;type&gt;&domaintemplate;1&lt;/type&gt; converts this argument to
+      an integer to specify the point.  The template
+      type&nbsp;&lt;type&gt;&domaintemplate;1&lt;/type&gt; may be any type that can be converted
+      to an integer, e.g., &bool;, &char;, &int;, or &double;.  The
+      constructors taking two and three arguments of templatized types
+      facilitate converting an &interval; and a &range; into a &loc;.
+      Since a &loc; represents a single point, the &interval;'s or
+      &range;'s first two arguments must be equal.  The stride is
+      ignored.  Again, the templatized types may be any type that can
+      be converted into an integer.&lt;/para&gt;
+ 
+      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-loc-multi_d_table&quot;&gt;
+       &lt;title&gt;Declaring Multidimensional &loc;s&lt;/title&gt;
+      
+       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+        &lt;thead&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;constructor&lt;/entry&gt;
+ 	 &lt;entry&gt;result&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/thead&gt;
+        &lt;tfoot&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &loc;'s dimension.
+ 	 &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are
+ 	 template parameters.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tfoot&gt;
+        &lt;tbody&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;points to zero.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an uninitialized &loc;, to be assigned a value later.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &loc; using the given &domain; object.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tbody&gt;
+       &lt;/tgroup&gt;
+      &lt;/table&gt;
+ 
+      &lt;para&gt;Constructors for multidimensional &loc;s appear in &lt;xref
+      linkend=&quot;arrays-domains_declarations-loc-multi_d_table&quot;&gt;&lt;/xref&gt;.
+      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &loc;'s dimension.  The
+      first two constructors are similar to &locone;'s first two
+      constructors, returning a representation of the zero point and
+      returning an uninitialized point.  The seven other constructors
+      create a &loc; using other &domain; objects.  These &domain; objects,
+      having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;, &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have
+      any type that can be converted into an integer, to a &locone;, or
+      to a multidimensional &domain; object that itself can be converted
+      into a &loc;.  The total dimensionality of all the arguments'
+      types should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  For example,
+      &lt;statement&gt;Loc&lt;5&gt;(Range&lt;1&gt;(2,2,2), Loc&lt;2&gt;(2,3),
+      Interval&lt;1&gt;(4,4))&lt;/statement&gt; creates a five-dimensional &loc;
+      [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
+      &loc;, and a one-dimensional &interval;.  The final fifth
+      dimension has an unspecified value, in this case&nbsp;1.  The
+      one-dimensional &range; is converted into the single integer two;
+      its beginning and ending points must be the same.  The
+      two-dimensional &loc; contributes values for the next two
+      dimensions, while the &interval; contributes its beginning point,
+      which must be the same as its ending point.  Note that the
+      &locone; constructors taking two and three parameters ignore
+      their second and third arguments, but this is not true for the
+      multidimensional constructors.&lt;/para&gt;
+     &lt;/section&gt;
+ 
+ 
+     &lt;section id=&quot;arrays-domains_declarations-intervals&quot;&gt;
+      &lt;title&gt;&interval;s&lt;/title&gt;
+ 
+      &lt;para&gt;A one-dimensional &interval; represents a set of integers
+      within a mathematical &lt;glossterm
+      linkend=&quot;glossary-interval&quot;&gt;interval&lt;/glossterm&gt;.
+      Multidimensional &interval;s represent their multidimensional
+      generalization, i.e., the direct product of one-dimensional
+      intervals.  &interval;s are arguably the most commonly used
+      &pooma; &domain;.  A one-dimensional &interval; has integral
+      beginning and ending points and a unit stride.&lt;/para&gt;
+ 
+      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-interval-one_d_table&quot;&gt;
+       &lt;title&gt;Declaring One-Dimensional &interval;s&lt;/title&gt;
+      
+       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+        &lt;thead&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;constructor&lt;/entry&gt;
+ 	 &lt;entry&gt;result&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/thead&gt;
+        &lt;tfoot&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
+ 	 &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
+ 	 &lt;entry&gt;&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tfoot&gt;
+        &lt;tbody&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an empty, uninitialized interval.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an uninitialized &intervalone;, to be assigned a value later.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &intervalone;.  See the text for an explanation.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &intervalone; with the integers converted from
+ 	 &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &intervalone; with the integers converted from
+ 	 &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.
+ 	 &lt;varname&gt;t3&lt;/varname&gt; must equal&nbsp;1.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tbody&gt;
+       &lt;/tgroup&gt;
+      &lt;/table&gt;
+ 
+      &lt;para&gt;&intervalone; constructors are patterned on &locone;
+      constructors except that &intervalone;s can have differing
+      beginning and ending points.  See &lt;xref
+      linkend=&quot;arrays-domains_declarations-interval-one_d_table&quot;&gt;&lt;/xref&gt;.
+      The default constructor creates an empty, uninitialized interval,
+      which should not be used before assigning it values.  If the
+      one-parameter constructor's argument is a &domain; object, it must
+      be a one-dimensional &domain; object which is copied into an
+      &interval; if possible; for example, it must have unit stride.
+      If the one-parameter constructor's argument is not a &domain;
+      object, it must be convertible to an
+      integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and an interval [0:e-1:1]
+      starting at zero is constructed.  If two arguments are specified,
+      they are assumed to be convertible to integers
+      &lt;varname&gt;b&lt;/varname&gt; and &lt;varname&gt;e&lt;/varname&gt;, specifying the
+      interval [b:e:1].  The three-parameter constructor is similar,
+      with the third argument specifying a stride, which must be
+      one.&lt;/para&gt;
+ 
+      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-intervals-multi_d_table&quot;&gt;
+       &lt;title&gt;Declaring Multidimensional &interval;s&lt;/title&gt;
+      
+       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+        &lt;thead&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;constructor&lt;/entry&gt;
+ 	 &lt;entry&gt;result&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/thead&gt;
+        &lt;tfoot&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &interval;'s dimension.
+ 	 &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are
+ 	 template parameters.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tfoot&gt;
+        &lt;tbody&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &interval; using the given &domain; object.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tbody&gt;
+       &lt;/tgroup&gt;
+      &lt;/table&gt;
+ 
+      &lt;para&gt;Constructors for multidimensional &interval;s closely
+      follow constructors for multidimensional &loc;s.  See &lt;xref
+      linkend=&quot;arrays-domains_declarations-intervals-multi_d_table&quot;&gt;&lt;/xref&gt;.
+      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &interval;'s
+      dimension.  The first two constructors both return empty,
+      uninitialized intervals.  The seven other constructors create an
+      &interval; using &domain; objects.  These &domain; objects,
+      having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
+      &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
+      converted into an integer, into a single-dimensional &domain;
+      object that can be converted into a single-dimensional
+      &interval;, or to a multidimensional &domain; object that itself
+      can be converted into an &interval;.  The total dimensionality of
+      all the arguments' types should be at
+      most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional &domain;
+      objects that can be converted into one-dimensional &interval;s
+      include &locone;s, &intervalone;s, and &rangeone;s with unit
+      strides.  If the sum of the objects' dimensions is less
+      than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the intervals for the final
+      dimensions are unspecified.  See the last paragraph of &lt;xref
+      linkend=&quot;arrays-domains_declarations-loc&quot;&gt;&lt;/xref&gt; for an
+      analogous example.  Note that the &intervalone; constructors
+      taking two and three parameters treat these arguments differently
+      than the multidimensional constructors do.&lt;/para&gt;
+     &lt;/section&gt;
+ 
+ 
+     &lt;section id=&quot;arrays-domains_declarations-ranges&quot;&gt;
+      &lt;title&gt;&range;s&lt;/title&gt;
+ 
+      &lt;para&gt;A one-dimensional &range; generalizes an &interval; by
+      permitting a non-unit stride between integral members.  A
+      &lt;glossterm
+      linkend=&quot;glossary-range&quot;&gt;&lt;firstterm&gt;range&lt;/firstterm&gt;&lt;/glossterm&gt;
+      is a set of integers in a mathematical interval [b,e] with a
+      stride&nbsp;s between them: {a, a+s, a+2s, &hellip;, b}.  Ranges
+      are generalized to &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;dimensions using the
+      direct product of one-dimensional ranges.&lt;/para&gt;
+ 
+      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-range-one_d_table&quot;&gt;
+       &lt;title&gt;Declaring One-Dimensional &range;s&lt;/title&gt;
+      
+       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+        &lt;thead&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;constructor&lt;/entry&gt;
+ 	 &lt;entry&gt;result&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/thead&gt;
+        &lt;tfoot&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
+ 	 &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
+ 	 &lt;entry&gt;&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tfoot&gt;
+        &lt;tbody&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an empty, uninitialized range.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an uninitialized &rangeone;, to be assigned a value later.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &rangeone;.  See the text for an explanation.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &rangeone; with an interval specified by the
+ 	 integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
+ 	 &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &rangeone; by converting the arguments to
+ 	 integers &lt;varname&gt;i1&lt;/varname&gt;, &lt;varname&gt;i2&lt;/varname&gt;, and
+ 	 &lt;varname&gt;i3&lt;/varname&gt; and then making a range [i1:i2:i3].&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tbody&gt;
+       &lt;/tgroup&gt;
+      &lt;/table&gt;
+ 
+      &lt;para&gt;&rangeone; constructors are the same as &intervalone;
+      constructors except they create ranges, not intervals.  See &lt;xref
+      linkend=&quot;arrays-domains_declarations-range-one_d_table&quot;&gt;&lt;/xref&gt;.
+      The default constructor creates an empty, uninitialized range,
+      which should not be used before assigning it values.  If the
+      one-parameter constructor's argument is a &domain; object, it must
+      be a one-dimensional &domain; object which is copied into a &range;
+      if possible.  If the one-parameter constructor's argument is not
+      a &domain; object, it must be convertible to an
+      integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and a range [0:e-1:1] starting
+      at zero is constructed.  If two arguments are specified, they are
+      assumed to be convertible to integers &lt;varname&gt;b&lt;/varname&gt; and
+      &lt;varname&gt;e&lt;/varname&gt;, specifying the range [b:e:1].  The
+      three-parameter constructor is similar, with the third argument
+      specifying a stride.&lt;/para&gt;
+ 
+      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-ranges-multi_d_table&quot;&gt;
+       &lt;title&gt;Declaring Multidimensional &range;s&lt;/title&gt;
+      
+       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+        &lt;thead&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;constructor&lt;/entry&gt;
+ 	 &lt;entry&gt;result&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/thead&gt;
+        &lt;tfoot&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &range;'s dimension.
+ 	 &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are
+ 	 template parameters.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tfoot&gt;
+        &lt;tbody&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &range; using the given &domain; object.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tbody&gt;
+       &lt;/tgroup&gt;
+      &lt;/table&gt;
+ 
+      &lt;para&gt;Constructors for multidimensional &range;s are the same as
+      multidimensional &interval; constructors except they create
+      ranges, not intervals.  See &lt;xref
+      linkend=&quot;arrays-domains_declarations-ranges-multi_d_table&quot;&gt;&lt;/xref&gt;.
+      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &range;'s dimension.  The
+      first two constructors return empty, uninitialized ranges.
+      The seven other constructors create an &range; using &domain;
+      objects.  These &domain; objects, having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;,
+      &hellip;, &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
+      converted into an integer, into a single-dimensional &domain;
+      object that can be converted into a single-dimensional &range;,
+      or to a multidimensional &domain; object that itself can be
+      converted into an &range;.  The total dimensionality of all the
+      arguments' types should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.
+      One-dimensional &domain; objects that can be converted into
+      one-dimensional &range;s include &locone;s, &intervalone;s, and
+      &rangeone;s.  If the sum of the objects' dimensions is less
+      than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the ranges for the final
+      dimensions are unspecified.  See the last paragraph of &lt;xref
+      linkend=&quot;arrays-domains_declarations-loc&quot;&gt;&lt;/xref&gt; for an
+      analogous example.  Note that the &rangeone; constructors taking
+      two and three parameters treat these arguments differently than
+      the multidimensional constructors do.&lt;/para&gt;
+     &lt;/section&gt;
+ 
+ 
+     &lt;section id=&quot;arrays-domains_declarations-grids&quot;&gt;
+      &lt;title&gt;&grid;s&lt;/title&gt;
+ 
+      &lt;para&gt;&loc;s, &interval;s, and &range;s all have regularly spaced
+      integral values so they can be represented using &lt;glossterm
+      linkend=&quot;glossary-domain_triplet&quot;&gt;domain triplets&lt;/glossterm&gt;.
+      One-dimensional &grid; integral domains contain ascending or
+      descending sequences of integers, with no fixed stride.  For
+      example, a &gridone; may represent {-13, 1, 4, 5, 34}.  &gridone;
+      is generalized to multidimensional &grid;s using the direct
+      product of &gridone; &domain;s.&lt;/para&gt;
+ 
+      &lt;para&gt;&grid;s that can be represented using domain triplets can
+      be constructed using techniques similar to other &domain;s, but
+      irregularly spaced domains can be constructed using
+      &indirectionlistint;s.&lt;/para&gt;
+ 
+      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-grid-one_d_table&quot;&gt;
+       &lt;title&gt;Declaring One-Dimensional &grid;s&lt;/title&gt;
+      
+       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+        &lt;thead&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;constructor&lt;/entry&gt;
+ 	 &lt;entry&gt;result&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/thead&gt;
+        &lt;tfoot&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
+ 	 &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
+ 	 &lt;entry&gt;&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tfoot&gt;
+        &lt;tbody&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an empty, uninitialized grid.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &gridone;.  See the text for an explanation.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &gridone; from the interval specified by the
+ 	 integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
+ 	 &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &gridone; from the domain triplet specified
+ 	 by the integers converted from &lt;varname&gt;t1&lt;/varname&gt;,
+ 	 &lt;varname&gt;t2&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tbody&gt;
+       &lt;/tgroup&gt;
+      &lt;/table&gt;
+ 
+      &lt;para&gt;To construct a &gridone; that can also be represented by a
+      domain triplet, use a &gridone; constructor similar to those for
+      &intervalone; and &rangeone;.  See &lt;xref
+      linkend=&quot;arrays-domains_declarations-grid-one_d_table&quot;&gt;&lt;/xref&gt;
+      and the text explanations following &lt;xref
+      linkend=&quot;arrays-domains_declarations-range-one_d_table&quot;&gt;&lt;/xref&gt;
+      or &lt;xref
+      linkend=&quot;arrays-domains_declarations-interval-one_d_table&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
+ 
+      &lt;para&gt;&gridone;s with irregularly spaced points can be
+      constructed using &indirectionlistint;s.  For example,
+ &lt;programlisting&gt;
+ IndirectionList&lt;int&gt; list(4);
+ list(0) = 2;
+ list(1) = 5;
+ list(2) = 6;
+ list(3) = 9;
+ Grid&lt;1&gt; g(list);
+ &lt;/programlisting&gt; constructs an empty &indirectionlistint;, fills it
+      with ascending values, and then creates a &gridone; containing
+      {2, 5, 6, 9}.  When creating a list, its size must be specified.
+      Subsequently, its values can be assigned.  &indirectionlist;s can
+      also be initialized using one-dimensional &array;s:
+ &lt;programlisting&gt;
+ Array&lt;1,int,Brick&gt; a1(Interval&lt;1&gt;(0,3));
+ a1(0) = 2; a1(1) = 5; a1(2) = 6; a1(3) = 9;
+ IndirectionList&lt;int&gt; il(a1);
+ Grid&lt;1&gt; g1(il);
+ &lt;/programlisting&gt;  The &array; stores the integral points to include
+      in the &gridone; and is used to create the &indirectionlistint;,
+      which itself is used to create the &gridone;.  Since the points
+      are integers, the &array;'s type is &int;.  Either a &brick; or
+      &compressiblebrick; &engine; should be used.&lt;/para&gt;
+ 
+      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-grids-multi_d_table&quot;&gt;
+       &lt;title&gt;Declaring Multidimensional &grid;s&lt;/title&gt;
+      
+       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+        &lt;thead&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;constructor&lt;/entry&gt;
+ 	 &lt;entry&gt;result&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/thead&gt;
+        &lt;tfoot&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &grid;'s
+ 	 dimension.  &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;,
+ 	 &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are template
+ 	 parameters.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tfoot&gt;
+        &lt;tbody&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates an empty, uninitialized &grid;, to be assigned a value later.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &grid; using the given &domain; object.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/tbody&gt;
+       &lt;/tgroup&gt;
+      &lt;/table&gt;
+ 
+      &lt;para&gt;Constructors for multidimensional &grid;s are the same as
+      multidimensional &interval; constructors except they create
+      &grid;s, not intervals.  See &lt;xref
+      linkend=&quot;arrays-domains_declarations-grids-multi_d_table&quot;&gt;&lt;/xref&gt;.
+      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &grid;'s dimension.  The
+      first constructor returns empty, uninitialized grids.  The seven
+      other constructors create an &grid; using &domain; objects.  These
+      &domain; objects, having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
+      &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be converted into an
+      integer, into a single-dimensional &domain; object that can be
+      converted into a single-dimensional &grid;, or to a
+      multidimensional &domain; object that itself can be converted into
+      an &grid;.  The total dimensionality of all the arguments' types
+      should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional
+      &domain; objects that can be converted into one-dimensional &grid;s
+      include &locone;s, &intervalone;s, &rangeone;s, and &gridone;s.
+      If the sum of the objects' dimensions is less
+      than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the grids for the final
+      dimensions are unspecified.  See the last paragraph of &lt;xref
+      linkend=&quot;arrays-domains_declarations-loc&quot;&gt;&lt;/xref&gt; for an
+      analogous example.  Note that the &gridone; constructors taking
+      two and three parameters treat these arguments differently than
+      the multidimensional constructors do.&lt;/para&gt;
+     &lt;/section&gt;
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;arrays-arrays_declarations&quot;&gt;
+     &lt;title&gt;Declaring &array;s&lt;/title&gt;
+ 
+     &lt;para&gt;A &pooma; &array; maps indices from its &domain; to values.
+     In this section, we describe first describe how to declare
+     &array;s.  In the next section, we explain how to access
+     individual values stored within an &array; and &array; copy
+     semantics.&lt;/para&gt;
+ 
+     &lt;para&gt;&array; values need not just be stored values, as &c; arrays
+     have.  They can also be computed using its engine.  We defer
+     discussion of computing values to the next chapter discussing
+     engines (&lt;xref linkend=&quot;engines&quot;&gt;&lt;/xref&gt;).  To avoid being verbose
+     in this chapter, when we discuss stored values, the values might
+     instead be computed.&lt;/para&gt;
+ 
+     &lt;para&gt;Declaring an &array; requires four arguments: the domain's
+     dimensionality, the type of values stored or computed, a
+     specification how the values are stored, and a &domain;.  The
+     first three arguments are template parameters since few scientific
+     programs (and no &pooma; programs) need to change these values
+     while a program executes.  For example, an &array; cannot change
+     the type of the elements it stores.  Alternatively, an &array;'s
+     values can be copied into another &array; having the desired type.
+     Although scientific programs do not frequently change an array's
+     domain, they do frequently request a subset of the array's values,
+     i.e., a &lt;glossterm linkend=&quot;glossary-view&quot;&gt;view&lt;/glossterm&gt;.  The
+     subset is specified via a &domain; so it is a run-time value.
+     Views are presented in &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;An &array;'s first template parameter specifies its
+     dimensionality.  This positive
+     integer&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt; specifies its rank.  This is
+     the same value as its domain's dimensionality.  Theoretically, an
+     &array; can have any positive integer, but the &pooma; code
+     currently supports &lt;varname&gt;&dim;&lt;/varname&gt; at most seven.  For
+     almost all scientific codes, a dimension of three or four is
+     sufficient, but the code can be extended to support higher
+     dimensions.&lt;/para&gt;
+ 
+     &lt;para&gt;An &array;'s second template parameter specifies the type of
+     its stored values.  Common value types include &int;, &double;,
+     &complex;, and &vector;, but any type is permissible.  For
+     example, an &array;'s values might be matrices or even other
+     &array;s.  The parameter's default value is usually &double;, but
+     it may be changed when the &poomatoolkit; is configured.&lt;/para&gt;
+ 
+     &lt;para&gt;An &array;'s third parameter specifies how its data is
+     stored by an &engine; and its values accessed.  The argument is a
+     tag indicating a particular type of &engine;.  Permissible tags
+     include &brick;, &compressiblebrick;, and
+     &lt;type&gt;ConstantFunction&lt;/type&gt;.  The &brick; tag indicates all
+     &array; values will be explicitly stored, just as built-in &c;
+     arrays do.  If the &array;s frequently stores exactly the same
+     value in every position, a &compressiblebrick; &engine;, which
+     reduces its space requirements to a constant whenever all its
+     values are the same, is appropriate.  A
+     &lt;type&gt;ConstantFunction&lt;/type&gt; &engine; returns the same value for
+     all indices.&lt;/para&gt;
+ 
+     &lt;para&gt;Even though every &array; container has an engine to store
+     its values and permit access to individual values, an &array; is
+     conceptually separated from engines.  An engine's role is
+     low-level, storing values and permitting access to individual
+     values.  As we indicated above, the storage can be optimized to
+     fit specific situations such as few nonzero values and computing
+     values using a function applied to another engine's values.  An
+     &array;'s role is high-level, supporting access to groups of
+     values.  They handle memory allocation and deallocation.  &array;s
+     can be used in data-parallel expressions, e.g., adding all the
+     values in one &array; to all the values in another.  (See &lt;xref
+     linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt; for more information.)  Subsets of
+     &array; values, frequently used in data-parallel statements, can
+     be obtained.  (See &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt; for more
+     information.)  Even though engines and &array;s are conceptually
+     separate, higher-level &array;s provide access to lower-level
+     &engine;s.  Users usually have an &array; create its &engine;,
+     rarely explicitly creating &engine;s themselves.  Also, &array;s
+     provide access to individual values.  In short, &pooma; users use
+     &array;s, only dealing with how they are implemented (engines)
+     upon declaration.  For more description of &engine;s, see &lt;xref
+     linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;The engine parameter's default value is usually &brick;, but
+     it may be changed when the &poomatoolkit; is configured.&lt;/para&gt;
+ 
+     &lt;para&gt;An &array;'s one constructor argument is its domain.  The
+     domain specifies its extent and simultaneously how many values it
+     can return.  All the provided &domain; objects are combined to
+     yield an &lt;type&gt;Interval&lt;&dim;&gt;&lt;/type&gt;, where &dim; matches
+     the &array;'s first template parameter.  Since an &interval;
+     domain with its unit strides is used, there are no unaccessed
+     &lt;quote&gt;gaps&lt;/quote&gt; within the domain, wasting storage space.  To
+     use other domains to access an &array;, first create it using an
+     &interval; domain and then take a view of it, as described in
+     &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.  As we mentioned above, the current
+     &pooma; code supports up to seven dimensions so at most seven
+     &domain; objects can be provided.  If more dimensions are
+     required, the &pooma; code can be extended to the desired number
+     of dimensions.&lt;/para&gt;
+ 
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_declarations-table&quot;&gt;
+      &lt;title&gt;Declaring &array;s&lt;/title&gt;
+      
+      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+       &lt;thead&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&array; declaration&lt;/entry&gt;
+ 	&lt;entry&gt;result&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/thead&gt;
+       &lt;tfoot&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;Template parameters &lt;varname&gt;&dim;&lt;/varname&gt;,
+ 	 &lt;varname&gt;T&lt;/varname&gt;, and &lt;varname&gt;E&lt;/varname&gt; indicates the
+ 	 &array;'s dimension, value type, and &engine; type,
+ 	 respectively.  &lt;varname&gt;DT1&lt;/varname&gt;, &hellip;,
+ 	 &lt;varname&gt;DT7&lt;/varname&gt; indicate domain types or
+ 	 integers.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tfoot&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an empty, uninitialized &array; which must be
+ 	&lt;methodname&gt;initialize&lt;/methodname&gt;()d before use.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;!-- Omit Indirection Array because src/Engine/IndirectionEngine.h indicates it is not yet finished. --&gt;
+        &lt;!-- Omit the two Array&lt;D1,T1,E1&gt; a constructors, which
+        should not be used by users. --&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; object or integer.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6, const DT7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; object or
+ 	integer and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6, const DT7&amp; t7,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/table&gt;
+ 
+     &lt;para&gt;&array; constructors are listed in &lt;xref
+     linkend=&quot;arrays-arrays_declarations-table&quot;&gt;&lt;/xref&gt;.  An &array;s'
+     three template parameters for dimensionality, value type, and
+     engine type are abbreviated &lt;varname&gt;D&lt;/varname&gt;,
+     &lt;varname&gt;T&lt;/varname&gt;, and &lt;varname&gt;E&lt;/varname&gt;.  Template
+     parameters for domain types are named &lt;varname&gt;DT1&lt;/varname&gt;,
+     &hellip;, &lt;varname&gt;DT7&lt;/varname&gt;.  The first constructor, with no
+     domain arguments, creates an empty, uninitialized &array; for
+     which a domain must be specified before it is used.  Specify the
+     array's domain using its &lt;methodname&gt;initialize&lt;/methodname&gt; function.
+     The next seven constructors combine their domain arguments to
+     compute the resulting &array;'s domain.  These are combined in the
+     same way that multidimensional &interval;s are constructed.  (See
+     &lt;xref
+     linkend=&quot;arrays-domains_declarations-intervals-multi_d_table&quot;&gt;&lt;/xref&gt;
+     and the following text.)  The domain objects, having types
+     &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
+     &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
+     converted into an integer, into a single-dimensional &domain;
+     object that can be converted into a single-dimensional &interval;,
+     or to a multidimensional &domain; object that itself can be
+     converted into an &interval;.  The total dimensionality of all the
+     arguments' types should
+     &lt;emphasis&gt;equal&lt;/emphasis&gt;&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, unlike
+     &interval; construction which permits total dimensionality less
+     than or equal to&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional
+     &domain; objects that can be converted into one-dimensional
+     &interval;s include &locone;s, &intervalone;s, and &rangeone;s
+     with unit strides.  To initialize all of an &array; values to a
+     specific value, use one of the final seven constructors, each
+     taking a particular value, wrapped as a &lt;type&gt;ModelElement&lt;/type&gt;.
+     These constructors use the given domain objects the same way as
+     the preceding constructors but assign &lt;varname&gt;model&lt;/varname&gt; to
+     every &array; value.  &lt;varname&gt;model&lt;/varname&gt;'s type
+     &lt;type&gt;ModelElement&lt;T&gt;&lt;/type&gt; rather than
+     &lt;varname&gt;T&lt;/varname&gt; to differentiate it from an &int;, which can
+     also be used to specify a domain object.
+     &lt;type&gt;ModelElement&lt;/type&gt; just stores an element of any type
+     &lt;varname&gt;T&lt;/varname&gt;, which must match the &array;'s value
+     type.&lt;/para&gt;
+ 
+     &lt;para&gt;We illustrate creating &array;s.  To create a
+     three-dimensional &array;&nbsp;&lt;varname&gt;a&lt;/varname&gt; explicitly
+     storing &double; floating-point values, use
+ &lt;programlisting&gt;
+ Interval&lt;1&gt; D(6);
+ Interval&lt;3&gt; I3(D,D,D);
+ Array&lt;3,double,Brick&gt; a(I3);.
+ &lt;/programlisting&gt;  The template parameters specify its dimensionality,
+     the type of its values, and a &brick; &engine; type, which
+     explicitly stores values.  Its domain, which must have three
+     dimensions, is specified by an &lt;type&gt;Interval&lt;3&gt;&lt;/type&gt;
+     object which consists of a [0,5] intervals for all its three
+     dimensions.  Since &double; and &brick; are usually the default
+     template parameters, they can be omitted so these declarations are
+     equivalent:
+ &lt;programlisting&gt;
+ Array&lt;3,double&gt; a_duplicate1(I3);
+ Array&lt;3&gt; a_duplicate2(I3);.
+ &lt;/programlisting&gt;  To create a similar &array; with a domain of
+ [0:1:1, 0:2:1, 0:0:1], use
+ &lt;programlisting&gt;
+ Array&lt;3&gt; b(2,3,1);.
+ &lt;/programlisting&gt; Specifying an integer&nbsp;&lt;varname&gt;i&lt;/varname&gt;
+     indicates a one-dimensional zero-based &interval; [0:i-1:1].  To
+     store &bool;s, specify &bool; as the second template argument:
+ &lt;programlisting&gt;
+ Array&lt;2,bool&gt; c(2,3);.
+ &lt;/programlisting&gt;  To specify a default &array; value of &true;, use
+     &lt;statement&gt;ModelElement&lt;bool&gt;(true)&lt;/statement&gt;:
+ &lt;programlisting&gt;
+ Array&lt;2,bool&gt; c(2,3, ModelElement&lt;bool&gt;(true));.
+ &lt;/programlisting&gt;  To create a one-dimensional &array; containing
+     seven &double;s all equaling &pi;, use
+ &lt;programlisting&gt;
+ Array&lt;1,double,CompressibleBrick&gt; d(7, ModelElement&lt;double&gt;(4.0*atan(1.0)));.
+ &lt;/programlisting&gt;  We use a &compressiblebrick; &engine;, rather than
+     a &brick; &engine;, so all seven values will be stored once rather
+     than seven times when they are all the same.&lt;/para&gt;
+ 
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_declarations-initialize_table&quot;&gt;
+      &lt;title&gt;Initializing &array;s' Domains&lt;/title&gt;
+      
+      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+       &lt;thead&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;An &array;'s &lt;methodname&gt;initialize&lt;/methodname&gt; member
+ 	functions sets its domain and should be invoked only for an
+ 	array created without a domain.  It returns nothing.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;methodname&gt;initialize&lt;/methodname&gt; declaration&lt;/entry&gt;
+ 	&lt;entry&gt;result&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/thead&gt;
+       &lt;tfoot&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;Template parameters &lt;varname&gt;DT1&lt;/varname&gt;, &hellip;,
+ 	&lt;varname&gt;DT7&lt;/varname&gt; indicate domain types or
+ 	integers.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tfoot&gt;
+       &lt;tbody&gt;
+        &lt;!-- Omit Indirection Array initialize because it does not exist! --&gt;
+        &lt;!-- Omit the two Array&lt;D1,T1,E1&gt; functions, which should not be used by users. --&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain;
+ object or integer.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6, const DT7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; object and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6, const DT7&amp; t7,
+ 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/table&gt;
+ 
+     &lt;para&gt;An uninitialized &array;, created using the parameter-less
+     constructor, must have a specified domain before it can be used.
+     For example, one must use the parameter-less &array; constructor
+     when creating an array of &array;s using
+     &lt;keywordname&gt;new&lt;/keywordname&gt; (although it would probably be
+     better to create an &array; of &array;s since memory allocation
+     and deallocation would automatically be handled) so their domains
+     must be specified.  &array;'s &lt;methodname&gt;initialize&lt;/methodname&gt;
+     functions accept the same set of domain object specifications and
+     model elements that the &array; constructors do, creating the
+     specified domain.  See &lt;xref
+     linkend=&quot;arrays-arrays_declarations-initialize_table&quot;&gt;&lt;/xref&gt;.
+     For example, both &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt;
+     are two-dimensional &array;s of &float;s with a [2:7:1,-2:4:1]
+     domains:
+ &lt;programlisting&gt;
+ // Create an Array and its domain.
+ Array&lt;2,float,Brick&gt; a(Interval&lt;1&gt;(2,7), Interval&lt;1&gt;(-2,4));
+ // Create an Array without a domain and then specify its domain.
+ Array&lt;2,float,Brick&gt; b();
+ b.initialize(Interval&lt;1&gt;(2,7), Interval&lt;1&gt;(-2,4));.
+ &lt;/programlisting&gt;  Invoking &lt;methodname&gt;initialize&lt;/methodname&gt; on an
+     &array; with an existing domain is unspecified.  All &array;
+     values may be lost and memory may be leaked.&lt;/para&gt;
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;arrays-arrays_use&quot;&gt;
+     &lt;title&gt;Using &array;s&lt;/title&gt;
+ 
+     &lt;para&gt;In the previous section, we explained how to declare and
+     initialize &array;s.  In this section, we explain how to access
+     individual values stored within an &array; and how to copy
+     &array;s.  In &lt;xref linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt;, we explain
+     how to use entire &array;s in data-parallel statements, including
+     how to print them.  In &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;, we extend
+     this capability to work on subsets.&lt;/para&gt;
+ 
+     &lt;para&gt;In its simplest form, an &array; stores individual values,
+     permitting access to these values.  For a &cc; array, the desired
+     index is specified within square brackets following the array's
+     name.  For &pooma; &array;s, the desired index is specified
+     within parentheses following the &array;'s name.  The same
+     notation is used to read and write values.  For example, the
+     following code prints the initial value at index (2,-2) and
+     increments its value, printing the new value:
+ &lt;programlisting&gt;
+ Array&lt;2,int,Brick&gt; a(Interval&lt;1&gt;(0,3), Interval&lt;1&gt;(-2,4),
+      	               ModelElement&lt;int&gt;(4));
+ std::cout &openopen; a(2,-2) &openopen; std::endl;
+ ++a(2,-2);
+ std::cout &openopen; a(2,-2) &openopen; std::endl;
+ &lt;/programlisting&gt;  &lt;computeroutput&gt;4&lt;/computeroutput&gt; and then
+     &lt;computeroutput&gt;5&lt;/computeroutput&gt; are printed.  An index
+     specification for an &array; usually has as many integers as
+     dimensions, all separated by commas, but the &array;'s engine may
+     permit other notation such as using strings or floating-point
+     numbers.&lt;/para&gt;
+ 
+     &lt;para&gt;For read-only access to a value, use the
+     &lt;methodname&gt;read&lt;/methodname&gt; member function, which takes the
+     same index notation as its nameless read-write counterpart:
+ &lt;programlisting&gt;
+ std::cout &openopen; a.read(2,-2) &openopen; std::endl;
+ &lt;/programlisting&gt; Using &lt;methodname&gt;read&lt;/methodname&gt; sometimes
+     permits the optimizer to produce faster executing code.&lt;/para&gt;
+ 
+     &lt;example id=&quot;arrays-arrays_use-copy_example&quot;&gt;
+      &lt;title&gt;Copying &array;s&lt;/title&gt;
+      &amp;array-copy;
+     &lt;/example&gt;
+ 
+     &lt;para&gt;Copying &array;s requires little execution time because they
+     have reference semantics.  That is, a copy of an &array; and the
+     &array; itself share the same underlying data.  Changing a value
+     in one changes it in the other.  &lt;xref
+     linkend=&quot;arrays-arrays_use-copy_example&quot;&gt;&lt;/xref&gt; illustrates this
+     behavior.  Initially, all values in the array &lt;varname&gt;a&lt;/varname&gt;
+     are&nbsp;4.  The &lt;varname&gt;b&lt;/varname&gt; array is initialized using
+     &lt;varname&gt;a&lt;/varname&gt; so it shares the same values as
+     &lt;varname&gt;a&lt;/varname&gt;.  Thus, changing the former's value also
+     changes the latter's value.  Function arguments are also
+     initialized so changing their underlying values also changes the
+     calling function's values.  For example, the
+     &lt;function&gt;changeValue&lt;/function&gt; function changes the value with
+     index&nbsp;(0,0) of both its function argument
+     and&nbsp;&lt;varname&gt;a&lt;/varname&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;The separation between a higher-level &array; and its
+     lower-level &engine; storage permits fast copying.  An &array;'s
+     only data member is its engine, which itself has reference
+     semantics that increments a reference-counted pointer to its data.
+     Thus, copying an &array; requires creating a new object with one
+     data member and incrementing a pointer's reference count.
+     Destruction is similarly inexpensive.&lt;/para&gt;
+ 
+     &lt;para&gt;Array assignment does not have reference semantics.  Thus,
+     the assignment &lt;statement&gt;a = b&lt;/statement&gt; ensures that all of
+     &lt;varname&gt;a&lt;/varname&gt;'s values are the same as &lt;varname&gt;b&lt;/varname&gt;
+     at the time of assignment only.  Subsequent changes to
+     &lt;varname&gt;a&lt;/varname&gt;'s values do not change &lt;varname&gt;b&lt;/varname&gt;'s
+     values or vice versa.&lt;/para&gt;
+ 
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_use-compile_time_table&quot;&gt;
+      &lt;title&gt;&array; Internal Type Definitions and Compile-Time Constants&lt;/title&gt;
+      
+      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+       &lt;thead&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;internal type or compile-time constant&lt;/entry&gt;
+ 	&lt;entry&gt;meaning&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/thead&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;type&gt;This_t&lt;/type&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;the &array;'s type &lt;type&gt;Array&lt;&dim;,T,E&gt;&lt;/type&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;type&gt;Engine_t&lt;/type&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;the &array;'s &engine; type &lt;type&gt;Engine&lt;&dim;,T,E&gt;&lt;/type&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;type&gt;EngineTag_t&lt;/type&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;the &array;'s &engine;'s tag&nbsp;&lt;varname&gt;E&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;type&gt;Element_t&lt;/type&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;the type&nbsp;&lt;varname&gt;T&lt;/varname&gt; of values stored in the &array;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;type&gt;ElementRef_t&lt;/type&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;the type of references to values stored in the &array;
+ 	(usually &lt;type&gt;T&amp;&lt;/type&gt;).&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;type&gt;Domain_t&lt;/type&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;the type of the &array;'s domain.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;type&gt;Layout_t&lt;/type&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;the type of the &array;'s layout.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;fieldsynopsis&gt;
+ 	  &lt;modifier&gt;const&lt;/modifier&gt;
+ 	  &lt;type&gt;int&lt;/type&gt;
+ 	  &lt;varname&gt;dimensions&lt;/varname&gt;&lt;/fieldsynopsis&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;the number&nbsp;&dim; of dimensions of the &array;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;fieldsynopsis&gt;
+ 	  &lt;modifier&gt;const&lt;/modifier&gt;
+ 	  &lt;type&gt;int&lt;/type&gt;
+ 	  &lt;varname&gt;rank&lt;/varname&gt;&lt;/fieldsynopsis&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;synonym for &lt;varname&gt;dimensions&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/table&gt;
+ 
+     &lt;para&gt;The &array; class has internal type definitions and
+     constants useful for both compile-time and run-time computations.
+     See &lt;xref linkend=&quot;arrays-arrays_use-compile_time_table&quot;&gt;&lt;/xref&gt;.
+     These may be accessed using the &array;'s type and the scope
+     resolution operator (&lt;operator&gt;::&lt;/operator&gt;).  The table begins
+     with a list of internal type definitions, e.g.,
+     &lt;statement&gt;Array&lt;&dim;,T,E&gt;::Domain_t&lt;/statement&gt;.  Member
+     functions use some of these types.  A &lt;glossterm
+     linkend=&quot;glossary-layout&quot;&gt;layout&lt;/glossterm&gt; maps a domain index
+     to a particular processor and memory used to compute the
+     associated value.&lt;!-- FIXME: Add a reference to the corresponding
+     chapter. --&gt; The two internal enumerations
+     &lt;fieldsynopsis&gt;&lt;varname&gt;dimensions&lt;/varname&gt;&lt;/fieldsynopsis&gt; and
+     &lt;fieldsynopsis&gt;&lt;varname&gt;rank&lt;/varname&gt;&lt;/fieldsynopsis&gt; both record
+     the &array;'s dimension.&lt;/para&gt;
+ 
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_use-accessor_table&quot;&gt;
+      &lt;title&gt;&array; Accessors&lt;/title&gt;
+      
+      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+       &lt;thead&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&array; member function&lt;/entry&gt;
+ 	&lt;entry&gt;result&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/thead&gt;
+       &lt;tfoot&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;Internal type definitions, e.g., &lt;type&gt;Domain_t&lt;/type&gt;,
+ 	are listed without a class type prefix
+ 	&lt;statement&gt;Array&lt;&dim;,T,E&gt;::&lt;/statement&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tfoot&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Domain_t domain()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Domain_t physicalDomain()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Domain_t totalDomain()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;int first(int dim)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the first (smallest) index value for the
+ 	specified dimension.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;int last(int dim)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the last (largest) index value for the
+ 	specified dimension.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;int length(int dim)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the number of indices (including endpoints) for
+ 	the specified dimension.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; firsts()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the first (smallest) index values for all the
+ 	dimensions.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; lasts()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the last (largest) index values for all the
+ 	specified dimensions.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; lengths()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the numbers of indices (including endpoints)
+ 	for all the specified dimensions.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;long size()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the total number of indices in the domain.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Layout_t layout()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Engine_t engine()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the &array;'s engine.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;const Engine_t engine()&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;returns the &array;'s engine.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/table&gt;
+ 
+     &lt;para&gt;The &array; class has several member functions easing access
+     to its domain and engine.  The first ten functions listed in &lt;xref
+     linkend=&quot;arrays-arrays_use-accessor_table&quot;&gt;&lt;/xref&gt; ease access to
+     &array; domains.  The first three functions are synonyms all
+     returning the &array;'s domain, which has type
+     &lt;type&gt;Array&lt;&dim;,T,E&gt;::Domain_t&lt;/type&gt;, abbreviated
+     &lt;type&gt;Domain_t&lt;/type&gt; in the table.  The next seven functions
+     query the domain.  &lt;methodname&gt;first&lt;/methodname&gt;,
+     &lt;methodname&gt;last&lt;/methodname&gt;, and &lt;methodname&gt;length&lt;/methodname&gt;
+     return the smallest, largest, and number of indices for the
+     specified dimension.  The domain's dimensions are numbered 0, 1,
+     &hellip;,
+     &lt;statement&gt;Array&lt;&dim;,T,E&gt;::dimensions&lt;/statement&gt;-1.  If
+     these values are needed for all dimensions, use
+     &lt;methodname&gt;firsts&lt;/methodname&gt;, &lt;methodname&gt;lasts&lt;/methodname&gt;,
+     and &lt;methodname&gt;lengths&lt;/methodname&gt;.  The returned
+     &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt;s have &dim; entries, one for each
+     dimension.  &lt;methodname&gt;size&lt;/methodname&gt; returns the total number
+     of indices in the entire domain.  This is the product of all the
+     dimensions' &lt;methodname&gt;length&lt;/methodname&gt;s.  The
+     &lt;methodname&gt;layout&lt;/methodname&gt; member function returns the
+     &array;'s layout, which specifies the mapping of indices to
+     processors and memory.&lt;!-- FIXME: Add a reference to the
+     corresponding chapter. --&gt; The last two functions return the
+     &array;'s engine.&lt;/para&gt;
+ 
+     &lt;example id=&quot;arrays-arrays_use-members_example&quot;&gt;
+      &lt;title&gt;Using &array; Member Functions&lt;/title&gt;
+      &amp;array-size;
+      &lt;calloutlist&gt;
+       &lt;callout arearefs=&quot;arrays-arrays_use-members-example-compare_size&quot;&gt;
+        &lt;para&gt;The &lt;methodname&gt;size&lt;/methodname&gt; is invoked by
+        prepending the &array;'s name followed by a period.  This
+        assertion is unnecessary, but the
+        &lt;function&gt;computeArraySize&lt;/function&gt; function further
+        illustrates using member functions.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-arrays_use-members-example-template_parameters&quot;&gt;
+        &lt;para&gt;These template parameters, used in the &array;
+        parameter's type, permit the function to work with any
+        &array;.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-arrays_use-members-example-function_call&quot;&gt;
+        &lt;para&gt;We invoke these three member functions using the
+        &array;'s name &lt;varname&gt;a&lt;/varname&gt;, a period, and the
+        functions' names.  These functions return &loc;s.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-arrays_use-members-example-loc_use&quot;&gt;
+        &lt;para&gt;&lt;statement&gt;lens[d]&lt;/statement&gt; returns a
+        &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt; for
+        dimension&nbsp;&lt;varname&gt;d&lt;/varname&gt;'s length.  Invoking
+        &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt; &lt;methodname&gt;first&lt;/methodname&gt;method
+        yields its value.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-arrays_use-members-example-check_length&quot;&gt;
+        &lt;para&gt;This comparison is unnecessary but further illustrates
+        using member functions.&lt;/para&gt;
+       &lt;/callout&gt;
+      &lt;/calloutlist&gt;
+     &lt;/example&gt;
+ 
+     &lt;para&gt;We illustrate using &array; member functions in &lt;xref
+     linkend=&quot;arrays-arrays_use-members_example&quot;&gt;&lt;/xref&gt;.  The program
+     computes the total number of &array;'s indices, comparing the
+     result with invoking its &lt;methodname&gt;size&lt;/methodname&gt; method.
+     Since the &array;'s name is &lt;varname&gt;a&lt;/varname&gt;,
+     &lt;statement&gt;a.size()&lt;/statement&gt; returns its size.
+     &lt;function&gt;computeArraySize&lt;/function&gt; also computes the &array;'s
+     size.  This templated function uses its three template parameters
+     to accept any &array;, regardless of its dimension, value type, or
+     &engine; tag.  It begins by obtaining the range of indices for all
+     dimensions and their lengths.  Only the latter is necessary for
+     the computation, but the former further illustrate using member
+     functions.  The domain's size is the product of the length of each
+     dimension.  Since the lengths are stored in the
+     &lt;type&gt;Loc&lt;&amp;dim&gt;&lt;/type&gt; &lt;varname&gt;lens&lt;/varname&gt;,
+     &lt;statement&gt;lens[d]&lt;/statement&gt; is a &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;, for
+     which its &lt;methodname&gt;first&lt;/methodname&gt; extracts the length.  The
+     &lt;methodname&gt;length&lt;/methodname&gt; &array; member function is used in
+     the &lt;function&gt;PAssert&lt;/function&gt;.&lt;/para&gt;
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;arrays-doof2d&quot;&gt;
+     &lt;title&gt;An &array; Implementation of &amp;doof2d;&lt;/title&gt;
+ 
+     &lt;para&gt;mostly copy pp.35-38 from tutorial chapter&lt;!-- UNFINISHED --&gt;&lt;/para&gt;
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;arrays-implementation&quot;&gt;
+     &lt;title&gt;Implementing &array;s&lt;/title&gt;
+ 
+     &lt;para&gt;What to write?&lt;!-- UNFINISHED --&gt;
+ 
+     Do I need to describe the public interface of Domains?  Do I need
+     to describe how a programmer would implement a new type of domain?
+     Probably not.&lt;/para&gt;
+    &lt;/section&gt;
+ 
+   &lt;/chapter&gt;
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.5
diff -c -p -r1.5 concepts.xml
*** concepts.xml	2002/01/14 17:33:33	1.5
--- concepts.xml	2002/01/16 00:48:35
***************
*** 134,140 ****
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm
  	linkend=&quot;glossary-array&quot;&gt;&array;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;container mapping indices to values and that may be
  	used in expressions&lt;/entry&gt;
       &lt;/row&gt;
       &lt;row&gt;
--- 134,140 ----
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm
  	linkend=&quot;glossary-array&quot;&gt;&array;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;container mapping &lt;glossterm linkend=&quot;glossary-index&quot;&gt;indices&lt;/glossterm&gt; to values and that may be
  	used in expressions&lt;/entry&gt;
       &lt;/row&gt;
       &lt;row&gt;
***************
*** 146,152 ****
       &lt;/row&gt;
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm linkend=&quot;glossary-field&quot;&gt;&field;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;container mapping indices to one or more values and
  	residing in multi-dimensional space&lt;/entry&gt;
       &lt;/row&gt;
       &lt;row&gt;
--- 146,152 ----
       &lt;/row&gt;
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm linkend=&quot;glossary-field&quot;&gt;&field;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;container mapping &lt;glossterm linkend=&quot;glossary-index&quot;&gt;indices&lt;/glossterm&gt; to one or more values and
  	residing in multi-dimensional space&lt;/entry&gt;
       &lt;/row&gt;
       &lt;row&gt;
***************
*** 172,178 ****
  
    &lt;para&gt;A &pooma; &lt;glossterm
    linkend=&quot;glossary-array&quot;&gt;&array;&lt;/glossterm&gt; generalizes a &c; array
!   and maps indices to values.  Given an index or position in an
    &array;'s domain, it returns the associated value, either by
    returning a stored value or by computing it.  The use of indices,
    which are usually ordered tuples, permits constant-time access
--- 172,178 ----
  
    &lt;para&gt;A &pooma; &lt;glossterm
    linkend=&quot;glossary-array&quot;&gt;&array;&lt;/glossterm&gt; generalizes a &c; array
!   and maps &lt;glossterm linkend=&quot;glossary-index&quot;&gt;indices&lt;/glossterm&gt; to values.  Given an index or position in an
    &array;'s domain, it returns the associated value, either by
    returning a stored value or by computing it.  The use of indices,
    which are usually ordered tuples, permits constant-time access
***************
*** 350,356 ****
  
     &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-layout&quot;&gt;&lt;firstterm&gt;layout&lt;/firstterm&gt;&lt;/glossterm&gt;
!    maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; indices to the
     processors and computer memory used by a container's engines.  See
     &lt;xref
     linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
--- 350,356 ----
  
     &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-layout&quot;&gt;&lt;firstterm&gt;layout&lt;/firstterm&gt;&lt;/glossterm&gt;
!    maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; &lt;glossterm linkend=&quot;glossary-index&quot;&gt;indices&lt;/glossterm&gt; to the
     processors and computer memory used by a container's engines.  See
     &lt;xref
     linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.6
diff -c -p -r1.6 manual.xml
*** manual.xml	2002/01/14 17:33:34	1.6
--- manual.xml	2002/01/16 00:48:38
***************
*** 15,21 ****
  &lt;!ENTITY book &quot;book&quot;&gt;
    &lt;!-- Produce a notation for the book/manual/report/WWW page.  --&gt;
    &lt;!-- Modify this to the desired noun. --&gt;
! &lt;!ENTITY bookCap &quot;Book&quot;&gt;
    &lt;!-- Produce a capitalized version of &book;  --&gt;
    &lt;!-- Modify this to the desired noun. --&gt;
  &lt;!ENTITY c &quot;&lt;application class='software'&gt;C&lt;/application&gt;&quot;&gt;
--- 15,21 ----
  &lt;!ENTITY book &quot;book&quot;&gt;
    &lt;!-- Produce a notation for the book/manual/report/WWW page.  --&gt;
    &lt;!-- Modify this to the desired noun. --&gt;
! &lt;!ENTITY bookcap &quot;Book&quot;&gt;
    &lt;!-- Produce a capitalized version of &book;  --&gt;
    &lt;!-- Modify this to the desired noun. --&gt;
  &lt;!ENTITY c &quot;&lt;application class='software'&gt;C&lt;/application&gt;&quot;&gt;
***************
*** 32,37 ****
--- 32,39 ----
    &lt;!-- Produce a notation for &quot;&gt;&gt;&gt;&quot;, which infrequently occurs with templates.  Without this, TeX produces a shift symbol. --&gt;
  &lt;!ENTITY dashdash &quot;-&gap;-&quot; &gt;
    &lt;!-- Produce a notation for a double dash.  Without this, TeX produces an en-hyphen. --&gt;
+ &lt;!ENTITY dim &quot;D&quot;&gt;
+   &lt;!-- the number of dimensions of an array, domain, etc. --&gt;
  &lt;!ENTITY doof2d &quot;&lt;command&gt;Doof2d&lt;/command&gt;&quot; &gt;
    &lt;!-- Produce a notation for the Doof2d program.  --&gt;
  &lt;!ENTITY fortran &quot;&lt;application class='software'&gt;Fortran&lt;/application&gt;&quot;&gt;
***************
*** 89,94 ****
--- 91,98 ----
    &lt;!-- The DistributedTag Layout type. --&gt;
  &lt;!ENTITY domain &quot;&lt;type&gt;Domain&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;Domain&quot; type. --&gt;
+ &lt;!ENTITY domaintemplate &quot;DT&quot;&gt;
+   &lt;!-- A domain template parameter. --&gt;
  &lt;!ENTITY double &quot;&lt;type&gt;double&lt;/type&gt;&quot;&gt;
    &lt;!-- The C &quot;double&quot; type. --&gt;
  &lt;!ENTITY dynamicarray &quot;&lt;type&gt;DynamicArray&lt;/type&gt;&quot;&gt;
***************
*** 100,105 ****
--- 104,111 ----
    &lt;!-- Modify its tag to the appropriate one. --&gt;
  &lt;!ENTITY field &quot;&lt;type&gt;Field&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;Field&quot; type. --&gt;
+ &lt;!ENTITY float &quot;&lt;type&gt;float&lt;/type&gt;&quot;&gt;
+   &lt;!-- The C &quot;float&quot; type. --&gt;
  &lt;!ENTITY grid &quot;&lt;type&gt;Grid&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;Grid&quot; domain type. --&gt;
  &lt;!ENTITY gridone &quot;&lt;type&gt;Grid&lt;1&gt;&lt;/type&gt;&quot;&gt;
***************
*** 193,198 ****
--- 199,206 ----
    &lt;!-- formatting: for sets, no spaces between brackets and entries but spaced between entries --&gt;
  
  &lt;!-- External Chapters --&gt;
+ &lt;!ENTITY arrays-chapter SYSTEM &quot;arrays.xml&quot;&gt;
+   &lt;!-- Pooma Arrays chapter --&gt;
  &lt;!ENTITY bibliography-chapter SYSTEM &quot;bibliography.xml&quot;&gt;
    &lt;!-- bibliography --&gt;
  &lt;!ENTITY concepts-chapter SYSTEM &quot;concepts.xml&quot;&gt;
***************
*** 228,233 ****
--- 236,245 ----
  &lt;!-- Sequential Programs --&gt;
  &lt;!ENTITY initialize-finalize SYSTEM &quot;./programs/examples/Sequential/initialize-finalize-annotated.cpp&quot;&gt;
    &lt;!-- Illustrate initialize() and finalize(). --&gt;
+ &lt;!ENTITY array-copy SYSTEM &quot;./programs/examples/Sequential/array-copy-annotated.cpp&quot;&gt;
+   &lt;!-- Illustrate Array reference semantics. --&gt;
+ &lt;!ENTITY array-size SYSTEM &quot;./programs/examples/Sequential/array-size-annotated.cpp&quot;&gt;
+   &lt;!-- Illustrate Array member functions. --&gt;
  
  &lt;!-- Template Programs --&gt;
  &lt;!ENTITY pairs-untemplated SYSTEM &quot;./programs/examples/Templates/pairs-untemplated-annotated.cpp&quot;&gt;
***************
*** 285,291 ****
  
  
    &lt;section id=&quot;preface-reading_book:&quot;&gt;
!    &lt;title&gt;How to Read This &bookCap;&lt;/title&gt;
  
     &lt;para&gt;FINISH: Write this section in a style similar to Lamport's
     LaTeX section 1.2.  FINISH: Fix the book title and the section
--- 297,303 ----
  
  
    &lt;section id=&quot;preface-reading_book:&quot;&gt;
!    &lt;title&gt;How to Read This &bookcap;&lt;/title&gt;
  
     &lt;para&gt;FINISH: Write this section in a style similar to Lamport's
     LaTeX section 1.2.  FINISH: Fix the book title and the section
***************
*** 338,1581 ****
    &amp;tutorial-chapter;
  
    &amp;concepts-chapter;
- 
- 
-   &lt;chapter id=&quot;arrays&quot;&gt;
-    &lt;title&gt;&array; Containers&lt;/title&gt;
- 
-    &lt;para&gt;A container is a class holding objects.  &array;s are one of
-    the two most widely used &pooma; containers since they model the
-    mathematical concept of mapping indices from domains to values.
-    &pooma; &array;s extend built-in &cc; arrays by supporting a wider
-    variety of domains, automatically handling memory allocations, and
-    supporting first-class status.  For example, they may be used as
-    operands and in assignments.  In this chapter, we introduce the
-    concept of containers, the mathematical concept of arrays, and the
-    &pooma; concept for &array;s.  Before illustrating how to declare
-    &array;s, we introduce &domain;s, which specify the sets of
-    indices.  After describing how to declare the various types of
-    &domain;s, we describe how to declare and use &array;s.  This is
-    illustrated in a &amp;doof2d; implementation using &array;s.  We end
-    with a description of their implementation.&lt;/para&gt;
- 
- 
-    &lt;section id=&quot;arrays-containers&quot;&gt;
-     &lt;title&gt;Containers&lt;/title&gt;
- 
-     &lt;para&gt;A &lt;glossterm
-     linkend=&quot;glossary-container&quot;&gt;&lt;firstterm&gt;container class
-     expression&lt;/firstterm&gt;&lt;/glossterm&gt; is a class with the main
-     purpose of holding objects.  These stored objects, called
-     &lt;glossterm linkend=&quot;glossary-container_value&quot;&gt;&lt;firstterm&gt;container
-     values&lt;/firstterm&gt;&lt;/glossterm&gt; or more simply
-     &lt;quote&gt;values&lt;/quote&gt; or elements&lt;quote&gt;&lt;/quote&gt;, may be accessed
-     and changed, usually using indices.  &lt;quote&gt;Container
-     class&lt;/quote&gt; is usually abbreviated
-     &lt;quote&gt;container&lt;/quote&gt;.&lt;/para&gt;
- 
-     &lt;para&gt;The six &pooma; containers can be categorized into two
-     groups.  Mathematical containers include &tensor;s, &matrix;s, and
-     &vector;s, modeling tensors, matrices, and vectors, respectively.
-     Storage containers include &array;s, &dynamicarray;s, and
-     &field;s.  In this chapter, we focus on simplest of these:
-     &array;s.  The other containers will be described in subsequent
-     chapters.&lt;/para&gt;
- 
-     &lt;para&gt;&c;&nbsp;has built-in arrays, and the &cc; Standard Library
-     provides &lt;type&gt;map&lt;/type&gt;s, &lt;type&gt;vector&lt;/type&gt;s,
-     &lt;type&gt;stack&lt;/type&gt;s, and other containers, but the &pooma;
-     containers better model scientific computing concepts and provide
-     more functionality.  They automatically handle memory allocation
-     and deallocation and can be used in expressions and on the
-     left-hand side of assignments.  Since &pooma; containers separate
-     the container concepts of accessing and using values from storing
-     values, value storage can be optimized to specific needs.  For
-     example, if most of an &array;'s values are known to be the same
-     most of the time, a compressible engine can be used.  Whenever all
-     the array's values are the same, it stores only one value.  At
-     other times, it stores all the values.  Engines will be discussed
-     in &lt;xref linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
-    &lt;/section&gt;
- 
- 
-    &lt;section id=&quot;arrays-arrays&quot;&gt;
-     &lt;title&gt;&array;s&lt;/title&gt;
- 
-     &lt;para&gt;Mathematically, an array maps indices from a domain to
-     values.  Usually, the domain consists of a one-dimensional
-     integral interval or it may be multidimensional.  &pooma;'s
-     &array; container class implements this idea.  Given an index,
-     i.e., a position in an &array;'s &domain;, it returns the associated
-     value, either by returning a stored value or by computing it.  The
-     use of indices, which are usually integral tuples but need not be
-     zero-based or even consist of all possible integral tuples in a
-     multidimensional range.  Using indices permits constant-time
-     access to values although computing a particular value may require
-     significant time.&lt;/para&gt;
- 
-     &lt;para&gt;&pooma; &array;s are &lt;glossterm
-     linkend=&quot;glossary-first_class&quot;&gt;first-class
-     types&lt;firstterm&gt;&lt;/firstterm&gt;&lt;/glossterm&gt; so they can be used more
-     widely than built-in &cc; arrays.  For example, &array;s can be
-     used as operands and in assignment statements.  The statement
-     &lt;statement&gt;a = a + b;&lt;/statement&gt; adds corresponding elements of
-     &array;s &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt;, assigning
-     the sums to the &array; &lt;varname&gt;a&lt;/varname&gt;.  The statement
-     treats each array as one object, rather than requiring the use of
-     one or more loops to access individual values.  Data-parallel
-     statements are further discussed in &lt;xref
-     linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt;.  &array;s also handle their own
-     memory allocation and deallocation.  For example, the &array;
-     declaration &lt;statement&gt;Array&lt;2, double, Brick&gt;
-     a(vertDomain)&lt;/statement&gt; creates an
-     &array;&nbsp;&lt;varname&gt;a&lt;/varname&gt;, allocating whatever memory it
-     needs.  When &lt;varname&gt;a&lt;/varname&gt; goes out of scope, it and its
-     memory is automatically deallocated.  Automatic memory allocation
-     and deallocation also eases copying.  As we mentioned above, an
-     &array;'s &engine; stores or computes its values so it, not the
-     &array; itself, is responsible for memory allocation and
-     deallocation.  Fortunately, this distinction is usually hidden
-     from the &pooma; user.&lt;/para&gt;
- 
-     &lt;para&gt;Individual &array; values can be accessed using parentheses,
-     not square brackets, as for &cc; arrays.  For example,
-     &lt;statement&gt;a(3,4)&lt;/statement&gt; yields the value at position (3,4)
-     of &lt;varname&gt;a&lt;/varname&gt;'s two-dimensional domain.&lt;/para&gt;
-    &lt;/section&gt;
- 
- 
-    &lt;section id=&quot;arrays-domains&quot;&gt;
-     &lt;title&gt;&domain;s&lt;/title&gt;
- 
-     &lt;para&gt;A &lt;glossterm
-     linkend=&quot;glossary-domain&quot;&gt;&lt;firstterm&gt;domain&lt;/firstterm&gt;&lt;/glossterm&gt;
-     specifies the set of points on which an &array; can define values.
-     These indices are the arguments placed within parentheses when
-     selecting particular values, as described previously.  A domain
-     supported both by &array;s and by built-in &cc; arrays is an
-     interval [0,n-1] of integers containing all integers {0, 1, 2,
-     &hellip;, n-1}.  For &cc;, every integer in the interval must be
-     included, and the minimum index must be zero.  &pooma; expands the
-     set of permissible domains to support intervals with nonzero
-     minimal indices and strides and by adding other choices.&lt;/para&gt;
- 
-     &lt;para&gt;In &pooma;, &domain;s implement domains.  There are four
-     different categories:
-      &lt;variablelist&gt;
-       &lt;varlistentry&gt;
-        &lt;term&gt;&loc;&lt;/term&gt;
-        &lt;listitem&gt;
- 	&lt;para&gt;&domain; with a single point.&lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/varlistentry&gt;
-       &lt;varlistentry&gt;
-        &lt;term&gt;&interval;&lt;/term&gt;
-        &lt;listitem&gt;
- 	&lt;para&gt;&domain; with an integral interval [a,b].&lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/varlistentry&gt;
-       &lt;varlistentry&gt;
-        &lt;term&gt;&range;&lt;/term&gt;
-        &lt;listitem&gt;
- 	&lt;para&gt;&domain; with an integral interval [a,b] and an integral
- 	stride&nbsp;s indicating the gap between indices: {a, a+s,
- 	a+2s, &hellip;, b}.&lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/varlistentry&gt;
-       &lt;varlistentry&gt;
-        &lt;term&gt;&grid;&lt;/term&gt;
-        &lt;listitem&gt;
- 	&lt;para&gt;&domain; with an ascending or descending sequence of
- 	integral values.  The sequence elements must be individually
- 	specified.&lt;/para&gt;
-        &lt;/listitem&gt;
-       &lt;/varlistentry&gt;
-      &lt;/variablelist&gt;
-     One-dimensional and multidimensional versions of each categories
-     are supported.  A multidimensional &domain; consists of the direct
-     product of one-dimensional &domain;s.  For example, the first
-     dimension of a two-dimensional interval [0,3]x[2,9] is the
-     interval&nbsp;[0,3], and its second dimension is the
-     interval&nbsp;[2,9].  Its indices are ordered pairs such as (0,2),
-     (0,3), (1,2), (1,9), and&nbsp;(3,7).&lt;/para&gt;
- 
-     &lt;para&gt;Many domains can be represented using domain triplets.  A
-     &lt;glossterm linkend=&quot;glossary-domain_triplet&quot;&gt;&lt;firstterm&gt;domain
-     triplet&lt;/firstterm&gt;&lt;/glossterm&gt;
-     [&lt;varname&gt;begin&lt;/varname&gt;:&lt;varname&gt;end&lt;/varname&gt;:&lt;varname&gt;stride&lt;/varname&gt;]
-     represents the mathematical set {begin, begin + stride, begin +
-     2stride, &hellip;, end}, where &lt;varname&gt;end&lt;/varname&gt; is in the
-     set only if it equals &lt;varname&gt;begin&lt;/varname&gt; plus some integral
-     multiple of &lt;varname&gt;stride&lt;/varname&gt;.  If the
-     &lt;varname&gt;stride&lt;/varname&gt; is negative, its beginning index
-     &lt;varname&gt;begin&lt;/varname&gt; should at least be as large as
-     &lt;varname&gt;end&lt;/varname&gt; if the interval is to be nonempty.  The
-     stride can be zero only if &lt;varname&gt;begin&lt;/varname&gt; and
-     &lt;varname&gt;end&lt;/varname&gt; are equal.  There are lots of ways to
-     represent an empty interval, e.g., [1:0:1] and [23,34,-1], and
-     &pooma; will accept them, but they are all equivalent.  The domain
-     triplet notation is easily extended to multiple dimensions by
-     separating different dimension's intervals with commas.  For
-     example, [2:4:2,6:4:-2] contains (2,6), (2,4), (4,6),
-     and&nbsp;(4,4).&lt;/para&gt;
- 
-     &lt;para&gt;All the &domain; categories listed above except &grid; can be
-     represented using domain triplet notation.  Since the triplet
-     [7:7:1] represents {7}, or more simply&nbsp;7, it can also
-     represent &lt;statement&gt;Loc&lt;1&gt;(7)&lt;/statement&gt;.  Multidimensional
-     &loc;s are similarly represented.  For example,
-     [0:0:1,10:10:1,2:2:1] represents
-     &lt;statement&gt;Loc&lt;3&gt;(0,10,2)&lt;/statement&gt;, but it is frequently
-     abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
-     [a:b:1], while a &range; has specific stride&nbsp;s:
-     [a:b:s].&lt;/para&gt;
- 
-     &lt;para&gt;&domain;s can be constructed by combining &domain;s of smaller
-     dimension.  For example, since a two-dimensional &interval; is the
-     direct product of two one-dimensional &interval;s, it can be
-     specified using two one-dimensional &interval;s.  For example,
-     &lt;statement&gt;Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
-     Interval&lt;1&gt;(4,5))&lt;/statement&gt; creates a [2:3:1,4:5:1]
-     &domain;.  The resulting dimensionality equals the sum of the
-     components' dimensions.  For example, a four-dimension &loc; can
-     be specified using three- and one-dimension &loc;s or using four
-     one-dimension &loc;s.  If fewer dimensions than the created
-     object's dimensionality, the last dimensions are unspecified and
-     uninitialized.  &loc;s, &interval;s, &range;s, and &grid;s can all
-     be composed from smaller similar components.&lt;/para&gt;
- 
-     &lt;para&gt;A &domain; can be composed from smaller components with
-     different types.  A &loc; object can be constructed from other
-     &loc; objects and integers.  &interval;s, &range;s, and &grid;s
-     can be constructed using any of these types, &loc;s, and integers.
-     For example, &lt;statement&gt;Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2),
-     Interval&lt;1&gt;(3,5))&lt;/statement&gt; uses a two-dimensional &loc;
-     and a one-dimensional &interval; to create a [1:1:1,2:2:1,3:5:1]
-     &domain;.  During creation of a &domain;, the type of each object
-     is changed to the &domain;'s type.  In the example,
-     &lt;statement&gt;Loc&lt;2&gt;(1,2)&lt;/statement&gt; is first converted to an
-     &interval;.&lt;/para&gt;
- 
-     &lt;para&gt;&domain;s can participate in some arithmetic and comparison
-     operations.  For example, a &domain;'s triplet can be shifted two
-     units to the right by adding two.  Multiplying a &domain; by two
-     multiplies its triplet's beginnings, endings, and strides by two.
-     &pooma; users rarely need to compare &domain;s, but we describe
-     operating with the less-than operator on &interval;s.  &interval;
-     &lt;varname&gt;d1&lt;/varname&gt; &lt; &interval; &lt;varname&gt;d2&lt;/varname&gt; if the
-     length of &lt;varname&gt;d1's&lt;/varname&gt; interval is less than
-     &lt;varname&gt;d2&lt;/varname&gt;'s or, if equal, its beginning value is
-     smaller.  &domain; arithmetic is frequently used with data-parallel
-     statements and container views.  These will be discussed in &lt;xref
-     linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt; and &lt;xref
-     linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
- 
-     &lt;para&gt;The current &pooma; implementation supports &domain;s with
-     dimensionality between one and seven, inclusive.  Since most
-     scientific computations use one, two, or three dimensions, this is
-     usually sufficient.  If more dimensions are needed, they can be
-     added to the source code.&lt;/para&gt;
-    &lt;/section&gt;
- 
  
!    &lt;section id=&quot;arrays-domains_declarations&quot;&gt;
!     &lt;title&gt;Declaring &domain;s&lt;/title&gt;
  
-     &lt;para&gt;Since &domain;s are mainly used to declare container
-     domains, we focus on declaring &domain;s.  Arithmetic operations
-     with &domain;s are described in &lt;xref
-     linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
- 
-     &lt;para&gt;All &domain; declarations require a dimension template
-     parameter&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  This positive integer
-     specifies the number of dimensions, i.e., rank, of the &domain; and
-     determines the length of the tuples for points in the &domain;.  For
-     example, a three-dimensional &domain; contains ordered triples,
-     while a one-dimensional &domain; contains singletons, or just
-     integers.  Multidimensional &domain;s are just the direct products
-     of one-dimensional &domain;s so the techniques for declaring
-     one-dimensional &domain;s carry over to multi-dimensional
-     ones.&lt;/para&gt;
- 
-     &lt;para&gt;To declare a &domain;, one must include the
-     &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; header
-     file.  However, most &pooma; programs declare &domain;s to use them
-     when constructing containers.  The container header files
-     automatically include &lt;filename
-     class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; so no explicit
-     inclusion is usually necessary.&lt;/para&gt;
- 
-     &lt;section id=&quot;arrays-domains_declarations-loc&quot;&gt;
-      &lt;title&gt;&loc;s&lt;/title&gt;
- 
-      &lt;para&gt;A &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt; is a &domain; with just a single
-      &lt;varname&gt;&dim;&lt;/varname&gt;-dimensional point.  Although it is
-      infrequently used as a container's domain, it is used to refer to
-      a single point within another domain.  Its beginning and ending
-      points are the same, and its stride is one.  One-dimensional
-      &loc;s and integers are frequently interchanged.&lt;/para&gt;
- 
-      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-loc-one_d_table&quot;&gt;
-       &lt;title&gt;Declaring One-Dimensional &loc;s&lt;/title&gt;
-      
-       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-        &lt;thead&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;constructor&lt;/entry&gt;
- 	 &lt;entry&gt;result&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/thead&gt;
-        &lt;tfoot&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;varname&gt;T1&lt;/varname&gt;, &lt;varname&gt;T2&lt;/varname&gt;, and
- 	 &lt;varname&gt;T3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
- 	 &lt;entry&gt;&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tfoot&gt;
-        &lt;tbody&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;points to zero.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an uninitialized &locone;, to be assigned a value later.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const T1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &locone; with the integer converted from &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const T1&amp; t1, const T2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &locone; with the integer converted from
- 	 &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
- 	 &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &locone; with the integer converted from
- 	 &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
- 	 &lt;varname&gt;t1&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt; is
- 	 ignored.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tbody&gt;
-       &lt;/tgroup&gt;
-      &lt;/table&gt;
- 
-      &lt;para&gt;Constructors for one-dimensional &loc;s appear in &lt;xref
-      linkend=&quot;arrays-domains_declarations-loc-one_d_table&quot;&gt;&lt;/xref&gt;.
-      The empty constructor yields the zero point.  The constructor
-      taking a &lt;type&gt;Pooma::Init&lt;/type&gt; object does not initialize the
-      resulting &loc; to any particular value.  Presumably, the value
-      will be assigned later.  For small &domain;s such as &loc;s, the
-      time savings from not initializing is small, but the
-      functionality is still available.  The constructor taking one
-      argument with type&nbsp;&lt;type&gt;T1&lt;/type&gt; converts this argument to
-      an integer to specify the point.  The template
-      type&nbsp;&lt;type&gt;T1&lt;/type&gt; may be any type that can be converted
-      to an integer, e.g., &bool;, &char;, &int;, or &double;.  The
-      constructors taking two and three arguments of templatized types
-      facilitate converting an &interval; and a &range; into a &loc;.
-      Since a &loc; represents a single point, the &interval;'s or
-      &range;'s first two arguments must be equal.  The stride is
-      ignored.  Again, the templatized types may be any type that can
-      be converted into an integer.&lt;/para&gt;
- 
-      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-loc-multi_d_table&quot;&gt;
-       &lt;title&gt;Declaring Multidimensional &loc;s&lt;/title&gt;
-      
-       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-        &lt;thead&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;constructor&lt;/entry&gt;
- 	 &lt;entry&gt;result&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/thead&gt;
-        &lt;tfoot&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &loc;'s dimension.
- 	 &lt;varname&gt;T1&lt;/varname&gt;, &lt;varname&gt;T2&lt;/varname&gt;, &hellip; are
- 	 template parameters.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tfoot&gt;
-        &lt;tbody&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;points to zero.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an uninitialized &loc;, to be assigned a value later.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const T1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &loc; using the given &domain; object.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6, const T7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tbody&gt;
-       &lt;/tgroup&gt;
-      &lt;/table&gt;
- 
-      &lt;para&gt;Constructors for multidimensional &loc;s appear in &lt;xref
-      linkend=&quot;arrays-domains_declarations-loc-multi_d_table&quot;&gt;&lt;/xref&gt;.
-      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &loc;'s dimension.  The
-      first two constructors are similar to &locone;'s first two
-      constructors, returning a representation of the zero point and
-      returning an uninitialized point.  The seven other constructors
-      create a &loc; using other &domain; objects.  These &domain; objects,
-      having types &lt;type&gt;T1&lt;/type&gt;, &hellip;, &lt;type&gt;T7&lt;/type&gt;, can have
-      any type that can be converted into an integer, to a &locone;, or
-      to a multidimensional &domain; object that itself can be converted
-      into a &loc;.  The total dimensionality of all the arguments'
-      types should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  For example,
-      &lt;statement&gt;Loc&lt;5&gt;(Range&lt;1&gt;(2,2,2), Loc&lt;2&gt;(2,3),
-      Interval&lt;1&gt;(4,4))&lt;/statement&gt; creates a five-dimensional &loc;
-      [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
-      &loc;, and a one-dimensional &interval;.  The final fifth
-      dimension has an unspecified value, in this case&nbsp;1.  The
-      one-dimensional &range; is converted into the single integer two;
-      its beginning and ending points must be the same.  The
-      two-dimensional &loc; contributes values for the next two
-      dimensions, while the &interval; contributes its beginning point,
-      which must be the same as its ending point.  Note that the
-      &locone; constructors taking two and three parameters ignore
-      their second and third arguments, but this is not true for the
-      multidimensional constructors.&lt;/para&gt;
-     &lt;/section&gt;
- 
- 
-     &lt;section id=&quot;arrays-domains_declarations-intervals&quot;&gt;
-      &lt;title&gt;&interval;s&lt;/title&gt;
- 
-      &lt;para&gt;A one-dimensional &interval; represents a set of integers
-      within a mathematical &lt;glossterm
-      linkend=&quot;glossary-interval&quot;&gt;interval&lt;/glossterm&gt;.
-      Multidimensional &interval;s represent their multidimensional
-      generalization, i.e., the direct product of one-dimensional
-      intervals.  &interval;s are arguably the most commonly used
-      &pooma; &domain;.  A one-dimensional &interval; has integral
-      beginning and ending points and a unit stride.&lt;/para&gt;
- 
-      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-interval-one_d_table&quot;&gt;
-       &lt;title&gt;Declaring One-Dimensional &interval;s&lt;/title&gt;
-      
-       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-        &lt;thead&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;constructor&lt;/entry&gt;
- 	 &lt;entry&gt;result&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/thead&gt;
-        &lt;tfoot&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;varname&gt;T1&lt;/varname&gt;, &lt;varname&gt;T2&lt;/varname&gt;, and
- 	 &lt;varname&gt;T3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
- 	 &lt;entry&gt;&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tfoot&gt;
-        &lt;tbody&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an empty, uninitialized interval.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an uninitialized &intervalone;, to be assigned a value later.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const T1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &intervalone;.  See the text for an explanation.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const T1&amp; t1, const T2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &intervalone; with the integers converted from
- 	 &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &intervalone; with the integers converted from
- 	 &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.
- 	 &lt;varname&gt;t3&lt;/varname&gt; must equal&nbsp;1.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tbody&gt;
-       &lt;/tgroup&gt;
-      &lt;/table&gt;
- 
-      &lt;para&gt;&intervalone; constructors are patterned on &locone;
-      constructors except that &intervalone;s can have differing
-      beginning and ending points.  See &lt;xref
-      linkend=&quot;arrays-domains_declarations-interval-one_d_table&quot;&gt;&lt;/xref&gt;.
-      The default constructor creates an empty, uninitialized interval,
-      which should not be used before assigning it values.  If the
-      one-parameter constructor's argument is a &domain; object, it must
-      be a one-dimensional &domain; object which is copied into an
-      &interval; if possible; for example, it must have unit stride.
-      If the one-parameter constructor's argument is not a &domain;
-      object, it must be convertible to an
-      integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and an interval [0:e-1:1]
-      starting at zero is constructed.  If two arguments are specified,
-      they are assumed to be convertible to integers
-      &lt;varname&gt;b&lt;/varname&gt; and &lt;varname&gt;e&lt;/varname&gt;, specifying the
-      interval [b:e:1].  The three-parameter constructor is similar,
-      with the third argument specifying a stride, which must be
-      one.&lt;/para&gt;
- 
-      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-intervals-multi_d_table&quot;&gt;
-       &lt;title&gt;Declaring Multidimensional &interval;s&lt;/title&gt;
-      
-       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-        &lt;thead&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;constructor&lt;/entry&gt;
- 	 &lt;entry&gt;result&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/thead&gt;
-        &lt;tfoot&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &interval;'s dimension.
- 	 &lt;varname&gt;T1&lt;/varname&gt;, &lt;varname&gt;T2&lt;/varname&gt;, &hellip; are
- 	 template parameters.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tfoot&gt;
-        &lt;tbody&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const T1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &interval; using the given &domain; object.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6, const T7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tbody&gt;
-       &lt;/tgroup&gt;
-      &lt;/table&gt;
- 
-      &lt;para&gt;Constructors for multidimensional &interval;s closely
-      follow constructors for multidimensional &loc;s.  See &lt;xref
-      linkend=&quot;arrays-domains_declarations-intervals-multi_d_table&quot;&gt;&lt;/xref&gt;.
-      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &interval;'s dimension.
-      The first two constructors both return empty, uninitialized
-      intervals.  The seven other constructors create an &interval;
-      using &domain; objects.  These &domain; objects, having types
-      &lt;type&gt;T1&lt;/type&gt;, &hellip;, &lt;type&gt;T7&lt;/type&gt;, can have any type
-      that can be converted into an integer, into a single-dimensional
-      &domain; object that can be converted into a single-dimensional
-      &interval;, or to a multidimensional &domain; object that itself
-      can be converted into an &interval;.  The total dimensionality of
-      all the arguments' types should be at
-      most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional &domain; objects
-      that can be converted into one-dimensional &interval;s include
-      &locone;s, &intervalone;s, and &rangeone;s with unit strides.  If
-      the sum of the objects' dimensions is less
-      than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the intervals for the final
-      dimensions are unspecified.  See the last paragraph of &lt;xref
-      linkend=&quot;arrays-domains_declarations-loc&quot;&gt;&lt;/xref&gt; for an
-      analogous example.  Note that the &intervalone; constructors
-      taking two and three parameters treat these arguments differently
-      than the multidimensional constructors do.&lt;/para&gt;
-     &lt;/section&gt;
- 
- 
-     &lt;section id=&quot;arrays-domains_declarations-ranges&quot;&gt;
-      &lt;title&gt;&range;s&lt;/title&gt;
- 
-      &lt;para&gt;A one-dimensional &range; generalizes an &interval; by
-      permitting a non-unit stride between integral members.  A
-      &lt;glossterm
-      linkend=&quot;glossary-range&quot;&gt;&lt;firstterm&gt;range&lt;/firstterm&gt;&lt;/glossterm&gt;
-      is a set of integers in a mathematical interval [b,e] with a
-      stride&nbsp;s between them: {a, a+s, a+2s, &hellip;, b}.  Ranges
-      are generalized to &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;dimensions using the
-      direct product of one-dimensional ranges.&lt;/para&gt;
- 
-      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-range-one_d_table&quot;&gt;
-       &lt;title&gt;Declaring One-Dimensional &range;s&lt;/title&gt;
-      
-       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-        &lt;thead&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;constructor&lt;/entry&gt;
- 	 &lt;entry&gt;result&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/thead&gt;
-        &lt;tfoot&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;varname&gt;T1&lt;/varname&gt;, &lt;varname&gt;T2&lt;/varname&gt;, and
- 	 &lt;varname&gt;T3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
- 	 &lt;entry&gt;&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tfoot&gt;
-        &lt;tbody&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an empty, uninitialized range.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an uninitialized &rangeone;, to be assigned a value later.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const T1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &rangeone;.  See the text for an explanation.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const T1&amp; t1, const T2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &rangeone; with an interval specified by the
- 	 integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
- 	 &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &rangeone; by converting the arguments to
- 	 integers &lt;varname&gt;i1&lt;/varname&gt;, &lt;varname&gt;i2&lt;/varname&gt;, and
- 	 &lt;varname&gt;i3&lt;/varname&gt; and then making a range [i1:i2:i3].&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tbody&gt;
-       &lt;/tgroup&gt;
-      &lt;/table&gt;
- 
-      &lt;para&gt;&rangeone; constructors are the same as &intervalone;
-      constructors except they create ranges, not intervals.  See &lt;xref
-      linkend=&quot;arrays-domains_declarations-range-one_d_table&quot;&gt;&lt;/xref&gt;.
-      The default constructor creates an empty, uninitialized range,
-      which should not be used before assigning it values.  If the
-      one-parameter constructor's argument is a &domain; object, it must
-      be a one-dimensional &domain; object which is copied into a &range;
-      if possible.  If the one-parameter constructor's argument is not
-      a &domain; object, it must be convertible to an
-      integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and a range [0:e-1:1] starting
-      at zero is constructed.  If two arguments are specified, they are
-      assumed to be convertible to integers &lt;varname&gt;b&lt;/varname&gt; and
-      &lt;varname&gt;e&lt;/varname&gt;, specifying the range [b:e:1].  The
-      three-parameter constructor is similar, with the third argument
-      specifying a stride.&lt;/para&gt;
- 
-      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-ranges-multi_d_table&quot;&gt;
-       &lt;title&gt;Declaring Multidimensional &range;s&lt;/title&gt;
-      
-       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-        &lt;thead&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;constructor&lt;/entry&gt;
- 	 &lt;entry&gt;result&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/thead&gt;
-        &lt;tfoot&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &range;'s dimension.
- 	 &lt;varname&gt;T1&lt;/varname&gt;, &lt;varname&gt;T2&lt;/varname&gt;, &hellip; are
- 	 template parameters.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tfoot&gt;
-        &lt;tbody&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const T1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &range; using the given &domain; object.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6, const T7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tbody&gt;
-       &lt;/tgroup&gt;
-      &lt;/table&gt;
- 
-      &lt;para&gt;Constructors for multidimensional &range;s are the same as
-      multidimensional &interval; constructors except they create
-      ranges, not intervals.  See &lt;xref
-      linkend=&quot;arrays-domains_declarations-ranges-multi_d_table&quot;&gt;&lt;/xref&gt;.
-      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &range;'s dimension.  The
-      first two constructors return empty, uninitialized ranges.
-      The seven other constructors create an &range; using &domain;
-      objects.  These &domain; objects, having types &lt;type&gt;T1&lt;/type&gt;,
-      &hellip;, &lt;type&gt;T7&lt;/type&gt;, can have any type that can be
-      converted into an integer, into a single-dimensional &domain;
-      object that can be converted into a single-dimensional &range;,
-      or to a multidimensional &domain; object that itself can be
-      converted into an &range;.  The total dimensionality of all the
-      arguments' types should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.
-      One-dimensional &domain; objects that can be converted into
-      one-dimensional &range;s include &locone;s, &intervalone;s, and
-      &rangeone;s.  If the sum of the objects' dimensions is less
-      than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the ranges for the final
-      dimensions are unspecified.  See the last paragraph of &lt;xref
-      linkend=&quot;arrays-domains_declarations-loc&quot;&gt;&lt;/xref&gt; for an
-      analogous example.  Note that the &rangeone; constructors taking
-      two and three parameters treat these arguments differently than
-      the multidimensional constructors do.&lt;/para&gt;
-     &lt;/section&gt;
- 
- 
-     &lt;section id=&quot;arrays-domains_declarations-grids&quot;&gt;
-      &lt;title&gt;&grid;s&lt;/title&gt;
- 
-      &lt;para&gt;&loc;s, &interval;s, and &range;s all have regularly spaced
-      integral values so they can be represented using &lt;glossterm
-      linkend=&quot;glossary-domain_triplet&quot;&gt;domain triplets&lt;/glossterm&gt;.
-      One-dimensional &grid; integral domains contain ascending or
-      descending sequences of integers, with no fixed stride.  For
-      example, a &gridone; may represent {-13, 1, 4, 5, 34}.  &gridone;
-      is generalized to multidimensional &grid;s using the direct
-      product of &gridone; &domain;s.&lt;/para&gt;
- 
-      &lt;para&gt;&grid;s that can be represented using domain triplets can
-      be constructed using techniques similar to other &domain;s, but
-      irregularly spaced domains can be constructed using
-      &indirectionlistint;s.&lt;/para&gt;
- 
-      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-grid-one_d_table&quot;&gt;
-       &lt;title&gt;Declaring One-Dimensional &grid;s&lt;/title&gt;
-      
-       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-        &lt;thead&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;constructor&lt;/entry&gt;
- 	 &lt;entry&gt;result&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/thead&gt;
-        &lt;tfoot&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;varname&gt;T1&lt;/varname&gt;, &lt;varname&gt;T2&lt;/varname&gt;, and
- 	 &lt;varname&gt;T3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
- 	 &lt;entry&gt;&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tfoot&gt;
-        &lt;tbody&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an empty, uninitialized grid.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const T1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &gridone;.  See the text for an explanation.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const T1&amp; t1, const T2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &gridone; from the interval specified by the
- 	 integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
- 	 &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &gridone; from the domain triplet specified
- 	 by the integers converted from &lt;varname&gt;t1&lt;/varname&gt;,
- 	 &lt;varname&gt;t2&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt;.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tbody&gt;
-       &lt;/tgroup&gt;
-      &lt;/table&gt;
- 
-      &lt;para&gt;To construct a &gridone; that can also be represented by a
-      domain triplet, use a &gridone; constructor similar to those for
-      &intervalone; and &rangeone;.  See &lt;xref
-      linkend=&quot;arrays-domains_declarations-grid-one_d_table&quot;&gt;&lt;/xref&gt;
-      and the text explanations following &lt;xref
-      linkend=&quot;arrays-domains_declarations-range-one_d_table&quot;&gt;&lt;/xref&gt;
-      or &lt;xref
-      linkend=&quot;arrays-domains_declarations-interval-one_d_table&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
- 
-      &lt;para&gt;&gridone;s with irregularly spaced points can be
-      constructed using &indirectionlistint;s.  For example,
- &lt;programlisting&gt;
- IndirectionList&lt;int&gt; list(4);
- list(0) = 2;
- list(1) = 5;
- list(2) = 6;
- list(3) = 9;
- Grid&lt;1&gt; g(list);
- &lt;/programlisting&gt; constructs an empty &indirectionlistint;, fills it
-      with ascending values, and then creates a &gridone; containing
-      {2, 5, 6, 9}.  When creating a list, its size must be specified.
-      Subsequently, its values can be assigned.  &indirectionlist;s can
-      also be initialized using one-dimensional &array;s:
- &lt;programlisting&gt;
- Array&lt;1,int,Brick&gt; a1(Interval&lt;1&gt;(0,3));
- a1(0) = 2; a1(1) = 5; a1(2) = 6; a1(3) = 9;
- IndirectionList&lt;int&gt; il(a1);
- Grid&lt;1&gt; g1(il);
- &lt;/programlisting&gt;  The &array; stores the integral points to include
-      in the &gridone; and is used to create the &indirectionlistint;,
-      which itself is used to create the &gridone;.  Since the points
-      are integers, the &array;'s type is &int;.  Either a &brick; or
-      &compressiblebrick; &engine; should be used.&lt;/para&gt;
- 
-      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-grids-multi_d_table&quot;&gt;
-       &lt;title&gt;Declaring Multidimensional &grid;s&lt;/title&gt;
-      
-       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-        &lt;thead&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;constructor&lt;/entry&gt;
- 	 &lt;entry&gt;result&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/thead&gt;
-        &lt;tfoot&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &grid;'s dimension.
- 	 &lt;varname&gt;T1&lt;/varname&gt;, &lt;varname&gt;T2&lt;/varname&gt;, &hellip; are
- 	 template parameters.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tfoot&gt;
-        &lt;tbody&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an empty, uninitialized &grid;, to be assigned a value later.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const T1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &grid; using the given &domain; object.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6, const T7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
- 	&lt;/row&gt;
-        &lt;/tbody&gt;
-       &lt;/tgroup&gt;
-      &lt;/table&gt;
- 
-      &lt;para&gt;Constructors for multidimensional &grid;s are the same as
-      multidimensional &interval; constructors except they create
-      &grid;s, not intervals.  See &lt;xref
-      linkend=&quot;arrays-domains_declarations-grids-multi_d_table&quot;&gt;&lt;/xref&gt;.
-      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &grid;'s dimension.  The
-      first constructor returns empty, uninitialized grids.  The seven
-      other constructors create an &grid; using &domain; objects.  These
-      &domain; objects, having types &lt;type&gt;T1&lt;/type&gt;, &hellip;,
-      &lt;type&gt;T7&lt;/type&gt;, can have any type that can be converted into an
-      integer, into a single-dimensional &domain; object that can be
-      converted into a single-dimensional &grid;, or to a
-      multidimensional &domain; object that itself can be converted into
-      an &grid;.  The total dimensionality of all the arguments' types
-      should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional
-      &domain; objects that can be converted into one-dimensional &grid;s
-      include &locone;s, &intervalone;s, &rangeone;s, and &gridone;s.
-      If the sum of the objects' dimensions is less
-      than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the grids for the final
-      dimensions are unspecified.  See the last paragraph of &lt;xref
-      linkend=&quot;arrays-domains_declarations-loc&quot;&gt;&lt;/xref&gt; for an
-      analogous example.  Note that the &gridone; constructors taking
-      two and three parameters treat these arguments differently than
-      the multidimensional constructors do.&lt;/para&gt;
-     &lt;/section&gt;
-    &lt;/section&gt;
- 
- 
-    &lt;section id=&quot;arrays-arrays_use&quot;&gt;
-     &lt;title&gt;Declaring and Using &array;s&lt;/title&gt;
- 
-     &lt;para&gt;A &pooma; &array; maps indices from its &domain; to values.
-     In this section, we describe first describe how to declare
-     &array;s.  Then, we explain how to access individual values stored
-     or computed by an &array; and their copy semantics.&lt;/para&gt;
- 
-     &lt;para&gt;&array; values need not just be stored values, as &c; arrays
-     have.  They can also be computed using its engine.  We defer
-     discussion of computing values to the next chapter discussing
-     engines (&lt;xref linkend=&quot;engines&quot;&gt;&lt;/xref&gt;).  To avoid being verbose
-     in this chapter, when we discuss stored values, the values might
-     instead be computed.&lt;/para&gt;
- 
-     &lt;para&gt;Declaring an &array; requires four arguments: the domain's
-     dimensionality, the type of values stored or computed, a
-     specification how the values are stored, and a &domain;.  The
-     first three arguments are template parameters since few scientific
-     programs (and no &pooma; programs) need to change these values
-     while a program executes.  For example, an &array; cannot change
-     the type of the elements it stores.  Alternatively, an &array;'s
-     values can be copied into another &array; having the desired type.
-     Although scientific programs do not frequently change an array's
-     domain, they do frequently request a subset of the array's values,
-     i.e., a &lt;glossterm linkend=&quot;glossary-view&quot;&gt;view&lt;/glossterm&gt;.  The
-     subset is specified via a &domain; so it is a run-time value.
-     Views are presented in &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
- 
-     &lt;para&gt;An &array;'s first template parameter specifies its
-     dimensionality.  This positive
-     integer&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt; specifies its rank.  This is
-     the same value as its domain's dimensionality.  Theoretically, an
-     &array; can have any positive integer, but the &pooma; code
-     currently supports &lt;varname&gt;&dim;&lt;/varname&gt; at most seven.  For
-     almost all scientific codes, a dimension of three or four is
-     sufficient, but the code can be extended to support higher
-     dimensions.&lt;/para&gt;
- 
-     &lt;para&gt;An &array;'s second template parameter specifies the type of
-     its stored values.  Common value types include &int;, &double;,
-     &complex;, and &vector;, but any type is permissible.  For
-     example, an &array;'s values might be matrices or even other
-     &array;s.&lt;/para&gt;
- 
-     &lt;para&gt;An &array;'s third parameter specifies how its data is
-     stored by an &engine; and its values accessed.  The argument is a
-     tag indicating a particular type of &engine;.  Permissible tags
-     include &brick;, &compressiblebrick;, and
-     &lt;type&gt;ConstantFunction&lt;/type&gt;.  The &brick; tag indicates all
-     &array; values will be explicitly stored, just as built-in &c;
-     arrays do.  If the &array;s frequently stores exactly the same
-     value in every position, a &compressiblebrick; &engine;, which
-     reduces its space requirements to a constant whenever all its
-     values are the same, is appropriate.  A
-     &lt;type&gt;ConstantFunction&lt;/type&gt; &engine; returns the same value for
-     all indices.&lt;/para&gt;
- 
-     &lt;para&gt;Even though every &array; container has an engine to store
-     its values and permit access to individual values, an &array; is
-     conceptually separated from engines.  An engine's role is
-     low-level, storing values and permitting access to individual
-     values.  As we indicated above, the storage can be optimized to
-     fit specific situations such as few nonzero values and computing
-     values using a function applied to another engine's values.  An
-     &array;'s role is high-level, supporting access to groups of
-     values.  They handle memory allocation and deallocation.  &array;s
-     can be used in data-parallel expressions, e.g., adding all the
-     values in one &array; to all the values in another.  (See &lt;xref
-     linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt; for more information.)  Subsets of
-     &array; values, frequently used in data-parallel statements, can
-     be obtained.  (See &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt; for more
-     information.)  Even though engines and &array;s are conceptually
-     separate, higher-level &array;s provide access to lower-level
-     &engine;s.  Users usually have an &array; create its &engine;,
-     rarely explicitly creating &engine;s themselves.  Also, &array;s
-     provide access to individual values.  In short, &pooma; users use
-     &array;s, only dealing with how they are implemented (engines)
-     upon declaration.  For more description of &engine;s, see &lt;xref
-     linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
- 
-     &lt;para&gt;An &array;'s one constructor argument is its domain.  The
-     domain specifies its extent and simultaneously how many values it
-     can return.  All the provided &domain; objects are combined to
-     yield an &lt;type&gt;Interval&lt;&dim;&gt;&lt;/type&gt;, where &dim; matches
-     the &array;'s first template parameter.  Since an &interval;
-     domain with its unit strides is used, there are no unaccessed
-     &lt;quote&gt;gaps&lt;/quote&gt; within the domain, wasting storage space.  To
-     use other domains to access an &array;, first create it using an
-     &interval; domain and then take a view of it, as described in
-     &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.  As we mentioned above, the current
-     &pooma; code supports up to seven dimensions so at most seven
-     &domain; objects can be provided.  If more dimensions are
-     required, the &pooma; code can be extended to the desired number
-     of dimensions.&lt;/para&gt;
- 
-     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_use-table&quot;&gt;
-      &lt;title&gt;Declaring &array;s&lt;/title&gt;
-      
-      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-       &lt;thead&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&array; declaration&lt;/entry&gt;
- 	&lt;entry&gt;result&lt;/entry&gt;
-        &lt;/row&gt;
-       &lt;/thead&gt;
-       &lt;tfoot&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;Template parameters &lt;varname&gt;&dim;&lt;/varname&gt;,
- 	 &lt;varname&gt;T&lt;/varname&gt;, and &lt;varname&gt;E&lt;/varname&gt; indicates the
- 	 &array;'s dimension, value type, and &engine; type,
- 	 respectively, as do &lt;varname&gt;D1&lt;/varname&gt;,
- 	 &lt;varname&gt;T1&lt;/varname&gt;, and &lt;varname&gt;E1&lt;/varname&gt;.
- 	 &lt;varname&gt;DT1&lt;/varname&gt;, &hellip;, &lt;varname&gt;DT7&lt;/varname&gt;
- 	 indicate domain types.&lt;/entry&gt;
-        &lt;/row&gt;
-       &lt;/tfoot&gt;
-       &lt;tbody&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;()&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates an empty, uninitialized &array;, which must be
- 	&lt;function&gt;initialize&lt;/function&gt;()d before use.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;!-- Omit Indirection Array because src/Engine/IndirectionEngine.h indicates it is not yet finished. --&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const Array&lt;D1,T1,E1&gt;&amp; a)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates an &array; by copying another one.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const
- 	Array&lt;D1,T1,E1&gt;&amp; a, const Dom&amp; d)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates an &array; by copying another one but using the
- 	specified domain.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates an &array; using the given &domain; object.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5, const DT6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5, const DT6&amp; t6, const DT7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1,
- 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates an &array; using the given &domain; object and
- 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2,
- 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects and
- 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
- 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects and
- 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
- 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects and
- 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5,
- 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects and
- 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5, const DT6&amp; t6,
- 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects and
- 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5, const DT6&amp; t6, const DT7&amp; t7,
- 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;creates a &array; using the given &domain; objects and
- 	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
-        &lt;/row&gt;
-       &lt;/tbody&gt;
-      &lt;/tgroup&gt;
-     &lt;/table&gt;
- 
-     &lt;para&gt;&array; constructors are listed in &lt;xref
-     linkend=&quot;arrays-arrays_use-table&quot;&gt;&lt;/xref&gt;.  An &array;s' three
-     template parameters for dimensionality, value type, and engine
-     type are abbreviated &lt;varname&gt;D&lt;/varname&gt;, &lt;varname&gt;T&lt;/varname&gt;,
-     and &lt;varname&gt;E&lt;/varname&gt;.  &lt;varname&gt;D1&lt;/varname&gt;,
-     &lt;varname&gt;T1&lt;/varname&gt;, and &lt;varname&gt;E1&lt;/varname&gt; are analogous.
-     Template parameters for &domain; types 
- 
- HERE&lt;/para&gt;
- 
-     &lt;para&gt;list ?all? possible declarations
-       perhaps this involves copying all possible domain declarations
- 
-     table of &lt;function&gt;initialize&lt;/function&gt;() versions
- 
-     use: (element-wise only for now)
-     how to assign and access particular elements
-     use a single set of parentheses, not multiple brackets
- 
-     semantics of copies and references
-       based on engines
- 
- HERE&lt;/para&gt;
-    &lt;/section&gt;
- 
- 
-    &lt;section id=&quot;arrays-doof2d&quot;&gt;
-     &lt;title&gt;An &array; Implementation of &amp;doof2d;&lt;/title&gt;
- 
-     &lt;para&gt;mostly copy pp.35-38 from tutorial chapter
- HERE&lt;/para&gt;
-    &lt;/section&gt;
- 
- 
-    &lt;section id=&quot;arrays-implementation&quot;&gt;
-     &lt;title&gt;Implementing &array;s&lt;/title&gt;
- 
-     &lt;para&gt;What to write?
- 
-     Do I need to describe the public interface of Domains?  Do I need
-     to describe how a programmer would implement a new type of domain?
-     Probably not.
- 
- HERE&lt;/para&gt;
-    &lt;/section&gt;
- 
- &lt;!-- HERE --&gt;
- 
-   &lt;/chapter&gt;
- 
- 
    &lt;chapter id=&quot;engines&quot;&gt;
     &lt;title&gt;Engines&lt;/title&gt;
  
!    &lt;para&gt;
! HERE&lt;/para&gt;
    &lt;/chapter&gt;
  
    &amp;data-parallel-chapter;
  
  
--- 350,365 ----
    &amp;tutorial-chapter;
  
    &amp;concepts-chapter;
  
!   &amp;arrays-chapter;
  
    &lt;chapter id=&quot;engines&quot;&gt;
     &lt;title&gt;Engines&lt;/title&gt;
  
!    &lt;para&gt;UNFINISHED&lt;/para&gt;
    &lt;/chapter&gt;
  
+ 
    &amp;data-parallel-chapter;
  
  
*************** HERE&lt;/para&gt;
*** 1584,1590 ****
  
     &lt;para&gt;Be sure to list the various arithmetic operations on domains
     that can be used.  This was deferred from the &array; and domain
!    chapter.&lt;/para&gt;
  
  &lt;!-- FIXME: Finish this chapter. --&gt;
    &lt;/chapter&gt;
--- 368,374 ----
  
     &lt;para&gt;Be sure to list the various arithmetic operations on domains
     that can be used.  This was deferred from the &array; and domain
!    chapter.  Explain &array;'s &lt;function&gt;comp&lt;/function&gt; function.&lt;/para&gt;
  
  &lt;!-- FIXME: Finish this chapter. --&gt;
    &lt;/chapter&gt;
*************** HERE&lt;/para&gt;
*** 1592,1605 ****
    &lt;chapter id=&quot;sequential&quot;&gt;
     &lt;title&gt;Writing Sequential Programs&lt;/title&gt;
  
!    &lt;para&gt;FIXME: Explain the chapter's purpose.
! HERE&lt;/para&gt;
  
!    &lt;para&gt;FIXME: Explain the format of each section.
! HERE&lt;/para&gt;
  
!    &lt;para&gt;FIXME: Explain the order of the sections.
! HERE&lt;/para&gt;
  
     &lt;para&gt;Proposed order.  Basically follow the order in the proposed
     reference section.
--- 376,386 ----
    &lt;chapter id=&quot;sequential&quot;&gt;
     &lt;title&gt;Writing Sequential Programs&lt;/title&gt;
  
!    &lt;para&gt;FIXME: Explain the chapter's purpose.&lt;/para&gt;
  
!    &lt;para&gt;FIXME: Explain the format of each section.&lt;/para&gt;
  
!    &lt;para&gt;FIXME: Explain the order of the sections.&lt;/para&gt;
  
     &lt;para&gt;Proposed order.  Basically follow the order in the proposed
     reference section.
*************** HERE&lt;/para&gt;
*** 1772,1778 ****
      &lt;title&gt;Beginning and Ending &pooma; Programs&lt;/title&gt;
  
      &lt;para&gt;Every &pooma; program must begin with a call to
!     &lt;function&gt;initialize&lt;/function&gt; and end with a call to
      &lt;function&gt;finalize&lt;/function&gt;.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.&lt;/para&gt;
  
--- 553,559 ----
      &lt;title&gt;Beginning and Ending &pooma; Programs&lt;/title&gt;
  
      &lt;para&gt;Every &pooma; program must begin with a call to
!     &lt;methodname&gt;initialize&lt;/methodname&gt; and end with a call to
      &lt;function&gt;finalize&lt;/function&gt;.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.&lt;/para&gt;
  
*************** HERE&lt;/para&gt;
*** 1822,1828 ****
      &lt;bridgehead id=&quot;sequential-begin_end-description&quot; renderas=&quot;sect2&quot;&gt;Description&lt;/bridgehead&gt;
  
       &lt;para&gt;Before its use, the &poomatoolkit; must be initialized by a
!      call to &lt;function&gt;initialize&lt;/function&gt;.  This usually occurs in
       the &lt;function&gt;main&lt;/function&gt; function.  The first form removes
       and processes any &pooma;-specific arguments from the
       command-line arguments &lt;varname&gt;argv&lt;/varname&gt; and
--- 603,609 ----
      &lt;bridgehead id=&quot;sequential-begin_end-description&quot; renderas=&quot;sect2&quot;&gt;Description&lt;/bridgehead&gt;
  
       &lt;para&gt;Before its use, the &poomatoolkit; must be initialized by a
!      call to &lt;methodname&gt;initialize&lt;/methodname&gt;.  This usually occurs in
       the &lt;function&gt;main&lt;/function&gt; function.  The first form removes
       and processes any &pooma;-specific arguments from the
       command-line arguments &lt;varname&gt;argv&lt;/varname&gt; and
*************** HERE&lt;/para&gt;
*** 1844,1850 ****
       architecture-specific initialization.  The function always
       returns &true;.&lt;/para&gt;
  
!      &lt;para&gt;&lt;function&gt;initialize&lt;/function&gt;'s alternative form
       assumes the &pooma;-specific and architecture-specific
       command-line arguments have already been removed from
       &lt;varname&gt;argv&lt;/varname&gt; and &lt;varname&gt;argc&lt;/varname&gt; and stored in
--- 625,631 ----
       architecture-specific initialization.  The function always
       returns &true;.&lt;/para&gt;
  
!      &lt;para&gt;&lt;methodname&gt;initialize&lt;/methodname&gt;'s alternative form
       assumes the &pooma;-specific and architecture-specific
       command-line arguments have already been removed from
       &lt;varname&gt;argv&lt;/varname&gt; and &lt;varname&gt;argc&lt;/varname&gt; and stored in
*************** HERE&lt;/para&gt;
*** 1872,1878 ****
      &lt;bridgehead id=&quot;sequential-begin_end-example&quot; renderas=&quot;sect2&quot;&gt;Example Program&lt;/bridgehead&gt;
  
       &lt;para&gt;Since every &pooma; program must call
!      &lt;function&gt;initialize&lt;/function&gt; and
       &lt;function&gt;finalize&lt;/function&gt;, the simplest &pooma; program also
       must call them.  This program also illustrates their usual
       use.&lt;/para&gt;
--- 653,659 ----
      &lt;bridgehead id=&quot;sequential-begin_end-example&quot; renderas=&quot;sect2&quot;&gt;Example Program&lt;/bridgehead&gt;
  
       &lt;para&gt;Since every &pooma; program must call
!      &lt;methodname&gt;initialize&lt;/methodname&gt; and
       &lt;function&gt;finalize&lt;/function&gt;, the simplest &pooma; program also
       must call them.  This program also illustrates their usual
       use.&lt;/para&gt;
*************** HERE&lt;/para&gt;
*** 1908,1914 ****
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&inform; &lt;varname&gt;pwarn&lt;/varname&gt;&lt;/entry&gt;
! 	&lt;entry&gt;HERE output stream used to print informative messages to the
  	user while the program executes.  The stream accepts a
  	superset of standard output operations.&lt;/entry&gt;
         &lt;/row&gt;
--- 689,695 ----
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&inform; &lt;varname&gt;pwarn&lt;/varname&gt;&lt;/entry&gt;
! 	&lt;entry&gt;FIXME: output stream used to print informative messages to the
  	user while the program executes.  The stream accepts a
  	superset of standard output operations.&lt;/entry&gt;
         &lt;/row&gt;
*************** HERE&lt;/para&gt;
*** 1918,1925 ****
  
     &lt;/section&gt;
  
- &lt;!-- HERE --&gt;
- 
     &lt;section id=&quot;sequential-options&quot;&gt;
      &lt;title&gt;&pooma; Command-line Options&lt;/title&gt;
  
--- 699,704 ----
*************** UNFINISHED&lt;/para&gt;
*** 1944,1961 ****
  	executes.&lt;/para&gt;
         &lt;/listitem&gt;
        &lt;/varlistentry&gt;
! &lt;!-- HERE --&gt;
       &lt;/variablelist&gt;
  
       &lt;para&gt;FIXME: Be sure to list default values.&lt;/para&gt;
! &lt;!-- HERE: need to describe the pinfo, pwarn, and perr streams somewhere.  To do so requires describing informs.--&gt;
! &lt;!-- HERE: Which streams are buffered and which are not? --&gt;
  
- &lt;!-- HERE --&gt;
- 
      &lt;/section&gt;
- 
- &lt;!-- HERE --&gt;
  
     &lt;/section&gt;&lt;!-- end sequential-options --&gt;
  
--- 723,736 ----
  	executes.&lt;/para&gt;
         &lt;/listitem&gt;
        &lt;/varlistentry&gt;
! &lt;!-- UNFINISHED --&gt;
       &lt;/variablelist&gt;
  
       &lt;para&gt;FIXME: Be sure to list default values.&lt;/para&gt;
! &lt;!-- FIXME: need to describe the pinfo, pwarn, and perr streams somewhere.  To do so requires describing informs.--&gt;
! &lt;!-- FIXME: Which streams are buffered and which are not? --&gt;
  
      &lt;/section&gt;
  
     &lt;/section&gt;&lt;!-- end sequential-options --&gt;

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000883.html">Patch: Remove Non-Existent 'Index' From Comments
</A></li>
	<LI>Next message: <A HREF="000886.html">Manual Patch: DynamicArrays and Part of Engines
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#885">[ date ]</a>
              <a href="thread.html#885">[ thread ]</a>
              <a href="subject.html#885">[ subject ]</a>
              <a href="author.html#885">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
