<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Manual Patch: DynamicArrays and Part of Engines
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%20Patch%3A%20DynamicArrays%20and%20Part%20of%20Engines&In-Reply-To=%3C20020122075542.A32076%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000885.html">
   <LINK REL="Next"  HREF="000887.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Manual Patch: DynamicArrays and Part of Engines</H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%20Patch%3A%20DynamicArrays%20and%20Part%20of%20Engines&In-Reply-To=%3C20020122075542.A32076%40codesourcery.com%3E"
       TITLE="Manual Patch: DynamicArrays and Part of Engines">oldham at codesourcery.com
       </A><BR>
    <I>Tue Jan 22 15:55:42 UTC 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="000885.html">Pooma Manual: Array and Domain Chapter
</A></li>
        <LI>Next message: <A HREF="000887.html">Manual: Wordsmithing Changes to First Four Chapters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#886">[ date ]</a>
              <a href="thread.html#886">[ thread ]</a>
              <a href="subject.html#886">[ subject ]</a>
              <a href="author.html#886">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch mainly adds a description of DynamicArrays, an unfinished
section on simple Domain accessors, and an unfinished chapter on
Engines.  (Mark, I was working on the Engines chapter, but the Dynamic
Engine led me back to the Arrays chapter.  Sorry.)

2002-Jan-22  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

	* arrays.xml: Add (unfinished) Domain use section, making Domain
	declarations section a subsection of 'Domains' section.  Add
	DynamicArray section.
	* concepts.xml: s/multi-dimensional/multidimensional/g
	* glossary.xml (function object): New definition.
	s/multi-dimensional/multidimensional/g
	* manual.xml: Add unfinished Engines chapter, explaining the
	concepts, a table of Engines, and descriptions of Brick and
	CompressibleBrick.
	s/&lt;methodname&gt;initialize&lt;/methodname&gt;/&lt;function&gt;initialize&lt;/function&gt;/
	as appropriate.
	* tutorial.xml: s/multi-dimensional/multidimensional/g

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.1
diff -c -p -r1.1 arrays.xml
*** arrays.xml	2002/01/16 00:50:27	1.1
--- arrays.xml	2002/01/22 15:37:14
***************
*** 233,968 ****
      scientific computations use one, two, or three dimensions, this is
      usually sufficient.  If more dimensions are needed, they can be
      added to the source code.&lt;/para&gt;
-    &lt;/section&gt;
- 
  
-    &lt;section id=&quot;arrays-domains_declarations&quot;&gt;
-     &lt;title&gt;Declaring &domain;s&lt;/title&gt;
  
!     &lt;para&gt;Since &domain;s are mainly used to declare container
!     domains, we focus on declaring &domain;s.  Arithmetic operations
!     with &domain;s are described in &lt;xref
!     linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
! 
!     &lt;para&gt;All &domain; declarations require a dimension template
!     parameter&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  This positive integer
!     specifies the number of dimensions, i.e., rank, of the &domain; and
!     determines the length of the tuples for points in the &domain;.  For
!     example, a three-dimensional &domain; contains ordered triples,
!     while a one-dimensional &domain; contains singletons, or just
!     integers.  Multidimensional &domain;s are just the direct products
!     of one-dimensional &domain;s so the techniques for declaring
!     one-dimensional &domain;s carry over to multi-dimensional
!     ones.&lt;/para&gt;
! 
!     &lt;para&gt;To declare a &domain;, one must include the
!     &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; header
!     file.  However, most &pooma; programs declare &domain;s to use them
!     when constructing containers.  The container header files
!     automatically include &lt;filename
!     class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; so no explicit
!     inclusion is usually necessary.&lt;/para&gt;
! 
!     &lt;section id=&quot;arrays-domains_declarations-loc&quot;&gt;
!      &lt;title&gt;&loc;s&lt;/title&gt;
! 
!      &lt;para&gt;A &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt; is a &domain; with just a single
!      &lt;varname&gt;&dim;&lt;/varname&gt;-dimensional point.  Although it is
!      infrequently used as a container's domain, it is used to refer to
!      a single point within another domain.  Its beginning and ending
!      points are the same, and its stride is one.  One-dimensional
!      &loc;s and integers are frequently interchanged.&lt;/para&gt;
  
!      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-loc-one_d_table&quot;&gt;
!       &lt;title&gt;Declaring One-Dimensional &loc;s&lt;/title&gt;
!      
!       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!        &lt;thead&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;constructor&lt;/entry&gt;
! 	 &lt;entry&gt;result&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/thead&gt;
!        &lt;tfoot&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
! 	 &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
! 	 &lt;entry&gt;&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tfoot&gt;
!        &lt;tbody&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;points to zero.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an uninitialized &locone;, to be assigned a value later.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &locone; with the integer converted from &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &locone; with the integer converted from
! 	 &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
! 	 &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &locone; with the integer converted from
! 	 &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
! 	 &lt;varname&gt;t1&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt; is
! 	 ignored.&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tbody&gt;
!       &lt;/tgroup&gt;
!      &lt;/table&gt;
! 
!      &lt;para&gt;Constructors for one-dimensional &loc;s appear in &lt;xref
!      linkend=&quot;arrays-domains_declarations-loc-one_d_table&quot;&gt;&lt;/xref&gt;.
!      The empty constructor yields the zero point.  The constructor
!      taking a &lt;type&gt;Pooma::Init&lt;/type&gt; object does not initialize the
!      resulting &loc; to any particular value.  Presumably, the value
!      will be assigned later.  For small &domain;s such as &loc;s, the
!      time savings from not initializing is small, but the
!      functionality is still available.  The constructor taking one
!      argument with type&nbsp;&lt;type&gt;&domaintemplate;1&lt;/type&gt; converts this argument to
!      an integer to specify the point.  The template
!      type&nbsp;&lt;type&gt;&domaintemplate;1&lt;/type&gt; may be any type that can be converted
!      to an integer, e.g., &bool;, &char;, &int;, or &double;.  The
!      constructors taking two and three arguments of templatized types
!      facilitate converting an &interval; and a &range; into a &loc;.
!      Since a &loc; represents a single point, the &interval;'s or
!      &range;'s first two arguments must be equal.  The stride is
!      ignored.  Again, the templatized types may be any type that can
!      be converted into an integer.&lt;/para&gt;
! 
!      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-loc-multi_d_table&quot;&gt;
!       &lt;title&gt;Declaring Multidimensional &loc;s&lt;/title&gt;
!      
!       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!        &lt;thead&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;constructor&lt;/entry&gt;
! 	 &lt;entry&gt;result&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/thead&gt;
!        &lt;tfoot&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &loc;'s dimension.
! 	 &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are
! 	 template parameters.&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tfoot&gt;
!        &lt;tbody&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;points to zero.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an uninitialized &loc;, to be assigned a value later.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &loc; using the given &domain; object.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tbody&gt;
!       &lt;/tgroup&gt;
!      &lt;/table&gt;
! 
!      &lt;para&gt;Constructors for multidimensional &loc;s appear in &lt;xref
!      linkend=&quot;arrays-domains_declarations-loc-multi_d_table&quot;&gt;&lt;/xref&gt;.
!      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &loc;'s dimension.  The
!      first two constructors are similar to &locone;'s first two
!      constructors, returning a representation of the zero point and
!      returning an uninitialized point.  The seven other constructors
!      create a &loc; using other &domain; objects.  These &domain; objects,
!      having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;, &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have
!      any type that can be converted into an integer, to a &locone;, or
!      to a multidimensional &domain; object that itself can be converted
!      into a &loc;.  The total dimensionality of all the arguments'
!      types should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  For example,
!      &lt;statement&gt;Loc&lt;5&gt;(Range&lt;1&gt;(2,2,2), Loc&lt;2&gt;(2,3),
!      Interval&lt;1&gt;(4,4))&lt;/statement&gt; creates a five-dimensional &loc;
!      [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
!      &loc;, and a one-dimensional &interval;.  The final fifth
!      dimension has an unspecified value, in this case&nbsp;1.  The
!      one-dimensional &range; is converted into the single integer two;
!      its beginning and ending points must be the same.  The
!      two-dimensional &loc; contributes values for the next two
!      dimensions, while the &interval; contributes its beginning point,
!      which must be the same as its ending point.  Note that the
!      &locone; constructors taking two and three parameters ignore
!      their second and third arguments, but this is not true for the
!      multidimensional constructors.&lt;/para&gt;
      &lt;/section&gt;
  
- 
-     &lt;section id=&quot;arrays-domains_declarations-intervals&quot;&gt;
-      &lt;title&gt;&interval;s&lt;/title&gt;
- 
-      &lt;para&gt;A one-dimensional &interval; represents a set of integers
-      within a mathematical &lt;glossterm
-      linkend=&quot;glossary-interval&quot;&gt;interval&lt;/glossterm&gt;.
-      Multidimensional &interval;s represent their multidimensional
-      generalization, i.e., the direct product of one-dimensional
-      intervals.  &interval;s are arguably the most commonly used
-      &pooma; &domain;.  A one-dimensional &interval; has integral
-      beginning and ending points and a unit stride.&lt;/para&gt;
  
!      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-interval-one_d_table&quot;&gt;
!       &lt;title&gt;Declaring One-Dimensional &interval;s&lt;/title&gt;
!      
!       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!        &lt;thead&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;constructor&lt;/entry&gt;
! 	 &lt;entry&gt;result&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/thead&gt;
!        &lt;tfoot&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
! 	 &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
! 	 &lt;entry&gt;&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tfoot&gt;
!        &lt;tbody&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an empty, uninitialized interval.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an uninitialized &intervalone;, to be assigned a value later.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &intervalone;.  See the text for an explanation.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &intervalone; with the integers converted from
! 	 &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &intervalone; with the integers converted from
! 	 &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.
! 	 &lt;varname&gt;t3&lt;/varname&gt; must equal&nbsp;1.&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tbody&gt;
!       &lt;/tgroup&gt;
!      &lt;/table&gt;
! 
!      &lt;para&gt;&intervalone; constructors are patterned on &locone;
!      constructors except that &intervalone;s can have differing
!      beginning and ending points.  See &lt;xref
!      linkend=&quot;arrays-domains_declarations-interval-one_d_table&quot;&gt;&lt;/xref&gt;.
!      The default constructor creates an empty, uninitialized interval,
!      which should not be used before assigning it values.  If the
!      one-parameter constructor's argument is a &domain; object, it must
!      be a one-dimensional &domain; object which is copied into an
!      &interval; if possible; for example, it must have unit stride.
!      If the one-parameter constructor's argument is not a &domain;
!      object, it must be convertible to an
!      integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and an interval [0:e-1:1]
!      starting at zero is constructed.  If two arguments are specified,
!      they are assumed to be convertible to integers
!      &lt;varname&gt;b&lt;/varname&gt; and &lt;varname&gt;e&lt;/varname&gt;, specifying the
!      interval [b:e:1].  The three-parameter constructor is similar,
!      with the third argument specifying a stride, which must be
!      one.&lt;/para&gt;
! 
!      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-intervals-multi_d_table&quot;&gt;
!       &lt;title&gt;Declaring Multidimensional &interval;s&lt;/title&gt;
!      
!       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!        &lt;thead&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;constructor&lt;/entry&gt;
! 	 &lt;entry&gt;result&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/thead&gt;
!        &lt;tfoot&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &interval;'s dimension.
! 	 &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are
! 	 template parameters.&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tfoot&gt;
!        &lt;tbody&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &interval; using the given &domain; object.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tbody&gt;
!       &lt;/tgroup&gt;
!      &lt;/table&gt;
! 
!      &lt;para&gt;Constructors for multidimensional &interval;s closely
!      follow constructors for multidimensional &loc;s.  See &lt;xref
!      linkend=&quot;arrays-domains_declarations-intervals-multi_d_table&quot;&gt;&lt;/xref&gt;.
!      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &interval;'s
!      dimension.  The first two constructors both return empty,
!      uninitialized intervals.  The seven other constructors create an
!      &interval; using &domain; objects.  These &domain; objects,
!      having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
!      &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
!      converted into an integer, into a single-dimensional &domain;
!      object that can be converted into a single-dimensional
!      &interval;, or to a multidimensional &domain; object that itself
!      can be converted into an &interval;.  The total dimensionality of
!      all the arguments' types should be at
!      most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional &domain;
!      objects that can be converted into one-dimensional &interval;s
!      include &locone;s, &intervalone;s, and &rangeone;s with unit
!      strides.  If the sum of the objects' dimensions is less
!      than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the intervals for the final
!      dimensions are unspecified.  See the last paragraph of &lt;xref
!      linkend=&quot;arrays-domains_declarations-loc&quot;&gt;&lt;/xref&gt; for an
!      analogous example.  Note that the &intervalone; constructors
!      taking two and three parameters treat these arguments differently
!      than the multidimensional constructors do.&lt;/para&gt;
!     &lt;/section&gt;
! 
! 
!     &lt;section id=&quot;arrays-domains_declarations-ranges&quot;&gt;
!      &lt;title&gt;&range;s&lt;/title&gt;
! 
!      &lt;para&gt;A one-dimensional &range; generalizes an &interval; by
!      permitting a non-unit stride between integral members.  A
!      &lt;glossterm
!      linkend=&quot;glossary-range&quot;&gt;&lt;firstterm&gt;range&lt;/firstterm&gt;&lt;/glossterm&gt;
!      is a set of integers in a mathematical interval [b,e] with a
!      stride&nbsp;s between them: {a, a+s, a+2s, &hellip;, b}.  Ranges
!      are generalized to &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;dimensions using the
!      direct product of one-dimensional ranges.&lt;/para&gt;
! 
!      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-range-one_d_table&quot;&gt;
!       &lt;title&gt;Declaring One-Dimensional &range;s&lt;/title&gt;
!      
!       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!        &lt;thead&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;constructor&lt;/entry&gt;
! 	 &lt;entry&gt;result&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/thead&gt;
!        &lt;tfoot&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
! 	 &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
! 	 &lt;entry&gt;&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tfoot&gt;
!        &lt;tbody&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an empty, uninitialized range.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an uninitialized &rangeone;, to be assigned a value later.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &rangeone;.  See the text for an explanation.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &rangeone; with an interval specified by the
! 	 integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
! 	 &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &rangeone; by converting the arguments to
! 	 integers &lt;varname&gt;i1&lt;/varname&gt;, &lt;varname&gt;i2&lt;/varname&gt;, and
! 	 &lt;varname&gt;i3&lt;/varname&gt; and then making a range [i1:i2:i3].&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tbody&gt;
!       &lt;/tgroup&gt;
!      &lt;/table&gt;
  
!      &lt;para&gt;&rangeone; constructors are the same as &intervalone;
!      constructors except they create ranges, not intervals.  See &lt;xref
!      linkend=&quot;arrays-domains_declarations-range-one_d_table&quot;&gt;&lt;/xref&gt;.
!      The default constructor creates an empty, uninitialized range,
!      which should not be used before assigning it values.  If the
!      one-parameter constructor's argument is a &domain; object, it must
!      be a one-dimensional &domain; object which is copied into a &range;
!      if possible.  If the one-parameter constructor's argument is not
!      a &domain; object, it must be convertible to an
!      integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and a range [0:e-1:1] starting
!      at zero is constructed.  If two arguments are specified, they are
!      assumed to be convertible to integers &lt;varname&gt;b&lt;/varname&gt; and
!      &lt;varname&gt;e&lt;/varname&gt;, specifying the range [b:e:1].  The
!      three-parameter constructor is similar, with the third argument
!      specifying a stride.&lt;/para&gt;
  
       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-ranges-multi_d_table&quot;&gt;
!       &lt;title&gt;Declaring Multidimensional &range;s&lt;/title&gt;
       
        &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
         &lt;thead&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;constructor&lt;/entry&gt;
  	 &lt;entry&gt;result&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
         &lt;tfoot&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &range;'s dimension.
! 	 &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are
! 	 template parameters.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tfoot&gt;
         &lt;tbody&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &range; using the given &domain; object.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	&lt;/row&gt;
-        &lt;/tbody&gt;
-       &lt;/tgroup&gt;
-      &lt;/table&gt;
- 
-      &lt;para&gt;Constructors for multidimensional &range;s are the same as
-      multidimensional &interval; constructors except they create
-      ranges, not intervals.  See &lt;xref
-      linkend=&quot;arrays-domains_declarations-ranges-multi_d_table&quot;&gt;&lt;/xref&gt;.
-      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &range;'s dimension.  The
-      first two constructors return empty, uninitialized ranges.
-      The seven other constructors create an &range; using &domain;
-      objects.  These &domain; objects, having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;,
-      &hellip;, &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
-      converted into an integer, into a single-dimensional &domain;
-      object that can be converted into a single-dimensional &range;,
-      or to a multidimensional &domain; object that itself can be
-      converted into an &range;.  The total dimensionality of all the
-      arguments' types should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.
-      One-dimensional &domain; objects that can be converted into
-      one-dimensional &range;s include &locone;s, &intervalone;s, and
-      &rangeone;s.  If the sum of the objects' dimensions is less
-      than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the ranges for the final
-      dimensions are unspecified.  See the last paragraph of &lt;xref
-      linkend=&quot;arrays-domains_declarations-loc&quot;&gt;&lt;/xref&gt; for an
-      analogous example.  Note that the &rangeone; constructors taking
-      two and three parameters treat these arguments differently than
-      the multidimensional constructors do.&lt;/para&gt;
-     &lt;/section&gt;
- 
- 
-     &lt;section id=&quot;arrays-domains_declarations-grids&quot;&gt;
-      &lt;title&gt;&grid;s&lt;/title&gt;
- 
-      &lt;para&gt;&loc;s, &interval;s, and &range;s all have regularly spaced
-      integral values so they can be represented using &lt;glossterm
-      linkend=&quot;glossary-domain_triplet&quot;&gt;domain triplets&lt;/glossterm&gt;.
-      One-dimensional &grid; integral domains contain ascending or
-      descending sequences of integers, with no fixed stride.  For
-      example, a &gridone; may represent {-13, 1, 4, 5, 34}.  &gridone;
-      is generalized to multidimensional &grid;s using the direct
-      product of &gridone; &domain;s.&lt;/para&gt;
- 
-      &lt;para&gt;&grid;s that can be represented using domain triplets can
-      be constructed using techniques similar to other &domain;s, but
-      irregularly spaced domains can be constructed using
-      &indirectionlistint;s.&lt;/para&gt;
- 
-      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-grid-one_d_table&quot;&gt;
-       &lt;title&gt;Declaring One-Dimensional &grid;s&lt;/title&gt;
-      
-       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-        &lt;thead&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;constructor&lt;/entry&gt;
! 	 &lt;entry&gt;result&lt;/entry&gt;
  	&lt;/row&gt;
-        &lt;/thead&gt;
-        &lt;tfoot&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
! 	 &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
! 	 &lt;entry&gt;&lt;/entry&gt;
  	&lt;/row&gt;
-        &lt;/tfoot&gt;
-        &lt;tbody&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates an empty, uninitialized grid.&lt;/entry&gt;
- 	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &gridone;.  See the text for an explanation.&lt;/entry&gt;
- 	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &gridone; from the interval specified by the
! 	 integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
! 	 &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
  	&lt;/row&gt;
- 	&lt;row&gt;
- 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
- 	 &lt;entry&gt;creates a &gridone; from the domain triplet specified
- 	 by the integers converted from &lt;varname&gt;t1&lt;/varname&gt;,
- 	 &lt;varname&gt;t2&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt;.&lt;/entry&gt;
- 	&lt;/row&gt;
         &lt;/tbody&gt;
        &lt;/tgroup&gt;
       &lt;/table&gt;
  
!      &lt;para&gt;To construct a &gridone; that can also be represented by a
!      domain triplet, use a &gridone; constructor similar to those for
!      &intervalone; and &rangeone;.  See &lt;xref
!      linkend=&quot;arrays-domains_declarations-grid-one_d_table&quot;&gt;&lt;/xref&gt;
!      and the text explanations following &lt;xref
!      linkend=&quot;arrays-domains_declarations-range-one_d_table&quot;&gt;&lt;/xref&gt;
!      or &lt;xref
!      linkend=&quot;arrays-domains_declarations-interval-one_d_table&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
!      &lt;para&gt;&gridone;s with irregularly spaced points can be
!      constructed using &indirectionlistint;s.  For example,
! &lt;programlisting&gt;
! IndirectionList&lt;int&gt; list(4);
! list(0) = 2;
! list(1) = 5;
! list(2) = 6;
! list(3) = 9;
! Grid&lt;1&gt; g(list);
! &lt;/programlisting&gt; constructs an empty &indirectionlistint;, fills it
!      with ascending values, and then creates a &gridone; containing
!      {2, 5, 6, 9}.  When creating a list, its size must be specified.
!      Subsequently, its values can be assigned.  &indirectionlist;s can
!      also be initialized using one-dimensional &array;s:
! &lt;programlisting&gt;
! Array&lt;1,int,Brick&gt; a1(Interval&lt;1&gt;(0,3));
! a1(0) = 2; a1(1) = 5; a1(2) = 6; a1(3) = 9;
! IndirectionList&lt;int&gt; il(a1);
! Grid&lt;1&gt; g1(il);
! &lt;/programlisting&gt;  The &array; stores the integral points to include
!      in the &gridone; and is used to create the &indirectionlistint;,
!      which itself is used to create the &gridone;.  Since the points
!      are integers, the &array;'s type is &int;.  Either a &brick; or
!      &compressiblebrick; &engine; should be used.&lt;/para&gt;
! 
!      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains_declarations-grids-multi_d_table&quot;&gt;
!       &lt;title&gt;Declaring Multidimensional &grid;s&lt;/title&gt;
!      
!       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!        &lt;thead&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;constructor&lt;/entry&gt;
! 	 &lt;entry&gt;result&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/thead&gt;
!        &lt;tfoot&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &grid;'s
! 	 dimension.  &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;,
! 	 &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are template
! 	 parameters.&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tfoot&gt;
!        &lt;tbody&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates an empty, uninitialized &grid;, to be assigned a value later.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &grid; using the given &domain; object.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tbody&gt;
!       &lt;/tgroup&gt;
!      &lt;/table&gt;
! 
!      &lt;para&gt;Constructors for multidimensional &grid;s are the same as
!      multidimensional &interval; constructors except they create
!      &grid;s, not intervals.  See &lt;xref
!      linkend=&quot;arrays-domains_declarations-grids-multi_d_table&quot;&gt;&lt;/xref&gt;.
!      &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &grid;'s dimension.  The
!      first constructor returns empty, uninitialized grids.  The seven
!      other constructors create an &grid; using &domain; objects.  These
!      &domain; objects, having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
!      &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be converted into an
!      integer, into a single-dimensional &domain; object that can be
!      converted into a single-dimensional &grid;, or to a
!      multidimensional &domain; object that itself can be converted into
!      an &grid;.  The total dimensionality of all the arguments' types
!      should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional
!      &domain; objects that can be converted into one-dimensional &grid;s
!      include &locone;s, &intervalone;s, &rangeone;s, and &gridone;s.
!      If the sum of the objects' dimensions is less
!      than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the grids for the final
!      dimensions are unspecified.  See the last paragraph of &lt;xref
!      linkend=&quot;arrays-domains_declarations-loc&quot;&gt;&lt;/xref&gt; for an
!      analogous example.  Note that the &gridone; constructors taking
!      two and three parameters treat these arguments differently than
!      the multidimensional constructors do.&lt;/para&gt;
!     &lt;/section&gt;
     &lt;/section&gt;
  
  
     &lt;section id=&quot;arrays-arrays_declarations&quot;&gt;
      &lt;title&gt;Declaring &array;s&lt;/title&gt;
  
      &lt;para&gt;A &pooma; &array; maps indices from its &domain; to values.
!     In this section, we describe first describe how to declare
!     &array;s.  In the next section, we explain how to access
!     individual values stored within an &array; and &array; copy
!     semantics.&lt;/para&gt;
  
      &lt;para&gt;&array; values need not just be stored values, as &c; arrays
      have.  They can also be computed using its engine.  We defer
--- 233,1063 ----
      scientific computations use one, two, or three dimensions, this is
      usually sufficient.  If more dimensions are needed, they can be
      added to the source code.&lt;/para&gt;
  
  
!     &lt;section id=&quot;arrays-domains-declarations&quot;&gt;
!      &lt;title&gt;Declaring &domain;s&lt;/title&gt;
  
!      &lt;para&gt;Since &domain;s are mainly used to declare container
!      domains, we focus on declaring &domain;s.  We describe a few
!      &domain; operations but most, including arithmetic operations with
!      &domain;s, are described in &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
! 
!      &lt;para&gt;All &domain; declarations require a dimension template
!      parameter&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  This positive integer
!      specifies the number of dimensions, i.e., rank, of the &domain; and
!      determines the length of the tuples for points in the &domain;.  For
!      example, a three-dimensional &domain; contains ordered triples,
!      while a one-dimensional &domain; contains singletons, or just
!      integers.  Multidimensional &domain;s are just the direct products
!      of one-dimensional &domain;s so the techniques for declaring
!      one-dimensional &domain;s carry over to multidimensional
!      ones.&lt;/para&gt;
! 
!      &lt;para&gt;To declare a &domain;, one must include the
!      &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; header
!      file.  However, most &pooma; programs declare &domain;s to use them
!      when constructing containers.  The container header files
!      automatically include &lt;filename
!      class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; so no explicit
!      inclusion is usually necessary.&lt;/para&gt;
! 
! 
!      &lt;section id=&quot;arrays-domains-declarations-loc&quot;&gt;
!       &lt;title&gt;&loc;s&lt;/title&gt;
! 
!       &lt;para&gt;A &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt; is a &domain; with just a single
!       &lt;varname&gt;&dim;&lt;/varname&gt;-dimensional point.  Although it is
!       infrequently used as a container's domain, it is used to refer to
!       a single point within another domain.  Its beginning and ending
!       points are the same, and its stride is one.  One-dimensional
!       &loc;s and integers are frequently interchanged.&lt;/para&gt;
! 
!       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-loc-one_d_table&quot;&gt;
!        &lt;title&gt;Declaring One-Dimensional &loc;s&lt;/title&gt;
! 
!        &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
! 	&lt;thead&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;constructor&lt;/entry&gt;
! 	  &lt;entry&gt;result&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/thead&gt;
! 	&lt;tfoot&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
! 	  &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
! 	  &lt;entry&gt;&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;points to zero.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an uninitialized &locone;, to be assigned a value later.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &locone; with the integer converted from &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &locone; with the integer converted from
! 	  &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
! 	  &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &locone; with the integer converted from
! 	  &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
! 	  &lt;varname&gt;t1&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt; is
! 	  ignored.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tbody&gt;
!        &lt;/tgroup&gt;
!       &lt;/table&gt;
! 
!       &lt;para&gt;Constructors for one-dimensional &loc;s appear in &lt;xref
!       linkend=&quot;arrays-domains-declarations-loc-one_d_table&quot;&gt;&lt;/xref&gt;.
!       The empty constructor yields the zero point.  The constructor
!       taking a &lt;type&gt;Pooma::Init&lt;/type&gt; object does not initialize the
!       resulting &loc; to any particular value.  Presumably, the value
!       will be assigned later.  For small &domain;s such as &loc;s, the
!       time savings from not initializing is small, but the
!       functionality is still available.  The constructor taking one
!       argument with type&nbsp;&lt;type&gt;&domaintemplate;1&lt;/type&gt; converts this argument to
!       an integer to specify the point.  The template
!       type&nbsp;&lt;type&gt;&domaintemplate;1&lt;/type&gt; may be any type that can be converted
!       to an integer, e.g., &bool;, &char;, &int;, or &double;.  The
!       constructors taking two and three arguments of templatized types
!       facilitate converting an &interval; and a &range; into a &loc;.
!       Since a &loc; represents a single point, the &interval;'s or
!       &range;'s first two arguments must be equal.  The stride is
!       ignored.  Again, the templatized types may be any type that can
!       be converted into an integer.&lt;/para&gt;
! 
!       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-loc-multi_d_table&quot;&gt;
!        &lt;title&gt;Declaring Multidimensional &loc;s&lt;/title&gt;
! 
!        &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
! 	&lt;thead&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;constructor&lt;/entry&gt;
! 	  &lt;entry&gt;result&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/thead&gt;
! 	&lt;tfoot&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &loc;'s dimension.
! 	  &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are
! 	  template parameters.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;points to zero.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an uninitialized &loc;, to be assigned a value later.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &loc; using the given &domain; object.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tbody&gt;
!        &lt;/tgroup&gt;
!       &lt;/table&gt;
! 
!       &lt;para&gt;Constructors for multidimensional &loc;s appear in &lt;xref
!       linkend=&quot;arrays-domains-declarations-loc-multi_d_table&quot;&gt;&lt;/xref&gt;.
!       &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &loc;'s dimension.  The
!       first two constructors are similar to &locone;'s first two
!       constructors, returning a representation of the zero point and
!       returning an uninitialized point.  The seven other constructors
!       create a &loc; using other &domain; objects.  These &domain; objects,
!       having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;, &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have
!       any type that can be converted into an integer, to a &locone;, or
!       to a multidimensional &domain; object that itself can be converted
!       into a &loc;.  The total dimensionality of all the arguments'
!       types should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  For example,
!       &lt;statement&gt;Loc&lt;5&gt;(Range&lt;1&gt;(2,2,2), Loc&lt;2&gt;(2,3),
!       Interval&lt;1&gt;(4,4))&lt;/statement&gt; creates a five-dimensional &loc;
!       [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
!       &loc;, and a one-dimensional &interval;.  The final fifth
!       dimension has an unspecified value, in this case&nbsp;1.  The
!       one-dimensional &range; is converted into the single integer two;
!       its beginning and ending points must be the same.  The
!       two-dimensional &loc; contributes values for the next two
!       dimensions, while the &interval; contributes its beginning point,
!       which must be the same as its ending point.  Note that the
!       &locone; constructors taking two and three parameters ignore
!       their second and third arguments, but this is not true for the
!       multidimensional constructors.&lt;/para&gt;
!      &lt;/section&gt;
! 
! 
!      &lt;section id=&quot;arrays-domains-declarations-intervals&quot;&gt;
!       &lt;title&gt;&interval;s&lt;/title&gt;
! 
!       &lt;para&gt;A one-dimensional &interval; represents a set of integers
!       within a mathematical &lt;glossterm
!       linkend=&quot;glossary-interval&quot;&gt;interval&lt;/glossterm&gt;.
!       Multidimensional &interval;s represent their multidimensional
!       generalization, i.e., the direct product of one-dimensional
!       intervals.  &interval;s are arguably the most commonly used
!       &pooma; &domain;.  A one-dimensional &interval; has integral
!       beginning and ending points and a unit stride.&lt;/para&gt;
! 
!       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-interval-one_d_table&quot;&gt;
!        &lt;title&gt;Declaring One-Dimensional &interval;s&lt;/title&gt;
! 
!        &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
! 	&lt;thead&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;constructor&lt;/entry&gt;
! 	  &lt;entry&gt;result&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/thead&gt;
! 	&lt;tfoot&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
! 	  &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
! 	  &lt;entry&gt;&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an empty, uninitialized interval.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an uninitialized &intervalone;, to be assigned a value later.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &intervalone;.  See the text for an explanation.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &intervalone; with the integers converted from
! 	  &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &intervalone; with the integers converted from
! 	  &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.
! 	  &lt;varname&gt;t3&lt;/varname&gt; must equal&nbsp;1.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tbody&gt;
!        &lt;/tgroup&gt;
!       &lt;/table&gt;
! 
!       &lt;para&gt;&intervalone; constructors are patterned on &locone;
!       constructors except that &intervalone;s can have differing
!       beginning and ending points.  See &lt;xref
!       linkend=&quot;arrays-domains-declarations-interval-one_d_table&quot;&gt;&lt;/xref&gt;.
!       The default constructor creates an empty, uninitialized interval,
!       which should not be used before assigning it values.  If the
!       one-parameter constructor's argument is a &domain; object, it must
!       be a one-dimensional &domain; object which is copied into an
!       &interval; if possible; for example, it must have unit stride.
!       If the one-parameter constructor's argument is not a &domain;
!       object, it must be convertible to an
!       integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and an interval [0:e-1:1]
!       starting at zero is constructed.  If two arguments are specified,
!       they are assumed to be convertible to integers
!       &lt;varname&gt;b&lt;/varname&gt; and &lt;varname&gt;e&lt;/varname&gt;, specifying the
!       interval [b:e:1].  The three-parameter constructor is similar,
!       with the third argument specifying a stride, which must be
!       one.&lt;/para&gt;
! 
!       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-intervals-multi_d_table&quot;&gt;
!        &lt;title&gt;Declaring Multidimensional &interval;s&lt;/title&gt;
! 
!        &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
! 	&lt;thead&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;constructor&lt;/entry&gt;
! 	  &lt;entry&gt;result&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/thead&gt;
! 	&lt;tfoot&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &interval;'s dimension.
! 	  &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are
! 	  template parameters.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; object.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tbody&gt;
!        &lt;/tgroup&gt;
!       &lt;/table&gt;
! 
!       &lt;para&gt;Constructors for multidimensional &interval;s closely
!       follow constructors for multidimensional &loc;s.  See &lt;xref
!       linkend=&quot;arrays-domains-declarations-intervals-multi_d_table&quot;&gt;&lt;/xref&gt;.
!       &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &interval;'s
!       dimension.  The first two constructors both return empty,
!       uninitialized intervals.  The seven other constructors create an
!       &interval; using &domain; objects.  These &domain; objects,
!       having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
!       &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
!       converted into an integer, into a single-dimensional &domain;
!       object that can be converted into a single-dimensional
!       &interval;, or to a multidimensional &domain; object that itself
!       can be converted into an &interval;.  The total dimensionality of
!       all the arguments' types should be at
!       most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional &domain;
!       objects that can be converted into one-dimensional &interval;s
!       include &locone;s, &intervalone;s, and &rangeone;s with unit
!       strides.  If the sum of the objects' dimensions is less
!       than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the intervals for the final
!       dimensions are unspecified.  See the last paragraph of &lt;xref
!       linkend=&quot;arrays-domains-declarations-loc&quot;&gt;&lt;/xref&gt; for an
!       analogous example.  Note that the &intervalone; constructors
!       taking two and three parameters treat these arguments differently
!       than the multidimensional constructors do.&lt;/para&gt;
!      &lt;/section&gt;
! 
! 
!      &lt;section id=&quot;arrays-domains-declarations-ranges&quot;&gt;
!       &lt;title&gt;&range;s&lt;/title&gt;
! 
!       &lt;para&gt;A one-dimensional &range; generalizes an &interval; by
!       permitting a non-unit stride between integral members.  A
!       &lt;glossterm
!       linkend=&quot;glossary-range&quot;&gt;&lt;firstterm&gt;range&lt;/firstterm&gt;&lt;/glossterm&gt;
!       is a set of integers in a mathematical interval [b,e] with a
!       stride&nbsp;s between them: {a, a+s, a+2s, &hellip;, b}.  Ranges
!       are generalized to &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;dimensions using the
!       direct product of one-dimensional ranges.&lt;/para&gt;
! 
!       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-range-one_d_table&quot;&gt;
!        &lt;title&gt;Declaring One-Dimensional &range;s&lt;/title&gt;
! 
!        &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
! 	&lt;thead&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;constructor&lt;/entry&gt;
! 	  &lt;entry&gt;result&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/thead&gt;
! 	&lt;tfoot&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
! 	  &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
! 	  &lt;entry&gt;&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an empty, uninitialized range.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an uninitialized &rangeone;, to be assigned a value later.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &rangeone;.  See the text for an explanation.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &rangeone; with an interval specified by the
! 	  integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
! 	  &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &rangeone; by converting the arguments to
! 	  integers &lt;varname&gt;i1&lt;/varname&gt;, &lt;varname&gt;i2&lt;/varname&gt;, and
! 	  &lt;varname&gt;i3&lt;/varname&gt; and then making a range [i1:i2:i3].&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tbody&gt;
!        &lt;/tgroup&gt;
!       &lt;/table&gt;
! 
!       &lt;para&gt;&rangeone; constructors are the same as &intervalone;
!       constructors except they create ranges, not intervals.  See &lt;xref
!       linkend=&quot;arrays-domains-declarations-range-one_d_table&quot;&gt;&lt;/xref&gt;.
!       The default constructor creates an empty, uninitialized range,
!       which should not be used before assigning it values.  If the
!       one-parameter constructor's argument is a &domain; object, it must
!       be a one-dimensional &domain; object which is copied into a &range;
!       if possible.  If the one-parameter constructor's argument is not
!       a &domain; object, it must be convertible to an
!       integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and a range [0:e-1:1] starting
!       at zero is constructed.  If two arguments are specified, they are
!       assumed to be convertible to integers &lt;varname&gt;b&lt;/varname&gt; and
!       &lt;varname&gt;e&lt;/varname&gt;, specifying the range [b:e:1].  The
!       three-parameter constructor is similar, with the third argument
!       specifying a stride.&lt;/para&gt;
! 
!       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-ranges-multi_d_table&quot;&gt;
!        &lt;title&gt;Declaring Multidimensional &range;s&lt;/title&gt;
! 
!        &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
! 	&lt;thead&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;constructor&lt;/entry&gt;
! 	  &lt;entry&gt;result&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/thead&gt;
! 	&lt;tfoot&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &range;'s dimension.
! 	  &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are
! 	  template parameters.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &range; using the given &domain; object.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tbody&gt;
!        &lt;/tgroup&gt;
!       &lt;/table&gt;
! 
!       &lt;para&gt;Constructors for multidimensional &range;s are the same as
!       multidimensional &interval; constructors except they create
!       ranges, not intervals.  See &lt;xref
!       linkend=&quot;arrays-domains-declarations-ranges-multi_d_table&quot;&gt;&lt;/xref&gt;.
!       &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &range;'s dimension.  The
!       first two constructors return empty, uninitialized ranges.
!       The seven other constructors create an &range; using &domain;
!       objects.  These &domain; objects, having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;,
!       &hellip;, &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
!       converted into an integer, into a single-dimensional &domain;
!       object that can be converted into a single-dimensional &range;,
!       or to a multidimensional &domain; object that itself can be
!       converted into an &range;.  The total dimensionality of all the
!       arguments' types should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.
!       One-dimensional &domain; objects that can be converted into
!       one-dimensional &range;s include &locone;s, &intervalone;s, and
!       &rangeone;s.  If the sum of the objects' dimensions is less
!       than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the ranges for the final
!       dimensions are unspecified.  See the last paragraph of &lt;xref
!       linkend=&quot;arrays-domains-declarations-loc&quot;&gt;&lt;/xref&gt; for an
!       analogous example.  Note that the &rangeone; constructors taking
!       two and three parameters treat these arguments differently than
!       the multidimensional constructors do.&lt;/para&gt;
!      &lt;/section&gt;
! 
! 
!      &lt;section id=&quot;arrays-domains-declarations-grids&quot;&gt;
!       &lt;title&gt;&grid;s&lt;/title&gt;
! 
!       &lt;para&gt;&loc;s, &interval;s, and &range;s all have regularly spaced
!       integral values so they can be represented using &lt;glossterm
!       linkend=&quot;glossary-domain_triplet&quot;&gt;domain triplets&lt;/glossterm&gt;.
!       One-dimensional &grid; integral domains contain ascending or
!       descending sequences of integers, with no fixed stride.  For
!       example, a &gridone; may represent {-13, 1, 4, 5, 34}.  &gridone;
!       is generalized to multidimensional &grid;s using the direct
!       product of &gridone; &domain;s.&lt;/para&gt;
! 
!       &lt;para&gt;&grid;s that can be represented using domain triplets can
!       be constructed using techniques similar to other &domain;s, but
!       irregularly spaced domains can be constructed using
!       &indirectionlistint;s.&lt;/para&gt;
! 
!       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-grid-one_d_table&quot;&gt;
!        &lt;title&gt;Declaring One-Dimensional &grid;s&lt;/title&gt;
! 
!        &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
! 	&lt;thead&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;constructor&lt;/entry&gt;
! 	  &lt;entry&gt;result&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/thead&gt;
! 	&lt;tfoot&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;varname&gt;&domaintemplate;1&lt;/varname&gt;, &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, and
! 	  &lt;varname&gt;&domaintemplate;3&lt;/varname&gt; are template parameters.&lt;/entry&gt;
! 	  &lt;entry&gt;&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an empty, uninitialized grid.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &gridone;.  See the text for an explanation.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &gridone; from the interval specified by the
! 	  integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
! 	  &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &gridone; from the domain triplet specified
! 	  by the integers converted from &lt;varname&gt;t1&lt;/varname&gt;,
! 	  &lt;varname&gt;t2&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt;.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tbody&gt;
!        &lt;/tgroup&gt;
!       &lt;/table&gt;
! 
!       &lt;para&gt;To construct a &gridone; that can also be represented by a
!       domain triplet, use a &gridone; constructor similar to those for
!       &intervalone; and &rangeone;.  See &lt;xref
!       linkend=&quot;arrays-domains-declarations-grid-one_d_table&quot;&gt;&lt;/xref&gt;
!       and the text explanations following &lt;xref
!       linkend=&quot;arrays-domains-declarations-range-one_d_table&quot;&gt;&lt;/xref&gt;
!       or &lt;xref
!       linkend=&quot;arrays-domains-declarations-interval-one_d_table&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
! 
!       &lt;para&gt;&gridone;s with irregularly spaced points can be
!       constructed using &indirectionlistint;s.  For example,
!  &lt;programlisting&gt;
!  IndirectionList&lt;int&gt; list(4);
!  list(0) = 2;
!  list(1) = 5;
!  list(2) = 6;
!  list(3) = 9;
!  Grid&lt;1&gt; g(list);
!  &lt;/programlisting&gt; constructs an empty &indirectionlistint;, fills it
!       with ascending values, and then creates a &gridone; containing
!       {2, 5, 6, 9}.  When creating a list, its size must be specified.
!       Subsequently, its values can be assigned.  &indirectionlist;s can
!       also be initialized using one-dimensional &array;s:
!  &lt;programlisting&gt;
!  Array&lt;1,int,Brick&gt; a1(Interval&lt;1&gt;(0,3));
!  a1(0) = 2; a1(1) = 5; a1(2) = 6; a1(3) = 9;
!  IndirectionList&lt;int&gt; il(a1);
!  Grid&lt;1&gt; g1(il);
!  &lt;/programlisting&gt;  The &array; stores the integral points to include
!       in the &gridone; and is used to create the &indirectionlistint;,
!       which itself is used to create the &gridone;.  Since the points
!       are integers, the &array;'s type is &int;.  Either a &brick; or
!       &compressiblebrick; &engine; should be used.&lt;/para&gt;
! 
!       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-grids-multi_d_table&quot;&gt;
!        &lt;title&gt;Declaring Multidimensional &grid;s&lt;/title&gt;
! 
!        &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
! 	&lt;thead&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;constructor&lt;/entry&gt;
! 	  &lt;entry&gt;result&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/thead&gt;
! 	&lt;tfoot&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;varname&gt;&dim;&lt;/varname&gt; indicates the &grid;'s
! 	  dimension.  &lt;varname&gt;&domaintemplate;1&lt;/varname&gt;,
! 	  &lt;varname&gt;&domaintemplate;2&lt;/varname&gt;, &hellip; are template
! 	  parameters.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an empty, uninitialized &grid;, to be assigned a value later.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &grid; using the given &domain; object.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
! 	 &lt;/row&gt;
! 	&lt;/tbody&gt;
!        &lt;/tgroup&gt;
!       &lt;/table&gt;
! 
!       &lt;para&gt;Constructors for multidimensional &grid;s are the same as
!       multidimensional &interval; constructors except they create
!       &grid;s, not intervals.  See &lt;xref
!       linkend=&quot;arrays-domains-declarations-grids-multi_d_table&quot;&gt;&lt;/xref&gt;.
!       &lt;varname&gt;&dim;&lt;/varname&gt;&nbsp;indicates the &grid;'s dimension.  The
!       first constructor returns empty, uninitialized grids.  The seven
!       other constructors create an &grid; using &domain; objects.  These
!       &domain; objects, having types &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
!       &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be converted into an
!       integer, into a single-dimensional &domain; object that can be
!       converted into a single-dimensional &grid;, or to a
!       multidimensional &domain; object that itself can be converted into
!       an &grid;.  The total dimensionality of all the arguments' types
!       should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional
!       &domain; objects that can be converted into one-dimensional &grid;s
!       include &locone;s, &intervalone;s, &rangeone;s, and &gridone;s.
!       If the sum of the objects' dimensions is less
!       than&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, the grids for the final
!       dimensions are unspecified.  See the last paragraph of &lt;xref
!       linkend=&quot;arrays-domains-declarations-loc&quot;&gt;&lt;/xref&gt; for an
!       analogous example.  Note that the &gridone; constructors taking
!       two and three parameters treat these arguments differently than
!       the multidimensional constructors do.&lt;/para&gt;
!      &lt;/section&gt;
      &lt;/section&gt;
  
  
!     &lt;section id=&quot;arrays-domains-use&quot;&gt;
!      &lt;title&gt;Using &domain;s&lt;/title&gt;
  
!      &lt;para&gt;Since an &array; can be queried for its domain, we briefly
!      describe some &domain; operations.  A fuller description,
!      including arithmetic operations, occur in &lt;xref
!      linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-use-table&quot;&gt;
!       &lt;title&gt;Some &domain; Accessors&lt;/title&gt;
       
        &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
         &lt;thead&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&domain; member function&lt;/entry&gt;
  	 &lt;entry&gt;result&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
         &lt;tfoot&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;Other &domain; accessors are described in &lt;xref
! 	 linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tfoot&gt;
         &lt;tbody&gt;
! 	&lt;row rowsep=&quot;1&quot;&gt;
! 	 &lt;entry&gt;Multidimensional &domain; Accessors&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;long size()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns the total number of indices.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;bool empty()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns &true; if and only if the &domain; has no indices.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;D&lt;1&gt; operator[](int dimension)&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns the one-dimensional &domain; for the specified
! 	 dimension.  The return type is a one-dimensional version of
! 	 the &domain;.&lt;/entry&gt;
  	&lt;/row&gt;
! 	&lt;row rowsep=&quot;1&quot;&gt;
! 	 &lt;entry&gt;One-dimensional &domain; Accessors&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;long length()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns the number of indices.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;int first()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns the beginning of the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;int last()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns the ending of the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;int min()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns the minimum index in the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;int max()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns the maximum index in the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;D&lt;1&gt;::iterator begin()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns a bidirectional iterator pointing to the
! 	 beginning domain index.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;D&lt;1&gt;::iterator end()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns a bidirectional iterator pointing to the ending
! 	 domain index.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tbody&gt;
        &lt;/tgroup&gt;
       &lt;/table&gt;
  
!      &lt;para&gt;&domain; member functions are listed in &lt;xref
!      linkend=&quot;arrays-domains-use-table&quot;&gt;&lt;/xref&gt;.  Functions applicable
!      to one-dimensional and multidimensional &domain;s are listed
!      before functions that only applicable to one-dimensional
!      &domain;s.  The &lt;methodname&gt;size&lt;/methodname&gt; member function
!      yields the total number of indices in a given &domain;.  If and
!      only if this number is zero, &lt;methodname&gt;empty&lt;/methodname&gt; will
!      yield &true;.  A multidimensional
!      &lt;type&gt;domain&lt;&dim;&gt;&lt;/type&gt; is the direct product of &dim;
!      one-dimensional &domain;s.
  
! HERE&lt;/para&gt;
     &lt;/section&gt;
+    &lt;/section&gt;
  
  
     &lt;section id=&quot;arrays-arrays_declarations&quot;&gt;
      &lt;title&gt;Declaring &array;s&lt;/title&gt;
  
      &lt;para&gt;A &pooma; &array; maps indices from its &domain; to values.
!     In this section, we first describe how to declare &array;s.  In
!     the next section, we explain how to access individual values
!     stored within an &array; and &array; copy semantics.&lt;/para&gt;
  
      &lt;para&gt;&array; values need not just be stored values, as &c; arrays
      have.  They can also be computed using its engine.  We defer
*************** Grid&lt;1&gt; g1(il);
*** 1195,1201 ****
      compute the resulting &array;'s domain.  These are combined in the
      same way that multidimensional &interval;s are constructed.  (See
      &lt;xref
!     linkend=&quot;arrays-domains_declarations-intervals-multi_d_table&quot;&gt;&lt;/xref&gt;
      and the following text.)  The domain objects, having types
      &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
      &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
--- 1290,1296 ----
      compute the resulting &array;'s domain.  These are combined in the
      same way that multidimensional &interval;s are constructed.  (See
      &lt;xref
!     linkend=&quot;arrays-domains-declarations-intervals-multi_d_table&quot;&gt;&lt;/xref&gt;
      and the following text.)  The domain objects, having types
      &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
      &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1715,1720 ****
--- 1810,2129 ----
      which its &lt;methodname&gt;first&lt;/methodname&gt; extracts the length.  The
      &lt;methodname&gt;length&lt;/methodname&gt; &array; member function is used in
      the &lt;function&gt;PAssert&lt;/function&gt;.&lt;/para&gt;
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;arrays-dynamic_arrays&quot;&gt;
+     &lt;title&gt;&dynamicarray;s: Dynamically Changing Domain Sizes&lt;/title&gt;
+ 
+     &lt;para&gt;&array;s have fixed domains so the set of valid indices
+     remains fixed after declaration.  The &dynamicarray; class
+     supports one-dimensional domains that can be resized even while
+     the array is used.&lt;/para&gt;
+ 
+     &lt;para&gt;&dynamicarray;'s interface extends the one-dimensional
+     interface of an &array; by adding member functions to change the
+     domain's size.  It is declared in &lt;filename
+     class=&quot;libraryfile&quot;&gt;Pooma/DynamicArrays.h&lt;/filename&gt;.  A
+     &dynamicarray; has two, not three, template parameters, omitting
+     the array's dimensionality.  The first
+     parameter&nbsp;&lt;type&gt;T&lt;/type&gt; specifies the type of stored values.
+     Its default value is usually &double;, but it may be changed when
+     the &poomatoolkit; is configured.  The second parameter specifies
+     an &engine; via a tag.  The engine must support a domain with
+     dynamic resizing.  For example, the &dynamic; &engine; is
+     analogous to a one-dimensional &brick; &engine; supporting a
+     dynamically-resizable domain.  It is also usually the default
+     value for this tag.  For example, &lt;statement&gt;DynamicArray&lt;&gt;
+     d0(1);&lt;/statement&gt;, &lt;statement&gt;DynamicArray&lt;double&gt;
+     d1(1);&lt;/statement&gt;, and &lt;statement&gt;DynamicArray&lt;double,
+     Dynamic&gt; d2(1);&lt;/statement&gt; all declare the same
+     &dynamicarray;s explicitly storing one &double; value.  A
+     &dynamicarray; automatically allocates its initial memory and
+     deallocates its final memory, just as an &array; does.&lt;/para&gt;
+ 
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-change_size&quot;&gt;
+      &lt;title&gt;Changing a &dynamicarray;'s Domain&lt;/title&gt;
+      
+      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+       &lt;thead&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&dynamicarray; member function&lt;/entry&gt;
+ 	&lt;entry&gt;description&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/thead&gt;
+       &lt;tfoot&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;This table omits member functions designed for
+ 	distributed computation.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tfoot&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;void create(int num)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;extend the current domain by the requested number of
+         elements.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;remove the elements specified by the indices in the
+ 	given &domain; argument.  &lt;quote&gt;Backfill&lt;/quote&gt; moves
+ 	elements from the end of the domain to replace the deleted
+ 	elements.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;remove the elements specified by the indices in the
+ 	container range [begin,end) specified by the random-access
+ 	iterators.  &lt;quote&gt;Backfill&lt;/quote&gt; moves elements from the
+ 	end of the domain to replace the deleted elements.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList, const
+ 	DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
+ 
+ 	&lt;entry&gt;remove the elements specified by the indices in the
+ 	given &domain; argument.  Deleted elements can be replaced by
+ 	&lt;type&gt;BackFill&lt;/type&gt;'ing, i.e., moving data from the domain's
+ 	end to fill removed elements, or by &lt;type&gt;ShiftUp&lt;/type&gt;'ing,
+ 	i.e., compacting all data but maintaining relative ordering.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd,
+ 	const DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
+         &lt;entry&gt;remove the elements specified by the indices in the
+ 	container range [begin,end) specified by the random-access
+ 	iterators.  Deleted elements can be replaced by
+ 	&lt;type&gt;BackFill&lt;/type&gt;'ing, i.e., moving data from the domain's
+ 	end to fill removed elements, or by &lt;type&gt;ShiftUp&lt;/type&gt;'ing,
+ 	i.e., compacting all data but maintaining relative ordering.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/table&gt;
+ 
+     &lt;para&gt;The &lt;methodname&gt;create&lt;/methodname&gt; and
+     &lt;methodname&gt;destroy&lt;/methodname&gt; member functions permit changing
+     a &dynamicarray;'s domain.  &lt;xref
+     linkend=&quot;arrays-dynamic_arrays-change_size&quot;&gt;&lt;/xref&gt; lists these member
+     functions but omits functions exclusively used in distributed
+     computation.  When making the domain larger, new indices are added
+     to the end of the one-dimensional domain and the corresponding
+     values are initialized with the default value
+     for&nbsp;&lt;type&gt;T&lt;/type&gt;.  Existing values are copied.&lt;/para&gt;
+ 
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-table&quot;&gt;
+      &lt;title&gt;Changing a &dynamicarray;'s Domain&lt;/title&gt;
+      
+      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+       &lt;thead&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&dynamicarray; member function&lt;/entry&gt;
+ 	&lt;entry&gt;description&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/thead&gt;
+       &lt;tfoot&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;This table omits member functions designed for
+ 	distributed computation.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tfoot&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;void create(int num)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;extend the current domain by the requested number of
+         elements.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;remove the elements specified by the indices in the
+ 	given &domain; argument.  &lt;quote&gt;Backfill&lt;/quote&gt; moves
+ 	elements from the end of the domain to replace the deleted
+ 	elements.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;remove the elements specified by the indices in the
+ 	container range [begin,end) specified by the random-access
+ 	iterators.  &lt;quote&gt;Backfill&lt;/quote&gt; moves elements from the
+ 	end of the domain to replace the deleted elements.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList, const
+ 	DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
+ 
+ 	&lt;entry&gt;remove the elements specified by the indices in the
+ 	given &domain; argument.  Deleted elements can be replaced by
+ 	&lt;type&gt;BackFill&lt;/type&gt;'ing, i.e., moving data from the domain's
+ 	end to fill removed elements, or by &lt;type&gt;ShiftUp&lt;/type&gt;'ing,
+ 	i.e., compacting all data but maintaining relative ordering.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd,
+ 	const DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
+         &lt;entry&gt;remove the elements specified by the indices in the
+ 	container range [begin,end) specified by the random-access
+ 	iterators.  Deleted elements can be replaced by
+ 	&lt;type&gt;BackFill&lt;/type&gt;'ing, i.e., moving data from the domain's
+ 	end to fill removed elements, or by &lt;type&gt;ShiftUp&lt;/type&gt;'ing,
+ 	i.e., compacting all data but maintaining relative ordering.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/table&gt;
+ 
+     &lt;para&gt;The &lt;methodname&gt;destroy&lt;/methodname&gt; deletes specified
+     indices.  The indices may be specified using either a &domain;
+     object (&lt;type&gt;Interval&lt;1&gt;&lt;/type&gt;,
+     &lt;type&gt;Range&lt;1&gt;&lt;/type&gt;, or &lt;type&gt;IndirectionList&lt;/type&gt;) or
+     in a container specified using random-access iterators.  For
+     example, every other element from a ten-element
+     array&nbsp;&lt;varname&gt;d&lt;/varname&gt; might be removed using
+     &lt;statement&gt;Range&lt;1&gt;(0,9,2)&lt;/statement&gt;.  Alternatively,
+ &lt;programlisting&gt;
+ int killList[] = {0, 2, 4, 6, 8};
+ d.destroy(killList, killList+5);
+ &lt;/programlisting&gt; performs the same deletions.  As indices are
+     removed, other indices are moved into their positions.  Using the
+     &lt;type&gt;BackFill&lt;/type&gt; method moves the last index and its
+     associated value into deleted index's position.  Thus, the total
+     number of indices is decreased by one, but the indices can be
+     reordered.  Using the &lt;type&gt;ShiftUp&lt;/type&gt; method ensures the
+     indices' orders are maintained by &lt;quote&gt;shifting&lt;/quote&gt; all
+     elements left (or up) so all &lt;quote&gt;gaps&lt;/quote&gt; between indices
+     disappear.  For example, consider removing the first index from a
+     domain.
+     &lt;informaltable frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-destroy_example&quot;&gt;
+      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;original indices:&lt;/entry&gt;
+ 	&lt;entry&gt;0 1 2 3&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;methodname&gt;destroy&lt;/methodname&gt; using &lt;type&gt;BackFill&lt;/type&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;3 1 2&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;methodname&gt;destroy&lt;/methodname&gt; using &lt;type&gt;ShiftUp&lt;/type&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;1 2 3&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/informaltable&gt;
+     The &lt;type&gt;BackFill&lt;/type&gt; moves the rightmost index&nbsp;3 into
+     the removed index&nbsp;0's position.  The &lt;type&gt;ShiftUp&lt;/type&gt;
+     moves all the indices one position to the left.  This illustrates
+     that &lt;type&gt;BackFill&lt;/type&gt; moves exactly as many indices as are
+     deleted, while &lt;type&gt;ShiftUp&lt;/type&gt; can shift all indices in a
+     domain.  Thus, &lt;type&gt;BackFill&lt;/type&gt; is the default method.  When
+     multiple indices are deleted, they are deleted from the largest to
+     the smallest.  When using the &lt;type&gt;BackFill&lt;/type&gt; method, some
+     indices may be moved repeatedly.  For example, consider removing
+     indices 0 and 2 from original indices of 0 1 2 3.  Removing 2
+     yields 0 1 3.  Removing 0 yields 3 1.  Using an object with the
+     desired type to indicate which fill method is desired, i.e.,
+     &lt;statement&gt;BackFill()&lt;/statement&gt; or
+     &lt;statement&gt;ShiftUp()&lt;/statement&gt;.&lt;/para&gt;
+ 
+     &lt;example id=&quot;arrays-dynamic_arrays-example&quot;&gt;
+      &lt;title&gt;Example Using &dynamicarray;s&lt;/title&gt;
+ 
+      &amp;dynamicarray-example;
+      &lt;calloutlist&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-header&quot;&gt;
+        &lt;para&gt;This header file declares &dynamicarray;s.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-identical_declarations&quot;&gt;
+        &lt;para&gt;These three declarations yield equivalent
+        &dynamicarray;s, storing one &double; value.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-extension&quot;&gt;
+        &lt;para&gt;This &lt;methodname&gt;create&lt;/methodname&gt; member function adds
+        five indices to the end of the domain.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-access&quot;&gt;
+        &lt;para&gt;&dynamicarray; values are accessed the same way as
+        &array; values.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-destroy_range&quot;&gt;
+        &lt;para&gt;The &range; object specifies that every other index
+        should be removed.  The &lt;statement&gt;BackFill()&lt;/statement&gt;
+        object is unnecessary since it is the default replacement
+        method.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-destroy_iterators&quot;&gt;
+        &lt;para&gt;This &lt;methodname&gt;destroy&lt;/methodname&gt; call is equivalent
+        to the previous one but uses iterators.&lt;/para&gt;
+       &lt;/callout&gt;
+      &lt;/calloutlist&gt;
+     &lt;/example&gt;
+ 
+     &lt;para&gt;We illustrate &dynamicarray; resizing in &lt;xref
+     linkend=&quot;arrays-dynamic_arrays-example&quot;&gt;&lt;/xref&gt;.  &dynamicarray;s
+     are declared in &lt;filename
+     class=&quot;headerfile&quot;&gt;Pooma/DynamicArrays.h&lt;/filename&gt;, not &lt;filename
+     class=&quot;headerfile&quot;&gt;Pooma/Arrays.h&lt;/filename&gt;.  Their declarations
+     require two, not three, template arguments because the array must
+     be one-dimensional.  The three arrays, each having one &double;
+     value, are equivalent.  (The &poomatoolkit; can be configured to
+     support different default values.)  Invoking
+     &lt;varname&gt;d0&lt;/varname&gt;'s &lt;methodname&gt;create&lt;/methodname&gt; with an
+     argument of five increases its domain size from one to six.  The
+     additional indices are added to the end of the domain so the value
+     at index&nbsp;0 is not changed.  To illustrate which indices are
+     removed and which indices are reordered, the program first sets
+     all values equal to their indices.  This illustrates that
+     &dynamicarray; values are accessed the same way as &array; values.
+     For example, &lt;statement&gt;d0(i)&lt;/statement&gt; accesses the
+     &lt;varname&gt;i&lt;/varname&gt;th value.  The
+     &lt;methodname&gt;destroy&lt;/methodname&gt; removes every other index from
+     the array.  The one-dimensional &range; specifies these indices by
+     specifying the domain's entire interval and a stride of&nbsp;2.
+     The &lt;statement&gt;BackFill&lt;/statement&gt; function call creates a
+     &lt;type&gt;BackFill&lt;/type&gt; object indicating the &lt;type&gt;BackFill&lt;/type&gt;
+     method should be used.  We illustrate the steps of this method:
+     &lt;informaltable frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-program_example&quot;&gt;
+      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;original indices:&lt;/entry&gt;
+ 	&lt;entry&gt;0 1 2 3 4 5&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;delete index 4&lt;/entry&gt;
+ 	&lt;entry&gt;0 1 2 3 5&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;delete index 2&lt;/entry&gt;
+ 	&lt;entry&gt;0 1 5 3&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;delete index 0&lt;/entry&gt;
+ 	&lt;entry&gt;3 1 5&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/informaltable&gt;
+     Since multiple indices are specified, the rightmost one is removed
+     first, i.e., index&nbsp;4.  The rightmost index&nbsp;5 is moved
+     into 4's position.  When removing index&nbsp;2, the index
+     originally at 5 is moved again into 2's position.  Finally,
+     index&nbsp;0 is replaced by index&nbsp;3.  The rest of the program
+     repeats the computation, using the random-access iterator version
+     of &lt;methodname&gt;destroy&lt;/methodname&gt;.  Since this &dynamicarray;'s
+     indices are specified using &int;s, the
+     &lt;varname&gt;killList&lt;/varname&gt; explicitly lists the indices to
+     remove.  The &lt;methodname&gt;destroy&lt;/methodname&gt; call uses pointers
+     to the beginning and end of the &lt;varname&gt;killList&lt;/varname&gt; array
+     to specify which of its indices to use.  Since no replacement
+     method is specified, the default &lt;type&gt;BackFill&lt;/type&gt; method is
+     used.  All the &dynamicarray;s' unallocated memory is
+     deallocated.&lt;/para&gt;
     &lt;/section&gt;
  
  
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.6
diff -c -p -r1.6 concepts.xml
*** concepts.xml	2002/01/16 00:50:27	1.6
--- concepts.xml	2002/01/22 15:37:14
***************
*** 147,158 ****
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm linkend=&quot;glossary-field&quot;&gt;&field;&lt;/glossterm&gt;&lt;/entry&gt;
  	&lt;entry&gt;container mapping &lt;glossterm linkend=&quot;glossary-index&quot;&gt;indices&lt;/glossterm&gt; to one or more values and
! 	residing in multi-dimensional space&lt;/entry&gt;
       &lt;/row&gt;
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm
  	linkend=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;multi-dimensional mathematical tensor&lt;/entry&gt;
       &lt;/row&gt;
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm
--- 147,158 ----
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm linkend=&quot;glossary-field&quot;&gt;&field;&lt;/glossterm&gt;&lt;/entry&gt;
  	&lt;entry&gt;container mapping &lt;glossterm linkend=&quot;glossary-index&quot;&gt;indices&lt;/glossterm&gt; to one or more values and
! 	residing in multidimensional space&lt;/entry&gt;
       &lt;/row&gt;
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm
  	linkend=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;multidimensional mathematical tensor&lt;/entry&gt;
       &lt;/row&gt;
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm
***************
*** 162,168 ****
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm
  	linkend=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;multi-dimensional mathematical vector&lt;/entry&gt;
       &lt;/row&gt;
      &lt;/tbody&gt;
     &lt;/tgroup&gt;
--- 162,168 ----
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm
  	linkend=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;multidimensional mathematical vector&lt;/entry&gt;
       &lt;/row&gt;
      &lt;/tbody&gt;
     &lt;/tgroup&gt;
***************
*** 210,216 ****
  &lt;!-- FIXME: Want firstterm around tensor. --&gt;
  
    &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossterm&gt;
!   implements a multi-dimensional mathematical tensor.  Since it is a
    first-class type, it can be used in expressions such as
    adding two &tensor;s.&lt;/para&gt;
  
--- 210,216 ----
  &lt;!-- FIXME: Want firstterm around tensor. --&gt;
  
    &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossterm&gt;
!   implements a multidimensional mathematical tensor.  Since it is a
    first-class type, it can be used in expressions such as
    adding two &tensor;s.&lt;/para&gt;
  
***************
*** 224,230 ****
  &lt;!-- FIXME: Want firstterm around vector. --&gt;
  
    &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossterm&gt;
!   implements a multi-dimensional mathematical vector, which is an
    ordered tuple of components.  Since it is a first-class type, it
    can be used in expressions such as adding two &vector;s and
    multiplying a &matrix; and a &vector;.&lt;/para&gt;
--- 224,230 ----
  &lt;!-- FIXME: Want firstterm around vector. --&gt;
  
    &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossterm&gt;
!   implements a multidimensional mathematical vector, which is an
    ordered tuple of components.  Since it is a first-class type, it
    can be used in expressions such as adding two &vector;s and
    multiplying a &matrix; and a &vector;.&lt;/para&gt;
***************
*** 263,269 ****
  	&lt;entry&gt;use a &vector;, &matrix;, or &tensor;.&lt;/entry&gt;
       &lt;/row&gt;
       &lt;row&gt;
! 	&lt;entry&gt;If indices and values reside in multi-dimensional space
  	&space;,&lt;/entry&gt;
  	&lt;entry&gt;use a &field;.&lt;/entry&gt;
       &lt;/row&gt;
--- 263,269 ----
  	&lt;entry&gt;use a &vector;, &matrix;, or &tensor;.&lt;/entry&gt;
       &lt;/row&gt;
       &lt;row&gt;
! 	&lt;entry&gt;If indices and values reside in multidimensional space
  	&space;,&lt;/entry&gt;
  	&lt;entry&gt;use a &field;.&lt;/entry&gt;
       &lt;/row&gt;
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.6
diff -c -p -r1.6 glossary.xml
*** glossary.xml	2002/01/14 17:33:34	1.6
--- glossary.xml	2002/01/22 15:37:16
***************
*** 369,374 ****
--- 369,384 ----
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
+   &lt;glossentry id=&quot;glossary-function_object&quot;&gt;
+    &lt;glossterm&gt;function object&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;object that can behave as a function.  The object can store
+     values that the function uses.  If its function is called
+     &lt;methodname&gt;operator()&lt;/methodname&gt;, the object can be invoked as
+     a function.&lt;/para&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-function_template&quot;&gt;
     &lt;glossterm&gt;function template&lt;/glossterm&gt;
     &lt;glossdef&gt;
***************
*** 547,553 ****
    &lt;glossentry id=&quot;glossary-point&quot;&gt;
     &lt;glossterm&gt;point&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a location in multi-dimensional space&nbsp;&space;.
      In contrast, indices specify positions in container domains.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossseealso&gt;
--- 557,563 ----
    &lt;glossentry id=&quot;glossary-point&quot;&gt;
     &lt;glossterm&gt;point&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a location in multidimensional space&nbsp;&space;.
      In contrast, indices specify positions in container domains.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossseealso&gt;
***************
*** 694,700 ****
    &lt;glossentry id=&quot;glossary-tensor&quot;&gt;
     &lt;glossterm&gt;&tensor;&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a &pooma; container implementing multi-dimensional
      mathematical tensors as first-class objects.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-matrix&quot;&gt;&matrix;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossseealso&gt;
--- 704,710 ----
    &lt;glossentry id=&quot;glossary-tensor&quot;&gt;
     &lt;glossterm&gt;&tensor;&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a &pooma; container implementing multidimensional
      mathematical tensors as first-class objects.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-matrix&quot;&gt;&matrix;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossseealso&gt;
***************
*** 750,756 ****
    &lt;glossentry id=&quot;glossary-vector&quot;&gt;
     &lt;glossterm&gt;&vector;&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a &pooma; container implementing multi-dimensional
      mathematical vectors, i.e., an ordered tuple of components, as
      first-class objects.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossseealso&gt;
--- 760,766 ----
    &lt;glossentry id=&quot;glossary-vector&quot;&gt;
     &lt;glossterm&gt;&vector;&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a &pooma; container implementing multidimensional
      mathematical vectors, i.e., an ordered tuple of components, as
      first-class objects.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossseealso&gt;
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.7
diff -c -p -r1.7 manual.xml
*** manual.xml	2002/01/16 00:50:27	1.7
--- manual.xml	2002/01/22 15:37:19
***************
*** 95,100 ****
--- 95,102 ----
    &lt;!-- A domain template parameter. --&gt;
  &lt;!ENTITY double &quot;&lt;type&gt;double&lt;/type&gt;&quot;&gt;
    &lt;!-- The C &quot;double&quot; type. --&gt;
+ &lt;!ENTITY dynamic &quot;&lt;type&gt;Dynamic&lt;/type&gt;&quot;&gt;
+   &lt;!-- The &quot;Dynamic&quot; Engine type. --&gt;
  &lt;!ENTITY dynamicarray &quot;&lt;type&gt;DynamicArray&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;DynamicArray&quot; type. --&gt;
  &lt;!ENTITY engine &quot;&lt;type&gt;Engine&lt;/type&gt;&quot;&gt;
***************
*** 156,167 ****
  
  &lt;!ENTITY container &quot;C&quot;&gt;
    &lt;!-- an abbreviation for a canonical container --&gt;
- &lt;!ENTITY dim &quot;D&quot;&gt;
-   &lt;!-- the number of dimensions of an array, domain, etc. --&gt;
  &lt;!ENTITY n &quot;n&quot;&gt;
    &lt;!-- the size of one dimension of an array --&gt;
  &lt;!ENTITY space &quot;&real;&lt;superscript&gt;d&lt;/superscript&gt;&quot;&gt;
!   &lt;!-- a notation for multi-dimensional space --&gt;
  
  &lt;!-- System and Operating System Entity Declarations --&gt;
  &lt;!ENTITY gcc &quot;&lt;application&gt;g++&lt;/application&gt;&quot;&gt;
--- 158,167 ----
  
  &lt;!ENTITY container &quot;C&quot;&gt;
    &lt;!-- an abbreviation for a canonical container --&gt;
  &lt;!ENTITY n &quot;n&quot;&gt;
    &lt;!-- the size of one dimension of an array --&gt;
  &lt;!ENTITY space &quot;&real;&lt;superscript&gt;d&lt;/superscript&gt;&quot;&gt;
!   &lt;!-- a notation for multidimensional space --&gt;
  
  &lt;!-- System and Operating System Entity Declarations --&gt;
  &lt;!ENTITY gcc &quot;&lt;application&gt;g++&lt;/application&gt;&quot;&gt;
***************
*** 234,245 ****
    &lt;!-- Field data-parallel distributed Doof2d implementation --&gt;
  
  &lt;!-- Sequential Programs --&gt;
- &lt;!ENTITY initialize-finalize SYSTEM &quot;./programs/examples/Sequential/initialize-finalize-annotated.cpp&quot;&gt;
-   &lt;!-- Illustrate initialize() and finalize(). --&gt;
  &lt;!ENTITY array-copy SYSTEM &quot;./programs/examples/Sequential/array-copy-annotated.cpp&quot;&gt;
    &lt;!-- Illustrate Array reference semantics. --&gt;
  &lt;!ENTITY array-size SYSTEM &quot;./programs/examples/Sequential/array-size-annotated.cpp&quot;&gt;
    &lt;!-- Illustrate Array member functions. --&gt;
  
  &lt;!-- Template Programs --&gt;
  &lt;!ENTITY pairs-untemplated SYSTEM &quot;./programs/examples/Templates/pairs-untemplated-annotated.cpp&quot;&gt;
--- 234,247 ----
    &lt;!-- Field data-parallel distributed Doof2d implementation --&gt;
  
  &lt;!-- Sequential Programs --&gt;
  &lt;!ENTITY array-copy SYSTEM &quot;./programs/examples/Sequential/array-copy-annotated.cpp&quot;&gt;
    &lt;!-- Illustrate Array reference semantics. --&gt;
  &lt;!ENTITY array-size SYSTEM &quot;./programs/examples/Sequential/array-size-annotated.cpp&quot;&gt;
    &lt;!-- Illustrate Array member functions. --&gt;
+ &lt;!ENTITY dynamicarray-example SYSTEM &quot;./programs/examples/Sequential/dynamicarray-annotated.cpp&quot;&gt;
+   &lt;!-- Illustrate using DynamicArray class. --&gt;
+ &lt;!ENTITY initialize-finalize SYSTEM &quot;./programs/examples/Sequential/initialize-finalize-annotated.cpp&quot;&gt;
+   &lt;!-- Illustrate initialize() and finalize(). --&gt;
  
  &lt;!-- Template Programs --&gt;
  &lt;!ENTITY pairs-untemplated SYSTEM &quot;./programs/examples/Templates/pairs-untemplated-annotated.cpp&quot;&gt;
***************
*** 353,362 ****
  
    &amp;arrays-chapter;
  
    &lt;chapter id=&quot;engines&quot;&gt;
     &lt;title&gt;Engines&lt;/title&gt;
  
!    &lt;para&gt;UNFINISHED&lt;/para&gt;
    &lt;/chapter&gt;
  
  
--- 355,692 ----
  
    &amp;arrays-chapter;
  
+ 
    &lt;chapter id=&quot;engines&quot;&gt;
     &lt;title&gt;Engines&lt;/title&gt;
  
!    &lt;para&gt;Each container has one or more &engine;s to store or compute
!    its values.  As we mentioned in &lt;xref
!    linkend=&quot;arrays-arrays_declarations&quot;&gt;&lt;/xref&gt;, a container's role is
!    high-level, supporting access to groups of values, and an engine's
!    role is low-level, storing or computing values and supporting
!    access to individual values.  This separation permits optimizing
!    space and computation requirements.&lt;/para&gt;
! 
!    &lt;para&gt;We begin this chapter by introducing the concept of an engine
!    and how it is used.  Then, we describe the various &engine;s that
!    &pooma; provides, separating them into engines that store values
!    and engines that compute values.  Finally, we describe how the
!    &engine;s are implemented, using tags to differentiate engines and
!    reference-counted pointers to their underlying data.&lt;/para&gt;
! 
! 
!    &lt;section id=&quot;engines-concept&quot;&gt;
!     &lt;title&gt;The Concept&lt;/title&gt;
! 
!     &lt;para&gt;An engine performs the low-level value storage, computation,
!     and element-wise access for a container.  The &pooma; &engine;
!     class and its specializations implement the concept.  An engine
!     has a domain and accessor functions returning individual elements.
!     Given an index within the domain, an engine's
!     &lt;methodname&gt;operator()&lt;/methodname&gt; function returns the
!     associated value, which can be used or changed.  Its
!     &lt;methodname&gt;read&lt;/methodname&gt; returns the same value for only use,
!     not modification.  The acceptable indices are determined by each
!     &engine;.  Most accept indices specified using &int; and
!     &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt; parameters, but an &engine; might
!     accept string or floating-point parameters.  An &engine;'s layout
!     specifies maps its domain indices to the processors and memory
!     used to store and compute the associated values.&lt;/para&gt;
! 
!     &lt;para&gt;Since an engine's main role is to return the individual
!     values associated with specific domain indices, any implementation
!     performing this task is an engine.  &pooma; &engine;s fall into
!     three categories:
!     &lt;itemizedlist&gt;
!      &lt;listitem&gt;
!       &lt;para&gt;&engine;s that store values.&lt;/para&gt;
!      &lt;/listitem&gt;
!      &lt;listitem&gt;
!       &lt;para&gt;&engine;s that compute their values using other &engine;s'
!       values.&lt;/para&gt;
!      &lt;/listitem&gt;
!      &lt;listitem&gt;
!       &lt;para&gt;&engine;s that support distributed computation.&lt;/para&gt;
!      &lt;/listitem&gt;
!     &lt;/itemizedlist&gt;
!     For example, the &brick; &engine; explicitly stores all its
!     values, while the &compressiblebrick; engine adds the feature of
!     reducing its storage requirements if all these values are
!     identical.  A &lt;type&gt;UserFunction&lt;/type&gt; &engine; yields values by
!     applying a &lt;glossterm linkend=&quot;glossary-function_object&quot;&gt;function
!     object&lt;/glossterm&gt; to each value returned by another &engine;.  A
!     &lt;type&gt;CompFwd&lt;/type&gt; &engine; projects components from another
!     &engine;.  For example, &lt;type&gt;CompFwd&lt;/type&gt; will use the second
!     components of each vector in an &array; to form its own &array;.
!     Since each container has one or more &engine;s, we can also
!     describe the latter category as containers that compute their
!     values using other containers' values.  A &lt;type&gt;MultiPatch&lt;/type&gt;
!     &engine; distributes its domain among various processors and
!     memory spaces, each responsible for computing values associated
!     with a portion, or patch, of the domain.&lt;/para&gt;
! 
!     &lt;para&gt;Just as multiple containers can use the same engine,
!     multiple &engine;s can use the same underlying data.  As we
!     mentioned in &lt;xref linkend=&quot;arrays-arrays_use&quot;&gt;&lt;/xref&gt;, &engine;s
!     have reference semantics.  So a copy of an &engine; has a
!     reference-counted pointer to an &engine;'s data (if any exists).
!     Thus, copying an &engine; or a container requires little execution
!     time.  If an &engine; has the same data as another &engine; but it
!     needs its own data to modify, the
!     &lt;methodname&gt;makeOwnCopy&lt;/methodname&gt; creates such a copy.&lt;/para&gt;
! 
!     &lt;para&gt;&engine;s are rarely explicitly declared.  Instead a
!     container is declared using an &engine; tag, and the container,
!     creates the specified &engine; to deal with its values.  For
!     example, a &brick; &engine; is explicitly declared as
!     &lt;type&gt;Engine&lt;&dim;,T,Brick&gt;&lt;/type&gt;, but they are more
!     frequently created by containers, e.g.,
!     &lt;type&gt;Array&lt;&dim;,T,Brick&gt;&lt;/type&gt;.  The first two template
!     parameters specify the domain's dimensionality and the value type,
!     as described in &lt;xref
!     linkend=&quot;arrays-arrays_declarations&quot;&gt;&lt;/xref&gt;.  Unlike container
!     declarations, the third template parameter, the &engine; tag,
!     specifies which &engine; specialization to use.  For example, the
!     &brick; engine tag indicates a brick &engine; should be used.
!     Some &engine;s, such as &lt;type&gt;CompFwd&lt;/type&gt;, are rarely declared
!     even using &engine; tags.  Instead the &array;'s
!     &lt;methodname&gt;comp&lt;/methodname&gt; and
!     &lt;methodname&gt;readComp&lt;/methodname&gt; methods return views of
!     containers using &lt;type&gt;CompFwd&lt;/type&gt; &engine;s.&lt;/para&gt;
!    &lt;/section&gt;
! 
! 
!    &lt;section id=&quot;engines-types&quot;&gt;
!     &lt;title&gt;Types of &engine;s&lt;/title&gt;
! 
!     &lt;para&gt;In this section, we describe the different types of
!     &engine;s and illustrate their creation, when appropriate.  First,
!     we describe &engine;s that explicitly store values and then
!     &engine;s that compute values.&lt;/para&gt;
! 
!      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;engines-types-table&quot;&gt;
!       &lt;title&gt;Types of &engine;s&lt;/title&gt;
!      
!       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!        &lt;thead&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&engine; tag&lt;/entry&gt;
! 	 &lt;entry&gt;description&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/thead&gt;
!        &lt;tbody&gt;
! 	&lt;row rowsep=&quot;1&quot;&gt;
! 	 &lt;entry&gt;&engine;s That Store&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&brick;&lt;/entry&gt;
! 	 &lt;entry&gt;explicitly stores all values; similar to &c; arrays.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&compressiblebrick;&lt;/entry&gt;
! 	 &lt;entry&gt;stores all values, reducing storage requirements when
! 	 all values are the same.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&dynamic;&lt;/entry&gt;
! 	 &lt;entry&gt;is a one-dimensional &brick; with dynamically
!          resizable domain.  HERE ever explicitly declare these?&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row rowsep=&quot;1&quot;&gt;
! 	 &lt;entry&gt;&engine;s That Compute&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;CompFwd&lt;/type&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;extracts specified components of an engine's vectors,
! 	 tensors, arrays, etc.; usually created using
! 	 &lt;methodname&gt;comp&lt;/methodname&gt; container function.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;ConstantFunction&lt;/type&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;makes a scalar value behave like a container.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;IndexFunction&lt;FunctionObject&gt;&lt;/type&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;makes the &lt;type&gt;FunctionObject&lt;/type&gt; function of
! 	 indices behave like a container.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;ExpressionTag&lt;Expr&gt;&lt;/type&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;evaluates an expression tree; usually created by
! 	 data-parallel expressions.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;Stencil&lt;Function,
! 	 Expression&gt;&lt;/type&gt;&lt;/entry&gt;
!          &lt;entry&gt;applies a stencil computation (&lt;type&gt;Function&lt;/type&gt;)
! 	 to its input (&lt;type&gt;Expression&lt;/type&gt;), usually a container;
! 	 usually created by applying a &lt;type&gt;Stencil&lt;/type&gt; object to
! 	 a container.  A stencil computation can use multiple
! 	 neighboring input values.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;UserFunctionEngine&lt;Function,
! 	 Expression&gt;&lt;/type&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;applies the given function (or &lt;glossterm
! 	 linkend=&quot;glossary-function_object&quot;&gt;function
! 	 object&lt;/glossterm&gt;) to its input (&lt;type&gt;Expression&lt;/type&gt;),
! 	 usually a container; usually created by applying a
! 	 &lt;type&gt;UserFunction&lt;/type&gt; object to a container.  The
! 	 function implements a one-to-one mapping from its input to
! 	 values.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row rowsep=&quot;1&quot;&gt;
! 	 &lt;entry&gt;&engine;s for Distributed Computation&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;MultiPatch&lt;LayoutTag,EngineTag&gt;&lt;/type&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;runs a separate &lt;type&gt;EngineTag&lt;/type&gt; &engine; on
! 	 each context (patch) specified by the given layout.  This is
! 	 the usual &engine; for distributed computation.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;Remote&lt;EngineTag&gt;&lt;/type&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;runs the &engine; specified by &lt;type&gt;EngineTag&lt;/type&gt;
! 	 on a specified context.&lt;/entry&gt;
! 	&lt;/row&gt;
! 	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;Remote&lt;Dynamic&gt;&lt;/type&gt;&lt;/entry&gt;
! 	&lt;entry&gt;runs a &lt;type&gt;Dynamic&lt;/type&gt; one-dimensional, resizable
! 	&engine; on a specified context.  This is a specialization of
! 	&lt;type&gt;Remote&lt;/type&gt;.&lt;/entry&gt;
! 	&lt;/row&gt;
!        &lt;/tbody&gt;
!       &lt;/tgroup&gt;
!      &lt;/table&gt;
! 
!     &lt;para&gt;&brick; &engine;s explicitly store values just like &c;
!     arrays.  &compressiblebrick; &engine;s optimize their storage
!     requirements when all values are the same.  Most &array;s use one
!     of these two &engine;s.  &brick;s are the default &engine;s for
!     &array; and &field; containers because each of their values are
!     explicitly stored.  Explicitly storing all an engine's value can
!     require a large amount of space, particularly if all these values
!     are the same.  If all a compressible brick &engine;'s values are
!     the same, the engine stores that one value rather than many, many
!     copies of the same value.  These engines can both save time as
!     well as space.  Initializing a compressible engine requires
!     setting only one value, not every value.  Using less storage space
!     may permit more useful values to be stored in cache, improving
!     cache performance.  Reading a value in a compressed &engine; using
!     &lt;methodname&gt;read&lt;/methodname&gt; is as fast as reading a value in a
!     &brick; &engine;, but writing a value always requires an
!     additional &lt;keywordname&gt;if&lt;/keywordname&gt; conditional.  Thus, if an
!     &engine; occasionally has multiple different values during its
!     life time, a &compressiblebrick; &engine; may be faster than a
!     &brick; &engine;.  If an &engine; is created and its values are
!     mostly read, not written, a &compressiblebrick; &engine; may also
!     be faster.  Otherwise, a &brick; &engine; may be preferable.
!     Timing the same program using the two different &engine; types
!     will reveal which is faster for a particular situation.&lt;/para&gt;
! 
!     &lt;para&gt;In distributed computing, many &engine;s may have few
!     nonzero values so &compressiblebrick; &engine;s may be preferable.
!     For distributed computing, a container's domain is partitioned
!     into regions each computed by a separate processor and &engine;.
!     If the computation is concentrated in sections of the domain, many
!     &engine;s may have few, if any, nonzero values.  Thus,
!     &compressiblebrick; &engine;s may be preferable for distributed
!     computing.&lt;/para&gt;
! 
!     &lt;para&gt;Both &brick; and &compressiblebrick; &engine;s have
!     &lt;methodname&gt;read&lt;/methodname&gt; and
!     &lt;methodname&gt;operator()&lt;/methodname&gt; members with &int; and &loc;
!     parameters.  The parameters should match the &array;'s
!     dimensionality.  For example, if &array; &lt;varname&gt;a&lt;/varname&gt; has
!     dimensionality&nbsp;3, &lt;function&gt;a.read(int, int, int)&lt;/function&gt;
!     and &lt;function&gt;a(int, int, int)&lt;/function&gt; should be used.  The
!     former returns a value that cannot be modified, while the latter
!     can be changed.  Using the &lt;methodname&gt;read&lt;/methodname&gt; can lead
!     to faster code.  Alternatively, an index can be specified using a
!     &loc;.  For example,
!     &lt;statement&gt;a.read(Loc&lt;3&gt;(1,-2,5))&lt;/statement&gt; and
!     &lt;statement&gt;a(Loc&lt;3&gt;(1,-2,5))&lt;/statement&gt; are equivalent to
!     &lt;statement&gt;a.read(1,-2,5))&lt;/statement&gt; and
!     &lt;statement&gt;a(1,-2,5)&lt;/statement&gt;.&lt;/para&gt;
! 
!     &lt;para&gt;The &dynamic; &engine; supports changing domain sizes while
!     a program is executing.  It is basically a one-dimensional
!     &brick;, explicitly storing values, but permitting the number and
!     order of stored values to change.  Thus, it supports the same
!     interface as &brick; except that all member functions are
!     restricted to their one-dimensional versions.  For example,
!     &lt;methodname&gt;read&lt;/methodname&gt; and
!     &lt;methodname&gt;operator()&lt;/methodname&gt; take &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;
!     or one &int; parameter.  In addition, the one-dimensional domain
!     can be dynamically resized using &lt;methodname&gt;create&lt;/methodname&gt;
!     and &lt;methodname&gt;destroy&lt;/methodname&gt;; see .  
! 
! HERE Dynamic. How does one change the domain size?  What is the model?&lt;/para&gt;
! 
! &lt;!-- HERE: Array cannot forward domain size changes to underlying Dynamic Engine. --&gt;
! 
!     &lt;para&gt;Types of &engine;s:
!    Brick - explicitly store values
!    CompressibleBrick - explicitly store values but store only one if all the same
!    ConstantFunction - convert scalar into an array
!    DynamicEngine - contiguous, local, resizable, 1D block
!    ExpressionEngine - evaluate PETE expression
!    CompFwd - array formed by extracted components from array
!      ForwardEngine
!      tut-02.html: use .comp() or .readComp()
!    IndexFunctionEngine - convert function of indices into an array
!    IndirectionEngine - incomplete
!    MultiPatch - ?How do I describe this?
!    RemoteDynamic - run a Dynamic engine on a specified context
!    Remote - permit computations on specified context
!      should discuss with MultiPatch
!    Stencil - apply a stencil to an array, returning a new Array with the results
!    UserFunction - Array = apply function to an Array
! &lt;/para&gt;
! 
!    &lt;para&gt;How do I organize these engines into understandable
! 	     categories?
! 
!    storage
!     Brick
!     CompressibleBrick
!     Dynamic - resizable 1D block
!       RemoteDynamic
!     MultiPatch - ?WHAT?
!       Remote
! 
!    computation
!     CompFwd: project(array)-&gt;array
!       .comp() and .readComp()
!       view, not a copy
!     ConstantFunction: scalar(array)-&gt;array
!       explicitly use
!     IndexFunctionEngine: function(indices)-&gt;array
!       explicitly use
!     ExpressionEngine: expression(array)-&gt;array
!       created by data-parallel expression
!     Stencil: stencil(array)-&gt;array
!       implicitly used
!       explicitly use Stencil&lt;...&gt; type
!     UserFunction: function(array)-&gt;array
!       explicitly use
! &lt;/para&gt;
! 
!     &lt;para&gt;
!       Element_t read(Loc&lt;&dim;&gt;)
!       ElementRef_t operator()(Loc&lt;&dim;&gt;)
!       Element_t read(int+)
!       ElementRef_t operator()(int+)
!     &lt;/para&gt;
! 
!     &lt;para&gt;Explain the concept of an engine.  How does an engine
!     interact with a container or an &array;?  Explain the different
!     types of engines likely to be used by &pooma; programmers and how
!     to declare containers using them.  Should I list the other engines
!     that are automatically created?&lt;/para&gt;
! 
!    &lt;/section&gt;
    &lt;/chapter&gt;
  
  
***************
*** 553,559 ****
      &lt;title&gt;Beginning and Ending &pooma; Programs&lt;/title&gt;
  
      &lt;para&gt;Every &pooma; program must begin with a call to
!     &lt;methodname&gt;initialize&lt;/methodname&gt; and end with a call to
      &lt;function&gt;finalize&lt;/function&gt;.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.&lt;/para&gt;
  
--- 883,889 ----
      &lt;title&gt;Beginning and Ending &pooma; Programs&lt;/title&gt;
  
      &lt;para&gt;Every &pooma; program must begin with a call to
!     &lt;function&gt;initialize&lt;/function&gt; and end with a call to
      &lt;function&gt;finalize&lt;/function&gt;.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.&lt;/para&gt;
  
***************
*** 603,609 ****
      &lt;bridgehead id=&quot;sequential-begin_end-description&quot; renderas=&quot;sect2&quot;&gt;Description&lt;/bridgehead&gt;
  
       &lt;para&gt;Before its use, the &poomatoolkit; must be initialized by a
!      call to &lt;methodname&gt;initialize&lt;/methodname&gt;.  This usually occurs in
       the &lt;function&gt;main&lt;/function&gt; function.  The first form removes
       and processes any &pooma;-specific arguments from the
       command-line arguments &lt;varname&gt;argv&lt;/varname&gt; and
--- 933,939 ----
      &lt;bridgehead id=&quot;sequential-begin_end-description&quot; renderas=&quot;sect2&quot;&gt;Description&lt;/bridgehead&gt;
  
       &lt;para&gt;Before its use, the &poomatoolkit; must be initialized by a
!      call to &lt;function&gt;initialize&lt;/function&gt;.  This usually occurs in
       the &lt;function&gt;main&lt;/function&gt; function.  The first form removes
       and processes any &pooma;-specific arguments from the
       command-line arguments &lt;varname&gt;argv&lt;/varname&gt; and
***************
*** 625,631 ****
       architecture-specific initialization.  The function always
       returns &true;.&lt;/para&gt;
  
!      &lt;para&gt;&lt;methodname&gt;initialize&lt;/methodname&gt;'s alternative form
       assumes the &pooma;-specific and architecture-specific
       command-line arguments have already been removed from
       &lt;varname&gt;argv&lt;/varname&gt; and &lt;varname&gt;argc&lt;/varname&gt; and stored in
--- 955,961 ----
       architecture-specific initialization.  The function always
       returns &true;.&lt;/para&gt;
  
!      &lt;para&gt;&lt;function&gt;initialize&lt;/function&gt;'s alternative form
       assumes the &pooma;-specific and architecture-specific
       command-line arguments have already been removed from
       &lt;varname&gt;argv&lt;/varname&gt; and &lt;varname&gt;argc&lt;/varname&gt; and stored in
***************
*** 653,659 ****
      &lt;bridgehead id=&quot;sequential-begin_end-example&quot; renderas=&quot;sect2&quot;&gt;Example Program&lt;/bridgehead&gt;
  
       &lt;para&gt;Since every &pooma; program must call
!      &lt;methodname&gt;initialize&lt;/methodname&gt; and
       &lt;function&gt;finalize&lt;/function&gt;, the simplest &pooma; program also
       must call them.  This program also illustrates their usual
       use.&lt;/para&gt;
--- 983,989 ----
      &lt;bridgehead id=&quot;sequential-begin_end-example&quot; renderas=&quot;sect2&quot;&gt;Example Program&lt;/bridgehead&gt;
  
       &lt;para&gt;Since every &pooma; program must call
!      &lt;function&gt;initialize&lt;/function&gt; and
       &lt;function&gt;finalize&lt;/function&gt;, the simplest &pooma; program also
       must call them.  This program also illustrates their usual
       use.&lt;/para&gt;
*************** UNFINISHED&lt;/para&gt;
*** 862,868 ****
        specifying N indices, which collectively specify a single point
        in the input domain: A(i1, i2, ..., iN).&lt;/para&gt;
  
!      &lt;para&gt;The &pooma; multi-dimensional Array concept is similar to
        the &fortran; 90 array facility, but extends it in several
        ways. Both &pooma; and &fortran; arrays can have up to seven
        dimensions, and can serve as containers for arbitrary
--- 1192,1198 ----
        specifying N indices, which collectively specify a single point
        in the input domain: A(i1, i2, ..., iN).&lt;/para&gt;
  
!      &lt;para&gt;The &pooma; multidimensional Array concept is similar to
        the &fortran; 90 array facility, but extends it in several
        ways. Both &pooma; and &fortran; arrays can have up to seven
        dimensions, and can serve as containers for arbitrary
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.5
diff -c -p -r1.5 tutorial.xml
*** tutorial.xml	2002/01/14 17:33:34	1.5
--- tutorial.xml	2002/01/22 15:37:20
***************
*** 856,862 ****
    multiple values.  Like &array;s, &field;s can be accessed via
    data-parallel expressions and stencils and may be distributed
    across processors.  Unlike &array; cells, &field; cells exist in a
!   multi-dimensional volume so, e.g., distances between cells and
    normals to cells can be computed.&lt;/para&gt;
  
    &lt;para&gt;In this section, we implement the &amp;doof2d; two-dimensional
--- 856,862 ----
    multiple values.  Like &array;s, &field;s can be accessed via
    data-parallel expressions and stencils and may be distributed
    across processors.  Unlike &array; cells, &field; cells exist in a
!   multidimensional volume so, e.g., distances between cells and
    normals to cells can be computed.&lt;/para&gt;
  
    &lt;para&gt;In this section, we implement the &amp;doof2d; two-dimensional
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000885.html">Pooma Manual: Array and Domain Chapter
</A></li>
	<LI>Next message: <A HREF="000887.html">Manual: Wordsmithing Changes to First Four Chapters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#886">[ date ]</a>
              <a href="thread.html#886">[ thread ]</a>
              <a href="subject.html#886">[ subject ]</a>
              <a href="author.html#886">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
