<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Manual: Second Half Revised
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%3A%20Second%20Half%20Revised&In-Reply-To=%3C20020124183333.B7684%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000888.html">
   <LINK REL="Next"  HREF="000890.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Manual: Second Half Revised</H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%3A%20Second%20Half%20Revised&In-Reply-To=%3C20020124183333.B7684%40codesourcery.com%3E"
       TITLE="Manual: Second Half Revised">oldham at codesourcery.com
       </A><BR>
    <I>Fri Jan 25 02:33:33 UTC 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="000888.html">[pooma-dev] Manual: Wordsmithing Changes to First Four Chapte	rs
</A></li>
        <LI>Next message: <A HREF="000890.html">Manual Figures
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#889">[ date ]</a>
              <a href="thread.html#889">[ thread ]</a>
              <a href="subject.html#889">[ subject ]</a>
              <a href="author.html#889">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2002-Jan-24  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

	These changes continue moving the manual toward delivery.
	Unfinished sections remain in the DocBook source code but are not
	printed.  Wordsmithing concentrated on the Arrays, Engines,
	data-parallel, container views, and glossary chapters.  The
	incomplete index and unformatted bibliography sections are not
	printed.

	* Makefile (manual.dvi): Update dependences.
	(%.dvi): Improve rule.
	(clean): Add generated index.
	* arrays.xml: Wordsmithing, some format fixes, and some glossary
	links added.
	* bibliography.xml: Prevent printing of incomplete bibliography.
	* concepts.xml: Ensure table cells are aligned at the top of the
	rows.
	* data-parallel.xml: Wordsmithing, some format fixes, and some glossary
	links added.
	* glossary.xml: Wordsmithing and new 'see also' links added.
	(reference semantics): New entry.
	* manual.xml: Wordsmith partially-completed Engine chapter.
	Ensure table cells are aligned at the top of the rows.  Add
	introductory statement to POOMA installation appendix.  Turn off
	index.

Applied to the	mainline.
Approved by	you.

Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: Makefile
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/Makefile,v
retrieving revision 1.1
diff -c -p -r1.1 Makefile
*** Makefile	2002/01/14 17:33:33	1.1
--- Makefile	2002/01/25 02:15:02
*************** CXXFLAGS= -g -Wall -pedantic -W -Wstrict
*** 25,32 ****
  
  all: manual.ps
  
! manual.dvi: manual.xml introduction.xml tutorial.xml concepts.xml \
!             data-parallel.xml glossary.xml bibliography.xml
  
  %.all:	%.ps %.pdf %.html
  	chmod 644 $*.ps $*.pdf
--- 25,33 ----
  
  all: manual.ps
  
! manual.dvi: manual.xml introduction.xml template.xml tutorial.xml \
!             concepts.xml arrays.xml data-parallel.xml glossary.xml \
!             bibliography.xml
  
  %.all:	%.ps %.pdf %.html
  	chmod 644 $*.ps $*.pdf
*************** manual.dvi: manual.xml introduction.xml 
*** 50,58 ****
  
  # This rule assumes index creation.
  %.dvi:	%.xml genindex.sgm
! 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $&lt;
! 	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index
! 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) $(XML) $&lt; &amp;&amp; jadetex $*.tex &amp;&amp; jadetex $*.tex &amp;&amp; jadetex $*.tex
  
  genindex.sgm:
  	perl collateindex.pl $(INDEXOPTIONS) -N -o $@
--- 51,59 ----
  
  # This rule assumes index creation.
  %.dvi:	%.xml genindex.sgm
! 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $&lt; &amp;&amp; \
! 	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index &amp;&amp; \
! 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) -V tex-backend $(XML) $&lt; &amp;&amp; jadetex $*.tex &amp;&amp; jadetex $*.tex &amp;&amp; jadetex $*.tex
  
  genindex.sgm:
  	perl collateindex.pl $(INDEXOPTIONS) -N -o $@
*************** mproof-%.ps:	%.mp
*** 70,73 ****
  	detex $&lt; &gt; $@
  
  clean:
! 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.mpx mpxerr.tex HTML.index manual.tex
--- 71,74 ----
  	detex $&lt; &gt; $@
  
  clean:
! 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.mpx mpxerr.tex HTML.index manual.tex genindex.sgm
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.3
diff -c -p -r1.3 arrays.xml
*** arrays.xml	2002/01/24 05:11:21	1.3
--- arrays.xml	2002/01/25 02:15:03
***************
*** 2,44 ****
    &lt;chapter id=&quot;arrays&quot;&gt;
     &lt;title&gt;&array; Containers&lt;/title&gt;
  
!    &lt;para&gt;A container is a class holding objects.  &array;s are one of
!    the two most widely used &pooma; containers since they model the
!    mathematical concept of mapping indices from domains to values.
     &pooma; &array;s extend built-in &cc; arrays by supporting a wider
!    variety of domains, automatically handling memory allocations, and
!    supporting first-class status.  For example, they may be used as
     operands and in assignments.  In this chapter, we introduce the
     concept of containers, the mathematical concept of arrays, and the
!    &pooma; concept for &array;s.  Before illustrating how to declare
!    &array;s, we introduce &domain;s, which specify the sets of
     indices.  After describing how to declare the various types of
!    &domain;s, we describe how to declare and use &array;s.  This is
!    illustrated in a &amp;doof2d; implementation using &array;s.  We end
!    with a description of their implementation.&lt;/para&gt;
  
  
     &lt;section id=&quot;arrays-containers&quot;&gt;
      &lt;title&gt;Containers&lt;/title&gt;
  
      &lt;para&gt;A &lt;glossterm
!     linkend=&quot;glossary-container&quot;&gt;&lt;firstterm&gt;container class
!     expression&lt;/firstterm&gt;&lt;/glossterm&gt; is a class with the main
!     purpose of holding objects.  These stored objects, called
!     &lt;glossterm linkend=&quot;glossary-container_value&quot;&gt;&lt;firstterm&gt;container
      values&lt;/firstterm&gt;&lt;/glossterm&gt; or more simply
!     &lt;quote&gt;values&lt;/quote&gt; or elements&lt;quote&gt;&lt;/quote&gt;, may be accessed
      and changed, usually using indices.  &lt;quote&gt;Container
!     class&lt;/quote&gt; is usually abbreviated
      &lt;quote&gt;container&lt;/quote&gt;.&lt;/para&gt;
  
      &lt;para&gt;The six &pooma; containers can be categorized into two
      groups.  Mathematical containers include &tensor;s, &matrix;s, and
!     &vector;s, modeling tensors, matrices, and vectors, respectively.
      Storage containers include &array;s, &dynamicarray;s, and
      &field;s.  In this chapter, we focus on simplest of these:
!     &array;s.  The other containers will be described in subsequent
!     chapters.&lt;/para&gt;
  
      &lt;para&gt;&c;&nbsp;has built-in arrays, and the &cc; Standard Library
      provides &lt;type&gt;map&lt;/type&gt;s, &lt;type&gt;vector&lt;/type&gt;s,
--- 2,46 ----
    &lt;chapter id=&quot;arrays&quot;&gt;
     &lt;title&gt;&array; Containers&lt;/title&gt;
  
!    &lt;para&gt;A container is an object holding objects.  &array;s are one
!    of the two most widely used &pooma; containers since they model the
!    mathematical concept of mapping from domain indices to values.
     &pooma; &array;s extend built-in &cc; arrays by supporting a wider
!    variety of domains, automatically handling memory allocation, and
!    having first-class status.  For example, they may be used as
     operands and in assignments.  In this chapter, we introduce the
     concept of containers, the mathematical concept of arrays, and the
!    &pooma; implementation of &array;s.  Before illustrating how to
!    declare &array;s, we introduce &domain;s, which specify the sets of
     indices.  After describing how to declare the various types of
!    &domain;s, we describe how to declare and use &array;s.
! &lt;![%unfinished;[
!    We end
!    with a description of their implementation.
! ]]&gt;  &lt;!-- end unfinished --&gt;
!    &lt;/para&gt;
  
  
     &lt;section id=&quot;arrays-containers&quot;&gt;
      &lt;title&gt;Containers&lt;/title&gt;
  
      &lt;para&gt;A &lt;glossterm
!     linkend=&quot;glossary-container&quot;&gt;&lt;firstterm&gt;container
!     class&lt;/firstterm&gt;&lt;/glossterm&gt; is a class whose main purpose is to
!     hold objects.  These stored objects, called &lt;glossterm
!     linkend=&quot;glossary-container_value&quot;&gt;&lt;firstterm&gt;container
      values&lt;/firstterm&gt;&lt;/glossterm&gt; or more simply
!     &lt;quote&gt;values&lt;/quote&gt; or &lt;quote&gt;elements&lt;/quote&gt;, may be accessed
      and changed, usually using indices.  &lt;quote&gt;Container
!     class&lt;/quote&gt; is usually abbreviated as
      &lt;quote&gt;container&lt;/quote&gt;.&lt;/para&gt;
  
      &lt;para&gt;The six &pooma; containers can be categorized into two
      groups.  Mathematical containers include &tensor;s, &matrix;s, and
!     &vector;s, which model tensors, matrices, and vectors, respectively.
      Storage containers include &array;s, &dynamicarray;s, and
      &field;s.  In this chapter, we focus on simplest of these:
!     &array;s.  &dynamicarray;s are also described.&lt;/para&gt;
  
      &lt;para&gt;&c;&nbsp;has built-in arrays, and the &cc; Standard Library
      provides &lt;type&gt;map&lt;/type&gt;s, &lt;type&gt;vector&lt;/type&gt;s,
***************
*** 47,100 ****
      more functionality.  They automatically handle memory allocation
      and deallocation and can be used in expressions and on the
      left-hand side of assignments.  Since &pooma; containers separate
!     the container concepts of accessing and using values from storing
!     values, value storage can be optimized to specific needs.  For
!     example, if most of an &array;'s values are known to be the same
!     most of the time, a compressible engine can be used.  Whenever all
!     the array's values are the same, it stores only one value.  At
!     other times, it stores all the values.  Engines will be discussed
!     in &lt;xref linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
     &lt;/section&gt;
  
  
     &lt;section id=&quot;arrays-arrays&quot;&gt;
      &lt;title&gt;&array;s&lt;/title&gt;
  
!     &lt;para&gt;Mathematically, an array maps indices from a domain to
!     values.  Usually, the domain consists of a one-dimensional
!     integral interval or it may be multidimensional.  &pooma;'s
      &array; container class implements this idea.  Given an index,
!     i.e., a position in an &array;'s &domain;, it returns the associated
!     value, either by returning a stored value or by computing it.  The
!     use of indices, which are usually integral tuples but need not be
!     zero-based or even consist of all possible integral tuples in a
!     multidimensional range.  Using indices permits constant-time
      access to values although computing a particular value may require
      significant time.&lt;/para&gt;
  
      &lt;para&gt;&pooma; &array;s are &lt;glossterm
      linkend=&quot;glossary-first_class&quot;&gt;first-class
!     types&lt;firstterm&gt;&lt;/firstterm&gt;&lt;/glossterm&gt; so they can be used more
!     widely than built-in &cc; arrays.  For example, &array;s can be
!     used as operands and in assignment statements.  The statement
!     &lt;statement&gt;a = a + b;&lt;/statement&gt; adds corresponding elements of
      &array;s &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt;, assigning
      the sums to the &array; &lt;varname&gt;a&lt;/varname&gt;.  The statement
!     treats each array as one object, rather than requiring the use of
      one or more loops to access individual values.  Data-parallel
!     statements are further discussed in &lt;xref
      linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt;.  &array;s also handle their own
      memory allocation and deallocation.  For example, the &array;
      declaration &lt;statement&gt;Array&lt;2, double, Brick&gt;
      a(vertDomain)&lt;/statement&gt; creates an
      &array;&nbsp;&lt;varname&gt;a&lt;/varname&gt;, allocating whatever memory it
      needs.  When &lt;varname&gt;a&lt;/varname&gt; goes out of scope, it and its
!     memory is automatically deallocated.  Automatic memory allocation
!     and deallocation also eases copying.  As we mentioned above, an
!     &array;'s &engine; stores or computes its values so it, not the
!     &array; itself, is responsible for memory allocation and
!     deallocation.  Fortunately, this distinction is usually hidden
!     from the &pooma; user.&lt;/para&gt;
  
      &lt;para&gt;Individual &array; values can be accessed using parentheses,
      not square brackets, as for &cc; arrays.  For example,
--- 49,98 ----
      more functionality.  They automatically handle memory allocation
      and deallocation and can be used in expressions and on the
      left-hand side of assignments.  Since &pooma; containers separate
!     the concepts of accessing and using values from the concept of
!     storing values, value storage can be optimized to specific needs.
!     For example, if most of an &array;'s values are known to be
!     identical most of the time, a compressible engine can be used.
!     Whenever all the array's values are identical, it stores only one
!     value.  At other times, it stores all the values.  Engines will be
!     discussed in &lt;xref linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
     &lt;/section&gt;
  
  
     &lt;section id=&quot;arrays-arrays&quot;&gt;
      &lt;title&gt;&array;s&lt;/title&gt;
  
!     &lt;para&gt;Mathematically, an array maps domain indices to values.
!     Usually, the domain consists of a one-dimensional integral
!     interval or it may be a multidimensional domain.  &pooma;'s
      &array; container class implements this idea.  Given an index,
!     i.e., a position in an &array;'s &domain;, it returns the
!     associated value, either by returning a stored value or by
!     computing it.  The indices are usually integral tuples but need
!     not be zero-based or even consist of all possible integral tuples
!     in a multidimensional range.  Using indices permits constant-time
      access to values although computing a particular value may require
      significant time.&lt;/para&gt;
  
      &lt;para&gt;&pooma; &array;s are &lt;glossterm
      linkend=&quot;glossary-first_class&quot;&gt;first-class
!     objects&lt;firstterm&gt;&lt;/firstterm&gt;&lt;/glossterm&gt; so they can be used
!     more easily than built-in &cc; arrays.  For example, &array;s can
!     be used as operands and in assignment statements.  The statement
!     &lt;statement&gt;a = a + b;&lt;/statement&gt; adds corresponding values of
      &array;s &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt;, assigning
      the sums to the &array; &lt;varname&gt;a&lt;/varname&gt;.  The statement
!     treats each array as an object, rather than requiring the use of
      one or more loops to access individual values.  Data-parallel
!     statements such as this are further discussed in &lt;xref
      linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt;.  &array;s also handle their own
      memory allocation and deallocation.  For example, the &array;
      declaration &lt;statement&gt;Array&lt;2, double, Brick&gt;
      a(vertDomain)&lt;/statement&gt; creates an
      &array;&nbsp;&lt;varname&gt;a&lt;/varname&gt;, allocating whatever memory it
      needs.  When &lt;varname&gt;a&lt;/varname&gt; goes out of scope, it and its
!     memory are automatically deallocated.  Automatic memory allocation
!     and deallocation also eases copying.&lt;/para&gt;
  
      &lt;para&gt;Individual &array; values can be accessed using parentheses,
      not square brackets, as for &cc; arrays.  For example,
***************
*** 108,125 ****
  
      &lt;para&gt;A &lt;glossterm
      linkend=&quot;glossary-domain&quot;&gt;&lt;firstterm&gt;domain&lt;/firstterm&gt;&lt;/glossterm&gt;
!     specifies the set of points on which an &array; can define values.
!     These indices are the arguments placed within parentheses when
!     selecting particular values, as described previously.  A domain
!     supported both by &array;s and by built-in &cc; arrays is an
      interval [0,n-1] of integers containing all integers {0, 1, 2,
      &hellip;, n-1}.  For &cc;, every integer in the interval must be
      included, and the minimum index must be zero.  &pooma; expands the
      set of permissible domains to support intervals with nonzero
!     minimal indices and strides and by adding other choices.&lt;/para&gt;
  
!     &lt;para&gt;In &pooma;, &domain;s implement domains.  There are four
!     different categories:
       &lt;variablelist&gt;
        &lt;varlistentry&gt;
         &lt;term&gt;&loc;&lt;/term&gt;
--- 106,123 ----
  
      &lt;para&gt;A &lt;glossterm
      linkend=&quot;glossary-domain&quot;&gt;&lt;firstterm&gt;domain&lt;/firstterm&gt;&lt;/glossterm&gt;
!     specifies the set of points on which an array can define values.
!     These indices are the arguments placed within parentheses to
!     select particular values, as described previously.  A domain
!     supported both by &array;s and by built-in &cc; arrays is the
      interval [0,n-1] of integers containing all integers {0, 1, 2,
      &hellip;, n-1}.  For &cc;, every integer in the interval must be
      included, and the minimum index must be zero.  &pooma; expands the
      set of permissible domains to support intervals with nonzero
!     minimal indices, nonzero strides, and other options.&lt;/para&gt;
  
!     &lt;para&gt;In &pooma;, &domain; classes implement domains.  There are
!     four different categories:
       &lt;variablelist&gt;
        &lt;varlistentry&gt;
         &lt;term&gt;&loc;&lt;/term&gt;
***************
*** 150,156 ****
         &lt;/listitem&gt;
        &lt;/varlistentry&gt;
       &lt;/variablelist&gt;
!     One-dimensional and multidimensional versions of each categories
      are supported.  A multidimensional &domain; consists of the direct
      product of one-dimensional &domain;s.  For example, the first
      dimension of a two-dimensional interval [0,3]x[2,9] is the
--- 148,154 ----
         &lt;/listitem&gt;
        &lt;/varlistentry&gt;
       &lt;/variablelist&gt;
!     One-dimensional and multidimensional versions of the categories
      are supported.  A multidimensional &domain; consists of the direct
      product of one-dimensional &domain;s.  For example, the first
      dimension of a two-dimensional interval [0,3]x[2,9] is the
***************
*** 178,198 ****
      example, [2:4:2,6:4:-2] contains (2,6), (2,4), (4,6),
      and&nbsp;(4,4).&lt;/para&gt;
  
!     &lt;para&gt;All the &domain; categories listed above except &grid; can be
!     represented using domain triplet notation.  Since the triplet
      [7:7:1] represents {7}, or more simply&nbsp;7, it can also
!     represent &lt;statement&gt;Loc&lt;1&gt;(7)&lt;/statement&gt;.  Multidimensional
!     &loc;s are similarly represented.  For example,
      [0:0:1,10:10:1,2:2:1] represents
      &lt;statement&gt;Loc&lt;3&gt;(0,10,2)&lt;/statement&gt;, but it is frequently
      abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
!     [a:b:1], while a &range; has specific stride&nbsp;s:
      [a:b:s].&lt;/para&gt;
  
!     &lt;para&gt;&domain;s can be constructed by combining &domain;s of smaller
!     dimension.  For example, since a two-dimensional &interval; is the
!     direct product of two one-dimensional &interval;s, it can be
!     specified using two one-dimensional &interval;s.  For example,
      &lt;statement&gt;Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
      Interval&lt;1&gt;(4,5))&lt;/statement&gt; creates a [2:3:1,4:5:1]
      &domain;.  The resulting dimensionality equals the sum of the
--- 176,197 ----
      example, [2:4:2,6:4:-2] contains (2,6), (2,4), (4,6),
      and&nbsp;(4,4).&lt;/para&gt;
  
!     &lt;para&gt;All the &domain; categories listed above except &grid; can
!     be represented using domain triplet notation.  Since the triplet
      [7:7:1] represents {7}, or more simply&nbsp;7, it can also
!     represent the one-dimensional &lt;statement&gt;Loc&lt;1&gt;(7)&lt;/statement&gt;.
!     Multidimensional &loc;s are similarly represented.  For example,
      [0:0:1,10:10:1,2:2:1] represents
      &lt;statement&gt;Loc&lt;3&gt;(0,10,2)&lt;/statement&gt;, but it is frequently
      abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
!     [a:b:1], while a &range; has specific stride&nbsp;s, e.g.,
      [a:b:s].&lt;/para&gt;
  
!     &lt;para&gt;&domain;s can be constructed by combining &domain;s with
!     smaller dimension.  For example, since a two-dimensional
!     &interval; is the direct product of two one-dimensional
!     &interval;s, it can be specified using two one-dimensional
!     &interval;s.  For example,
      &lt;statement&gt;Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
      Interval&lt;1&gt;(4,5))&lt;/statement&gt; creates a [2:3:1,4:5:1]
      &domain;.  The resulting dimensionality equals the sum of the
***************
*** 220,248 ****
      units to the right by adding two.  Multiplying a &domain; by two
      multiplies its triplet's beginnings, endings, and strides by two.
      &pooma; users rarely need to compare &domain;s, but we describe
!     operating with the less-than operator on &interval;s.  &interval;
      &lt;varname&gt;d1&lt;/varname&gt; &lt; &interval; &lt;varname&gt;d2&lt;/varname&gt; if the
      length of &lt;varname&gt;d1's&lt;/varname&gt; interval is less than
      &lt;varname&gt;d2&lt;/varname&gt;'s or, if equal, its beginning value is
!     smaller.  &domain; arithmetic is frequently used with data-parallel
!     statements and container views.  These will be discussed in &lt;xref
!     linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt; and &lt;xref
      linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
      &lt;para&gt;The current &pooma; implementation supports &domain;s with
      dimensionality between one and seven, inclusive.  Since most
      scientific computations use one, two, or three dimensions, this is
!     usually sufficient.  If more dimensions are needed, they can be
!     added to the source code.&lt;/para&gt;
  
  
      &lt;section id=&quot;arrays-domains-declarations&quot;&gt;
       &lt;title&gt;Declaring &domain;s&lt;/title&gt;
  
       &lt;para&gt;Since &domain;s are mainly used to declare container
!      domains, we focus on declaring &domain;s.  We describe a few
!      &domain; operations but most, including arithmetic operations with
!      &domain;s, are described in &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
       &lt;para&gt;All &domain; declarations require a dimension template
       parameter&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  This positive integer
--- 219,248 ----
      units to the right by adding two.  Multiplying a &domain; by two
      multiplies its triplet's beginnings, endings, and strides by two.
      &pooma; users rarely need to compare &domain;s, but we describe
!     operating with the less-than operator on &interval;s: &interval;
      &lt;varname&gt;d1&lt;/varname&gt; &lt; &interval; &lt;varname&gt;d2&lt;/varname&gt; if the
      length of &lt;varname&gt;d1's&lt;/varname&gt; interval is less than
      &lt;varname&gt;d2&lt;/varname&gt;'s or, if equal, its beginning value is
!     smaller.  &domain; arithmetic is frequently used with
!     data-parallel statements and container views.  These will be
!     discussed in &lt;xref linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt; and &lt;xref
      linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
      &lt;para&gt;The current &pooma; implementation supports &domain;s with
      dimensionality between one and seven, inclusive.  Since most
      scientific computations use one, two, or three dimensions, this is
!     usually sufficient.  If more dimensions than seven are needed,
!     they can be added to the source code.&lt;/para&gt;
  
  
      &lt;section id=&quot;arrays-domains-declarations&quot;&gt;
       &lt;title&gt;Declaring &domain;s&lt;/title&gt;
  
       &lt;para&gt;Since &domain;s are mainly used to declare container
!      domains, we focus on declaring &domain;s.  We subsequently
!      describe a few &domain; operations but most, including arithmetic
!      operations with &domain;s, are described in &lt;xref
!      linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
       &lt;para&gt;All &domain; declarations require a dimension template
       parameter&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  This positive integer
***************
*** 255,267 ****
       one-dimensional &domain;s carry over to multidimensional
       ones.&lt;/para&gt;
  
!      &lt;para&gt;To declare a &domain;, one must include the
!      &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; header
!      file.  However, most &pooma; programs declare &domain;s to use them
!      when constructing containers.  The container header files
!      automatically include &lt;filename
!      class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; so no explicit
!      inclusion is usually necessary.&lt;/para&gt;
  
  
       &lt;section id=&quot;arrays-domains-declarations-loc&quot;&gt;
--- 255,266 ----
       one-dimensional &domain;s carry over to multidimensional
       ones.&lt;/para&gt;
  
!      &lt;para&gt;To declare a &domain;, one must include the &lt;filename
!      class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; header file.
!      However, most &pooma; programs use &domain;s when constructing
!      containers.  The storage container header files automatically
!      include &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt;
!      so no explicit inclusion is usually necessary.&lt;/para&gt;
  
  
       &lt;section id=&quot;arrays-domains-declarations-loc&quot;&gt;
***************
*** 292,301 ****
  	  &lt;entry&gt;&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;points to zero.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
--- 291,300 ----
  	  &lt;entry&gt;&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;indicates zero.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
***************
*** 330,345 ****
        will be assigned later.  For small &domain;s such as &loc;s, the
        time savings from not initializing is small, but the
        functionality is still available.  The constructor taking one
!       argument with type&nbsp;&lt;type&gt;&domaintemplate;1&lt;/type&gt; converts this argument to
!       an integer to specify the point.  The template
!       type&nbsp;&lt;type&gt;&domaintemplate;1&lt;/type&gt; may be any type that can be converted
!       to an integer, e.g., &bool;, &char;, &int;, or &double;.  The
!       constructors taking two and three arguments of templatized types
!       facilitate converting an &interval; and a &range; into a &loc;.
!       Since a &loc; represents a single point, the &interval;'s or
!       &range;'s first two arguments must be equal.  The stride is
!       ignored.  Again, the templatized types may be any type that can
!       be converted into an integer.&lt;/para&gt;
  
        &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-loc-multi_d_table&quot;&gt;
--- 329,344 ----
        will be assigned later.  For small &domain;s such as &loc;s, the
        time savings from not initializing is small, but the
        functionality is still available.  The constructor taking one
!       argument with type&nbsp;&lt;type&gt;&domaintemplate;1&lt;/type&gt; converts
!       this argument to an integer to specify the point.  The template
!       type&nbsp;&lt;type&gt;&domaintemplate;1&lt;/type&gt; may be any type that
!       can be converted to an integer, e.g., &bool;, &char;, &int;, or
!       &double;.  The constructors taking two and three arguments of
!       templatized types facilitate converting an &intervalone; and a
!       &rangeone; into a &locone;.  Since a &loc; represents a single
!       point, the &interval;'s or &range;'s first two arguments must be
!       equal.  The stride is ignored.  Again, the templatized types may
!       be any type that can be converted into an integer.&lt;/para&gt;
  
        &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-loc-multi_d_table&quot;&gt;
***************
*** 359,368 ****
  	  template parameters.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;points to zero.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
--- 358,367 ----
  	  template parameters.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;indicates zero.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
***************
*** 465,471 ****
  	  &lt;entry&gt;&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized interval.&lt;/entry&gt;
--- 464,470 ----
  	  &lt;entry&gt;&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized interval.&lt;/entry&gt;
***************
*** 476,491 ****
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &intervalone;.  See the text for an explanation.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &intervalone; with the integers converted from
  	  &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &intervalone; with the integers converted from
  	  &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.
  	  &lt;varname&gt;t3&lt;/varname&gt; must equal&nbsp;1.&lt;/entry&gt;
  	 &lt;/row&gt;
--- 475,490 ----
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an &intervalone;.  See the text for an explanation.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an &intervalone; with the integers converted from
  	  &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an &intervalone; with the integers converted from
  	  &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.
  	  &lt;varname&gt;t3&lt;/varname&gt; must equal&nbsp;1.&lt;/entry&gt;
  	 &lt;/row&gt;
***************
*** 497,512 ****
        constructors except that &intervalone;s can have differing
        beginning and ending points.  See &lt;xref
        linkend=&quot;arrays-domains-declarations-interval-one_d_table&quot;&gt;&lt;/xref&gt;.
!       The default constructor creates an empty, uninitialized interval,
!       which should not be used before assigning it values.  If the
!       one-parameter constructor's argument is a &domain; object, it must
!       be a one-dimensional &domain; object which is copied into an
!       &interval; if possible; for example, it must have unit stride.
!       If the one-parameter constructor's argument is not a &domain;
!       object, it must be convertible to an
        integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and an interval [0:e-1:1]
!       starting at zero is constructed.  If two arguments are specified,
!       they are assumed to be convertible to integers
        &lt;varname&gt;b&lt;/varname&gt; and &lt;varname&gt;e&lt;/varname&gt;, specifying the
        interval [b:e:1].  The three-parameter constructor is similar,
        with the third argument specifying a stride, which must be
--- 496,512 ----
        constructors except that &intervalone;s can have differing
        beginning and ending points.  See &lt;xref
        linkend=&quot;arrays-domains-declarations-interval-one_d_table&quot;&gt;&lt;/xref&gt;.
!       The default constructor creates an empty, uninitialized
!       interval, which should not be used before assigning it values.
!       If the one-parameter constructor's argument is a &domain;
!       object, it must be a one-dimensional &domain; object which is
!       converted into an &interval; if possible; for example, it must have
!       unit stride.  If the one-parameter constructor's argument is not
!       a &domain; object, it must be convertible to an
        integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and an interval [0:e-1:1]
!       starting at zero is constructed.  Note e-1, not e, is used so
!       the &intervalone; has e indices.  If two arguments are
!       specified, they are assumed to be convertible to integers
        &lt;varname&gt;b&lt;/varname&gt; and &lt;varname&gt;e&lt;/varname&gt;, specifying the
        interval [b:e:1].  The three-parameter constructor is similar,
        with the third argument specifying a stride, which must be
***************
*** 530,536 ****
  	  template parameters.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
--- 530,536 ----
  	  template parameters.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
***************
*** 541,578 ****
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; object.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates a &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tbody&gt;
         &lt;/tgroup&gt;
--- 541,578 ----
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an &interval; using the given &domain; object.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
! 	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tbody&gt;
         &lt;/tgroup&gt;
***************
*** 635,641 ****
  	  &lt;entry&gt;&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized range.&lt;/entry&gt;
--- 635,641 ----
  	  &lt;entry&gt;&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized range.&lt;/entry&gt;
***************
*** 665,684 ****
        &lt;/table&gt;
  
        &lt;para&gt;&rangeone; constructors are the same as &intervalone;
!       constructors except they create ranges, not intervals.  See &lt;xref
        linkend=&quot;arrays-domains-declarations-range-one_d_table&quot;&gt;&lt;/xref&gt;.
        The default constructor creates an empty, uninitialized range,
        which should not be used before assigning it values.  If the
!       one-parameter constructor's argument is a &domain; object, it must
!       be a one-dimensional &domain; object which is copied into a &range;
!       if possible.  If the one-parameter constructor's argument is not
!       a &domain; object, it must be convertible to an
        integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and a range [0:e-1:1] starting
!       at zero is constructed.  If two arguments are specified, they are
!       assumed to be convertible to integers &lt;varname&gt;b&lt;/varname&gt; and
!       &lt;varname&gt;e&lt;/varname&gt;, specifying the range [b:e:1].  The
!       three-parameter constructor is similar, with the third argument
!       specifying a stride.&lt;/para&gt;
  
        &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-ranges-multi_d_table&quot;&gt;
--- 665,686 ----
        &lt;/table&gt;
  
        &lt;para&gt;&rangeone; constructors are the same as &intervalone;
!       constructors except they create ranges, not intervals.  See
!       &lt;xref
        linkend=&quot;arrays-domains-declarations-range-one_d_table&quot;&gt;&lt;/xref&gt;.
        The default constructor creates an empty, uninitialized range,
        which should not be used before assigning it values.  If the
!       one-parameter constructor's argument is a &domain; object, it
!       must be a one-dimensional &domain; object which is converted
!       into a &range; if possible.  If the one-parameter constructor's
!       argument is not a &domain; object, it must be convertible to an
        integer&nbsp;&lt;varname&gt;e&lt;/varname&gt; and a range [0:e-1:1] starting
!       at zero is constructed.  Note e-1, not e, is used so the
!       &intervalone; has e indices.  If two arguments are specified,
!       they are assumed to be convertible to integers
!       &lt;varname&gt;b&lt;/varname&gt; and &lt;varname&gt;e&lt;/varname&gt;, specifying the
!       range [b:e:1].  The three-parameter constructor is similar, with
!       the third argument specifying a stride.&lt;/para&gt;
  
        &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-declarations-ranges-multi_d_table&quot;&gt;
***************
*** 698,704 ****
  	  template parameters.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
--- 700,706 ----
  	  template parameters.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
***************
*** 807,813 ****
  	  &lt;entry&gt;&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized grid.&lt;/entry&gt;
--- 809,815 ----
  	  &lt;entry&gt;&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized grid.&lt;/entry&gt;
***************
*** 843,856 ****
  
        &lt;para&gt;&gridone;s with irregularly spaced points can be
        constructed using &indirectionlistint;s.  For example,
!  &lt;programlisting&gt;
!  IndirectionList&lt;int&gt; list(4);
!  list(0) = 2;
!  list(1) = 5;
!  list(2) = 6;
!  list(3) = 9;
!  Grid&lt;1&gt; g(list);
!  &lt;/programlisting&gt; constructs an empty &indirectionlistint;, fills it
        with ascending values, and then creates a &gridone; containing
        {2, 5, 6, 9}.  When creating a list, its size must be specified.
        Subsequently, its values can be assigned.  &indirectionlist;s can
--- 845,858 ----
  
        &lt;para&gt;&gridone;s with irregularly spaced points can be
        constructed using &indirectionlistint;s.  For example,
! &lt;programlisting&gt;
! IndirectionList&lt;int&gt; list(4);
! list(0) = 2;
! list(1) = 5;
! list(2) = 6;
! list(3) = 9;
! Grid&lt;1&gt; g(list);
! &lt;/programlisting&gt; constructs an empty &indirectionlistint;, fills it
        with ascending values, and then creates a &gridone; containing
        {2, 5, 6, 9}.  When creating a list, its size must be specified.
        Subsequently, its values can be assigned.  &indirectionlist;s can
***************
*** 885,891 ****
  	  parameters.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &grid;, to be assigned a value later.&lt;/entry&gt;
--- 887,893 ----
  	  parameters.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tfoot&gt;
! 	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
  	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &grid;, to be assigned a value later.&lt;/entry&gt;
***************
*** 961,973 ****
  
       &lt;para&gt;Since an &array; can be queried for its domain, we briefly
       describe some &domain; operations.  A fuller description,
!      including arithmetic operations, occur in &lt;xref
       linkend=&quot;views&quot;&gt;&lt;/xref&gt;.  As we mentioned in &lt;xref
       linkend=&quot;arrays-domains-declarations&quot;&gt;&lt;/xref&gt;, the &lt;filename
       class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; header file
!      declares &domain;s, but most container header files automatically
!      include &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt;
!      so no explicit inclusion of is usually necessary.&lt;/para&gt;
  
       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-use-table&quot;&gt;
--- 963,976 ----
  
       &lt;para&gt;Since an &array; can be queried for its domain, we briefly
       describe some &domain; operations.  A fuller description,
!      including arithmetic operations, occurs in &lt;xref
       linkend=&quot;views&quot;&gt;&lt;/xref&gt;.  As we mentioned in &lt;xref
       linkend=&quot;arrays-domains-declarations&quot;&gt;&lt;/xref&gt;, the &lt;filename
       class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; header file
!      declares &domain;s, but most storage container header files
!      automatically include &lt;filename
!      class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; so no explicit
!      inclusion is usually necessary.&lt;/para&gt;
  
       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-use-table&quot;&gt;
***************
*** 982,993 ****
         &lt;/thead&gt;
         &lt;tfoot&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;D&lt;/type&gt; abbreviates the particular &domain;
! 	 type, e.g., &interval; or &grid;.  Other &domain; accessors
! 	 are described in &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tfoot&gt;
!        &lt;tbody&gt;
  	&lt;row rowsep=&quot;1&quot;&gt;
  	 &lt;entry&gt;Multidimensional &domain; Accessors&lt;/entry&gt;
  	&lt;/row&gt;
--- 985,996 ----
         &lt;/thead&gt;
         &lt;tfoot&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;D&lt;/type&gt; abbreviates a particular &domain; type,
! 	 e.g., &interval; or &grid;.  Other &domain; accessors are
! 	 described in &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tfoot&gt;
!        &lt;tbody valign=&quot;top&quot;&gt;
  	&lt;row rowsep=&quot;1&quot;&gt;
  	 &lt;entry&gt;Multidimensional &domain; Accessors&lt;/entry&gt;
  	&lt;/row&gt;
***************
*** 1030,1041 ****
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;statement&gt;D&lt;1&gt;::iterator begin()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns a bidirectional iterator pointing to the
  	 beginning domain index.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;statement&gt;D&lt;1&gt;::iterator end()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns a bidirectional iterator pointing to the ending
  	 domain index.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tbody&gt;
--- 1033,1044 ----
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;statement&gt;D&lt;1&gt;::iterator begin()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns a forward iterator pointing to the
  	 beginning domain index.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;statement&gt;D&lt;1&gt;::iterator end()&lt;/statement&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;returns a forward iterator pointing to the ending
  	 domain index.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tbody&gt;
***************
*** 1054,1060 ****
       one-dimensional &domain;s.  The &lt;methodname&gt;operator[](int
       dimension)&lt;/methodname&gt; operator extracts the one-dimensional
       &domain; corresponding to its parameter.  For example, the three
!      &lt;type&gt;Range&lt;1&gt;&lt;/type&gt; (one-dimensional) &domain;s can be
       extracted from a &lt;type&gt;Range&lt;3&gt;&lt;/type&gt;
       object&nbsp;&lt;varname&gt;r&lt;/varname&gt; using
       &lt;statement&gt;r[0]&lt;/statement&gt;, &lt;statement&gt;r[1]&lt;/statement&gt;, and
--- 1057,1063 ----
       one-dimensional &domain;s.  The &lt;methodname&gt;operator[](int
       dimension)&lt;/methodname&gt; operator extracts the one-dimensional
       &domain; corresponding to its parameter.  For example, the three
!      one-dimensional &lt;type&gt;Range&lt;1&gt;&lt;/type&gt; &domain;s can be
       extracted from a &lt;type&gt;Range&lt;3&gt;&lt;/type&gt;
       object&nbsp;&lt;varname&gt;r&lt;/varname&gt; using
       &lt;statement&gt;r[0]&lt;/statement&gt;, &lt;statement&gt;r[1]&lt;/statement&gt;, and
***************
*** 1069,1075 ****
       &lt;methodname&gt;first&lt;/methodname&gt; and &lt;methodname&gt;last&lt;/methodname&gt;
       member functions return the domain's beginning and ending
       indices.  The &lt;methodname&gt;begin&lt;/methodname&gt; and
!      &lt;methodname&gt;end&lt;/methodname&gt; member functions return input
       iterators pointing to these respective locations.  They have type
       &lt;type&gt;D&lt;1&gt;::iterator&lt;/type&gt;, where &lt;type&gt;D&lt;/type&gt;
       abbreviates the &domain;'s type, e.g., &interval; or &grid;.
--- 1072,1078 ----
       &lt;methodname&gt;first&lt;/methodname&gt; and &lt;methodname&gt;last&lt;/methodname&gt;
       member functions return the domain's beginning and ending
       indices.  The &lt;methodname&gt;begin&lt;/methodname&gt; and
!      &lt;methodname&gt;end&lt;/methodname&gt; member functions return forward
       iterators pointing to these respective locations.  They have type
       &lt;type&gt;D&lt;1&gt;::iterator&lt;/type&gt;, where &lt;type&gt;D&lt;/type&gt;
       abbreviates the &domain;'s type, e.g., &interval; or &grid;.
***************
*** 1077,1086 ****
       --&gt; The &lt;methodname&gt;min&lt;/methodname&gt; and
       &lt;methodname&gt;max&lt;/methodname&gt; member functions return the minimum
       and maximum indices in the &domain; object, respectively.  For
!      &locone; and &intervalone;, these are the same as
       &lt;methodname&gt;first&lt;/methodname&gt; and &lt;methodname&gt;last&lt;/methodname&gt;,
!      but &rangeone; and &gridone; can have their largest index at the
!      beginning of their &domain;s.&lt;/para&gt;
      &lt;/section&gt;
     &lt;/section&gt;
  
--- 1080,1089 ----
       --&gt; The &lt;methodname&gt;min&lt;/methodname&gt; and
       &lt;methodname&gt;max&lt;/methodname&gt; member functions return the minimum
       and maximum indices in the &domain; object, respectively.  For
!      &locone; and &intervalone;, these yield the same values as
       &lt;methodname&gt;first&lt;/methodname&gt; and &lt;methodname&gt;last&lt;/methodname&gt;,
!      but &rangeone; and &gridone; can have their numerically largest
!      index at the beginning of their &domain;s.&lt;/para&gt;
      &lt;/section&gt;
     &lt;/section&gt;
  
***************
*** 1088,1100 ****
     &lt;section id=&quot;arrays-arrays_declarations&quot;&gt;
      &lt;title&gt;Declaring &array;s&lt;/title&gt;
  
!     &lt;para&gt;A &pooma; &array; maps indices from its &domain; to values.
!     In this section, we first describe how to declare &array;s.  In
!     the next section, we explain how to access individual values
!     stored within an &array; and &array; copy semantics.&lt;/para&gt;
  
      &lt;para&gt;&array; values need not just be stored values, as &c; arrays
!     have.  They can also be computed using its engine.  We defer
      discussion of computing values to the next chapter discussing
      engines (&lt;xref linkend=&quot;engines&quot;&gt;&lt;/xref&gt;).  To avoid being verbose
      in this chapter, when we discuss stored values, the values might
--- 1091,1105 ----
     &lt;section id=&quot;arrays-arrays_declarations&quot;&gt;
      &lt;title&gt;Declaring &array;s&lt;/title&gt;
  
!     &lt;para&gt;A &pooma; &array; maps &domain; indices to values.  In this
!     section, we describe how to declare &array;s.  In the next
!     section, we explain how to access individual values stored within
!     an &array; and how to copy &array;s.&lt;/para&gt;
  
+ &lt;!-- FIXME: This paragraph is poorly worded. --&gt;
+ 
      &lt;para&gt;&array; values need not just be stored values, as &c; arrays
!     have.  They can also be computed by its engine.  We defer
      discussion of computing values to the next chapter discussing
      engines (&lt;xref linkend=&quot;engines&quot;&gt;&lt;/xref&gt;).  To avoid being verbose
      in this chapter, when we discuss stored values, the values might
***************
*** 1102,1177 ****
  
      &lt;para&gt;Declaring an &array; requires four arguments: the domain's
      dimensionality, the type of values stored or computed, a
!     specification how the values are stored, and a &domain;.  The
!     first three arguments are template parameters since few scientific
!     programs (and no &pooma; programs) need to change these values
!     while a program executes.  For example, an &array; cannot change
!     the type of the elements it stores.  Alternatively, an &array;'s
!     values can be copied into another &array; having the desired type.
!     Although scientific programs do not frequently change an array's
!     domain, they do frequently request a subset of the array's values,
!     i.e., a &lt;glossterm linkend=&quot;glossary-view&quot;&gt;view&lt;/glossterm&gt;.  The
!     subset is specified via a &domain; so it is a run-time value.
!     Views are presented in &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
      &lt;para&gt;An &array;'s first template parameter specifies its
      dimensionality.  This positive
!     integer&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt; specifies its rank.  This is
      the same value as its domain's dimensionality.  Theoretically, an
      &array; can have any positive integer, but the &pooma; code
!     currently supports &lt;varname&gt;&dim;&lt;/varname&gt; at most seven.  For
!     almost all scientific codes, a dimension of three or four is
!     sufficient, but the code can be extended to support higher
      dimensions.&lt;/para&gt;
  
      &lt;para&gt;An &array;'s second template parameter specifies the type of
!     its stored values.  Common value types include &int;, &double;,
!     &complex;, and &vector;, but any type is permissible.  For
!     example, an &array;'s values might be matrices or even other
      &array;s.  The parameter's default value is usually &double;, but
      it may be changed when the &poomatoolkit; is configured.&lt;/para&gt;
  
      &lt;para&gt;An &array;'s third parameter specifies how its data is
!     stored by an &engine; and its values accessed.  The argument is a
!     tag indicating a particular type of &engine;.  Permissible tags
!     include &brick;, &compressiblebrick;, and
      &lt;type&gt;ConstantFunction&lt;/type&gt;.  The &brick; tag indicates all
      &array; values will be explicitly stored, just as built-in &c;
!     arrays do.  If the &array;s frequently stores exactly the same
!     value in every position, a &compressiblebrick; &engine;, which
!     reduces its space requirements to a constant whenever all its
!     values are the same, is appropriate.  A
!     &lt;type&gt;ConstantFunction&lt;/type&gt; &engine; returns the same value for
!     all indices.&lt;/para&gt;
  
      &lt;para&gt;Even though every &array; container has an engine to store
!     its values and permit access to individual values, an &array; is
!     conceptually separated from engines.  An engine's role is
!     low-level, storing values and permitting access to individual
!     values.  As we indicated above, the storage can be optimized to
!     fit specific situations such as few nonzero values and computing
!     values using a function applied to another engine's values.  An
!     &array;'s role is high-level, supporting access to groups of
!     values.  They handle memory allocation and deallocation.  &array;s
!     can be used in data-parallel expressions, e.g., adding all the
!     values in one &array; to all the values in another.  (See &lt;xref
!     linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt; for more information.)  Subsets of
!     &array; values, frequently used in data-parallel statements, can
!     be obtained.  (See &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt; for more
!     information.)  Even though engines and &array;s are conceptually
!     separate, higher-level &array;s provide access to lower-level
!     &engine;s.  Users usually have an &array; create its &engine;,
!     rarely explicitly creating &engine;s themselves.  Also, &array;s
!     provide access to individual values.  In short, &pooma; users use
!     &array;s, only dealing with how they are implemented (engines)
!     upon declaration.  For more description of &engine;s, see &lt;xref
      linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
- 
-     &lt;para&gt;The engine parameter's default value is usually &brick;, but
-     it may be changed when the &poomatoolkit; is configured.&lt;/para&gt;
  
!     &lt;para&gt;An &array;'s one constructor argument is its domain.  The
!     domain specifies its extent and simultaneously how many values it
      can return.  All the provided &domain; objects are combined to
      yield an &lt;type&gt;Interval&lt;&dim;&gt;&lt;/type&gt;, where &dim; matches
      the &array;'s first template parameter.  Since an &interval;
--- 1107,1186 ----
  
      &lt;para&gt;Declaring an &array; requires four arguments: the domain's
      dimensionality, the type of values stored or computed, a
!     specification how the values are stored or computed, and a
!     &domain;.  The first three arguments are template parameters since
!     few scientific programs need to (and no &pooma; programs can)
!     change these values while a program executes.  For example, an
!     &array; cannot change the type of the values it stores, but an
!     &array;'s values can be copied into another &array; having the
!     desired type.  Although scientific programs do not frequently
!     change an array's domain, they do frequently request a subset of
!     the array's values, i.e., a &lt;glossterm
!     linkend=&quot;glossary-view&quot;&gt;view&lt;/glossterm&gt;.  The subset is specified
!     via a &domain; so it is a run-time value.  Views are presented in
!     &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
      &lt;para&gt;An &array;'s first template parameter specifies its
      dimensionality.  This positive
!     integer&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt; specifies its rank and has
      the same value as its domain's dimensionality.  Theoretically, an
      &array; can have any positive integer, but the &pooma; code
!     currently supports a dimensionality of at most seven.  For almost
!     all scientific codes, a dimension of three or four is sufficient,
!     but the &pooma; code can be extended to support higher
      dimensions.&lt;/para&gt;
  
      &lt;para&gt;An &array;'s second template parameter specifies the type of
!     its stored or computed values.  Common value types include &int;,
!     &double;, &complex;, and &vector;, but any type is permissible.
!     For example, an &array;'s values might be matrices or even other
      &array;s.  The parameter's default value is usually &double;, but
      it may be changed when the &poomatoolkit; is configured.&lt;/para&gt;
  
      &lt;para&gt;An &array;'s third parameter specifies how its data is
!     stored or computed by an &engine; and its values accessed.  The
!     argument is a tag indicating a particular type of &engine;.
!     Permissible tags include &brick;, &compressiblebrick;, and
      &lt;type&gt;ConstantFunction&lt;/type&gt;.  The &brick; tag indicates all
      &array; values will be explicitly stored, just as built-in &c;
!     arrays do.  If an &array; frequently stores exactly the same value
!     in every position, a &compressiblebrick; &engine;, which reduces
!     its space requirements to a constant whenever all its values are
!     the same, is appropriate.  A &lt;type&gt;ConstantFunction&lt;/type&gt;
!     &engine; returns the same value for all indices.  Some &engine;s
!     compute values, e.g., applying a function to every value in
!     another &engine;.  These &engine;s are discussed in &lt;xref
!     linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.  To avoid being verbose in the rest of
!     this chapter, we abbreviate &lt;quote&gt;store or compute values&lt;/quote&gt;
!     as &lt;quote&gt;store values&lt;/quote&gt;.  The engine parameter's default
!     value is usually &brick;, but it may be changed when the
!     &poomatoolkit; is configured.&lt;/para&gt;
  
      &lt;para&gt;Even though every &array; container has an engine to store
!     its values and permit access to individual values, the concept of
!     an &array; is conceptually separate from the concept of an engine.
!     An engine's role is low-level, storing values and permitting
!     access to individual values.  As we indicated above, the storage
!     can be optimized to fit specific situations such as few nonzero
!     values and computing values using a function applied to another
!     engine's values.  An &array;'s role is high-level, supporting
!     access to groups of values.  &array;s can be used in data-parallel
!     expressions, e.g., adding all the values in one &array; to all the
!     values in another.  (See &lt;xref linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt; for
!     more information.)  Subsets of &array; values, frequently used in
!     data-parallel statements, can be obtained.  (See &lt;xref
!     linkend=&quot;views&quot;&gt;&lt;/xref&gt; for more information.)  Even though
!     engines and &array;s are conceptually separate, higher-level
!     &array;s provide access to lower-level &engine;s.  Users usually
!     have an &array; create its &engine;(s), rarely explicitly creating
!     &engine;s themselves.  Also, &array;s support access to individual
!     values.  In short, &pooma; users use &array;s, only dealing with
!     how they are implemented (engines) when declaring them.  For a
!     description of &engine;s, see &lt;xref
      linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
!     &lt;para&gt;An &array;'s one run-time argument is its domain.  The
!     domain specifies its extent and consequently how many values it
      can return.  All the provided &domain; objects are combined to
      yield an &lt;type&gt;Interval&lt;&dim;&gt;&lt;/type&gt;, where &dim; matches
      the &array;'s first template parameter.  Since an &interval;
***************
*** 1185,1190 ****
--- 1194,1240 ----
      required, the &pooma; code can be extended to the desired number
      of dimensions.&lt;/para&gt;
  
+     &lt;para&gt;&array; constructors are listed in &lt;xref
+     linkend=&quot;arrays-arrays_declarations-table&quot;&gt;&lt;/xref&gt;.  An &array;'s
+     three template parameters for dimensionality, value type, and
+     engine type are abbreviated &lt;varname&gt;D&lt;/varname&gt;,
+     &lt;varname&gt;T&lt;/varname&gt;, and &lt;varname&gt;E&lt;/varname&gt;.  Template
+     parameters for domain types are named &lt;varname&gt;DT1&lt;/varname&gt;,
+     &hellip;, &lt;varname&gt;DT7&lt;/varname&gt;.  The first constructor, with no
+     domain arguments, creates an empty, uninitialized &array; for
+     which a domain must be specified before it is used.  Specify the
+     array's domain using its &lt;methodname&gt;initialize&lt;/methodname&gt;
+     function.  The next seven constructors combine their domain
+     arguments to compute the resulting &array;'s domain.  These are
+     combined in the same way that multidimensional &interval;s are
+     constructed.  (See &lt;xref
+     linkend=&quot;arrays-domains-declarations-intervals-multi_d_table&quot;&gt;&lt;/xref&gt;
+     and the following text.)  The domain objects, having types
+     &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
+     &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
+     converted into an integer, into a single-dimensional &domain;
+     object that can be converted into a single-dimensional &interval;,
+     or to a multidimensional &domain; object that itself can be
+     converted into an &interval;.  The total dimensionality of all the
+     arguments' types should
+     &lt;emphasis&gt;equal&lt;/emphasis&gt;&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, unlike
+     &interval; construction which permits total dimensionality less
+     than or equal to&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional
+     &domain; objects that can be converted into one-dimensional
+     &interval;s include &locone;s, &intervalone;s, and &rangeone;s
+     with unit strides.  To initialize all of an &array;'s values to a
+     specific value, use one of the final seven constructors, each
+     taking a particular value, wrapped as a &lt;type&gt;ModelElement&lt;/type&gt;.
+     These constructors use the given domain objects the same way as
+     the preceding constructors but assign &lt;varname&gt;model&lt;/varname&gt; to
+     every &array; value.  &lt;varname&gt;model&lt;/varname&gt;'s type is
+     &lt;type&gt;ModelElement&lt;T&gt;&lt;/type&gt;, rather than
+     &lt;varname&gt;T&lt;/varname&gt;, to differentiate it from an &int;, which can
+     also be used to specify a domain object.
+     &lt;type&gt;ModelElement&lt;/type&gt; just stores an element of any type
+     &lt;varname&gt;T&lt;/varname&gt;, which must match the &array;'s value
+     type&nbsp;&lt;varname&gt;T&lt;/varname&gt;.&lt;/para&gt;
+ 
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_declarations-table&quot;&gt;
       &lt;title&gt;Declaring &array;s&lt;/title&gt;
***************
*** 1206,1212 ****
  	 integers.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an empty, uninitialized &array; which must be
--- 1256,1262 ----
  	 integers.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an empty, uninitialized &array; which must be
***************
*** 1310,1368 ****
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
-     &lt;para&gt;&array; constructors are listed in &lt;xref
-     linkend=&quot;arrays-arrays_declarations-table&quot;&gt;&lt;/xref&gt;.  An &array;s'
-     three template parameters for dimensionality, value type, and
-     engine type are abbreviated &lt;varname&gt;D&lt;/varname&gt;,
-     &lt;varname&gt;T&lt;/varname&gt;, and &lt;varname&gt;E&lt;/varname&gt;.  Template
-     parameters for domain types are named &lt;varname&gt;DT1&lt;/varname&gt;,
-     &hellip;, &lt;varname&gt;DT7&lt;/varname&gt;.  The first constructor, with no
-     domain arguments, creates an empty, uninitialized &array; for
-     which a domain must be specified before it is used.  Specify the
-     array's domain using its &lt;methodname&gt;initialize&lt;/methodname&gt; function.
-     The next seven constructors combine their domain arguments to
-     compute the resulting &array;'s domain.  These are combined in the
-     same way that multidimensional &interval;s are constructed.  (See
-     &lt;xref
-     linkend=&quot;arrays-domains-declarations-intervals-multi_d_table&quot;&gt;&lt;/xref&gt;
-     and the following text.)  The domain objects, having types
-     &lt;type&gt;&domaintemplate;1&lt;/type&gt;, &hellip;,
-     &lt;type&gt;&domaintemplate;7&lt;/type&gt;, can have any type that can be
-     converted into an integer, into a single-dimensional &domain;
-     object that can be converted into a single-dimensional &interval;,
-     or to a multidimensional &domain; object that itself can be
-     converted into an &interval;.  The total dimensionality of all the
-     arguments' types should
-     &lt;emphasis&gt;equal&lt;/emphasis&gt;&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;, unlike
-     &interval; construction which permits total dimensionality less
-     than or equal to&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  One-dimensional
-     &domain; objects that can be converted into one-dimensional
-     &interval;s include &locone;s, &intervalone;s, and &rangeone;s
-     with unit strides.  To initialize all of an &array; values to a
-     specific value, use one of the final seven constructors, each
-     taking a particular value, wrapped as a &lt;type&gt;ModelElement&lt;/type&gt;.
-     These constructors use the given domain objects the same way as
-     the preceding constructors but assign &lt;varname&gt;model&lt;/varname&gt; to
-     every &array; value.  &lt;varname&gt;model&lt;/varname&gt;'s type
-     &lt;type&gt;ModelElement&lt;T&gt;&lt;/type&gt; rather than
-     &lt;varname&gt;T&lt;/varname&gt; to differentiate it from an &int;, which can
-     also be used to specify a domain object.
-     &lt;type&gt;ModelElement&lt;/type&gt; just stores an element of any type
-     &lt;varname&gt;T&lt;/varname&gt;, which must match the &array;'s value
-     type.&lt;/para&gt;
- 
      &lt;para&gt;We illustrate creating &array;s.  To create a
      three-dimensional &array;&nbsp;&lt;varname&gt;a&lt;/varname&gt; explicitly
      storing &double; floating-point values, use
  &lt;programlisting&gt;
  Interval&lt;1&gt; D(6);
  Interval&lt;3&gt; I3(D,D,D);
! Array&lt;3,double,Brick&gt; a(I3);.
  &lt;/programlisting&gt;  The template parameters specify its dimensionality,
      the type of its values, and a &brick; &engine; type, which
      explicitly stores values.  Its domain, which must have three
      dimensions, is specified by an &lt;type&gt;Interval&lt;3&gt;&lt;/type&gt;
!     object which consists of a [0,5] intervals for all its three
      dimensions.  Since &double; and &brick; are usually the default
      template parameters, they can be omitted so these declarations are
      equivalent:
--- 1360,1377 ----
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
      &lt;para&gt;We illustrate creating &array;s.  To create a
      three-dimensional &array;&nbsp;&lt;varname&gt;a&lt;/varname&gt; explicitly
      storing &double; floating-point values, use
  &lt;programlisting&gt;
  Interval&lt;1&gt; D(6);
  Interval&lt;3&gt; I3(D,D,D);
! Array&lt;3,double,Brick&gt; a(I3);
  &lt;/programlisting&gt;  The template parameters specify its dimensionality,
      the type of its values, and a &brick; &engine; type, which
      explicitly stores values.  Its domain, which must have three
      dimensions, is specified by an &lt;type&gt;Interval&lt;3&gt;&lt;/type&gt;
!     object which consists of [0,5] intervals for all its three
      dimensions.  Since &double; and &brick; are usually the default
      template parameters, they can be omitted so these declarations are
      equivalent:
*************** Array&lt;3&gt; a_duplicate2(I3);.
*** 1372,1383 ****
  &lt;/programlisting&gt;  To create a similar &array; with a domain of
  [0:1:1, 0:2:1, 0:0:1], use
  &lt;programlisting&gt;
! Array&lt;3&gt; b(2,3,1);.
! &lt;/programlisting&gt; Specifying an integer&nbsp;&lt;varname&gt;i&lt;/varname&gt;
      indicates a one-dimensional zero-based &interval; [0:i-1:1].  To
!     store &bool;s, specify &bool; as the second template argument:
  &lt;programlisting&gt;
! Array&lt;2,bool&gt; c(2,3);.
  &lt;/programlisting&gt;  To specify a default &array; value of &true;, use
      &lt;statement&gt;ModelElement&lt;bool&gt;(true)&lt;/statement&gt;:
  &lt;programlisting&gt;
--- 1381,1392 ----
  &lt;/programlisting&gt;  To create a similar &array; with a domain of
  [0:1:1, 0:2:1, 0:0:1], use
  &lt;programlisting&gt;
! Array&lt;3&gt; b(2,3,1);
! &lt;/programlisting&gt; since specifying an integer&nbsp;&lt;varname&gt;i&lt;/varname&gt;
      indicates a one-dimensional zero-based &interval; [0:i-1:1].  To
!     store booleans, specify &bool; as the second template argument:
  &lt;programlisting&gt;
! Array&lt;2,bool&gt; c(2,3);
  &lt;/programlisting&gt;  To specify a default &array; value of &true;, use
      &lt;statement&gt;ModelElement&lt;bool&gt;(true)&lt;/statement&gt;:
  &lt;programlisting&gt;
*************** Array&lt;2,bool&gt; c(2,3, ModelElement&amp;
*** 1385,1395 ****
  &lt;/programlisting&gt;  To create a one-dimensional &array; containing
      seven &double;s all equaling &pi;, use
  &lt;programlisting&gt;
! Array&lt;1,double,CompressibleBrick&gt; d(7, ModelElement&lt;double&gt;(4.0*atan(1.0)));.
  &lt;/programlisting&gt;  We use a &compressiblebrick; &engine;, rather than
!     a &brick; &engine;, so all seven values will be stored once rather
!     than seven times when they are all the same.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_declarations-initialize_table&quot;&gt;
       &lt;title&gt;Initializing &array;s' Domains&lt;/title&gt;
--- 1394,1432 ----
  &lt;/programlisting&gt;  To create a one-dimensional &array; containing
      seven &double;s all equaling &pi;, use
  &lt;programlisting&gt;
! const double pi = 4.0*atan(1.0);
! Array&lt;1,double,CompressibleBrick&gt; d(7, ModelElement&lt;double&gt;(pi));.
  &lt;/programlisting&gt;  We use a &compressiblebrick; &engine;, rather than
!     a &brick; &engine;, so all seven values will be stored in one
!     location rather than in seven separate locations when they are all the
!     same.&lt;/para&gt;
  
+     &lt;para&gt;An uninitialized &array;, created using its parameter-less
+     constructor, must have a specified domain before it can be used.
+     For example, one must use the parameter-less &array; constructor
+     when creating an array of &array;s using
+     &lt;keywordname&gt;new&lt;/keywordname&gt; so their domains must be specified.
+     (It would probably be better to create an &array; of &array;s
+     since memory allocation and deallocation would automatically be
+     handled.)  &array;'s &lt;methodname&gt;initialize&lt;/methodname&gt; functions
+     accept the same set of domain object specifications and model
+     elements that the &array; constructors do, creating the specified
+     domain.  See &lt;xref
+     linkend=&quot;arrays-arrays_declarations-initialize_table&quot;&gt;&lt;/xref&gt;.
+     For example, both &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt;
+     are two-dimensional &array;s of &float;s with a [2:7:1,-2:4:1]
+     domains:
+ &lt;programlisting&gt;
+ // Create an Array and its domain.
+ Array&lt;2,float,Brick&gt; a(Interval&lt;1&gt;(2,7), Interval&lt;1&gt;(-2,4));
+ 
+ // Create an Array without a domain and then specify its domain.
+ Array&lt;2,float,Brick&gt; b();
+ b.initialize(Interval&lt;1&gt;(2,7), Interval&lt;1&gt;(-2,4));.
+ &lt;/programlisting&gt;  Invoking &lt;methodname&gt;initialize&lt;/methodname&gt; on an
+     &array; with an existing domain yields unspecified behavior.  All
+     &array; values may be lost and memory may be leaked.&lt;/para&gt;
+ 
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_declarations-initialize_table&quot;&gt;
       &lt;title&gt;Initializing &array;s' Domains&lt;/title&gt;
*************** Array&lt;1,double,CompressibleBrick&gt; 
*** 1413,1419 ****
  	integers.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
!       &lt;tbody&gt;
         &lt;!-- Omit Indirection Array initialize because it does not exist! --&gt;
         &lt;!-- Omit the two Array&lt;D1,T1,E1&gt; functions, which should not be used by users. --&gt;
         &lt;row&gt;
--- 1450,1456 ----
  	integers.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;!-- Omit Indirection Array initialize because it does not exist! --&gt;
         &lt;!-- Omit the two Array&lt;D1,T1,E1&gt; functions, which should not be used by users. --&gt;
         &lt;row&gt;
*************** object or integer.&lt;/entry&gt;
*** 1455,1480 ****
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; object and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
--- 1492,1520 ----
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain;
! 	object or integer and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain;
! 	objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain;
! 	objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
*************** object or integer.&lt;/entry&gt;
*** 1482,1488 ****
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
--- 1522,1528 ----
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
*************** object or integer.&lt;/entry&gt;
*** 1490,1496 ****
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
--- 1530,1536 ----
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
*************** object or integer.&lt;/entry&gt;
*** 1498,1534 ****
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
      &lt;/table&gt;
- 
-     &lt;para&gt;An uninitialized &array;, created using the parameter-less
-     constructor, must have a specified domain before it can be used.
-     For example, one must use the parameter-less &array; constructor
-     when creating an array of &array;s using
-     &lt;keywordname&gt;new&lt;/keywordname&gt; (although it would probably be
-     better to create an &array; of &array;s since memory allocation
-     and deallocation would automatically be handled) so their domains
-     must be specified.  &array;'s &lt;methodname&gt;initialize&lt;/methodname&gt;
-     functions accept the same set of domain object specifications and
-     model elements that the &array; constructors do, creating the
-     specified domain.  See &lt;xref
-     linkend=&quot;arrays-arrays_declarations-initialize_table&quot;&gt;&lt;/xref&gt;.
-     For example, both &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt;
-     are two-dimensional &array;s of &float;s with a [2:7:1,-2:4:1]
-     domains:
- &lt;programlisting&gt;
- // Create an Array and its domain.
- Array&lt;2,float,Brick&gt; a(Interval&lt;1&gt;(2,7), Interval&lt;1&gt;(-2,4));
- // Create an Array without a domain and then specify its domain.
- Array&lt;2,float,Brick&gt; b();
- b.initialize(Interval&lt;1&gt;(2,7), Interval&lt;1&gt;(-2,4));.
- &lt;/programlisting&gt;  Invoking &lt;methodname&gt;initialize&lt;/methodname&gt; on an
-     &array; with an existing domain is unspecified.  All &array;
-     values may be lost and memory may be leaked.&lt;/para&gt;
     &lt;/section&gt;
  
  
--- 1538,1549 ----
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
  	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
      &lt;/table&gt;
     &lt;/section&gt;
  
  
*************** std::cout &openopen; a(2,-2) &openopen; 
*** 1571,1586 ****
  std::cout &openopen; a.read(2,-2) &openopen; std::endl;
  &lt;/programlisting&gt; Using &lt;methodname&gt;read&lt;/methodname&gt; sometimes
      permits the optimizer to produce faster executing code.&lt;/para&gt;
- 
-     &lt;example id=&quot;arrays-arrays_use-copy_example&quot;&gt;
-      &lt;title&gt;Copying &array;s&lt;/title&gt;
-      &amp;array-copy;
-     &lt;/example&gt;
  
!     &lt;para&gt;Copying &array;s requires little execution time because they
!     have reference semantics.  That is, a copy of an &array; and the
!     &array; itself share the same underlying data.  Changing a value
!     in one changes it in the other.  &lt;xref
      linkend=&quot;arrays-arrays_use-copy_example&quot;&gt;&lt;/xref&gt; illustrates this
      behavior.  Initially, all values in the array &lt;varname&gt;a&lt;/varname&gt;
      are&nbsp;4.  The &lt;varname&gt;b&lt;/varname&gt; array is initialized using
--- 1586,1598 ----
  std::cout &openopen; a.read(2,-2) &openopen; std::endl;
  &lt;/programlisting&gt; Using &lt;methodname&gt;read&lt;/methodname&gt; sometimes
      permits the optimizer to produce faster executing code.&lt;/para&gt;
  
!     &lt;para&gt;Copying &array;s requires little execution time because
!     &array;s have &lt;glossterm
!     linkend=&quot;glossary-reference_semantics&quot;&gt;&lt;firstterm&gt;reference
!     semantics&lt;/firstterm&gt;&lt;/glossterm&gt;.  That is, a copy of an &array;
!     and the &array; itself share the same underlying data.  Changing a
!     value in one changes it in the other.  &lt;xref
      linkend=&quot;arrays-arrays_use-copy_example&quot;&gt;&lt;/xref&gt; illustrates this
      behavior.  Initially, all values in the array &lt;varname&gt;a&lt;/varname&gt;
      are&nbsp;4.  The &lt;varname&gt;b&lt;/varname&gt; array is initialized using
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1589,1598 ****
      changes the latter's value.  Function arguments are also
      initialized so changing their underlying values also changes the
      calling function's values.  For example, the
!     &lt;function&gt;changeValue&lt;/function&gt; function changes the value with
!     index&nbsp;(0,0) of both its function argument
      and&nbsp;&lt;varname&gt;a&lt;/varname&gt;.&lt;/para&gt;
  
      &lt;para&gt;The separation between a higher-level &array; and its
      lower-level &engine; storage permits fast copying.  An &array;'s
      only data member is its engine, which itself has reference
--- 1601,1615 ----
      changes the latter's value.  Function arguments are also
      initialized so changing their underlying values also changes the
      calling function's values.  For example, the
!     &lt;function&gt;changeValue&lt;/function&gt; function changes the value at
!     index&nbsp;(0,0) for both its function argument
      and&nbsp;&lt;varname&gt;a&lt;/varname&gt;.&lt;/para&gt;
  
+     &lt;example id=&quot;arrays-arrays_use-copy_example&quot;&gt;
+      &lt;title&gt;Copying &array;s&lt;/title&gt;
+      &amp;array-copy;
+     &lt;/example&gt;
+ 
      &lt;para&gt;The separation between a higher-level &array; and its
      lower-level &engine; storage permits fast copying.  An &array;'s
      only data member is its engine, which itself has reference
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1608,1613 ****
--- 1625,1645 ----
      &lt;varname&gt;a&lt;/varname&gt;'s values do not change &lt;varname&gt;b&lt;/varname&gt;'s
      values or vice versa.&lt;/para&gt;
  
+     &lt;para&gt;The &array; class has internal type definitions and
+     constants useful for both compile-time and run-time computations.
+     See &lt;xref linkend=&quot;arrays-arrays_use-compile_time_table&quot;&gt;&lt;/xref&gt;.
+     These may be accessed using the &array;'s type and the scope
+     resolution operator (&lt;operator&gt;::&lt;/operator&gt;).  The table begins
+     with a list of internal type definitions, e.g.,
+     &lt;statement&gt;Array&lt;&dim;,T,E&gt;::This_t&lt;/statement&gt;.  A
+     &lt;glossterm linkend=&quot;glossary-layout&quot;&gt;layout&lt;/glossterm&gt; maps a
+     domain index to a particular processor and memory used to compute
+     the associated value.&lt;!-- FIXME: Add a reference to the
+     corresponding chapter. --&gt; The two internal enumerations
+     &lt;fieldsynopsis&gt;&lt;varname&gt;dimensions&lt;/varname&gt;&lt;/fieldsynopsis&gt; and
+     &lt;fieldsynopsis&gt;&lt;varname&gt;rank&lt;/varname&gt;&lt;/fieldsynopsis&gt; both record
+     the &array;'s dimension.&lt;/para&gt;
+ 
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_use-compile_time_table&quot;&gt;
       &lt;title&gt;&array; Internal Type Definitions and Compile-Time Constants&lt;/title&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1619,1625 ****
  	&lt;entry&gt;meaning&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;type&gt;This_t&lt;/type&gt;&lt;/entry&gt;
  	&lt;entry&gt;the &array;'s type &lt;type&gt;Array&lt;&dim;,T,E&gt;&lt;/type&gt;.&lt;/entry&gt;
--- 1651,1657 ----
  	&lt;entry&gt;meaning&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;type&gt;This_t&lt;/type&gt;&lt;/entry&gt;
  	&lt;entry&gt;the &array;'s type &lt;type&gt;Array&lt;&dim;,T,E&gt;&lt;/type&gt;.&lt;/entry&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1650,1687 ****
  	&lt;entry&gt;the type of the &array;'s layout.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;fieldsynopsis&gt;
! 	  &lt;modifier&gt;const&lt;/modifier&gt;
! 	  &lt;type&gt;int&lt;/type&gt;
! 	  &lt;varname&gt;dimensions&lt;/varname&gt;&lt;/fieldsynopsis&gt;&lt;/entry&gt;
  	&lt;entry&gt;the number&nbsp;&dim; of dimensions of the &array;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;fieldsynopsis&gt;
! 	  &lt;modifier&gt;const&lt;/modifier&gt;
! 	  &lt;type&gt;int&lt;/type&gt;
! 	  &lt;varname&gt;rank&lt;/varname&gt;&lt;/fieldsynopsis&gt;&lt;/entry&gt;
  	&lt;entry&gt;synonym for &lt;varname&gt;dimensions&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
!     &lt;para&gt;The &array; class has internal type definitions and
!     constants useful for both compile-time and run-time computations.
!     See &lt;xref linkend=&quot;arrays-arrays_use-compile_time_table&quot;&gt;&lt;/xref&gt;.
!     These may be accessed using the &array;'s type and the scope
!     resolution operator (&lt;operator&gt;::&lt;/operator&gt;).  The table begins
!     with a list of internal type definitions, e.g.,
!     &lt;statement&gt;Array&lt;&dim;,T,E&gt;::Domain_t&lt;/statement&gt;.  Member
!     functions use some of these types.  A &lt;glossterm
!     linkend=&quot;glossary-layout&quot;&gt;layout&lt;/glossterm&gt; maps a domain index
!     to a particular processor and memory used to compute the
!     associated value.&lt;!-- FIXME: Add a reference to the corresponding
!     chapter. --&gt; The two internal enumerations
!     &lt;fieldsynopsis&gt;&lt;varname&gt;dimensions&lt;/varname&gt;&lt;/fieldsynopsis&gt; and
!     &lt;fieldsynopsis&gt;&lt;varname&gt;rank&lt;/varname&gt;&lt;/fieldsynopsis&gt; both record
!     the &array;'s dimension.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_use-accessor_table&quot;&gt;
--- 1682,1723 ----
  	&lt;entry&gt;the type of the &array;'s layout.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;const int dimensions&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;the number&nbsp;&dim; of dimensions of the &array;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;const int rank&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;synonym for &lt;varname&gt;dimensions&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
!     &lt;para&gt;The &array; class has several member functions easing access
!     to its domain and engine.  The first ten functions listed in &lt;xref
!     linkend=&quot;arrays-arrays_use-accessor_table&quot;&gt;&lt;/xref&gt; ease access to
!     &array; domains.  The first three functions are synonyms all
!     returning the &array;'s domain, which has type
!     &lt;type&gt;Array&lt;&dim;,T,E&gt;::Domain_t&lt;/type&gt; (abbreviated
!     &lt;type&gt;Domain_t&lt;/type&gt; in the table).  The next seven functions
!     query the domain.  &lt;methodname&gt;first&lt;/methodname&gt;,
!     &lt;methodname&gt;last&lt;/methodname&gt;, and &lt;methodname&gt;length&lt;/methodname&gt;
!     return the first index, last index, and number of indices for the
!     specified dimension.  The domain's dimensions are numbered 0, 1,
!     &hellip;,
!     &lt;statement&gt;Array&lt;&dim;,T,E&gt;::dimensions&lt;/statement&gt;-1.  If
!     these values are needed for all dimensions, use
!     &lt;methodname&gt;firsts&lt;/methodname&gt;, &lt;methodname&gt;lasts&lt;/methodname&gt;,
!     and &lt;methodname&gt;lengths&lt;/methodname&gt;.  The returned
!     &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt;s have &dim; entries, one for each
!     dimension.  &lt;methodname&gt;size&lt;/methodname&gt; returns the total number
!     of indices in the entire domain.  This is the product of all the
!     dimensions' &lt;methodname&gt;length&lt;/methodname&gt;s.  The
!     &lt;methodname&gt;layout&lt;/methodname&gt; member function returns the
!     &array;'s layout, which specifies the mapping of indices to
!     processors and memory.&lt;!-- FIXME: Add a reference to the
!     corresponding chapter. --&gt; The last two functions return the
!     &array;'s engine.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-arrays_use-accessor_table&quot;&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1697,1707 ****
        &lt;tfoot&gt;
         &lt;row&gt;
  	&lt;entry&gt;Internal type definitions, e.g., &lt;type&gt;Domain_t&lt;/type&gt;,
! 	are listed without a class type prefix
  	&lt;statement&gt;Array&lt;&dim;,T,E&gt;::&lt;/statement&gt;.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Domain_t domain()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
--- 1733,1743 ----
        &lt;tfoot&gt;
         &lt;row&gt;
  	&lt;entry&gt;Internal type definitions, e.g., &lt;type&gt;Domain_t&lt;/type&gt;,
! 	are listed here without the class type prefix
  	&lt;statement&gt;Array&lt;&dim;,T,E&gt;::&lt;/statement&gt;.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Domain_t domain()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1716,1728 ****
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;int first(int dim)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;returns the first (smallest) index value for the
! 	specified dimension.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;int last(int dim)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;returns the last (largest) index value for the
! 	specified dimension.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;int length(int dim)&lt;/statement&gt;&lt;/entry&gt;
--- 1752,1764 ----
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;int first(int dim)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;returns the first index value for the specified
! 	dimension.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;int last(int dim)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;returns the last index value for the specified
! 	dimension.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;int length(int dim)&lt;/statement&gt;&lt;/entry&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1731,1743 ****
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; firsts()&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;returns the first (smallest) index values for all the
  	dimensions.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; lasts()&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;returns the last (largest) index values for all the
! 	specified dimensions.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; lengths()&lt;/statement&gt;&lt;/entry&gt;
--- 1767,1779 ----
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; firsts()&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;returns the first index values for all the
  	dimensions.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; lasts()&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;returns the last index values for all the specified
! 	dimensions.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; lengths()&lt;/statement&gt;&lt;/entry&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1750,1756 ****
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Layout_t layout()&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Engine_t engine()&lt;/statement&gt;&lt;/entry&gt;
--- 1786,1792 ----
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Layout_t layout()&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;returns the &array;'s layout.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Engine_t engine()&lt;/statement&gt;&lt;/entry&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1764,1806 ****
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
!     &lt;para&gt;The &array; class has several member functions easing access
!     to its domain and engine.  The first ten functions listed in &lt;xref
!     linkend=&quot;arrays-arrays_use-accessor_table&quot;&gt;&lt;/xref&gt; ease access to
!     &array; domains.  The first three functions are synonyms all
!     returning the &array;'s domain, which has type
!     &lt;type&gt;Array&lt;&dim;,T,E&gt;::Domain_t&lt;/type&gt;, abbreviated
!     &lt;type&gt;Domain_t&lt;/type&gt; in the table.  The next seven functions
!     query the domain.  &lt;methodname&gt;first&lt;/methodname&gt;,
!     &lt;methodname&gt;last&lt;/methodname&gt;, and &lt;methodname&gt;length&lt;/methodname&gt;
!     return the smallest, largest, and number of indices for the
!     specified dimension.  The domain's dimensions are numbered 0, 1,
!     &hellip;,
!     &lt;statement&gt;Array&lt;&dim;,T,E&gt;::dimensions&lt;/statement&gt;-1.  If
!     these values are needed for all dimensions, use
!     &lt;methodname&gt;firsts&lt;/methodname&gt;, &lt;methodname&gt;lasts&lt;/methodname&gt;,
!     and &lt;methodname&gt;lengths&lt;/methodname&gt;.  The returned
!     &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt;s have &dim; entries, one for each
!     dimension.  &lt;methodname&gt;size&lt;/methodname&gt; returns the total number
!     of indices in the entire domain.  This is the product of all the
!     dimensions' &lt;methodname&gt;length&lt;/methodname&gt;s.  The
!     &lt;methodname&gt;layout&lt;/methodname&gt; member function returns the
!     &array;'s layout, which specifies the mapping of indices to
!     processors and memory.&lt;!-- FIXME: Add a reference to the
!     corresponding chapter. --&gt; The last two functions return the
!     &array;'s engine.&lt;/para&gt;
  
      &lt;example id=&quot;arrays-arrays_use-members_example&quot;&gt;
       &lt;title&gt;Using &array; Member Functions&lt;/title&gt;
       &amp;array-size;
       &lt;calloutlist&gt;
-       &lt;callout arearefs=&quot;arrays-arrays_use-members-example-compare_size&quot;&gt;
-        &lt;para&gt;The &lt;methodname&gt;size&lt;/methodname&gt; is invoked by
-        prepending the &array;'s name followed by a period.  This
-        assertion is unnecessary, but the
-        &lt;function&gt;computeArraySize&lt;/function&gt; function further
-        illustrates using member functions.&lt;/para&gt;
-       &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-arrays_use-members-example-template_parameters&quot;&gt;
         &lt;para&gt;These template parameters, used in the &array;
         parameter's type, permit the function to work with any
--- 1800,1830 ----
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
!     &lt;para&gt;We illustrate using &array; member functions in &lt;xref
!     linkend=&quot;arrays-arrays_use-members_example&quot;&gt;&lt;/xref&gt;.  The program
!     computes the total number of &array;'s indices, comparing the
!     result with invoking its &lt;methodname&gt;size&lt;/methodname&gt; method.
!     Since the &array;'s name is &lt;varname&gt;a&lt;/varname&gt;,
!     &lt;statement&gt;a.size()&lt;/statement&gt; returns its size.  The
!     &lt;function&gt;computeArraySize&lt;/function&gt; function also computes the
!     &array;'s size.  This templated function uses its three template
!     parameters to accept any &array;, regardless of its dimension,
!     value type, or &engine; tag.  It begins by obtaining the range of
!     indices for all dimensions and their lengths.  Only the latter is
!     necessary for the computation, but using the former further
!     illustrates using member functions.  The domain's size is the
!     product of the length of each dimension.  Since the lengths are
!     stored in the &lt;type&gt;Loc&lt;&amp;dim&gt;&lt;/type&gt;
!     &lt;varname&gt;lens&lt;/varname&gt;, &lt;statement&gt;lens[d]&lt;/statement&gt; is a
!     &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;, for which its
!     &lt;methodname&gt;first&lt;/methodname&gt; member function extracts the
!     length.  The &lt;methodname&gt;length&lt;/methodname&gt; &array; member
!     function is used in the &lt;function&gt;PAssert&lt;/function&gt;.&lt;/para&gt;
  
      &lt;example id=&quot;arrays-arrays_use-members_example&quot;&gt;
       &lt;title&gt;Using &array; Member Functions&lt;/title&gt;
       &amp;array-size;
       &lt;calloutlist&gt;
        &lt;callout arearefs=&quot;arrays-arrays_use-members-example-template_parameters&quot;&gt;
         &lt;para&gt;These template parameters, used in the &array;
         parameter's type, permit the function to work with any
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1815,1849 ****
         &lt;para&gt;&lt;statement&gt;lens[d]&lt;/statement&gt; returns a
         &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt; for
         dimension&nbsp;&lt;varname&gt;d&lt;/varname&gt;'s length.  Invoking
!        &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt; &lt;methodname&gt;first&lt;/methodname&gt;method
         yields its value.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-arrays_use-members-example-check_length&quot;&gt;
         &lt;para&gt;This comparison is unnecessary but further illustrates
         using member functions.&lt;/para&gt;
        &lt;/callout&gt;
       &lt;/calloutlist&gt;
      &lt;/example&gt;
- 
-     &lt;para&gt;We illustrate using &array; member functions in &lt;xref
-     linkend=&quot;arrays-arrays_use-members_example&quot;&gt;&lt;/xref&gt;.  The program
-     computes the total number of &array;'s indices, comparing the
-     result with invoking its &lt;methodname&gt;size&lt;/methodname&gt; method.
-     Since the &array;'s name is &lt;varname&gt;a&lt;/varname&gt;,
-     &lt;statement&gt;a.size()&lt;/statement&gt; returns its size.
-     &lt;function&gt;computeArraySize&lt;/function&gt; also computes the &array;'s
-     size.  This templated function uses its three template parameters
-     to accept any &array;, regardless of its dimension, value type, or
-     &engine; tag.  It begins by obtaining the range of indices for all
-     dimensions and their lengths.  Only the latter is necessary for
-     the computation, but the former further illustrate using member
-     functions.  The domain's size is the product of the length of each
-     dimension.  Since the lengths are stored in the
-     &lt;type&gt;Loc&lt;&amp;dim&gt;&lt;/type&gt; &lt;varname&gt;lens&lt;/varname&gt;,
-     &lt;statement&gt;lens[d]&lt;/statement&gt; is a &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;, for
-     which its &lt;methodname&gt;first&lt;/methodname&gt; extracts the length.  The
-     &lt;methodname&gt;length&lt;/methodname&gt; &array; member function is used in
-     the &lt;function&gt;PAssert&lt;/function&gt;.&lt;/para&gt;
     &lt;/section&gt;
  
  
--- 1839,1860 ----
         &lt;para&gt;&lt;statement&gt;lens[d]&lt;/statement&gt; returns a
         &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt; for
         dimension&nbsp;&lt;varname&gt;d&lt;/varname&gt;'s length.  Invoking
!        &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt; &lt;methodname&gt;first&lt;/methodname&gt; method
         yields its value.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-arrays_use-members-example-check_length&quot;&gt;
         &lt;para&gt;This comparison is unnecessary but further illustrates
         using member functions.&lt;/para&gt;
        &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-arrays_use-members-example-compare_size&quot;&gt;
+        &lt;para&gt;The &lt;methodname&gt;size&lt;/methodname&gt; is invoked by
+        prepending the &array;'s name followed by a period.  This
+        assertion is unnecessary, but the
+        &lt;function&gt;computeArraySize&lt;/function&gt; function further
+        illustrates using member functions.&lt;/para&gt;
+       &lt;/callout&gt;
       &lt;/calloutlist&gt;
      &lt;/example&gt;
     &lt;/section&gt;
  
  
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1851,1942 ****
      &lt;title&gt;&dynamicarray;s&lt;/title&gt;
  
      &lt;para&gt;&array;s have fixed domains so the set of valid indices
!     remains fixed after declaration.  The &dynamicarray; class
!     supports one-dimensional domains that can be resized even while
!     the array is used.&lt;/para&gt;
  
      &lt;para&gt;&dynamicarray;'s interface extends the one-dimensional
      interface of an &array; by adding member functions to change the
      domain's size.  It is declared in &lt;filename
      class=&quot;libraryfile&quot;&gt;Pooma/DynamicArrays.h&lt;/filename&gt;.  A
      &dynamicarray; has two, not three, template parameters, omitting
!     the array's dimensionality.  The first
      parameter&nbsp;&lt;type&gt;T&lt;/type&gt; specifies the type of stored values.
!     Its default value is usually &double;, but it may be changed when
!     the &poomatoolkit; is configured.  The second parameter specifies
!     an &engine; via a tag.  The engine must support a domain with
!     dynamic resizing.  For example, the &dynamic; &engine; is
!     analogous to a one-dimensional &brick; &engine; supporting a
!     dynamically-resizable domain.  It is also usually the default
!     value for this tag.  For example, &lt;statement&gt;DynamicArray&lt;&gt;
!     d0(1);&lt;/statement&gt;, &lt;statement&gt;DynamicArray&lt;double&gt;
!     d1(1);&lt;/statement&gt;, and &lt;statement&gt;DynamicArray&lt;double,
!     Dynamic&gt; d2(1);&lt;/statement&gt; all declare the same
!     &dynamicarray;s explicitly storing one &double; value.  A
!     &dynamicarray; automatically allocates its initial memory and
!     deallocates its final memory, just as an &array; does.&lt;/para&gt;
  
-     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
- 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-change_size&quot;&gt;
-      &lt;title&gt;Changing a &dynamicarray;'s Domain&lt;/title&gt;
-      
-      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
-       &lt;thead&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&dynamicarray; member function&lt;/entry&gt;
- 	&lt;entry&gt;description&lt;/entry&gt;
-        &lt;/row&gt;
-       &lt;/thead&gt;
-       &lt;tfoot&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;This table omits member functions designed for
- 	distributed computation.&lt;/entry&gt;
-        &lt;/row&gt;
-       &lt;/tfoot&gt;
-       &lt;tbody&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;void create(int num)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;extend the current domain by the requested number of
-         elements.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;remove the elements specified by the indices in the
- 	given &domain; argument.  &lt;quote&gt;Backfill&lt;/quote&gt; moves
- 	elements from the end of the domain to replace the deleted
- 	elements.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;remove the elements specified by the indices in the
- 	container range [begin,end) specified by the random-access
- 	iterators.  &lt;quote&gt;Backfill&lt;/quote&gt; moves elements from the
- 	end of the domain to replace the deleted elements.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList, const
- 	DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
- 
- 	&lt;entry&gt;remove the elements specified by the indices in the
- 	given &domain; argument.  Deleted elements can be replaced by
- 	&lt;type&gt;BackFill&lt;/type&gt;'ing, i.e., moving data from the domain's
- 	end to fill removed elements, or by &lt;type&gt;ShiftUp&lt;/type&gt;'ing,
- 	i.e., compacting all data but maintaining relative ordering.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd,
- 	const DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
-         &lt;entry&gt;remove the elements specified by the indices in the
- 	container range [begin,end) specified by the random-access
- 	iterators.  Deleted elements can be replaced by
- 	&lt;type&gt;BackFill&lt;/type&gt;'ing, i.e., moving data from the domain's
- 	end to fill removed elements, or by &lt;type&gt;ShiftUp&lt;/type&gt;'ing,
- 	i.e., compacting all data but maintaining relative ordering.&lt;/entry&gt;
-        &lt;/row&gt;
-       &lt;/tbody&gt;
-      &lt;/tgroup&gt;
-     &lt;/table&gt;
- 
      &lt;para&gt;The &lt;methodname&gt;create&lt;/methodname&gt; and
      &lt;methodname&gt;destroy&lt;/methodname&gt; member functions permit changing
      a &dynamicarray;'s domain.  &lt;xref
--- 1862,1895 ----
      &lt;title&gt;&dynamicarray;s&lt;/title&gt;
  
      &lt;para&gt;&array;s have fixed domains so the set of valid indices
!     remains fixed after creation.  The &lt;glossterm
!     linkend=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;
!     class&lt;/glossterm&gt;&lt;!-- FIXME: Add firstterm here. --&gt; supports
!     one-dimensional domains that can be resized even while the array
!     is used.&lt;/para&gt;
  
      &lt;para&gt;&dynamicarray;'s interface extends the one-dimensional
      interface of an &array; by adding member functions to change the
      domain's size.  It is declared in &lt;filename
      class=&quot;libraryfile&quot;&gt;Pooma/DynamicArrays.h&lt;/filename&gt;.  A
      &dynamicarray; has two, not three, template parameters, omitting
!     the array's dimensionality which must be one.  The first
      parameter&nbsp;&lt;type&gt;T&lt;/type&gt; specifies the type of stored values.
!     Its default value is usually &double;, but this may be changed
!     when the &poomatoolkit; is configured.  The second parameter
!     specifies an &engine; via an &engine; tag.  The engine must
!     support a domain with dynamic resizing.  For example, the
!     &dynamic; &engine; is analogous to a one-dimensional &brick;
!     &engine; supporting a dynamically-resizable domain.  It is also
!     usually the default value for this tag.  For example,
!     &lt;statement&gt;DynamicArray&lt;&gt; d0(1);&lt;/statement&gt;,
!     &lt;statement&gt;DynamicArray&lt;double&gt; d1(1);&lt;/statement&gt;, and
!     &lt;statement&gt;DynamicArray&lt;double, Dynamic&gt; d2(1);&lt;/statement&gt;
!     all declare the same &dynamicarray;s explicitly storing one
!     &double; value.  A &dynamicarray; automatically allocates its
!     initial memory and deallocates its final memory, just as an
!     &array; does.&lt;/para&gt;
  
      &lt;para&gt;The &lt;methodname&gt;create&lt;/methodname&gt; and
      &lt;methodname&gt;destroy&lt;/methodname&gt; member functions permit changing
      a &dynamicarray;'s domain.  &lt;xref
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1948,1954 ****
      for&nbsp;&lt;type&gt;T&lt;/type&gt;.  Existing values are copied.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-table&quot;&gt;
       &lt;title&gt;Changing a &dynamicarray;'s Domain&lt;/title&gt;
       
       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
--- 1901,1907 ----
      for&nbsp;&lt;type&gt;T&lt;/type&gt;.  Existing values are copied.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-change_size&quot;&gt;
       &lt;title&gt;Changing a &dynamicarray;'s Domain&lt;/title&gt;
       
       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1964,1970 ****
  	distributed computation.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;void create(int num)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;extend the current domain by the requested number of
--- 1917,1923 ----
  	distributed computation.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;void create(int num)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;extend the current domain by the requested number of
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1972,2019 ****
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;remove the elements specified by the indices in the
! 	given &domain; argument.  &lt;quote&gt;Backfill&lt;/quote&gt; moves
! 	elements from the end of the domain to replace the deleted
! 	elements.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;remove the elements specified by the indices in the
  	container range [begin,end) specified by the random-access
! 	iterators.  &lt;quote&gt;Backfill&lt;/quote&gt; moves elements from the
! 	end of the domain to replace the deleted elements.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList, const
  	DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
  
! 	&lt;entry&gt;remove the elements specified by the indices in the
! 	given &domain; argument.  Deleted elements can be replaced by
  	&lt;type&gt;BackFill&lt;/type&gt;'ing, i.e., moving data from the domain's
! 	end to fill removed elements, or by &lt;type&gt;ShiftUp&lt;/type&gt;'ing,
! 	i.e., compacting all data but maintaining relative ordering.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd,
  	const DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
!         &lt;entry&gt;remove the elements specified by the indices in the
  	container range [begin,end) specified by the random-access
! 	iterators.  Deleted elements can be replaced by
  	&lt;type&gt;BackFill&lt;/type&gt;'ing, i.e., moving data from the domain's
! 	end to fill removed elements, or by &lt;type&gt;ShiftUp&lt;/type&gt;'ing,
! 	i.e., compacting all data but maintaining relative ordering.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
!     &lt;para&gt;The &lt;methodname&gt;destroy&lt;/methodname&gt; deletes specified
!     indices.  The indices may be specified using either a &domain;
!     object (&lt;type&gt;Interval&lt;1&gt;&lt;/type&gt;,
      &lt;type&gt;Range&lt;1&gt;&lt;/type&gt;, or &lt;type&gt;IndirectionList&lt;/type&gt;) or
!     in a container specified using random-access iterators.  For
!     example, every other element from a ten-element
      array&nbsp;&lt;varname&gt;d&lt;/varname&gt; might be removed using
      &lt;statement&gt;Range&lt;1&gt;(0,9,2)&lt;/statement&gt;.  Alternatively,
  &lt;programlisting&gt;
--- 1925,1975 ----
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;remove the values specified by the indices in the given
! 	&domain; argument.  The &lt;quote&gt;Backfill&lt;/quote&gt; method moves
! 	values from the end of the domain to replace the deleted
! 	values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
! 	iterators.  The &lt;quote&gt;Backfill&lt;/quote&gt; method moves values
! 	from the end of the domain to replace the deleted
! 	values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList, const
  	DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
  
! 	&lt;entry&gt;remove the values specified by the indices in the
! 	given &domain; argument.  Deleted values can be replaced by
  	&lt;type&gt;BackFill&lt;/type&gt;'ing, i.e., moving data from the domain's
! 	end to fill removed values, or by &lt;type&gt;ShiftUp&lt;/type&gt;'ing,
! 	i.e., compacting all data but maintaining the relative
! 	ordering.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd,
  	const DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
!         &lt;entry&gt;remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
! 	iterators.  Deleted values can be replaced by
  	&lt;type&gt;BackFill&lt;/type&gt;'ing, i.e., moving data from the domain's
! 	end to fill removed values, or by &lt;type&gt;ShiftUp&lt;/type&gt;'ing,
! 	i.e., compacting all data but maintaining the relative
! 	ordering.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
!     &lt;para&gt;The &lt;methodname&gt;destroy&lt;/methodname&gt; member function deletes
!     the specified indices.  The indices may be specified using either
!     a &domain; object (&lt;type&gt;Interval&lt;1&gt;&lt;/type&gt;,
      &lt;type&gt;Range&lt;1&gt;&lt;/type&gt;, or &lt;type&gt;IndirectionList&lt;/type&gt;) or
!     by random-access iterators pointing into a container.  For
!     example, every other value from a ten-value
      array&nbsp;&lt;varname&gt;d&lt;/varname&gt; might be removed using
      &lt;statement&gt;Range&lt;1&gt;(0,9,2)&lt;/statement&gt;.  Alternatively,
  &lt;programlisting&gt;
*************** d.destroy(killList, killList+5);
*** 2023,2048 ****
      removed, other indices are moved into their positions.  Using the
      &lt;type&gt;BackFill&lt;/type&gt; method moves the last index and its
      associated value into deleted index's position.  Thus, the total
!     number of indices is decreased by one, but the indices can be
      reordered.  Using the &lt;type&gt;ShiftUp&lt;/type&gt; method ensures the
!     indices' orders are maintained by &lt;quote&gt;shifting&lt;/quote&gt; all
!     elements left (or up) so all &lt;quote&gt;gaps&lt;/quote&gt; between indices
      disappear.  For example, consider removing the first index from a
      domain.
      &lt;informaltable frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-destroy_example&quot;&gt;
       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;original indices:&lt;/entry&gt;
  	&lt;entry&gt;0 1 2 3&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;methodname&gt;destroy&lt;/methodname&gt; using &lt;type&gt;BackFill&lt;/type&gt;&lt;/entry&gt;
  	&lt;entry&gt;3 1 2&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;methodname&gt;destroy&lt;/methodname&gt; using &lt;type&gt;ShiftUp&lt;/type&gt;&lt;/entry&gt;
  	&lt;entry&gt;1 2 3&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
--- 1979,2004 ----
      removed, other indices are moved into their positions.  Using the
      &lt;type&gt;BackFill&lt;/type&gt; method moves the last index and its
      associated value into deleted index's position.  Thus, the total
!     number of indices is decreased by one, but the indices are
      reordered.  Using the &lt;type&gt;ShiftUp&lt;/type&gt; method ensures the
!     order of the indices is preserved by &lt;quote&gt;shifting&lt;/quote&gt; all
!     values left (or up) so all &lt;quote&gt;gaps&lt;/quote&gt; between indices
      disappear.  For example, consider removing the first index from a
      domain.
      &lt;informaltable frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-destroy_example&quot;&gt;
       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;original indices:&lt;/entry&gt;
  	&lt;entry&gt;0 1 2 3&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;methodname&gt;destroy&lt;/methodname&gt; using &lt;type&gt;BackFill&lt;/type&gt;:&lt;/entry&gt;
  	&lt;entry&gt;3 1 2&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;methodname&gt;destroy&lt;/methodname&gt; using &lt;type&gt;ShiftUp&lt;/type&gt;:&lt;/entry&gt;
  	&lt;entry&gt;1 2 3&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
*************** d.destroy(killList, killList+5);
*** 2054,2101 ****
      that &lt;type&gt;BackFill&lt;/type&gt; moves exactly as many indices as are
      deleted, while &lt;type&gt;ShiftUp&lt;/type&gt; can shift all indices in a
      domain.  Thus, &lt;type&gt;BackFill&lt;/type&gt; is the default method.  When
!     multiple indices are deleted, they are deleted from the largest to
!     the smallest.  When using the &lt;type&gt;BackFill&lt;/type&gt; method, some
!     indices may be moved repeatedly.  For example, consider removing
!     indices 0 and 2 from original indices of 0 1 2 3.  Removing 2
!     yields 0 1 3.  Removing 0 yields 3 1.  Using an object with the
!     desired type to indicate which fill method is desired, i.e.,
!     &lt;statement&gt;BackFill()&lt;/statement&gt; or
      &lt;statement&gt;ShiftUp()&lt;/statement&gt;.&lt;/para&gt;
  
-     &lt;example id=&quot;arrays-dynamic_arrays-example&quot;&gt;
-      &lt;title&gt;Example Using &dynamicarray;s&lt;/title&gt;
- 
-      &amp;dynamicarray-example;
-      &lt;calloutlist&gt;
-       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-header&quot;&gt;
-        &lt;para&gt;This header file declares &dynamicarray;s.&lt;/para&gt;
-       &lt;/callout&gt;
-       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-identical_declarations&quot;&gt;
-        &lt;para&gt;These three declarations yield equivalent
-        &dynamicarray;s, storing one &double; value.&lt;/para&gt;
-       &lt;/callout&gt;
-       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-extension&quot;&gt;
-        &lt;para&gt;This &lt;methodname&gt;create&lt;/methodname&gt; member function adds
-        five indices to the end of the domain.&lt;/para&gt;
-       &lt;/callout&gt;
-       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-access&quot;&gt;
-        &lt;para&gt;&dynamicarray; values are accessed the same way as
-        &array; values.&lt;/para&gt;
-       &lt;/callout&gt;
-       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-destroy_range&quot;&gt;
-        &lt;para&gt;The &range; object specifies that every other index
-        should be removed.  The &lt;statement&gt;BackFill()&lt;/statement&gt;
-        object is unnecessary since it is the default replacement
-        method.&lt;/para&gt;
-       &lt;/callout&gt;
-       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-destroy_iterators&quot;&gt;
-        &lt;para&gt;This &lt;methodname&gt;destroy&lt;/methodname&gt; call is equivalent
-        to the previous one but uses iterators.&lt;/para&gt;
-       &lt;/callout&gt;
-      &lt;/calloutlist&gt;
-     &lt;/example&gt;
- 
      &lt;para&gt;We illustrate &dynamicarray; resizing in &lt;xref
      linkend=&quot;arrays-dynamic_arrays-example&quot;&gt;&lt;/xref&gt;.  &dynamicarray;s
      are declared in &lt;filename
--- 2010,2025 ----
      that &lt;type&gt;BackFill&lt;/type&gt; moves exactly as many indices as are
      deleted, while &lt;type&gt;ShiftUp&lt;/type&gt; can shift all indices in a
      domain.  Thus, &lt;type&gt;BackFill&lt;/type&gt; is the default method.  When
!     multiple indices are deleted, they are deleted from the last
!     (largest) to the first (smallest).  When using the
!     &lt;type&gt;BackFill&lt;/type&gt; method, some indices may be moved
!     repeatedly.  For example, consider removing indices 0 and 2 from
!     original indices of 0 1 2 3.  Removing 2 yields 0 1 3 because 3 is
!     moved into 2's position.  Removing 0 yields 3 1 because 3 is again
!     moved.  Use an object with the desired type to indicate which fill
!     method is desired, i.e., &lt;statement&gt;BackFill()&lt;/statement&gt; or
      &lt;statement&gt;ShiftUp()&lt;/statement&gt;.&lt;/para&gt;
  
      &lt;para&gt;We illustrate &dynamicarray; resizing in &lt;xref
      linkend=&quot;arrays-dynamic_arrays-example&quot;&gt;&lt;/xref&gt;.  &dynamicarray;s
      are declared in &lt;filename
*************** d.destroy(killList, killList+5);
*** 2104,2110 ****
      require two, not three, template arguments because the array must
      be one-dimensional.  The three arrays, each having one &double;
      value, are equivalent.  (The &poomatoolkit; can be configured to
!     support different default values.)  Invoking
      &lt;varname&gt;d0&lt;/varname&gt;'s &lt;methodname&gt;create&lt;/methodname&gt; with an
      argument of five increases its domain size from one to six.  The
      additional indices are added to the end of the domain so the value
--- 2028,2034 ----
      require two, not three, template arguments because the array must
      be one-dimensional.  The three arrays, each having one &double;
      value, are equivalent.  (The &poomatoolkit; can be configured to
!     support different default template values.)  Invoking
      &lt;varname&gt;d0&lt;/varname&gt;'s &lt;methodname&gt;create&lt;/methodname&gt; with an
      argument of five increases its domain size from one to six.  The
      additional indices are added to the end of the domain so the value
*************** d.destroy(killList, killList+5);
*** 2113,2143 ****
      all values equal to their indices.  This illustrates that
      &dynamicarray; values are accessed the same way as &array; values.
      For example, &lt;statement&gt;d0(i)&lt;/statement&gt; accesses the
!     &lt;varname&gt;i&lt;/varname&gt;th value.  The
!     &lt;methodname&gt;destroy&lt;/methodname&gt; removes every other index from
!     the array.  The one-dimensional &range; specifies these indices by
!     specifying the domain's entire interval and a stride of&nbsp;2.
      The &lt;statement&gt;BackFill&lt;/statement&gt; function call creates a
      &lt;type&gt;BackFill&lt;/type&gt; object indicating the &lt;type&gt;BackFill&lt;/type&gt;
      method should be used.  We illustrate the steps of this method:
      &lt;informaltable frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-program_example&quot;&gt;
       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;original indices:&lt;/entry&gt;
  	&lt;entry&gt;0 1 2 3 4 5&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;delete index 4&lt;/entry&gt;
  	&lt;entry&gt;0 1 2 3 5&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;delete index 2&lt;/entry&gt;
  	&lt;entry&gt;0 1 5 3&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;delete index 0&lt;/entry&gt;
  	&lt;entry&gt;3 1 5&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
--- 2037,2067 ----
      all values equal to their indices.  This illustrates that
      &dynamicarray; values are accessed the same way as &array; values.
      For example, &lt;statement&gt;d0(i)&lt;/statement&gt; accesses the
!     &lt;varname&gt;i&lt;/varname&gt;&lt;superscript&gt;th&lt;/superscript&gt; value.  The
!     &lt;methodname&gt;destroy&lt;/methodname&gt; member function removes every
!     other index from the array because the one-dimensional &range;
!     specifies the domain's entire interval with a stride of&nbsp;2.
      The &lt;statement&gt;BackFill&lt;/statement&gt; function call creates a
      &lt;type&gt;BackFill&lt;/type&gt; object indicating the &lt;type&gt;BackFill&lt;/type&gt;
      method should be used.  We illustrate the steps of this method:
      &lt;informaltable frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-dynamic_arrays-program_example&quot;&gt;
       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;original indices:&lt;/entry&gt;
  	&lt;entry&gt;0 1 2 3 4 5&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;delete index 4:&lt;/entry&gt;
  	&lt;entry&gt;0 1 2 3 5&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;delete index 2:&lt;/entry&gt;
  	&lt;entry&gt;0 1 5 3&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;delete index 0:&lt;/entry&gt;
  	&lt;entry&gt;3 1 5&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
*************** d.destroy(killList, killList+5);
*** 2146,2152 ****
      Since multiple indices are specified, the rightmost one is removed
      first, i.e., index&nbsp;4.  The rightmost index&nbsp;5 is moved
      into 4's position.  When removing index&nbsp;2, the index
!     originally at 5 is moved again into 2's position.  Finally,
      index&nbsp;0 is replaced by index&nbsp;3.  The rest of the program
      repeats the computation, using the random-access iterator version
      of &lt;methodname&gt;destroy&lt;/methodname&gt;.  Since this &dynamicarray;'s
--- 2070,2076 ----
      Since multiple indices are specified, the rightmost one is removed
      first, i.e., index&nbsp;4.  The rightmost index&nbsp;5 is moved
      into 4's position.  When removing index&nbsp;2, the index
!     originally at 5 is again moved into 2's position.  Finally,
      index&nbsp;0 is replaced by index&nbsp;3.  The rest of the program
      repeats the computation, using the random-access iterator version
      of &lt;methodname&gt;destroy&lt;/methodname&gt;.  Since this &dynamicarray;'s
*************** d.destroy(killList, killList+5);
*** 2158,2166 ****
--- 2082,2125 ----
      method is specified, the default &lt;type&gt;BackFill&lt;/type&gt; method is
      used.  All the &dynamicarray;s' unallocated memory is
      deallocated.&lt;/para&gt;
+ 
+     &lt;example id=&quot;arrays-dynamic_arrays-example&quot;&gt;
+      &lt;title&gt;Example Using &dynamicarray;s&lt;/title&gt;
+ 
+      &amp;dynamicarray-example;
+      &lt;calloutlist&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-header&quot;&gt;
+        &lt;para&gt;This header file declares &dynamicarray;s.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-identical_declarations&quot;&gt;
+        &lt;para&gt;These three declarations yield equivalent
+        &dynamicarray;s, storing one &double; value.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-extension&quot;&gt;
+        &lt;para&gt;This &lt;methodname&gt;create&lt;/methodname&gt; member function call
+        adds five indices to the end of the domain.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-access&quot;&gt;
+        &lt;para&gt;&dynamicarray; values are accessed the same way as
+        &array; values.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-destroy_range&quot;&gt;
+        &lt;para&gt;The &range; object specifies that every other index
+        should be removed.  The &lt;statement&gt;BackFill()&lt;/statement&gt;
+        object is unnecessary since it is the default replacement
+        method.&lt;/para&gt;
+       &lt;/callout&gt;
+       &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-destroy_iterators&quot;&gt;
+        &lt;para&gt;This &lt;methodname&gt;destroy&lt;/methodname&gt; call is equivalent
+        to the previous one but uses iterators.&lt;/para&gt;
+       &lt;/callout&gt;
+      &lt;/calloutlist&gt;
+     &lt;/example&gt;
+ 
     &lt;/section&gt;
  
  
+ &lt;![%unfinished;[
     &lt;section id=&quot;arrays-doof2d&quot;&gt;
      &lt;title&gt;An &array; Implementation of &amp;doof2d;&lt;/title&gt;
  
*************** d.destroy(killList, killList+5);
*** 2177,2181 ****
--- 2136,2141 ----
      to describe how a programmer would implement a new type of domain?
      Probably not.&lt;/para&gt;
     &lt;/section&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
    &lt;/chapter&gt;
Index: bibliography.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/bibliography.xml,v
retrieving revision 1.1
diff -c -p -r1.1 bibliography.xml
*** bibliography.xml	2002/01/04 17:42:43	1.1
--- bibliography.xml	2002/01/25 02:15:03
***************
*** 1,5 ****
--- 1,7 ----
  &lt;!-- Bibliography --&gt;
  
+ &lt;![%unfinished;[
+ 
  &lt;bibliography id=&quot;bibliography&quot;&gt;
   &lt;title&gt;Bibliography&lt;/title&gt;
  
*************** Array.  1995.  unpublished.  Available a
*** 275,277 ****
--- 277,281 ----
  
  
  &lt;/bibliography&gt;
+ 
+ ]]&gt;  &lt;!-- end unfinished --&gt;
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.8
diff -c -p -r1.8 concepts.xml
*** concepts.xml	2002/01/24 05:11:21	1.8
--- concepts.xml	2002/01/25 02:15:04
***************
*** 57,63 ****
  	&lt;entry&gt;Computation Environment&lt;/entry&gt;
       &lt;/row&gt;
      &lt;/thead&gt;
!     &lt;tbody&gt;
       &lt;row&gt;
  	&lt;entry&gt;&array;&lt;/entry&gt;
  	&lt;entry&gt;element-wise&lt;/entry&gt;
--- 57,63 ----
  	&lt;entry&gt;Computation Environment&lt;/entry&gt;
       &lt;/row&gt;
      &lt;/thead&gt;
!     &lt;tbody valign=&quot;top&quot;&gt;
       &lt;row&gt;
  	&lt;entry&gt;&array;&lt;/entry&gt;
  	&lt;entry&gt;element-wise&lt;/entry&gt;
***************
*** 136,142 ****
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-table&quot;&gt;
     &lt;title&gt;&pooma; Container Summary&lt;/title&gt;
     &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!     &lt;tbody&gt;
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm
  	linkend=&quot;glossary-array&quot;&gt;&array;&lt;/glossterm&gt;&lt;/entry&gt;
--- 136,142 ----
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-table&quot;&gt;
     &lt;title&gt;&pooma; Container Summary&lt;/title&gt;
     &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!     &lt;tbody valign=&quot;top&quot;&gt;
       &lt;row&gt;
  	&lt;entry&gt;&lt;glossterm
  	linkend=&quot;glossary-array&quot;&gt;&array;&lt;/glossterm&gt;&lt;/entry&gt;
***************
*** 265,271 ****
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-choice_table&quot;&gt;
     &lt;title&gt;Choosing a &pooma; Container&lt;/title&gt;
     &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!     &lt;tbody&gt;
       &lt;row&gt;
  	&lt;entry&gt;If modeling mathematical entries,&lt;/entry&gt;
  	&lt;entry&gt;use a &vector;, &matrix;, or &tensor;.&lt;/entry&gt;
--- 265,271 ----
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-choice_table&quot;&gt;
     &lt;title&gt;Choosing a &pooma; Container&lt;/title&gt;
     &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!     &lt;tbody valign=&quot;top&quot;&gt;
       &lt;row&gt;
  	&lt;entry&gt;If modeling mathematical entries,&lt;/entry&gt;
  	&lt;entry&gt;use a &vector;, &matrix;, or &tensor;.&lt;/entry&gt;
Index: data-parallel.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/data-parallel.xml,v
retrieving revision 1.2
diff -c -p -r1.2 data-parallel.xml
*** data-parallel.xml	2002/01/24 05:11:21	1.2
--- data-parallel.xml	2002/01/25 02:15:05
***************
*** 1,16 ****
    &lt;chapter id=&quot;data_parallel&quot;&gt;
     &lt;title&gt;Data-Parallel Expressions&lt;/title&gt;
  
!    &lt;para&gt;In the previous sections, we accessed container values one at
     a time.  Accessing more than one value in a container required a
     writing an explicit loop.  Scientists and engineers commonly
     operate on sets of values, treated as an aggregate.  For example, a
     vector is a one-dimension collection of data and two vectors can be
     added together.  A matrix is a two-dimensional collection of data,
!    and a scalar and a matrix are multiplied.  A &lt;glossterm
     linkend=&quot;glossary-data_parallel&quot;&gt;&lt;firstterm&gt;data-parallel
     expression&lt;/firstterm&gt;&lt;/glossterm&gt; simultaneously uses multiple
!    container values.  &pooma; supports data-parallel syntax.&lt;/para&gt;
  
     &lt;para&gt;After introducing data-parallel expressions and statements,
     we present the corresponding &pooma; syntax.  Then we present its
--- 1,17 ----
    &lt;chapter id=&quot;data_parallel&quot;&gt;
     &lt;title&gt;Data-Parallel Expressions&lt;/title&gt;
  
!    &lt;para&gt;In the previous chapters, we accessed container values one at
     a time.  Accessing more than one value in a container required a
     writing an explicit loop.  Scientists and engineers commonly
     operate on sets of values, treated as an aggregate.  For example, a
     vector is a one-dimension collection of data and two vectors can be
     added together.  A matrix is a two-dimensional collection of data,
!    and a scalar and a matrix can be multiplied.  A &lt;glossterm
     linkend=&quot;glossary-data_parallel&quot;&gt;&lt;firstterm&gt;data-parallel
     expression&lt;/firstterm&gt;&lt;/glossterm&gt; simultaneously uses multiple
!    container values.  &pooma; supports data-parallel
!    expressions.&lt;/para&gt;
  
     &lt;para&gt;After introducing data-parallel expressions and statements,
     we present the corresponding &pooma; syntax.  Then we present its
***************
*** 61,73 ****
      &lt;para&gt;&pooma; containers can be used in data-parallel expressions
      and statements.  The basic guidelines are simple:
      &lt;itemizedlist&gt;
! 		   &lt;listitem&gt;
! 		   &lt;para&gt;The &cc; built-in and mathematical operators operate on
         an entire container by operating element-wise on its values.&lt;/para&gt;
!    &lt;/listitem&gt;
      &lt;listitem&gt;
       &lt;para&gt;Binary operators operate only on containers with the same
!       domain types by combining values with the same indices.  If the
        result is a container, it has a domain equal to the left operand's
        domain.&lt;/para&gt;
      &lt;/listitem&gt;
--- 62,74 ----
      &lt;para&gt;&pooma; containers can be used in data-parallel expressions
      and statements.  The basic guidelines are simple:
      &lt;itemizedlist&gt;
!      &lt;listitem&gt;
!       &lt;para&gt;The &cc; built-in and mathematical operators operate on
         an entire container by operating element-wise on its values.&lt;/para&gt;
!      &lt;/listitem&gt;
      &lt;listitem&gt;
       &lt;para&gt;Binary operators operate only on containers with the same
!       domain types and by combining values with the same indices.  If the
        result is a container, it has a domain equal to the left operand's
        domain.&lt;/para&gt;
      &lt;/listitem&gt;
***************
*** 79,86 ****
     &lt;/itemizedlist&gt;
     &lt;/para&gt;
  
!     &lt;para&gt;The operators operate element-wise on containers' values.
!     For example, if &lt;varname&gt;A&lt;/varname&gt; is a one-dimensional array,
      &lt;statement&gt;-&lt;varname&gt;A&lt;/varname&gt;&lt;/statement&gt; is a one-dimensional
      array with the same size such that the value at the
      i&lt;superscript&gt;th&lt;/superscript&gt; position equals -A(i).  If
--- 80,88 ----
     &lt;/itemizedlist&gt;
     &lt;/para&gt;
  
!     &lt;para&gt;The data-parallel operators operate element-wise on
!     containers' values.  For example, if &lt;varname&gt;A&lt;/varname&gt; is a
!     one-dimensional array,
      &lt;statement&gt;-&lt;varname&gt;A&lt;/varname&gt;&lt;/statement&gt; is a one-dimensional
      array with the same size such that the value at the
      i&lt;superscript&gt;th&lt;/superscript&gt; position equals -A(i).  If
***************
*** 91,114 ****
      corresponding values in &lt;varname&gt;A&lt;/varname&gt; and
      &lt;varname&gt;B&lt;/varname&gt;.&lt;/para&gt;
  
-     &lt;figure float=&quot;1&quot; id=&quot;data_parallel-use-addition_example&quot;&gt;
-      &lt;title&gt;Adding &array;s with Different Domains&lt;/title&gt;
-        &lt;mediaobject&gt;
- 	&lt;imageobject&gt;
- 	 &lt;imagedata fileref=&quot;figures/data-parallel.212&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
- 	&lt;/imageobject&gt;
- 	&lt;textobject&gt;
- 	 &lt;phrase&gt;Adding two arrays with different domains adds values
-        with the same indices.&lt;/phrase&gt;
- 	&lt;/textobject&gt;
- 	&lt;caption&gt;
- 	 &lt;para&gt;Adding &array;s with different domains is supported.
-        Solid lines indicate the domains' extent.  Values with the same
-        indices are added.&lt;/para&gt;
-       &lt;/caption&gt;
-      &lt;/mediaobject&gt;
-     &lt;/figure&gt;
- 
      &lt;para&gt;Binary operators operate on containers with the same domain
      types.  The domain's indices need not be the same, but the result
      will have a domain equal to the left operand.  For example, the
--- 93,98 ----
*************** Interval&lt;1&gt; H(0,2), I(1,3), J(2,4);
*** 131,155 ****
  Array&lt;2, double, Brick&gt; A(I,I), B(J,H);
  // ... fill A and B with values ...
  ... = A + B;
! &lt;/programlisting&gt;Both &lt;varname&gt;A&lt;/varname&gt; and
!     &lt;varname&gt;B&lt;/varname&gt; have domains of two-dimensional intervals so
!     they may be added, but their domains' extent differ, as indicated
!     by the solid lines in the figure.  The sum has domain equal to the
!     left operand's domain.  Values with the same indices are added.  For
!     example, &lt;statement&gt;A(2,2)&lt;/statement&gt; and
!     &lt;statement&gt;B(2,2)&lt;/statement&gt; are added.  &lt;varname&gt;B&lt;/varname&gt;'s
!     domain does not include index (1,1) so, when adding
!     &lt;statement&gt;A(1,1)&lt;/statement&gt; and &lt;statement&gt;B(1,1)&lt;/statement&gt;,
!     the default value for &lt;varname&gt;B&lt;/varname&gt;'s value type is used.
!     Usually this is&nbsp;0.  Thus, &lt;statement&gt;A(1,1) +
!     B(1,1)&lt;/statement&gt; equals &lt;statement&gt;9 + 0&lt;/statement&gt;.&lt;/para&gt;
! 
!     &lt;para&gt;Operations with &array;s and scalar values are supported.
!     Conceptually, a scalar value can be thought of as an &array; with
!     any desired domain and having the same value everywhere.  For
!     example, consider
  &lt;programlisting&gt;
! 		 Array&lt;1, double, Brick&gt; D(Interval&lt;1&gt;(7,10));
  D += 2*D + 7;
  &lt;/programlisting&gt;&lt;statement&gt;2*D&lt;/statement&gt; obeys the guidelines
      because the scalar &lt;statement&gt;2&lt;/statement&gt; can be thought of as
--- 115,159 ----
  Array&lt;2, double, Brick&gt; A(I,I), B(J,H);
  // ... fill A and B with values ...
  ... = A + B;
! &lt;/programlisting&gt;&lt;/para&gt;
! 
!     &lt;figure float=&quot;1&quot; id=&quot;data_parallel-use-addition_example&quot;&gt;
!      &lt;title&gt;Adding &array;s with Different Domains&lt;/title&gt;
!        &lt;mediaobject&gt;
! 	&lt;imageobject&gt;
! 	 &lt;imagedata fileref=&quot;figures/data-parallel.212&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
! 	&lt;/imageobject&gt;
! 	&lt;textobject&gt;
! 	 &lt;phrase&gt;Adding two arrays with different domains adds values
!        with the same indices.&lt;/phrase&gt;
! 	&lt;/textobject&gt;
! 	&lt;caption&gt;
! 	 &lt;para&gt;Adding &array;s with different domains is supported.
!        Solid lines indicate the domains' extent.  Values with the same
!        indices are added.&lt;/para&gt;
!       &lt;/caption&gt;
!      &lt;/mediaobject&gt;
!     &lt;/figure&gt;
! 
!     &lt;para&gt;Both &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;B&lt;/varname&gt; have
!     domains of two-dimensional intervals so they may be added, but
!     their domains' extent differ, as indicated by the solid lines in
!     the figure.  The sum has domain equal to the left operand's
!     domain.  Values with the same indices are added.  For example,
!     &lt;statement&gt;A(2,2)&lt;/statement&gt; and &lt;statement&gt;B(2,2)&lt;/statement&gt;
!     are added.  &lt;varname&gt;B&lt;/varname&gt;'s domain does not include index
!     (1,1) so, when adding &lt;statement&gt;A(1,1)&lt;/statement&gt; and
!     &lt;statement&gt;B(1,1)&lt;/statement&gt;, the default value for
!     &lt;varname&gt;B&lt;/varname&gt;'s value type is used.  Usually this
!     is&nbsp;0.  Thus, &lt;statement&gt;A(1,1) + B(1,1)&lt;/statement&gt; equals
!     &lt;statement&gt;9 + 0&lt;/statement&gt;.&lt;/para&gt;
! 
!     &lt;para&gt;Operations with both &array;s and scalar values are
!     supported.  Conceptually, a scalar value can be thought of as an
!     &array; with any desired domain and having the same value
!     everywhere.  For example, consider
  &lt;programlisting&gt;
! Array&lt;1, double, Brick&gt; D(Interval&lt;1&gt;(7,10));
  D += 2*D + 7;
  &lt;/programlisting&gt;&lt;statement&gt;2*D&lt;/statement&gt; obeys the guidelines
      because the scalar &lt;statement&gt;2&lt;/statement&gt; can be thought of as
*************** D += 2*D + 7;
*** 163,180 ****
      not first convert scalar values to arrays but instead uses them
      directly in expressions.&lt;/para&gt;
  
!     &lt;para&gt;Assignment to containers is also supported.  The domain
      types of the assignment's left-hand side and its right-hand side
      must be the same.  Their indices need not be the same, but they
      must correspond.  That is, the domains must be &lt;glossterm
!     linkend=&quot;glossary-conformable_domains&quot;&gt;&lt;firstterm&gt;conformable
!     domains&lt;/firstterm&gt;&lt;/glossterm&gt;, or have the &lt;quote&gt;same
!     shape&lt;/quote&gt;, i.e., have the same number of indices for each
!     dimension.  For example, the one-dimensional interval [0,3] is
!     conformable to the one-dimensional interval [1,4] because they
!     both have the same number of indices in each dimension.  The
!     domains of &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;B&lt;/varname&gt;, as
!     declared
  &lt;programlisting&gt;
  Interval&lt;1&gt; H(0,2), I(1,3), J(2,4), K(0,4);
  Array&lt;2, double, Brick&gt; A(I,I), B(H,J), C(I,K);
--- 167,183 ----
      not first convert scalar values to arrays but instead uses them
      directly in expressions.&lt;/para&gt;
  
!     &lt;para&gt;Assignments to containers are also supported.  The domain
      types of the assignment's left-hand side and its right-hand side
      must be the same.  Their indices need not be the same, but they
      must correspond.  That is, the domains must be &lt;glossterm
!     linkend=&quot;glossary-conformable_domains&quot;&gt;&lt;firstterm&gt;conformable&lt;/firstterm&gt;&lt;/glossterm&gt;,
!     or have the &lt;quote&gt;same shape&lt;/quote&gt;, i.e., have the same number
!     of indices for each dimension.  For example, the one-dimensional
!     interval [0,3] is conformable to the one-dimensional interval
!     [1,4] because they both have the same number of indices in each
!     dimension.  The domains of &lt;varname&gt;A&lt;/varname&gt; and
!     &lt;varname&gt;B&lt;/varname&gt;, as declared
  &lt;programlisting&gt;
  Interval&lt;1&gt; H(0,2), I(1,3), J(2,4), K(0,4);
  Array&lt;2, double, Brick&gt; A(I,I), B(H,J), C(I,K);
*************** Array&lt;2, double, Brick&gt; A(I,I), B(H,J), 
*** 182,188 ****
      number of indices.  &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;C&lt;/varname&gt;
      are not conformable because, while their first dimensions are
      conformable, their second dimensions are not conformable.  It has
!     three indices while the other has four.  We define &lt;glossterm
      linkend=&quot;glossary-conformable_containers&quot;&gt;&lt;firstterm&gt;conformable
      containers&lt;/firstterm&gt;&lt;/glossterm&gt; to be containers with
      conformable domains.&lt;/para&gt;
--- 185,191 ----
      number of indices.  &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;C&lt;/varname&gt;
      are not conformable because, while their first dimensions are
      conformable, their second dimensions are not conformable.  It has
!     three indices while the other has five.  We define &lt;glossterm
      linkend=&quot;glossary-conformable_containers&quot;&gt;&lt;firstterm&gt;conformable
      containers&lt;/firstterm&gt;&lt;/glossterm&gt; to be containers with
      conformable domains.&lt;/para&gt;
*************** Array&lt;1, double, Brick&gt; A(Interval&lt;1&gt;(0,
*** 222,228 ****
  Array&lt;1, double, Brick&gt; B(Interval&lt;1&gt;(1,3));
  A = 1.0;
  B = 2.0;
! std::cout &lt;&lt; A-B &lt;&lt; std::endl;
  &lt;/programlisting&gt; yields
      &lt;computeroutput&gt;
      (000:002:001) = 1 -1 -1&lt;/computeroutput&gt;.  The initial
--- 225,231 ----
  Array&lt;1, double, Brick&gt; B(Interval&lt;1&gt;(1,3));
  A = 1.0;
  B = 2.0;
! std::cout &openopen; A-B &openopen; std::endl;
  &lt;/programlisting&gt; yields
      &lt;computeroutput&gt;
      (000:002:001) = 1 -1 -1&lt;/computeroutput&gt;.  The initial
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 233,261 ****
      &lt;para&gt;The following four tables list the data-parallel operators
      that operate on &array;s.  &lt;xref
      linkend=&quot;data_parallel-use-operators_table&quot;&gt;&lt;/xref&gt; lists standard
!     &cc; operators that can be applied to &array;s and constant values
!     if appropriate.  Each unary operator takes an &array; parameter
!     and returns an &array;.  The types of the two &array;s need not be
!     the same.  For example, &lt;operator&gt;!&lt;/operator&gt; can take an
!     &lt;type&gt;Array&lt;bool&gt;&lt;/type&gt;, &lt;type&gt;Array&lt;int&gt;&lt;/type&gt;,
!     &lt;type&gt;Array&lt;long&gt;&lt;/type&gt;, or any other value type to which
!     &lt;operator&gt;!&lt;/operator&gt; can be applied.  The result is an
!     &lt;type&gt;Array&lt;bool&gt;&lt;/type&gt;.  Each binary operator also returns
!     an &array;.  When specifying two &array;s or an &array; and a
!     constant value, a full set of operators is supported.  When
!     specifying an &array; and a &tensor;, &matrix;, or &vector;, a
!     more limited set of operators is supported.  For example,
!     &lt;operator&gt;==&lt;/operator&gt; can take two &array;s, an &array; and a
!     constant value, or a constant value and an &array;.  If given two
!     &array;s, corresponding values are used.  If a parameter is a
!     constant value, its same value is the used with each &array;
!     value.  The &lt;operator&gt;+&lt;/operator&gt; supports the same set of
!     parameters but also supports adding an &array; and a &tensor;, an
!     &array; and a &matrix;, an &array; and a &vector;, a &tensor; and
!     an &array;, a &matrix; and an &array;, and a &vector; and an
!     &array;.  For these cases, the &array; must have a value type that
!     can be added to the other argument.  For example, a &vector; can
!     be added to an &array; of &vector;s.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
       orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;data_parallel-use-operators_table&quot;&gt;
--- 236,264 ----
      &lt;para&gt;The following four tables list the data-parallel operators
      that operate on &array;s.  &lt;xref
      linkend=&quot;data_parallel-use-operators_table&quot;&gt;&lt;/xref&gt; lists standard
!     &cc; operators that can be applied to &array;s and also scalar
!     values if appropriate.  Each unary operator takes an &array;
!     parameter and returns an &array;.  The types of the two &array;s
!     need not be the same.  For example, &lt;operator&gt;!&lt;/operator&gt; can
!     take an &lt;type&gt;Array&lt;bool&gt;&lt;/type&gt;,
!     &lt;type&gt;Array&lt;int&gt;&lt;/type&gt;, &lt;type&gt;Array&lt;long&gt;&lt;/type&gt;, or
!     any other value type to which &lt;operator&gt;!&lt;/operator&gt; can be
!     applied.  The result is an &lt;type&gt;Array&lt;bool&gt;&lt;/type&gt;.  Each
!     binary operator also returns an &array;.  When specifying two
!     &array;s or an &array; and a scalar value, a full set of operators
!     is supported.  When specifying an &array; and a &tensor;,
!     &matrix;, or &vector;, a more limited set of operators is
!     supported.  For example, &lt;operator&gt;==&lt;/operator&gt; can take two
!     &array;s, an &array; and a scalar value, or a scalar value and an
!     &array;.  If given two &array;s, corresponding values are used.
!     If an argument is a scalar value, its same value is the used with
!     each &array; value.  The &lt;operator&gt;+&lt;/operator&gt; supports the same
!     set of parameters but also supports adding an &array; and a
!     &tensor;, an &array; and a &matrix;, an &array; and a &vector;, a
!     &tensor; and an &array;, a &matrix; and an &array;, and a &vector;
!     and an &array;.  For these cases, the &array; must have a value
!     type that can be added to the other argument.  For example, a
!     &vector; can be added to an &array; of &vector;s.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
       orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;data_parallel-use-operators_table&quot;&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 268,287 ****
          &lt;entry&gt;supported operators&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
          &lt;entry&gt;unary operators &lt;/entry&gt;
          &lt;entry&gt;&lt;operator&gt;+&lt;/operator&gt;, &lt;operator&gt;-&lt;/operator&gt;, &lt;operator&gt;~&lt;/operator&gt;, &lt;operator&gt;!&lt;/operator&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
!         &lt;entry&gt;binary operators with at least one array and at most
!         one value&lt;/entry&gt;
          &lt;entry&gt;&lt;operator&gt;+&lt;/operator&gt;, &lt;operator&gt;-&lt;/operator&gt;, &lt;operator&gt;*&lt;/operator&gt;, &lt;operator&gt;/&lt;/operator&gt;, &lt;operator&gt;%&lt;/operator&gt;, &lt;operator&gt;&amp;&lt;/operator&gt;, &lt;operator&gt;|&lt;/operator&gt;, &lt;operator&gt;^&lt;/operator&gt;, &lt;operator&gt;&lt;&lt;/operator&gt;, &lt;operator&gt;&lt;=&lt;/operator&gt;, &lt;operator&gt;&gt;=&lt;/operator&gt;, &lt;operator&gt;&gt;&lt;/operator&gt;, &lt;operator&gt;==&lt;/operator&gt;, &lt;operator&gt;!=&lt;/operator&gt;, &lt;operator&gt;&amp;&amp;&lt;/operator&gt;, &lt;operator&gt;||&lt;/operator&gt;, &lt;operator&gt;&openopen;&lt;/operator&gt;, &lt;operator&gt;&closeclose;&lt;/operator&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
!         &lt;entry&gt;binary operators with at least one array and at most
          one &tensor;, &matrix;, or &vector;&lt;/entry&gt;
!         &lt;entry&gt;&lt;operator&gt;+&lt;/operator&gt;, &lt;operator&gt;-&lt;/operator&gt;, &lt;operator&gt;*&lt;/operator&gt;, &lt;operator&gt;/&lt;/operator&gt;, &lt;operator&gt;%&lt;/operator&gt;, &lt;operator&gt;&amp;&lt;/operator&gt;, &lt;operator&gt;|&lt;/operator&gt;, &lt;operator&gt;^&lt;/operator&gt;, &lt;operator&gt;==&lt;/operator&gt;, &lt;operator&gt;!=&lt;/operator&gt;&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
--- 271,294 ----
          &lt;entry&gt;supported operators&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
          &lt;entry&gt;unary operators &lt;/entry&gt;
          &lt;entry&gt;&lt;operator&gt;+&lt;/operator&gt;, &lt;operator&gt;-&lt;/operator&gt;, &lt;operator&gt;~&lt;/operator&gt;, &lt;operator&gt;!&lt;/operator&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
!         &lt;entry&gt;binary operators with at least one &array; and at most
!         one scalar value&lt;/entry&gt;
          &lt;entry&gt;&lt;operator&gt;+&lt;/operator&gt;, &lt;operator&gt;-&lt;/operator&gt;, &lt;operator&gt;*&lt;/operator&gt;, &lt;operator&gt;/&lt;/operator&gt;, &lt;operator&gt;%&lt;/operator&gt;, &lt;operator&gt;&amp;&lt;/operator&gt;, &lt;operator&gt;|&lt;/operator&gt;, &lt;operator&gt;^&lt;/operator&gt;, &lt;operator&gt;&lt;&lt;/operator&gt;, &lt;operator&gt;&lt;=&lt;/operator&gt;, &lt;operator&gt;&gt;=&lt;/operator&gt;, &lt;operator&gt;&gt;&lt;/operator&gt;, &lt;operator&gt;==&lt;/operator&gt;, &lt;operator&gt;!=&lt;/operator&gt;, &lt;operator&gt;&amp;&amp;&lt;/operator&gt;, &lt;operator&gt;||&lt;/operator&gt;, &lt;operator&gt;&openopen;&lt;/operator&gt;, &lt;operator&gt;&closeclose;&lt;/operator&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
!         &lt;entry&gt;binary operators with at least one &array; and at most
          one &tensor;, &matrix;, or &vector;&lt;/entry&gt;
!         &lt;entry&gt;&lt;operator&gt;+&lt;/operator&gt;, &lt;operator&gt;-&lt;/operator&gt;,
!         &lt;operator&gt;*&lt;/operator&gt;, &lt;operator&gt;/&lt;/operator&gt;,
!         &lt;operator&gt;%&lt;/operator&gt;, &lt;operator&gt;&amp;&lt;/operator&gt;,
!         &lt;operator&gt;|&lt;/operator&gt;, &lt;operator&gt;^&lt;/operator&gt;,
!         &lt;operator&gt;==&lt;/operator&gt;, &lt;operator&gt;!=&lt;/operator&gt;&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 291,302 ****
      expressions appear in &lt;xref
      linkend=&quot;data_parallel-use-math_functions_table&quot;&gt;&lt;/xref&gt;.  For
      example, applying &lt;function&gt;cos&lt;/function&gt; to an &array; of values
!     with type&nbsp;&lt;type&gt;T&lt;/type&gt; yields an array of the same type.
!     The functions are split into five sections:
!      &lt;itemizedlist&gt;
! 		  &lt;listitem&gt;
! 		   &lt;para&gt;trigonometric and hyperbolic functions,&lt;/para&gt;
! 		  &lt;/listitem&gt;
  		  &lt;listitem&gt;
  		   &lt;para&gt;functions computing absolute values, rounding functions,
         and modulus functions,&lt;/para&gt;
--- 298,309 ----
      expressions appear in &lt;xref
      linkend=&quot;data_parallel-use-math_functions_table&quot;&gt;&lt;/xref&gt;.  For
      example, applying &lt;function&gt;cos&lt;/function&gt; to an &array; of values
!     with type&nbsp;&lt;type&gt;T&lt;/type&gt; yields an &array; with the same
!     type.  The functions are split into five sections:
!     &lt;itemizedlist&gt;
!      &lt;listitem&gt;
!       &lt;para&gt;trigonometric and hyperbolic functions,&lt;/para&gt;
!      &lt;/listitem&gt;
  		  &lt;listitem&gt;
  		   &lt;para&gt;functions computing absolute values, rounding functions,
         and modulus functions,&lt;/para&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 312,326 ****
  		  &lt;/listitem&gt;
  		 &lt;/itemizedlist&gt;
      Several data-parallel functions require inclusion of header files
!     declaring the underlying element-wise function.  These header
      files are listed at the beginning of each section.  For the
      data-parallel operator to be applicable, it must operate on the
      &array;'s type.  For example, &lt;function&gt;cos&lt;/function&gt; can be
! 							   applied on &array;s of &int;, &double;, and even &bool;, but
      applying on &array;s of pointers is not supported because
!     &lt;function&gt;cos&lt;/function&gt; cannot be called with a pointer argument.&lt;/para&gt;
  
!     &lt;para&gt;A few functions deserve explanation.  The
      &lt;function&gt;PETE_identity&lt;/function&gt; function applies the identity
      operation to the array.  That is, the returned array has values
      equaling the argument's values.  &lt;function&gt;pow2&lt;/function&gt;,
--- 319,334 ----
  		  &lt;/listitem&gt;
  		 &lt;/itemizedlist&gt;
      Several data-parallel functions require inclusion of header files
!     declaring their underlying element-wise function.  These header
      files are listed at the beginning of each section.  For the
      data-parallel operator to be applicable, it must operate on the
      &array;'s type.  For example, &lt;function&gt;cos&lt;/function&gt; can be
!     applied on &array;s of &int;, &double;, and even &bool;, but
      applying on &array;s of pointers is not supported because
!     &lt;function&gt;cos&lt;/function&gt; cannot be called with a pointer
!     argument.&lt;/para&gt;
  
!     &lt;para&gt;Two functions deserve special explanation.  The
      &lt;function&gt;PETE_identity&lt;/function&gt; function applies the identity
      operation to the array.  That is, the returned array has values
      equaling the argument's values.  &lt;function&gt;pow2&lt;/function&gt;,
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 347,380 ****
  	choices for the template type parameters.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
!       &lt;tbody&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Trigonometric and Hyperbolic Functions&lt;/entry&gt;
  	&lt;entry&gt;&lt;statement&gt;#include &lt;math.h&gt;&lt;/statement&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; cos (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the cosines of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sin (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the sines of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; tan (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the tangents of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; acos (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the arc cosines of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; asin (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the arc sines of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; atan (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the arc tangents of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
--- 355,388 ----
  	choices for the template type parameters.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Trigonometric and Hyperbolic Functions&lt;/entry&gt;
  	&lt;entry&gt;&lt;statement&gt;#include &lt;math.h&gt;&lt;/statement&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; cos (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the cosines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sin (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the sines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; tan (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the tangents of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; acos (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the arc cosines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; asin (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the arc sines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; atan (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the arc tangents of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 398,412 ****
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; cosh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the hyperbolic cosines of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sinh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the hyperbolic sines of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; tanh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the hyperbolic tangents of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Absolute Value, Rounding, and Modulus Functions&lt;/entry&gt;
--- 406,420 ----
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; cosh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the hyperbolic cosines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sinh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the hyperbolic sines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; tanh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the hyperbolic tangents of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Absolute Value, Rounding, and Modulus Functions&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 415,435 ****
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; fabs (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the absolute values of the floating point
! 	numbers in the array.&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;For each of the array's values, return the integer
! 	larger than or equal to it (as a floating point number).&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;For each of the array's values, return the integer
  	larger than or equal to it (as a floating point number).&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; floor (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;For each of the array's values, return the integer
  	smaller than or equal to it (as a floating point number).&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
--- 423,438 ----
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; fabs (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the absolute values of the floating point
! 	numbers in the &array;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;For each of the &array;'s values, return the integer
  	larger than or equal to it (as a floating point number).&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; floor (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;For each of the &array;'s values, return the integer
  	smaller than or equal to it (as a floating point number).&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 438,444 ****
  	&lt;varname&gt;A&lt;/varname&gt;'s values with the corresponding value
  	in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.  The results have the same signs
  	as &lt;varname&gt;A&lt;/varname&gt; and absolute values less than the
! 	absolute values of values in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
--- 441,447 ----
  	&lt;varname&gt;A&lt;/varname&gt;'s values with the corresponding value
  	in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.  The results have the same signs
  	as &lt;varname&gt;A&lt;/varname&gt; and absolute values less than the
! 	absolute values of&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 453,459 ****
  	&lt;varname&gt;l&lt;/varname&gt; with the values
  	in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.  The results have the same signs
  	as &lt;varname&gt;l&lt;/varname&gt; and absolute values less than the
! 	absolute values of values in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Powers, Exponentiation, and Logarithmic Functions&lt;/entry&gt;
--- 456,462 ----
  	&lt;varname&gt;l&lt;/varname&gt; with the values
  	in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.  The results have the same signs
  	as &lt;varname&gt;l&lt;/varname&gt; and absolute values less than the
! 	absolute values of&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Powers, Exponentiation, and Logarithmic Functions&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 461,471 ****
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; PETE_identity (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the array.  That is, it applies the identity operation.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sqrt (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the square roots of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
--- 464,474 ----
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; PETE_identity (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the &array;.  That is, it applies the identity operation.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sqrt (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the square roots of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 501,507 ****
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, int r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Multiplies &lt;varname&gt;A&lt;/varname&gt;'s values by two raised
! 	to the &lt;varname&gt;r&lt;/varname&gt;'th power.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ldexp (const T1&amp; l, const Array&lt;int&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
--- 504,511 ----
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, int r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Multiplies &lt;varname&gt;A&lt;/varname&gt;'s values by two raised
! 	to the &lt;varname&gt;r&lt;/varname&gt;&lt;subscript&gt;th&lt;/subscript&gt;
! 	power.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ldexp (const T1&amp; l, const Array&lt;int&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 510,524 ****
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; exp (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the exponentiations of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; log (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the natural logarithms of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; log10 (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the base-10 logarithms of the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Functions Involving Complex Numbers&lt;/entry&gt;
--- 514,528 ----
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; exp (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the exponentiations of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; log (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the natural logarithms of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; log10 (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the base-10 logarithms of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Functions Involving Complex Numbers&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 561,578 ****
  	&lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
  	 coordinates (magnitudes and phase angles) in corresponding
! 	 arrays.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
  	 coordinates with magnitude&nbsp;&lt;varname&gt;l&lt;/varname&gt; and
! 	 phase angles in the array.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
! 	 coordinates with magnitudes in the array and phase
  	 angle&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
--- 565,582 ----
  	&lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
  	 coordinates (magnitudes and phase angles) in corresponding
! 	 &array;s.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
  	 coordinates with magnitude&nbsp;&lt;varname&gt;l&lt;/varname&gt; and
! 	 phase angles in the &array;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
! 	 coordinates with magnitudes in the &array; and phase
  	 angle&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 599,612 ****
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the dot products of values in the two arrays.
  	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
  	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
  	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the dot products of values in the array
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.
  	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
  	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
--- 603,616 ----
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the dot products of values in the two &array;s.
  	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
  	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
  	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the dot products of values in the &array;
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.
  	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
  	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 615,635 ****
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the dot products of &lt;varname&gt;l&lt;/varname&gt; with
! 	 values in the array.  Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
  	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
  	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
- 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; B)&lt;/statement&gt;&lt;/entry&gt;
- 	&lt;entry&gt;Returns the dot products of values in the array
- 	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
- 	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
- 	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
-        &lt;/row&gt;
-        &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
! 	 of corresponding vectors in the two arrays.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors
  	 must have the same length.&lt;/entry&gt;
--- 619,632 ----
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the dot products of &lt;varname&gt;l&lt;/varname&gt; with
! 	 values in the &array;.  Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
  	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
  	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
! 	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors
  	 must have the same length.&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 637,643 ****
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
! 	 of &lt;varname&gt;l&lt;/varname&gt; with the vectors in the array.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors
  	 must have the same length.&lt;/entry&gt;
--- 634,640 ----
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
! 	 of &lt;varname&gt;l&lt;/varname&gt; with the vectors in the &array;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors
  	 must have the same length.&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 645,651 ****
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
! 	 of vectors in the array with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors
  	 must have the same length.&lt;/entry&gt;
--- 642,648 ----
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
! 	 of vectors in the &array; with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors
  	 must have the same length.&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 654,660 ****
  	&lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const Array&lt;T1&gt;&amp; A, const
  	 Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer product
! 	 of corresponding vectors in the two arrays.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors must have
  	 the same length.&lt;/entry&gt;
--- 651,657 ----
  	&lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const Array&lt;T1&gt;&amp; A, const
  	 Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer product
! 	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors must have
  	 the same length.&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 663,669 ****
  	&lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const T1&amp; l, const
  	 Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer
! 	 product of &lt;varname&gt;l&lt;/varname&gt; with the vectors in the array.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors must
  	 have the same length.&lt;/entry&gt;
--- 660,666 ----
  	&lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const T1&amp; l, const
  	 Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer
! 	 product of &lt;varname&gt;l&lt;/varname&gt; with the vectors in the &array;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors must
  	 have the same length.&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 672,678 ****
  	&lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const
  	 Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer
! 	 product of the vectors in the array
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors must
--- 669,675 ----
  	&lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const
  	 Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer
! 	 product of the vectors in the &array;
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
  	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors must
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 701,828 ****
  	&lt;entry&gt;effect&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the maximum of corresponding array values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the maximums of &lt;varname&gt;l&lt;/varname&gt; with the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the maximums of the array's values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the minimum of corresponding array values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the minimums of &lt;varname&gt;l&lt;/varname&gt; with the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the minimums of the array's values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt; to compare corresponding array values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const T1&amp; r, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt; to compare &lt;varname&gt;l&lt;/varname&gt; with the array's
  	 values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt; to compare the array's
  	 values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&le; to compare array values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&le; to compare &lt;varname&gt;l&lt;/varname&gt; with the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&le; to compare the array's values
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&ge; to compare array values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&ge; to compare &lt;varname&gt;l&lt;/varname&gt; with the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&ge; to compare the array's values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&gt; to compare array values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&gt; to compare the array's values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
! 	 corresponding array values in &lt;varname&gt;A&lt;/varname&gt; and
  	 &lt;varname&gt;B&lt;/varname&gt; are equal.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
! 	 &lt;varname&gt;l&lt;/varname&gt; equals the array's values..&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns booleans from determining whether the array's values equal&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
! 	 corresponding array values in &lt;varname&gt;A&lt;/varname&gt; and
  	 &lt;varname&gt;B&lt;/varname&gt; are not equal.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
! 	 &lt;varname&gt;l&lt;/varname&gt; does not equal the array's values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether the 
! 	 array's values are not equal to&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;!-- FIXME: Add dotdot from src/Array/PoomaArrayOperators.h if it is defined. --&gt;
        &lt;/tbody&gt;
--- 698,825 ----
  	&lt;entry&gt;effect&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the maximum of corresponding &array; values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the maximums of &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the maximums of the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the minimum of corresponding &array; values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the minimums of &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns the minimums of the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt;operator&gt;&lt;&lt;/operator&gt; to compare corresponding &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const T1&amp; r, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt;operator&gt;&lt;&lt;/operator&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s
  	 values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt;operator&gt;&lt;&lt;/operator&gt; to compare the &array;'s
  	 values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&lt;=&lt;/operator&gt; to compare &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&lt;=&lt;/operator&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&lt;=&lt;/operator&gt; to compare the &array;'s values
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&gt;=&lt;/operator&gt; to compare &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&gt;=&lt;/operator&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&gt;=&lt;/operator&gt; to compare the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&lt;operator&gt;&gt;&lt;/operator&gt; to compare &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&lt;operator&gt;&gt;&lt;/operator&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&lt;operator&gt;&gt;&lt;/operator&gt; to compare the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
! 	 corresponding &array; values in &lt;varname&gt;A&lt;/varname&gt; and
  	 &lt;varname&gt;B&lt;/varname&gt; are equal.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
! 	 &lt;varname&gt;l&lt;/varname&gt; equals the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
! 	&lt;entry&gt;Returns booleans from determining whether the &array;'s values equal&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
! 	 corresponding &array; values in &lt;varname&gt;A&lt;/varname&gt; and
  	 &lt;varname&gt;B&lt;/varname&gt; are not equal.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
! 	 &lt;varname&gt;l&lt;/varname&gt; does not equal the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether the 
! 	 &array;'s values are not equal to&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;!-- FIXME: Add dotdot from src/Array/PoomaArrayOperators.h if it is defined. --&gt;
        &lt;/tbody&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 832,838 ****
      &lt;para&gt;The table of miscellaneous functions (&lt;xref
  						      linkend=&quot;data_parallel-use-misc_functions_table&quot;&gt;&lt;/xref&gt;) contains
      two functions.  &lt;function&gt;peteCast&lt;/function&gt; casts all values in
!     an array to the type specified by the first parameter.  The
      &lt;function&gt;where&lt;/function&gt; function generalizes the trinary
      &lt;operator&gt;?:&lt;/operator&gt; operator.  Using its first &array;
      argument as boolean values, it returns an &array; of just two
--- 829,835 ----
      &lt;para&gt;The table of miscellaneous functions (&lt;xref
  						      linkend=&quot;data_parallel-use-misc_functions_table&quot;&gt;&lt;/xref&gt;) contains
      two functions.  &lt;function&gt;peteCast&lt;/function&gt; casts all values in
!     an &array; to the type specified by its first parameter.  The
      &lt;function&gt;where&lt;/function&gt; function generalizes the trinary
      &lt;operator&gt;?:&lt;/operator&gt; operator.  Using its first &array;
      argument as boolean values, it returns an &array; of just two
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 849,863 ****
  	   &lt;entry&gt;effect&lt;/entry&gt;
  	  &lt;/row&gt;
  	 &lt;/thead&gt;
! 	 &lt;tbody&gt;
  	  &lt;row&gt;
  	   &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; peteCast (const T1&amp;, const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	   &lt;entry&gt;Returns the casting of the array's values to type &lt;type&gt;T1&lt;/type&gt;.&lt;/entry&gt;
  	  &lt;/row&gt;
  	  &lt;row&gt;
  	   &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; where (const Array&lt;T1&gt;&amp; A, const T2&amp; t, const T3&amp; f)&lt;/statement&gt;&lt;/entry&gt;
  	   &lt;entry&gt;Generalizes the &lt;operator&gt;?:&lt;/operator&gt; operator,
! 	returning an array of &lt;varname&gt;t&lt;/varname&gt; and
  	&lt;varname&gt;f&lt;/varname&gt; values depending on whether
  	&lt;varname&gt;A&lt;/varname&gt;'s values are true or false,
  	respectively.&lt;/entry&gt;
--- 846,860 ----
  	   &lt;entry&gt;effect&lt;/entry&gt;
  	  &lt;/row&gt;
  	 &lt;/thead&gt;
! 	 &lt;tbody valign=&quot;top&quot;&gt;
  	  &lt;row&gt;
  	   &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; peteCast (const T1&amp;, const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
! 	   &lt;entry&gt;Returns the casting of the &array;'s values to type &lt;type&gt;T1&lt;/type&gt;.&lt;/entry&gt;
  	  &lt;/row&gt;
  	  &lt;row&gt;
  	   &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; where (const Array&lt;T1&gt;&amp; A, const T2&amp; t, const T3&amp; f)&lt;/statement&gt;&lt;/entry&gt;
  	   &lt;entry&gt;Generalizes the &lt;operator&gt;?:&lt;/operator&gt; operator,
! 	returning an &array; of &lt;varname&gt;t&lt;/varname&gt; and
  	&lt;varname&gt;f&lt;/varname&gt; values depending on whether
  	&lt;varname&gt;A&lt;/varname&gt;'s values are true or false,
  	respectively.&lt;/entry&gt;
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 871,878 ****
      values.  Frequently, operating on a subset is useful.  In &pooma;,
      a subset of a container's values is called a view.  Combining
      views and data-parallel expressions will enable us to more
!     succinctly and more easily write the diffusion program.  Views are
!     discussed in the next chapter.&lt;/para&gt;
     &lt;/section&gt;
  
  
--- 868,875 ----
      values.  Frequently, operating on a subset is useful.  In &pooma;,
      a subset of a container's values is called a view.  Combining
      views and data-parallel expressions will enable us to more
!     succinctly and more easily write the &amp;doof2d; diffusion program.
!     Views are discussed in the next chapter.&lt;/para&gt;
     &lt;/section&gt;
  
  
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 885,915 ****
      these statements may create and destroy containers holding
      intermediate values, slowing execution considerably.
      In&nbsp;1995, Todd &lt;!-- FIXME: Add citations to vandevoorde-95 and
!     veldhuizen-95. --&gt; Veldhuizen and David Vandevoorde developed an
!     expression-template technique to transform arithmetic expressions
!     involving array-like containers into efficient loops without using
!     temporaries.  Despite its perceived complexity, &pooma;
!     incorporated the technology.  The framework called &amp;pete, the
!     &lt;application&gt;Portable Expression Template Engine&lt;/application&gt;
!     framework, is also available separately from &pooma; at
!     &lt;ulink url=&quot;<A HREF="http://www.acl.lanl.gov/pete/">http://www.acl.lanl.gov/pete/</A>&quot;&gt;&lt;/ulink&gt;.&lt;/para&gt;
  
!     &lt;para&gt;In this section, we first describe how a &naive;
      implementation may slow execution.  Then, we describe &pete;'s
!     faster implementation.  A data-parallel statement is converted
      into a parse tree, rather than immediately evaluating it.  The
      parse tree has two representations.  Its run-time representation
      holds run-time values.  Its compile-time representation records
      the types of the tree's values.  After a parse tree for the entire
      statement is constructed, it is evaluated.  Since it is a
      data-parallel statement, this evaluation involves at least one
!     loop.  At run time, each loop iteration, the value of one
      container value is computed and assigned.  At compile time, when
      the code for the loop iteration is produced, the parse tree's
      types are traversed and code is produced without the need for any
      intermediate values.  We present the implementation in &lt;xref
! 								 linkend=&quot;data_parallel-implementation-pete&quot;&gt;&lt;/xref&gt;, but first we
!     explain the difficulties caused by the &naive; implementation.&lt;/para&gt;
  
      &lt;section id=&quot;data_parallel-implementation-naive&quot;&gt;
       &lt;title&gt;&naivecap; Implementation&lt;/title&gt;
--- 882,913 ----
      these statements may create and destroy containers holding
      intermediate values, slowing execution considerably.
      In&nbsp;1995, Todd &lt;!-- FIXME: Add citations to vandevoorde-95 and
!     veldhuizen-95. --&gt; Veldhuizen and David Vandevoorde each developed
!     an expression-template technique to transform arithmetic
!     expressions involving array-like containers into efficient loops
!     without using temporaries.  Despite its perceived complexity,
!     &pooma; incorporated the technology.  The framework called &amp;pete,
!     the &lt;application&gt;Portable Expression Template Engine&lt;/application&gt;
!     framework, is also available separately from &pooma; at &lt;ulink
!     url=&quot;<A HREF="http://www.acl.lanl.gov/pete/">http://www.acl.lanl.gov/pete/</A>&quot;&gt;&lt;/ulink&gt;.&lt;/para&gt;
  
!     &lt;para&gt;In this chapter, we first describe how a &naive;
      implementation may slow execution.  Then, we describe &pete;'s
!     faster implementation.  &pete; converts a data-parallel statement
      into a parse tree, rather than immediately evaluating it.  The
      parse tree has two representations.  Its run-time representation
      holds run-time values.  Its compile-time representation records
      the types of the tree's values.  After a parse tree for the entire
      statement is constructed, it is evaluated.  Since it is a
      data-parallel statement, this evaluation involves at least one
!     loop.  At run time, for each loop iteration, the value of one
      container value is computed and assigned.  At compile time, when
      the code for the loop iteration is produced, the parse tree's
      types are traversed and code is produced without the need for any
      intermediate values.  We present the implementation in &lt;xref
!     linkend=&quot;data_parallel-implementation-pete&quot;&gt;&lt;/xref&gt;, but first we
!     explain the difficulties caused by the &naive;
!     implementation.&lt;/para&gt;
  
      &lt;section id=&quot;data_parallel-implementation-naive&quot;&gt;
       &lt;title&gt;&naivecap; Implementation&lt;/title&gt;
*************** Array&lt;1, double, Brick&gt; A(I), B(I);
*** 923,933 ****
  A = 1.0;
  B = 2.0;
  A += -A + 2*B;
! std::cout &lt;&lt; A &lt;&lt; std::endl;
  &lt;/programlisting&gt; Our goal is to transform the data-parallel
       statement &lt;statement&gt;A += -A + 2*B&lt;/statement&gt; into a single
!      loop, preferably without intermediary containers.  To simplify
!      notation, let &lt;type&gt;Ar&lt;/type&gt; abbreviate the type
       &lt;type&gt;Array&lt;1, double, Brick&gt;&lt;/type&gt;.&lt;/para&gt;
       
       &lt;para&gt;Using overloaded arithmetic operators would require using
--- 921,931 ----
  A = 1.0;
  B = 2.0;
  A += -A + 2*B;
! std::cout &openopen; A &openopen; std::endl;
  &lt;/programlisting&gt; Our goal is to transform the data-parallel
       statement &lt;statement&gt;A += -A + 2*B&lt;/statement&gt; into a single
!      loop, preferably without using intermediary containers.  To
!      simplify notation, let &lt;type&gt;Ar&lt;/type&gt; abbreviate the type
       &lt;type&gt;Array&lt;1, double, Brick&gt;&lt;/type&gt;.&lt;/para&gt;
       
       &lt;para&gt;Using overloaded arithmetic operators would require using
*************** std::cout &lt;&lt; A &lt;&lt; std::endl;
*** 952,967 ****
       Template Engine&lt;/application&gt; framework, to evaluate
       data-parallel statements using efficient loops without
       intermediate values.  &pete; uses expression-template technology.
!      Instead of aggressively evaluating a data-parallel statement's
!      subexpressions, it defers evaluation, instead building a parse
!      tree of the required computations.  The parse tree's type records
!      the types of each of its subtrees.  Then, the parse tree is
!      evaluated using an evaluator determined by the left-hand side's
!      type.  This container type determines how to loop through its
!      domain.  Each loop iteration, the corresponding value of the
!      right-hand side is evaluated.  No intermediate loops or temporary
!      values are needed.&lt;/para&gt;
  
       &lt;figure float=&quot;1&quot; id=&quot;data_parallel-implementation-pete-tree_figure&quot;&gt;
        &lt;title&gt;Annotated Parse Tree for &lt;statement&gt;-A + 2*B&lt;/statement&gt;&lt;/title&gt;
         &lt;mediaobject&gt;
--- 950,983 ----
       Template Engine&lt;/application&gt; framework, to evaluate
       data-parallel statements using efficient loops without
       intermediate values.  &pete; uses expression-template technology.
!      Instead of evaluating a data-parallel statement's subexpressions
!      at solely at run time, it evaluates the code at both run time and
!      at compile time.  At compile time, it builds a parse tree of the
!      required computations.  The parse tree's type records the types
!      of each of its subtrees.  Then, the parse tree is evaluated at
!      compile time using an evaluator determined by the left-hand
!      side's type.  This container type determines how to loop through
!      its domain.  Each loop iteration of the resulting run time code,
!      the corresponding value of the right-hand side is evaluated.  No
!      intermediate loops or temporary values are needed.&lt;/para&gt;
  
+      &lt;para&gt;Before explaining the implementation, let us illustrate
+      using our example statement &lt;statement&gt;A += -A + 2*B&lt;/statement&gt;.
+      Evaluating the right-hand side creates a parse tree similar to
+      the one in &lt;xref
+      linkend=&quot;data_parallel-implementation-pete-tree_figure&quot;&gt;&lt;/xref&gt;.
+      For example, the overloaded unary minus operator yields a tree
+      node representing &lt;statement&gt;-A&lt;/statement&gt;, having a unary-minus
+      function object, and having type
+      &lt;type&gt;Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;&lt;/type&gt;.
+      The binary nodes continue the construction process yielding a
+      parse tree object for the entire right-hand side and having type
+      &lt;type&gt;Expression&lt;BinaryNode&lt;OpAdd, UnaryNode&lt;OpMinus,
+      Ar&gt;,
+      BinaryNode&lt;OpMultiply&lt;Scalar&lt;int&gt;,Ar&closecloseclose;&lt;/type&gt;.
+      Evaluating the left-hand side yields an object
+      representing&nbsp;&lt;varname&gt;A&lt;/varname&gt;.&lt;/para&gt;
+ 
       &lt;figure float=&quot;1&quot; id=&quot;data_parallel-implementation-pete-tree_figure&quot;&gt;
        &lt;title&gt;Annotated Parse Tree for &lt;statement&gt;-A + 2*B&lt;/statement&gt;&lt;/title&gt;
         &lt;mediaobject&gt;
*************** std::cout &lt;&lt; A &lt;&lt; std::endl;
*** 979,1025 ****
         &lt;/mediaobject&gt;
        &lt;/figure&gt;
  
-      &lt;para&gt;Before explaining the implementation, let us illustrate
-      using our example statement &lt;statement&gt;A += -A + 2*B&lt;/statement&gt;.
-      Evaluating the right-hand side creates a parse tree similar to
-      the one in &lt;xref
- 		      linkend=&quot;data_parallel-implementation-pete-tree_figure&quot;&gt;&lt;/xref&gt;.
-      For example, the overloaded unary minus operator yields a tree
-      node representing &lt;statement&gt;-A&lt;/statement&gt;, having a unary-minus
-      function object, and having type
-      &lt;type&gt;Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;&lt;/type&gt;.
-      The binary nodes continue the construction process yielding a
-      parse tree object for the entire right-hand side and having type
-      &lt;type&gt;Expression&lt;BinaryNode&lt;OpAdd, UnaryNode&lt;OpMinus,
-      Ar&gt;,
-      BinaryNode&lt;OpMultiply&lt;Scalar&lt;int&gt;,Ar&closecloseclose;&lt;/type&gt;.
-      Evaluating the left-hand side yields an object
-      representing&nbsp;&lt;varname&gt;A&lt;/varname&gt;.&lt;/para&gt;
- 
       &lt;para&gt;Finally, the assignment operator &lt;statement&gt;+=&lt;/statement&gt;
       calls the &lt;function&gt;evaluate&lt;/function&gt; function corresponding to
       the left-hand side's type.  At compile time, it produces the code
       for the computation.  Since this templated function is
       specialized on the type of the left-hand side, it generates a
!      loop through the left-hand side's container.  In the loop body,
!      the &lt;function&gt;forEach&lt;/function&gt; function produces code for the
!      right-hand side expression at a specific position using a
!      post-order parse-tree traversal.  At a leaf, this evaluation
!      queries the leaf's container for a specified value or extracts a
!      scalar value.  At an interior node, its children's results are
!      combined using its function operator.  One loop performs the
!      entire assignment.  It is important to note that the type of the
!      entire right-hand side is known at compile time.  Thus, all of
!      these &lt;function&gt;evaluate&lt;/function&gt;,
       &lt;function&gt;forEach&lt;/function&gt;, and function operator function
       calls can be inlined at compile time to yield simple code without
       any temporary containers and hopefully as fast as hand-written
       loops!&lt;/para&gt;
  
!      &lt;para&gt;To implement this scheme, we need &pooma; code to both
!      create the parse tree and to evaluate it.  We describe parse tree
!      creation first.  Parse trees consist of leaves,
!      &lt;type&gt;UnaryNode&lt;/type&gt;s, &lt;type&gt;BinaryNode&lt;/type&gt;s, and
       &lt;type&gt;TrinaryNode&lt;/type&gt;s.  Since &lt;type&gt;TrinaryNode&lt;/type&gt;s are
       similar to &lt;type&gt;BinaryNode&lt;/type&gt;s, we omit describing them.  A
       &lt;type&gt;BinaryNode&lt;/type&gt;'s three template parameters correspond to
--- 995,1024 ----
         &lt;/mediaobject&gt;
        &lt;/figure&gt;
  
       &lt;para&gt;Finally, the assignment operator &lt;statement&gt;+=&lt;/statement&gt;
       calls the &lt;function&gt;evaluate&lt;/function&gt; function corresponding to
       the left-hand side's type.  At compile time, it produces the code
       for the computation.  Since this templated function is
       specialized on the type of the left-hand side, it generates a
!      loop iterating through the left-hand side's container.  To
!      produce the loop body, the &lt;function&gt;forEach&lt;/function&gt; function
!      produces code for the right-hand side expression at a specific
!      position using a post-order parse-tree traversal.  At a leaf,
!      this evaluation queries the leaf's container for a specified
!      value or extracts a scalar value.  At an interior node, its
!      children's results are combined using its function operator.  One
!      loop performs the entire assignment.  It is important to note
!      that the type of the entire right-hand side is known at compile
!      time.  Thus, all of these &lt;function&gt;evaluate&lt;/function&gt;,
       &lt;function&gt;forEach&lt;/function&gt;, and function operator function
       calls can be inlined at compile time to yield simple code without
       any temporary containers and hopefully as fast as hand-written
       loops!&lt;/para&gt;
  
!      &lt;para&gt;To implement this scheme, we need &pooma; (really &pete;)
!      code to both create the parse tree and to evaluate it.  We
!      describe parse tree creation first.  Parse trees consist of
!      leaves, &lt;type&gt;UnaryNode&lt;/type&gt;s, &lt;type&gt;BinaryNode&lt;/type&gt;s, and
       &lt;type&gt;TrinaryNode&lt;/type&gt;s.  Since &lt;type&gt;TrinaryNode&lt;/type&gt;s are
       similar to &lt;type&gt;BinaryNode&lt;/type&gt;s, we omit describing them.  A
       &lt;type&gt;BinaryNode&lt;/type&gt;'s three template parameters correspond to
*************** std::cout &lt;&lt; A &lt;&lt; std::endl;
*** 1050,1056 ****
  
       &lt;para&gt;&lt;type&gt;BinaryNode&lt;/type&gt; does not need to store any
      representation of the node's operation.  Instead the
!     &lt;type&gt;Op&lt;/type&gt; type is an empty structure declaring a function
      object.  For example, &lt;type&gt;OpAdd&lt;/type&gt;'s function object is
      declared as
  &lt;programlisting&gt;
--- 1049,1055 ----
  
       &lt;para&gt;&lt;type&gt;BinaryNode&lt;/type&gt; does not need to store any
      representation of the node's operation.  Instead the
!     &lt;type&gt;Op&lt;/type&gt; type is an empty structure defining a function
      object.  For example, &lt;type&gt;OpAdd&lt;/type&gt;'s function object is
      declared as
  &lt;programlisting&gt;
*************** struct CreateLeaf&lt;Array&lt;Dim, T, En
*** 1116,1127 ****
  
       &lt;para&gt;Now that we have defined the node classes, the &cc;
      arithmetic operators must be overloaded to return the appropriate
!     parse tree.  For example, unary minus operator
!     &lt;function&gt;operator-&lt;/function&gt; overloaded to accept an &array;
!     argument should create a &lt;type&gt;UnaryNode&lt;/type&gt; having an &array;
      as its child, which will be a leaf:
  &lt;programlisting&gt;
! 		 template&lt;int D1,class T1,class E1&gt;
  inline typename MakeReturn&lt;UnaryNode&lt;OpUnaryMinus,
    typename CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::Leaf_t&gt; &gt;::Expression_t
  operator-(const Array&lt;D1,T1,E1&gt; &amp; l)
--- 1115,1126 ----
  
       &lt;para&gt;Now that we have defined the node classes, the &cc;
      arithmetic operators must be overloaded to return the appropriate
!     parse tree.  For example, the unary minus operator
!     &lt;function&gt;operator-&lt;/function&gt; is overloaded to accept an &array;
!     argument.  It should create a &lt;type&gt;UnaryNode&lt;/type&gt; having an &array;
      as its child, which will be a leaf:
  &lt;programlisting&gt;
! template&lt;int D1,class T1,class E1&gt;
  inline typename MakeReturn&lt;UnaryNode&lt;OpUnaryMinus,
    typename CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::Leaf_t&gt; &gt;::Expression_t
  operator-(const Array&lt;D1,T1,E1&gt; &amp; l)
*************** operator-(const Array&lt;D1,T1,E1&gt; &amp;a
*** 1144,1183 ****
      type from &lt;type&gt;Expression&lt;/type&gt;'s internal
      &lt;type&gt;Expression_t&lt;/type&gt; type.&lt;/para&gt;
  
!      &lt;para&gt;Specialized all the operators for &array;s using such
!     complicated is likely to be error-prone so &pete; provides a way
!     to automate it.  Using its &lt;command&gt;MakeOperators&lt;/command&gt;
! 								command with this input:
  &lt;programlisting&gt;
! 		 classes
  -----
    ARG   = &quot;int D[n],class T[n],class E[n]&quot;
    CLASS = &quot;Array&lt;D[n],T[n],E[n]&gt;&quot;
  &lt;/programlisting&gt; automatically generates code for all the needed operators.
      The &lt;quote&gt;[n]&lt;/quote&gt; strings are used to number arguments for binary
      and ternary operators.&lt;/para&gt;
  
!      &lt;para&gt;Assignment operators must also be specialized for &array;.
      Inside the &array; class definition, each such operator just
!     invokes the &lt;function&gt;assign&lt;/function&gt; function with a corresponding
! 					    function object.  For example, &lt;function&gt;operator+=&lt;/function&gt;
! 													   invokes &lt;statement&gt;assign(*this, rhs, OpAddAssign())&lt;/statement&gt;.
!     &lt;varname&gt;rhs&lt;/varname&gt; is the parse tree object for the right-hand
!     side.  Calling this function invokes
!     &lt;function&gt;evaluate&lt;/function&gt;, which begins the evaluation.&lt;/para&gt;
  
!      &lt;para&gt;Before we explain the evaluation, let us summarize the
      effect of the code so far described.  If we are considering run
!     time, parse trees for the left-hand and right-hand sides have been
!     constructed.  If we are considering compile time, the types of
!     these parse trees are known.  At compile time, the
!     &lt;function&gt;evaluate&lt;/function&gt; function described below will
!     generate a loop through the left-hand side container's domain.
!     The loop's body will have code computing a container's value.  At
!     run time, this code will read values from containers, but the
!     run-time parse tree object itself will not traversed!&lt;/para&gt;
  
!      &lt;para&gt;We now explore the evaluation, concentrating on compile
      time, not run time.  &lt;function&gt;evaluate&lt;/function&gt; is an
      overloaded function specialized on the type of the left-hand side.
      In our example, the left-hand side is a one-dimensional &array;,
--- 1143,1185 ----
      type from &lt;type&gt;Expression&lt;/type&gt;'s internal
      &lt;type&gt;Expression_t&lt;/type&gt; type.&lt;/para&gt;
  
!     &lt;para&gt;Specializing all the operators for &array;s using such
!     complicated functions is likely to be error-prone so &pete;
!     provides a way to automate their creation.  Using its
!     &lt;command&gt;MakeOperators&lt;/command&gt; command with this input:
  &lt;programlisting&gt;
! classes
  -----
    ARG   = &quot;int D[n],class T[n],class E[n]&quot;
    CLASS = &quot;Array&lt;D[n],T[n],E[n]&gt;&quot;
  &lt;/programlisting&gt; automatically generates code for all the needed operators.
      The &lt;quote&gt;[n]&lt;/quote&gt; strings are used to number arguments for binary
      and ternary operators.&lt;/para&gt;
+ 
  
!     &lt;para&gt;Assignment operators must also be specialized for &array;.
      Inside the &array; class definition, each such operator just
!     invokes the &lt;function&gt;assign&lt;/function&gt; function with a
!     corresponding function object.  For example,
!     &lt;function&gt;operator+=&lt;/function&gt; invokes &lt;statement&gt;assign(*this,
!     rhs, OpAddAssign())&lt;/statement&gt;.  &lt;varname&gt;rhs&lt;/varname&gt; is the
!     parse tree object for the right-hand side.  Calling this function
!     invokes &lt;function&gt;evaluate&lt;/function&gt;, which begins the
!     evaluation.&lt;/para&gt;
  
!     &lt;para&gt;Before we explain the evaluation, let us summarize the
      effect of the code so far described.  If we are considering run
!     time evaluation, parse trees for the left-hand and right-hand
!     sides have been constructed.  If we are considering compile time
!     evaluation, the types of these parse trees are known.  At compile
!     time, the &lt;function&gt;evaluate&lt;/function&gt; function described below
!     will generate a loop iterating through the left-hand side
!     container's domain.  The loop's body will have code computing a
!     container's value.  At run time, this code will read values from
!     containers, but the run-time parse tree object itself will not
!     traversed!&lt;/para&gt;
  
!     &lt;para&gt;We now explore the evaluation, concentrating on compile
      time, not run time.  &lt;function&gt;evaluate&lt;/function&gt; is an
      overloaded function specialized on the type of the left-hand side.
      In our example, the left-hand side is a one-dimensional &array;,
*************** forEach(const Expression&amp; e, const L
*** 1205,1211 ****
      nodes, it combines the results using the &lt;type&gt;CombineTag&lt;/type&gt;
      operator&nbsp;&lt;varname&gt;c&lt;/varname&gt;.  It inlines into a call to
  &lt;programlisting&gt;
!     ForEach&lt;Expression, LeafTag, CombineTag&gt;::apply(e, f, c).
  &lt;/programlisting&gt;  The &lt;function&gt;apply&lt;/function&gt; function continues
      the traversal through the tree.  For our example,
      &lt;type&gt;LeafTag&lt;/type&gt; equals &lt;type&gt;EvalLeaf&lt;1&gt;&lt;/type&gt;, and
--- 1207,1213 ----
      nodes, it combines the results using the &lt;type&gt;CombineTag&lt;/type&gt;
      operator&nbsp;&lt;varname&gt;c&lt;/varname&gt;.  It inlines into a call to
  &lt;programlisting&gt;
! ForEach&lt;Expression, LeafTag, CombineTag&gt;::apply(e, f, c).
  &lt;/programlisting&gt;  The &lt;function&gt;apply&lt;/function&gt; function continues
      the traversal through the tree.  For our example,
      &lt;type&gt;LeafTag&lt;/type&gt; equals &lt;type&gt;EvalLeaf&lt;1&gt;&lt;/type&gt;, and
*************** for (int i = A.domain[0].first(); i &lt; en
*** 1282,1292 ****
      code.&lt;/para&gt;
  
      &lt;para&gt;&pete;'s expression template technology may be complicated,
!     using parse trees and their types, but the code they produce is
!     not.  Using the technology is also easy.  All data-parallel
!     statements are automatically converted.  In the next chapter, we
!     explore views of containers, permitting use of container subsets
!     and making data-parallel expressions even more useful.&lt;/para&gt;
      &lt;/section&gt;
  
     &lt;/section&gt;
--- 1284,1294 ----
      code.&lt;/para&gt;
  
      &lt;para&gt;&pete;'s expression template technology may be complicated,
!     using parse trees and their types, but the produced code is not.
!     Using the technology is also easy.  All data-parallel statements
!     are automatically converted.  In the next chapter, we explore
!     views of containers, permitting use of container subsets and
!     making data-parallel expressions even more useful.&lt;/para&gt;
      &lt;/section&gt;
  
     &lt;/section&gt;
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.8
diff -c -p -r1.8 glossary.xml
*** glossary.xml	2002/01/24 05:11:21	1.8
--- glossary.xml	2002/01/25 02:15:05
***************
*** 11,19 ****
--- 11,21 ----
    should finish a sentence.  The rest of the definition should
    consist of complete sentences.  --&gt;
  
+ &lt;![%unfinished;[
   &lt;para&gt;ADD: Make sure all entries are indexed and perhaps point back
   to their first use.  WARNING: This is constructed by hand so it is
   likely to be full of inconsistencies and errors.&lt;/para&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
   &lt;glossdiv id=&quot;glossary-a&quot;&gt;
    &lt;title&gt;A&lt;/title&gt;
***************
*** 29,42 ****
    &lt;glossentry id=&quot;glossary-array&quot;&gt;
     &lt;glossterm&gt;&array;&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a &pooma; container generalizing &c; arrays and mapping
!     indices to values.  Constant-time access to values is supported,
!     ignoring the time to compute the values if applicable.  &array;s
!     are &lt;link linkend=&quot;glossary-first_class&quot;&gt;first-class
!     object&lt;/link&gt;s.  &lt;link
      linkend=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/link&gt;s and &lt;link
      linkend=&quot;glossary-field&quot;&gt;&field;&lt;/link&gt;s generalize
      &array;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
--- 31,46 ----
    &lt;glossentry id=&quot;glossary-array&quot;&gt;
     &lt;glossterm&gt;&array;&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a &pooma; &lt;link
!     linkend=&quot;glossary-container&quot;&gt;container&lt;/link&gt; generalizing &c;
!     arrays and mapping indices to values.  Constant-time access to
!     values is supported, ignoring the time to compute the values if
!     applicable.  &array;s are &lt;link
!     linkend=&quot;glossary-first_class&quot;&gt;first-class object&lt;/link&gt;s.  &lt;link
      linkend=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/link&gt;s and &lt;link
      linkend=&quot;glossary-field&quot;&gt;&field;&lt;/link&gt;s generalize
      &array;.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-container&quot;&gt;container&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
***************
*** 63,82 ****
     &lt;glossdef&gt;
      &lt;para&gt;a &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; element of
      a &lt;link linkend=&quot;glossary-field&quot;&gt;&field;&lt;/link&gt;.  Both &lt;link
! 								  linkend=&quot;glossary-array&quot;&gt;&array;&lt;/link&gt; and &field; domain
      elements are denoted by indices, but a cell exists in space.  For
      example, it might be a rectangle or rectangular
      parallelepiped.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
    &lt;glossentry id=&quot;glossary-cell_size&quot;&gt;
     &lt;glossterm&gt;cell size&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;specifies a &field; cell's dimensions e.g., its
      width, height, and depth, in&nbsp;&space;.  This is frequently
      used to specify a mesh.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-corner_position&quot;&gt;corner position&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
--- 67,90 ----
     &lt;glossdef&gt;
      &lt;para&gt;a &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; element of
      a &lt;link linkend=&quot;glossary-field&quot;&gt;&field;&lt;/link&gt;.  Both &lt;link
!     linkend=&quot;glossary-array&quot;&gt;&array;&lt;/link&gt; and &field; domain
      elements are denoted by indices, but a cell exists in space.  For
      example, it might be a rectangle or rectangular
      parallelepiped.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-cell_size&quot;&gt;cell size&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
    &lt;glossentry id=&quot;glossary-cell_size&quot;&gt;
     &lt;glossterm&gt;cell size&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;specifies a &lt;link linkend=&quot;glossary-field&quot;&gt;&field;&lt;/link&gt;
!     &lt;link linkend=&quot;glossary-cell&quot;&gt;cell&lt;/link&gt;'s dimensions e.g., its
      width, height, and depth, in&nbsp;&space;.  This is frequently
      used to specify a mesh.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-cell&quot;&gt;cell&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-corner_position&quot;&gt;corner position&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
***************
*** 85,99 ****
    &lt;glossentry id=&quot;glossary-communication_library&quot;&gt;
     &lt;glossterm&gt;communication library&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;software library passing information among contexts, usually
!     using messages.&lt;/para&gt;
!     &lt;glossseealso otherterm=&quot;glossary-distributed&quot;&gt;distributed computing environment&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
    &lt;glossentry id=&quot;glossary-compilation_time&quot;&gt;
     &lt;glossterm&gt;compilation time&lt;/glossterm&gt;
!    &lt;glosssee otherterm=&quot;glossary-compilation_time&quot;&gt;&lt;/glosssee&gt;
    &lt;/glossentry&gt;
  
    &lt;glossentry id=&quot;glossary-compile_time&quot;&gt;
--- 93,109 ----
    &lt;glossentry id=&quot;glossary-communication_library&quot;&gt;
     &lt;glossterm&gt;communication library&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;software library passing information among &lt;glossterm
!     linkend=&quot;glossary-context&quot;&gt;contexts&lt;/glossterm&gt;, usually using
!     messages.&lt;/para&gt; &lt;glossseealso
!     otherterm=&quot;glossary-distributed&quot;&gt;distributed computing
!     environment&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
    &lt;glossentry id=&quot;glossary-compilation_time&quot;&gt;
     &lt;glossterm&gt;compilation time&lt;/glossterm&gt;
!    &lt;glosssee otherterm=&quot;glossary-compile_time&quot;&gt;&lt;/glosssee&gt;
    &lt;/glossentry&gt;
  
    &lt;glossentry id=&quot;glossary-compile_time&quot;&gt;
***************
*** 141,147 ****
      &lt;para&gt;domains with the &lt;quote&gt;same shape&lt;/quote&gt; so that
      corresponding dimensions have the same number of elements.
      Scalars, deemed conformable with any domain, get
!     &lt;quote&gt;expanded&lt;/quote&gt; to the domain's shape.  Binary operators
      can operate on containers with conformable domains.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-conformable_containers&quot;&gt;conformable containers&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
--- 151,157 ----
      &lt;para&gt;domains with the &lt;quote&gt;same shape&lt;/quote&gt; so that
      corresponding dimensions have the same number of elements.
      Scalars, deemed conformable with any domain, get
!     &lt;quote&gt;expanded&lt;/quote&gt; to the domain's shape.  Assignment
      can operate on containers with conformable domains.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-conformable_containers&quot;&gt;conformable containers&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
***************
*** 178,184 ****
     &lt;glossterm&gt;context&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;a collection of shared memory and processors that can execute
!      a program of a portion of a program.  It can have one or more
       processors, but all these processors must access the same shared
       memory.  Usually the computer and its operating system, not the
       programmer, determine the available contexts.&lt;/para&gt;
--- 188,194 ----
     &lt;glossterm&gt;context&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;a collection of shared memory and processors that can execute
!      a program or a portion of a program.  It can have one or more
       processors, but all these processors must access the same shared
       memory.  Usually the computer and its operating system, not the
       programmer, determine the available contexts.&lt;/para&gt;
***************
*** 193,198 ****
--- 203,209 ----
      &lt;para&gt;indicates how a container's patches are mapped to
      processors and shared memory.  Two common choices are
      distribution among the various processors and replication.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-context&quot;&gt;context&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-patch&quot;&gt;patch&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
***************
*** 214,221 ****
    &lt;glossentry id=&quot;glossary-data_parallel&quot;&gt;
     &lt;glossterm&gt;data parallel&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;describes an expression representing a subset of a
!     container's values.  For example,
      &lt;statement&gt;sin(&container;)&lt;/statement&gt; is an expression
      indicating that the &lt;function&gt;sin&lt;/function&gt; is applied to each
      value in container&nbsp;&container;.&lt;/para&gt;
--- 225,232 ----
    &lt;glossentry id=&quot;glossary-data_parallel&quot;&gt;
     &lt;glossterm&gt;data parallel&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;describes an expression involving a (non-singleton) subset
!     of a container's values.  For example,
      &lt;statement&gt;sin(&container;)&lt;/statement&gt; is an expression
      indicating that the &lt;function&gt;sin&lt;/function&gt; is applied to each
      value in container&nbsp;&container;.&lt;/para&gt;
***************
*** 258,264 ****
      2stride, &hellip;, end}.  &lt;varname&gt;end&lt;/varname&gt; is in the set
      only if it equals &lt;varname&gt;begin&lt;/varname&gt; plus some integral
      multiple of &lt;varname&gt;stride&lt;/varname&gt;.  This notation can
!     abbreviate most domains.  It is extended to multiple dimensions by
      separating the dimensions' sets with commas:
      [&lt;varname&gt;begin0&lt;/varname&gt;:&lt;varname&gt;end0&lt;/varname&gt;:&lt;varname&gt;stride0&lt;/varname&gt;,&lt;varname&gt;begin1&lt;/varname&gt;:&lt;varname&gt;end1&lt;/varname&gt;:&lt;varname&gt;stride1&lt;/varname&gt;].&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
--- 269,275 ----
      2stride, &hellip;, end}.  &lt;varname&gt;end&lt;/varname&gt; is in the set
      only if it equals &lt;varname&gt;begin&lt;/varname&gt; plus some integral
      multiple of &lt;varname&gt;stride&lt;/varname&gt;.  This notation can
!     abbreviate many domains.  It is extended to multiple dimensions by
      separating the dimensions' sets with commas:
      [&lt;varname&gt;begin0&lt;/varname&gt;:&lt;varname&gt;end0&lt;/varname&gt;:&lt;varname&gt;stride0&lt;/varname&gt;,&lt;varname&gt;begin1&lt;/varname&gt;:&lt;varname&gt;end1&lt;/varname&gt;:&lt;varname&gt;stride1&lt;/varname&gt;].&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
***************
*** 268,279 ****
    &lt;glossentry id=&quot;glossary-dynamicarray&quot;&gt;
     &lt;glossterm&gt;&dynamicarray;&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a &pooma; container generalizing one-dimensional &lt;link
!     linkend=&quot;glossary-array&quot;&gt;&array;&lt;/link&gt;s by supporting domain
!     resizing at run-time.  It maps indices to values in constant-time
!     access, ignoring the time to compute the values if applicable.
!     &dynamicarray;s are &lt;link
      linkend=&quot;glossary-first_class&quot;&gt;first-class object&lt;/link&gt;s.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-array&quot;&gt;&array;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
--- 279,292 ----
    &lt;glossentry id=&quot;glossary-dynamicarray&quot;&gt;
     &lt;glossterm&gt;&dynamicarray;&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a &pooma; &lt;link
!     linkend=&quot;glossary-container&quot;&gt;container&lt;/link&gt; generalizing
!     one-dimensional &lt;link linkend=&quot;glossary-array&quot;&gt;&array;&lt;/link&gt;s by
!     supporting domain resizing at run-time.  It maps indices to values
!     in constant time, ignoring the time to compute the values if
!     applicable.  &dynamicarray;s are &lt;link
      linkend=&quot;glossary-first_class&quot;&gt;first-class object&lt;/link&gt;s.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-container&quot;&gt;container&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-array&quot;&gt;&array;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
***************
*** 292,298 ****
     &lt;glossterm&gt;element wise&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;describes accesses to individual values within a container.
!     For example, &lt;statement&gt;&amp;container(i,j)&lt;/statement&gt; represents one
      particular value in the container&nbsp;&container;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-relation&quot;&gt;relation&lt;/glossseealso&gt;
--- 305,311 ----
     &lt;glossterm&gt;element wise&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;describes accesses to individual values within a container.
!     For example, &lt;statement&gt;&amp;container(-4,3)&lt;/statement&gt; represents one
      particular value in the container&nbsp;&container;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-relation&quot;&gt;relation&lt;/glossseealso&gt;
***************
*** 303,314 ****
    &lt;glossentry id=&quot;glossary-engine&quot;&gt;
     &lt;glossterm&gt;engine&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;stores and, if necessary, computes a &lt;link
      linkend=&quot;glossary-container&quot;&gt;container&lt;/link&gt;'s values.  These can
      be specialized, e.g., to minimize storage when a domain has few
      distinct values.  Separating a container and its storage also
      permits &lt;link linkend=&quot;glossary-view&quot;&gt;views&lt;/link&gt; of a
      container.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-container&quot;&gt;&engine;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-view&quot;&gt;view of a container&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
--- 316,328 ----
    &lt;glossentry id=&quot;glossary-engine&quot;&gt;
     &lt;glossterm&gt;engine&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;stores or computes a &lt;link
      linkend=&quot;glossary-container&quot;&gt;container&lt;/link&gt;'s values.  These can
      be specialized, e.g., to minimize storage when a domain has few
      distinct values.  Separating a container and its storage also
      permits &lt;link linkend=&quot;glossary-view&quot;&gt;views&lt;/link&gt; of a
      container.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-brick&quot;&gt;&brick; &engine;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-container&quot;&gt;&engine;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-view&quot;&gt;view of a container&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
***************
*** 362,375 ****
    &lt;glossentry id=&quot;glossary-field&quot;&gt;
     &lt;glossterm&gt;&field;&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a &pooma; container representing an &array; with spatial
!     extent.  It also supports multiple values and multiple materials
!     indexed by the same value.  It maps indices to values in constant
!     time, ignoring the time to compute the values if applicable.  It
!     also supports geometric computations such as the distance between
!     two &lt;link linkend=&quot;glossary-cell&quot;&gt;cell&lt;/link&gt;s and normals to a
!     cell.  &field;s are &lt;link
!     linkend=&quot;glossary-first_class&quot;&gt;first-class object&lt;/link&gt;s.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-array&quot;&gt;&array;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
--- 376,394 ----
    &lt;glossentry id=&quot;glossary-field&quot;&gt;
     &lt;glossterm&gt;&field;&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a &pooma; &lt;link
!     linkend=&quot;glossary-container&quot;&gt;container&lt;/link&gt; representing an
!     &array; with spatial extent.  It also supports multiple values and
!     multiple materials having the same index.  It maps indices to
!     values in constant time, ignoring the time to compute the values
!     if applicable.  It also supports geometric computations such as
!     the distance between two &lt;link
!     linkend=&quot;glossary-cell&quot;&gt;cell&lt;/link&gt;s and normals to a cell.
!     &field;s are &lt;link linkend=&quot;glossary-first_class&quot;&gt;first-class
!     object&lt;/link&gt;s.&lt;/para&gt;
!     &lt;glossseealso otherterm=&quot;glossary-container&quot;&gt;container&lt;/glossseealso&gt;
!     &lt;glossseealso otherterm=&quot;glossary-cell&quot;&gt;cell&lt;/glossseealso&gt;
!     &lt;glossseealso otherterm=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-array&quot;&gt;&array;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
***************
*** 379,385 ****
     &lt;glossterm&gt;first-class type&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;a type of object with all the capabilities of the built-in
!     type with the most capabilities.  For example, &lt;type&gt;char&lt;/type&gt;
      and &lt;type&gt;int&lt;/type&gt; are first-class types in &cc; because they
      may be declared anywhere, stored in automatic variables, accessed
      anywhere, copied, and passed by both value and reference.
--- 398,404 ----
     &lt;glossterm&gt;first-class type&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;a type of object with all the capabilities of the built-in
!     type having the most capabilities.  For example, &lt;type&gt;char&lt;/type&gt;
      and &lt;type&gt;int&lt;/type&gt; are first-class types in &cc; because they
      may be declared anywhere, stored in automatic variables, accessed
      anywhere, copied, and passed by both value and reference.
*************** guard layer&lt;/glossseealso&gt;
*** 477,483 ****
  
    &lt;glossentry id=&quot;glossary-instantiation&quot;&gt;
     &lt;glossterm&gt;instantiation&lt;/glossterm&gt;
!    &lt;glosssee&gt;template instantiation&lt;/glosssee&gt;
    &lt;/glossentry&gt;
  
    &lt;glossentry id=&quot;glossary-indices&quot;&gt;
--- 496,502 ----
  
    &lt;glossentry id=&quot;glossary-instantiation&quot;&gt;
     &lt;glossterm&gt;instantiation&lt;/glossterm&gt;
!    &lt;glosssee otherterm=&quot;glossary-template_instantiation&quot;&gt;template instantiation&lt;/glosssee&gt;
    &lt;/glossentry&gt;
  
    &lt;glossentry id=&quot;glossary-indices&quot;&gt;
*************** guard layer&lt;/glossseealso&gt;
*** 559,567 ****
     &lt;glossterm&gt;mesh&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;a &field;'s map from indices to geometric values such as
!     cell size, edge length, and cell normals.  In other words, it
      specifies a &field;'s &lt;quote&gt;spatial extent&lt;/quote&gt;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-layout&quot;&gt;layout&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
--- 578,589 ----
     &lt;glossterm&gt;mesh&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;a &field;'s map from indices to geometric values such as
!     &lt;link linkend=&quot;glossary-cell_size&quot;&gt;cell size&lt;/link&gt;, edge length, and cell normals.  In other words, it
      specifies a &field;'s &lt;quote&gt;spatial extent&lt;/quote&gt;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-cell&quot;&gt;cell&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-cell_size&quot;&gt;cell size&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-corner_position&quot;&gt;corner position&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-layout&quot;&gt;layout&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
*************** guard layer&lt;/glossseealso&gt;
*** 657,663 ****
      linkend=&quot;glossary-range&quot;&gt;domain triplets&lt;/link&gt; [b:e:s], can also
      be represented mathematically as an integral interval [b,e] with
      stride&nbsp;s, i.e., {a, a+s, a+2s, &hellip;, b}.  It is
!     generalized to &n;-dimensional range as the direct product of
      one-dimensional ranges.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-stride&quot;&gt;stride&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-interval&quot;&gt;interval&lt;/glossseealso&gt;
--- 679,685 ----
      linkend=&quot;glossary-range&quot;&gt;domain triplets&lt;/link&gt; [b:e:s], can also
      be represented mathematically as an integral interval [b,e] with
      stride&nbsp;s, i.e., {a, a+s, a+2s, &hellip;, b}.  It is
!     generalized to an &n;-dimensional range as the direct product of
      one-dimensional ranges.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-stride&quot;&gt;stride&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-interval&quot;&gt;interval&lt;/glossseealso&gt;
*************** guard layer&lt;/glossseealso&gt;
*** 665,670 ****
--- 687,702 ----
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
+   &lt;glossentry id=&quot;glossary-reference_semantics&quot;&gt;
+    &lt;glossterm&gt;reference semantics&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;a copy of an object&nbsp;&lt;varname&gt;o&lt;/varname&gt; refers to the
+     object&nbsp;&lt;varname&gt;o&lt;/varname&gt; such that changing either one
+     also changes the other.  This is the opposite of value
+     semantics.&lt;/para&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-relation&quot;&gt;
     &lt;glossterm&gt;relation&lt;/glossterm&gt;
     &lt;glossdef&gt;
*************** guard layer&lt;/glossseealso&gt;
*** 717,728 ****
    &lt;glossentry id=&quot;glossary-stencil&quot;&gt;
     &lt;glossterm&gt;stencil&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;set of values neighboring a container value and a function
      using those values to compute it.  For example, the stencil in a
!     two-dimensional Conway game of life consists of a value's eight
!     neighbors and a function that sets the value to
!     &lt;quote&gt;live&lt;/quote&gt; if it is already live or it has exactly three
!     live neighbors.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-element_wise&quot;&gt;element wise&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-relation&quot;&gt;relation&lt;/glossseealso&gt;
--- 749,760 ----
    &lt;glossentry id=&quot;glossary-stencil&quot;&gt;
     &lt;glossterm&gt;stencil&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;set of values neighboring a container index and a function
      using those values to compute it.  For example, the stencil in a
!     two-dimensional Conway game of life consists of an index's eight
!     neighbors and a function that sets its value to
!     &lt;quote&gt;live&lt;/quote&gt; if it is already live and it has two neighbors
!     or it has exactly three live neighbors.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-element_wise&quot;&gt;element wise&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-relation&quot;&gt;relation&lt;/glossseealso&gt;
*************** guard layer&lt;/glossseealso&gt;
*** 768,775 ****
      &lt;/indexterm&gt;
      class or function definition having template parameters.
      These parameters' values are used at compile time, not run time,
!     so they may include types and other compile-time values.
!     &lt;!-- FIXME: Strengthen this definition. --&gt;&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-template_instantiation&quot;&gt;template instantiation&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-template_specialization&quot;&gt;template specialization&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
--- 800,806 ----
      &lt;/indexterm&gt;
      class or function definition having template parameters.
      These parameters' values are used at compile time, not run time,
!     so they may include types and other compile-time values.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-template_instantiation&quot;&gt;template instantiation&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-template_specialization&quot;&gt;template specialization&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
*************** guard layer&lt;/glossseealso&gt;
*** 788,793 ****
--- 819,825 ----
      foo&lt;/statement&gt; with the type &double; and the constant
      integer&nbsp;3.  Template instantiation is analogous to applying a
      function to function arguments.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-template&quot;&gt;template&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
*************** guard layer&lt;/glossseealso&gt;
*** 800,805 ****
--- 832,838 ----
      &lt;/indexterm&gt;
      class or function definition for a particular (special)
      subset of template arguments.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-template&quot;&gt;template&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
*************** guard layer&lt;/glossseealso&gt;
*** 843,849 ****
       &lt;primary&gt;traits class&lt;/primary&gt;
      &lt;/indexterm&gt;
      a class containing one or more traits all describing a particular
!     type's chacteristics.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-trait&quot;&gt;trait&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
--- 876,882 ----
       &lt;primary&gt;traits class&lt;/primary&gt;
      &lt;/indexterm&gt;
      a class containing one or more traits all describing a particular
!     type's characteristics.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-trait&quot;&gt;trait&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.9
diff -c -p -r1.9 manual.xml
*** manual.xml	2002/01/24 05:11:21	1.9
--- manual.xml	2002/01/25 02:15:08
***************
*** 150,155 ****
--- 150,157 ----
    &lt;!-- The &quot;Range&quot; domain type. --&gt;
  &lt;!ENTITY rangeone &quot;&lt;type&gt;Range&lt;1&gt;&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;Range&lt;1&gt;&quot; one-dimensional domain type. --&gt;
+ &lt;!ENTITY remote &quot;&lt;type&gt;Remote&lt;/type&gt;&quot;&gt;
+   &lt;!-- The &quot;Remote&quot; engine type. --&gt;
  &lt;!ENTITY replicatedtag &quot;&lt;type&gt;ReplicatedTag&lt;/type&gt;&quot;&gt;
    &lt;!-- The ReplicatedTag Layout type. --&gt;
  &lt;!ENTITY stencil &quot;&lt;type&gt;Stencil&lt;/type&gt;&quot;&gt;
***************
*** 390,417 ****
     &lt;para&gt;We begin this chapter by introducing the concept of an engine
     and how it is used.  Then, we describe the various &engine;s that
     &pooma; provides, separating them into engines that store values
!    and engines that compute values.  Finally, we describe how the
     &engine;s are implemented, using tags to differentiate engines and
!    reference-counted pointers to their underlying data.&lt;/para&gt;
  
  
     &lt;section id=&quot;engines-concept&quot;&gt;
      &lt;title&gt;The Concept&lt;/title&gt;
  
      &lt;para&gt;An engine performs the low-level value storage, computation,
!     and element-wise access for a container.  The &pooma; &engine;
!     class and its specializations implement the concept.  An engine
!     has a domain and accessor functions returning individual elements.
!     Given an index within the domain, an engine's
      &lt;methodname&gt;operator()&lt;/methodname&gt; function returns the
      associated value, which can be used or changed.  Its
!     &lt;methodname&gt;read&lt;/methodname&gt; returns the same value for only use,
!     not modification.  The acceptable indices are determined by each
!     &engine;.  Most accept indices specified using &int; and
!     &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt; parameters, but an &engine; might
!     accept string or floating-point parameters.  An &engine;'s layout
!     specifies maps its domain indices to the processors and memory
!     used to store and compute the associated values.&lt;/para&gt;
  
      &lt;para&gt;Since an engine's main role is to return the individual
      values associated with specific domain indices, any implementation
--- 392,424 ----
     &lt;para&gt;We begin this chapter by introducing the concept of an engine
     and how it is used.  Then, we describe the various &engine;s that
     &pooma; provides, separating them into engines that store values
!    and engines that compute values.
! &lt;![%unfinished;[
!    Finally, we describe how the
     &engine;s are implemented, using tags to differentiate engines and
!    reference-counted pointers to their underlying data.
! ]]&gt;  &lt;!-- end unfinished --&gt;
!    &lt;/para&gt;
  
  
     &lt;section id=&quot;engines-concept&quot;&gt;
      &lt;title&gt;The Concept&lt;/title&gt;
  
      &lt;para&gt;An engine performs the low-level value storage, computation,
!     and element-wise access for a container.  An engine has a domain
!     and accessor functions returning individual elements.  The &pooma;
!     &engine; class and its specializations implement the engine
!     concept.  Given an index within the domain, an &engine;'s
      &lt;methodname&gt;operator()&lt;/methodname&gt; function returns the
      associated value, which can be used or changed.  Its
!     &lt;methodname&gt;read&lt;/methodname&gt; member function returns the same
!     value but permitting only use, not modification.  The acceptable
!     indices are determined by each &engine;.  Most accept indices
!     specified using &int; and &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt;
!     parameters, but an &engine; might accept string or floating-point
!     parameters.  An &engine;'s layout specifies maps its domain
!     indices to the processors and memory used to store and compute the
!     associated values.&lt;/para&gt;
  
      &lt;para&gt;Since an engine's main role is to return the individual
      values associated with specific domain indices, any implementation
***************
*** 437,477 ****
      object&lt;/glossterm&gt; to each value returned by another &engine;.  A
      &lt;type&gt;CompFwd&lt;/type&gt; &engine; projects components from another
      &engine;.  For example, &lt;type&gt;CompFwd&lt;/type&gt; will use the second
!     components of each vector in an &array; to form its own &array;.
!     Since each container has one or more &engine;s, we can also
      describe the latter category as containers that compute their
      values using other containers' values.  A &multipatch; &engine;
      distributes its domain among various processors and memory spaces,
      each responsible for computing values associated with a portion,
!     or patch, of the domain.&lt;/para&gt;
  
      &lt;para&gt;Just as multiple containers can use the same engine,
      multiple &engine;s can use the same underlying data.  As we
      mentioned in &lt;xref linkend=&quot;arrays-arrays_use&quot;&gt;&lt;/xref&gt;, &engine;s
!     have reference semantics.  So a copy of an &engine; has a
!     reference-counted pointer to an &engine;'s data (if any exists).
      Thus, copying an &engine; or a container requires little execution
      time.  If an &engine; has the same data as another &engine; but it
      needs its own data to modify, the
!     &lt;methodname&gt;makeOwnCopy&lt;/methodname&gt; creates such a copy.&lt;/para&gt;
  
      &lt;para&gt;&engine;s are rarely explicitly declared.  Instead a
!     container is declared using an &engine; tag, and the container,
      creates the specified &engine; to deal with its values.  For
      example, a &brick; &engine; is explicitly declared as
      &lt;type&gt;Engine&lt;&dim;,T,Brick&gt;&lt;/type&gt;, but they are more
      frequently created by containers, e.g.,
!     &lt;type&gt;Array&lt;&dim;,T,Brick&gt;&lt;/type&gt;.  The first two template
!     parameters specify the domain's dimensionality and the value type,
!     as described in &lt;xref
      linkend=&quot;arrays-arrays_declarations&quot;&gt;&lt;/xref&gt;.  Unlike container
      declarations, the third template parameter, the &engine; tag,
      specifies which &engine; specialization to use.  For example, the
!     &brick; engine tag indicates a brick &engine; should be used.
      Some &engine;s, such as &lt;type&gt;CompFwd&lt;/type&gt;, are rarely declared
      even using &engine; tags.  Instead the &array;'s
      &lt;methodname&gt;comp&lt;/methodname&gt; and
!     &lt;methodname&gt;readComp&lt;/methodname&gt; methods return views of
      containers using &lt;type&gt;CompFwd&lt;/type&gt; &engine;s.&lt;/para&gt;
     &lt;/section&gt;
  
--- 444,487 ----
      object&lt;/glossterm&gt; to each value returned by another &engine;.  A
      &lt;type&gt;CompFwd&lt;/type&gt; &engine; projects components from another
      &engine;.  For example, &lt;type&gt;CompFwd&lt;/type&gt; will use the second
!     components of each &vector; in an &array; to form its own &array;.
!     Since each container has at least one &engine;, we can also
      describe the latter category as containers that compute their
      values using other containers' values.  A &multipatch; &engine;
      distributes its domain among various processors and memory spaces,
      each responsible for computing values associated with a portion,
!     or patch, of the domain.  The &remote; &engine; also supports
!     distributed computation.&lt;/para&gt;
  
      &lt;para&gt;Just as multiple containers can use the same engine,
      multiple &engine;s can use the same underlying data.  As we
      mentioned in &lt;xref linkend=&quot;arrays-arrays_use&quot;&gt;&lt;/xref&gt;, &engine;s
!     have &lt;glossterm linkend=&quot;glossary-reference_semantics&quot;&gt;reference
!     semantics&lt;/glossterm&gt;.  A copy of an &engine; has a
!     reference-counted pointer to the &engine;'s data (if any exists).
      Thus, copying an &engine; or a container requires little execution
      time.  If an &engine; has the same data as another &engine; but it
      needs its own data to modify, the
!     &lt;methodname&gt;makeOwnCopy&lt;/methodname&gt; member function creates such
!     a copy.&lt;/para&gt;
  
      &lt;para&gt;&engine;s are rarely explicitly declared.  Instead a
!     container is declared using an &engine; tag, and the container
      creates the specified &engine; to deal with its values.  For
      example, a &brick; &engine; is explicitly declared as
      &lt;type&gt;Engine&lt;&dim;,T,Brick&gt;&lt;/type&gt;, but they are more
      frequently created by containers, e.g.,
!     &lt;type&gt;Array&lt;&dim;,T,Brick&gt;&lt;/type&gt;.  An &engine;'s first two
!     template parameters specify the domain's dimensionality and the
!     value type, as described in &lt;xref
      linkend=&quot;arrays-arrays_declarations&quot;&gt;&lt;/xref&gt;.  Unlike container
      declarations, the third template parameter, the &engine; tag,
      specifies which &engine; specialization to use.  For example, the
!     &brick; &engine; tag indicates a &brick; &engine; should be used.
      Some &engine;s, such as &lt;type&gt;CompFwd&lt;/type&gt;, are rarely declared
      even using &engine; tags.  Instead the &array;'s
      &lt;methodname&gt;comp&lt;/methodname&gt; and
!     &lt;methodname&gt;readComp&lt;/methodname&gt; member functions return views of
      containers using &lt;type&gt;CompFwd&lt;/type&gt; &engine;s.&lt;/para&gt;
     &lt;/section&gt;
  
***************
*** 482,501 ****
      &lt;para&gt;In this section, we describe the different types of
      &engine;s and illustrate their creation, when appropriate.  First,
      we describe &engine;s that explicitly store values and then
!     &engine;s that compute values.&lt;/para&gt;
  
!      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;engines-types-table&quot;&gt;
!       &lt;title&gt;Types of &engine;s&lt;/title&gt;
       
!       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
         &lt;thead&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&engine; tag&lt;/entry&gt;
  	 &lt;entry&gt;description&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody&gt;
  	&lt;row rowsep=&quot;1&quot;&gt;
  	 &lt;entry&gt;&engine;s That Store&lt;/entry&gt;
  	&lt;/row&gt;
--- 492,512 ----
      &lt;para&gt;In this section, we describe the different types of
      &engine;s and illustrate their creation, when appropriate.  First,
      we describe &engine;s that explicitly store values and then
!     &engine;s that compute values.  See &lt;xref
!     linkend=&quot;engines-types-table&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
!     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
!            orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;engines-types-table&quot;&gt;
!      &lt;title&gt;Types of &engine;s&lt;/title&gt;
       
!      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
         &lt;thead&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&engine; tag&lt;/entry&gt;
  	 &lt;entry&gt;description&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody valign=&quot;top&quot;&gt;
  	&lt;row rowsep=&quot;1&quot;&gt;
  	 &lt;entry&gt;&engine;s That Store&lt;/entry&gt;
  	&lt;/row&gt;
***************
*** 506,512 ****
  	&lt;row&gt;
  	 &lt;entry&gt;&compressiblebrick;&lt;/entry&gt;
  	 &lt;entry&gt;stores all values, reducing storage requirements when
! 	 all values are the same.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&dynamic;&lt;/entry&gt;
--- 517,523 ----
  	&lt;row&gt;
  	 &lt;entry&gt;&compressiblebrick;&lt;/entry&gt;
  	 &lt;entry&gt;stores all values, reducing storage requirements when
! 	 all values are identical.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&dynamic;&lt;/entry&gt;
***************
*** 520,526 ****
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;type&gt;CompFwd&lt;/type&gt;&lt;/entry&gt;
  	 &lt;entry&gt;extracts specified components of an engine's vectors,
! 	 tensors, arrays, etc.; usually created using
  	 &lt;methodname&gt;comp&lt;/methodname&gt; container function.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
--- 531,537 ----
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;type&gt;CompFwd&lt;/type&gt;&lt;/entry&gt;
  	 &lt;entry&gt;extracts specified components of an engine's vectors,
! 	 tensors, arrays, etc.; usually created using the
  	 &lt;methodname&gt;comp&lt;/methodname&gt; container function.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
***************
*** 529,535 ****
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;type&gt;IndexFunction&lt;FunctionObject&gt;&lt;/type&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;makes the &lt;type&gt;FunctionObject&lt;/type&gt; function of
  	 indices behave like a container.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
--- 540,546 ----
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;type&gt;IndexFunction&lt;FunctionObject&gt;&lt;/type&gt;&lt;/entry&gt;
! 	 &lt;entry&gt;makes the &lt;type&gt;FunctionObject&lt;/type&gt;'s function of
  	 indices behave like a container.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
***************
*** 538,558 ****
  	 data-parallel expressions.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;Stencil&lt;Function,
! 	 Expression&gt;&lt;/type&gt;&lt;/entry&gt;
           &lt;entry&gt;applies a stencil computation (&lt;type&gt;Function&lt;/type&gt;)
! 	 to its input (&lt;type&gt;Expression&lt;/type&gt;), usually a container;
! 	 usually created by applying a &lt;type&gt;Stencil&lt;/type&gt; object to
! 	 a container.  A stencil computation can use multiple
! 	 neighboring input values.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;type&gt;UserFunctionEngine&lt;Function,
  	 Expression&gt;&lt;/type&gt;&lt;/entry&gt;
  	 &lt;entry&gt;applies the given function (or &lt;glossterm
  	 linkend=&quot;glossary-function_object&quot;&gt;function
! 	 object&lt;/glossterm&gt;) to its input (&lt;type&gt;Expression&lt;/type&gt;),
! 	 usually a container; usually created by applying a
  	 &lt;type&gt;UserFunction&lt;/type&gt; object to a container.  The
  	 function implements a one-to-one mapping from its input to
  	 values.&lt;/entry&gt;
--- 549,568 ----
  	 data-parallel expressions.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;Stencil&lt;Function, Expression&gt;&lt;/type&gt;&lt;/entry&gt;
           &lt;entry&gt;applies a stencil computation (&lt;type&gt;Function&lt;/type&gt;)
! 	 to its input (&lt;type&gt;Expression&lt;/type&gt;) which is usually a
! 	 container; usually created by applying a &lt;type&gt;Stencil&lt;/type&gt;
! 	 object to a container.  A stencil computation can use
! 	 multiple neighboring input values.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;type&gt;UserFunctionEngine&lt;Function,
  	 Expression&gt;&lt;/type&gt;&lt;/entry&gt;
  	 &lt;entry&gt;applies the given function (or &lt;glossterm
  	 linkend=&quot;glossary-function_object&quot;&gt;function
! 	 object&lt;/glossterm&gt;) to its input (&lt;type&gt;Expression&lt;/type&gt;)
! 	 which is usually a container; usually created by applying a
  	 &lt;type&gt;UserFunction&lt;/type&gt; object to a container.  The
  	 function implements a one-to-one mapping from its input to
  	 values.&lt;/entry&gt;
***************
*** 581,631 ****
        &lt;/tgroup&gt;
       &lt;/table&gt;
  
!     &lt;para&gt;&brick; &engine;s explicitly store values just like &c;
      arrays.  &compressiblebrick; &engine;s optimize their storage
!     requirements when all values are the same.  Most &array;s use one
      of these two &engine;s.  &brick;s are the default &engine;s for
!     &array; and &field; containers because each of their values are
!     explicitly stored.  Explicitly storing all an engine's value can
!     require a large amount of space, particularly if all these values
!     are the same.  If all a compressible brick &engine;'s values are
!     the same, the engine stores that one value rather than many, many
!     copies of the same value.  These engines can both save time as
!     well as space.  Initializing a compressible engine requires
!     setting only one value, not every value.  Using less storage space
!     may permit more useful values to be stored in cache, improving
!     cache performance.  Reading a value in a compressed &engine; using
!     &lt;methodname&gt;read&lt;/methodname&gt; is as fast as reading a value in a
!     &brick; &engine;, but writing a value always requires an
!     additional &lt;keywordname&gt;if&lt;/keywordname&gt; conditional.  Thus, if an
!     &engine; occasionally has multiple different values during its
!     life time, a &compressiblebrick; &engine; may be faster than a
!     &brick; &engine;.  If an &engine; is created and its values are
!     mostly read, not written, a &compressiblebrick; &engine; may also
!     be faster.  Otherwise, a &brick; &engine; may be preferable.
!     Timing the same program using the two different &engine; types
!     will reveal which is faster for a particular situation.&lt;/para&gt;
! 
!     &lt;para&gt;In distributed computing, many &engine;s may have few
!     nonzero values so &compressiblebrick; &engine;s may be preferable.
!     For distributed computing, a container's domain is partitioned
!     into regions each computed by a separate processor and &engine;.
!     If the computation is concentrated in sections of the domain, many
!     &engine;s may have few, if any, nonzero values.  Thus,
!     &compressiblebrick; &engine;s may be preferable for distributed
!     computing.&lt;/para&gt;
  
      &lt;para&gt;Both &brick; and &compressiblebrick; &engine;s have
      &lt;methodname&gt;read&lt;/methodname&gt; and
!     &lt;methodname&gt;operator()&lt;/methodname&gt; members with &int; and &loc;
!     parameters.  The parameters should match the &array;'s
      dimensionality.  For example, if &array; &lt;varname&gt;a&lt;/varname&gt; has
      dimensionality&nbsp;3, &lt;function&gt;a.read(int, int, int)&lt;/function&gt;
      and &lt;function&gt;a(int, int, int)&lt;/function&gt; should be used.  The
      former returns a value that cannot be modified, while the latter
!     can be changed.  Using the &lt;methodname&gt;read&lt;/methodname&gt; can lead
!     to faster code.  Alternatively, an index can be specified using a
!     &loc;.  For example,
      &lt;statement&gt;a.read(Loc&lt;3&gt;(1,-2,5))&lt;/statement&gt; and
      &lt;statement&gt;a(Loc&lt;3&gt;(1,-2,5))&lt;/statement&gt; are equivalent to
      &lt;statement&gt;a.read(1,-2,5))&lt;/statement&gt; and
--- 591,642 ----
        &lt;/tgroup&gt;
       &lt;/table&gt;
  
! &lt;!-- FIXME: Place in firstterm. --&gt;
!     &lt;para&gt;&lt;glossterm linkend=&quot;glossary-brick&quot;&gt;&brick;
!     &engine;s&lt;/glossterm&gt; explicitly store values just like &c;
      arrays.  &compressiblebrick; &engine;s optimize their storage
!     requirements when all values are identical.  Many &array;s use one
      of these two &engine;s.  &brick;s are the default &engine;s for
!     &array; and &field; containers because they explicitly store each
!     value.  This explicit storage can require a large amount of space,
!     particularly if all these values are the same.  If all a
!     compressible brick &engine;'s values are identical, the &engine;
!     stores that one value rather than many, many copies of the same
!     value.  These engines can both save time as well as space.
!     Initializing a compressible engine requires setting only one
!     value, not every value.  Using less storage space may also permit
!     more useful values to be stored in cache, improving cache
!     performance.  Reading a value in a compressed &engine; using the
!     &lt;methodname&gt;read&lt;/methodname&gt; member function is as fast as
!     reading a value in a &brick; &engine;, but writing a value always
!     requires executing an additional &lt;keywordname&gt;if&lt;/keywordname&gt;
!     conditional.  Thus, if an &engine; infrequently has multiple
!     different values during its life time, a &compressiblebrick;
!     &engine; may be faster than a &brick; &engine;.  If an &engine; is
!     created and its values are mostly read, not written, a
!     &compressiblebrick; &engine; may also be faster.  Otherwise, a
!     &brick; &engine; may be preferable.  Timing the same program using
!     the two different &engine; types will reveal which is faster for a
!     particular situation.  In distributed computing, many &engine;s
!     may have few nonzero values so &compressiblebrick; &engine;s may
!     be preferable.  For distributed computing, a container's domain is
!     partitioned into regions each computed by a separate processor and
!     &engine;.  If the computation is concentrated in sections of the
!     domain, many &engine;s may have few, if any, nonzero values.
!     Thus, &compressiblebrick; &engine;s may be preferable for
!     distributed computing.&lt;/para&gt;
  
      &lt;para&gt;Both &brick; and &compressiblebrick; &engine;s have
      &lt;methodname&gt;read&lt;/methodname&gt; and
!     &lt;methodname&gt;operator()&lt;/methodname&gt; member functions taking &int;
!     and &loc; parameters.  The parameters should match the &array;'s
      dimensionality.  For example, if &array; &lt;varname&gt;a&lt;/varname&gt; has
      dimensionality&nbsp;3, &lt;function&gt;a.read(int, int, int)&lt;/function&gt;
      and &lt;function&gt;a(int, int, int)&lt;/function&gt; should be used.  The
      former returns a value that cannot be modified, while the latter
!     can be changed.  Using the &lt;methodname&gt;read&lt;/methodname&gt; member
!     function can lead to faster code.  Alternatively, an index can be
!     specified using a &loc;.  For example,
      &lt;statement&gt;a.read(Loc&lt;3&gt;(1,-2,5))&lt;/statement&gt; and
      &lt;statement&gt;a(Loc&lt;3&gt;(1,-2,5))&lt;/statement&gt; are equivalent to
      &lt;statement&gt;a.read(1,-2,5))&lt;/statement&gt; and
***************
*** 641,650 ****
      &lt;methodname&gt;operator()&lt;/methodname&gt; take &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;
      or one &int; parameter.  In addition, the one-dimensional domain
      can be dynamically resized using &lt;methodname&gt;create&lt;/methodname&gt;
!     and &lt;methodname&gt;destroy&lt;/methodname&gt;; see .
  
! HERE Dynamic. How does one change the domain size?  What is the model?&lt;/para&gt;
  
  &lt;!-- HERE: Array cannot forward domain size changes to underlying Dynamic Engine. --&gt;
  
      &lt;para&gt;Types of &engine;s:
--- 652,666 ----
      &lt;methodname&gt;operator()&lt;/methodname&gt; take &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;
      or one &int; parameter.  In addition, the one-dimensional domain
      can be dynamically resized using &lt;methodname&gt;create&lt;/methodname&gt;
!     and &lt;methodname&gt;destroy&lt;/methodname&gt;.
! &lt;![%unfinished;[
! ; see .
  
! HERE Dynamic. How does one change the domain size?  What is the model?
! ]]&gt;  &lt;!-- end unfinished --&gt;
! &lt;/para&gt;
  
+ &lt;![%unfinished;[
  &lt;!-- HERE: Array cannot forward domain size changes to underlying Dynamic Engine. --&gt;
  
      &lt;para&gt;Types of &engine;s:
*************** HERE Dynamic. How does one change the do
*** 706,711 ****
--- 722,728 ----
      types of engines likely to be used by &pooma; programmers and how
      to declare containers using them.  Should I list the other engines
      that are automatically created?&lt;/para&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
     &lt;/section&gt;
    &lt;/chapter&gt;
*************** HERE Dynamic. How does one change the do
*** 729,745 ****
  &lt;![%temporary;[
  
     &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-view&quot;&gt;&lt;firstterm&gt;view of a
!    container&nbsp;&container;&lt;/firstterm&gt;&lt;/glossterm&gt; is a container
!    accessing a subset of &container;'s domain&nbsp;&containerdomain;
!    and values.  The subset can include all of&nbsp;&containerdomain;.
!    A &lt;quote&gt;view&lt;/quote&gt; is so named because it is a different way to
!    access, or view, another container's values.  Both the container
!    and its view share the same underlying engine so changing values in
!    one also changes them in the other.&lt;/para&gt;
  
     &lt;para&gt;A view is created by following a container's name by
!    parentheses containing a domain&nbsp;&containerdomain;.  For
!    example, consider this code extracted from &lt;xref
     linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt; in &lt;xref
     linkend=&quot;tutorial-array_data_parallel&quot;&gt;&lt;/xref&gt;.
  &lt;programlisting&gt;
--- 746,762 ----
  &lt;![%temporary;[
  
     &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-view&quot;&gt;&lt;firstterm&gt;view of a
!    container&lt;/firstterm&gt;&lt;/glossterm&gt; is a container accessing a subset
!    of &container;'s domain and values.  The subset can include all of
!    the container's domain.  A &lt;quote&gt;view&lt;/quote&gt; is so named because
!    it is a different way to access, or view, another container's
!    values.  Both the container and its view share the same underlying
!    engine so changing values in one also changes them in the
!    other.&lt;/para&gt;
  
     &lt;para&gt;A view is created by following a container's name by
!    parentheses containing a domain.  For example, consider this code
!    extracted from &lt;xref
     linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt; in &lt;xref
     linkend=&quot;tutorial-array_data_parallel&quot;&gt;&lt;/xref&gt;.
  &lt;programlisting&gt;
*************** a(I,J) = (1.0/9.0) *
*** 922,928 ****
  	 &lt;para&gt;create, copy, and destroy operations (mostly table)&lt;/para&gt;
  	&lt;/listitem&gt;
  	&lt;listitem&gt;
! 	 &lt;para&gt;nonmodifying operations (mostly table)&lt;/para&gt;
  	&lt;/listitem&gt;
  	&lt;listitem&gt;
  	 &lt;para&gt;assignments (mostly table)&lt;/para&gt;
--- 939,945 ----
  	 &lt;para&gt;create, copy, and destroy operations (mostly table)&lt;/para&gt;
  	&lt;/listitem&gt;
  	&lt;listitem&gt;
! 	 &lt;para&gt;non-modifying operations (mostly table)&lt;/para&gt;
  	&lt;/listitem&gt;
  	&lt;listitem&gt;
  	 &lt;para&gt;assignments (mostly table)&lt;/para&gt;
*************** a(I,J) = (1.0/9.0) *
*** 1082,1088 ****
  	&lt;entry&gt;description&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;&inform; &lt;varname&gt;pinfo&lt;/varname&gt;&lt;/entry&gt;
  	&lt;entry&gt;output stream used to print informative messages to the
--- 1099,1105 ----
  	&lt;entry&gt;description&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;&inform; &lt;varname&gt;pinfo&lt;/varname&gt;&lt;/entry&gt;
  	&lt;entry&gt;output stream used to print informative messages to the
*************** UNFINISHED&lt;/para&gt;
*** 1939,1945 ****
  	&lt;entry&gt;Interpretation&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;varname&gt;Dim&lt;/varname&gt;&lt;/entry&gt;
  	&lt;entry&gt;&lt;para&gt;dimension&lt;/para&gt;&lt;/entry&gt;
--- 1956,1962 ----
  	&lt;entry&gt;Interpretation&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;varname&gt;Dim&lt;/varname&gt;&lt;/entry&gt;
  	&lt;entry&gt;&lt;para&gt;dimension&lt;/para&gt;&lt;/entry&gt;
*************** UNFINISHED&lt;/para&gt;
*** 1971,1977 ****
  	&lt;entry&gt;Interpretation&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;fieldsynopsis&gt;&lt;varname&gt;This_t&lt;/varname&gt;&lt;/fieldsynopsis&gt;&lt;/entry&gt;
  	&lt;entry&gt;&lt;para&gt;the &array; object's type&lt;/para&gt;&lt;/entry&gt;
--- 1988,1994 ----
  	&lt;entry&gt;Interpretation&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;fieldsynopsis&gt;&lt;varname&gt;This_t&lt;/varname&gt;&lt;/fieldsynopsis&gt;&lt;/entry&gt;
  	&lt;entry&gt;&lt;para&gt;the &array; object's type&lt;/para&gt;&lt;/entry&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2032,2038 ****
  	 &lt;entry&gt;Effect&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;constructorsynopsis&gt;
--- 2049,2055 ----
  	 &lt;entry&gt;Effect&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody valign=&quot;top&quot;&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;constructorsynopsis&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2104,2110 ****
  	 &lt;entry&gt;Effect&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
--- 2121,2127 ----
  	 &lt;entry&gt;Effect&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody valign=&quot;top&quot;&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2187,2193 ****
  	 &lt;entry&gt;Effect&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
--- 2204,2210 ----
  	 &lt;entry&gt;Effect&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody valign=&quot;top&quot;&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2223,2229 ****
  	 &lt;entry&gt;Effect&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
--- 2240,2246 ----
  	 &lt;entry&gt;Effect&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody valign=&quot;top&quot;&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2269,2275 ****
  	 &lt;entry&gt;Effect&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
--- 2286,2292 ----
  	 &lt;entry&gt;Effect&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody valign=&quot;top&quot;&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2307,2313 ****
  	 &lt;entry&gt;Meaning&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;fieldsynopsis&gt;
--- 2324,2330 ----
  	 &lt;entry&gt;Meaning&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody valign=&quot;top&quot;&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;fieldsynopsis&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2433,2439 ****
  	&lt;entry&gt;Value&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;
            &lt;funcsynopsis&gt;
--- 2450,2456 ----
  	&lt;entry&gt;Value&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;
            &lt;funcsynopsis&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2914,2920 ****
  	&lt;entry&gt;Description&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;type&gt;NoMesh&lt;Dim&gt;&lt;/type&gt;&lt;/entry&gt;
  	&lt;entry&gt;&lt;para&gt;no physical spacing, causing a &field; to mimic
--- 2931,2937 ----
  	&lt;entry&gt;Description&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;&lt;type&gt;NoMesh&lt;Dim&gt;&lt;/type&gt;&lt;/entry&gt;
  	&lt;entry&gt;&lt;para&gt;no physical spacing, causing a &field; to mimic
*************** UNFINISHED&lt;/para&gt;
*** 2992,2998 ****
         &lt;entry&gt;Description&lt;/entry&gt;
        &lt;/row&gt;
       &lt;/thead&gt;
!      &lt;tbody&gt;
        &lt;row&gt;
         &lt;entry&gt;&lt;para&gt;Brick&lt;/para&gt;&lt;/entry&gt;
         &lt;entry&gt;&lt;para&gt;&lt;literal&gt;Brick&lt;/literal&gt;&lt;/para&gt;&lt;/entry&gt;
--- 3009,3015 ----
         &lt;entry&gt;Description&lt;/entry&gt;
        &lt;/row&gt;
       &lt;/thead&gt;
!      &lt;tbody valign=&quot;top&quot;&gt;
        &lt;row&gt;
         &lt;entry&gt;&lt;para&gt;Brick&lt;/para&gt;&lt;/entry&gt;
         &lt;entry&gt;&lt;para&gt;&lt;literal&gt;Brick&lt;/literal&gt;&lt;/para&gt;&lt;/entry&gt;
*************** UNFINISHED&lt;/para&gt;
*** 3585,3591 ****
     &lt;title&gt;Particles&lt;/title&gt;
  
     &lt;para&gt;&lt;filename
! 		   class=&quot;libraryfile&quot;&gt;docs/ParticlesDoc.txt&lt;/filename&gt; has
     out-of-date information.&lt;/para&gt;
  
     &lt;para&gt;See Section&nbsp;3.2.3 of
--- 3602,3608 ----
     &lt;title&gt;Particles&lt;/title&gt;
  
     &lt;para&gt;&lt;filename
!    class=&quot;libraryfile&quot;&gt;docs/ParticlesDoc.txt&lt;/filename&gt; has
     out-of-date information.&lt;/para&gt;
  
     &lt;para&gt;See Section&nbsp;3.2.3 of
*************** UNFINISHED&lt;/para&gt;
*** 3703,3711 ****
--- 3720,3736 ----
   &lt;appendix id=&quot;installation&quot;&gt;
    &lt;title&gt;Obtaining and Installing &pooma;&lt;/title&gt;
  
+ &lt;![%temporary;[
+   &lt;para&gt;In &lt;xref linkend=&quot;tutorial-installation&quot;&gt;&lt;/xref&gt;, we described
+   how to install &pooma;.  In the following section, we describe how
+   to install &pooma; to support distributed computation.&lt;/para&gt;
+ ]]&gt;  &lt;!-- end temporary --&gt;
+ 
+ &lt;![%unfinished;[
    &lt;para&gt;ADD: Write this section, including extensive instructions
    for Unix, MS Windows, and MacOS.  List the configuration options.
    Be sure to describe configuring for parallel execution.&lt;/para&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
    &lt;section id=&quot;installation-distributed_computing&quot;&gt;
     &lt;title&gt;Supporting Distributed Computation&lt;/title&gt;
*************** UNFINISHED&lt;/para&gt;
*** 3724,3743 ****
      &lt;para&gt;&cheetah;, and thus &pooma;, can use Ralf Engelschall's &mm;
      Shared Memory Library to pass messages between processors.  For
      example, the &author; uses this library on a two-processor
!     computer running &linux;.  The library, available at
!     <A HREF="http://www.engelschall.com/sw/mm/,">http://www.engelschall.com/sw/mm/,</A> is available for free and has
!     been successfully tested on a variety of Unix platforms.&lt;/para&gt;
  
      &lt;para&gt;We describe how to download and install the &mm; library.
       &lt;orderedlist spacing=&quot;compact&quot;&gt;
! 	&lt;listitem&gt;
! 	 &lt;para&gt;Download the library from the &pooma; Download page
!          available off the &pooma; home page (&poomahomepage;).&lt;/para&gt;
! 	&lt;/listitem&gt;
  	&lt;listitem&gt;
  	 &lt;para&gt;Extract the source code using &lt;command&gt;tar xzvf
!          mm-1.1.3.tar.gz&lt;/command&gt;.  Move into the resulting source
!          code directory &lt;filename
           class=&quot;directory&quot;&gt;mm-1.1.3&lt;/filename&gt;.&lt;/para&gt;
  	&lt;/listitem&gt;
  	&lt;listitem&gt;
--- 3749,3770 ----
      &lt;para&gt;&cheetah;, and thus &pooma;, can use Ralf Engelschall's &mm;
      Shared Memory Library to pass messages between processors.  For
      example, the &author; uses this library on a two-processor
!     computer running &linux;.  The library, available at &lt;ulink
!     url=&quot;<A HREF="http://www.engelschall.com/sw/mm/">http://www.engelschall.com/sw/mm/</A>&quot;&gt;<A HREF="http://www.engelschall.com/sw/mm/&lt;/ulink">http://www.engelschall.com/sw/mm/&lt;/ulink</A>&gt;,
!     is available for free and has been successfully tested on a
!     variety of Unix platforms.&lt;/para&gt;
  
      &lt;para&gt;We describe how to download and install the &mm; library.
       &lt;orderedlist spacing=&quot;compact&quot;&gt;
!       &lt;listitem&gt;
!        &lt;para&gt;Download the library from the &pooma; Download page
!        (&poomadownloadpage;) available off the &pooma; home page
!        (&poomahomepage;).&lt;/para&gt;
!       &lt;/listitem&gt;
  	&lt;listitem&gt;
  	 &lt;para&gt;Extract the source code using &lt;command&gt;tar xzvf
!          mm-1.1.3.tar.gz&lt;/command&gt;.  Change directories into the
!          resulting source code directory &lt;filename
           class=&quot;directory&quot;&gt;mm-1.1.3&lt;/filename&gt;.&lt;/para&gt;
  	&lt;/listitem&gt;
  	&lt;listitem&gt;
*************** UNFINISHED&lt;/para&gt;
*** 3754,3763 ****
           &dashdash;prefix=${HOME}/pooma/mm-1.1.3&lt;/command&gt;.&lt;/para&gt;
  	&lt;/listitem&gt;
  	&lt;listitem&gt;
! 	 &lt;para&gt;Create the library by issuing the &lt;command&gt;make&lt;/command&gt;
!      command.  This compiles the source code using a &c; compiler.  To
!      use a different compiler than the &mm; configuration chooses, set
!      the &lt;envar&gt;CC&lt;/envar&gt; to the compiler before configuring.&lt;/para&gt;
        &lt;/listitem&gt;
      &lt;listitem&gt;
       &lt;para&gt;Optionally test the library by issuing the &lt;command&gt;make
--- 3781,3792 ----
           &dashdash;prefix=${HOME}/pooma/mm-1.1.3&lt;/command&gt;.&lt;/para&gt;
  	&lt;/listitem&gt;
  	&lt;listitem&gt;
! 	 &lt;para&gt;Create the library by issuing the
!          &lt;command&gt;make&lt;/command&gt; command.  This compiles the source
!          code using a &c; compiler.  To use a different compiler than
!          the &mm; configuration chooses, set the &lt;envar&gt;CC&lt;/envar&gt;
!          environment variable to the desired compiler before
!          configuring.&lt;/para&gt;
        &lt;/listitem&gt;
      &lt;listitem&gt;
       &lt;para&gt;Optionally test the library by issuing the &lt;command&gt;make
*************** UNFINISHED&lt;/para&gt;
*** 3791,3798 ****
  
      &lt;para&gt;&cheetah;'s messaging is implemented using an underlying
      messaging library such as the Message Passing Interface (&mpi;)
!     Communications Library (FIXME: xref linkend=&quot;mpi99&quot;, &lt;ulink
!     url=&quot;<A HREF="http://www-unix.mcs.anl.gov/mpi/">http://www-unix.mcs.anl.gov/mpi/</A>&quot;&gt;&lt;/ulink&gt;) or the &mm;
      Shared Memory Library.  &mpi; works on a wide variety of platforms
      and has achieved widespread usage.  &mm; works under Unix on any
      computer with shared memory.  Both libraries are available for
--- 3820,3831 ----
  
      &lt;para&gt;&cheetah;'s messaging is implemented using an underlying
      messaging library such as the Message Passing Interface (&mpi;)
!     Communications Library
! &lt;![%unfinished;[
!  (FIXME: xref linkend=&quot;mpi99&quot;, &lt;ulink
!     url=&quot;<A HREF="http://www-unix.mcs.anl.gov/mpi/">http://www-unix.mcs.anl.gov/mpi/</A>&quot;&gt;&lt;/ulink&gt;)
! ]]&gt;  &lt;!-- end unfinished --&gt;
!     or the &mm;
      Shared Memory Library.  &mpi; works on a wide variety of platforms
      and has achieved widespread usage.  &mm; works under Unix on any
      computer with shared memory.  Both libraries are available for
*************** UNFINISHED&lt;/para&gt;
*** 3803,3814 ****
       &lt;orderedlist spacing=&quot;compact&quot;&gt;
        &lt;listitem&gt;
         &lt;para&gt;Download the library from the &pooma; Download page
!        available off the &pooma; home page (&poomahomepage;).&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
         &lt;para&gt;Extract the source code using &lt;command&gt;tar xzvf
!        cheetah-1.0.tgz&lt;/command&gt;.  Move into the resulting source code
!        directory &lt;filename
         class=&quot;directory&quot;&gt;cheetah-1.0&lt;/filename&gt;.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
--- 3836,3848 ----
       &lt;orderedlist spacing=&quot;compact&quot;&gt;
        &lt;listitem&gt;
         &lt;para&gt;Download the library from the &pooma; Download page
!        (&poomadownloadpage;) available off the &pooma; home page
!        (&poomahomepage;).&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
         &lt;para&gt;Extract the source code using &lt;command&gt;tar xzvf
!        cheetah-1.0.tgz&lt;/command&gt;.  Change directories into the
!        resulting source code directory &lt;filename
         class=&quot;directory&quot;&gt;cheetah-1.0&lt;/filename&gt;.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
*************** UNFINISHED&lt;/para&gt;
*** 3935,3941 ****
          installed &cheetah; library.  For
          example, &lt;command&gt;declare -x
          CHEETAHDIR=${HOME}/pooma/cheetah-1.0&lt;/command&gt; specifies the
!         installation directory used in the previous section.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
         &lt;para&gt;When configuring &pooma;, specify the
--- 3969,3977 ----
          installed &cheetah; library.  For
          example, &lt;command&gt;declare -x
          CHEETAHDIR=${HOME}/pooma/cheetah-1.0&lt;/command&gt; specifies the
!         installation directory used in the previous section.  If using
!         the &lt;application&gt;csh&lt;/application&gt; shell, use &lt;command&gt;setenv 
!         CHEETAHDIR ${HOME}/pooma/cheetah-1.0&lt;/command&gt;.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
         &lt;para&gt;When configuring &pooma;, specify the
*************** UNFINISHED&lt;/para&gt;
*** 4137,4142 ****
--- 4173,4180 ----
  
   &lt;!-- Index --&gt;
  
+ &lt;![%unfinished;[
    &amp;genindex.sgm;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
  &lt;/book&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000888.html">[pooma-dev] Manual: Wordsmithing Changes to First Four Chapte	rs
</A></li>
	<LI>Next message: <A HREF="000890.html">Manual Figures
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#889">[ date ]</a>
              <a href="thread.html#889">[ thread ]</a>
              <a href="subject.html#889">[ subject ]</a>
              <a href="author.html#889">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
