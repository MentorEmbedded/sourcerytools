<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Patch: Recent Manual Changes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Patch%3A%20Recent%20Manual%20Changes&In-Reply-To=%3C20020104024400.A6343%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000878.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Patch: Recent Manual Changes</H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Patch%3A%20Recent%20Manual%20Changes&In-Reply-To=%3C20020104024400.A6343%40codesourcery.com%3E"
       TITLE="Patch: Recent Manual Changes">oldham at codesourcery.com
       </A><BR>
    <I>Fri Jan  4 10:44:00 UTC 2002</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000878.html">Manual Patch: Program Movements and Additions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#877">[ date ]</a>
              <a href="thread.html#877">[ thread ]</a>
              <a href="subject.html#877">[ subject ]</a>
              <a href="author.html#877">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch mainly adds (mostly finished) chapters on understanding and
using data-parallel operators and templates to the R2 manual that is
being written.

2002-Jan-04  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

	* bibliography.xml: New file containing bibliographic information.
	* concepts.xml: Clarify containers that map indices to values.
	* glossary.xml: Add entries for compilation time, compile time,
	conformable containers, conformable domains, execution time,
	instantiation, programming time, run time, template instantiation,
	trait, traits class, Turing complete.
	* introduction.xml: Many minor changes mainly involving formatting
	and word choice.  Add sections discussing program execution speed
	and open-source software.
	* manual.xml: Add several new entity definitions.  Add unfinished
	chapter discussing writing programs using templates.  Add unfinished
	data-parallel operator chapter.  Many other minor changes.  Move
	bibliography to separate file.
	* tutorial.xml: Minor wordsmithing changes.
	* figures/box-macros.mp: New file containing macros to create
	boxes in illustrations.
	* figures/data-parallel.mp: New file illustrating data-parallel
	operations.
	* figures/doof2d.mp: Replace definitions with inclusion of
	grid-macros.mp.
	* figures/grid-macros.mp: New file containing macros to create
	grids.
	* figures/introduction.mp: Use box-macros.mp.
	* programs/Doof2d-Array-distributed-annotated.patch: Moved to
	different directory.
	* programs/Doof2d-Array-element-annotated.patch: Likewise.
	* programs/Doof2d-Array-parallel-annotated.patch: Likewise.
	* programs/Doof2d-Array-stencil-annotated.patch: Likewise.
	* programs/Doof2d-C-element-annotated.patch: Likewise.
	* programs/Doof2d-Field-distributed-annotated.patch: Likewise.
	* programs/Doof2d-Field-parallel-annotated.patch: Likewise.
	* programs/makefile: Likewise.

Applied to	mainline.

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: bibliography.xml
===================================================================
RCS file: bibliography.xml
diff -N bibliography.xml
*** /dev/null	Fri Mar 23 21:37:44 2001
--- bibliography.xml	Fri Jan  4 10:14:05 2002
***************
*** 0 ****
--- 1,277 ----
+ &lt;!-- Bibliography --&gt;
+ 
+ &lt;bibliography id=&quot;bibliography&quot;&gt;
+  &lt;title&gt;Bibliography&lt;/title&gt;
+ 
+  &lt;para&gt;FIXME: How do I process these entries?&lt;/para&gt;
+ 
+  &lt;biblioentry&gt;
+   &lt;abbrev&gt;mpi99&lt;/abbrev&gt;
+   &lt;authorgroup&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;William&lt;/firstname&gt;&lt;surname&gt;Gropp&lt;/surname&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Ewing&lt;/firstname&gt;&lt;surname&gt;Lusk&lt;/surname&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Anthony&lt;/firstname&gt;&lt;surname&gt;Skjellum&lt;/surname&gt;
+    &lt;/author&gt;
+   &lt;/authorgroup&gt;
+   &lt;copyright&gt;
+    &lt;year&gt;1999&lt;/year&gt;
+    &lt;holder&gt;Massachusetts Institute of Technology&lt;/holder&gt;
+   &lt;/copyright&gt;
+   &lt;isbn&gt;0-262-57132-3&lt;/isbn&gt;
+   &lt;publisher&gt;
+    &lt;publishername&gt;The MIT Press&lt;/publishername&gt;
+    &lt;address&gt;Cambridge, MA&lt;/address&gt;
+   &lt;/publisher&gt;
+   &lt;title&gt;Using MPI&lt;/title&gt;
+   &lt;subtitle&gt;Portable Parallel Programming with the Message-Passing Interface&lt;/subtitle&gt;
+   &lt;edition&gt;second edition&lt;/edition&gt;
+  &lt;/biblioentry&gt;
+ 
+  &lt;biblioentry&gt;
+   &lt;abbrev&gt;pooma95&lt;/abbrev&gt;
+   &lt;authorgroup&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;John&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;V. W.&lt;/othername&gt;&lt;surname&gt;Reynders&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Paul&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;J.&lt;/othername&gt;&lt;surname&gt;Hinker&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Dakota Software Systems, Inc.&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Rapid City&lt;/city&gt;&lt;state&gt;SD&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Julian&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;C.&lt;/othername&gt;&lt;surname&gt;Cummings&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Susan&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;R.&lt;/othername&gt;&lt;surname&gt;Atlas&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Parallel Solutions, Inc.&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Santa Fe&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Subhankar&lt;/firstname&gt;&lt;surname&gt;Banerjee&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;New Mexico State University&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Las Cruces&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;William&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;F.&lt;/othername&gt;&lt;surname&gt;Humphrey&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;University of Illinois at Urbana-Champaign&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Urbana-Champaign&lt;/city&gt;&lt;state&gt;IL&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Steve&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;R.&lt;/othername&gt;&lt;surname&gt;Karmesin&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;California Institute of Technology&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Pasadena&lt;/city&gt;&lt;state&gt;CA&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Katarzyna&lt;/firstname&gt;&lt;surname&gt;Keahey&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Indiana University&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Bloomington&lt;/city&gt;&lt;state&gt;IN&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Marydell&lt;/firstname&gt;&lt;surname&gt;Tholburn&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+   &lt;/authorgroup&gt;
+   &lt;title&gt;&pooma;&lt;/title&gt;
+   &lt;subtitle&gt;A Framework for Scientific Simulation on Parallel Architectures&lt;/subtitle&gt;
+   &lt;releaseinfo&gt;unpublished&lt;/releaseinfo&gt;
+  &lt;/biblioentry&gt;
+ 
+  &lt;biblioentry&gt;
+   &lt;abbrev&gt;pooma-sc95&lt;/abbrev&gt;
+   &lt;authorgroup&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Susan&lt;/firstname&gt;&lt;surname&gt;Atlas&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Subhankar&lt;/firstname&gt;&lt;surname&gt;Banerjee&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;New Mexico State University&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Las Cruces&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Julian&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;C.&lt;/othername&gt;&lt;surname&gt;Cummings&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Paul&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;J.&lt;/othername&gt;&lt;surname&gt;Hinker&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Advanced Computing Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;M.&lt;/firstname&gt;&lt;surname&gt;Srikant&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;New Mexico State University&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Las Cruces&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;John&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;V. W.&lt;/othername&gt;&lt;surname&gt;Reynders&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Marydell&lt;/firstname&gt;&lt;surname&gt;Tholburn&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+   &lt;/authorgroup&gt;
+   &lt;title&gt;&pooma;&lt;/title&gt;
+   &lt;subtitle&gt;A High Performance Distributed Simulation Environment for
+   Scientific Applications&lt;/subtitle&gt;
+ &lt;!-- FIXME: Where list Supercomputing 1995? --&gt;
+  &lt;/biblioentry&gt;
+ 
+  &lt;biblioentry&gt;
+   &lt;abbrev&gt;pooma-siam98&lt;/abbrev&gt;
+   &lt;authorgroup&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Julian&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;C.&lt;/othername&gt;&lt;surname&gt;Cummings&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;James&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;A.&lt;/othername&gt;&lt;surname&gt;Crotinger&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Scott&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;W.&lt;/othername&gt;&lt;surname&gt;Haney&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;William&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;F.&lt;/othername&gt;&lt;surname&gt;Humphrey&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Steve&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;R.&lt;/othername&gt;&lt;surname&gt;Karmesin&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;John&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;V. W.&lt;/othername&gt;&lt;surname&gt;Reynders&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Stephen&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;A.&lt;/othername&gt;&lt;surname&gt;Smith&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Timothy&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;J.&lt;/othername&gt;&lt;surname&gt;Williams&lt;/surname&gt;
+     &lt;affiliation&gt;
+      &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
+      &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
+     &lt;/affiliation&gt;
+    &lt;/author&gt;
+   &lt;/authorgroup&gt;
+   &lt;title&gt;Raid Application Development and Enhanced Code
+   Interoperability using the &pooma; Framework&lt;/title&gt;
+ &lt;!-- FIXME: Where list SIAM Workshop ... 1998? --&gt;
+  &lt;/biblioentry&gt;
+ 
+  &lt;biblioentry&gt;
+   &lt;abbrev&gt;pete-99&lt;/abbrev&gt;
+   &lt;authorgroup&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Scott&lt;/firstname&gt;&lt;surname&gt;Haney&lt;/surname&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;James&lt;/firstname&gt;&lt;surname&gt;Crotinger&lt;/surname&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Steve&lt;/firstname&gt;&lt;surname&gt;Karmesin&lt;/surname&gt;
+    &lt;/author&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Stephen&lt;/firstname&gt;&lt;surname&gt;Smith&lt;/surname&gt;
+    &lt;/author&gt;
+   &lt;/authorgroup&gt;
+   &lt;title&gt;&pete;: The Portable Expression Template Engine.  1999 October,
+ \emph{Dr. Dobb's Journal}, vol.24, nu.10, pp.88--95&lt;/title&gt;
+ &lt;!-- FIXME: Fix the tagging. --&gt;
+  &lt;/biblioentry&gt;
+ 
+  &lt;biblioentry&gt;
+   &lt;abbrev&gt;veldhuizen-95&lt;/abbrev&gt;
+   &lt;authorgroup&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;Todd&lt;/firstname&gt;&lt;surname&gt;Veldhuizen&lt;/surname&gt;
+    &lt;/author&gt;
+   &lt;/authorgroup&gt;
+   &lt;title&gt;Expression Templates.  1995 June, \emph{&cc; Report}, vol.7,
+ nu.5, pp.26--31.  Also available at <A HREF="http://osl.iu.edu/~tveldhui/papers/Expression-Templates/exprtmpl.html&lt;/title">http://osl.iu.edu/~tveldhui/papers/Expression-Templates/exprtmpl.html&lt;/title</A>&gt;
+ &lt;!-- FIXME: Fix the tagging. --&gt;
+  &lt;/biblioentry&gt;
+ 
+  &lt;biblioentry&gt;
+   &lt;abbrev&gt;vandevoorde-95&lt;/abbrev&gt;
+   &lt;authorgroup&gt;
+    &lt;author&gt;
+     &lt;firstname&gt;David&lt;/firstname&gt;&lt;surname&gt;Vandevoorde&lt;/surname&gt;
+    &lt;/author&gt;
+   &lt;/authorgroup&gt;
+   &lt;title&gt;\texttt{valarray&lt;Troy&gt;}: An Implementation of a Numerical
+ Array.  1995.  unpublished.  Available at <A HREF="ftp://ftp.cs.rpi.edu/pub/vandevod/Valarray/Documents/valarray.ps.&lt;/title">ftp://ftp.cs.rpi.edu/pub/vandevod/Valarray/Documents/valarray.ps.&lt;/title</A>&gt;
+ &lt;!-- FIXME: Fix the tagging. --&gt;
+  &lt;/biblioentry&gt;
+ 
+ 
+ &lt;/bibliography&gt;
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.3
diff -c -p -r1.3 concepts.xml
*** concepts.xml	2001/12/17 17:27:41	1.3
--- concepts.xml	2002/01/04 17:14:05
***************
*** 343,349 ****
  	&lt;imagedata fileref=&quot;figures/concepts.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
       &lt;/imageobject&gt;
       &lt;textobject&gt;
! 	&lt;phrase&gt;maps from indices to values&lt;/phrase&gt;
       &lt;/textobject&gt;
      &lt;/mediaobject&gt;
     &lt;/figure&gt;
--- 343,349 ----
  	&lt;imagedata fileref=&quot;figures/concepts.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
       &lt;/imageobject&gt;
       &lt;textobject&gt;
! 	&lt;phrase&gt;&array;s and &field;s map from indices to values.&lt;/phrase&gt;
       &lt;/textobject&gt;
      &lt;/mediaobject&gt;
     &lt;/figure&gt;
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.4
diff -c -p -r1.4 glossary.xml
*** glossary.xml	2001/12/17 17:27:41	1.4
--- glossary.xml	2002/01/04 17:14:06
***************
*** 91,96 ****
--- 91,112 ----
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
+   &lt;glossentry id=&quot;glossary-compilation_time&quot;&gt;
+    &lt;glossterm&gt;compilation time&lt;/glossterm&gt;
+    &lt;glosssee otherterm=&quot;glossary-compilation_time&quot;&gt;&lt;/glosssee&gt;
+   &lt;/glossentry&gt;
+ 
+   &lt;glossentry id=&quot;glossary-compile_time&quot;&gt;
+    &lt;glossterm&gt;compile time&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;time in the process from writing a program to executing it
+     when the program is compiled by a compiler.  This is also called
+     &lt;firstterm&gt;compilation time&lt;/firstterm&gt;.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-programming_time&quot;&gt;programming time&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-run_time&quot;&gt;run time&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-computing_environment&quot;&gt;
     &lt;glossterm&gt;computing environment&lt;/glossterm&gt;
     &lt;glossdef&gt;
***************
*** 102,107 ****
--- 118,145 ----
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
+   &lt;glossentry id=&quot;glossary-conformable_containers&quot;&gt;
+    &lt;glossterm&gt;conformable containers&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;containers with conformable domains.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-conformable_domains&quot;&gt;conformable domains&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
+   &lt;glossentry id=&quot;glossary-conformable_domains&quot;&gt;
+    &lt;glossterm&gt;conformable domains&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;domains with the &lt;quote&gt;same shape&lt;/quote&gt; so that
+     corresponding dimensions have the same number of elements.
+     Scalars, deemed conformable with any domain, get
+     &lt;quote&gt;expanded&lt;/quote&gt; to the domain's shape.  Binary operators
+     can operate on containers with conformable domains.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-conformable_containers&quot;&gt;conformable containers&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-container&quot;&gt;
     &lt;glossterm&gt;container&lt;/glossterm&gt;
     &lt;glossdef&gt;
***************
*** 240,245 ****
--- 278,288 ----
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
+   &lt;glossentry id=&quot;glossary-execution_time&quot;&gt;
+    &lt;glossterm&gt;execution time&lt;/glossterm&gt;
+    &lt;glosssee otherterm=&quot;glossary-run_time&quot;&gt;&lt;/glosssee&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-external_guard_layer&quot;&gt;
     &lt;glossterm&gt;external guard layer&lt;/glossterm&gt;
     &lt;glossdef&gt;
***************
*** 297,311 ****
     &lt;glossdef&gt;
      &lt;para&gt;domain surrounding each patch of a container's domain.  It
      contains read-only values.  &lt;link
! 				       linkend=&quot;glossary-external_guard_layer&quot;&gt;External guard
      layer&lt;/link&gt;s ease programming, while &lt;link
! 						 linkend=&quot;glossary-internal_guard_layer&quot;&gt;internal guard
      layer&lt;/link&gt;s permit each patch's computation to be occur without
!     copying values from adjacent patches.  They are optimizations,
!     not required for program correctness.&lt;/para&gt;
!     &lt;glossseealso otherterm=&quot;glossary-external_guard_layer&quot;&gt;external guard layer&lt;/glossseealso&gt;
!     &lt;glossseealso otherterm=&quot;glossary-internal_guard_layer&quot;&gt;internal guard layer&lt;/glossseealso&gt;
!     &lt;glossseealso otherterm=&quot;glossary-partition&quot;&gt;partition&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-patch&quot;&gt;patch&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
--- 340,356 ----
     &lt;glossdef&gt;
      &lt;para&gt;domain surrounding each patch of a container's domain.  It
      contains read-only values.  &lt;link
!     linkend=&quot;glossary-external_guard_layer&quot;&gt;External guard
      layer&lt;/link&gt;s ease programming, while &lt;link
!     linkend=&quot;glossary-internal_guard_layer&quot;&gt;internal guard
      layer&lt;/link&gt;s permit each patch's computation to be occur without
!     copying values from adjacent patches.  They are optimizations, not
!     required for program correctness.&lt;/para&gt; &lt;glossseealso
!     otherterm=&quot;glossary-external_guard_layer&quot;&gt;external guard
!     layer&lt;/glossseealso&gt; &lt;glossseealso
!     otherterm=&quot;glossary-internal_guard_layer&quot;&gt;internal guard
!     layer&lt;/glossseealso&gt; &lt;glossseealso
!     otherterm=&quot;glossary-partition&quot;&gt;partition&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-patch&quot;&gt;patch&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
***************
*** 319,331 ****
     &lt;glossterm&gt;index&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;a position in a &lt;link
! 				 linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; usually denoted by an
      ordered tuple.  More than one index are called &lt;link
! 							  linkend=&quot;glossary-indices&quot;&gt;indices&lt;/link&gt;.&lt;/para&gt;
!     &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
    &lt;glossentry id=&quot;glossary-indices&quot;&gt;
     &lt;glossterm&gt;indices&lt;/glossterm&gt;
     &lt;glossdef&gt;
--- 364,381 ----
     &lt;glossterm&gt;index&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;a position in a &lt;link
!     linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; usually denoted by an
      ordered tuple.  More than one index are called &lt;link
!     linkend=&quot;glossary-indices&quot;&gt;indices&lt;/link&gt;.&lt;/para&gt; &lt;glossseealso
!     otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
+   &lt;glossentry id=&quot;glossary-instantiation&quot;&gt;
+    &lt;glossterm&gt;instantiation&lt;/glossterm&gt;
+    &lt;glosssee&gt;template instantiation&lt;/glosssee&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-indices&quot;&gt;
     &lt;glossterm&gt;indices&lt;/glossterm&gt;
     &lt;glossdef&gt;
***************
*** 439,444 ****
--- 489,504 ----
      &lt;glossseealso otherterm=&quot;glossary-index&quot;&gt;index&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
+ 
+   &lt;glossentry id=&quot;glossary-programming_time&quot;&gt;
+    &lt;glossterm&gt;programming time&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;time in the process from writing a program to executing it
+     when the program is being written by a programmer.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-compile_time&quot;&gt;compile time&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-run_time&quot;&gt;run time&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
  
   &lt;glossdiv id=&quot;glossary-r&quot;&gt;
***************
*** 480,485 ****
--- 540,556 ----
      &lt;glossseealso otherterm=&quot;glossary-stencil&quot;&gt;stencil&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
+ 
+   &lt;glossentry id=&quot;glossary-run_time&quot;&gt;
+    &lt;glossterm&gt;run time&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;time in the process from writing a program to executing it
+     when the program is executed.  This is also called
+     &lt;firstterm&gt;execution time&lt;/firstterm&gt;.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-compile_time&quot;&gt;compile time&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-programming_time&quot;&gt;programming time&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
  
   &lt;glossdiv id=&quot;glossary-s&quot;&gt;
***************
*** 541,546 ****
--- 612,629 ----
   &lt;glossdiv id=&quot;glossary-t&quot;&gt;
    &lt;title&gt;T&lt;/title&gt;
  
+   &lt;glossentry id=&quot;glossary-template_instantiation&quot;&gt;
+    &lt;glossterm&gt;template instantiation&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;applying a template class to template parameters to create a
+     type.  For example, &lt;statement&gt;foo&lt;double,3&gt;&lt;/statement&gt;
+     instantiates &lt;statement&gt;template &lt;typename T, int n&gt; class
+     foo&lt;/statement&gt; with the type &double; and the constant
+     integer&nbsp;3.  Template instantiation is analogous to applying a
+     function to function arguments.&lt;/para&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-tensor&quot;&gt;
     &lt;glossterm&gt;&tensor;&lt;/glossterm&gt;
     &lt;glossdef&gt;
***************
*** 558,563 ****
--- 641,673 ----
      mathematical matrices as first-class objects.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
+   &lt;glossentry id=&quot;glossary-trait&quot;&gt;
+    &lt;glossterm&gt;trait&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;a characteristic of a type.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-traits_class&quot;&gt;traits class&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
+   &lt;glossentry id=&quot;glossary-traits_class&quot;&gt;
+    &lt;glossterm&gt;traits class&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;a class containing one or more traits all describing a
+     particular type's chacteristics.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-trait&quot;&gt;trait&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
+   &lt;glossentry id=&quot;glossary-Turing_complete&quot;&gt;
+    &lt;glossterm&gt;Turing complete&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;describes a language that can compute anything that can be
+     computed.  That is, the language for computation is as powerful as
+     it can be.  Most wide-spread programming languages are
+     Turing-complete, including &cc;, &c;, and &fortran;.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
Index: introduction.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/introduction.xml,v
retrieving revision 1.1
diff -c -p -r1.1 introduction.xml
*** introduction.xml	2001/12/17 17:27:41	1.1
--- introduction.xml	2002/01/04 17:14:06
***************
*** 2,21 ****
   &lt;title&gt;Introduction&lt;/title&gt;
  
   &lt;para&gt;The Parallel Object-Oriented Methods and Applications
!  &lt;acronym&gt;POOMA&lt;/acronym&gt; &toolkitcap; is a &cc; &toolkit; for
!  writing high-performance scientific programs for sequential and
!  distributed computation.  The &toolkit; provides a variety of
!  tools:
   &lt;itemizedlist spacing=&quot;compact&quot;&gt;
     &lt;listitem&gt;
      &lt;para&gt;containers and other abstractions suitable for scientific
      computation,&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
-     &lt;para&gt;several container storage classes to reduce a program's
-     storage requirements,&lt;/para&gt;
-    &lt;/listitem&gt;
-    &lt;listitem&gt;
      &lt;para&gt;support for a variety of computation modes including
      data-parallel expressions, stencil-based computations, and lazy
      evaluation,&lt;/para&gt;
--- 2,16 ----
   &lt;title&gt;Introduction&lt;/title&gt;
  
   &lt;para&gt;The Parallel Object-Oriented Methods and Applications
!  (&lt;acronym&gt;POOMA&lt;/acronym&gt;) &toolkitcap; is a &cc; &toolkit; for
!  writing high-performance scientific programs.  The &toolkit; provides
!  a variety of tools:
   &lt;itemizedlist spacing=&quot;compact&quot;&gt;
     &lt;listitem&gt;
      &lt;para&gt;containers and other abstractions suitable for scientific
      computation,&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;support for a variety of computation modes including
      data-parallel expressions, stencil-based computations, and lazy
      evaluation,&lt;/para&gt;
***************
*** 25,31 ****
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;automatic creation of all interprocessor communication for
!     parallel and distributed programs, and&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;automatic out-of-order execution and loop rearrangement
--- 20,30 ----
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;automatic creation of all interprocessor communication for
!     parallel and distributed programs&lt;/para&gt;
!    &lt;/listitem&gt;
!    &lt;listitem&gt;
!     &lt;para&gt;several container storage classes to reduce a program's
!     storage requirements, and&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;automatic out-of-order execution and loop rearrangement
***************
*** 34,53 ****
    &lt;/itemizedlist&gt;
   Since the &toolkit; provides high-level abstractions, &pooma;
   programs are much shorter than corresponding &fortran; or &c;
!  programs, requiring less time to write and less time to debug.
!  Using these high-level abstractions, the same code runs on a wide
!  variety of computers almost as fast as carefully crafted
!  machine-specific hand-written programs.  The &toolkit; is freely
!  available, open-source software compatible with any modern &cc;
!  compiler.&lt;/para&gt;
  
!  &lt;formalpara&gt;&lt;title&gt;&pooma; Goals.&lt;/title&gt;
    &lt;para&gt;The goals for the &poomatoolkit; have remained unchanged
!   since its inception in 1994:
    &lt;orderedlist&gt;
     &lt;listitem&gt;
      &lt;para&gt;Code portability across serial, distributed, and parallel
!     architectures with no change to source code.&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;Development of reusable, cross-problem-domain components
--- 33,55 ----
    &lt;/itemizedlist&gt;
   Since the &toolkit; provides high-level abstractions, &pooma;
   programs are much shorter than corresponding &fortran; or &c;
!  programs and require less time to write and less time to debug.
!  Using these high-level abstractions, the same code runs on a
!  sequential, parallel, and distributed computers.  It runs almost as
!  fast as carefully crafted machine-specific hand-written programs.
!  The &toolkit; is freely available, open-source software compatible
!  with any modern &cc; compiler.&lt;/para&gt;
  
! 
!  &lt;section id=&quot;introduction-goals&quot;&gt;
!   &lt;title&gt;&pooma; Goals&lt;/title&gt;
! 
    &lt;para&gt;The goals for the &poomatoolkit; have remained unchanged
!   since its conception in 1994:
    &lt;orderedlist&gt;
     &lt;listitem&gt;
      &lt;para&gt;Code portability across serial, distributed, and parallel
!     architectures without any change to the source code.&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;Development of reusable, cross-problem-domain components
***************
*** 58,66 ****
      scientific simulation.&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
!     &lt;para&gt;[&toolkitcap;] design and development driven by
!     applications from a diverse set of scientific problem
!     domains.&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;Shorter time from problem inception to working parallel
--- 60,67 ----
      scientific simulation.&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
!     &lt;para&gt;&toolkitcap; design and development driven by applications
!     from a diverse set of scientific problem domains.&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;Shorter time from problem inception to working parallel
***************
*** 68,296 ****
  &lt;!-- FIXME: Add citation to pooma95, p.&nbsp;3 --&gt;
     &lt;/listitem&gt;
    &lt;/orderedlist&gt;
!  &lt;/para&gt;
!  &lt;/formalpara&gt;
  
-  &lt;formalpara&gt;&lt;title&gt;Code Portability for Sequential and Distributed Programs.&lt;/title&gt;
-  &lt;para&gt;&pooma; programs run on sequential, distributed, and parallel
-  computers with no change in source code.  The programmer writes two
-  or three lines specifying how each container's domain should be
-  distributed among available processors.  Using these directives and
-  run-time information about the computer's configuration, the
-  &toolkit; automatically distributes pieces of the container
-  domains, called &lt;firstterm&gt;patch&lt;/firstterm&gt;es, among the available
-  processors.  If a computation needs values from another patch,
-  &pooma; automatically passes the value to the place it is needed.
-  The same program, and even the same executable, works regardless of
-  the number of the available processors and the size of the
-  containers' domains.  A programmer interested in only sequential
-  execution can omit the two or three lines specifying how the
-  domains are to be distributed.&lt;/para&gt;
-  &lt;/formalpara&gt;
- 
-  &lt;figure float=&quot;1&quot; id=&quot;introduction-science_algorithms&quot;&gt;
-   &lt;title&gt;Science, Algorithms, Engineering, and &pooma;&lt;/title&gt;
-   &lt;mediaobject&gt;
-    &lt;imageobject&gt;
-     &lt;imagedata fileref=&quot;figures/introduction.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
-    &lt;/imageobject&gt;
-    &lt;textobject&gt;
-     &lt;phrase&gt;how &pooma; helps translate algorithms into programs&lt;/phrase&gt;
-    &lt;/textobject&gt;
-    &lt;caption&gt;
-     &lt;para&gt;In the translation from theoretical science and math to
-     computational science and math to computer programs, &pooma;
-     containers eases the translation of algorithms to computer
-     programs.&lt;/para&gt;
-    &lt;/caption&gt;
-   &lt;/mediaobject&gt;
-  &lt;/figure&gt;
- 
-  &lt;formalpara&gt;&lt;title&gt;Rapid Application Development.&lt;/title&gt;
-  &lt;para&gt;The &poomatoolkit; is designed to enable rapid development of
-  scientific and distributed applications.  For example, its vector,
-  matrix, and tensor classes model the corresponding mathematical
-  concepts.  Its &array; and &field; classes model the discrete
-  spaces and mathematical arrays frequently found in computational
-  science and math.  See &lt;xref
-  linkend=&quot;introduction-science_algorithms&quot;&gt;&lt;/xref&gt;.  The left column
-  illustrates theoretical science and math, the middle column
-  computational science and math, and the right column computer
-  science implementations.  For example, theoretical physics
-  frequently uses continuous fields in three-dimension space, while
-  algorithms for the corresponding computational physics problem
-  usually uses discrete fields.  &pooma; containers, classes, and
-  functions ease the engineering to map these algorithms to computer
-  programs.  For example, the &pooma; &field; container models
-  discrete fields; both map locations in discrete space to values and
-  permit computations of spatial distances and values.  The &pooma;
-  &array; container models the mathematical concept of an array, used
-  in numerical analysis.&lt;/para&gt;
-  &lt;/formalpara&gt;
- 
-  &lt;para&gt;&pooma; containers support a variety of computation modes,
-  easing transition of algorithms into code.  For example, many
-  algorithms for solving partial differential equations use
-  stencil-based computations.  &pooma; supports stencil-based
-  computations on &array;s and &field;s.  It also supports
-  data-parallel computation.  For computations where one &field;'s
-  values is a function of several other &field;'s values, the
-  programmer can specify a relation.  Relations are lazily evaluated;
-  whenever the dependent &field;'s values are needed and it is
-  related to a &field; whose values have changed, the former
-  &field;'s values are computed.  Lazy evaluation also assists
-  correctness by eliminating the (frequently forgotten) need for a
-  programmer to ensure a &field;'s values are up-to-date before being
-  used.&lt;/para&gt;
- 
-  &lt;formalpara&gt;&lt;title&gt;Efficient Code.&lt;/title&gt;
-  &lt;para&gt;&pooma; incorporates a variety of techniques to ensure it
-  produces code that executes as quickly as special-case,
-  hand-written code.
- &lt;!-- FIXME: Do I present execution numbers here? --&gt;
-  These techniques include extensive use of templates, out-of-order
-  evaluation to permit communication and computation to overlap,
-  availability of guard layers to reduce processors' synchronicity,
-  and use of &pete; to produce fast inner loops.&lt;/para&gt;
-  &lt;/formalpara&gt;
- 
-  &lt;para&gt;Using templates permits the expressiveness of using pointers
-  and function arguments but ensures as much as work as possible
-  occurs at compile time, not run time.  Also, more code is exposed
-  to the compiler's optimizer, further speeding execution.  For
-  example, use of template parameters to define the &pooma; &array;
-  container permits the use of specialized data storage classes
-  called engines, fast creation of views of a portion of an &array;,
-  and polymorphic indexing.  An &array;'s engine template parameter
-  specifies how data is stored and indexed.  Some &array;s expect
-  almost all values to be used, while others might be mostly empty.
-  In the latter case, using a specialized engine storing the few
-  nonzero values would greatly reduce space requirements.  Using
-  engines also permits fast creation of container views, known as
-  &lt;firstterm&gt;array sections&lt;/firstterm&gt; in Fortran&nbsp;90.  A view's
-  engine is the same as the original container's engine, while the
-  view object maps its restricted domain to the original domain.
-  Space requirements and execution time are minimal.  Using templates
-  also permits containers to support polymorphic indexing, e.g.,
-  indexing both by integers and by three-dimensional coordinates.
-  For example, a container defers returning values to its engine
-  using a templatized index operator.  The engine can define indexing
-  functions with different function arguments, without the need to
-  add corresponding container functions.  Some of these features can
-  be expressed without using templates, but doing so increases
-  execution time.  For example, a container could have a pointer to
-  an engine object, but this requires a pointer dereference for each
-  operation.  Implementing polymorphic indexing without templates
-  would require adding virtual function corresponding to each of the
-  indexing functions.&lt;/para&gt;
- 
- &lt;!-- FIXME: Are the claims concerning out-of-order evaluation I make true? --&gt;
- 
-  &lt;para&gt;To ensure multiprocessor &pooma; programs execute quickly, it
-  is important that interprocessor communication overlaps with
-  intraprocessor computation as much as possible and communication is
-  minimized.  Asynchronous communication, out-of-order evaluation, and
-  use of guard layers all help achieve this.  &pooma; uses the
-  asynchronous communication facilities of the &cheetah; communication
-  library.  When a processor needs data stored or computed by another
-  processor, a message is sent between the two.  For synchronous
-  communication, the sender must issue an explicit send, and the
-  recipient must issue an explicit receive.  This synchronizes them.
-  &cheetah; permits the sender to put and get data without the
-  intervention of the remote site and also invoke functions at the
-  remote site to ensure the data is up-to-date.  Thus, out-of-order
-  evaluation must be supported.  Out-of-order evaluation has another
-  benefit: only computations directly or indirectly related to values
-  that are printed need occur.&lt;/para&gt;
- 
-  &lt;para&gt;Using guard layers also helps overlap communication and
-  computation.  For distributed computation, each container's domain is
-  split into pieces distributed among the available processors.
-  Frequently, computing a container value is local, involving just the
-  value itself and a few neighbors.  Computing a value near the edge of
-  a processor's domain may require knowing a few values from a
-  neighboring domain.  Guard layers permit these values to be copied
-  locally so they need not be repeatedly communicated.&lt;/para&gt;
- 
-  &lt;para&gt;&pooma; uses &pete; technology to ensure inner loops using
-  &pooma;'s object-oriented containers run as quickly as hand-coded
-  &lt;!-- FIXME: Add a citation to Dr. Dobb's Journal article
-  pete-99. --&gt; loops.  &pete; (the Portable Expression Template
-  Engine) uses expression-template technology to convert
-  data-parallel statements frequently found in the inner loops of
-  programs into efficient loops without any intermediate
-  computations.  For example, consider evaluating the &lt;statement&gt;A +=
-  -B + 2 * C;&lt;/statement&gt; statement where &lt;varname&gt;A&lt;/varname&gt; and
-  &lt;varname&gt;C&lt;/varname&gt; are &lt;type&gt;vector&lt;double&gt;&lt;/type&gt;s and
-  &lt;varname&gt;B&lt;/varname&gt; is a &lt;type&gt;vector&lt;int&gt;&lt;/type&gt;s.
-  Ordinary evaluation might introduce intermediaries for
-  &lt;statement&gt;-B&lt;/statement&gt;, &lt;statement&gt;2*C&lt;/statement&gt;, and their
-  sum.  The presence of these intermediaries in inner loops can
-  measurably slow evaluation.  To produce a loop without
-  intermediaries, &pete; stores each expression as a parse tree.  The
-  resulting parse trees can be combined into a larger parse tree.
-  Using its templates, the parse tree is converted, at compile time,
-  to an outer loop with contents corresponding to evaluating each
-  component of the result.  Thus, no intermediate values are computed
-  or stored.  For example, the code corresponding to &lt;statement&gt;A +=
-  -B + 2 * C;&lt;/statement&gt; is 
-  &lt;programlisting&gt;
-  vector&lt;double&gt;::iterator iterA = A.begin();
-  vector&lt;int&gt;::const_iterator iterB = B.begin();
-  vector&lt;double&gt;::const_iterator iterC = C.begin();
-  while (iterA != A.end()) {
-    *iterA += -*iterB + 2 * *iterC;
-    ++iterA; ++iterB; ++iterC;
-  }
-  &lt;/programlisting&gt;
-  Furthermore, since the code is available at compile-, not run-, time,
-  it can be further optimized, e.g., moving any loop-invariant code out
-  of the loop.&lt;/para&gt;
- 
-  &lt;formalpara&gt;&lt;title&gt;Used for Diverse Set of Scientific Problems.&lt;/title&gt;
-  &lt;para&gt;&pooma; has been used to solve a wide variety of scientific
-  problems.  Most recently, physicists at Los Alamos National
-  Laboratory implemented an entire library of hydrodynamics codes as
-  part of the U.S. government's Science-based Stockpile Stewardship
-  (&lt;acronym&gt;SBSS&lt;/acronym&gt;) program to simulate nuclear weapons.
-  Other applications include a matrix solver, an accelerator code
-  simulating the dynamics of high-intensity charged particle beams in
-  linear accelerators, and a Monte Carlo neutron transport
-  code.&lt;/para&gt;
-  &lt;/formalpara&gt;
- 
-  &lt;formalpara&gt;&lt;title&gt;Easy Implementation.&lt;/title&gt;
-  &lt;para&gt;&pooma;'s tools greatly reduce the time to implement
-  applications.  As we noted above, &pooma;'s containers and
-  expression syntax model the computational models and algorithms
-  most frequently found in scientific programs.  Using these
-  high-level tools which are known to be correct reduce the time
-  needed to debug programs.  Programmers can write and test programs
-  using their one or two-processor personal computers.  With no
-  additional work, the same program runs on computers with hundreds
-  of processors; the code is exactly the same, and the &toolkit;
-  automatically handles distribution of the data, all data
-  communication, and all synchronization.  Using all these tools
-  greatly reduces programming time.  For example, a team of two
-  physicists and two support people at Los Alamos National Laboratory
-  implemented a suite of hydrodynamics kernels in six months.  Their
-  work replaced the previous suite of less-powerful kernels which had
-  taken sixteen people several years to implement and debug.  Despite
-  not previously implementing any of the kernels, they averaged one
-  new kernel every three days, including the time to read the
-  corresponding scientific papers!&lt;/para&gt;
-  &lt;/formalpara&gt;
  
   &lt;section id=&quot;introduction-pooma_history&quot;&gt;
    &lt;title&gt;History of &pooma;&lt;/title&gt;
  
!   &lt;para&gt;The &poomatoolkit; developed at Los Alamos National
    Laboratory to assist nuclear fusion and fission research.
!   In&nbsp;1994, the &toolkit; grew out of the Object-Oriented
!   Particle Simulation (OOPS) class library developed for
!   particle-in-cell simulations.  The goals of the Framework, as it
!   was called at the time, were driven by the Numerical Tokamak's
!   &lt;quote&gt;Parallel Platform Paradox&lt;/quote&gt;:
    &lt;blockquote&gt;
     &lt;para&gt;The average time required to implement a moderate-sized
     application on a parallel computer architecture is equivalent to
--- 69,335 ----
  &lt;!-- FIXME: Add citation to pooma95, p.&nbsp;3 --&gt;
     &lt;/listitem&gt;
    &lt;/orderedlist&gt;
!   Below, we discuss how &pooma; achieves these goals.
!   &lt;/para&gt;
! 
!   &lt;bridgehead id=&quot;introduction-goals-portability&quot; renderas=&quot;sect2&quot;&gt;Code Portability for Sequential and Distributed Programs&lt;/bridgehead&gt;
! 
!   &lt;para&gt;The same &pooma; programs run on sequential, distributed, and
!   parallel computers.  No change in source code is required.  Two or
!   three lines specifying how each container's domain should be
!   distributed among available processors.  Using these directives and
!   run-time information about the computer's configuration, the
!   &toolkit; automatically distributes pieces of the container domains,
!   called &lt;link
!   linkend=&quot;glossary-patch&quot;&gt;&lt;firstterm&gt;patches&lt;/firstterm&gt;&lt;/link&gt;,
!   among the available processors.  If a computation needs values from
!   another patch, &pooma; automatically passes the value to the patch
!   where it is needed.  The same program, and even the same executable,
!   works regardless of the number of the available processors and the
!   size of the containers' domains.  A programmer interested in only
!   sequential execution can omit the two or three lines specifying how
!   the domains are to be distributed.&lt;/para&gt;
! 
!   &lt;bridgehead id=&quot;introduction-goals-rapid_development&quot; renderas=&quot;sect2&quot;&gt;Rapid Application Development&lt;/bridgehead&gt;
! 
!   &lt;para&gt;The &poomatoolkit; is designed to enable rapid development of
!   scientific and distributed applications.  For example, its vector,
!   matrix, and tensor classes model the corresponding mathematical
!   concepts.  Its &array; and &field; classes model the discrete spaces
!   and mathematical arrays frequently found in computational science and
!   math.  See &lt;xref linkend=&quot;introduction-science_algorithms&quot;&gt;&lt;/xref&gt;.
!   The left column indicates theoretical science and math concepts, the
!   middle column computational science and math concepts, and the right
!   column computer science implementations.  For example, theoretical
!   physics frequently uses continuous fields in three-dimension space,
!   while algorithms for a corresponding computational physics problem
!   usually uses discrete fields.  &pooma; containers, classes, and
!   functions ease engineering computer programs for these algorithms.
!   For example, the &pooma; &field; container models discrete fields;
!   both map locations in discrete space to values and permit
!   computations of spatial distances and values.  The &pooma; &array;
!   container models the mathematical concept of an array, used in
!   numerical analysis.&lt;/para&gt;
! 
!   &lt;figure float=&quot;1&quot; id=&quot;introduction-science_algorithms&quot;&gt;
!    &lt;title&gt;How &pooma; Fits Into the Scientific Process&lt;/title&gt;
!    &lt;mediaobject&gt;
!     &lt;imageobject&gt;
!      &lt;imagedata fileref=&quot;figures/introduction.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!     &lt;/imageobject&gt;
!     &lt;textobject&gt;
!      &lt;phrase&gt;&pooma; helps translate algorithms into programs.&lt;/phrase&gt;
!     &lt;/textobject&gt;
!     &lt;caption&gt;
!      &lt;para&gt;In the translation from theoretical science and math to
!      computational science and math to computer programs, &pooma; eases
!      the implementation of algorithms as computer programs.&lt;/para&gt;
!     &lt;/caption&gt;
!    &lt;/mediaobject&gt;
!   &lt;/figure&gt;
! 
!   &lt;para&gt;&pooma; containers support a variety of computation modes,
!   easing translation of algorithms into code.  For example, many
!   algorithms for solving partial differential equations use
!   stencil-based computations.  &pooma; supports stencil-based
!   computations on &array;s and &field;s.  It also supports
!   data-parallel computation similar to &amp;fortran&nbsp;90 syntax.  For
!   computations where one &field;'s values is a function of several
!   other &field;'s values, the programmer can specify a relation.
!   Relations are lazily evaluated: whenever the dependent &field;'s
!   values are needed and it is dependent on a &field; whose values have
!   changed, its values are computed.  Lazy evaluation also assists
!   correctness by eliminating the frequently forgotten need for a
!   programmer to ensure a &field;'s values are up-to-date before being
!   used.&lt;/para&gt;
! 
!   &lt;bridgehead id=&quot;introduction-goals-efficient&quot; renderas=&quot;sect2&quot;&gt;Efficient Code&lt;/bridgehead&gt;
! 
!   &lt;para&gt;&pooma; incorporates a variety of techniques to ensure it
!   produces code that executes as quickly as special-case,
!   hand-written code.
!  &lt;!-- FIXME: Do I present execution numbers here? --&gt;
!   These techniques include extensive use of templates, out-of-order
!   evaluation, use of guard layers, and production of fast inner loops.&lt;/para&gt;
! 
!   &lt;para&gt;&pooma;'s uses of &cc; templates permits the expressiveness
!   from using pointers and function arguments but ensures as much as
!   work as possible occurs at compile time, not run time.  This speeds
!   programs' execution.  Since more code is produced at compile time,
!   more code is available to the compiler's optimizer, further speeding
!   execution.  The &pooma; &array; container benefits from the use of
!   template parameters.  Their use permits the use of specialized data
!   storage classes called &lt;link
!   linkend=&quot;glossary-engine&quot;&gt;&lt;firstterm&gt;engines&lt;/firstterm&gt;&lt;/link&gt;.  An
!   &array;'s engine template parameter specifies how data is stored and
!   indexed.  Some &array;s expect almost all values to be used, while
!   others might be mostly vacant.  In the latter case, using a
!   specialized engine storing the few nonzero values greatly reduces
!   space requirements.  Using engines also permits fast creation of
!   container views, known as &lt;firstterm&gt;array sections&lt;/firstterm&gt; in
!   Fortran&nbsp;90.  A view's engine is the same as the original
!   container's engine, but the view object maps its restricted domain to
!   the original domain.  Space requirements and execution time to use
!   views are minimal.  Using templates also permits containers to
!   support polymorphic indexing, e.g., indexing both by integers and by
!   three-dimensional coordinates.  A container defers indexing
!   operations to its engine's templatized index operator.  Since it uses
!   templates, the engine can define indexing functions with different
!   function arguments, without the need to add corresponding container
!   functions.  Some of these benefits of using templates can be
!   expressed without them, but doing so increases execution time.  For
!   example, a container could have a pointer to an engine object, but
!   this requires a pointer dereference for each operation.  Implementing
!   polymorphic indexing without templates would require adding virtual
!   functions corresponding to each of the indexing functions.&lt;/para&gt;
! 
!  &lt;!-- FIXME: Are the claims concerning out-of-order evaluation I make true? --&gt;
! 
!   &lt;para&gt;To ensure multiprocessor &pooma; programs execute quickly, it
!   is important that interprocessor communication overlaps with
!   intraprocessor computations as much as possible and that
!   communication is minimized.  Asynchronous communication, out-of-order
!   evaluation, and use of guard layers all help achieve these goals.
!   &pooma; uses the asynchronous communication facilities of the
!   &cheetah; communication library.  When a processor needs data that is
!   stored or computed by another processor, a message is sent between
!   the two.  If synchronous communication was used, the sender must
!   issue an explicit send, and the recipient must issue an explicit
!   receive, synchronizing the two processors.  &cheetah; permits the
!   sender to put and get data without synchronizing with the recipient
!   processor, and it also permits invoking functions at remote sites to
!   ensure desired data is up-to-date.  Thus, out-of-order evaluation
!   must be supported.  Out-of-order evaluation also has another benefit:
!   Only computations directly or indirectly related to values that are
!   printed need occur.&lt;/para&gt;
! 
!   &lt;para&gt;Surrounding a patch with &lt;link
!   linkend=&quot;glossary-guard_layer&quot;&gt;&lt;firstterm&gt;guard
!   layers&lt;/firstterm&gt;&lt;/link&gt; can help reduce interprocessor
!   communication.  For distributed computation, each container's domain
!   is split into pieces distributed among the available processors.
!   Frequently, computing a container value is local, involving just the
!   value itself and a few neighbors, but computing a value near the edge
!   of a processor's domain may require knowing a few values from a
!   neighboring domain.  Guard layers permit these values to be copied
!   locally so they need not be repeatedly communicated.&lt;/para&gt;
! 
!   &lt;para&gt;&pooma; uses &pete; technology to ensure inner loops involving
!   &pooma;'s object-oriented containers run as quickly as hand-coded
!   &lt;!-- FIXME: Add a citation to Dr. Dobb's Journal article pete-99. --&gt;
!   loops.  &pete; (the Portable Expression Template Engine) uses
!   expression-template technology to convert data-parallel statements
!   in the inner loops of programs into efficient loops
!   without any intermediate computations.  For example, consider
!   evaluating the statement
!   &lt;programlisting&gt;
!   A += -B + 2 * C;&lt;/programlisting&gt;
!   where &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;C&lt;/varname&gt; are
!   &lt;type&gt;vector&lt;double&gt;&lt;/type&gt;s and &lt;varname&gt;B&lt;/varname&gt; is a
!   &lt;type&gt;vector&lt;int&gt;&lt;/type&gt;.  Naive evaluation might introduce
!   intermediaries for &lt;statement&gt;-B&lt;/statement&gt;,
!   &lt;statement&gt;2*C&lt;/statement&gt;, and their sum.  The presence of these
!   intermediaries in inner loops can measurably slow evaluation.  To
!   produce a loop without intermediaries, &pete; stores each expression
!   as a parse tree.  The resulting parse trees can be combined into a
!   larger parse tree.  Using its templates, the parse tree is converted,
!   at compile time, to a loop evaluating each component of the result.
!   Thus, no intermediate values are computed or stored.  For example,
!   the code corresponding to the statement above is
!   &lt;programlisting&gt;
!   vector&lt;double&gt;::iterator iterA = A.begin();
!   vector&lt;int&gt;::const_iterator iterB = B.begin();
!   vector&lt;double&gt;::const_iterator iterC = C.begin();
!   while (iterA != A.end()) {
!     *iterA += -*iterB + 2 * *iterC;
!     ++iterA; ++iterB; ++iterC;
!   }&lt;/programlisting&gt;
!   Furthermore, since the code is available at compile, not run, time,
!   it can be further optimized, e.g., moving any loop-invariant code out
!   of the loop.&lt;/para&gt;
! 
!   &lt;bridgehead id=&quot;introduction-goals-scientific&quot; renderas=&quot;sect2&quot;&gt;Used for Diverse Set of Scientific Problems&lt;/bridgehead&gt;
! 
!   &lt;para&gt;&pooma; has been used to solve a wide variety of scientific
!   problems.  Most recently, physicists at Los Alamos National
!   Laboratory implemented an entire library of hydrodynamics codes as
!   part of the U.S. government's science-based Stockpile Stewardship
!   Program to simulate nuclear weapons.  Other applications include a
!   matrix solver, an accelerator code simulating the dynamics of
!   high-intensity charged particle beams in linear accelerators, and a
!   Monte Carlo neutron transport code.&lt;/para&gt;
! 
!   &lt;bridgehead id=&quot;introduction-goals-easy_implementation&quot; renderas=&quot;sect2&quot;&gt;Easy Implementation&lt;/bridgehead&gt;
! 
!   &lt;para&gt;&pooma;'s tools greatly reduce the time to implement
!   applications.  As we noted above, &pooma;'s containers and expression
!   syntax model the computational models and algorithms most frequently
!   found in scientific programs.  These high-level tools are known to be
!   correct and reduce the time to debug programs.  Since the same
!   programs run on one processor and multiple processors, programmers
!   can write and test programs using their one or two-processor personal
!   computers.  With no additional work, the same program runs on
!   computers with hundreds of processors; the code is exactly the same,
!   and the &toolkit; automatically handles distribution of the data, all
!   data communication, and all synchronization.  The net results is a
!   significant reduction in programming time.  For example, a team of
!   two physicists and two support people at Los Alamos National
!   Laboratory implemented a suite of hydrodynamics kernels in six
!   months.  Their work replaced a previous suite of less-powerful
!   kernels which had taken sixteen people several years to implement and
!   debug.  Despite not have previously implemented any of the kernels,
!   they implemented one new kernel every three days, including the time
!   to read the corresponding scientific papers!&lt;/para&gt;
!  &lt;/section&gt;&lt;!-- introduction-goals --&gt;
! 
! 
!  &lt;section id=&quot;introduction-performance&quot;&gt;
!   &lt;title&gt;&pooma; Produces Fast Programs&lt;/title&gt;
! 
!   &lt;para&gt;almost as fast as &c;.  wide variety of configurations: one
!   processor, many processors, give performance data for at least two
!   different programs
! HERE&lt;/para&gt;
! 
!   &lt;para&gt;describe &amp;doof2d; here
! 
!   &amp;doof2d; is a two-dimensional diffusion simulation program.
!   Initially, all values in the square two-dimensional grid are zero
!   except for the central value.  
! 
! HERE&lt;/para&gt;
! 
!  &lt;/section&gt;
! 
! &lt;!-- HERE --&gt;
! 
!  &lt;section id=&quot;introduction-open_source&quot;&gt;
!   &lt;title&gt;&pooma; is Free, Open-Source Software&lt;/title&gt;
! 
!   &lt;para&gt;The &poomatoolkit; is open-source software.  Anyone may
!   download, read, redistribute, and modify the &pooma; source code.
!   If an application requires a specialized container, any programmer
!   may add it.  Any programmer can extend it to solve problems in
!   previously unsupported domains.  Companies using the &toolkit; can
!   read the source code to ensure it has no hidden back doors or
!   security holes.  It may be downloaded for free and used for
!   perpetuity.  There are no annual licenses and no on-going costs.  By
!   keeping their own copies, companies are guaranteed the software will
!   never disappear.  In summary, the &poomatoolkit; is free, low-risk
!   software.&lt;/para&gt;
!  &lt;/section&gt;
  
  
   &lt;section id=&quot;introduction-pooma_history&quot;&gt;
    &lt;title&gt;History of &pooma;&lt;/title&gt;
  
!   &lt;para&gt;The &poomatoolkit; was developed at Los Alamos National
    Laboratory to assist nuclear fusion and fission research.
!   In&nbsp;1994, the &toolkit; grew out of the &lt;application
!   class='software'&gt;Object-Oriented Particle Simulation&lt;/application&gt;
!   class library developed for particle-in-cell simulations.  The goals
!   of the Framework, as it was called at the time, were driven by the
!   Numerical Tokamak's &lt;quote&gt;Parallel Platform Paradox&lt;/quote&gt;:
    &lt;blockquote&gt;
     &lt;para&gt;The average time required to implement a moderate-sized
     application on a parallel computer architecture is equivalent to
***************
*** 298,304 ****
    &lt;/blockquote&gt;
    The framework's goal of being able to quickly write efficient
    scientific code that could be run on a wide variety of platforms
!   remains unchanged today.  Development, driven mainly by the
    Advanced Computing Laboratory at Los Alamos, proceeded rapidly.
    A matrix solver application was written using the framework.
  &lt;!-- FIXME: Add citation to pooma-sc95. --&gt;
--- 337,343 ----
    &lt;/blockquote&gt;
    The framework's goal of being able to quickly write efficient
    scientific code that could be run on a wide variety of platforms
!   remains unchanged today.  Development, mainly at the
    Advanced Computing Laboratory at Los Alamos, proceeded rapidly.
    A matrix solver application was written using the framework.
  &lt;!-- FIXME: Add citation to pooma-sc95. --&gt;
***************
*** 307,321 ****
  
    &lt;para&gt;By&nbsp;1998, &pooma; was part of the U.S. Department of
    Energy's Accelerated Strategic Computing Initiative
!   (&lt;acronym&gt;ASCI&lt;/acronym&gt;).  The Comprehensive Test Ban Treaty
!   forbid nuclear weapons testing so they were instead simulated.
!   &lt;acronym&gt;ASCI&lt;/acronym&gt;'s goal was to radically advance the state
!   of the art in high-performance computing and numerical simulations
!   so the nuclear weapon simulations could use 100-teraflop
!   computers.  A linear accelerator code &lt;application
    class='software'&gt;linac&lt;/application&gt; and a Monte Carlo neutron
!   transport code &lt;application class='software'&gt;MC++&lt;/application&gt;
!   were written.
  &lt;!-- FIXME: Add citation to pooma-siam98. --&gt;
    &lt;/para&gt;
  
--- 346,360 ----
  
    &lt;para&gt;By&nbsp;1998, &pooma; was part of the U.S. Department of
    Energy's Accelerated Strategic Computing Initiative
!   (&lt;acronym&gt;ASCI&lt;/acronym&gt;).  The Comprehensive Test Ban Treaty forbid
!   nuclear weapons testing so they were instead simulated using
!   computers.  &lt;acronym&gt;ASCI&lt;/acronym&gt;'s goal was to radically advance
!   the state of the art in high-performance computing and numerical
!   simulations so the nuclear weapon simulations could use 100-teraflop
!   parallel computers.  A linear accelerator code &lt;application
    class='software'&gt;linac&lt;/application&gt; and a Monte Carlo neutron
!   transport code &lt;application class='software'&gt;MC++&lt;/application&gt; were
!   among the codes written.
  &lt;!-- FIXME: Add citation to pooma-siam98. --&gt;
    &lt;/para&gt;
  
***************
*** 332,348 ****
    engines were added.  Release&nbsp;2.1.0 included &field;s with
    their spatial extent and &dynamicarray;s with the ability to
    dynamically change its domain size.  Support for particles and
!   their interaction with &field;s was added.  The &pooma; messaging
    implementation was revised in release&nbsp;2.3.0.  Use of the
    &cheetah; Library separated &pooma; from the actual messaging
!   library used.  Support for applications running on clusters of
!   computers was added.  During the past two years, the &field;
    abstraction and implementation was improved to increase its
    flexibility, add support for multiple values and materials in the
    same cell, and permit lazy evaluation.  Simultaneously, the
!   execution speed of the inner loops was greatly increased.  The
!   particle code has not yet been ported to the new &field;
!   abstraction.&lt;/para&gt;
   &lt;/section&gt;
  
  &lt;/chapter&gt;
--- 371,389 ----
    engines were added.  Release&nbsp;2.1.0 included &field;s with
    their spatial extent and &dynamicarray;s with the ability to
    dynamically change its domain size.  Support for particles and
!   their interaction with &field;s were added.  The &pooma; messaging
    implementation was revised in release&nbsp;2.3.0.  Use of the
    &cheetah; Library separated &pooma; from the actual messaging
!   library used, and support for applications running on clusters of
!   computers was added.  &lt;ulink
!   url=&quot;<A HREF="http://www.codesourcery.com">http://www.codesourcery.com</A>&quot;&gt;CodeSourcery, LLC&lt;/ulink&gt;, and
!   &lt;ulink url=&quot;www.proximation.com&quot;&gt;Proximation, LLC&lt;/ulink&gt;, took
!   over &pooma; development from Los Alamos National Laboratory.
!   During the past two years, the &field;
    abstraction and implementation was improved to increase its
    flexibility, add support for multiple values and materials in the
    same cell, and permit lazy evaluation.  Simultaneously, the
!   execution speed of the inner loops was greatly increased.&lt;/para&gt;
   &lt;/section&gt;
  
  &lt;/chapter&gt;
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.4
diff -c -p -r1.4 manual.xml
*** manual.xml	2001/12/17 17:27:41	1.4
--- manual.xml	2002/01/04 17:14:10
***************
*** 26,31 ****
--- 26,33 ----
    &lt;!-- Modify this to the desired formatting. --&gt;
  &lt;!ENTITY cheetah &quot;&lt;application class='software'&gt;Cheetah&lt;/application&gt;&quot; &gt;
    &lt;!-- Produce a notation for the Cheetah Library.  --&gt;
+ &lt;!ENTITY closeclose &quot;&gt;&hairsp;&gt;&quot; &gt;
+   &lt;!-- Produce a notation for &quot;&gt;&gt;&quot;, which frequently occurs with templates.  Without this, TeX produces a shift symbol. --&gt;
  &lt;!ENTITY dashdash &quot;-&hairsp;-&quot; &gt;
    &lt;!-- Produce a notation for a double dash.  Without this, TeX produces an en-hyphen. --&gt;
  &lt;!ENTITY doof2d &quot;&lt;command&gt;Doof2d&lt;/command&gt;&quot; &gt;
***************
*** 38,47 ****
    &lt;!-- Produce a notation for the MM Library.  --&gt;
  &lt;!ENTITY mpi &quot;&lt;application class='software'&gt;MPI&lt;/application&gt;&quot;&gt;
    &lt;!-- Produce a notation for the MPI package.  --&gt;
  &lt;!ENTITY pdt &quot;&lt;application class='software'&gt;PDToolkit&lt;/application&gt;&quot;&gt;
    &lt;!-- Produce a notation for the PDT software package.  --&gt;
  &lt;!ENTITY pete &quot;&lt;application class='software'&gt;PETE&lt;/application&gt;&quot;&gt;
!   &lt;!-- Produce a notation for the PETE library.  --&gt;
  &lt;!ENTITY pooma &quot;&lt;application class='software'&gt;POOMA&lt;/application&gt;&quot;&gt;
    &lt;!-- Produce a notation for Pooma software.  --&gt;
  &lt;!ENTITY poomatoolkit &quot;&lt;application class='software'&gt;POOMA &toolkitcap;&lt;/application&gt;&quot;&gt;
--- 40,51 ----
    &lt;!-- Produce a notation for the MM Library.  --&gt;
  &lt;!ENTITY mpi &quot;&lt;application class='software'&gt;MPI&lt;/application&gt;&quot;&gt;
    &lt;!-- Produce a notation for the MPI package.  --&gt;
+ &lt;!ENTITY openopen &quot;&lt;&hairsp;&lt;&quot; &gt;
+   &lt;!-- Produce a notation for &quot;&lt;&lt;&quot;, which frequently occurs with output.  Without this, TeX produces a shift symbol. --&gt;
  &lt;!ENTITY pdt &quot;&lt;application class='software'&gt;PDToolkit&lt;/application&gt;&quot;&gt;
    &lt;!-- Produce a notation for the PDT software package.  --&gt;
  &lt;!ENTITY pete &quot;&lt;application class='software'&gt;PETE&lt;/application&gt;&quot;&gt;
!   &lt;!-- Produce a notation for the PETE framework.  --&gt;
  &lt;!ENTITY pooma &quot;&lt;application class='software'&gt;POOMA&lt;/application&gt;&quot;&gt;
    &lt;!-- Produce a notation for Pooma software.  --&gt;
  &lt;!ENTITY poomatoolkit &quot;&lt;application class='software'&gt;POOMA &toolkitcap;&lt;/application&gt;&quot;&gt;
***************
*** 87,92 ****
--- 91,98 ----
    &lt;!-- The &quot;Field&quot; type. --&gt;
  &lt;!ENTITY inform &quot;&lt;type&gt;Inform&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;Inform&quot; output type. --&gt;
+ &lt;!ENTITY int &quot;&lt;type&gt;int&lt;/type&gt;&quot;&gt;
+   &lt;!-- The C &quot;int&quot; type. --&gt;
  &lt;!ENTITY interval &quot;&lt;type&gt;Interval&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;Interval&quot; type. --&gt;
  &lt;!ENTITY layout &quot;&lt;type&gt;Layout&lt;/type&gt;&quot;&gt;
***************
*** 155,162 ****
--- 161,172 ----
    &lt;!-- spelling: nonzero, not non-zero --&gt;
  
  &lt;!-- External Chapters --&gt;
+ &lt;!ENTITY bibliography-chapter SYSTEM &quot;bibliography.xml&quot;&gt;
+   &lt;!-- bibliography --&gt;
  &lt;!ENTITY concepts-chapter SYSTEM &quot;concepts.xml&quot;&gt;
    &lt;!-- Pooma concepts chapter --&gt;
+ &lt;!ENTITY data-parallel-chapter SYSTEM &quot;data-parallel.xml&quot;&gt;
+   &lt;!-- data-parallel expressions chapter --&gt;
  &lt;!ENTITY glossary-chapter SYSTEM &quot;glossary.xml&quot;&gt;
    &lt;!-- glossary --&gt;
  &lt;!ENTITY introductory-chapter SYSTEM &quot;introduction.xml&quot;&gt;
***************
*** 183,189 ****
  
  &lt;!-- Sequential Programs --&gt;
  &lt;!ENTITY initialize-finalize SYSTEM &quot;./programs/examples/Sequential/initialize-finalize-annotated.cpp&quot;&gt;
!   &lt;!-- illustrate initialize() and finalize() --&gt;
  ]&gt;
  
  &lt;book&gt;
--- 193,205 ----
  
  &lt;!-- Sequential Programs --&gt;
  &lt;!ENTITY initialize-finalize SYSTEM &quot;./programs/examples/Sequential/initialize-finalize-annotated.cpp&quot;&gt;
!   &lt;!-- Illustrate initialize() and finalize(). --&gt;
! 
! &lt;!-- Template Programs --&gt;
! &lt;!ENTITY pairs-untemplated SYSTEM &quot;./programs/examples/Templates/pairs-untemplated-annotated.cpp&quot;&gt;
!   &lt;!-- Illustrate defining classes with pairs of values of the same type. --&gt;
! &lt;!ENTITY pairs-templated SYSTEM &quot;./programs/examples/Templates/pairs-templated-annotated.cpp&quot;&gt;
!   &lt;!-- Illustrate defining a template class with pairs of values of the same type. --&gt;
  ]&gt;
  
  &lt;book&gt;
***************
*** 205,211 ****
    &lt;revhistory&gt;
     &lt;revision&gt;
      &lt;revnumber&gt;0.01&lt;/revnumber&gt;
!     &lt;date&gt;2001 Nov 26&lt;/date&gt;
      &lt;authorinitials&gt;jdo&lt;/authorinitials&gt;
      &lt;revremark&gt;first draft&lt;/revremark&gt;
     &lt;/revision&gt;
--- 221,227 ----
    &lt;revhistory&gt;
     &lt;revision&gt;
      &lt;revnumber&gt;0.01&lt;/revnumber&gt;
!     &lt;date&gt;2001 Dec 18&lt;/date&gt;
      &lt;authorinitials&gt;jdo&lt;/authorinitials&gt;
      &lt;revremark&gt;first draft&lt;/revremark&gt;
     &lt;/revision&gt;
***************
*** 280,292 ****
    &lt;title&gt;Programming with &pooma;&lt;/title&gt;
  
  &lt;!-- FIXME: Add a partintro to the part above? --&gt;
  
!   &amp;introductory-chapter;
  
    &amp;tutorial-chapter;
  
    &amp;concepts-chapter;
  
  
    &lt;chapter id=&quot;sequential&quot;&gt;
     &lt;title&gt;Writing Sequential Programs&lt;/title&gt;
--- 296,1819 ----
    &lt;title&gt;Programming with &pooma;&lt;/title&gt;
  
  &lt;!-- FIXME: Add a partintro to the part above? --&gt;
+ 
+   &amp;introductory-chapter; 
+ 
+ 
+   &lt;chapter id=&quot;template_programming&quot;&gt;
+    &lt;title&gt;Programming with Templates&lt;/title&gt;
+ 
+    &lt;para&gt;&pooma; extensively uses &cc; templates to support type
+    polymorphism without any run-time cost.  In this chapter, we
+    briefly introduce using templates in &cc; programs by relating them
+    to &lt;quote&gt;ordinary&lt;/quote&gt; &cc; constructs such as values, objects,
+    and classes.  The two main concepts underlying &cc; templates will
+    occur repeatedly:
+    &lt;itemizedlist&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;Template programming occurs at compile time, not run
+      time.  That is, template operations occur inside the compiler,
+      not when a program runs.&lt;/para&gt;
+     &lt;/listitem&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;Templates permit declaring families of classes with a
+      single declaration.  For example, the &array; template
+      declaration permits using arrays with many different element
+      types, e.g., arrays of integers, arrays of floating point
+      numbers, and arrays of arrays.&lt;/para&gt;
+     &lt;/listitem&gt;
+    &lt;/itemizedlist&gt;
+    For those interested in the implementation of &pooma;, we close
+    with a discussion of some template programming concepts used in the
+    implementation but not likely to be used by &pooma; users.&lt;/para&gt;
+ 
+    &lt;section id=&quot;template_programming-compile_time&quot;&gt;
+     &lt;title&gt;Templates Occur at Compile-Time&lt;/title&gt;
+ 
+     &lt;para&gt;&pooma; uses templates to support type polymorphism without
+     incurring any run-time cost as a program executes.  All template
+     operations are performed at compile time by the compiler.&lt;/para&gt;
+ 
+     &lt;para&gt;Prior to the introduction of templates, almost all a
+     program's interesting computation occurred when it was executed.
+     When writing the program, the programmer, at &lt;glossterm
+     linkend=&quot;glossary-programming_time&quot;&gt;&lt;firstterm&gt;programming
+     time&lt;/firstterm&gt;&lt;/glossterm&gt;, would specify which statements and
+     expressions would occur and which types to use.  At &lt;glossterm
+     linkend=&quot;glossary-compile_time&quot;&gt;&lt;firstterm&gt;compile
+     time&lt;/firstterm&gt;&lt;/glossterm&gt;, the compiler converts the program's
+     source code into an executable program.  Even though the compiler
+     uses the types to produce the executable, no interesting
+     computation occurs.  At &lt;glossterm
+     linkend=&quot;glossary-run_time&quot;&gt;&lt;firstterm&gt;run
+     time&lt;/firstterm&gt;&lt;/glossterm&gt;, the resulting executable program
+     actually performs the operations.&lt;/para&gt;
+ 
+     &lt;para&gt;The introduction of templates permits interesting
+     computation to occur while the compiler produces the executable.
+     Most interesting is template instantiation, which produces a type
+     at compile time.  For example, the &array; &lt;quote&gt;type&lt;/quote&gt;
+     definition requires template parameters &lt;varname&gt;Dim&lt;/varname&gt;,
+     &lt;varname&gt;T&lt;/varname&gt;, and &lt;varname&gt;EngineTag&lt;/varname&gt;, specifying
+     its dimension, the type of its elements, and its engine type.  To
+     use this, a programmer specifies values for the template
+     parameters:
+     &lt;statement&gt;&lt;type&gt;Array&lt;2,double,Brick&gt;&lt;/type&gt;&lt;/statement&gt;.
+     At compile time, the compiler creates a type definition by
+     substituting the values for the template parameters in the
+     template definition.  The substitution is analogous to the
+     run-time application of a function to specific values.&lt;/para&gt;
+ 
+     &lt;para&gt;All computation not involving run-time input or output can
+     occur at program time, compile time, or run time, whichever is
+     more convenient.  At program time, a programmer can perform
+     computations by hand rather than writing code to compute it.  &cc;
+     templates are Turing-complete so they can compute anything.
+     Unfortunately, syntax for compile-time computation is more
+     difficult than for run-time computation, and also current compiler
+     are not as efficient as executables.  Run-time &cc; constructs are
+     Turing-complete so using templates is unnecessary.  Thus, we shift
+     computation to the time which best trades off the ease of
+     expressing syntax with the speed of computation by programmer,
+     compiler, or computer chip.  For example, &pooma; uses expression
+     template technology to speed run-time execution of data-parallel
+     statements.  The &pooma; developers decided to shift some of the
+     computation from run-time to compile-time using template
+     computations.  The resulting run-time code runs more quickly, but
+     compiling the code takes longer.  Also, programming time for the
+     &pooma; developers increased significantly, but, since most users
+     are most concerned about decreasing run times, they made this
+     choice.&lt;/para&gt;
+ 
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;template_programming-template_use&quot;&gt;
+     &lt;title&gt;Template Programming for &pooma; Users&lt;/title&gt;
+ 
+     &lt;para&gt;Most &pooma; users need only understand a subset of
+     available tools for template programming.  These tools include
+     &lt;itemizedlist&gt;
+       &lt;listitem&gt;
+        &lt;para&gt;reading template declarations and understanding template
+        parameters, which are used in this book.&lt;/para&gt;
+       &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;template instantiation, specifying a particular type by
+       specifying values for template parameters.&lt;/para&gt;
+      &lt;/listitem&gt;
+       &lt;listitem&gt;
+        &lt;para&gt;nested type names, which are types specified within a
+        class definition.&lt;/para&gt;
+       &lt;/listitem&gt;
+     &lt;/itemizedlist&gt;
+     We discuss these below.&lt;/para&gt;
  
!     &lt;example id=&quot;template_programming-template_use-untemplated_pair_example&quot;&gt;
!      &lt;title&gt;Classes Storing Pairs of Values&lt;/title&gt;
! &amp;pairs-untemplated;
!     &lt;/example&gt;
! 
!     &lt;para&gt;Templates generalize writing class declarations by
!     permitting class declarations dependent on other types.  For
!     example, consider writing a class storing a pair of integers and a
!     class storing a pair of doubles.  See &lt;xref
!     linkend=&quot;template_programming-template_use-untemplated_pair_example&quot;&gt;&lt;/xref&gt;.
!     Almost all of the code for the two definitions is the same.  Both
!     of these definitions define a class with a constructor and storing
!     two values named &lt;varname&gt;left&lt;/varname&gt; and
!     &lt;varname&gt;right&lt;/varname&gt; having the same type.  Only the classes'
!     names and its use of types differ.&lt;/para&gt;
! 
!     &lt;example id=&quot;template_programming-template_use-templated_pair_example&quot;&gt;
!      &lt;title&gt;Templated Class Storing Pairs of Values&lt;/title&gt;
! &amp;pairs-templated;
!      &lt;calloutlist&gt;
!       &lt;callout
!        arearefs=&quot;template_programming-template_use-templated_pair_program-template_declaration&quot;&gt;
!        &lt;para&gt;Template parameters are written before, not after, a
!        class name.&lt;/para&gt;
!       &lt;/callout&gt;
!       &lt;callout
!        arearefs=&quot;template_programming-template_use-templated_pair_program-constructor&quot;&gt;
!        &lt;para&gt;The constructor has two parameters with the type&nbsp;&lt;varname&gt;T&lt;/varname&gt;.&lt;/para&gt;
!       &lt;/callout&gt;
!       &lt;callout
!        arearefs=&quot;template_programming-template_use-templated_pair_program-members&quot;&gt;
!        &lt;para&gt;An object stores two values having type&nbsp;&lt;varname&gt;T&lt;/varname&gt;.&lt;/para&gt;
!       &lt;/callout&gt;
!       &lt;callout
!        arearefs=&quot;template_programming-template_use-templated_pair_program-use&quot;&gt;
!        &lt;para&gt;To use a templated class, specify the template
!        parameter's argument after the class's name and surrounded by
!        angle brackets&nbsp;(&lt;statement&gt;&lt;&gt;&lt;/statement&gt;).&lt;/para&gt;
!       &lt;/callout&gt;
!      &lt;/calloutlist&gt;
!     &lt;/example&gt;
! 
!     &lt;para&gt;Using templates, we can use a template parameter to
!     represent their different uses of types and write one templated
!     class definition.  See &lt;xref
!     linkend=&quot;template_programming-template_use-templated_pair_example&quot;&gt;&lt;/xref&gt;.
!     The templated class definition is a copy of the common portions of
!     the two preceding definitions.  Because the two definitions differ
!     only in their use of the &int; and &double; types, we replace
!     these concrete types with a template
!     parameter&nbsp;&lt;varname&gt;T&lt;/varname&gt;.  We
!     &lt;emphasis&gt;precede&lt;/emphasis&gt;, not follow, the class definition
!     with &lt;statement&gt;template &lt;typename T&gt;&lt;/statement&gt;.  The
!     constructor's parameters' types are changed
!     to&nbsp;&lt;varname&gt;T&lt;/varname&gt; as are the data members'
!     types.&lt;/para&gt;
! 
!     &lt;para&gt;To use a template class definition, template arguments
!     follow the class name surrounded by angle
!     brackets&nbsp;(&lt;statement&gt;&lt;&gt;&lt;/statement&gt;).  For example,
!     &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; &lt;glossterm
!     linkend=&quot;glossary-template_instantiation&quot;&gt;&lt;firstterm&gt;instantiates&lt;/firstterm&gt;&lt;/glossterm&gt;
!     &lt;classname&gt;pair&lt;/classname&gt; template class definition with
!     &lt;varname&gt;T&lt;/varname&gt; equal to &int;.  That is, the compiler
!     creates a definition for &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; by copying
!     &lt;classname&gt;pair&lt;/classname&gt;'s template definition and substituting
!     &int; for each occurrence of&nbsp;&lt;varname&gt;T&lt;/varname&gt;.  The copy
!     omits the template parameter declaration &lt;statement&gt;template
!     &lt;typename T&gt;&lt;/statement&gt; at the beginning of its definition.
!     The result is a definition exactly the same as
!     &lt;classname&gt;pairOfInts&lt;/classname&gt;.&lt;/para&gt;
  
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+      orient=&quot;port&quot; pgwide=&quot;0&quot;
+      id=&quot;template_programming-template_use-correspondence_table&quot;&gt;
+      &lt;title&gt;Correspondences Between Run-Time and Compile-Time
+      Programming Constructs&lt;/title&gt;
+      
+      &lt;tgroup cols=&quot;3&quot; align=&quot;left&quot;&gt;
+       &lt;thead&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;run time&lt;/entry&gt;
+ 	&lt;entry&gt;compile time&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/thead&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;values&lt;/entry&gt;
+ 	&lt;entry&gt;integers, strings, objects, functions, &hellip;&lt;/entry&gt;
+ 	&lt;entry&gt;types, &hellip;&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;create a value to store multiple values&lt;/entry&gt;
+ 	&lt;entry&gt;object creation&lt;/entry&gt;
+ 	&lt;entry&gt;class definition&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;values stored in a collection&lt;/entry&gt;
+ 	&lt;entry&gt;data member, member function&lt;/entry&gt;
+ 	&lt;entry&gt;nested type name, nested class, static member function,
+ 	constant integral values&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;placeholder for &lt;quote&gt;any particular value&lt;/quote&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;variable, e.g., &lt;quote&gt;any int&lt;/quote&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;template argument, e.g., &lt;quote&gt;any type&lt;/quote&gt;&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;repeated operations&lt;/entry&gt;
+ 	&lt;entry&gt;A function generalizes a particular operation applied to
+ 	different values.  The function parameters are placeholders
+ 	for particular values.&lt;/entry&gt;
+ 	&lt;entry&gt;A template class generalizes a particular class
+ 	definition using different types.  The template parameters are
+ 	placeholders for particular values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;application&lt;/entry&gt;
+ 	&lt;entry&gt;Use a function by appending function arguments
+ 	surrounded by parentheses.&lt;/entry&gt;
+ 	&lt;entry&gt;Use a template class by appending template arguments
+ 	surrounded by angle brackets&nbsp;(&lt;&gt;).&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/table&gt;
+ 
+     &lt;para&gt;As we mentioned above, template instantiation is analogous
+     to function application.  A template class is analogous to a
+     function.  The analogy between compile-time and run-time
+     programming constructs can be extended.  At run time, values used
+     consist of things such as integers, floating point numbers,
+     pointers, functions, and objects.  Programs compute by operating
+     on these values at run time.  At compile time, the values used
+     include types.  Compile-time operations use these types.  &cc;
+     defines default sets of values that all conforming compilers must
+     support.  Object creation extends the set of run-time values,
+     while a class definition extends the set of compile-time types.&lt;/para&gt;
+ 
+     &lt;para&gt;Functions generalize similar run-time operations, while
+     template class generalize similar class definitions.  A function
+     definition generalizes a similar run-time operation.  For
+     example, consider repeatedly printing the largest of two numbers:
+ &lt;programlisting&gt;
+ std::cout &lt;&lt; (3 &gt; 4 ? 3 : 4) &lt;&lt; std::endl;
+ std::cout &lt;&lt; (4 &gt; -13 ? 4 : -13) &lt;&lt; std::endl;
+ std::cout &lt;&lt; (23 &gt; 4 ? 23 : 4) &lt;&lt; std::endl;
+ std::cout &lt;&lt; (0 &gt; 3 ? 0 : 3) &lt;&lt; std::endl;
+ &lt;/programlisting&gt;  Each statement is exactly the same except for its
+ two values.  Thus, we can generalize these statements writing a function.
+ &lt;programlisting&gt;
+ void maxOut(int a, int b)
+ { std::cout &openopen; (a &gt; b ? a : b) &openopen; std::endl; }
+ &lt;/programlisting&gt;  The function's body consists of a statement with
+ variables substituted for the two particular values.  Each parameter
+ is a placeholder that, when used, holds one particular value among the
+ set of possible integral values.  The function must be named to permit
+ its use, and declarations for its two parameters follow.  Using the
+ function simplifies the code:
+ &lt;programlisting&gt;
+ maxOut(3, 4);
+ maxOut(4, -13);
+ maxOut(23, 4);
+ maxOut(0, 3);
+ &lt;/programlisting&gt;  To use a function, the function's name precedes
+     parentheses surrounding specific values for its parameters.  The
+     function's return value does not appear.&lt;/para&gt;
+ 
+     &lt;para&gt;A template class definition generalizes similar class
+     definitions.  If two class definitions differ only in a few types,
+     template parameters can be substituted.  Each parameter is a
+     placeholder that, when used, holds one particular value, i.e.,
+     type, among the set of possible values.  The class definition is
+     named to permit its use, and declarations for its parameters
+     precede it.  The example found in the previous section illustrates
+     this transformation.  Compare the original, untemplated classes in
+     &lt;xref
+     linkend=&quot;template_programming-template_use-untemplated_pair_example&quot;&gt;&lt;/xref&gt;
+     with the templated class in &lt;xref
+     linkend=&quot;template_programming-template_use-templated_pair_example&quot;&gt;&lt;/xref&gt;.
+     Note the notation for the template class parameters.
+     &lt;statement&gt;template &lt;typename T&gt;&lt;/statement&gt;
+     &lt;emphasis&gt;precedes&lt;/emphasis&gt; the class definition.  The keyword
+     &lt;keywordname&gt;typename&lt;/keywordname&gt; indicates the template
+     parameter is a type.  &lt;varname&gt;T&lt;/varname&gt;&nbsp;is the template
+     parameter's name.  Note that using
+     &lt;keywordname&gt;class&lt;/keywordname&gt; is equivalent to using
+     &lt;keywordname&gt;typename&lt;/keywordname&gt; so &lt;statement&gt;template
+     &lt;class T&gt;&lt;/statement&gt; is equivalent to &lt;statement&gt;template
+     &lt;typename T&gt;&lt;/statement&gt;.  Using a templated class requires
+     postfix, not prefix, notation.  The class's name precedes angle
+     brackets&nbsp;(&lt;&gt;) surrounding specific values (types) for
+     its parameters.  As we showed above,
+     &lt;statement&gt;pair&lt;int&gt;&lt;/statement&gt; &lt;glossterm
+     linkend=&quot;glossary-template_instantiation&quot;&gt;instantiates&lt;/glossterm&gt;
+     the template class &lt;classname&gt;pair&lt;/classname&gt; with &int; for its
+     type parameter&nbsp;&lt;varname&gt;T&lt;/varname&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;In template programming, nested type names store
+     compile-time data that can be used within template classes.  Since
+     compile-time class definitions are analogous to run-time objects
+     and the latter stores named values, nested type names are values,
+     i.e., types, stores within class definitions.  For example, the
+     template class &array; has an nested type name for the type of its
+     domain:
+ &lt;programlisting&gt;
+ typedef typename Engine_t::Domain_t Domain_t;
+ &lt;/programlisting&gt; This &lt;keywordname&gt;typedef&lt;/keywordname&gt;, i.e., type
+     definition, defines the type &lt;type&gt;Domain_t&lt;/type&gt; as equivalent
+     to &lt;type&gt;Engine_t::Domain_t&lt;/type&gt;.  The &lt;statement&gt;::&lt;/statement&gt;
+     operator selects the &lt;type&gt;Domain_t&lt;/type&gt; nested type from inside
+     the &lt;type&gt;Engine_t&lt;/type&gt; type.  This illustrates how to access
+     &array;'s &lt;type&gt;Domain_t&lt;/type&gt; when not within &array;'s scope:
+     &lt;type&gt;Array&lt;Dim, T, EngineTag&gt;::Domain_t&lt;/type&gt;.  The
+     analogy between object members and nested type names alludes to
+     its usefulness.  Just as run-time object members store information
+     for later use, nested type names store type information for later
+     use at compile time.  Using nested type names has no impact on the
+     speed of executing programs.&lt;/para&gt;
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;template_programming-pooma_implementation&quot;&gt;
+     &lt;title&gt;Template Programming Used to Write &pooma;&lt;/title&gt;
+ 
+     &lt;para&gt;The preceding section presented template programming tools
+     needed to read this &book; and write programs using the
+     &poomatoolkit;.  In this section, we present template programming
+     techniques used to implement &pooma;.  We extend the
+     correspondence between compile-time template programming
+     constructs and run-time constructs.  Reading this section is not
+     necessary unless you wish to understand how &pooma; works.&lt;/para&gt;
+ 
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+      orient=&quot;port&quot; pgwide=&quot;0&quot;
+      id=&quot;template_programming-pooma_implementation-correspondence_table&quot;&gt;
+      &lt;title&gt;More Correspondences Between Compile-Time and Run-Time
+      Programming Constructs&lt;/title&gt;
+      
+      &lt;tgroup cols=&quot;3&quot; align=&quot;left&quot;&gt;
+       &lt;thead&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;run time&lt;/entry&gt;
+ 	&lt;entry&gt;compile time&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/thead&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;values&lt;/entry&gt;
+ 	&lt;entry&gt;integers, strings, objects, functions, &hellip;&lt;/entry&gt;
+ 	&lt;entry&gt;types, constant integers and enumerations, &hellip;&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;control flow to choose among operations&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;keywordname&gt;if&lt;/keywordname&gt;, &lt;keywordname&gt;while&lt;/keywordname&gt;, &lt;keywordname&gt;goto&lt;/keywordname&gt;, &hellip;&lt;/entry&gt;
+ 	&lt;entry&gt;template class specializations with pattern matching&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;values stored in a collection&lt;/entry&gt;
+ 	&lt;entry&gt;An object stores values.&lt;/entry&gt;
+ 	&lt;entry&gt;A &lt;glossterm linkend=&quot;glossary-traits_class&quot;&gt;traits
+ 	class&lt;/glossterm&gt; contains values describing a type.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/table&gt;
+ 
+ 
+     &lt;para&gt;
+ 
+ HERE&lt;/para&gt;
+    &lt;/section&gt;
+ 
+ &lt;!-- HERE --&gt;
+ 
+   &lt;/chapter&gt;
+ 
+ 
    &amp;tutorial-chapter;
  
    &amp;concepts-chapter;
  
+   &lt;!-- FIXME: Revert to &amp;data-parallel-chapter; --&gt;
+ 
+   &lt;chapter id=&quot;data_parallel&quot;&gt;
+    &lt;title&gt;Data-Parallel Expressions&lt;/title&gt;
+ 
+    &lt;para&gt;In the previous sections, we accessed container values one at
+    a time.  Accessing more than one value in a container required a
+    writing an explicit loop.  Scientists and engineers commonly
+    operate on sets of values, treated as an aggregate.  For example, a
+    vector is a one-dimension collection of data and two vectors can be
+    added together.  A matrix is a two-dimensional collection of data,
+    and a scalar and a matrix are multiplied.  A &lt;glossterm
+    linkend=&quot;glossary-data_parallel&quot;&gt;&lt;firstterm&gt;data-parallel
+    expression&lt;/firstterm&gt;&lt;/glossterm&gt; simultaneously uses multiple
+    container values.  &pooma; supports data-parallel syntax.&lt;/para&gt;
+ 
+    &lt;para&gt;After introducing data-parallel expressions and statements,
+    we present the corresponding &pooma; syntax.  Then we present its
+    implementation, which uses expression-template technology.  A naive
+    data-parallel implementation might generate temporary variables,
+    cluttering a program's inner loops and slowing its execution.
+    Instead, &pooma; uses &amp;pete, the Portable Expression Template
+    Engine.  Using expression templates, it constructs a parse tree of
+    expressions and corresponding types, which is then quickly
+    evaluated without the need for temporary variables.&lt;/para&gt;
+ 
+ 
+    &lt;section id=&quot;data_parallel-multiple_values&quot;&gt;
+     &lt;title&gt;Expressions with More Than One Container Value&lt;/title&gt;
+ 
+     &lt;para&gt;Science and math is filled with aggregated values.  A vector
+     contains several components, and a matrix is a two-dimensional
+     object.  Operations on individual values are frequently extended
+     to operations on these aggregated values.  For example, two
+     vectors having the same length are added by adding corresponding
+     components.  The product of two matrices is defined in terms of
+     sums and products on its components.  The sine of an array is an
+     array containing the sine of every value in it.&lt;/para&gt;
+ 
+     &lt;para&gt;A &lt;glossterm
+     linkend=&quot;glossary-data_parallel&quot;&gt;&lt;firstterm&gt;data-parallel
+     expression&lt;/firstterm&gt;&lt;/glossterm&gt; simultaneously refers to
+     multiple container values.  Data-parallel statements, i.e.,
+     statements using data-parallel expressions, frequently occur in
+     scientific programs.  For example, the sum of two vectors v and w
+     is written as v+w.  Algorithms frequently use data-parallel
+     syntax.  Consider, for example, computing the total energy&nbsp;E
+     as the sum of kinetic energy&nbsp;K and potential energy&nbsp;U.
+     For a simple particle subject to the earth's gravity, the kinetic
+     energy&nbsp;K equals mv&lt;superscript&gt;2&lt;/superscript&gt;/2, and the
+     potential energy&nbsp;U equals mgh.  These formulae apply to both
+     an individual particle with a particular mass&nbsp;m and
+     height&nbsp;h and to an entire field of particles with
+     masses&nbsp;m and heights&nbsp;h.  Our algorithm works with
+     data-parallel syntax, and we would like to write the corresponding
+     computer program using data-parallel syntax as well..&lt;/para&gt;
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;data_parallel-use&quot;&gt;
+     &lt;title&gt;Their Use&lt;/title&gt;
+ 
+     &lt;para&gt;&pooma; containers can be used in data-parallel expressions
+     and statements.  The basic guidelines are simple:
+     &lt;itemizedlist&gt;
+      &lt;listitem&gt;
+        &lt;para&gt;The &cc; built-in and mathematical operators operate on
+        an entire container by operating element-wise on its values.&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;Binary operators operate only on containers with the same
+       domain types by combining values with the same indices.  If the
+       result is a container, it has a domain equal to the left operand's
+       domain.&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;For assignment operators, the domains of the left
+       operand and the right operand must have the same type and
+       be conformable, i.e., have the &lt;quote&gt;same shape&lt;/quote&gt;.&lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/itemizedlist&gt;
+     &lt;/para&gt;
+ 
+     &lt;para&gt;The operators operate element-wise on containers' values.
+     For example, if &lt;varname&gt;A&lt;/varname&gt; is a one-dimensional array,
+     &lt;statement&gt;-&lt;varname&gt;A&lt;/varname&gt;&lt;/statement&gt; is a one-dimensional
+     array with the same size such that the value at the
+     i&lt;superscript&gt;th&lt;/superscript&gt; position equals -A(i).  If
+     &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;B&lt;/varname&gt; are two-dimensional
+     &array;s on the same domain,
+     &lt;statement&gt;&lt;varname&gt;A&lt;/varname&gt;+&lt;varname&gt;B&lt;/varname&gt;&lt;/statement&gt;
+     is an array on the same domain with values equaling the sum of
+     corresponding values in &lt;varname&gt;A&lt;/varname&gt; and
+     &lt;varname&gt;B&lt;/varname&gt;.&lt;/para&gt;
+ 
+     &lt;figure float=&quot;1&quot; id=&quot;data_parallel-use-addition_example&quot;&gt;
+      &lt;title&gt;Adding &array;s with Different Domains&lt;/title&gt;
+      &lt;mediaobject&gt;
+       &lt;imageobject&gt;
+        &lt;imagedata fileref=&quot;figures/data-parallel.212&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+       &lt;/imageobject&gt;
+       &lt;textobject&gt;
+        &lt;phrase&gt;Adding two arrays with different domains adds values
+        with the same indices.&lt;/phrase&gt;
+       &lt;/textobject&gt;
+       &lt;caption&gt;
+        &lt;para&gt;Adding &array;s with different domains is supported.
+        Solid lines indicate the domains' extent.  Values with the same
+        indices are added.&lt;/para&gt;
+       &lt;/caption&gt;
+      &lt;/mediaobject&gt;
+     &lt;/figure&gt;
+ 
+     &lt;para&gt;Binary operators operate on containers with the same domain
+     types.  The domain's indices need not be the same, but the result
+     will have a domain equal to the left operand.  For example, the
+     sum of an &array;&nbsp;&lt;varname&gt;A&lt;/varname&gt; with a one-dimensional
+     interval&nbsp;[0,3] and an &array;&nbsp;&lt;varname&gt;B&lt;/varname&gt; with
+     a one-dimensional interval&nbsp;[1,2] is well-defined because both
+     domains are one-dimensional intervals.  The result is an &array;
+     with a one-dimensional interval&nbsp;[0,3].  Its first and last
+     entries equal &lt;varname&gt;A&lt;/varname&gt;'s first and last entries, while
+     its middle two entries are the sums
+     &lt;statement&gt;A(1)+B(1)&lt;/statement&gt; and
+     &lt;statement&gt;A(2)+B(2)&lt;/statement&gt;.  We assume zero is the
+     default value for the type of values stored
+     in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.  A more complicated example of
+     adding two &array;s with different domains is illustrated in &lt;xref
+     linkend=&quot;data_parallel-use-addition_example&quot;&gt;&lt;/xref&gt;.  Code for
+     these &array;s could be
+ &lt;programlisting&gt;
+ Interval&lt;1&gt; H(0,2), I(1,3), J(2,4);
+ Array&lt;2, double, Brick&gt; A(I,I), B(J,H);
+ // ... fill A and B with values ...
+ ... = A + B;
+ &lt;/programlisting&gt;Both &lt;varname&gt;A&lt;/varname&gt; and
+     &lt;varname&gt;B&lt;/varname&gt; have domains of two-dimensional intervals so
+     they may be added, but their domains' extent differ, as indicated
+     by the solid lines in the figure.  The sum has domain equal to the
+     left operand's domain.  Values with the same indices are added.  For
+     example, &lt;statement&gt;A(2,2)&lt;/statement&gt; and
+     &lt;statement&gt;B(2,2)&lt;/statement&gt; are added.  &lt;varname&gt;B&lt;/varname&gt;'s
+     domain does not include index (1,1) so, when adding
+     &lt;statement&gt;A(1,1)&lt;/statement&gt; and &lt;statement&gt;B(1,1)&lt;/statement&gt;,
+     the default value for &lt;varname&gt;B&lt;/varname&gt;'s value type is used.
+     Usually this is&nbsp;0.  Thus, &lt;statement&gt;A(1,1) +
+     B(1,1)&lt;/statement&gt; equals &lt;statement&gt;9 + 0&lt;/statement&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;Operations with &array;s and scalar values are supported.
+     Conceptually, a scalar value can be thought of as an &array; with
+     any desired domain and having the same value everywhere.  For
+     example, consider
+ &lt;programlisting&gt;
+ Array&lt;1, double, Brick&gt; D(Interval&lt;1&gt;(7,10));
+ D += 2*D + 7;
+ &lt;/programlisting&gt;&lt;statement&gt;2*D&lt;/statement&gt; obeys the guidelines
+     because the scalar &lt;statement&gt;2&lt;/statement&gt; can be thought of as
+     an array with the same domain as &lt;varname&gt;D&lt;/varname&gt;.  It has the
+     same value &lt;statement&gt;2&lt;/statement&gt; everywhere.  Likewise the
+     conceptual domain for the scalar &lt;statement&gt;7&lt;/statement&gt; is the
+     same as &lt;statement&gt;2*D&lt;/statement&gt;'s domain.  Thus,
+     &lt;statement&gt;2*D(i) + 7&lt;/statement&gt; is added to
+     &lt;statement&gt;D(i)&lt;/statement&gt; wherever index&nbsp;i is in
+     &lt;varname&gt;D&lt;/varname&gt;'s domain.  In practice, the &toolkit; does
+     not first convert scalar values to arrays but instead uses them
+     directly in expressions.&lt;/para&gt;
+ 
+     &lt;para&gt;Assignment to containers is also supported.  The domain
+     types of the assignment's left-hand side and its right-hand side
+     must be the same.  Their indices need not be the same, but they
+     must correspond.  That is, the domains must be &lt;glossterm
+     linkend=&quot;glossary-conformable_domains&quot;&gt;&lt;firstterm&gt;conformable
+     domains&lt;/firstterm&gt;&lt;/glossterm&gt;, or have the &lt;quote&gt;same
+     shape&lt;/quote&gt;, i.e., have the same number of indices for each
+     dimension.  For example, the one-dimensional interval [0,3] is
+     conformable to the one-dimensional interval [1,4] because they
+     both have the same number of indices in each dimension.  The
+     domains of &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;B&lt;/varname&gt;, as
+     declared
+ &lt;programlisting&gt;
+ Interval&lt;1&gt; H(0,2), I(1,3), J(2,4), K(0,4);
+ Array&lt;2, double, Brick&gt; A(I,I), B(H,J), C(I,K);
+ &lt;/programlisting&gt; are conformable because each dimension has the same
+     number of indices.  &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;C&lt;/varname&gt;
+     are not conformable because, while their first dimensions are
+     conformable, their second dimensions are not conformable.  It has
+     three indices while the other has four.  We define &lt;glossterm
+     linkend=&quot;glossary-conformable_containers&quot;&gt;&lt;firstterm&gt;conformable
+     containers&lt;/firstterm&gt;&lt;/glossterm&gt; to be containers with
+     conformable domains.&lt;/para&gt;
+ 
+     &lt;para&gt;When assigning to a container, corresponding container
+     values are assigned.  (Since the left-hand side and the right-hand
+     side are conformable, corresponding values exist.)  In this code
+     fragment,
+ &lt;programlisting&gt;
+ Array&lt;1, double, Brick&gt; A(Interval&lt;1&gt;(0,1));
+ Array&lt;1, double, Brick&gt; B(Interval&lt;1&gt;(1,2));
+ A = B;
+ &lt;/programlisting&gt; &lt;statement&gt;A(0)&lt;/statement&gt; is assigned
+     &lt;statement&gt;B(1)&lt;/statement&gt; and &lt;statement&gt;A(1)&lt;/statement&gt; is
+     assigned &lt;statement&gt;B(2)&lt;/statement&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;Assigning a scalar value to an &array; also is supported,
+     but assigning an &array; to a scalar is not.  A scalar value is
+     conformable to any domain because, conceptually it can be viewed
+     as an &array; with any desired domain and having the same value
+     everywhere.  Thus, the assignment &lt;statement&gt;B = 3&lt;/statement&gt;
+     ensures every value in &lt;varname&gt;B&lt;/varname&gt; equals&nbsp;3.  Even
+     though a scalar value is conformable to any &array;, it is not an
+     l-value so it cannot appear on the left-hand side of an
+     assignment.&lt;/para&gt;
+ 
+     &lt;para&gt;Data-parallel expressions can involve typical mathematical
+     functions and output operations.  For example,
+     &lt;statement&gt;sin(A)&lt;/statement&gt; yields an &array; with values equal
+     to the sine of each of &array; &lt;varname&gt;A&lt;/varname&gt;'s values.
+     &lt;statement&gt;dot(A,B)&lt;/statement&gt; has values equaling the dot
+     product of corresponding values in &array;s &lt;varname&gt;A&lt;/varname&gt;
+     and &lt;varname&gt;B&lt;/varname&gt;.  The contents of an entire &array; can
+     be easily printed to standard output.  For example, the program
+ &lt;programlisting&gt;
+ Array&lt;1, double, Brick&gt; A(Interval&lt;1&gt;(0,2));
+ Array&lt;1, double, Brick&gt; B(Interval&lt;1&gt;(1,3));
+ A = 1.0;
+ B = 2.0;
+ std::cout &lt;&lt; A-B &lt;&lt; std::endl;
+ &lt;/programlisting&gt; yields
+     &lt;computeroutput&gt;
+     (000:002:001) = 1 -1 -1&lt;/computeroutput&gt;.  The initial
+     &lt;computeroutput&gt;(000:002:001)&lt;/computeroutput&gt; indicates the
+     &array;'s domain ranges from 0 to 2 with a stride of&nbsp;1.  The
+     three values in &lt;statement&gt;A-B&lt;/statement&gt; follow.&lt;/para&gt;
+ 
+     &lt;para&gt;So far, all of the above examples illustrating data-parallel
+     expressions and statements operate on all of a container's values.
+     Frequently, operating on a subset is useful.  In &pooma;, a subset
+     of a container's values is called a view.  Combining views and
+     data-parallel expressions will enable us to more succinctly and more
+     easily write the diffusion program.  Views are discussed in the
+     next chapter.&lt;/para&gt;
+ 
+ &lt;!-- HERE --&gt;
+ 
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot;&gt;
+      &lt;title&gt;Operators Permissible for Data-Parallel Expressions&lt;/title&gt;
+      
+      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+       &lt;thead&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;supported operators&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/thead&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;unary operators&lt;/entry&gt;
+ 	&lt;entry&gt;+, -, ~, !
+ HERE&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;binary operators&lt;/entry&gt;
+ 	&lt;entry&gt;+, -, *, /, %, &amp;, |, ^
+ HERE&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/table&gt;
+ 
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot;&gt;
+       &lt;title&gt;Mathematical Operators Permissible for Data-Parallel Expressions&lt;/title&gt;
+       
+       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+        &lt;thead&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;function&lt;/entry&gt;
+ 	 &lt;entry&gt;effect&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;/thead&gt;
+       &lt;tfoot&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;Every effort has been made to present accurate
+         information, but restrictions caused by the underlying
+         functions may further restriction the data-parallel
+         functions.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tfoot&gt;
+        &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; peteCast (const T1&amp;, const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the casting of the array's values to type &lt;type&gt;T1&lt;/type&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Multiplies &lt;varname&gt;A&lt;/varname&gt;'s values by the
+ 	corresponding integral power of two in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
+        &lt;/row&gt;
+ &lt;!-- HERE Reorder the above to be more sensible and add headings. --&gt;
+        &lt;row rowsep=&quot;1&quot;&gt;
+ 	&lt;entry&gt;Trigonometric and Hyperbolic Operators&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;statement&gt;#include &lt;math.h&gt;&lt;/statement&gt;&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; cos (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the cosines of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sin (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the sines of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; tan (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the tangents of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; acos (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the arc cosines of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; asin (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the arc sines of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; atan (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the arc tangents of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; cosh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the hyperbolic cosines of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sinh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the hyperbolic sines of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; tanh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the hyperbolic tangents of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row rowsep=&quot;1&quot;&gt;
+ 	&lt;entry&gt;Absolute Value and Rounding Operators&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;statement&gt;#include &lt;math.h&gt;&lt;/statement&gt;&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; fabs (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the absolute values of the floating point
+ 	numbers in the array.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;For each of the array's values, return the integer
+ 	larger than or equal to it (as a floating point number).&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;For each of the array's values, return the integer
+ 	larger than or equal to it (as a floating point number).&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; floor (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;For each of the array's values, return the integer
+ 	smaller than or equal to it (as a floating point number).&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row rowsep=&quot;1&quot;&gt;
+ 	&lt;entry&gt;Powers, Exponentiation, and Logarithmic Operators&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;statement&gt;#include &lt;math.h&gt;&lt;/statement&gt;&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; PETE_identity (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the array.  That is, it applies the identity operation.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sqrt (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the square roots of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow2 (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the squares of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow3 (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the cubes of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow4 (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the fourth powers of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; exp (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the exponentiations of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; log (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the natural logarithms of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; log10 (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the base-10 logarithms of the array's values.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row rowsep=&quot;1&quot;&gt;
+ 	&lt;entry&gt;Operators Involving Complex Numbers&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;statement&gt;#include &lt;complex&gt;&lt;/statement&gt;&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; real (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the real parts of &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; imag (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the imaginary parts of &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; abs (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the absolute values (magnitudes) of
+ 	&lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; abs (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the absolute values of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; arg (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the angle representations (in radians) of the
+ 	 polar representations of &lt;varname&gt;A&lt;/varname&gt;'s complex
+ 	 numbers.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; norm (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the squared absolute values of
+ 	 &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; conj (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the complex conjugates of
+ 	 &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the complex numbers created from polar
+ 	 coordinates (magnitudes and phase angles) in corresponding
+ 	 arrays.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the complex numbers created from polar
+ 	 coordinates with magnitude&nbsp;&lt;varname&gt;l&lt;/varname&gt; and
+ 	 phase angles in the array.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the complex numbers created from polar
+ 	 coordinates with magnitudes in the array and phase
+ 	 angle&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+         &lt;row rowsep=&quot;1&quot;&gt;
+ 	 &lt;entry&gt;Operators Involving Matrices and Tensors&lt;/entry&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;#include &quot;Pooma/Tiny.h&quot;&lt;/statement&gt;&lt;/entry&gt;
+         &lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;T trace (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the sum of the &lt;varname&gt;A&lt;/varname&gt;'s diagonal
+ 	 entries, viewed as a matrix.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;T det (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+          &lt;entry&gt;Returns the determinant of &lt;varname&gt;A&lt;/varname&gt;, viewed as a matrix.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; transpose (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the transpose of &lt;varname&gt;A&lt;/varname&gt;, viewed as a matrix.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; symmetrize (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the tensors of &lt;varname&gt;A&lt;/varname&gt; with the
+ 	 requested output symmetry.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the dot products of values in the two arrays.
+ 	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
+ 	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
+ 	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the dot products of values in the array
+ 	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.
+ 	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
+ 	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
+ 	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the dot products of &lt;varname&gt;l&lt;/varname&gt; with
+ 	 values in the array.  Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
+ 	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
+ 	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the dot products of values in the array
+ 	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
+ 	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
+ 	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns tensors created by computing the outer product
+ 	 of corresponding vectors in the two arrays.  Value
+ 	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
+ 	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors
+ 	 must have the same length.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns tensors created by computing the outer product
+ 	 of &lt;varname&gt;l&lt;/varname&gt; with the vectors in the array.  Value
+ 	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
+ 	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors
+ 	 must have the same length.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns tensors created by computing the outer product
+ 	 of vectors in the array with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  Value
+ 	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
+ 	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors
+ 	 must have the same length.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const Array&lt;T1&gt;&amp; A, const
+ 	 Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns matrices created by computing the outer product
+ 	 of corresponding vectors in the two arrays.  Value
+ 	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
+ 	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors must have
+ 	 the same length.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const T1&amp; l, const
+ 	 Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+          &lt;entry&gt;Returns matrices created by computing the outer
+ 	 product of &lt;varname&gt;l&lt;/varname&gt; with the vectors in the array.  Value
+ 	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
+ 	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors must
+ 	 have the same length.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const
+ 	 Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+          &lt;entry&gt;Returns matrices created by computing the outer
+ 	 product of the vectors in the array
+ 	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  Value
+ 	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
+ 	 &lt;type&gt;T1&lt;/type&gt; and &lt;type&gt;T2&lt;/type&gt;.  The vectors must
+ 	 have the same length.&lt;/entry&gt;
+ 	&lt;/row&gt;
+         &lt;row rowsep=&quot;1&quot;&gt;
+ 	 &lt;entry&gt;Comparison Operators&lt;/entry&gt;
+         &lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the maximum of corresponding array values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the maximums of &lt;varname&gt;l&lt;/varname&gt; with the array's values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the maximums of the array's values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns the minimum of corresponding array values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the minimums of &lt;varname&gt;l&lt;/varname&gt; with the array's values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;Returns the minimums of the array's values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the less-than
+ 	 operator&nbsp;&lt; to compare corresponding array values in
+ 	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const T1&amp; r, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the less-than
+ 	 operator&nbsp;&lt; to compare &lt;varname&gt;l&lt;/varname&gt; with the array's
+ 	 values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the less-than
+ 	 operator&nbsp;&lt; to compare the array's
+ 	 values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the less-than-or-equal
+ 	 operator&nbsp;&le; to compare array values in
+ 	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the less-than-or-equal
+ 	 operator&nbsp;&le; to compare &lt;varname&gt;l&lt;/varname&gt; with the array's values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the less-than-or-equal
+ 	 operator&nbsp;&le; to compare the array's values
+ 	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the greater-than-or-equal
+ 	 operator&nbsp;&ge; to compare array values in
+ 	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the greater-than-or-equal
+ 	 operator&nbsp;&ge; to compare &lt;varname&gt;l&lt;/varname&gt; with the array's values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the greater-than-or-equal
+ 	 operator&nbsp;&ge; to compare the array's values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the greater-than
+ 	 operator&nbsp;&gt; to compare array values in
+ 	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the greater-than
+ 	 operator&nbsp;&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the array's values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from using the greater-than
+ 	 operator&nbsp;&gt; to compare the array's values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from determining whether
+ 	 corresponding array values in &lt;varname&gt;A&lt;/varname&gt; and
+ 	 &lt;varname&gt;B&lt;/varname&gt; are equal.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from determining whether
+ 	 &lt;varname&gt;l&lt;/varname&gt; equals the array's values..&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from determining whether the array's values equal&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from determining whether
+ 	 corresponding array values in &lt;varname&gt;A&lt;/varname&gt; and
+ 	 &lt;varname&gt;B&lt;/varname&gt; are not equal.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from determining whether
+ 	 &lt;varname&gt;l&lt;/varname&gt; does not equal the array's values.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ 	&lt;row&gt;
+ 	 &lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
+ 	 &lt;entry&gt;Returns booleans from determining whether the 
+ 	 array's values are not equal to&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
+ 	&lt;/row&gt;
+ &lt;!-- FIXME: Add dotdot from src/Array/PoomaArrayOperators.h if it is defined. --&gt;
+        &lt;/tbody&gt;
+       &lt;/tgroup&gt;
+      &lt;/table&gt;
+ 
+ &lt;para&gt;We need to explain that proper types must be chosen.  For
+ example, cos on complex and double works but ceil on complex does not.
+ HERE&lt;/para&gt;
+ 
+ 
+ &lt;!-- HERE --&gt;
+ 
+    &lt;/section&gt;
+ 
+ 
+    &lt;section id=&quot;data_parallel-implementation&quot;&gt;
+     &lt;title&gt;Implementation of Data-Parallel Statements&lt;/title&gt;
+ 
+     &lt;para&gt;Data-parallel statements involving containers occur
+     frequently in the inner loops of scientific programs so their
+     efficient execution is important.  A naive implementation for
+     these statements may create and destroy containers holding
+     intermediate values, slowing execution considerably.
+     In&nbsp;1995, Todd &lt;!-- FIXME: Add citations to vandevoorde-95 and
+     veldhuizen-95. --&gt; Veldhuizen and David Vandevoorde developed an
+     expression-template technique to transform arithmetic expressions
+     involving array-like containers into efficient loops without using
+     temporaries.  Despite its perceived complexity, &pooma;
+     incorporated the technology.  The framework called &amp;pete, the
+     &lt;application&gt;Portable Expression Template Engine&lt;/application&gt;
+     framework, is also available separately from &pooma; at
+     &lt;ulink url=&quot;<A HREF="http://www.acl.lanl.gov/pete/">http://www.acl.lanl.gov/pete/</A>&quot;&gt;&lt;/ulink&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;In this section, we first describe how a naive
+     implementation may slow execution.  Then, we describe &pete;'s
+     faster implementation.  A data-parallel statement is converted
+     into a parse tree, rather than immediately evaluating it.  The
+     parse tree has two representations.  Its run-time representation
+     holds run-time values.  Its compile-time representation records
+     the types of the tree's values.  After a parse tree for the entire
+     statement is constructed, it is evaluated.  Since it is a
+     data-parallel statement, this evaluation involves at least one
+     loop.  At run time, each loop iteration, the value of one
+     container value is computed and assigned.  At compile time, when
+     the code for the loop iteration is produced, the parse tree's
+     types are traversed and code is produced without the need for any
+     intermediate values.  We present the implementation in &lt;xref
+     linkend=&quot;data_parallel-implementation-pete&quot;&gt;&lt;/xref&gt;, but first we
+     explain the difficulties caused by the naive implementation.&lt;/para&gt;
+ 
+     &lt;section id=&quot;data_parallel-implementation-naive&quot;&gt;
+      &lt;title&gt;Naive Implementation&lt;/title&gt;
+ 
+      &lt;para&gt;A conventional implementation to evaluate data-parallel
+      expressions might overload arithmetic operator functions.
+      Consider this program fragment:
+ &lt;programlisting&gt;
+ Interval&lt;1&gt; I(0,3);
+ Array&lt;1, double, Brick&gt; A(I), B(I);
+ A = 1.0;
+ B = 2.0;
+ A += -A + 2*B;
+ std::cout &lt;&lt; A &lt;&lt; std::endl;
+ &lt;/programlisting&gt; Our goal is to transform the data-parallel
+      statement &lt;statement&gt;A += -A + 2*B&lt;/statement&gt; into a single
+      loop, preferably without intermediary containers.  To simplify
+      notation, let &lt;type&gt;Ar&lt;/type&gt; abbreviate the type
+      &lt;type&gt;Array&lt;1, double, Brick&gt;&lt;/type&gt;.&lt;/para&gt;
+      
+      &lt;para&gt;Using overloaded arithmetic operators would require using
+      intermediate containers to evaluate the statement.  For example,
+      &lt;!-- FIXME: What is the proper tag for an inline function
+      prototype? --&gt; the sum's left operand &lt;statement&gt;-A&lt;/statement&gt;
+      would be computed by the overloaded unary operator &lt;statement&gt;Ar
+      operator-(const Ar&amp;)&lt;/statement&gt;, which would produce an
+      intermediate &array;.  &lt;statement&gt;Ar operator*(double,
+      const Ar&amp;)&lt;/statement&gt; would produce another intermediate
+      &array; holding &lt;statement&gt;2*B&lt;/statement&gt;.  Yet another
+      intermediate container would hold their sum, all before
+      performing the assignment.  Thus, three intermediate containers
+      would be created and destroyed.  Below, we show these are
+      unnecessary.&lt;/para&gt;
+     &lt;/section&gt;
+ 
+     &lt;section id=&quot;data_parallel-implementation-pete&quot;&gt;
+      &lt;title&gt;Portable Expression Template Engine&lt;/title&gt;
+ 
+      &lt;para&gt;&pooma; uses &pete;, the &lt;application&gt;Portable Expression
+      Template Engine&lt;/application&gt; framework, to evaluate
+      data-parallel statements using efficient loops without
+      intermediate values.  &pete; uses expression-template technology.
+      Instead of aggressively evaluating a data-parallel statement's
+      subexpressions, it defers evaluation, instead building a parse
+      tree of the required computations.  The parse tree's type records
+      the types of each of its subtrees.  Then, the parse tree is
+      evaluated using an evaluator determined by the left-hand side's
+      type.  This container type determines how to loop through its
+      domain.  Each loop iteration, the corresponding value of the
+      right-hand side is evaluated.  No intermediate loops or temporary
+      values are needed.&lt;/para&gt;
+ 
+      &lt;figure float=&quot;1&quot; id=&quot;data_parallel-implementation-pete-tree_figure&quot;&gt;
+       &lt;title&gt;Annotated Parse Tree for &lt;statement&gt;-A + 2*B&lt;/statement&gt;&lt;/title&gt;
+       &lt;mediaobject&gt;
+        &lt;imageobject&gt;
+ 	&lt;imagedata fileref=&quot;figures/data-parallel.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+        &lt;/imageobject&gt;
+        &lt;textobject&gt;
+ 	&lt;phrase&gt;A parse tree for the statement is produced.&lt;/phrase&gt;
+        &lt;/textobject&gt;
+        &lt;caption&gt;
+ 	&lt;para&gt;The parse tree for &lt;statement&gt;-A + 2*B&lt;/statement&gt; with
+         type annotations.  The complete type of a node equals the
+         concatenation of the preorder traversal of annotated types.&lt;/para&gt;
+        &lt;/caption&gt;
+       &lt;/mediaobject&gt;
+      &lt;/figure&gt;
+ 
+      &lt;para&gt;Before explaining the implementation, let us illustrate
+      using our example statement &lt;statement&gt;A += -A + 2*B&lt;/statement&gt;.
+      Evaluating the right-hand side creates a parse tree similar to
+      the one in &lt;xref
+      linkend=&quot;data_parallel-implementation-pete-tree_figure&quot;&gt;&lt;/xref&gt;.
+      For example, the overloaded unary minus operator yields a tree
+      node representing &lt;statement&gt;-A&lt;/statement&gt;, having a unary-minus
+      function object, and having type
+      &lt;type&gt;Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;&lt;/type&gt;.
+      The binary nodes continue the construction process yielding a
+      parse tree object for the entire right-hand side and having type
+      &lt;type&gt;Expression&lt;BinaryNode&lt;OpAdd, UnaryNode&lt;OpMinus,
+      Ar&gt;,
+      BinaryNode&lt;OpMultiply&lt;Scalar&lt;int&gt;,Ar&closeclose;&hairsp;&gt;&lt;/type&gt;.
+      Evaluating the left-hand side yields an object
+      representing&nbsp;&lt;varname&gt;A&lt;/varname&gt;.&lt;/para&gt;
+ 
+      &lt;para&gt;Finally, the assignment operator &lt;statement&gt;+=&lt;/statement&gt;
+      calls the &lt;function&gt;evaluate&lt;/function&gt; function corresponding to
+      the left-hand side's type.  At compile time, it produces the code
+      for the computation.  Since this templated function is
+      specialized on the type of the left-hand side, it generates a
+      loop through the left-hand side's container.  In the loop body,
+      the &lt;function&gt;forEach&lt;/function&gt; function produces code for the
+      right-hand side expression at a specific position using a
+      post-order parse-tree traversal.  At a leaf, this evaluation
+      queries the leaf's container for a specified value or extracts a
+      scalar value.  At an interior node, its children's results are
+      combined using its function operator.  One loop performs the
+      entire assignment.  It is important to note that the type of the
+      entire right-hand side is known at compile time.  Thus, all of
+      these &lt;function&gt;evaluate&lt;/function&gt;,
+      &lt;function&gt;forEach&lt;/function&gt;, and function operator function
+      calls can be inlined at compile time to yield simple code without
+      any temporary containers and hopefully as fast as hand-written
+      loops!&lt;/para&gt;
+ 
+      &lt;para&gt;To implement this scheme, we need &pooma; code to both
+      create the parse tree and to evaluate it.  We describe parse tree
+      creation first.  Parse trees consist of leaves,
+      &lt;type&gt;UnaryNode&lt;/type&gt;s, &lt;type&gt;BinaryNode&lt;/type&gt;s, and
+      &lt;type&gt;TrinaryNode&lt;/type&gt;s.  Since &lt;type&gt;TrinaryNode&lt;/type&gt;s are
+      similar to &lt;type&gt;BinaryNode&lt;/type&gt;s, we omit describing them.  A
+      &lt;type&gt;BinaryNode&lt;/type&gt;'s three template parameters correspond to
+      the three things it must store:
+      &lt;variablelist&gt;
+        &lt;varlistentry&gt;
+ 	&lt;term&gt;&lt;statement&gt;Op&lt;/statement&gt;&lt;/term&gt;
+ 	&lt;listitem&gt;
+ 	 &lt;para&gt;the type of the node's operation.  For example, the
+ 	 &lt;type&gt;OpAdd&lt;/type&gt; type represents adding two operands
+ 	 together.&lt;/para&gt;
+ 	&lt;/listitem&gt;
+        &lt;/varlistentry&gt;
+        &lt;varlistentry&gt;
+ 	&lt;term&gt;&lt;statement&gt;Left&lt;/statement&gt;&lt;/term&gt;
+ 	&lt;listitem&gt;
+ 	 &lt;para&gt;the type of the left child.&lt;/para&gt;
+ 	&lt;/listitem&gt;
+        &lt;/varlistentry&gt;
+        &lt;varlistentry&gt;
+ 	&lt;term&gt;&lt;statement&gt;Right&lt;/statement&gt;&lt;/term&gt;
+ 	&lt;listitem&gt;
+ 	 &lt;para&gt;the type of the right child.&lt;/para&gt;
+ 	&lt;/listitem&gt;
+        &lt;/varlistentry&gt;
+       &lt;/variablelist&gt;
+     The node stores the left and right children's nodes.&lt;/para&gt;
+ 
+     &lt;para&gt;&lt;type&gt;BinaryNode&lt;/type&gt; does not need to store any
+     representation of the node's operation.  Instead the
+     &lt;type&gt;Op&lt;/type&gt; type is an empty structure declaring a function
+     object.  For example, &lt;type&gt;OpAdd&lt;/type&gt;'s function object is
+     declared as
+ &lt;programlisting&gt;
+ template&lt;class T1, class T2&gt;
+ inline typename BinaryReturn&lt;T1, T2, OpAdd&gt;::Type_t
+ operator()(const T1 &amp;a, const T2 &amp;b) const
+ {
+   return (a + b);
+ }
+ &lt;/programlisting&gt;  Since it has two template arguments, it can be
+     applied to operands of any type.  Because of &cc; type
+     conversions, the type of the result is determined using the
+     &lt;type&gt;BinaryReturn&lt;/type&gt; traits class.  Consider adding an &int;
+     and a &double;.  &lt;type&gt;BinaryReturn&lt;int, double,
+     OpAdd&gt;::Type_t&lt;/type&gt; equals &double;.  Inlining the function
+     ensures all this syntax is eliminated, leaving behind just an
+     addition.&lt;/para&gt;
+ 
+     &lt;para&gt;&lt;type&gt;UnaryNode&lt;/type&gt;s are similar but have only two
+     template parameters and store only one child.&lt;/para&gt;
+ 
+      &lt;para&gt;Parse tree leaves are created by the
+      &lt;type&gt;CreateLeaf&lt;/type&gt; class and its specializations.  The
+      default leaf is a scalar so it has the most general definition:
+ &lt;programlisting&gt;
+ template&lt;class T&gt;
+ struct CreateLeaf
+ {
+   typedef Scalar&lt;T&gt; Leaf_t;
+ 
+   inline static
+   Leaf_t make(const T &amp;a)
+   {
+     return Scalar&lt;T&gt;(a);
+   }
+ };
+ &lt;/programlisting&gt; The &lt;type&gt;Scalar&lt;/type&gt; class stores the scalar
+     value.  The &lt;type&gt;CreateLeaf&lt;/type&gt;'s &lt;type&gt;Leaf_t&lt;/type&gt; type
+     indicates its type.  The &lt;statement&gt;static&lt;/statement&gt;
+     &lt;function&gt;make&lt;/function&gt; function is invoked by an overloaded
+     operator function when creating its children.&lt;/para&gt;
+ 
+     &lt;para&gt;The &lt;type&gt;CreateLeaf&lt;/type&gt; class is specialized for &array;s:
+ &lt;programlisting&gt;
+ template&lt;int Dim, class T, class EngineTag&gt;
+ struct CreateLeaf&lt;Array&lt;Dim, T, EngineTag&gt; &gt;
+ {
+   typedef Array&lt;Dim, T, EngineTag&gt; Input_t;
+   typedef Reference&lt;Input_t&gt; Leaf_t;
+   typedef Leaf_t Return_t;
+   inline static
+   Return_t make(const Input_t &amp;a)
+     {
+       return Leaf_t(a);
+     }
+ };
+ &lt;/programlisting&gt;  The &array; object is stored as a
+     &lt;type&gt;Reference&lt;/type&gt;, rather than directly as for scalars.&lt;/para&gt;
+ 
+     &lt;para&gt;To simplify the next step of overloading arithmetic
+     operators, a parse tree's topmost type is an
+     &lt;type&gt;Expression&lt;/type&gt;.&lt;/para&gt;
+ 
+     &lt;para&gt;Now that we have defined the node classes, the &cc;
+     arithmetic operators must be overloaded to return the appropriate
+     parse tree.  For example, unary minus operator
+     &lt;function&gt;operator-&lt;/function&gt; overloaded to accept an &array;
+     argument should create a &lt;type&gt;UnaryNode&lt;/type&gt; having an &array;
+     as its child, which will be a leaf:
+ &lt;programlisting&gt;
+ template&lt;int D1,class T1,class E1&gt;
+ inline typename MakeReturn&lt;UnaryNode&lt;OpUnaryMinus,
+   typename CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::Leaf_t&gt; &gt;::Expression_t
+ operator-(const Array&lt;D1,T1,E1&gt; &amp; l)
+ {
+   typedef UnaryNode&lt;OpUnaryMinus,
+     typename CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::Leaf_t&gt; Tree_t;
+   return MakeReturn&lt;Tree_t&gt;::make(Tree_t(
+     CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::make(l)));
+ }
+ &lt;/programlisting&gt;  &lt;type&gt;Tree_t&lt;/type&gt; specifies the node's unique
+     type.  Constructing the object first involves creating a leaf
+     containing the &array; reference through the call to
+     &lt;function&gt;CreateLeaf&lt;Array&lt;D1,T1,E1&gt;
+     &gt;::make&lt;/function&gt;.  The call to
+     &lt;function&gt;MakeReturn&lt;Tree_t&gt;::make&lt;/function&gt; permits
+     programmers to store trees in different formats.  The &pooma;
+     implementation stores them as &lt;type&gt;Expression&lt;/type&gt;s.  The
+     function's return type is similar to the
+     &lt;statement&gt;return&lt;/statement&gt; statement except it extracts the
+     type from &lt;type&gt;Expression&lt;/type&gt;'s internal
+     &lt;type&gt;Expression_t&lt;/type&gt; type.&lt;/para&gt;
+ 
+     &lt;para&gt;Specialized all the operators for &array;s using such
+     complicated is likely to be error-prone so &pete; provides a way
+     to automate it.  Using its &lt;command&gt;MakeOperators&lt;/command&gt;
+     command with this input:
+ &lt;programlisting&gt;
+ classes
+ -----
+   ARG   = &quot;int D[n],class T[n],class E[n]&quot;
+   CLASS = &quot;Array&lt;D[n],T[n],E[n]&gt;&quot;
+ &lt;/programlisting&gt; automatically generates code for all the needed operators.
+     The &lt;quote&gt;[n]&lt;/quote&gt; strings are used to number arguments for binary
+     and ternary operators.&lt;/para&gt;
+ 
+     &lt;para&gt;Assignment operators must also be specialized for &array;.
+     Inside the &array; class definition, each such operator just
+     invokes the &lt;function&gt;assign&lt;/function&gt; function with a corresponding
+     function object.  For example, &lt;function&gt;operator+=&lt;/function&gt;
+     invokes &lt;statement&gt;assign(*this, rhs, OpAddAssign())&lt;/statement&gt;.
+     &lt;varname&gt;rhs&lt;/varname&gt; is the parse tree object for the right-hand
+     side.  Calling this function invokes
+     &lt;function&gt;evaluate&lt;/function&gt;, which begins the evaluation.&lt;/para&gt;
+ 
+     &lt;para&gt;Before we explain the evaluation, let us summarize the
+     effect of the code so far described.  If we are considering run
+     time, parse trees for the left-hand and right-hand sides have been
+     constructed.  If we are considering compile time, the types of
+     these parse trees are known.  At compile time, the
+     &lt;function&gt;evaluate&lt;/function&gt; function described below will
+     generate a loop through the left-hand side container's domain.
+     The loop's body will have code computing a container's value.  At
+     run time, this code will read values from containers, but the
+     run-time parse tree object itself will not traversed!&lt;/para&gt;
+ 
+     &lt;para&gt;We now explore the evaluation, concentrating on compile
+     time, not run time.  &lt;function&gt;evaluate&lt;/function&gt; is an
+     overloaded function specialized on the type of the left-hand side.
+     In our example, the left-hand side is a one-dimensional &array;,
+     so &lt;function&gt;evaluate(const Ar&amp; a, const Op&amp; op, const
+     RHS&amp; rhs)&lt;/function&gt; is inlined into a loop like
+ &lt;programlisting&gt;
+ int end = a's domain[0].first() + a's domain[0].length();
+ for (int i = a's domain[0].first(); i &lt; end; ++i)
+   op(a(i), rhs.read(i));
+ &lt;/programlisting&gt;  &lt;varname&gt;a&lt;/varname&gt; is the array,
+     &lt;varname&gt;op&lt;/varname&gt; is a function object representing the
+     assignment operation, and &lt;varname&gt;rhs&lt;/varname&gt; is the right-hand
+     side's parse tree.&lt;/para&gt;
+ 
+     &lt;para&gt;Evaluating &lt;statement&gt;rhs.read(i)&lt;/statement&gt; inlines into a
+     call to the &lt;function&gt;forEach&lt;/function&gt; function.  This function
+     performs a &lt;emphasis&gt;compile-time&lt;/emphasis&gt; post-order parse-tree
+     traversal.  Its general form is
+ &lt;programlisting&gt;
+ forEach(const Expression&amp; e, const LeafTag&amp; f, const CombineTag&amp; c).
+ &lt;/programlisting&gt; That is, it traverses the nodes of the
+     &lt;type&gt;Expression&lt;/type&gt; object&nbsp;&lt;varname&gt;e&lt;/varname&gt;.  At
+     leaves, it applies the operation specified by
+     &lt;type&gt;LeafTag&lt;/type&gt;&nbsp;&lt;varname&gt;f&lt;/varname&gt;.  At interior
+     nodes, it combines the results using the &lt;type&gt;CombineTag&lt;/type&gt;
+     operator&nbsp;&lt;varname&gt;c&lt;/varname&gt;.  It inlines into a call to
+ &lt;programlisting&gt;
+     ForEach&lt;Expression, LeafTag, CombineTag&gt;::apply(e, f, c).
+ &lt;/programlisting&gt;  The &lt;function&gt;apply&lt;/function&gt; function continues
+     the traversal through the tree.  For our example,
+     &lt;type&gt;LeafTag&lt;/type&gt; equals &lt;type&gt;EvalLeaf&lt;1&gt;&lt;/type&gt;, and
+     &lt;type&gt;CombineTag&lt;/type&gt; equals &lt;type&gt;OpCombine&lt;/type&gt;.  The former
+     indicates that, when reaching a leaf, the leaf should be a
+     one-dimensional container which should be evaluated
+     at the position stored in the &lt;type&gt;EvalLeaf&lt;/type&gt; object.  The
+     &lt;type&gt;OpCombine&lt;/type&gt; class applies an interior node's
+     &lt;type&gt;Op&lt;/type&gt; to the results of its children.&lt;/para&gt;
+ 
+     &lt;para&gt;&lt;type&gt;ForEach&lt;/type&gt; structures are specialized for the
+     various node types.  For example, the specialization for
+     &lt;type&gt;UnaryNode&lt;/type&gt; is
+ &lt;programlisting&gt;
+ template&lt;class Op, class A, class FTag, class CTag&gt;
+ struct ForEach&lt;UnaryNode&lt;Op, A&gt;, FTag, CTag&gt;
+ {
+   typedef typename ForEach&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
+   typedef typename Combine1&lt;TypeA_t, Op, CTag&gt;::Type_t Type_t;
+   inline static
+   Type_t apply(const UnaryNode&lt;Op, A&gt; &amp;expr, const FTag &amp;f, 
+     const CTag &amp;c) 
+   {
+     return Combine1&lt;TypeA_t, Op, CTag&gt;::
+       combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.child(), f, c), c);
+   }
+ };
+ &lt;/programlisting&gt;  Since this structure is specialized for
+     &lt;type&gt;UnaryNode&lt;/type&gt;s, the first parameter of its
+     &lt;statement&gt;static &lt;/statement&gt; &lt;function&gt;apply&lt;/function&gt; function
+     is a &lt;type&gt;UnaryNode&lt;/type&gt;.  After recursively calling its child,
+     it invokes the combination function indicated by the
+     &lt;type&gt;Combine1&lt;/type&gt; traits class.  In our example, the
+     &lt;varname&gt;c&lt;/varname&gt; function object should be applied.  Other
+     combiners have different roles.  For example, using the
+     &lt;type&gt;NullCombine&lt;/type&gt; tag indicates the child's result should
+     not be combined but occurs just for side effects.&lt;/para&gt;
+ 
+     &lt;para&gt;Leaves are treated as the default behavior so they are not
+     specialized:
+ &lt;programlisting&gt;
+ template&lt;class Expr, class FTag, class CTag&gt;
+ struct ForEach
+ {
+   typedef typename LeafFunctor&lt;Expr, FTag&gt;::Type_t Type_t;
+   inline static
+   Type_t apply(const Expr &amp;expr, const FTag &amp;f, const CTag &amp;)
+   {
+     return LeafFunctor&lt;Expr, FTag&gt;::apply(expr, f);
+   }
+ };
+ &lt;/programlisting&gt;  Thus, &lt;type&gt;LeafFunctor&lt;/type&gt;'s
+     &lt;function&gt;apply&lt;/function&gt; member is called.  &lt;type&gt;Expr&lt;/type&gt;
+     represents the expression type, e.g., an &array;, and
+     &lt;type&gt;FTag&lt;/type&gt; is the &lt;type&gt;LeafTag&lt;/type&gt;, e.g.,
+     &lt;type&gt;EvalLeaf&lt;/type&gt;.  The &lt;type&gt;LeafFunctor&lt;/type&gt;specialization
+     for &array; passes the index stored by the &lt;type&gt;EvalLeaf&lt;/type&gt;
+     object to the &array;'s engine, which returns the corresponding
+     value.&lt;/para&gt;
+ 
+      &lt;para&gt;If one uses an aggressive optimizing compiler, code
+      resulting from the &lt;function&gt;evaluate&lt;/function&gt; function
+      corresponds to this pseudocode:
+ &lt;programlisting&gt;
+ int end = A.domain[0].first() + A.domain[0].length();
+ for (int i = A.domain[0].first(); i &lt; end; ++i)
+   A.engine(i) += -A.engine.read(i) + 2 * B.engine.read(i);
+ &lt;/programlisting&gt;  The loop iterates through &lt;varname&gt;A&lt;/varname&gt;'s
+     domain, using &array;'s engines to obtain values and assigning
+     values.  Notice there is no use of the run-time parse tree so the
+     optimizer can eliminate the code to construct it.  All the work to
+     construct the parse tree by overloading operators is unimportant
+     at run time, but it certainly helped the compiler produce improved
+     code.&lt;/para&gt;
+ 
+      &lt;para&gt;&pete;'s expression template technology may be complicated,
+      using parse trees and their types, but the code they produce is
+      not.  Using the technology is also easy.  All data-parallel
+      statements are automatically converted.  In the next chapter, we
+      explore views of containers, permitting use of container subsets
+      and making data-parallel expressions even more useful.&lt;/para&gt;
+     &lt;/section&gt;
+ 
+    &lt;/section&gt;
+ 
+   &lt;/chapter&gt;
+   
+ 
  
    &lt;chapter id=&quot;sequential&quot;&gt;
     &lt;title&gt;Writing Sequential Programs&lt;/title&gt;
*************** HERE&lt;/para&gt;
*** 297,303 ****
     &lt;para&gt;FIXME: Explain the format of each section.
  HERE&lt;/para&gt;
  
!    &lt;para&gt;FIXME: Explain the order  of the sections.
  HERE&lt;/para&gt;
  
     &lt;para&gt;Proposed order.  Basically follow the order in the proposed
--- 1824,1830 ----
     &lt;para&gt;FIXME: Explain the format of each section.
  HERE&lt;/para&gt;
  
!    &lt;para&gt;FIXME: Explain the order of the sections.
  HERE&lt;/para&gt;
  
     &lt;para&gt;Proposed order.  Basically follow the order in the proposed
*************** HERE&lt;/para&gt;
*** 475,490 ****
      &lt;function&gt;finalize&lt;/function&gt;.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.&lt;/para&gt;
  
!     &lt;section id=&quot;sequential-begin_end-files&quot;&gt;
!      &lt;title&gt;Files&lt;/title&gt;
  
       &lt;programlisting&gt;
       #include &quot;Pooma/Pooma.h&quot;  // or &quot;Pooma/Arrays.h&quot; or &quot;Pooma/Fields.h&quot; or ...
       &lt;/programlisting&gt;
-     &lt;/section&gt;
  
!     &lt;section id=&quot;sequential-begin_end-declarations&quot;&gt;
!       &lt;title&gt;Declarations&lt;/title&gt;
  
       &lt;funcsynopsis&gt;
        &lt;funcprototype&gt;
--- 2002,2014 ----
      &lt;function&gt;finalize&lt;/function&gt;.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.&lt;/para&gt;
  
!     &lt;bridgehead id=&quot;sequential-begin_end-files&quot; renderas=&quot;sect2&quot;&gt;Files&lt;/bridgehead&gt;
  
       &lt;programlisting&gt;
       #include &quot;Pooma/Pooma.h&quot;  // or &quot;Pooma/Arrays.h&quot; or &quot;Pooma/Fields.h&quot; or ...
       &lt;/programlisting&gt;
  
!     &lt;bridgehead id=&quot;sequential-begin_end-declarations&quot; renderas=&quot;sect2&quot;&gt;Declarations&lt;/bridgehead&gt;
  
       &lt;funcsynopsis&gt;
        &lt;funcprototype&gt;
*************** HERE&lt;/para&gt;
*** 520,529 ****
         &lt;/paramdef&gt;
        &lt;/funcprototype&gt;
       &lt;/funcsynopsis&gt;
-     &lt;/section&gt;
  
!     &lt;section id=&quot;sequential-begin_end-description&quot;&gt;
!      &lt;title&gt;Description&lt;/title&gt;
  
       &lt;para&gt;Before its use, the &poomatoolkit; must be initialized by a
       call to &lt;function&gt;initialize&lt;/function&gt;.  This usually occurs in
--- 2044,2051 ----
         &lt;/paramdef&gt;
        &lt;/funcprototype&gt;
       &lt;/funcsynopsis&gt;
  
!     &lt;bridgehead id=&quot;sequential-begin_end-description&quot; renderas=&quot;sect2&quot;&gt;Description&lt;/bridgehead&gt;
  
       &lt;para&gt;Before its use, the &poomatoolkit; must be initialized by a
       call to &lt;function&gt;initialize&lt;/function&gt;.  This usually occurs in
*************** HERE&lt;/para&gt;
*** 572,581 ****
       &lt;para&gt;Including almost any &pooma; header file, rather than just
       &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Pooma.h&lt;/filename&gt; suffices
       since most other &pooma; header files include it.&lt;/para&gt;
-     &lt;/section&gt;
  
!     &lt;section id=&quot;sequential-begin_end-example&quot;&gt;
!      &lt;title&gt;Example Program&lt;/title&gt;
  
       &lt;para&gt;Since every &pooma; program must call
       &lt;function&gt;initialize&lt;/function&gt; and
--- 2094,2101 ----
       &lt;para&gt;Including almost any &pooma; header file, rather than just
       &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Pooma.h&lt;/filename&gt; suffices
       since most other &pooma; header files include it.&lt;/para&gt;
  
!     &lt;bridgehead id=&quot;sequential-begin_end-example&quot; renderas=&quot;sect2&quot;&gt;Example Program&lt;/bridgehead&gt;
  
       &lt;para&gt;Since every &pooma; program must call
       &lt;function&gt;initialize&lt;/function&gt; and
*************** HERE&lt;/para&gt;
*** 584,599 ****
       use.&lt;/para&gt;
  
       &amp;initialize-finalize;
-     &lt;/section&gt;
  
     &lt;/section&gt;&lt;!-- end sequential-begin_end --&gt;
  
     &lt;section id=&quot;sequential-options&quot;&gt;
      &lt;title&gt;&pooma; Command-line Options&lt;/title&gt;
  
      &lt;para&gt;Every &pooma; program accepts a set of &pooma;-specific
      command-line options to set values at run-time.&lt;/para&gt;
  
      &lt;section id=&quot;sequential-options-list&quot;&gt;
       &lt;title&gt;Options Summary&lt;/title&gt;
  
--- 2104,2163 ----
       use.&lt;/para&gt;
  
       &amp;initialize-finalize;
  
     &lt;/section&gt;&lt;!-- end sequential-begin_end --&gt;
  
+ 
+    &lt;section id=&quot;sequential-global&quot;&gt;
+     &lt;title&gt;Global Variables&lt;/title&gt;
+ 
+     &lt;para&gt;&pooma; makes a few global variables available after
+     initialization.&lt;/para&gt;
+ 
+     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot;&gt;
+      &lt;title&gt;&pooma; Global Variables&lt;/title&gt;
+      
+      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+       &lt;thead&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;variable&lt;/entry&gt;
+ 	&lt;entry&gt;description&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/thead&gt;
+       &lt;tbody&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&inform; &lt;varname&gt;pinfo&lt;/varname&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;output stream used to print informative messages to the
+ 	user while the program executes.  The stream accepts a
+ 	superset of standard output operations.&lt;/entry&gt;
+        &lt;/row&gt;
+        &lt;row&gt;
+ 	&lt;entry&gt;&inform; &lt;varname&gt;pwarn&lt;/varname&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;HERE output stream used to print informative messages to the
+ 	user while the program executes.  The stream accepts a
+ 	superset of standard output operations.&lt;/entry&gt;
+        &lt;/row&gt;
+       &lt;/tbody&gt;
+      &lt;/tgroup&gt;
+     &lt;/table&gt;
+ 
+    &lt;/section&gt;
+ 
+ &lt;!-- HERE --&gt;
+ 
     &lt;section id=&quot;sequential-options&quot;&gt;
      &lt;title&gt;&pooma; Command-line Options&lt;/title&gt;
  
      &lt;para&gt;Every &pooma; program accepts a set of &pooma;-specific
      command-line options to set values at run-time.&lt;/para&gt;
  
+     &lt;para&gt;QUESTION: Should I defer documenting &options; to the
+     reference manual, instead just listing commonly used options in
+     the previous section?
+ 
+ UNFINISHED&lt;/para&gt;
+ 
      &lt;section id=&quot;sequential-options-list&quot;&gt;
       &lt;title&gt;Options Summary&lt;/title&gt;
  
*************** HERE&lt;/para&gt;
*** 601,614 ****
        &lt;varlistentry&gt;
         &lt;term&gt;&lt;parameter class=&quot;option&quot;&gt;&dashdash;pooma-info&lt;/parameter&gt;&lt;/term&gt;
         &lt;listitem&gt;
! 	&lt;para&gt;
! HERE  Who uses this?&lt;/para&gt;
         &lt;/listitem&gt;
        &lt;/varlistentry&gt;
  &lt;!-- HERE --&gt;
       &lt;/variablelist&gt;
  
       &lt;para&gt;FIXME: Be sure to list default values.&lt;/para&gt;
  
  &lt;!-- HERE --&gt;
  
--- 2165,2181 ----
        &lt;varlistentry&gt;
         &lt;term&gt;&lt;parameter class=&quot;option&quot;&gt;&dashdash;pooma-info&lt;/parameter&gt;&lt;/term&gt;
         &lt;listitem&gt;
! 	&lt;para&gt;enable use of the &lt;varname&gt;pinfo&lt;/varname&gt;, used to
! 	print informative messages to the user while the program
! 	executes.&lt;/para&gt;
         &lt;/listitem&gt;
        &lt;/varlistentry&gt;
  &lt;!-- HERE --&gt;
       &lt;/variablelist&gt;
  
       &lt;para&gt;FIXME: Be sure to list default values.&lt;/para&gt;
+ &lt;!-- HERE: need to describe the pinfo, pwarn, and perr streams somewhere.  To do so requires describing informs.--&gt;
+ &lt;!-- HERE: Which streams are buffered and which are not? --&gt;
  
  &lt;!-- HERE --&gt;
  
*************** HERE  Who uses this?&lt;/para&gt;
*** 616,627 ****
  
  &lt;!-- HERE --&gt;
  
-     &lt;para&gt;QUESTION: Should I defer documenting &options; to the
-     reference manual, instead just listing commonly used options in
-     the previous section?
- 
- UNFINISHED&lt;/para&gt;
- 
     &lt;/section&gt;&lt;!-- end sequential-options --&gt;
  
     &lt;section&gt;
--- 2183,2188 ----
*************** UNFINISHED&lt;/para&gt;
*** 740,746 ****
        code. An Array maps a fairly arbitrary input domain to an
        arbitrary range of outputs. When used by itself, an &array;
        object &lt;varname&gt;A&lt;/varname&gt; refers to all of the values in its
! 				  domain. Element-wise mathematical operations or functions can be
        applied to an array using straightforward notation, like A + B
        or sin(A). Expressions involving Array objects are themselves
        Arrays. The operation A(d), where d is a domain object that
--- 2301,2307 ----
        code. An Array maps a fairly arbitrary input domain to an
        arbitrary range of outputs. When used by itself, an &array;
        object &lt;varname&gt;A&lt;/varname&gt; refers to all of the values in its
!       domain. Element-wise mathematical operations or functions can be
        applied to an array using straightforward notation, like A + B
        or sin(A). Expressions involving Array objects are themselves
        Arrays. The operation A(d), where d is a domain object that
*************** UNFINISHED&lt;/para&gt;
*** 1188,1195 ****
     class=&quot;libraryfile&quot;&gt;.cmpl.cpp&lt;/filename&gt;, &lt;filename
     class=&quot;libraryfile&quot;&gt;.mk&lt;/filename&gt;, &lt;filename
     class=&quot;libraryfile&quot;&gt;.conf&lt;/filename&gt;.  Should we also explain use
!    of &lt;literal&gt;inline&lt;/literal&gt; even when necessary and the template
!    model, &lt;!-- FIXME: s/literal/keyword/ --&gt; e.g., including &lt;filename
     class=&quot;libraryfile&quot;&gt;.cpp&lt;/filename&gt; files.&lt;/para&gt;
  
     &lt;para&gt;QUESTION: What are the key concepts around which to organize
--- 2749,2756 ----
     class=&quot;libraryfile&quot;&gt;.cmpl.cpp&lt;/filename&gt;, &lt;filename
     class=&quot;libraryfile&quot;&gt;.mk&lt;/filename&gt;, &lt;filename
     class=&quot;libraryfile&quot;&gt;.conf&lt;/filename&gt;.  Should we also explain use
!    of &lt;keywordname&gt;inline&lt;/keywordname&gt; even when necessary and the template
!    model, e.g., including &lt;filename
     class=&quot;libraryfile&quot;&gt;.cpp&lt;/filename&gt; files.&lt;/para&gt;
  
     &lt;para&gt;QUESTION: What are the key concepts around which to organize
*************** UNFINISHED&lt;/para&gt;
*** 1420,1426 ****
  	&lt;entry&gt;&lt;para&gt;dimension&lt;/para&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;varname&gt;T&lt;/varname&gt;&lt;/entry&gt;
  	&lt;entry&gt;&lt;para&gt;array element type&lt;/para&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
--- 2981,2987 ----
  	&lt;entry&gt;&lt;para&gt;dimension&lt;/para&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;type&gt;T&lt;/type&gt;&lt;/entry&gt;
  	&lt;entry&gt;&lt;para&gt;array element type&lt;/para&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
*************** UNFINISHED&lt;/para&gt;
*** 3014,3021 ****
       class=&quot;headerfile&quot;&gt;src/Utilities/DerefIterator.h&lt;/filename&gt;:
       &lt;type&gt;DerefIterator&lt;T&gt;&lt;/type&gt; and
       &lt;type&gt;ConstDerefIterator&lt;T&gt;&lt;/type&gt; automatically
!      dereference themselves to maintain &lt;literal&gt;const&lt;/literal&gt;
!      correctness.  &lt;!-- FIXME: s/literal/keyword/ --&gt;&lt;/para&gt;
      &lt;/listitem&gt;
  
      &lt;listitem&gt;
--- 4575,4582 ----
       class=&quot;headerfile&quot;&gt;src/Utilities/DerefIterator.h&lt;/filename&gt;:
       &lt;type&gt;DerefIterator&lt;T&gt;&lt;/type&gt; and
       &lt;type&gt;ConstDerefIterator&lt;T&gt;&lt;/type&gt; automatically
!      dereference themselves to maintain &lt;keywordname&gt;const&lt;/keywordname&gt;
!      correctness.&lt;/para&gt;
      &lt;/listitem&gt;
  
      &lt;listitem&gt;
*************** UNFINISHED&lt;/para&gt;
*** 3042,3048 ****
      &lt;listitem&gt;
       &lt;para&gt;Discuss &options; and related material.  Add developer
       command-line options listed in &lt;filename
!      class=&quot;library&quot;&gt;Utilities/Options.cmpl.cpp&lt;/filename&gt; and also
       possibly &lt;parameter class=&quot;option&quot;&gt;&dashdash;pooma-threads
       &lt;replaceable&gt;n&lt;/replaceable&gt;&lt;/parameter&gt;.&lt;/para&gt;
      &lt;/listitem&gt;
--- 4603,4609 ----
      &lt;listitem&gt;
       &lt;para&gt;Discuss &options; and related material.  Add developer
       command-line options listed in &lt;filename
!      class=&quot;libraryfile&quot;&gt;Utilities/Options.cmpl.cpp&lt;/filename&gt; and also
       possibly &lt;parameter class=&quot;option&quot;&gt;&dashdash;pooma-threads
       &lt;replaceable&gt;n&lt;/replaceable&gt;&lt;/parameter&gt;.&lt;/para&gt;
      &lt;/listitem&gt;
*************** UNFINISHED&lt;/para&gt;
*** 3600,3859 ****
  
   &lt;/appendix&gt;
  
- 
-  &lt;!-- Bibliography --&gt;
- 
-  &lt;bibliography id=&quot;bibliography&quot;&gt;
-   &lt;title&gt;Bibliography&lt;/title&gt;
- 
-   &lt;para&gt;FIXME: How do I process these entries?&lt;/para&gt;
- 
-   &lt;biblioentry&gt;
-    &lt;abbrev&gt;mpi99&lt;/abbrev&gt;
-    &lt;authorgroup&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;William&lt;/firstname&gt;&lt;surname&gt;Gropp&lt;/surname&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Ewing&lt;/firstname&gt;&lt;surname&gt;Lusk&lt;/surname&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Anthony&lt;/firstname&gt;&lt;surname&gt;Skjellum&lt;/surname&gt;
-     &lt;/author&gt;
-    &lt;/authorgroup&gt;
-    &lt;copyright&gt;
-     &lt;year&gt;1999&lt;/year&gt;
-     &lt;holder&gt;Massachusetts Institute of Technology&lt;/holder&gt;
-    &lt;/copyright&gt;
-    &lt;isbn&gt;0-262-57132-3&lt;/isbn&gt;
-    &lt;publisher&gt;
-     &lt;publishername&gt;The MIT Press&lt;/publishername&gt;
-     &lt;address&gt;Cambridge, MA&lt;/address&gt;
-    &lt;/publisher&gt;
-    &lt;title&gt;Using MPI&lt;/title&gt;
-    &lt;subtitle&gt;Portable Parallel Programming with the Message-Passing Interface&lt;/subtitle&gt;
-    &lt;edition&gt;second edition&lt;/edition&gt;
-   &lt;/biblioentry&gt;
- 
-   &lt;biblioentry&gt;
-    &lt;abbrev&gt;pooma95&lt;/abbrev&gt;
-    &lt;authorgroup&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;John&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;V. W.&lt;/othername&gt;&lt;surname&gt;Reynders&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Paul&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;J.&lt;/othername&gt;&lt;surname&gt;Hinker&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Dakota Software Systems, Inc.&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Rapid City&lt;/city&gt;&lt;state&gt;SD&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Julian&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;C.&lt;/othername&gt;&lt;surname&gt;Cummings&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Susan&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;R.&lt;/othername&gt;&lt;surname&gt;Atlas&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Parallel Solutions, Inc.&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Santa Fe&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Subhankar&lt;/firstname&gt;&lt;surname&gt;Banerjee&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;New Mexico State University&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Las Cruces&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;William&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;F.&lt;/othername&gt;&lt;surname&gt;Humphrey&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;University of Illinois at Urbana-Champaign&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Urbana-Champaign&lt;/city&gt;&lt;state&gt;IL&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Steve&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;R.&lt;/othername&gt;&lt;surname&gt;Karmesin&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;California Institute of Technology&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Pasadena&lt;/city&gt;&lt;state&gt;CA&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Katarzyna&lt;/firstname&gt;&lt;surname&gt;Keahey&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Indiana University&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Bloomington&lt;/city&gt;&lt;state&gt;IN&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Marydell&lt;/firstname&gt;&lt;surname&gt;Tholburn&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-    &lt;/authorgroup&gt;
-    &lt;title&gt;&pooma;&lt;/title&gt;
-    &lt;subtitle&gt;A Framework for Scientific Simulation on Parallel Architectures&lt;/subtitle&gt;
-    &lt;releaseinfo&gt;unpublished&lt;/releaseinfo&gt;
-   &lt;/biblioentry&gt;
- 
-   &lt;biblioentry&gt;
-    &lt;abbrev&gt;pooma-sc95&lt;/abbrev&gt;
-    &lt;authorgroup&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Susan&lt;/firstname&gt;&lt;surname&gt;Atlas&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Subhankar&lt;/firstname&gt;&lt;surname&gt;Banerjee&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;New Mexico State University&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Las Cruces&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Julian&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;C.&lt;/othername&gt;&lt;surname&gt;Cummings&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Paul&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;J.&lt;/othername&gt;&lt;surname&gt;Hinker&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Advanced Computing Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;M.&lt;/firstname&gt;&lt;surname&gt;Srikant&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;New Mexico State University&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Las Cruces&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;John&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;V. W.&lt;/othername&gt;&lt;surname&gt;Reynders&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Marydell&lt;/firstname&gt;&lt;surname&gt;Tholburn&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-    &lt;/authorgroup&gt;
-    &lt;title&gt;&pooma;&lt;/title&gt;
-    &lt;subtitle&gt;A High Performance Distributed Simulation Environment for
-    Scientific Applications&lt;/subtitle&gt;
- &lt;!-- FIXME: Where list Supercomputing 1995? --&gt;
-   &lt;/biblioentry&gt;
- 
-   &lt;biblioentry&gt;
-    &lt;abbrev&gt;pooma-siam98&lt;/abbrev&gt;
-    &lt;authorgroup&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Julian&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;C.&lt;/othername&gt;&lt;surname&gt;Cummings&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;James&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;A.&lt;/othername&gt;&lt;surname&gt;Crotinger&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Scott&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;W.&lt;/othername&gt;&lt;surname&gt;Haney&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;William&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;F.&lt;/othername&gt;&lt;surname&gt;Humphrey&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Steve&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;R.&lt;/othername&gt;&lt;surname&gt;Karmesin&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;John&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;V. W.&lt;/othername&gt;&lt;surname&gt;Reynders&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Stephen&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;A.&lt;/othername&gt;&lt;surname&gt;Smith&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Timothy&lt;/firstname&gt;&lt;othername role=&quot;mi&quot;&gt;J.&lt;/othername&gt;&lt;surname&gt;Williams&lt;/surname&gt;
-      &lt;affiliation&gt;
-       &lt;orgname&gt;Los Alamos National Laboratory&lt;/orgname&gt;
-       &lt;address&gt;&lt;city&gt;Los Alamos&lt;/city&gt;&lt;state&gt;NM&lt;/state&gt;&lt;/address&gt;
-      &lt;/affiliation&gt;
-     &lt;/author&gt;
-    &lt;/authorgroup&gt;
-    &lt;title&gt;Raid Application Development and Enhanced Code
-    Interoperability using the &pooma; Framework&lt;/title&gt;
- &lt;!-- FIXME: Where list SIAM Workshop ... 1998? --&gt;
-   &lt;/biblioentry&gt;
- 
-   &lt;biblioentry&gt;
- &lt;!-- FIXME: Change the year when we learn it. --&gt;
-    &lt;abbrev&gt;pete-99&lt;/abbrev&gt;
-    &lt;authorgroup&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Scott&lt;/firstname&gt;&lt;surname&gt;Haney&lt;/surname&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;James&lt;/firstname&gt;&lt;surname&gt;Crotinger&lt;/surname&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Steve&lt;/firstname&gt;&lt;surname&gt;Karmesin&lt;/surname&gt;
-     &lt;/author&gt;
-     &lt;author&gt;
-      &lt;firstname&gt;Stephen&lt;/firstname&gt;&lt;surname&gt;Smith&lt;/surname&gt;
-     &lt;/author&gt;
-    &lt;/authorgroup&gt;
-    &lt;title&gt;Easy Expression Templates Using &pete;: The Portable
-    Expression Template Engine&lt;/title&gt;
- &lt;!-- FIXME: When and where was this published? --&gt;
-   &lt;/biblioentry&gt;
-  &lt;/bibliography&gt;
  
  
   &amp;glossary-chapter; 
  
--- 5161,5168 ----
  
   &lt;/appendix&gt;
  
  
+  &amp;bibliography-chapter;
  
   &amp;glossary-chapter; 
  
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.3
diff -c -p -r1.3 tutorial.xml
*** tutorial.xml	2001/12/17 17:27:42	1.3
--- tutorial.xml	2002/01/04 17:14:11
***************
*** 54,60 ****
      &lt;imagedata fileref=&quot;figures/doof2d.201&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
     &lt;/imageobject&gt;
     &lt;textobject&gt;
!     &lt;phrase&gt;The Initial Configuration&lt;/phrase&gt;
     &lt;/textobject&gt;
    &lt;/mediaobject&gt;
    &lt;mediaobject&gt;
--- 54,60 ----
      &lt;imagedata fileref=&quot;figures/doof2d.201&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
     &lt;/imageobject&gt;
     &lt;textobject&gt;
!     &lt;phrase&gt;The Initial &amp;doof2d; Configuration&lt;/phrase&gt;
     &lt;/textobject&gt;
    &lt;/mediaobject&gt;
    &lt;mediaobject&gt;
***************
*** 476,482 ****
       &lt;imagedata fileref=&quot;figures/doof2d.210&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
      &lt;/imageobject&gt;
      &lt;textobject&gt;
!      &lt;phrase&gt;Adding two arrays with different domains.&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
       &lt;para&gt;When adding arrays, values in corresponding positions are
--- 476,482 ----
       &lt;imagedata fileref=&quot;figures/doof2d.210&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
      &lt;/imageobject&gt;
      &lt;textobject&gt;
!      &lt;phrase&gt;Adding two arrays with different domains is supported.&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
       &lt;para&gt;When adding arrays, values in corresponding positions are
***************
*** 587,593 ****
       &lt;imagedata fileref=&quot;figures/doof2d.211&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
      &lt;/imageobject&gt;
      &lt;textobject&gt;
!      &lt;phrase&gt;Apply a stencil to position (1,3) of an array.&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
       &lt;para&gt;To compute the value associated with index position (1,3)
--- 587,593 ----
       &lt;imagedata fileref=&quot;figures/doof2d.211&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
      &lt;/imageobject&gt;
      &lt;textobject&gt;
!      &lt;phrase&gt;Apply a stencil to position (1,3) of an &array;.&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
       &lt;para&gt;To compute the value associated with index position (1,3)
***************
*** 692,698 ****
       &lt;imagedata fileref=&quot;figures/distributed.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
      &lt;/imageobject&gt;
      &lt;textobject&gt;
!      &lt;phrase&gt;the &pooma; distributed computation model.&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
       &lt;para&gt;The &pooma; distributed computation model combines
--- 692,698 ----
       &lt;imagedata fileref=&quot;figures/distributed.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
      &lt;/imageobject&gt;
      &lt;textobject&gt;
!      &lt;phrase&gt;the &pooma; distributed computation model&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
       &lt;para&gt;The &pooma; distributed computation model combines
Index: figures/box-macros.mp
===================================================================
RCS file: box-macros.mp
diff -N box-macros.mp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- box-macros.mp	Fri Jan  4 10:14:11 2002
***************
*** 0 ****
--- 1,106 ----
+ %% Oldham, Jeffrey D.
+ %% 2001Dec20
+ %% Pooma
+ 
+ %% Macros to Improve Boxes
+ 
+ %% Assumes 'input boxes;'
+ 
+   % Ensure a list of boxes all have the same width.
+   % input &lt;- suffixes for the boxes;
+   % output-&gt; all boxes have the same width (maximum picture width + defaultdx)
+   vardef samewidth(suffix $)(text t) =
+     save p_; pair p_;
+     p_ = maxWidthAndHeight($)(t);
+     numericSetWidth(xpart(p_)+2defaultdx)($)(t);
+   enddef;
+   
+   % Ensure a list of boxes all have the same height.
+   % input &lt;- suffixes for the boxes;
+   % output-&gt; all boxes have the same height (maximum picture height + defaultdy)
+   vardef sameheight(suffix $)(text t) =
+     save p_; pair p_;
+     p_ = maxWidthAndHeight($)(t);
+     numericSetWidth(ypart(p_)+2defaultdy)($)(t);
+   enddef;
+   
+   % Given a list of boxes, determine the maximum picture width and
+   % maximum picture height.
+   % input &lt;- suffixes for the boxes
+   % output-&gt; pair of maximum picture width and height
+   vardef maxWidthAndHeight(suffix f)(text t) =
+     save w_, h_; numeric w_, h_;
+     w_ = xpart((urcorner pic_.f - llcorner pic_.f));
+     h_ = ypart((urcorner pic_.f - llcorner pic_.f));
+     forsuffixes uu = t:
+       if xpart((urcorner pic_.uu - llcorner pic_.uu)) &gt; w_ :
+ 	w_ := xpart((urcorner pic_.uu - llcorner pic_.uu));
+       fi
+       if ypart((urcorner pic_.uu - llcorner pic_.uu)) &gt; h_ :
+ 	h_ := ypart((urcorner pic_.uu - llcorner pic_.uu));
+       fi
+     endfor
+     (w_, h_)
+   enddef;
+ 
+   % Given a width, ensure a box has the given width.
+   % input &lt;- box width
+   %          suffix for the one box
+   % output-&gt; the box has the given width by setting its .dx
+   vardef numericSetWidthOne(expr width)(suffix f) =
+     f.dx = 0.5(width - xpart(urcorner pic_.f - llcorner pic_.f));
+   enddef;
+   
+   % Given a width, ensure all boxes have the given width.
+   % input &lt;- box width
+   %          suffixes for the boxes
+   % output-&gt; all boxes have the given width by setting their .dx
+   vardef numericSetWidth(expr width)(suffix f)(text t) =
+     f.dx = 0.5(width - xpart(urcorner pic_.f - llcorner pic_.f));
+     forsuffixes $ = t:
+       $.dx = 0.5(width - xpart(urcorner pic_.$ - llcorner pic_.$));
+     endfor
+   enddef;
+ 
+   % Given a height, ensure all boxes have the given height.
+   % input &lt;- box height
+   %          suffixes for the boxes
+   % output-&gt; all boxes have the given height by setting their .dx
+   vardef numericSetHeight(expr height)(suffix f)(text t) =
+     f.dy = 0.5(height - ypart(urcorner pic_.f - llcorner pic_.f));
+     forsuffixes $ = t:
+       $.dy = 0.5(height - ypart(urcorner pic_.$ - llcorner pic_.$));
+     endfor
+   enddef;
+   
+   % Ensure a list of boxes and circles all to have the same width, height,
+   % and diameter.
+   % input &lt;- suffixes for the boxes and circles
+   % output-&gt; all boxes have .dx and .dy set so they have the same width,
+   %           height, and radius
+   % The boxes are squares and the circles are circular, not oval.
+   vardef sameWidthAndHeight(suffix f)(text t) =
+     save p_; pair p_;
+     p_ = maxWidthAndHeight(f)(t);
+     if (xpart(p_)+2defaultdx &gt;= ypart(p_)+2defaultdy):
+       numericSetWidth(xpart(p_)+2defaultdx)(f)(t);
+       numericSetHeight(xpart(p_)+2defaultdx)(f)(t);
+     else:
+       numericSetWidth(ypart(p_)+2defaultdy)(f)(t);
+       numericSetHeight(ypart(p_)+2defaultdy)(f)(t);
+     fi
+   enddef;
+ 
+   % Ensure a list of boxes and circles all to have the same width and
+   % the same height.  Unlike sameWidthAndHeight, the width and height
+   % can differ.
+   % input &lt;- suffixes for the boxes and circles
+   % output-&gt; all boxes have .dx and .dy set so they have the same width,
+   %           height, and radius
+   % The boxes are squares and the circles are circular, not oval.
+   vardef sameWidthSameHeight(suffix f)(text t) =
+     save p_; pair p_;
+     p_ = maxWidthAndHeight(f)(t);
+     numericSetWidth(xpart(p_)+2defaultdx)(f)(t);
+     numericSetHeight(ypart(p_)+2defaultdy)(f)(t);
+   enddef;
Index: figures/data-parallel.mp
===================================================================
RCS file: data-parallel.mp
diff -N data-parallel.mp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- data-parallel.mp	Fri Jan  4 10:14:11 2002
***************
*** 0 ****
--- 1,157 ----
+ %% Oldham, Jeffrey D.
+ %% 2001Dec20
+ %% Pooma
+ 
+ %% Illustrations for the Data-Parallel Chapter
+ 
+ %% Assumes TEX=latex.
+ 
+ input boxes;
+ input box-macros;
+ input grid-macros;
+ 
+ verbatimtex
+ \documentclass[10pt]{article}
+ \input{macros.ltx}
+ \begin{document}
+ etex
+ 
+ %% Parse Tree for Example Statement A += -A + 2*B
+ beginfig(101)
+   numeric unit; unit = 1.5cm;
+   numeric xunit; xunit = unit;
+   numeric yunit; yunit = unit;
+   
+   %% Create the tree nodes.
+   circleit.b0(btex \statement{+=} etex);
+   circleit.b1(btex \varname{A} etex);
+   circleit.b2(btex \statement{+} etex);
+   circleit.b3(btex \statement{-} etex);
+   circleit.b4(btex \varname{A} etex);
+   circleit.b5(btex \statement{*} etex);
+   circleit.b6(btex \statement{2} etex);
+   circleit.b7(btex \varname{B} etex);
+   numeric nuBoxes; nuBoxes = 7;
+   sameWidthAndHeight(b0,b1,b2,b3,b4,b5,b6,b7);
+   
+   %% Position the tree nodes.
+   b2.c = origin;
+   b0.c - 0.5[b1.c,b2.c] = (0,yunit);
+   b2.c - 0.5[b3.c,b5.c] = (0,yunit);
+   b3.c - 0.5[b4.c,b6.c] = (0,yunit);
+   b5.c - 0.5[b6.c,b7.c] = (0,yunit);
+   b1.c - b2.c = b3.c - b5.c = b4.c - b6.c = b6.c - b8.c = (-xunit,0);
+   
+   %% Draw the tree.
+   for t = 2 upto 7:
+     drawboxed(b[t]);
+   endfor
+   vardef drawEdge(expr start, stop) =
+     draw b[start].c -- b[stop].c cutbefore bpath b[start] cutafter bpath b[stop];
+   enddef;
+   for t = (2,3), (2,5), (3,4), (5,6), (5,7):
+     drawEdge(xpart(t),ypart(t));
+   endfor
+ 
+   %% Label the node's types.
+ % TMP  label.rt(btex \type{OpAddAssign} etex, b0.e);
+ % TMP  label.rt(btex \type{Expression} etex, 0.5[b0.c,b2.c]);
+   label.top(btex \type{Expression} etex, b2.n);
+ % TMP  label.lft(btex \type{Ar} etex, b1.w);
+   label.rt(btex \type{BinaryNode&lt;OpAdd,} etex, b2.e);
+   label.lft(btex \type{UnaryNode&lt;OpMinus,} etex, b3.w);
+   label.lft(btex \type{Ar} etex, b4.w);
+   label.rt(btex \type{BinaryNode&lt;OpMultiply,} etex, b5.e);
+   label.bot(btex \type{Scalar&lt;int&gt;} etex, b6.s);
+   label.rt(btex \type{Ar} etex, b7.e);
+   
+ endfig;
+ 
+ 
+ %% An illustratation of the addition of arrays.
+ beginfig(212)
+   numeric unit; unit = 0.9cm;	% width or height of an individual grid cell
+   numeric nuCells; nuCells = 5;	% number of cells in each dimension
+ 				% This number should be odd.
+   numeric nuArrayCells; nuArrayCells = 3;
+ 				% number of cells in array in each dimension
+   numeric operatorWidth; operatorWidth = 1.5;
+   				% horizontal space for an operator as
+   				% a multiple of &quot;unit&quot;
+   
+   %% Determine the locations of the arrays.
+   z0 = origin;
+   z1 = z0 + unit * (nuCells+operatorWidth,0);
+   z2 - z1 = z1 - z0;
+ 
+   %% Draw the grid cells and the operators.
+   for t = 0 upto 2:
+     drawGridDashed(nuCells, unit, z[t]);
+   endfor
+   for t = 0 upto 1:
+     drawGrid(nuArrayCells, unit, z[t]+unit*(1,1));
+   endfor
+   drawGrid(nuArrayCells, unit, z2+unit*(2,0));
+  
+   label(btex = etex, z1 + unit*(-0.6operatorWidth, 0.5nuCells));
+   label(btex + etex, z2 + unit*(-0.6operatorWidth, 0.5nuCells));
+   
+   %% Label the indices.
+   % Label b(I,J) grid indices.
+   for t = 0 upto 2:
+     labelCellBottom(btex \footnotesize 0 etex, (0,0), z[t]);
+     labelCellBottom(btex \footnotesize 1 etex, (1,0), z[t]);
+     labelCellBottom(btex \footnotesize 2 etex, (2,0), z[t]);
+     labelCellBottom(btex \footnotesize 3 etex, (3,0), z[t]);
+     labelCellBottom(btex \footnotesize 4 etex, (4,0), z[t]);
+     labelCellLeft(btex \footnotesize 0 etex, (0,0), z[t]);
+     labelCellLeft(btex \footnotesize 1 etex, (0,1), z[t]);
+     labelCellLeft(btex \footnotesize 2 etex, (0,2), z[t]);
+     labelCellLeft(btex \footnotesize 3 etex, (0,3), z[t]);
+     labelCellLeft(btex \footnotesize 4 etex, (0,4), z[t]);
+   endfor
+   
+   %% Label the grid cells' values.
+   % Label b(I,J) grid values.
+   pair zShift;
+   zShift := z1 + unit*(1,1);
+   labelCell(btex \normalsize 9 etex, (0,0), zShift);
+   labelCell(btex \normalsize 11 etex, (1,0), zShift);
+   labelCell(btex \normalsize 13 etex, (2,0), zShift);
+   labelCell(btex \normalsize 17 etex, (0,1), zShift);
+   labelCell(btex \normalsize 19 etex, (1,1), zShift);
+   labelCell(btex \normalsize 21 etex, (2,1), zShift);
+   labelCell(btex \normalsize 25 etex, (0,2), zShift);
+   labelCell(btex \normalsize 27 etex, (1,2), zShift);
+   labelCell(btex \normalsize 29 etex, (2,2), zShift);
+   % Label b(I+1,J-1) grid values.
+   zShift := z2 + unit*(2,0);
+   labelCell(btex \normalsize 3 etex, (0,0), zShift);
+   labelCell(btex \normalsize 5 etex, (1,0), zShift);
+   labelCell(btex \normalsize 7 etex, (2,0), zShift);
+   labelCell(btex \normalsize 11 etex, (0,1), zShift);
+   labelCell(btex \normalsize 13 etex, (1,1), zShift);
+   labelCell(btex \normalsize 15 etex, (2,1), zShift);
+   labelCell(btex \normalsize 19 etex, (0,2), zShift);
+   labelCell(btex \normalsize 21 etex, (1,2), zShift);
+   labelCell(btex \normalsize 23 etex, (2,2), zShift);
+   % Label b(I,J)+b(I+1,J-1) grid values.
+   zShift := z0 + unit*(1,1);
+   labelCell(btex \normalsize 9 etex, (0,0), zShift);
+   labelCell(btex \normalsize 22 etex, (1,0), zShift);
+   labelCell(btex \normalsize 26 etex, (2,0), zShift);
+   labelCell(btex \normalsize 17 etex, (0,1), zShift);
+   labelCell(btex \normalsize 38 etex, (1,1), zShift);
+   labelCell(btex \normalsize 42 etex, (2,1), zShift);
+   labelCell(btex \normalsize 25 etex, (0,2), zShift);
+   labelCell(btex \normalsize 27 etex, (1,2), zShift);
+   labelCell(btex \normalsize 29 etex, (2,2), zShift);
+ 
+   %% Label the grids.
+   labelGrid(btex $A+B$ etex, nuCells, z0);
+   labelGrid(btex $A$ etex, nuCells, z1);
+   labelGrid(btex $B$ etex, nuCells, z2);
+ endfig;
+ 
+ 
+ bye
Index: figures/doof2d.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/doof2d.mp,v
retrieving revision 1.2
diff -c -p -r1.2 doof2d.mp
*** figures/doof2d.mp	2001/12/11 20:36:13	1.2
--- figures/doof2d.mp	2002/01/04 17:14:11
*************** verbatimtex
*** 12,46 ****
  \begin{document}
  etex
  
! % Draw a set of grid cells.
! vardef drawGrid(expr nuCells, unit, llCorner) =
!   for i = 0 upto nuCells-1:
!     for j = 0 upto nuCells-1:
!       draw unitsquare scaled unit shifted (llCorner + unit*(i,j));
!     endfor
!   endfor
! enddef;
! 
! % Label the specified grid, grid cell, or its edge.
! % Place a value at the center of a grid cell.
! vardef labelCell(expr lbl, xy, llCorner) =
!   label(lbl, llCorner + unit*(xy + 0.5*(1,1)));
! enddef;
! 
! % Label the bottom of a grid cell.
! vardef labelCellBottom(expr lbl, xy, llCorner) =
!   label.bot(lbl, llCorner + unit*(xy + 0.5*(1,0)));
! enddef;
! 
! % Label the left side of a grid cell.
! vardef labelCellLeft(expr lbl, xy, llCorner) =
!   label.lft(lbl, llCorner + unit*(xy + 0.5*(0,1)));
! enddef;
! 
! % Label the top of a grid.
! vardef labelGrid(expr lbl, nuCells, llCorner) =
!   label.top(lbl, llCorner + unit*(nuCells/2,nuCells));
! enddef;
  
  %% Global Declarations
  numeric unit; unit = 0.9cm;	% width or height of an individual grid cell
--- 12,18 ----
  \begin{document}
  etex
  
! input grid-macros;
  
  %% Global Declarations
  numeric unit; unit = 0.9cm;	% width or height of an individual grid cell
Index: figures/grid-macros.mp
===================================================================
RCS file: grid-macros.mp
diff -N grid-macros.mp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- grid-macros.mp	Fri Jan  4 10:14:11 2002
***************
*** 0 ****
--- 1,45 ----
+ %% Oldham, Jeffrey D.
+ %% 2001Dec21
+ %% Pooma
+ 
+ %% Macros for Drawing Grids
+ 
+ % Draw a set of grid cells.
+ vardef drawGrid(expr nuCells, unit, llCorner) =
+   for i = 0 upto nuCells-1:
+     for j = 0 upto nuCells-1:
+       draw unitsquare scaled unit shifted (llCorner + unit*(i,j));
+     endfor
+   endfor
+ enddef;
+ 
+ % Draw a set of grid cells with dashed lines.
+ vardef drawGridDashed(expr nuCells, unit, llCorner) =
+   for i = 0 upto nuCells-1:
+     for j = 0 upto nuCells-1:
+       draw unitsquare scaled unit shifted (llCorner + unit*(i,j)) dashed evenly;
+     endfor
+   endfor
+ enddef;
+ 
+ % Label the specified grid, grid cell, or its edge.
+ % Place a value at the center of a grid cell.
+ vardef labelCell(expr lbl, xy, llCorner) =
+   label(lbl, llCorner + unit*(xy + 0.5*(1,1)));
+ enddef;
+ 
+ % Label the bottom of a grid cell.
+ vardef labelCellBottom(expr lbl, xy, llCorner) =
+   label.bot(lbl, llCorner + unit*(xy + 0.5*(1,0)));
+ enddef;
+ 
+ % Label the left side of a grid cell.
+ vardef labelCellLeft(expr lbl, xy, llCorner) =
+   label.lft(lbl, llCorner + unit*(xy + 0.5*(0,1)));
+ enddef;
+ 
+ % Label the top of a grid.
+ vardef labelGrid(expr lbl, nuCells, llCorner) =
+   label.top(lbl, llCorner + unit*(nuCells/2,nuCells));
+ enddef;
+ 
Index: figures/introduction.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/introduction.mp,v
retrieving revision 1.1
diff -c -p -r1.1 introduction.mp
*** figures/introduction.mp	2001/12/17 17:27:42	1.1
--- figures/introduction.mp	2002/01/04 17:14:11
***************
*** 7,12 ****
--- 7,13 ----
  %% Assumes TEX=latex.
  
  input boxes;
+ input box-macros;
  
  verbatimtex
  \documentclass[10pt]{article}
*************** beginfig(101)
*** 21,125 ****
    numeric horizSpace; horizSpace = 8unit;
    numeric vertSpace; vertSpace = unit;
    numeric nuBoxes;		% number of boxes
- 
-   % Ensure a list of boxes all have the same width.
-   % input &lt;- suffixes for the boxes;
-   % output-&gt; all boxes have the same width (maximum picture width + defaultdx)
-   vardef samewidth(suffix $)(text t) =
-     save p_; pair p_;
-     p_ = maxWidthAndHeight($)(t);
-     numericSetWidth(xpart(p_)+2defaultdx)($)(t);
-   enddef;
-   
-   % Ensure a list of boxes all have the same height.
-   % input &lt;- suffixes for the boxes;
-   % output-&gt; all boxes have the same height (maximum picture height + defaultdy)
-   vardef sameheight(suffix $)(text t) =
-     save p_; pair p_;
-     p_ = maxWidthAndHeight($)(t);
-     numericSetWidth(ypart(p_)+2defaultdy)($)(t);
-   enddef;
-   
-   % Given a list of boxes, determine the maximum picture width and
-   % maximum picture height.
-   % input &lt;- suffixes for the boxes
-   % output-&gt; pair of maximum picture width and height
-   vardef maxWidthAndHeight(suffix f)(text t) =
-     save w_, h_; numeric w_, h_;
-     w_ = xpart((urcorner pic_.f - llcorner pic_.f));
-     h_ = ypart((urcorner pic_.f - llcorner pic_.f));
-     forsuffixes uu = t:
-       if xpart((urcorner pic_.uu - llcorner pic_.uu)) &gt; w_ :
- 	w_ := xpart((urcorner pic_.uu - llcorner pic_.uu));
-       fi
-       if ypart((urcorner pic_.uu - llcorner pic_.uu)) &gt; h_ :
- 	h_ := ypart((urcorner pic_.uu - llcorner pic_.uu));
-       fi
-     endfor
-     (w_, h_)
-   enddef;
- 
-   % Given a width, ensure a box has the given width.
-   % input &lt;- box width
-   %          suffix for the one box
-   % output-&gt; the box has the given width by setting its .dx
-   vardef numericSetWidthOne(expr width)(suffix f) =
-     f.dx = 0.5(width - xpart(urcorner pic_.f - llcorner pic_.f));
-   enddef;
-   
-   % Given a width, ensure all boxes have the given width.
-   % input &lt;- box width
-   %          suffixes for the boxes
-   % output-&gt; all boxes have the given width by setting their .dx
-   vardef numericSetWidth(expr width)(suffix f)(text t) =
-     f.dx = 0.5(width - xpart(urcorner pic_.f - llcorner pic_.f));
-     forsuffixes $ = t:
-       $.dx = 0.5(width - xpart(urcorner pic_.$ - llcorner pic_.$));
-     endfor
-   enddef;
- 
-   % Given a height, ensure all boxes have the given height.
-   % input &lt;- box height
-   %          suffixes for the boxes
-   % output-&gt; all boxes have the given height by setting their .dx
-   vardef numericSetHeight(expr height)(suffix f)(text t) =
-     f.dy = 0.5(height - ypart(urcorner pic_.f - llcorner pic_.f));
-     forsuffixes $ = t:
-       $.dy = 0.5(height - ypart(urcorner pic_.$ - llcorner pic_.$));
-     endfor
-   enddef;
-   
-   % Ensure a list of boxes and circles all to have the same width, height,
-   % and diameter.
-   % input &lt;- suffixes for the boxes and circles
-   % output-&gt; all boxes have .dx and .dy set so they have the same width,
-   %           height, and radius
-   % The boxes are squares and the circles are circular, not oval.
-   vardef sameWidthAndHeight(suffix f)(text t) =
-     save p_; pair p_;
-     p_ = maxWidthAndHeight(f)(t);
-     if (xpart(p_)+2defaultdx &gt;= ypart(p_)+2defaultdy):
-       numericSetWidth(xpart(p_)+2defaultdx)(f)(t);
-       numericSetHeight(xpart(p_)+2defaultdx)(f)(t);
-     else:
-       numericSetWidth(ypart(p_)+2defaultdy)(f)(t);
-       numericSetHeight(ypart(p_)+2defaultdy)(f)(t);
-     fi
-   enddef;
- 
-   % Ensure a list of boxes and circles all to have the same width and
-   % the same height.  Unlike sameWidthAndHeight, the width and height
-   % can differ.
-   % input &lt;- suffixes for the boxes and circles
-   % output-&gt; all boxes have .dx and .dy set so they have the same width,
-   %           height, and radius
-   % The boxes are squares and the circles are circular, not oval.
-   vardef sameWidthSameHeight(suffix f)(text t) =
-     save p_; pair p_;
-     p_ = maxWidthAndHeight(f)(t);
-     numericSetWidth(xpart(p_)+2defaultdx)(f)(t);
-     numericSetHeight(ypart(p_)+2defaultdy)(f)(t);
-   enddef;
  
    % Create the boxes.
    boxit.b0(btex \textsl{science / math} etex);
--- 22,27 ----
Index: programs/Doof2d-Array-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Array-distributed-annotated.patch
diff -N Doof2d-Array-distributed-annotated.patch
*** /tmp/cvsKKb5AR	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,184 ****
- *** Doof2d-Array-distributed.cpp	Wed Dec  5 14:04:36 2001
- --- Doof2d-Array-distributed-annotated.cpp	Wed Dec  5 14:07:56 2001
- ***************
- *** 1,3 ****
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include &quot;Pooma/Arrays.h&quot;	// has Pooma's Array
-   
- --- 1,5 ----
- ! &lt;programlisting id=&quot;tutorial-array_distributed-doof2d-program&quot; linenumbering=&quot;numbered&quot; format=&quot;linespecific&quot;&gt;
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include &quot;Pooma/Arrays.h&quot;	// has Pooma's Array
-   
- ***************
- *** 14,18 ****
-     // (i,j).  The &quot;C&quot; template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- --- 16,20 ----
-     // (i,j).  The &quot;C&quot; template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 42,46 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 44,48 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  &lt;co id=&quot;tutorial-array_distributed-doof2d-io&quot;&gt;&lt;/co&gt;
-     Inform output;
-   
- ***************
- *** 48,52 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &lt;&lt; argv[0] &lt;&lt; &quot;: number-of-processors number-of-averagings number-of-values&quot; &lt;&lt; std::endl;
-       return EXIT_FAILURE;
-     }
- --- 50,54 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &lt;&lt; argv[0] &lt;&lt; &quot;: number-of-processors number-of-averagings number-of-values&quot; &lt;&lt; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 55,63 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 57,65 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 65,69 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 67,71 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 71,80 ****
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- --- 73,82 ----
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- ***************
- *** 83,98 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // The template parameters indicate 2 dimensions and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; b(layout);
-   
-     // Set up the initial conditions.
- --- 85,100 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.  &lt;co id=&quot;tutorial-array_distributed-doof2d-layout&quot;&gt;&lt;/co&gt;
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // The template parameters indicate 2 dimensions and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  &lt;co id=&quot;tutorial-array_distributed-doof2d-remote&quot;&gt;&lt;/co&gt;
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; b(layout);
-   
-     // Set up the initial conditions.
- ***************
- *** 104,112 ****
-   
-     // Create the stencil performing the computation.
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 106,114 ----
-   
-     // Create the stencil performing the computation.
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  &lt;co id=&quot;tutorial-array_distributed-doof2d-first_write&quot;&gt;&lt;/co&gt;
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 117,121 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 119,123 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 125,126 ****
- --- 127,129 ----
-     return EXIT_SUCCESS;
-   }
- + &lt;/programlisting&gt;
--- 0 ----
Index: programs/Doof2d-Array-element-annotated.patch
===================================================================
RCS file: Doof2d-Array-element-annotated.patch
diff -N Doof2d-Array-element-annotated.patch
*** /tmp/cvslmAiwW	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,143 ****
- *** Doof2d-Array-element.cpp	Tue Dec  4 12:02:10 2001
- --- Doof2d-Array-element-annotated.cpp	Tue Dec  4 12:24:25 2001
- ***************
- *** 1,5 ****
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include &quot;Pooma/Arrays.h&quot;	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, element-wise implementation
- --- 1,6 ----
- ! &lt;programlisting id=&quot;tutorial-array_elementwise-doof2d-program&quot; linenumbering=&quot;numbered&quot; format=&quot;linespecific&quot;&gt;
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include &quot;Pooma/Arrays.h&quot;	// has Pooma's Array  &lt;co id=&quot;tutorial-array_elementwise-doof2d-header&quot;&gt;&lt;/co&gt;
-   
-   // Doof2d: Pooma Arrays, element-wise implementation
- ***************
- *** 7,17 ****
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the Pooma library for execution.
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; &quot;Please enter the number of averagings: &quot;;
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 8,18 ----
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the Pooma library for execution.  &lt;co id=&quot;tutorial-array_elementwise-doof2d-pooma_initialize&quot;&gt;&lt;/co&gt;
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; &quot;Please enter the number of averagings: &quot;;
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,37 ****
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; &quot;Please enter the array size: &quot;;
- !   std::cin &gt;&gt; n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
-     for (int j = 1; j &lt; n-1; j++)
-       for (int i = 1; i &lt; n-1; i++)
- --- 20,38 ----
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; &quot;Please enter the array size: &quot;;
- !   std::cin &gt;&gt; n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).  &lt;co id=&quot;tutorial-array_elementwise-doof2d-domain&quot;&gt;&lt;/co&gt;
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Create the arrays.  &lt;co id=&quot;tutorial-array_elementwise-doof2d-array_creation&quot;&gt;&lt;/co&gt;
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  &lt;co id=&quot;tutorial-array_elementwise-doof2d-initialization&quot;&gt;&lt;/co&gt;
-     for (int j = 1; j &lt; n-1; j++)
-       for (int i = 1; i &lt; n-1; i++)
- ***************
- *** 43,51 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
- !         a(i,j) = weight *
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- --- 44,52 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
- !         a(i,j) = weight *  &lt;co id=&quot;tutorial-array_elementwise-doof2d-first_write&quot;&gt;&lt;/co&gt;
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- ***************
- *** 53,58 ****
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- --- 54,59 ----
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- ***************
- *** 62,71 ****
-   
-     // Print out the final central value.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
- !   // The arrays are automatically deallocated.
-   
- !   // Tell the Pooma library execution has finished.
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- --- 63,74 ----
-   
-     // Print out the final central value.
- !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
- !   // The arrays are automatically deallocated.  &lt;co id=&quot;tutorial-array_elementwise-doof2d-deallocation&quot;&gt;&lt;/co&gt;
-   
- !   // Tell the Pooma library execution has finished.  &lt;co id=&quot;tutorial-array_elementwise-doof2d-pooma_finish&quot;&gt;&lt;/co&gt;
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- + &lt;/programlisting&gt;
--- 0 ----
Index: programs/Doof2d-Array-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Array-parallel-annotated.patch
diff -N Doof2d-Array-parallel-annotated.patch
*** /tmp/cvsuReKr3	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,116 ****
- *** Doof2d-Array-parallel.cpp	Tue Dec  4 11:49:43 2001
- --- Doof2d-Array-parallel-annotated.cpp	Tue Dec  4 12:24:36 2001
- ***************
- *** 1,4 ****
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include &quot;Pooma/Arrays.h&quot;	// has Pooma's Array
-   
- --- 1,5 ----
- ! &lt;programlisting id=&quot;tutorial-array_parallel-doof2d-program&quot; linenumbering=&quot;numbered&quot; format=&quot;linespecific&quot;&gt;
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include &quot;Pooma/Arrays.h&quot;	// has Pooma's Array
-   
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; &quot;Please enter the number of averagings: &quot;;
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; &quot;Please enter the number of averagings: &quot;;
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,43 ****
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; &quot;Please enter the array size: &quot;;
- !   std::cin &gt;&gt; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- --- 20,44 ----
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; &quot;Please enter the array size: &quot;;
- !   std::cin &gt;&gt; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.  &lt;co id=&quot;tutorial-array_parallel-doof2d-innerdomain&quot;&gt;&lt;/co&gt;
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.  &lt;co id=&quot;tutorial-array_parallel-doof2d-blockAndEvaluate&quot;&gt;&lt;/co&gt;
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- ***************
- *** 47,52 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 48,53 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  &lt;co id=&quot;tutorial-array_parallel-doof2d-first_write&quot;&gt;&lt;/co&gt;
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 63,67 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 64,68 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 71,72 ****
- --- 72,74 ----
-     return EXIT_SUCCESS;
-   }
- + &lt;/programlisting&gt;
--- 0 ----
Index: programs/Doof2d-Array-stencil-annotated.patch
===================================================================
RCS file: Doof2d-Array-stencil-annotated.patch
diff -N Doof2d-Array-stencil-annotated.patch
*** /tmp/cvsLwSPO9	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,152 ****
- *** Doof2d-Array-stencil.cpp	Tue Dec  4 11:49:39 2001
- --- Doof2d-Array-stencil-annotated.cpp	Tue Dec  4 12:26:46 2001
- ***************
- *** 1,9 ****
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include &quot;Pooma/Arrays.h&quot;	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.
-   class DoofNinePt
-   {
- --- 1,10 ----
- ! &lt;programlisting id=&quot;tutorial-array_stencil-doof2d-program&quot; linenumbering=&quot;numbered&quot; format=&quot;linespecific&quot;&gt;
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include &quot;Pooma/Arrays.h&quot;	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.  &lt;co id=&quot;tutorial-array_stencil-doof2d-stencil&quot;&gt;&lt;/co&gt;
-   class DoofNinePt
-   {
- ***************
- *** 14,19 ****
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The &quot;C&quot; template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- --- 15,20 ----
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The &quot;C&quot; template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.  &lt;co id=&quot;tutorial-array_stencil-doof2d-stencil_operator&quot;&gt;&lt;/co&gt;
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 26,30 ****
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }
-     inline int upperExtent(int) const { return 1; }
-   
- --- 27,31 ----
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }  &lt;co id=&quot;tutorial-array_stencil-doof2d-stencil_extent&quot;&gt;&lt;/co&gt;
-     inline int upperExtent(int) const { return 1; }
-   
- ***************
- *** 42,47 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; &quot;Please enter the number of averagings: &quot;;
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 43,48 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; &quot;Please enter the number of averagings: &quot;;
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 49,68 ****
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; &quot;Please enter the array size: &quot;;
- !   std::cin &gt;&gt; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- --- 50,69 ----
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; &quot;Please enter the array size: &quot;;
- !   std::cin &gt;&gt; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- ***************
- *** 73,82 ****
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 74,83 ----
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.  &lt;co id=&quot;tutorial-array_stencil-doof2d-stencil_creation&quot;&gt;&lt;/co&gt;
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  &lt;co id=&quot;tutorial-array_stencil-doof2d-first_write&quot;&gt;&lt;/co&gt;
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 87,91 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 88,92 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 95,96 ****
- --- 96,98 ----
-     return EXIT_SUCCESS;
-   }
- + &lt;/programlisting&gt;
--- 0 ----
Index: programs/Doof2d-C-element-annotated.patch
===================================================================
RCS file: Doof2d-C-element-annotated.patch
diff -N Doof2d-C-element-annotated.patch
*** /tmp/cvs2hDHVf	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,150 ****
- *** Doof2d-C-element.cpp	Tue Nov 27 08:36:38 2001
- --- Doof2d-C-element-annotated.cpp	Tue Nov 27 12:08:03 2001
- ***************
- *** 1,4 ****
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- --- 1,5 ----
- ! &lt;programlisting id=&quot;tutorial-hand_coded-doof2d-program&quot; linenumbering=&quot;numbered&quot; format=&quot;linespecific&quot;&gt;
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- ***************
- *** 6,30 ****
-   int main()
-   {
- !   // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; &quot;Please enter the number of averagings: &quot;;
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of elements along one dimension of
- !   // the grid.
-     long n;
- !   std::cout &lt;&lt; &quot;Please enter the array size: &quot;;
- !   std::cin &gt;&gt; n;
-   
- !   // Allocate the arrays.
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i &lt; n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- --- 7,31 ----
-   int main()
-   {
- !   // Ask the user for the number of averagings.  &lt;co id=&quot;tutorial-hand_coded-doof2d-nuaveragings&quot;&gt;&lt;/co&gt;
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; &quot;Please enter the number of averagings: &quot;;
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.  &lt;co id=&quot;tutorial-hand_coded-doof2d-array_storage&quot;&gt;&lt;/co&gt;
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of elements along one dimension of
- !   // the grid.  &lt;co id=&quot;tutorial-hand_coded-doof2d-grid_size&quot;&gt;&lt;/co&gt;
-     long n;
- !   std::cout &lt;&lt; &quot;Please enter the array size: &quot;;
- !   std::cin &gt;&gt; n;
-   
- !   // Allocate the arrays.  &lt;co id=&quot;tutorial-hand_coded-doof2d-allocation&quot;&gt;&lt;/co&gt;
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i &lt; n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- ***************
- *** 32,49 ****
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
- !   for (int j = 0; j &lt; n; j++)
- !     for (int i = 0; i &lt; n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- --- 33,50 ----
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  &lt;co id=&quot;tutorial-hand_coded-doof2d-initialization&quot;&gt;&lt;/co&gt;
- !   for (int j = 0; j &lt; n; j++)
- !     for (int i = 0; i &lt; n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.  &lt;co id=&quot;tutorial-hand_coded-doof2d-constants&quot;&gt;&lt;/co&gt;
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  &lt;co id=&quot;tutorial-hand_coded-doof2d-first_write&quot;&gt;&lt;/co&gt;
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- ***************
- *** 51,57 ****
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- --- 52,58 ----
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.  &lt;co id=&quot;tutorial-hand_coded-doof2d-second_write&quot;&gt;&lt;/co&gt;
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- ***************
- *** 60,68 ****
-     }
-   
- !   // Print out the final central value.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) &lt;&lt; std::endl;
-   
- !   // Deallocate the arrays.
- !   for (int i = 0; i &lt; n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- --- 61,69 ----
-     }
-   
- !   // Print out the final central value.  &lt;co id=&quot;tutorial-hand_coded-doof2d-answer&quot;&gt;&lt;/co&gt;
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) &lt;&lt; std::endl;
-   
- !   // Deallocate the arrays.  &lt;co id=&quot;tutorial-hand_coded-doof2d-deallocation&quot;&gt;&lt;/co&gt;
- !   for (int i = 0; i &lt; n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- ***************
- *** 73,74 ****
- --- 74,76 ----
-     return EXIT_SUCCESS;
-   }
- + &lt;/programlisting&gt;
--- 0 ----
Index: programs/Doof2d-Field-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Field-distributed-annotated.patch
diff -N Doof2d-Field-distributed-annotated.patch
*** /tmp/cvsF2z45n	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,176 ****
- *** Doof2d-Field-distributed.cpp	Wed Dec  5 14:05:10 2001
- --- Doof2d-Field-distributed-annotated.cpp	Wed Dec  5 14:41:24 2001
- ***************
- *** 1,3 ****
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include &quot;Pooma/Fields.h&quot;	// has Pooma's Field
-   
- --- 1,4 ----
- ! &lt;programlisting id=&quot;tutorial-field_distributed-doof2d-program&quot; linenumbering=&quot;numbered&quot; format=&quot;linespecific&quot;&gt;
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include &quot;Pooma/Fields.h&quot;	// has Pooma's Field
-   
- ***************
- *** 12,16 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 13,17 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  &lt;co id=&quot;tutorial-field_distributed-doof2d-io&quot;&gt;&lt;/co&gt;
-     Inform output;
-   
- ***************
- *** 18,22 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &lt;&lt; argv[0] &lt;&lt; &quot;: number-of-processors number-of-averagings number-of-values&quot; &lt;&lt; std::endl;
-       return EXIT_FAILURE;
-     }
- --- 19,23 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &lt;&lt; argv[0] &lt;&lt; &quot;: number-of-processors number-of-averagings number-of-values&quot; &lt;&lt; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 25,33 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 26,34 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 35,39 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 36,40 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 41,50 ****
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- --- 42,51 ----
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- ***************
- *** 52,74 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // The template parameters indicate a mesh and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 53,75 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.  &lt;co id=&quot;tutorial-field_distributed-doof2d-layout&quot;&gt;&lt;/co&gt;
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  &lt;co id=&quot;tutorial-field_distributed-doof2d-mesh&quot;&gt;&lt;/co&gt;
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // The template parameters indicate a mesh and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  &lt;co id=&quot;tutorial-field_distributed-doof2d-remote&quot;&gt;&lt;/co&gt;
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 83,87 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- --- 84,88 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- ***************
- *** 99,103 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The fields are automatically deallocated.
- --- 100,104 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 107,108 ****
- --- 108,110 ----
-     return EXIT_SUCCESS;
-   }
- + &lt;/programlisting&gt;
--- 0 ----
Index: programs/Doof2d-Field-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Field-parallel-annotated.patch
diff -N Doof2d-Field-parallel-annotated.patch
*** /tmp/cvswOFpSv	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,120 ****
- *** Doof2d-Field-parallel.cpp	Tue Dec  4 10:01:28 2001
- --- Doof2d-Field-parallel-annotated.cpp	Tue Dec  4 11:04:26 2001
- ***************
- *** 1,5 ****
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include &quot;Pooma/Fields.h&quot;	// has Pooma's Field
-   
-   // Doof2d: Pooma Fields, data-parallel implementation
- --- 1,6 ----
- ! &lt;programlisting id=&quot;tutorial-field_parallel-doof2d-program&quot; linenumbering=&quot;numbered&quot; format=&quot;linespecific&quot;&gt;
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include &quot;Pooma/Fields.h&quot;	// has Pooma's Field  &lt;co id=&quot;tutorial-field_parallel-doof2d-header&quot;&gt;&lt;/co&gt;
-   
-   // Doof2d: Pooma Fields, data-parallel implementation
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; &quot;Please enter the number of averagings: &quot;;
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; &quot;Please enter the number of averagings: &quot;;
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,44 ****
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; &quot;Please enter the field size: &quot;;
- !   std::cin &gt;&gt; n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   DomainLayout&lt;2&gt; layout(vertDomain);
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The template parameters indicate a mesh, a 'double' element
- !   // type, and ordinary 'Brick' storage.
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 20,45 ----
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; &quot;Please enter the field size: &quot;;
- !   std::cin &gt;&gt; n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  &lt;co id=&quot;tutorial-field_parallel-doof2d-mesh&quot;&gt;&lt;/co&gt;
- !   DomainLayout&lt;2&gt; layout(vertDomain);
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The template parameters indicate a mesh, a 'double' element
- !   // type, and ordinary 'Brick' storage.  &lt;co id=&quot;tutorial-field_parallel-doof2d-field_creation&quot;&gt;&lt;/co&gt;
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 51,56 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 52,57 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  &lt;co id=&quot;tutorial-field_parallel-doof2d-first_write&quot;&gt;&lt;/co&gt;
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 67,71 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The fields are automatically deallocated.
- --- 68,72 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 75,76 ****
- --- 76,78 ----
-     return EXIT_SUCCESS;
-   }
- + &lt;/programlisting&gt;
--- 0 ----
Index: programs/makefile
===================================================================
RCS file: makefile
diff -N makefile
*** /tmp/cvsfaiLlD	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,12 ****
- ### Oldham, Jeffrey D.
- ### 2001Nov27
- ### Pooma
- ###
- ### Produce Annotated Source Code
- 
- all: Doof2d-C-element-annotated.cpp Doof2d-Array-element-annotated.cpp \
-      Doof2d-Array-parallel-annotated.cpp Doof2d-Array-stencil-annotated.cpp \
-      Doof2d-Array-distributed-annotated.cpp
- 
- %-annotated.cpp: %-annotated.patch %.cpp
- 	patch -o $@ &lt; $&lt;
--- 0 ----
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000878.html">Manual Patch: Program Movements and Additions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#877">[ date ]</a>
              <a href="thread.html#877">[ thread ]</a>
              <a href="subject.html#877">[ subject ]</a>
              <a href="author.html#877">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
