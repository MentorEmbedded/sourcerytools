<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Manual Patch: Use Standard DocBook Tags
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%20Patch%3A%20Use%20Standard%20DocBook%20Tags&In-Reply-To=%3C20020130155445.A26013%40vaio.codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000896.html">
   <LINK REL="Next"  HREF="000898.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Manual Patch: Use Standard DocBook Tags</H1>
    <B>Jeffrey D . Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%20Patch%3A%20Use%20Standard%20DocBook%20Tags&In-Reply-To=%3C20020130155445.A26013%40vaio.codesourcery.com%3E"
       TITLE="Manual Patch: Use Standard DocBook Tags">oldham at codesourcery.com
       </A><BR>
    <I>Wed Jan 30 23:54:45 UTC 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="000896.html">Manual Patch: Figure Code
</A></li>
        <LI>Next message: <A HREF="000898.html">Manual Patch: Formatting Changes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#897">[ date ]</a>
              <a href="thread.html#897">[ thread ]</a>
              <a href="subject.html#897">[ subject ]</a>
              <a href="author.html#897">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2002-Jan-30  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

Before this change, the POOMA manual used non-standard tags to describe
programming language features: &lt;statement&gt;, &lt;keywordname&gt;, &lt;methodname&gt;,
&lt;operator&gt;.  Since these are not standard, we replace them with &lt;literal&gt;,
losing information. :(

	* arrays.xml: Replace &lt;statement&gt;, &lt;keywordname&gt;, &lt;methodname&gt;, and
	&lt;operator&gt; with &lt;literal&gt;.
	* concepts.xml: Likewise.
	* data-parallel.xml: Likewise.
	* glossary.xml: Likewise.
	* introduction.xml: Likewise.
	* manual.xml: Likewise.
	* template.xml: Likewise.
	* tutorial.xml: Likewise.

Applied to	mainline.

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.6
diff -c -p -r1.6 arrays.xml
*** arrays.xml	2002/01/30 23:09:06	1.6
--- arrays.xml	2002/01/30 23:47:30
***************
*** 79,85 ****
      objects&lt;firstterm&gt;&lt;/firstterm&gt;&lt;/glossterm&gt; so they can be used
      more easily than built-in &cc; arrays.  For example, &array;s can
      be used as operands and in assignment statements.  The statement
!     &lt;statement&gt;a = a + b;&lt;/statement&gt; adds corresponding values of
      &array;s &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt;, assigning
      the sums to the &array; &lt;varname&gt;a&lt;/varname&gt;.  The statement
      treats each array as an object, rather than requiring the use of
--- 79,85 ----
      objects&lt;firstterm&gt;&lt;/firstterm&gt;&lt;/glossterm&gt; so they can be used
      more easily than built-in &cc; arrays.  For example, &array;s can
      be used as operands and in assignment statements.  The statement
!     &lt;literal&gt;a = a + b;&lt;/literal&gt; adds corresponding values of
      &array;s &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt;, assigning
      the sums to the &array; &lt;varname&gt;a&lt;/varname&gt;.  The statement
      treats each array as an object, rather than requiring the use of
***************
*** 87,94 ****
      statements such as this are further discussed in &lt;xref
      linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt;.  &array;s also handle their own
      memory allocation and deallocation.  For example, the &array;
!     declaration &lt;statement&gt;Array&lt;2, double, Brick&gt;
!     a(vertDomain)&lt;/statement&gt; creates an
      &array;&nbsp;&lt;varname&gt;a&lt;/varname&gt;, allocating whatever memory it
      needs.  When &lt;varname&gt;a&lt;/varname&gt; goes out of scope, it and its
      memory are automatically deallocated.  Automatic memory allocation
--- 87,94 ----
      statements such as this are further discussed in &lt;xref
      linkend=&quot;data_parallel&quot;&gt;&lt;/xref&gt;.  &array;s also handle their own
      memory allocation and deallocation.  For example, the &array;
!     declaration &lt;literal&gt;Array&lt;2, double, Brick&gt;
!     a(vertDomain)&lt;/literal&gt; creates an
      &array;&nbsp;&lt;varname&gt;a&lt;/varname&gt;, allocating whatever memory it
      needs.  When &lt;varname&gt;a&lt;/varname&gt; goes out of scope, it and its
      memory are automatically deallocated.  Automatic memory allocation
***************
*** 96,102 ****
  
      &lt;para&gt;Individual &array; values can be accessed using parentheses,
      not square brackets, as for &cc; arrays.  For example,
!     &lt;statement&gt;a(3,4)&lt;/statement&gt; yields the value at position (3,4)
      of &lt;varname&gt;a&lt;/varname&gt;'s two-dimensional domain.&lt;/para&gt;
     &lt;/section&gt;
  
--- 96,102 ----
  
      &lt;para&gt;Individual &array; values can be accessed using parentheses,
      not square brackets, as for &cc; arrays.  For example,
!     &lt;literal&gt;a(3,4)&lt;/literal&gt; yields the value at position (3,4)
      of &lt;varname&gt;a&lt;/varname&gt;'s two-dimensional domain.&lt;/para&gt;
     &lt;/section&gt;
  
***************
*** 179,188 ****
      &lt;para&gt;All the &domain; categories listed above except &grid; can
      be represented using domain triplet notation.  Since the triplet
      [7:7:1] represents {7}, or more simply&nbsp;7, it can also
!     represent the one-dimensional &lt;statement&gt;Loc&lt;1&gt;(7)&lt;/statement&gt;.
      Multidimensional &loc;s are similarly represented.  For example,
      [0:0:1,10:10:1,2:2:1] represents
!     &lt;statement&gt;Loc&lt;3&gt;(0,10,2)&lt;/statement&gt;, but it is frequently
      abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
      [a:b:1], while a &range; has specific stride&nbsp;s, e.g.,
      [a:b:s].&lt;/para&gt;
--- 179,188 ----
      &lt;para&gt;All the &domain; categories listed above except &grid; can
      be represented using domain triplet notation.  Since the triplet
      [7:7:1] represents {7}, or more simply&nbsp;7, it can also
!     represent the one-dimensional &lt;literal&gt;Loc&lt;1&gt;(7)&lt;/literal&gt;.
      Multidimensional &loc;s are similarly represented.  For example,
      [0:0:1,10:10:1,2:2:1] represents
!     &lt;literal&gt;Loc&lt;3&gt;(0,10,2)&lt;/literal&gt;, but it is frequently
      abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
      [a:b:1], while a &range; has specific stride&nbsp;s, e.g.,
      [a:b:s].&lt;/para&gt;
***************
*** 192,199 ****
      &interval; is the direct product of two one-dimensional
      &interval;s, it can be specified using two one-dimensional
      &interval;s.  For example,
!     &lt;statement&gt;Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
!     Interval&lt;1&gt;(4,5))&lt;/statement&gt; creates a [2:3:1,4:5:1]
      &domain;.  The resulting dimensionality equals the sum of the
      components' dimensions.  For example, a four-dimension &loc; can
      be specified using three- and one-dimension &loc;s or using four
--- 192,199 ----
      &interval; is the direct product of two one-dimensional
      &interval;s, it can be specified using two one-dimensional
      &interval;s.  For example,
!     &lt;literal&gt;Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
!     Interval&lt;1&gt;(4,5))&lt;/literal&gt; creates a [2:3:1,4:5:1]
      &domain;.  The resulting dimensionality equals the sum of the
      components' dimensions.  For example, a four-dimension &loc; can
      be specified using three- and one-dimension &loc;s or using four
***************
*** 206,217 ****
      different types.  A &loc; object can be constructed from other
      &loc; objects and integers.  &interval;s, &range;s, and &grid;s
      can be constructed using any of these types, &loc;s, and integers.
!     For example, &lt;statement&gt;Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2),
!     Interval&lt;1&gt;(3,5))&lt;/statement&gt; uses a two-dimensional &loc;
      and a one-dimensional &interval; to create a [1:1:1,2:2:1,3:5:1]
      &domain;.  During creation of a &domain;, the type of each object
      is changed to the &domain;'s type.  In the example,
!     &lt;statement&gt;Loc&lt;2&gt;(1,2)&lt;/statement&gt; is first converted to an
      &interval;.&lt;/para&gt;
  
      &lt;para&gt;&domain;s can participate in some arithmetic and comparison
--- 206,217 ----
      different types.  A &loc; object can be constructed from other
      &loc; objects and integers.  &interval;s, &range;s, and &grid;s
      can be constructed using any of these types, &loc;s, and integers.
!     For example, &lt;literal&gt;Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2),
!     Interval&lt;1&gt;(3,5))&lt;/literal&gt; uses a two-dimensional &loc;
      and a one-dimensional &interval; to create a [1:1:1,2:2:1,3:5:1]
      &domain;.  During creation of a &domain;, the type of each object
      is changed to the &domain;'s type.  In the example,
!     &lt;literal&gt;Loc&lt;2&gt;(1,2)&lt;/literal&gt; is first converted to an
      &interval;.&lt;/para&gt;
  
      &lt;para&gt;&domain;s can participate in some arithmetic and comparison
***************
*** 293,317 ****
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;indicates zero.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an uninitialized &locone;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &locone; with the integer converted from &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &locone; with the integer converted from
  	  &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
  	  &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &locone; with the integer converted from
  	  &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
  	  &lt;varname&gt;t1&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt; is
--- 293,317 ----
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;1&gt;()&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;indicates zero.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an uninitialized &locone;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &locone; with the integer converted from &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &locone; with the integer converted from
  	  &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
  	  &lt;varname&gt;t1&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &locone; with the integer converted from
  	  &lt;varname&gt;t1&lt;/varname&gt;.  &lt;varname&gt;t2&lt;/varname&gt; must equal
  	  &lt;varname&gt;t1&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt; is
***************
*** 360,405 ****
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;indicates zero.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an uninitialized &loc;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; object.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tbody&gt;
--- 360,405 ----
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;&dim;&gt;()&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;indicates zero.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an uninitialized &loc;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; object.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &loc; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tbody&gt;
***************
*** 418,425 ****
        to a multidimensional &domain; object that itself can be converted
        into a &loc;.  The total dimensionality of all the arguments'
        types should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  For example,
!       &lt;statement&gt;Loc&lt;5&gt;(Range&lt;1&gt;(2,2,2), Loc&lt;2&gt;(2,3),
!       Interval&lt;1&gt;(4,4))&lt;/statement&gt; creates a five-dimensional &loc;
        [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
        &loc;, and a one-dimensional &interval;.  The final fifth
        dimension has an unspecified value, in this case&nbsp;1.  The
--- 418,425 ----
        to a multidimensional &domain; object that itself can be converted
        into a &loc;.  The total dimensionality of all the arguments'
        types should be at most&nbsp;&lt;varname&gt;&dim;&lt;/varname&gt;.  For example,
!       &lt;literal&gt;Loc&lt;5&gt;(Range&lt;1&gt;(2,2,2), Loc&lt;2&gt;(2,3),
!       Interval&lt;1&gt;(4,4))&lt;/literal&gt; creates a five-dimensional &loc;
        [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
        &loc;, and a one-dimensional &interval;.  The final fifth
        dimension has an unspecified value, in this case&nbsp;1.  The
***************
*** 466,489 ****
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized interval.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an uninitialized &intervalone;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &intervalone;.  See the text for an explanation.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &intervalone; with the integers converted from
  	  &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &intervalone; with the integers converted from
  	  &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.
  	  &lt;varname&gt;t3&lt;/varname&gt; must equal&nbsp;1.&lt;/entry&gt;
--- 466,489 ----
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;1&gt;()&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized interval.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an uninitialized &intervalone;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &intervalone;.  See the text for an explanation.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &intervalone; with the integers converted from
  	  &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &intervalone; with the integers converted from
  	  &lt;varname&gt;t1&lt;/varname&gt; and &lt;varname&gt;t2&lt;/varname&gt;.
  	  &lt;varname&gt;t3&lt;/varname&gt; must equal&nbsp;1.&lt;/entry&gt;
***************
*** 532,577 ****
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; object.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tbody&gt;
--- 532,577 ----
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;&dim;&gt;()&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &interval;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; object.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an &interval; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tbody&gt;
***************
*** 637,661 ****
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized range.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an uninitialized &rangeone;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &rangeone;.  See the text for an explanation.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &rangeone; with an interval specified by the
  	  integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
  	  &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &rangeone; by converting the arguments to
  	  integers &lt;varname&gt;i1&lt;/varname&gt;, &lt;varname&gt;i2&lt;/varname&gt;, and
  	  &lt;varname&gt;i3&lt;/varname&gt; and then making a range [i1:i2:i3].&lt;/entry&gt;
--- 637,661 ----
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;1&gt;()&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized range.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;1&gt;(const Pooma::NoInit&amp; no)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an uninitialized &rangeone;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &rangeone;.  See the text for an explanation.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &rangeone; with an interval specified by the
  	  integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
  	  &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &rangeone; by converting the arguments to
  	  integers &lt;varname&gt;i1&lt;/varname&gt;, &lt;varname&gt;i2&lt;/varname&gt;, and
  	  &lt;varname&gt;i3&lt;/varname&gt; and then making a range [i1:i2:i3].&lt;/entry&gt;
***************
*** 702,747 ****
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; object.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tbody&gt;
--- 702,747 ----
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;&dim;&gt;()&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &range;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; object.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &range; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tbody&gt;
***************
*** 811,831 ****
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized grid.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &gridone;.  See the text for an explanation.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &gridone; from the interval specified by the
  	  integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
  	  &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &gridone; from the domain triplet specified
  	  by the integers converted from &lt;varname&gt;t1&lt;/varname&gt;,
  	  &lt;varname&gt;t2&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt;.&lt;/entry&gt;
--- 811,831 ----
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;1&gt;()&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized grid.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &gridone;.  See the text for an explanation.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &gridone; from the interval specified by the
  	  integers converted from &lt;varname&gt;t1&lt;/varname&gt; and
  	  &lt;varname&gt;t2&lt;/varname&gt;.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &gridone; from the domain triplet specified
  	  by the integers converted from &lt;varname&gt;t1&lt;/varname&gt;,
  	  &lt;varname&gt;t2&lt;/varname&gt;, and &lt;varname&gt;t3&lt;/varname&gt;.&lt;/entry&gt;
*************** Grid&lt;1&gt; g(list);
*** 889,930 ****
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &grid;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; object.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;statement&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tbody&gt;
--- 889,930 ----
  	&lt;/tfoot&gt;
  	&lt;tbody valign=&quot;top&quot;&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;&dim;&gt;()&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates an empty, uninitialized &grid;, to be assigned a value later.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; object.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	 &lt;row&gt;
! 	  &lt;entry&gt;&lt;literal&gt;Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)&lt;/literal&gt;&lt;/entry&gt;
  	  &lt;entry&gt;creates a &grid; using the given &domain; objects.&lt;/entry&gt;
  	 &lt;/row&gt;
  	&lt;/tbody&gt;
*************** Grid&lt;1&gt; g(list);
*** 995,1009 ****
  	 &lt;entry&gt;Multidimensional &domain; Accessors&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;long size()&lt;/statement&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the total number of indices.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;bool empty()&lt;/statement&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns &true; if and only if the &domain; has no indices.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;D&lt;1&gt; operator[](int dimension)&lt;/statement&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the one-dimensional &domain; for the specified
  	 dimension.  The return type is a one-dimensional version of
  	 the &domain;.&lt;/entry&gt;
--- 995,1009 ----
  	 &lt;entry&gt;Multidimensional &domain; Accessors&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;literal&gt;long size()&lt;/literal&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the total number of indices.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;literal&gt;bool empty()&lt;/literal&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns &true; if and only if the &domain; has no indices.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;literal&gt;D&lt;1&gt; operator[](int dimension)&lt;/literal&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the one-dimensional &domain; for the specified
  	 dimension.  The return type is a one-dimensional version of
  	 the &domain;.&lt;/entry&gt;
*************** Grid&lt;1&gt; g(list);
*** 1012,1043 ****
  	 &lt;entry&gt;One-dimensional &domain; Accessors&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;long length()&lt;/statement&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the number of indices.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;int first()&lt;/statement&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the beginning of the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;int last()&lt;/statement&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the ending of the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;int min()&lt;/statement&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the minimum index in the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;int max()&lt;/statement&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the maximum index in the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;D&lt;1&gt;::iterator begin()&lt;/statement&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns a forward iterator pointing to the
  	 beginning domain index.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;statement&gt;D&lt;1&gt;::iterator end()&lt;/statement&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns a forward iterator pointing to the ending
  	 domain index.&lt;/entry&gt;
  	&lt;/row&gt;
--- 1012,1043 ----
  	 &lt;entry&gt;One-dimensional &domain; Accessors&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;literal&gt;long length()&lt;/literal&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the number of indices.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;literal&gt;int first()&lt;/literal&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the beginning of the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;literal&gt;int last()&lt;/literal&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the ending of the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;literal&gt;int min()&lt;/literal&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the minimum index in the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;literal&gt;int max()&lt;/literal&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns the maximum index in the domain.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;literal&gt;D&lt;1&gt;::iterator begin()&lt;/literal&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns a forward iterator pointing to the
  	 beginning domain index.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;literal&gt;D&lt;1&gt;::iterator end()&lt;/literal&gt;&lt;/entry&gt;
  	 &lt;entry&gt;returns a forward iterator pointing to the ending
  	 domain index.&lt;/entry&gt;
  	&lt;/row&gt;
*************** Grid&lt;1&gt; g(list);
*** 1049,1087 ****
       linkend=&quot;arrays-domains-use-table&quot;&gt;&lt;/xref&gt;.  Functions applicable
       to both one-dimensional and multidimensional &domain;s are listed
       before functions that only applicable to one-dimensional
!      &domain;s.  The &lt;methodname&gt;size&lt;/methodname&gt; member function
       yields the total number of indices in a given &domain;.  If and
!      only if this number is zero, &lt;methodname&gt;empty&lt;/methodname&gt; will
       yield &true;.  A multidimensional
       &lt;type&gt;domain&lt;&dim;&gt;&lt;/type&gt; is the direct product of &dim;
!      one-dimensional &domain;s.  The &lt;methodname&gt;operator[](int
!      dimension)&lt;/methodname&gt; operator extracts the one-dimensional
       &domain; corresponding to its parameter.  For example, the three
       one-dimensional &lt;type&gt;Range&lt;1&gt;&lt;/type&gt; &domain;s can be
       extracted from a &lt;type&gt;Range&lt;3&gt;&lt;/type&gt;
       object&nbsp;&lt;varname&gt;r&lt;/varname&gt; using
!      &lt;statement&gt;r[0]&lt;/statement&gt;, &lt;statement&gt;r[1]&lt;/statement&gt;, and
!      &lt;statement&gt;r[2]&lt;/statement&gt;.&lt;/para&gt;
  
       &lt;para&gt;&domain; accessors applicable only to one-dimensional
       &domain;s are listed in the second half of &lt;xref
       linkend=&quot;arrays-domains-use-table&quot;&gt;&lt;/xref&gt;.  The
!      &lt;methodname&gt;length&lt;/methodname&gt; member function, analogous to the
!      multidimensional &lt;methodname&gt;size&lt;/methodname&gt; function, returns
       the number of indices in the &domain;.  The
!      &lt;methodname&gt;first&lt;/methodname&gt; and &lt;methodname&gt;last&lt;/methodname&gt;
       member functions return the domain's beginning and ending
!      indices.  The &lt;methodname&gt;begin&lt;/methodname&gt; and
!      &lt;methodname&gt;end&lt;/methodname&gt; member functions return forward
       iterators pointing to these respective locations.  They have type
       &lt;type&gt;D&lt;1&gt;::iterator&lt;/type&gt;, where &lt;type&gt;D&lt;/type&gt;
       abbreviates the &domain;'s type, e.g., &interval; or &grid;.
       &lt;!-- FIXME: Do I need to explain input iterators and their use?
!      --&gt; The &lt;methodname&gt;min&lt;/methodname&gt; and
!      &lt;methodname&gt;max&lt;/methodname&gt; member functions return the minimum
       and maximum indices in the &domain; object, respectively.  For
       &locone; and &intervalone;, these yield the same values as
!      &lt;methodname&gt;first&lt;/methodname&gt; and &lt;methodname&gt;last&lt;/methodname&gt;,
       but &rangeone; and &gridone; can have their numerically largest
       index at the beginning of their &domain;s.&lt;/para&gt;
      &lt;/section&gt;
--- 1049,1087 ----
       linkend=&quot;arrays-domains-use-table&quot;&gt;&lt;/xref&gt;.  Functions applicable
       to both one-dimensional and multidimensional &domain;s are listed
       before functions that only applicable to one-dimensional
!      &domain;s.  The &lt;literal&gt;size&lt;/literal&gt; member function
       yields the total number of indices in a given &domain;.  If and
!      only if this number is zero, &lt;literal&gt;empty&lt;/literal&gt; will
       yield &true;.  A multidimensional
       &lt;type&gt;domain&lt;&dim;&gt;&lt;/type&gt; is the direct product of &dim;
!      one-dimensional &domain;s.  The &lt;literal&gt;operator[](int
!      dimension)&lt;/literal&gt; operator extracts the one-dimensional
       &domain; corresponding to its parameter.  For example, the three
       one-dimensional &lt;type&gt;Range&lt;1&gt;&lt;/type&gt; &domain;s can be
       extracted from a &lt;type&gt;Range&lt;3&gt;&lt;/type&gt;
       object&nbsp;&lt;varname&gt;r&lt;/varname&gt; using
!      &lt;literal&gt;r[0]&lt;/literal&gt;, &lt;literal&gt;r[1]&lt;/literal&gt;, and
!      &lt;literal&gt;r[2]&lt;/literal&gt;.&lt;/para&gt;
  
       &lt;para&gt;&domain; accessors applicable only to one-dimensional
       &domain;s are listed in the second half of &lt;xref
       linkend=&quot;arrays-domains-use-table&quot;&gt;&lt;/xref&gt;.  The
!      &lt;literal&gt;length&lt;/literal&gt; member function, analogous to the
!      multidimensional &lt;literal&gt;size&lt;/literal&gt; function, returns
       the number of indices in the &domain;.  The
!      &lt;literal&gt;first&lt;/literal&gt; and &lt;literal&gt;last&lt;/literal&gt;
       member functions return the domain's beginning and ending
!      indices.  The &lt;literal&gt;begin&lt;/literal&gt; and
!      &lt;literal&gt;end&lt;/literal&gt; member functions return forward
       iterators pointing to these respective locations.  They have type
       &lt;type&gt;D&lt;1&gt;::iterator&lt;/type&gt;, where &lt;type&gt;D&lt;/type&gt;
       abbreviates the &domain;'s type, e.g., &interval; or &grid;.
       &lt;!-- FIXME: Do I need to explain input iterators and their use?
!      --&gt; The &lt;literal&gt;min&lt;/literal&gt; and
!      &lt;literal&gt;max&lt;/literal&gt; member functions return the minimum
       and maximum indices in the &domain; object, respectively.  For
       &locone; and &intervalone;, these yield the same values as
!      &lt;literal&gt;first&lt;/literal&gt; and &lt;literal&gt;last&lt;/literal&gt;,
       but &rangeone; and &gridone; can have their numerically largest
       index at the beginning of their &domain;s.&lt;/para&gt;
      &lt;/section&gt;
*************** Grid&lt;1&gt; g(list);
*** 1204,1210 ****
      &hellip;, &lt;varname&gt;DT7&lt;/varname&gt;.  The first constructor, with no
      domain arguments, creates an empty, uninitialized &array; for
      which a domain must be specified before it is used.  Specify the
!     array's domain using its &lt;methodname&gt;initialize&lt;/methodname&gt;
      function.  The next seven constructors combine their domain
      arguments to compute the resulting &array;'s domain.  These are
      combined in the same way that multidimensional &interval;s are
--- 1204,1210 ----
      &hellip;, &lt;varname&gt;DT7&lt;/varname&gt;.  The first constructor, with no
      domain arguments, creates an empty, uninitialized &array; for
      which a domain must be specified before it is used.  Specify the
!     array's domain using its &lt;literal&gt;initialize&lt;/literal&gt;
      function.  The next seven constructors combine their domain
      arguments to compute the resulting &array;'s domain.  These are
      combined in the same way that multidimensional &interval;s are
*************** Grid&lt;1&gt; g(list);
*** 1259,1358 ****
        &lt;/tfoot&gt;
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an empty, uninitialized &array; which must be
! 	&lt;methodname&gt;initialize&lt;/methodname&gt;()d before use.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;!-- Omit Indirection Array because src/Engine/IndirectionEngine.h indicates it is not yet finished. --&gt;
         &lt;!-- Omit the two Array&lt;D1,T1,E1&gt; a constructors, which
         should not be used by users. --&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; object or integer.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
! 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6, const DT7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; object or
  	integer and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
--- 1259,1358 ----
        &lt;/tfoot&gt;
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an empty, uninitialized &array; which must be
! 	&lt;literal&gt;initialize&lt;/literal&gt;()d before use.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;!-- Omit Indirection Array because src/Engine/IndirectionEngine.h indicates it is not yet finished. --&gt;
         &lt;!-- Omit the two Array&lt;D1,T1,E1&gt; a constructors, which
         should not be used by users. --&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; object or integer.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
! 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6, const DT7&amp; t7)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; object or
  	integer and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
*************** Array&lt;3&gt; b(2,3,1);
*** 1389,1395 ****
  &lt;programlisting&gt;
  Array&lt;2,bool&gt; c(2,3);
  &lt;/programlisting&gt;  To specify a default &array; value of &true;, use
!     &lt;statement&gt;ModelElement&lt;bool&gt;(true)&lt;/statement&gt;:
  &lt;programlisting&gt;
  Array&lt;2,bool&gt; c(2,3, ModelElement&lt;bool&gt;(true));.
  &lt;/programlisting&gt;  To create a one-dimensional &array; containing
--- 1389,1395 ----
  &lt;programlisting&gt;
  Array&lt;2,bool&gt; c(2,3);
  &lt;/programlisting&gt;  To specify a default &array; value of &true;, use
!     &lt;literal&gt;ModelElement&lt;bool&gt;(true)&lt;/literal&gt;:
  &lt;programlisting&gt;
  Array&lt;2,bool&gt; c(2,3, ModelElement&lt;bool&gt;(true));.
  &lt;/programlisting&gt;  To create a one-dimensional &array; containing
*************** Array&lt;1,double,CompressibleBrick&gt;
*** 1407,1416 ****
      constructor, must have a specified domain before it can be used.
      For example, one must use the parameter-less &array; constructor
      when creating an array of &array;s using
!     &lt;keywordname&gt;new&lt;/keywordname&gt; so their domains must be specified.
      (It would probably be better to create an &array; of &array;s
      since memory allocation and deallocation would automatically be
!     handled.)  &array;'s &lt;methodname&gt;initialize&lt;/methodname&gt; functions
      accept the same set of domain object specifications and model
      elements that the &array; constructors do, creating the specified
      domain.  See &lt;xref
--- 1407,1416 ----
      constructor, must have a specified domain before it can be used.
      For example, one must use the parameter-less &array; constructor
      when creating an array of &array;s using
!     &lt;literal&gt;new&lt;/literal&gt; so their domains must be specified.
      (It would probably be better to create an &array; of &array;s
      since memory allocation and deallocation would automatically be
!     handled.)  &array;'s &lt;literal&gt;initialize&lt;/literal&gt; functions
      accept the same set of domain object specifications and model
      elements that the &array; constructors do, creating the specified
      domain.  See &lt;xref
*************** Array&lt;2,float,Brick&gt; a(Interval&lt;1&gt;(2,7),
*** 1426,1432 ****
  // its domain.
  Array&lt;2,float,Brick&gt; b();
  b.initialize(Interval&lt;1&gt;(2,7), Interval&lt;1&gt;(-2,4));.
! &lt;/programlisting&gt;  Invoking &lt;methodname&gt;initialize&lt;/methodname&gt; on an
      &array; with an existing domain yields unspecified behavior.  All
      &array; values may be lost and memory may be leaked.&lt;/para&gt;
  
--- 1426,1432 ----
  // its domain.
  Array&lt;2,float,Brick&gt; b();
  b.initialize(Interval&lt;1&gt;(2,7), Interval&lt;1&gt;(-2,4));.
! &lt;/programlisting&gt;  Invoking &lt;literal&gt;initialize&lt;/literal&gt; on an
      &array; with an existing domain yields unspecified behavior.  All
      &array; values may be lost and memory may be leaked.&lt;/para&gt;
  
*************** b.initialize(Interval&lt;1&gt;(2,7), Interval&lt;
*** 1437,1448 ****
       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
        &lt;thead&gt;
         &lt;row&gt;
! 	&lt;entry&gt;An &array;'s &lt;methodname&gt;initialize&lt;/methodname&gt; member
  	functions sets its domain and should be invoked only for an
  	array created without a domain.  It returns nothing.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;methodname&gt;initialize&lt;/methodname&gt; declaration&lt;/entry&gt;
  	&lt;entry&gt;result&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
--- 1437,1448 ----
       &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
        &lt;thead&gt;
         &lt;row&gt;
! 	&lt;entry&gt;An &array;'s &lt;literal&gt;initialize&lt;/literal&gt; member
  	functions sets its domain and should be invoked only for an
  	array created without a domain.  It returns nothing.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize&lt;/literal&gt; declaration&lt;/entry&gt;
  	&lt;entry&gt;result&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
*************** b.initialize(Interval&lt;1&gt;(2,7), Interval&lt;
*** 1457,1546 ****
         &lt;!-- Omit Indirection Array initialize because it does not exist! --&gt;
         &lt;!-- Omit the two Array&lt;D1,T1,E1&gt; functions, which should not be used by users. --&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain;
  object or integer.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
! 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6, const DT7&amp; t7)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain;
  	object or integer and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain;
  	objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain;
  	objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
--- 1457,1546 ----
         &lt;!-- Omit Indirection Array initialize because it does not exist! --&gt;
         &lt;!-- Omit the two Array&lt;D1,T1,E1&gt; functions, which should not be used by users. --&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain;
  object or integer.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const DT2&amp; t2)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const
! 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6, const DT7&amp; t7)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain;
  	object or integer and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const DT2&amp; t2,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain;
  	objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain;
  	objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
! 	const ModelElement&lt;T&gt;&amp; model)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using &lt;varname&gt;model&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
*************** std::cout &openopen; a(2,-2) &openopen; 
*** 1583,1593 ****
      numbers.&lt;/para&gt;
  
      &lt;para&gt;For read-only access to a value, use the
!     &lt;methodname&gt;read&lt;/methodname&gt; member function, which takes the
      same index notation as its nameless read-write counterpart:
  &lt;programlisting&gt;
  std::cout &openopen; a.read(2,-2) &openopen; std::endl;
! &lt;/programlisting&gt; Using &lt;methodname&gt;read&lt;/methodname&gt; sometimes
      permits the optimizer to produce faster executing code.&lt;/para&gt;
  
      &lt;para&gt;Copying &array;s requires little execution time because
--- 1583,1593 ----
      numbers.&lt;/para&gt;
  
      &lt;para&gt;For read-only access to a value, use the
!     &lt;literal&gt;read&lt;/literal&gt; member function, which takes the
      same index notation as its nameless read-write counterpart:
  &lt;programlisting&gt;
  std::cout &openopen; a.read(2,-2) &openopen; std::endl;
! &lt;/programlisting&gt; Using &lt;literal&gt;read&lt;/literal&gt; sometimes
      permits the optimizer to produce faster executing code.&lt;/para&gt;
  
      &lt;para&gt;Copying &array;s requires little execution time because
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1622,1628 ****
      Destruction is similarly inexpensive.&lt;/para&gt;
  
      &lt;para&gt;Array assignment does not have reference semantics.  Thus,
!     the assignment &lt;statement&gt;a = b&lt;/statement&gt; ensures that all of
      &lt;varname&gt;a&lt;/varname&gt;'s values are the same as &lt;varname&gt;b&lt;/varname&gt;
      at the time of assignment only.  Subsequent changes to
      &lt;varname&gt;a&lt;/varname&gt;'s values do not change &lt;varname&gt;b&lt;/varname&gt;'s
--- 1622,1628 ----
      Destruction is similarly inexpensive.&lt;/para&gt;
  
      &lt;para&gt;Array assignment does not have reference semantics.  Thus,
!     the assignment &lt;literal&gt;a = b&lt;/literal&gt; ensures that all of
      &lt;varname&gt;a&lt;/varname&gt;'s values are the same as &lt;varname&gt;b&lt;/varname&gt;
      at the time of assignment only.  Subsequent changes to
      &lt;varname&gt;a&lt;/varname&gt;'s values do not change &lt;varname&gt;b&lt;/varname&gt;'s
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1637,1645 ****
      constants useful for both compile-time and run-time computations.
      See &lt;xref linkend=&quot;arrays-arrays_use-compile_time_table&quot;&gt;&lt;/xref&gt;.
      These may be accessed using the &array;'s type and the scope
!     resolution operator (&lt;operator&gt;::&lt;/operator&gt;).  The table begins
      with a list of internal type definitions, e.g.,
!     &lt;statement&gt;Array&lt;&dim;,T,E&gt;::This_t&lt;/statement&gt;.  A
      &lt;glossterm linkend=&quot;glossary-layout&quot;&gt;layout&lt;/glossterm&gt; maps a
      domain index to a particular processor and memory used to compute
      the associated value.&lt;!-- FIXME: Add a reference to the
--- 1637,1645 ----
      constants useful for both compile-time and run-time computations.
      See &lt;xref linkend=&quot;arrays-arrays_use-compile_time_table&quot;&gt;&lt;/xref&gt;.
      These may be accessed using the &array;'s type and the scope
!     resolution operator (&lt;literal&gt;::&lt;/literal&gt;).  The table begins
      with a list of internal type definitions, e.g.,
!     &lt;literal&gt;Array&lt;&dim;,T,E&gt;::This_t&lt;/literal&gt;.  A
      &lt;glossterm linkend=&quot;glossary-layout&quot;&gt;layout&lt;/glossterm&gt; maps a
      domain index to a particular processor and memory used to compute
      the associated value.&lt;!-- FIXME: Add a reference to the
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1690,1700 ****
  	&lt;entry&gt;the type of the &array;'s layout.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;const int dimensions&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;the number&nbsp;&dim; of dimensions of the &array;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;const int rank&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;synonym for &lt;varname&gt;dimensions&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
--- 1690,1700 ----
  	&lt;entry&gt;the type of the &array;'s layout.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;const int dimensions&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;the number&nbsp;&dim; of dimensions of the &array;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;const int rank&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;synonym for &lt;varname&gt;dimensions&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1708,1727 ****
      returning the &array;'s domain, which has type
      &lt;type&gt;Array&lt;&dim;,T,E&gt;::Domain_t&lt;/type&gt; (abbreviated
      &lt;type&gt;Domain_t&lt;/type&gt; in the table).  The next seven functions
!     query the domain.  &lt;methodname&gt;first&lt;/methodname&gt;,
!     &lt;methodname&gt;last&lt;/methodname&gt;, and &lt;methodname&gt;length&lt;/methodname&gt;
      return the first index, last index, and number of indices for the
      specified dimension.  The domain's dimensions are numbered 0, 1,
      &hellip;,
!     &lt;statement&gt;Array&lt;&dim;,T,E&gt;::dimensions&lt;/statement&gt;-1.  If
      these values are needed for all dimensions, use
!     &lt;methodname&gt;firsts&lt;/methodname&gt;, &lt;methodname&gt;lasts&lt;/methodname&gt;,
!     and &lt;methodname&gt;lengths&lt;/methodname&gt;.  The returned
      &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt;s have &dim; entries, one for each
!     dimension.  &lt;methodname&gt;size&lt;/methodname&gt; returns the total number
      of indices in the entire domain.  This is the product of all the
!     dimensions' &lt;methodname&gt;length&lt;/methodname&gt;s.  The
!     &lt;methodname&gt;layout&lt;/methodname&gt; member function returns the
      &array;'s layout, which specifies the mapping of indices to
      processors and memory.&lt;!-- FIXME: Add a reference to the
      corresponding chapter. --&gt; The last two functions return the
--- 1708,1727 ----
      returning the &array;'s domain, which has type
      &lt;type&gt;Array&lt;&dim;,T,E&gt;::Domain_t&lt;/type&gt; (abbreviated
      &lt;type&gt;Domain_t&lt;/type&gt; in the table).  The next seven functions
!     query the domain.  &lt;literal&gt;first&lt;/literal&gt;,
!     &lt;literal&gt;last&lt;/literal&gt;, and &lt;literal&gt;length&lt;/literal&gt;
      return the first index, last index, and number of indices for the
      specified dimension.  The domain's dimensions are numbered 0, 1,
      &hellip;,
!     &lt;literal&gt;Array&lt;&dim;,T,E&gt;::dimensions&lt;/literal&gt;-1.  If
      these values are needed for all dimensions, use
!     &lt;literal&gt;firsts&lt;/literal&gt;, &lt;literal&gt;lasts&lt;/literal&gt;,
!     and &lt;literal&gt;lengths&lt;/literal&gt;.  The returned
      &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt;s have &dim; entries, one for each
!     dimension.  &lt;literal&gt;size&lt;/literal&gt; returns the total number
      of indices in the entire domain.  This is the product of all the
!     dimensions' &lt;literal&gt;length&lt;/literal&gt;s.  The
!     &lt;literal&gt;layout&lt;/literal&gt; member function returns the
      &array;'s layout, which specifies the mapping of indices to
      processors and memory.&lt;!-- FIXME: Add a reference to the
      corresponding chapter. --&gt; The last two functions return the
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1742,1807 ****
         &lt;row&gt;
  	&lt;entry&gt;Internal type definitions, e.g., &lt;type&gt;Domain_t&lt;/type&gt;,
  	are listed here without the class type prefix
! 	&lt;statement&gt;Array&lt;&dim;,T,E&gt;::&lt;/statement&gt;.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Domain_t domain()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Domain_t physicalDomain()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Domain_t totalDomain()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;int first(int dim)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the first index value for the specified
  	dimension.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;int last(int dim)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the last index value for the specified
  	dimension.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;int length(int dim)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the number of indices (including endpoints) for
  	the specified dimension.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; firsts()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the first index values for all the
  	dimensions.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; lasts()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the last index values for all the specified
  	dimensions.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Loc&lt;Dim&gt; lengths()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the numbers of indices (including endpoints)
  	for all the specified dimensions.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;long size()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the total number of indices in the domain.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Layout_t layout()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s layout.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Engine_t engine()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s engine.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;const Engine_t engine()&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s engine.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
--- 1742,1807 ----
         &lt;row&gt;
  	&lt;entry&gt;Internal type definitions, e.g., &lt;type&gt;Domain_t&lt;/type&gt;,
  	are listed here without the class type prefix
! 	&lt;literal&gt;Array&lt;&dim;,T,E&gt;::&lt;/literal&gt;.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tfoot&gt;
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Domain_t domain()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Domain_t physicalDomain()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Domain_t totalDomain()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s domain.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;int first(int dim)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the first index value for the specified
  	dimension.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;int last(int dim)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the last index value for the specified
  	dimension.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;int length(int dim)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the number of indices (including endpoints) for
  	the specified dimension.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Loc&lt;Dim&gt; firsts()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the first index values for all the
  	dimensions.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Loc&lt;Dim&gt; lasts()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the last index values for all the specified
  	dimensions.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Loc&lt;Dim&gt; lengths()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the numbers of indices (including endpoints)
  	for all the specified dimensions.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;long size()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the total number of indices in the domain.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Layout_t layout()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s layout.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Engine_t engine()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s engine.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;const Engine_t engine()&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;returns the &array;'s engine.&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1811,1819 ****
      &lt;para&gt;We illustrate using &array; member functions in &lt;xref
      linkend=&quot;arrays-arrays_use-members_example&quot;&gt;&lt;/xref&gt;.  The program
      computes the total number of &array;'s indices, comparing the
!     result with invoking its &lt;methodname&gt;size&lt;/methodname&gt; method.
      Since the &array;'s name is &lt;varname&gt;a&lt;/varname&gt;,
!     &lt;statement&gt;a.size()&lt;/statement&gt; returns its size.  The
      &lt;function&gt;computeArraySize&lt;/function&gt; function also computes the
      &array;'s size.  This templated function uses its three template
      parameters to accept any &array;, regardless of its dimension,
--- 1811,1819 ----
      &lt;para&gt;We illustrate using &array; member functions in &lt;xref
      linkend=&quot;arrays-arrays_use-members_example&quot;&gt;&lt;/xref&gt;.  The program
      computes the total number of &array;'s indices, comparing the
!     result with invoking its &lt;literal&gt;size&lt;/literal&gt; method.
      Since the &array;'s name is &lt;varname&gt;a&lt;/varname&gt;,
!     &lt;literal&gt;a.size()&lt;/literal&gt; returns its size.  The
      &lt;function&gt;computeArraySize&lt;/function&gt; function also computes the
      &array;'s size.  This templated function uses its three template
      parameters to accept any &array;, regardless of its dimension,
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1823,1832 ****
      illustrates using member functions.  The domain's size is the
      product of the length of each dimension.  Since the lengths are
      stored in the &lt;type&gt;Loc&lt;&amp;dim&gt;&lt;/type&gt;
!     &lt;varname&gt;lens&lt;/varname&gt;, &lt;statement&gt;lens[d]&lt;/statement&gt; is a
      &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;, for which its
!     &lt;methodname&gt;first&lt;/methodname&gt; member function extracts the
!     length.  The &lt;methodname&gt;length&lt;/methodname&gt; &array; member
      function is used in the &lt;function&gt;PAssert&lt;/function&gt;.&lt;/para&gt;
  
      &lt;example id=&quot;arrays-arrays_use-members_example&quot;&gt;
--- 1823,1832 ----
      illustrates using member functions.  The domain's size is the
      product of the length of each dimension.  Since the lengths are
      stored in the &lt;type&gt;Loc&lt;&amp;dim&gt;&lt;/type&gt;
!     &lt;varname&gt;lens&lt;/varname&gt;, &lt;literal&gt;lens[d]&lt;/literal&gt; is a
      &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;, for which its
!     &lt;literal&gt;first&lt;/literal&gt; member function extracts the
!     length.  The &lt;literal&gt;length&lt;/literal&gt; &array; member
      function is used in the &lt;function&gt;PAssert&lt;/function&gt;.&lt;/para&gt;
  
      &lt;example id=&quot;arrays-arrays_use-members_example&quot;&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1844,1853 ****
         functions' names.  These functions return &loc;s.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-arrays_use-members-example-loc_use&quot;&gt;
!        &lt;para&gt;&lt;statement&gt;lens[d]&lt;/statement&gt; returns a
         &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt; for
         dimension&nbsp;&lt;varname&gt;d&lt;/varname&gt;'s length.  Invoking
!        &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt; &lt;methodname&gt;first&lt;/methodname&gt; method
         yields its value.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-arrays_use-members-example-check_length&quot;&gt;
--- 1844,1853 ----
         functions' names.  These functions return &loc;s.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-arrays_use-members-example-loc_use&quot;&gt;
!        &lt;para&gt;&lt;literal&gt;lens[d]&lt;/literal&gt; returns a
         &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt; for
         dimension&nbsp;&lt;varname&gt;d&lt;/varname&gt;'s length.  Invoking
!        &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt; &lt;literal&gt;first&lt;/literal&gt; method
         yields its value.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-arrays_use-members-example-check_length&quot;&gt;
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1855,1861 ****
         using member functions.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-arrays_use-members-example-compare_size&quot;&gt;
!        &lt;para&gt;The &lt;methodname&gt;size&lt;/methodname&gt; is invoked by
         prepending the &array;'s name followed by a period.  This
         assertion is unnecessary, but the
         &lt;function&gt;computeArraySize&lt;/function&gt; function further
--- 1855,1861 ----
         using member functions.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-arrays_use-members-example-compare_size&quot;&gt;
!        &lt;para&gt;The &lt;literal&gt;size&lt;/literal&gt; is invoked by
         prepending the &array;'s name followed by a period.  This
         assertion is unnecessary, but the
         &lt;function&gt;computeArraySize&lt;/function&gt; function further
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1890,1905 ****
      &dynamic; &engine; is analogous to a one-dimensional &brick;
      &engine; supporting a dynamically-resizable domain.  It is also
      usually the default value for this tag.  For example,
!     &lt;statement&gt;DynamicArray&lt;&gt; d0(1);&lt;/statement&gt;,
!     &lt;statement&gt;DynamicArray&lt;double&gt; d1(1);&lt;/statement&gt;, and
!     &lt;statement&gt;DynamicArray&lt;double, Dynamic&gt; d2(1);&lt;/statement&gt;
      all declare the same &dynamicarray;s explicitly storing one
      &double; value.  A &dynamicarray; automatically allocates its
      initial memory and deallocates its final memory, just as an
      &array; does.&lt;/para&gt;
  
!     &lt;para&gt;The &lt;methodname&gt;create&lt;/methodname&gt; and
!     &lt;methodname&gt;destroy&lt;/methodname&gt; member functions permit changing
      a &dynamicarray;'s domain.  &lt;xref
      linkend=&quot;arrays-dynamic_arrays-change_size&quot;&gt;&lt;/xref&gt; lists these member
      functions but omits functions exclusively used in distributed
--- 1890,1905 ----
      &dynamic; &engine; is analogous to a one-dimensional &brick;
      &engine; supporting a dynamically-resizable domain.  It is also
      usually the default value for this tag.  For example,
!     &lt;literal&gt;DynamicArray&lt;&gt; d0(1);&lt;/literal&gt;,
!     &lt;literal&gt;DynamicArray&lt;double&gt; d1(1);&lt;/literal&gt;, and
!     &lt;literal&gt;DynamicArray&lt;double, Dynamic&gt; d2(1);&lt;/literal&gt;
      all declare the same &dynamicarray;s explicitly storing one
      &double; value.  A &dynamicarray; automatically allocates its
      initial memory and deallocates its final memory, just as an
      &array; does.&lt;/para&gt;
  
!     &lt;para&gt;The &lt;literal&gt;create&lt;/literal&gt; and
!     &lt;literal&gt;destroy&lt;/literal&gt; member functions permit changing
      a &dynamicarray;'s domain.  &lt;xref
      linkend=&quot;arrays-dynamic_arrays-change_size&quot;&gt;&lt;/xref&gt; lists these member
      functions but omits functions exclusively used in distributed
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1927,1945 ****
        &lt;/tfoot&gt;
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;void create(int num)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;extend the current domain by the requested number of
          elements.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;remove the values specified by the indices in the given
  	&domain; argument.  The &lt;quote&gt;Backfill&lt;/quote&gt; method moves
  	values from the end of the domain to replace the deleted
  	values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
  	iterators.  The &lt;quote&gt;Backfill&lt;/quote&gt; method moves values
--- 1927,1945 ----
        &lt;/tfoot&gt;
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;void create(int num)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;extend the current domain by the requested number of
          elements.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;void destroy(const Dom&amp; killList)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;remove the values specified by the indices in the given
  	&domain; argument.  The &lt;quote&gt;Backfill&lt;/quote&gt; method moves
  	values from the end of the domain to replace the deleted
  	values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;void destroy(Iter killBegin, Iter killEnd)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
  	iterators.  The &lt;quote&gt;Backfill&lt;/quote&gt; method moves values
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1947,1954 ****
  	values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;void destroy(const Dom&amp; killList, const
! 	DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
  
  	&lt;entry&gt;remove the values specified by the indices in the
  	given &domain; argument.  Deleted values can be replaced by
--- 1947,1954 ----
  	values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;void destroy(const Dom&amp; killList, const
! 	DeleteMethod&amp; method)&lt;/literal&gt;&lt;/entry&gt;
  
  	&lt;entry&gt;remove the values specified by the indices in the
  	given &domain; argument.  Deleted values can be replaced by
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1958,1965 ****
  	ordering.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;void destroy(Iter killBegin, Iter killEnd,
! 	const DeleteMethod&amp; method)&lt;/statement&gt;&lt;/entry&gt;
          &lt;entry&gt;remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
  	iterators.  Deleted values can be replaced by
--- 1958,1965 ----
  	ordering.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;void destroy(Iter killBegin, Iter killEnd,
! 	const DeleteMethod&amp; method)&lt;/literal&gt;&lt;/entry&gt;
          &lt;entry&gt;remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
  	iterators.  Deleted values can be replaced by
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1972,1985 ****
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
!     &lt;para&gt;The &lt;methodname&gt;destroy&lt;/methodname&gt; member function deletes
      the specified indices.  The indices may be specified using either
      a &domain; object (&lt;type&gt;Interval&lt;1&gt;&lt;/type&gt;,
      &lt;type&gt;Range&lt;1&gt;&lt;/type&gt;, or &lt;type&gt;IndirectionList&lt;/type&gt;) or
      by random-access iterators pointing into a container.  For
      example, every other value from a ten-value
      array&nbsp;&lt;varname&gt;d&lt;/varname&gt; might be removed using
!     &lt;statement&gt;Range&lt;1&gt;(0,9,2)&lt;/statement&gt;.  Alternatively,
  &lt;programlisting&gt;
  int killList[] = {0, 2, 4, 6, 8};
  d.destroy(killList, killList+5);
--- 1972,1985 ----
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
!     &lt;para&gt;The &lt;literal&gt;destroy&lt;/literal&gt; member function deletes
      the specified indices.  The indices may be specified using either
      a &domain; object (&lt;type&gt;Interval&lt;1&gt;&lt;/type&gt;,
      &lt;type&gt;Range&lt;1&gt;&lt;/type&gt;, or &lt;type&gt;IndirectionList&lt;/type&gt;) or
      by random-access iterators pointing into a container.  For
      example, every other value from a ten-value
      array&nbsp;&lt;varname&gt;d&lt;/varname&gt; might be removed using
!     &lt;literal&gt;Range&lt;1&gt;(0,9,2)&lt;/literal&gt;.  Alternatively,
  &lt;programlisting&gt;
  int killList[] = {0, 2, 4, 6, 8};
  d.destroy(killList, killList+5);
*************** d.destroy(killList, killList+5);
*** 2002,2012 ****
  	&lt;entry&gt;0 1 2 3&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;methodname&gt;destroy&lt;/methodname&gt; using &lt;type&gt;BackFill&lt;/type&gt;:&lt;/entry&gt;
  	&lt;entry&gt;3 1 2&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;methodname&gt;destroy&lt;/methodname&gt; using &lt;type&gt;ShiftUp&lt;/type&gt;:&lt;/entry&gt;
  	&lt;entry&gt;1 2 3&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
--- 2002,2012 ----
  	&lt;entry&gt;0 1 2 3&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;destroy&lt;/literal&gt; using &lt;type&gt;BackFill&lt;/type&gt;:&lt;/entry&gt;
  	&lt;entry&gt;3 1 2&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;destroy&lt;/literal&gt; using &lt;type&gt;ShiftUp&lt;/type&gt;:&lt;/entry&gt;
  	&lt;entry&gt;1 2 3&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
*************** d.destroy(killList, killList+5);
*** 2025,2032 ****
      original indices of 0 1 2 3.  Removing 2 yields 0 1 3 because 3 is
      moved into 2's position.  Removing 0 yields 3 1 because 3 is again
      moved.  Use an object with the desired type to indicate which fill
!     method is desired, i.e., &lt;statement&gt;BackFill()&lt;/statement&gt; or
!     &lt;statement&gt;ShiftUp()&lt;/statement&gt;.&lt;/para&gt;
  
      &lt;para&gt;We illustrate &dynamicarray; resizing in &lt;xref
      linkend=&quot;arrays-dynamic_arrays-example&quot;&gt;&lt;/xref&gt;.  &dynamicarray;s
--- 2025,2032 ----
      original indices of 0 1 2 3.  Removing 2 yields 0 1 3 because 3 is
      moved into 2's position.  Removing 0 yields 3 1 because 3 is again
      moved.  Use an object with the desired type to indicate which fill
!     method is desired, i.e., &lt;literal&gt;BackFill()&lt;/literal&gt; or
!     &lt;literal&gt;ShiftUp()&lt;/literal&gt;.&lt;/para&gt;
  
      &lt;para&gt;We illustrate &dynamicarray; resizing in &lt;xref
      linkend=&quot;arrays-dynamic_arrays-example&quot;&gt;&lt;/xref&gt;.  &dynamicarray;s
*************** d.destroy(killList, killList+5);
*** 2037,2055 ****
      be one-dimensional.  The three arrays, each having one &double;
      value, are equivalent.  (The &poomatoolkit; can be configured to
      support different default template values.)  Invoking
!     &lt;varname&gt;d0&lt;/varname&gt;'s &lt;methodname&gt;create&lt;/methodname&gt; with an
      argument of five increases its domain size from one to six.  The
      additional indices are added to the end of the domain so the value
      at index&nbsp;0 is not changed.  To illustrate which indices are
      removed and which indices are reordered, the program first sets
      all values equal to their indices.  This illustrates that
      &dynamicarray; values are accessed the same way as &array; values.
!     For example, &lt;statement&gt;d0(i)&lt;/statement&gt; accesses the
      &lt;varname&gt;i&lt;/varname&gt;&lt;superscript&gt;th&lt;/superscript&gt; value.  The
!     &lt;methodname&gt;destroy&lt;/methodname&gt; member function removes every
      other index from the array because the one-dimensional &range;
      specifies the domain's entire interval with a stride of&nbsp;2.
!     The &lt;statement&gt;BackFill&lt;/statement&gt; function call creates a
      &lt;type&gt;BackFill&lt;/type&gt; object indicating the &lt;type&gt;BackFill&lt;/type&gt;
      method should be used.  We illustrate the steps of this method:
      &lt;informaltable frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
--- 2037,2055 ----
      be one-dimensional.  The three arrays, each having one &double;
      value, are equivalent.  (The &poomatoolkit; can be configured to
      support different default template values.)  Invoking
!     &lt;varname&gt;d0&lt;/varname&gt;'s &lt;literal&gt;create&lt;/literal&gt; with an
      argument of five increases its domain size from one to six.  The
      additional indices are added to the end of the domain so the value
      at index&nbsp;0 is not changed.  To illustrate which indices are
      removed and which indices are reordered, the program first sets
      all values equal to their indices.  This illustrates that
      &dynamicarray; values are accessed the same way as &array; values.
!     For example, &lt;literal&gt;d0(i)&lt;/literal&gt; accesses the
      &lt;varname&gt;i&lt;/varname&gt;&lt;superscript&gt;th&lt;/superscript&gt; value.  The
!     &lt;literal&gt;destroy&lt;/literal&gt; member function removes every
      other index from the array because the one-dimensional &range;
      specifies the domain's entire interval with a stride of&nbsp;2.
!     The &lt;literal&gt;BackFill&lt;/literal&gt; function call creates a
      &lt;type&gt;BackFill&lt;/type&gt; object indicating the &lt;type&gt;BackFill&lt;/type&gt;
      method should be used.  We illustrate the steps of this method:
      &lt;informaltable frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
*************** d.destroy(killList, killList+5);
*** 2081,2090 ****
      originally at 5 is again moved into 2's position.  Finally,
      index&nbsp;0 is replaced by index&nbsp;3.  The rest of the program
      repeats the computation, using the random-access iterator version
!     of &lt;methodname&gt;destroy&lt;/methodname&gt;.  Since this &dynamicarray;'s
      indices are specified using &int;s, the
      &lt;varname&gt;killList&lt;/varname&gt; explicitly lists the indices to
!     remove.  The &lt;methodname&gt;destroy&lt;/methodname&gt; call uses pointers
      to the beginning and end of the &lt;varname&gt;killList&lt;/varname&gt; array
      to specify which of its indices to use.  Since no replacement
      method is specified, the default &lt;type&gt;BackFill&lt;/type&gt; method is
--- 2081,2090 ----
      originally at 5 is again moved into 2's position.  Finally,
      index&nbsp;0 is replaced by index&nbsp;3.  The rest of the program
      repeats the computation, using the random-access iterator version
!     of &lt;literal&gt;destroy&lt;/literal&gt;.  Since this &dynamicarray;'s
      indices are specified using &int;s, the
      &lt;varname&gt;killList&lt;/varname&gt; explicitly lists the indices to
!     remove.  The &lt;literal&gt;destroy&lt;/literal&gt; call uses pointers
      to the beginning and end of the &lt;varname&gt;killList&lt;/varname&gt; array
      to specify which of its indices to use.  Since no replacement
      method is specified, the default &lt;type&gt;BackFill&lt;/type&gt; method is
*************** d.destroy(killList, killList+5);
*** 2104,2110 ****
         &dynamicarray;s, storing one &double; value.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-extension&quot;&gt;
!        &lt;para&gt;This &lt;methodname&gt;create&lt;/methodname&gt; member function call
         adds five indices to the end of the domain.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-access&quot;&gt;
--- 2104,2110 ----
         &dynamicarray;s, storing one &double; value.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-extension&quot;&gt;
!        &lt;para&gt;This &lt;literal&gt;create&lt;/literal&gt; member function call
         adds five indices to the end of the domain.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-access&quot;&gt;
*************** d.destroy(killList, killList+5);
*** 2113,2124 ****
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-destroy_range&quot;&gt;
         &lt;para&gt;The &range; object specifies that every other index
!        should be removed.  The &lt;statement&gt;BackFill()&lt;/statement&gt;
         object is unnecessary since it is the default replacement
         method.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-destroy_iterators&quot;&gt;
!        &lt;para&gt;This &lt;methodname&gt;destroy&lt;/methodname&gt; call is equivalent
         to the previous one but uses iterators.&lt;/para&gt;
        &lt;/callout&gt;
       &lt;/calloutlist&gt;
--- 2113,2124 ----
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-destroy_range&quot;&gt;
         &lt;para&gt;The &range; object specifies that every other index
!        should be removed.  The &lt;literal&gt;BackFill()&lt;/literal&gt;
         object is unnecessary since it is the default replacement
         method.&lt;/para&gt;
        &lt;/callout&gt;
        &lt;callout arearefs=&quot;arrays-dynamic_arrays-example-destroy_iterators&quot;&gt;
!        &lt;para&gt;This &lt;literal&gt;destroy&lt;/literal&gt; call is equivalent
         to the previous one but uses iterators.&lt;/para&gt;
        &lt;/callout&gt;
       &lt;/calloutlist&gt;
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.11
diff -c -p -r1.11 concepts.xml
*** concepts.xml	2002/01/30 23:09:06	1.11
--- concepts.xml	2002/01/30 23:47:30
***************
*** 251,258 ****
    versa.  While users sometimes explicitly create views, they are
    perhaps more frequently created as temporaries in expressions.  For
    example, if &lt;varname&gt;A&lt;/varname&gt; is an &array; and
!   &lt;varname&gt;I&lt;/varname&gt; is a domain, &lt;statement&gt;A(I) -
!   A(I-1)&lt;/statement&gt; uses two views to form the difference between
    adjacent values.&lt;/para&gt;
  
  
--- 251,258 ----
    versa.  While users sometimes explicitly create views, they are
    perhaps more frequently created as temporaries in expressions.  For
    example, if &lt;varname&gt;A&lt;/varname&gt; is an &array; and
!   &lt;varname&gt;I&lt;/varname&gt; is a domain, &lt;literal&gt;A(I) -
!   A(I-1)&lt;/literal&gt; uses two views to form the difference between
    adjacent values.&lt;/para&gt;
  
  
***************
*** 523,530 ****
    computation accesses individual container values through explicit
    notation.  For example, values in a two-dimensional
    container&nbsp;&container; might be referenced as
!   &lt;statement&gt;&amp;container(3,4)&lt;/statement&gt; or
!   &lt;statement&gt;&amp;container(i,j+1)&lt;/statement&gt;.  This is the usual
    notation for non-object-oriented languages such as &c;.&lt;/para&gt;
  
    &lt;para&gt;&lt;glossterm
--- 523,530 ----
    computation accesses individual container values through explicit
    notation.  For example, values in a two-dimensional
    container&nbsp;&container; might be referenced as
!   &lt;literal&gt;&amp;container(3,4)&lt;/literal&gt; or
!   &lt;literal&gt;&amp;container(i,j+1)&lt;/literal&gt;.  This is the usual
    notation for non-object-oriented languages such as &c;.&lt;/para&gt;
  
    &lt;para&gt;&lt;glossterm
***************
*** 532,538 ****
    computation uses expressions to access subsets of a container's
    values.  For example, in &lt;xref
    linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;,
!   &lt;statement&gt;a(I,J)&lt;/statement&gt; represents the subset of &array;
    &lt;varname&gt;a&lt;/varname&gt;'s values having coordinates in the domain
    specified by the direct product of one-dimensional &interval;s
    &lt;varname&gt;I&lt;/varname&gt; and&nbsp;&lt;varname&gt;J&lt;/varname&gt;.  Using
--- 532,538 ----
    computation uses expressions to access subsets of a container's
    values.  For example, in &lt;xref
    linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;,
!   &lt;literal&gt;a(I,J)&lt;/literal&gt; represents the subset of &array;
    &lt;varname&gt;a&lt;/varname&gt;'s values having coordinates in the domain
    specified by the direct product of one-dimensional &interval;s
    &lt;varname&gt;I&lt;/varname&gt; and&nbsp;&lt;varname&gt;J&lt;/varname&gt;.  Using
Index: data-parallel.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/data-parallel.xml,v
retrieving revision 1.5
diff -c -p -r1.5 data-parallel.xml
*** data-parallel.xml	2002/01/30 23:09:06	1.5
--- data-parallel.xml	2002/01/30 23:47:31
***************
*** 83,94 ****
      &lt;para&gt;The data-parallel operators operate element-wise on
      containers' values.  For example, if &lt;varname&gt;A&lt;/varname&gt; is a
      one-dimensional array,
!     &lt;statement&gt;-&lt;varname&gt;A&lt;/varname&gt;&lt;/statement&gt; is a one-dimensional
      array with the same size such that the value at the
      i&lt;superscript&gt;th&lt;/superscript&gt; position equals -A(i).  If
      &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;B&lt;/varname&gt; are two-dimensional
      &array;s on the same domain,
!     &lt;statement&gt;&lt;varname&gt;A&lt;/varname&gt;+&lt;varname&gt;B&lt;/varname&gt;&lt;/statement&gt;
      is an array on the same domain with values equaling the sum of
      corresponding values in &lt;varname&gt;A&lt;/varname&gt; and
      &lt;varname&gt;B&lt;/varname&gt;.&lt;/para&gt;
--- 83,94 ----
      &lt;para&gt;The data-parallel operators operate element-wise on
      containers' values.  For example, if &lt;varname&gt;A&lt;/varname&gt; is a
      one-dimensional array,
!     &lt;literal&gt;-&lt;varname&gt;A&lt;/varname&gt;&lt;/literal&gt; is a one-dimensional
      array with the same size such that the value at the
      i&lt;superscript&gt;th&lt;/superscript&gt; position equals -A(i).  If
      &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;B&lt;/varname&gt; are two-dimensional
      &array;s on the same domain,
!     &lt;literal&gt;&lt;varname&gt;A&lt;/varname&gt;+&lt;varname&gt;B&lt;/varname&gt;&lt;/literal&gt;
      is an array on the same domain with values equaling the sum of
      corresponding values in &lt;varname&gt;A&lt;/varname&gt; and
      &lt;varname&gt;B&lt;/varname&gt;.&lt;/para&gt;
***************
*** 103,110 ****
      with a one-dimensional interval&nbsp;[0,3].  Its first and last
      entries equal &lt;varname&gt;A&lt;/varname&gt;'s first and last entries, while
      its middle two entries are the sums
!     &lt;statement&gt;A(1)+B(1)&lt;/statement&gt; and
!     &lt;statement&gt;A(2)+B(2)&lt;/statement&gt;.  We assume zero is the default
      value for the type of values stored in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.
      A more complicated example of adding two &array;s with different
      domains is illustrated in &lt;xref
--- 103,110 ----
      with a one-dimensional interval&nbsp;[0,3].  Its first and last
      entries equal &lt;varname&gt;A&lt;/varname&gt;'s first and last entries, while
      its middle two entries are the sums
!     &lt;literal&gt;A(1)+B(1)&lt;/literal&gt; and
!     &lt;literal&gt;A(2)+B(2)&lt;/literal&gt;.  We assume zero is the default
      value for the type of values stored in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.
      A more complicated example of adding two &array;s with different
      domains is illustrated in &lt;xref
*************** Array&lt;2, double, Brick&gt; A(I,I), B(J,H);
*** 143,155 ****
      their domains' extent differ, as indicated by the solid lines in
      the figure.  The sum has domain equal to the left operand's
      domain.  Values with the same indices are added.  For example,
!     &lt;statement&gt;A(2,2)&lt;/statement&gt; and &lt;statement&gt;B(2,2)&lt;/statement&gt;
      are added.  &lt;varname&gt;B&lt;/varname&gt;'s domain does not include index
!     (1,1) so, when adding &lt;statement&gt;A(1,1)&lt;/statement&gt; and
!     &lt;statement&gt;B(1,1)&lt;/statement&gt;, the default value for
      &lt;varname&gt;B&lt;/varname&gt;'s value type is used.  Usually this
!     is&nbsp;0.  Thus, &lt;statement&gt;A(1,1) + B(1,1)&lt;/statement&gt; equals
!     &lt;statement&gt;9 + 0&lt;/statement&gt;.&lt;/para&gt;
  
      &lt;para&gt;Operations with both &array;s and scalar values are
      supported.  Conceptually, a scalar value can be thought of as an
--- 143,155 ----
      their domains' extent differ, as indicated by the solid lines in
      the figure.  The sum has domain equal to the left operand's
      domain.  Values with the same indices are added.  For example,
!     &lt;literal&gt;A(2,2)&lt;/literal&gt; and &lt;literal&gt;B(2,2)&lt;/literal&gt;
      are added.  &lt;varname&gt;B&lt;/varname&gt;'s domain does not include index
!     (1,1) so, when adding &lt;literal&gt;A(1,1)&lt;/literal&gt; and
!     &lt;literal&gt;B(1,1)&lt;/literal&gt;, the default value for
      &lt;varname&gt;B&lt;/varname&gt;'s value type is used.  Usually this
!     is&nbsp;0.  Thus, &lt;literal&gt;A(1,1) + B(1,1)&lt;/literal&gt; equals
!     &lt;literal&gt;9 + 0&lt;/literal&gt;.&lt;/para&gt;
  
      &lt;para&gt;Operations with both &array;s and scalar values are
      supported.  Conceptually, a scalar value can be thought of as an
*************** Array&lt;2, double, Brick&gt; A(I,I), B(J,H);
*** 158,171 ****
  &lt;programlisting&gt;
  Array&lt;1, double, Brick&gt; D(Interval&lt;1&gt;(7,10));
  D += 2*D + 7;
! &lt;/programlisting&gt;&lt;statement&gt;2*D&lt;/statement&gt; obeys the guidelines
!     because the scalar &lt;statement&gt;2&lt;/statement&gt; can be thought of as
      an array with the same domain as &lt;varname&gt;D&lt;/varname&gt;.  It has the
!     same value &lt;statement&gt;2&lt;/statement&gt; everywhere.  Likewise the
!     conceptual domain for the scalar &lt;statement&gt;7&lt;/statement&gt; is the
!     same as &lt;statement&gt;2*D&lt;/statement&gt;'s domain.  Thus,
!     &lt;statement&gt;2*D(i) + 7&lt;/statement&gt; is added to
!     &lt;statement&gt;D(i)&lt;/statement&gt; wherever index&nbsp;i is in
      &lt;varname&gt;D&lt;/varname&gt;'s domain.  In practice, the &toolkit; does
      not first convert scalar values to arrays but instead uses them
      directly in expressions.&lt;/para&gt;
--- 158,171 ----
  &lt;programlisting&gt;
  Array&lt;1, double, Brick&gt; D(Interval&lt;1&gt;(7,10));
  D += 2*D + 7;
! &lt;/programlisting&gt;&lt;literal&gt;2*D&lt;/literal&gt; obeys the guidelines
!     because the scalar &lt;literal&gt;2&lt;/literal&gt; can be thought of as
      an array with the same domain as &lt;varname&gt;D&lt;/varname&gt;.  It has the
!     same value &lt;literal&gt;2&lt;/literal&gt; everywhere.  Likewise the
!     conceptual domain for the scalar &lt;literal&gt;7&lt;/literal&gt; is the
!     same as &lt;literal&gt;2*D&lt;/literal&gt;'s domain.  Thus,
!     &lt;literal&gt;2*D(i) + 7&lt;/literal&gt; is added to
!     &lt;literal&gt;D(i)&lt;/literal&gt; wherever index&nbsp;i is in
      &lt;varname&gt;D&lt;/varname&gt;'s domain.  In practice, the &toolkit; does
      not first convert scalar values to arrays but instead uses them
      directly in expressions.&lt;/para&gt;
*************** Array&lt;2, double, Brick&gt; A(I,I), B(H,J), 
*** 201,215 ****
  Array&lt;1, double, Brick&gt; A(Interval&lt;1&gt;(0,1));
  Array&lt;1, double, Brick&gt; B(Interval&lt;1&gt;(1,2));
  A = B;
! &lt;/programlisting&gt; &lt;statement&gt;A(0)&lt;/statement&gt; is assigned
!     &lt;statement&gt;B(1)&lt;/statement&gt; and &lt;statement&gt;A(1)&lt;/statement&gt; is
!     assigned &lt;statement&gt;B(2)&lt;/statement&gt;.&lt;/para&gt;
  
      &lt;para&gt;Assigning a scalar value to an &array; also is supported,
      but assigning an &array; to a scalar is not.  A scalar value is
      conformable to any domain because, conceptually it can be viewed
      as an &array; with any desired domain and having the same value
!     everywhere.  Thus, the assignment &lt;statement&gt;B = 3&lt;/statement&gt;
  						   ensures every value in &lt;varname&gt;B&lt;/varname&gt; equals&nbsp;3.  Even
      though a scalar value is conformable to any &array;, it is not an
      l-value so it cannot appear on the left-hand side of an
--- 201,215 ----
  Array&lt;1, double, Brick&gt; A(Interval&lt;1&gt;(0,1));
  Array&lt;1, double, Brick&gt; B(Interval&lt;1&gt;(1,2));
  A = B;
! &lt;/programlisting&gt; &lt;literal&gt;A(0)&lt;/literal&gt; is assigned
!     &lt;literal&gt;B(1)&lt;/literal&gt; and &lt;literal&gt;A(1)&lt;/literal&gt; is
!     assigned &lt;literal&gt;B(2)&lt;/literal&gt;.&lt;/para&gt;
  
      &lt;para&gt;Assigning a scalar value to an &array; also is supported,
      but assigning an &array; to a scalar is not.  A scalar value is
      conformable to any domain because, conceptually it can be viewed
      as an &array; with any desired domain and having the same value
!     everywhere.  Thus, the assignment &lt;literal&gt;B = 3&lt;/literal&gt;
  						   ensures every value in &lt;varname&gt;B&lt;/varname&gt; equals&nbsp;3.  Even
      though a scalar value is conformable to any &array;, it is not an
      l-value so it cannot appear on the left-hand side of an
*************** A = B;
*** 217,225 ****
  
      &lt;para&gt;Data-parallel expressions can involve typical mathematical
      functions and output operations.  For example,
!     &lt;statement&gt;sin(A)&lt;/statement&gt; yields an &array; with values equal
      to the sine of each of &array; &lt;varname&gt;A&lt;/varname&gt;'s values.
!     &lt;statement&gt;dot(A,B)&lt;/statement&gt; has values equaling the dot
      product of corresponding values in &array;s &lt;varname&gt;A&lt;/varname&gt;
      and &lt;varname&gt;B&lt;/varname&gt;.  The contents of an entire &array; can
      be easily printed to standard output.  For example, the program
--- 217,225 ----
  
      &lt;para&gt;Data-parallel expressions can involve typical mathematical
      functions and output operations.  For example,
!     &lt;literal&gt;sin(A)&lt;/literal&gt; yields an &array; with values equal
      to the sine of each of &array; &lt;varname&gt;A&lt;/varname&gt;'s values.
!     &lt;literal&gt;dot(A,B)&lt;/literal&gt; has values equaling the dot
      product of corresponding values in &array;s &lt;varname&gt;A&lt;/varname&gt;
      and &lt;varname&gt;B&lt;/varname&gt;.  The contents of an entire &array; can
      be easily printed to standard output.  For example, the program
*************** std::cout &openopen; A-B &openopen; std:
*** 234,240 ****
      (000:002:001) = 1 -1 -1&lt;/computeroutput&gt;.  The initial
      &lt;computeroutput&gt;(000:002:001)&lt;/computeroutput&gt; indicates the
      &array;'s domain ranges from 0 to 2 with a stride of&nbsp;1.  The
!     three values in &lt;statement&gt;A-B&lt;/statement&gt; follow.&lt;/para&gt;
  
      &lt;para&gt;The following four tables list the data-parallel operators
      that operate on &array;s.  &lt;xref
--- 234,240 ----
      (000:002:001) = 1 -1 -1&lt;/computeroutput&gt;.  The initial
      &lt;computeroutput&gt;(000:002:001)&lt;/computeroutput&gt; indicates the
      &array;'s domain ranges from 0 to 2 with a stride of&nbsp;1.  The
!     three values in &lt;literal&gt;A-B&lt;/literal&gt; follow.&lt;/para&gt;
  
      &lt;para&gt;The following four tables list the data-parallel operators
      that operate on &array;s.  &lt;xref
*************** std::cout &openopen; A-B &openopen; std:
*** 242,261 ****
      &cc; operators that can be applied to &array;s and also scalar
      values if appropriate.  Each unary operator takes an &array;
      parameter and returns an &array;.  The types of the two &array;s
!     need not be the same.  For example, &lt;operator&gt;!&lt;/operator&gt; can
      take an &lt;type&gt;Array&lt;bool&gt;&lt;/type&gt;,
      &lt;type&gt;Array&lt;int&gt;&lt;/type&gt;, &lt;type&gt;Array&lt;long&gt;&lt;/type&gt;, or
!     any other value type to which &lt;operator&gt;!&lt;/operator&gt; can be
      applied.  The result is an &lt;type&gt;Array&lt;bool&gt;&lt;/type&gt;.  Each
      binary operator also returns an &array;.  When specifying two
      &array;s or an &array; and a scalar value, a full set of operators
      is supported.  When specifying an &array; and a &tensor;,
      &matrix;, or &vector;, a more limited set of operators is
!     supported.  For example, &lt;operator&gt;==&lt;/operator&gt; can take two
      &array;s, an &array; and a scalar value, or a scalar value and an
      &array;.  If given two &array;s, corresponding values are used.
      If an argument is a scalar value, its same value is the used with
!     each &array; value.  The &lt;operator&gt;+&lt;/operator&gt; supports the same
      set of parameters but also supports adding an &array; and a
      &tensor;, an &array; and a &matrix;, an &array; and a &vector;, a
      &tensor; and an &array;, a &matrix; and an &array;, and a &vector;
--- 242,261 ----
      &cc; operators that can be applied to &array;s and also scalar
      values if appropriate.  Each unary operator takes an &array;
      parameter and returns an &array;.  The types of the two &array;s
!     need not be the same.  For example, &lt;literal&gt;!&lt;/literal&gt; can
      take an &lt;type&gt;Array&lt;bool&gt;&lt;/type&gt;,
      &lt;type&gt;Array&lt;int&gt;&lt;/type&gt;, &lt;type&gt;Array&lt;long&gt;&lt;/type&gt;, or
!     any other value type to which &lt;literal&gt;!&lt;/literal&gt; can be
      applied.  The result is an &lt;type&gt;Array&lt;bool&gt;&lt;/type&gt;.  Each
      binary operator also returns an &array;.  When specifying two
      &array;s or an &array; and a scalar value, a full set of operators
      is supported.  When specifying an &array; and a &tensor;,
      &matrix;, or &vector;, a more limited set of operators is
!     supported.  For example, &lt;literal&gt;==&lt;/literal&gt; can take two
      &array;s, an &array; and a scalar value, or a scalar value and an
      &array;.  If given two &array;s, corresponding values are used.
      If an argument is a scalar value, its same value is the used with
!     each &array; value.  The &lt;literal&gt;+&lt;/literal&gt; supports the same
      set of parameters but also supports adding an &array; and a
      &tensor;, an &array; and a &matrix;, an &array; and a &vector;, a
      &tensor; and an &array;, a &matrix; and an &array;, and a &vector;
*************** std::cout &openopen; A-B &openopen; std:
*** 277,297 ****
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
          &lt;entry&gt;unary operators &lt;/entry&gt;
!         &lt;entry&gt;&lt;operator&gt;+&lt;/operator&gt;, &lt;operator&gt;-&lt;/operator&gt;, &lt;operator&gt;~&lt;/operator&gt;, &lt;operator&gt;!&lt;/operator&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
          &lt;entry&gt;binary operators with at least one &array; and at most
          one scalar value&lt;/entry&gt;
!         &lt;entry&gt;&lt;operator&gt;+&lt;/operator&gt;, &lt;operator&gt;-&lt;/operator&gt;, &lt;operator&gt;*&lt;/operator&gt;, &lt;operator&gt;/&lt;/operator&gt;, &lt;operator&gt;%&lt;/operator&gt;, &lt;operator&gt;&amp;&lt;/operator&gt;, &lt;operator&gt;|&lt;/operator&gt;, &lt;operator&gt;^&lt;/operator&gt;, &lt;operator&gt;&lt;&lt;/operator&gt;, &lt;operator&gt;&lt;=&lt;/operator&gt;, &lt;operator&gt;&gt;=&lt;/operator&gt;, &lt;operator&gt;&gt;&lt;/operator&gt;, &lt;operator&gt;==&lt;/operator&gt;, &lt;operator&gt;!=&lt;/operator&gt;, &lt;operator&gt;&amp;&amp;&lt;/operator&gt;, &lt;operator&gt;||&lt;/operator&gt;, &lt;operator&gt;&openopen;&lt;/operator&gt;, &lt;operator&gt;&closeclose;&lt;/operator&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
          &lt;entry&gt;binary operators with at least one &array; and at most
          one &tensor;, &matrix;, or &vector;&lt;/entry&gt;
!         &lt;entry&gt;&lt;operator&gt;+&lt;/operator&gt;, &lt;operator&gt;-&lt;/operator&gt;,
!         &lt;operator&gt;*&lt;/operator&gt;, &lt;operator&gt;/&lt;/operator&gt;,
!         &lt;operator&gt;%&lt;/operator&gt;, &lt;operator&gt;&amp;&lt;/operator&gt;,
!         &lt;operator&gt;|&lt;/operator&gt;, &lt;operator&gt;^&lt;/operator&gt;,
!         &lt;operator&gt;==&lt;/operator&gt;, &lt;operator&gt;!=&lt;/operator&gt;&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
--- 277,297 ----
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
          &lt;entry&gt;unary operators &lt;/entry&gt;
!         &lt;entry&gt;&lt;literal&gt;+&lt;/literal&gt;, &lt;literal&gt;-&lt;/literal&gt;, &lt;literal&gt;~&lt;/literal&gt;, &lt;literal&gt;!&lt;/literal&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
          &lt;entry&gt;binary operators with at least one &array; and at most
          one scalar value&lt;/entry&gt;
!         &lt;entry&gt;&lt;literal&gt;+&lt;/literal&gt;, &lt;literal&gt;-&lt;/literal&gt;, &lt;literal&gt;*&lt;/literal&gt;, &lt;literal&gt;/&lt;/literal&gt;, &lt;literal&gt;%&lt;/literal&gt;, &lt;literal&gt;&amp;&lt;/literal&gt;, &lt;literal&gt;|&lt;/literal&gt;, &lt;literal&gt;^&lt;/literal&gt;, &lt;literal&gt;&lt;&lt;/literal&gt;, &lt;literal&gt;&lt;=&lt;/literal&gt;, &lt;literal&gt;&gt;=&lt;/literal&gt;, &lt;literal&gt;&gt;&lt;/literal&gt;, &lt;literal&gt;==&lt;/literal&gt;, &lt;literal&gt;!=&lt;/literal&gt;, &lt;literal&gt;&amp;&amp;&lt;/literal&gt;, &lt;literal&gt;||&lt;/literal&gt;, &lt;literal&gt;&openopen;&lt;/literal&gt;, &lt;literal&gt;&closeclose;&lt;/literal&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
          &lt;entry&gt;binary operators with at least one &array; and at most
          one &tensor;, &matrix;, or &vector;&lt;/entry&gt;
!         &lt;entry&gt;&lt;literal&gt;+&lt;/literal&gt;, &lt;literal&gt;-&lt;/literal&gt;,
!         &lt;literal&gt;*&lt;/literal&gt;, &lt;literal&gt;/&lt;/literal&gt;,
!         &lt;literal&gt;%&lt;/literal&gt;, &lt;literal&gt;&amp;&lt;/literal&gt;,
!         &lt;literal&gt;|&lt;/literal&gt;, &lt;literal&gt;^&lt;/literal&gt;,
!         &lt;literal&gt;==&lt;/literal&gt;, &lt;literal&gt;!=&lt;/literal&gt;&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
*************** std::cout &openopen; A-B &openopen; std:
*** 361,445 ****
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Trigonometric and Hyperbolic Functions&lt;/entry&gt;
! 	&lt;entry&gt;&lt;statement&gt;#include &lt;math.h&gt;&lt;/statement&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; cos (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the cosines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sin (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the sines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; tan (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the tangents of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; acos (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the arc cosines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; asin (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the arc sines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; atan (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the arc tangents of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the arc tangents of the values from the division
  	of elements in &lt;varname&gt;B&lt;/varname&gt; by the elements
  	in&nbsp;&lt;varname&gt;A&lt;/varname&gt;.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the arc tangents of the values from the division
  	of &lt;varname&gt;r&lt;/varname&gt; by the elements
  	in&nbsp;&lt;varname&gt;A&lt;/varname&gt;.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; atan2 (const T1&amp; l, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the arc tangents of the values from the division
  	of elements in &lt;varname&gt;B&lt;/varname&gt; by&nbsp;&lt;varname&gt;l&lt;/varname&gt;.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; cosh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the hyperbolic cosines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sinh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the hyperbolic sines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; tanh (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the hyperbolic tangents of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Absolute Value, Rounding, and Modulus Functions&lt;/entry&gt;
! 	&lt;entry&gt;&lt;statement&gt;#include &lt;math.h&gt;&lt;/statement&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; fabs (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the absolute values of the floating point
  	numbers in the &array;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;For each of the &array;'s values, return the integer
  	larger than or equal to it (as a floating point number).&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; floor (const Array&lt;T1&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;For each of the &array;'s values, return the integer
  	smaller than or equal to it (as a floating point number).&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the floating-point modulus (remainder) of
  	&lt;varname&gt;A&lt;/varname&gt;'s values with the corresponding value
  	in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.  The results have the same signs
--- 361,445 ----
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Trigonometric and Hyperbolic Functions&lt;/entry&gt;
! 	&lt;entry&gt;&lt;literal&gt;#include &lt;math.h&gt;&lt;/literal&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; cos (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the cosines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; sin (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the sines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; tan (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the tangents of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; acos (const Array&lt;T1&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the arc cosines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; asin (const Array&lt;T1&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the arc sines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; atan (const Array&lt;T1&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the arc tangents of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the arc tangents of the values from the division
  	of elements in &lt;varname&gt;B&lt;/varname&gt; by the elements
  	in&nbsp;&lt;varname&gt;A&lt;/varname&gt;.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the arc tangents of the values from the division
  	of &lt;varname&gt;r&lt;/varname&gt; by the elements
  	in&nbsp;&lt;varname&gt;A&lt;/varname&gt;.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; atan2 (const T1&amp; l, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the arc tangents of the values from the division
  	of elements in &lt;varname&gt;B&lt;/varname&gt; by&nbsp;&lt;varname&gt;l&lt;/varname&gt;.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; cosh (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the hyperbolic cosines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; sinh (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the hyperbolic sines of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; tanh (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the hyperbolic tangents of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Absolute Value, Rounding, and Modulus Functions&lt;/entry&gt;
! 	&lt;entry&gt;&lt;literal&gt;#include &lt;math.h&gt;&lt;/literal&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; fabs (const Array&lt;T1&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the absolute values of the floating point
  	numbers in the &array;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;For each of the &array;'s values, return the integer
  	larger than or equal to it (as a floating point number).&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; floor (const Array&lt;T1&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;For each of the &array;'s values, return the integer
  	smaller than or equal to it (as a floating point number).&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the floating-point modulus (remainder) of
  	&lt;varname&gt;A&lt;/varname&gt;'s values with the corresponding value
  	in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.  The results have the same signs
*************** std::cout &openopen; A-B &openopen; std:
*** 447,460 ****
  	absolute values of&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the floating-point modulus (remainder) of
  	&lt;varname&gt;A&lt;/varname&gt;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  The results have the same signs
  	as &lt;varname&gt;A&lt;/varname&gt; and absolute values less than the
  	absolute value of&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; fmod (const T1&amp; l, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the floating-point modulus (remainder) of
  	&lt;varname&gt;l&lt;/varname&gt; with the values
  	in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.  The results have the same signs
--- 447,460 ----
  	absolute values of&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the floating-point modulus (remainder) of
  	&lt;varname&gt;A&lt;/varname&gt;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  The results have the same signs
  	as &lt;varname&gt;A&lt;/varname&gt; and absolute values less than the
  	absolute value of&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; fmod (const T1&amp; l, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Computes the floating-point modulus (remainder) of
  	&lt;varname&gt;l&lt;/varname&gt; with the values
  	in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.  The results have the same signs
*************** std::cout &openopen; A-B &openopen; std:
*** 463,618 ****
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Powers, Exponentiation, and Logarithmic Functions&lt;/entry&gt;
! 	&lt;entry&gt;&lt;statement&gt;#include &lt;math.h&gt;&lt;/statement&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; PETE_identity (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the &array;.  That is, it applies the identity operation.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; sqrt (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the square roots of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Raises &lt;varname&gt;A&lt;/varname&gt;'s values by the
  	corresponding power in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Raises &lt;varname&gt;A&lt;/varname&gt;'s values by the power&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow (const T1&amp; l, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Raises &lt;varname&gt;l&lt;/varname&gt; by the powers
  	in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow2 (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the squares of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow3 (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the cubes of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; pow4 (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the fourth powers of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, const Array&lt;int&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Multiplies &lt;varname&gt;A&lt;/varname&gt;'s values by two raised
  	to the corresponding value in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, int r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Multiplies &lt;varname&gt;A&lt;/varname&gt;'s values by two raised
  	to the &lt;varname&gt;r&lt;/varname&gt;&lt;subscript&gt;th&lt;/subscript&gt;
  	power.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; ldexp (const T1&amp; l, const Array&lt;int&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Multiplies &lt;varname&gt;l&lt;/varname&gt; by two raised
  	to the values in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; exp (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the exponentiations of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; log (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the natural logarithms of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; log10 (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the base-10 logarithms of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Functions Involving Complex Numbers&lt;/entry&gt;
! 	&lt;entry&gt;&lt;statement&gt;#include &lt;complex&gt;&lt;/statement&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; real (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the real parts of &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; imag (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the imaginary parts of &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; abs (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the absolute values (magnitudes) of
  	&lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; abs (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the absolute values of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; arg (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the angle representations (in radians) of the
  	 polar representations of &lt;varname&gt;A&lt;/varname&gt;'s complex
  	 numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; norm (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the squared absolute values of
  	 &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; conj (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex conjugates of
  	 &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
  	 coordinates (magnitudes and phase angles) in corresponding
  	 &array;s.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
  	 coordinates with magnitude&nbsp;&lt;varname&gt;l&lt;/varname&gt; and
  	 phase angles in the &array;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
  	 coordinates with magnitudes in the &array; and phase
  	 angle&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Functions Involving Matrices and Tensors&lt;/entry&gt;
! 	&lt;entry&gt;&lt;statement&gt;#include &quot;Pooma/Tiny.h&quot;&lt;/statement&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;T trace (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the sum of the &lt;varname&gt;A&lt;/varname&gt;'s diagonal
  	 entries, viewed as a matrix.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;T det (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the determinant of &lt;varname&gt;A&lt;/varname&gt;, viewed as a matrix.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; transpose (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the transpose of &lt;varname&gt;A&lt;/varname&gt;, viewed as a matrix.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; symmetrize (const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the tensors of &lt;varname&gt;A&lt;/varname&gt; with the
  	 requested output symmetry.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the dot products of values in the two &array;s.
  	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
  	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
  	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the dot products of values in the &array;
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.
  	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
--- 463,618 ----
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Powers, Exponentiation, and Logarithmic Functions&lt;/entry&gt;
! 	&lt;entry&gt;&lt;literal&gt;#include &lt;math.h&gt;&lt;/literal&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; PETE_identity (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the &array;.  That is, it applies the identity operation.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; sqrt (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the square roots of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Raises &lt;varname&gt;A&lt;/varname&gt;'s values by the
  	corresponding power in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Raises &lt;varname&gt;A&lt;/varname&gt;'s values by the power&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; pow (const T1&amp; l, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Raises &lt;varname&gt;l&lt;/varname&gt; by the powers
  	in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; pow2 (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the squares of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; pow3 (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the cubes of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; pow4 (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the fourth powers of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, const Array&lt;int&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Multiplies &lt;varname&gt;A&lt;/varname&gt;'s values by two raised
  	to the corresponding value in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, int r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Multiplies &lt;varname&gt;A&lt;/varname&gt;'s values by two raised
  	to the &lt;varname&gt;r&lt;/varname&gt;&lt;subscript&gt;th&lt;/subscript&gt;
  	power.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; ldexp (const T1&amp; l, const Array&lt;int&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Multiplies &lt;varname&gt;l&lt;/varname&gt; by two raised
  	to the values in&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; exp (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the exponentiations of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; log (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the natural logarithms of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; log10 (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the base-10 logarithms of the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Functions Involving Complex Numbers&lt;/entry&gt;
! 	&lt;entry&gt;&lt;literal&gt;#include &lt;complex&gt;&lt;/literal&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; real (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the real parts of &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; imag (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the imaginary parts of &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; abs (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the absolute values (magnitudes) of
  	&lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; abs (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the absolute values of &lt;varname&gt;A&lt;/varname&gt;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; arg (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the angle representations (in radians) of the
  	 polar representations of &lt;varname&gt;A&lt;/varname&gt;'s complex
  	 numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; norm (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the squared absolute values of
  	 &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;complex&lt;T&closeclose; conj (const Array&lt;complex&lt;T&closeclose;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex conjugates of
  	 &lt;varname&gt;A&lt;/varname&gt;'s complex numbers.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
  	 coordinates (magnitudes and phase angles) in corresponding
  	 &array;s.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;complex&lt;T&closeclose; polar (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
  	 coordinates with magnitude&nbsp;&lt;varname&gt;l&lt;/varname&gt; and
  	 phase angles in the &array;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the complex numbers created from polar
  	 coordinates with magnitudes in the &array; and phase
  	 angle&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
  	&lt;entry&gt;Functions Involving Matrices and Tensors&lt;/entry&gt;
! 	&lt;entry&gt;&lt;literal&gt;#include &quot;Pooma/Tiny.h&quot;&lt;/literal&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;T trace (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the sum of the &lt;varname&gt;A&lt;/varname&gt;'s diagonal
  	 entries, viewed as a matrix.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;T det (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the determinant of &lt;varname&gt;A&lt;/varname&gt;, viewed as a matrix.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; transpose (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the transpose of &lt;varname&gt;A&lt;/varname&gt;, viewed as a matrix.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; symmetrize (const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the tensors of &lt;varname&gt;A&lt;/varname&gt; with the
  	 requested output symmetry.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the dot products of values in the two &array;s.
  	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
  	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
  	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the dot products of values in the &array;
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.
  	 Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
*************** std::cout &openopen; A-B &openopen; std:
*** 620,633 ****
  	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; dot (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the dot products of &lt;varname&gt;l&lt;/varname&gt; with
  	 values in the &array;.  Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
  	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
  	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
  	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
--- 620,633 ----
  	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; dot (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the dot products of &lt;varname&gt;l&lt;/varname&gt; with
  	 values in the &array;.  Value type &lt;type&gt;T&lt;/type&gt; equals the type of the
  	 &lt;function&gt;dot&lt;/function&gt; operating on &lt;type&gt;T1&lt;/type&gt;
  	 and &lt;type&gt;T2&lt;/type&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
  	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
*************** std::cout &openopen; A-B &openopen; std:
*** 635,641 ****
  	 must have the same length.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
  	 of &lt;varname&gt;l&lt;/varname&gt; with the vectors in the &array;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
--- 635,641 ----
  	 must have the same length.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
  	 of &lt;varname&gt;l&lt;/varname&gt; with the vectors in the &array;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
*************** std::cout &openopen; A-B &openopen; std:
*** 643,649 ****
  	 must have the same length.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
  	 of vectors in the &array; with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
--- 643,649 ----
  	 must have the same length.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns tensors created by computing the outer product
  	 of vectors in the &array; with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
*************** std::cout &openopen; A-B &openopen; std:
*** 651,658 ****
  	 must have the same length.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const Array&lt;T1&gt;&amp; A, const
! 	 Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer product
  	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
--- 651,658 ----
  	 must have the same length.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const Array&lt;T1&gt;&amp; A, const
! 	 Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer product
  	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
*************** std::cout &openopen; A-B &openopen; std:
*** 660,667 ****
  	 the same length.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const T1&amp; l, const
! 	 Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer
  	 product of &lt;varname&gt;l&lt;/varname&gt; with the vectors in the &array;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
--- 660,667 ----
  	 the same length.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const T1&amp; l, const
! 	 Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer
  	 product of &lt;varname&gt;l&lt;/varname&gt; with the vectors in the &array;.  Value
  	 type&nbsp;&lt;type&gt;T&lt;/type&gt; equals the type of the product of
*************** std::cout &openopen; A-B &openopen; std:
*** 669,676 ****
  	 have the same length.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const
! 	 Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer
  	 product of the vectors in the &array;
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  Value
--- 669,676 ----
  	 have the same length.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const
! 	 Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns matrices created by computing the outer
  	 product of the vectors in the &array;
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.  Value
*************** std::cout &openopen; A-B &openopen; std:
*** 687,694 ****
      &lt;function&gt;max&lt;/function&gt; and &lt;function&gt;min&lt;/function&gt; functions
      supplement named comparison functions.  For example,
      &lt;function&gt;LT&lt;/function&gt; and &lt;function&gt;LE&lt;/function&gt; compute the
!     same thing as the &lt;operator&gt;&lt;&lt;/operator&gt; and
!     &lt;operator&gt;&lt;=&lt;/operator&gt; operators.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;data_parallel-use-comparison_functions_table&quot;&gt;
--- 687,694 ----
      &lt;function&gt;max&lt;/function&gt; and &lt;function&gt;min&lt;/function&gt; functions
      supplement named comparison functions.  For example,
      &lt;function&gt;LT&lt;/function&gt; and &lt;function&gt;LE&lt;/function&gt; compute the
!     same thing as the &lt;literal&gt;&lt;&lt;/literal&gt; and
!     &lt;literal&gt;&lt;=&lt;/literal&gt; operators.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;data_parallel-use-comparison_functions_table&quot;&gt;
*************** std::cout &openopen; A-B &openopen; std:
*** 703,826 ****
        &lt;/thead&gt;
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the maximum of corresponding &array; values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the maximums of &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the maximums of the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the minimum of corresponding &array; values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the minimums of &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the minimums of the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt;operator&gt;&lt;&lt;/operator&gt; to compare corresponding &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const T1&amp; r, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt;operator&gt;&lt;&lt;/operator&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s
  	 values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt;operator&gt;&lt;&lt;/operator&gt; to compare the &array;'s
  	 values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&lt;=&lt;/operator&gt; to compare &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&lt;=&lt;/operator&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&lt;=&lt;/operator&gt; to compare the &array;'s values
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&gt;=&lt;/operator&gt; to compare &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&gt;=&lt;/operator&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&lt;operator&gt;&gt;=&lt;/operator&gt; to compare the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&lt;operator&gt;&gt;&lt;/operator&gt; to compare &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&lt;operator&gt;&gt;&lt;/operator&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&lt;operator&gt;&gt;&lt;/operator&gt; to compare the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
  	 corresponding &array; values in &lt;varname&gt;A&lt;/varname&gt; and
  	 &lt;varname&gt;B&lt;/varname&gt; are equal.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
  	 &lt;varname&gt;l&lt;/varname&gt; equals the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether the &array;'s values equal&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
  	 corresponding &array; values in &lt;varname&gt;A&lt;/varname&gt; and
  	 &lt;varname&gt;B&lt;/varname&gt; are not equal.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
  	 &lt;varname&gt;l&lt;/varname&gt; does not equal the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;statement&gt;Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/statement&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether the 
  	 &array;'s values are not equal to&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
--- 703,826 ----
        &lt;/thead&gt;
        &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the maximum of corresponding &array; values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; max (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the maximums of &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the maximums of the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the minimum of corresponding &array; values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; min (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the minimums of &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns the minimums of the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt;literal&gt;&lt;&lt;/literal&gt; to compare corresponding &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; LT (const T1&amp; r, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt;literal&gt;&lt;&lt;/literal&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s
  	 values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than
! 	 operator&nbsp;&lt;literal&gt;&lt;&lt;/literal&gt; to compare the &array;'s
  	 values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&lt;literal&gt;&lt;=&lt;/literal&gt; to compare &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; LE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&lt;literal&gt;&lt;=&lt;/literal&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&lt;literal&gt;&lt;=&lt;/literal&gt; to compare the &array;'s values
  	 with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&lt;literal&gt;&gt;=&lt;/literal&gt; to compare &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; GE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&lt;literal&gt;&gt;=&lt;/literal&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&lt;literal&gt;&gt;=&lt;/literal&gt; to compare the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&lt;literal&gt;&gt;&lt;/literal&gt; to compare &array; values in
  	 &lt;varname&gt;A&lt;/varname&gt; and&nbsp;&lt;varname&gt;B&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; GT (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&lt;literal&gt;&gt;&lt;/literal&gt; to compare &lt;varname&gt;l&lt;/varname&gt; with the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from using the greater-than
! 	 operator&nbsp;&lt;literal&gt;&gt;&lt;/literal&gt; to compare the &array;'s values with&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
  	 corresponding &array; values in &lt;varname&gt;A&lt;/varname&gt; and
  	 &lt;varname&gt;B&lt;/varname&gt; are equal.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; EQ (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
  	 &lt;varname&gt;l&lt;/varname&gt; equals the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether the &array;'s values equal&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
  	 corresponding &array; values in &lt;varname&gt;A&lt;/varname&gt; and
  	 &lt;varname&gt;B&lt;/varname&gt; are not equal.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; NE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether
  	 &lt;varname&gt;l&lt;/varname&gt; does not equal the &array;'s values.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;&lt;literal&gt;Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;Returns booleans from determining whether the 
  	 &array;'s values are not equal to&nbsp;&lt;varname&gt;r&lt;/varname&gt;.&lt;/entry&gt;
         &lt;/row&gt;
*************** std::cout &openopen; A-B &openopen; std:
*** 834,840 ****
      two functions.  &lt;function&gt;peteCast&lt;/function&gt; casts all values in
      an &array; to the type specified by its first parameter.  The
      &lt;function&gt;where&lt;/function&gt; function generalizes the trinary
!     &lt;operator&gt;?:&lt;/operator&gt; operator.  Using its first &array;
      argument as boolean values, it returns an &array; of just two
      values: &lt;parameter&gt;t&lt;/parameter&gt; and &lt;parameter&gt;f&lt;/parameter&gt;.&lt;/para&gt;
  
--- 834,840 ----
      two functions.  &lt;function&gt;peteCast&lt;/function&gt; casts all values in
      an &array; to the type specified by its first parameter.  The
      &lt;function&gt;where&lt;/function&gt; function generalizes the trinary
!     &lt;literal&gt;?:&lt;/literal&gt; operator.  Using its first &array;
      argument as boolean values, it returns an &array; of just two
      values: &lt;parameter&gt;t&lt;/parameter&gt; and &lt;parameter&gt;f&lt;/parameter&gt;.&lt;/para&gt;
  
*************** std::cout &openopen; A-B &openopen; std:
*** 851,862 ****
  	 &lt;/thead&gt;
  	 &lt;tbody valign=&quot;top&quot;&gt;
  	  &lt;row&gt;
! 	   &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; peteCast (const T1&amp;, const Array&lt;T&gt;&amp; A)&lt;/statement&gt;&lt;/entry&gt;
  	   &lt;entry&gt;Returns the casting of the &array;'s values to type &lt;type&gt;T1&lt;/type&gt;.&lt;/entry&gt;
  	  &lt;/row&gt;
  	  &lt;row&gt;
! 	   &lt;entry&gt;&lt;statement&gt;Array&lt;T&gt; where (const Array&lt;T1&gt;&amp; A, const T2&amp; t, const T3&amp; f)&lt;/statement&gt;&lt;/entry&gt;
! 	   &lt;entry&gt;Generalizes the &lt;operator&gt;?:&lt;/operator&gt; operator,
  	returning an &array; of &lt;varname&gt;t&lt;/varname&gt; and
  	&lt;varname&gt;f&lt;/varname&gt; values depending on whether
  	&lt;varname&gt;A&lt;/varname&gt;'s values are true or false,
--- 851,862 ----
  	 &lt;/thead&gt;
  	 &lt;tbody valign=&quot;top&quot;&gt;
  	  &lt;row&gt;
! 	   &lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; peteCast (const T1&amp;, const Array&lt;T&gt;&amp; A)&lt;/literal&gt;&lt;/entry&gt;
  	   &lt;entry&gt;Returns the casting of the &array;'s values to type &lt;type&gt;T1&lt;/type&gt;.&lt;/entry&gt;
  	  &lt;/row&gt;
  	  &lt;row&gt;
! 	   &lt;entry&gt;&lt;literal&gt;Array&lt;T&gt; where (const Array&lt;T1&gt;&amp; A, const T2&amp; t, const T3&amp; f)&lt;/literal&gt;&lt;/entry&gt;
! 	   &lt;entry&gt;Generalizes the &lt;literal&gt;?:&lt;/literal&gt; operator,
  	returning an &array; of &lt;varname&gt;t&lt;/varname&gt; and
  	&lt;varname&gt;f&lt;/varname&gt; values depending on whether
  	&lt;varname&gt;A&lt;/varname&gt;'s values are true or false,
*************** B = 2.0;
*** 926,932 ****
  A += -A + 2*B;
  std::cout &openopen; A &openopen; std::endl;
  &lt;/programlisting&gt; Our goal is to transform the data-parallel
!      statement &lt;statement&gt;A += -A + 2*B&lt;/statement&gt; into a single
       loop, preferably without using intermediary containers.  To
       simplify notation, let &lt;type&gt;Ar&lt;/type&gt; abbreviate the type
       &lt;type&gt;Array&lt;1, double, Brick&gt;&lt;/type&gt;.&lt;/para&gt;
--- 926,932 ----
  A += -A + 2*B;
  std::cout &openopen; A &openopen; std::endl;
  &lt;/programlisting&gt; Our goal is to transform the data-parallel
!      statement &lt;literal&gt;A += -A + 2*B&lt;/literal&gt; into a single
       loop, preferably without using intermediary containers.  To
       simplify notation, let &lt;type&gt;Ar&lt;/type&gt; abbreviate the type
       &lt;type&gt;Array&lt;1, double, Brick&gt;&lt;/type&gt;.&lt;/para&gt;
*************** std::cout &openopen; A &openopen; std::e
*** 934,945 ****
       &lt;para&gt;Using overloaded arithmetic operators would require using
       intermediate containers to evaluate the statement.  For example,
       &lt;!-- FIXME: What is the proper tag for an inline function
!      prototype? --&gt; the sum's left operand &lt;statement&gt;-A&lt;/statement&gt;
!      would be computed by the overloaded unary operator &lt;statement&gt;Ar
!      operator-(const Ar&amp;)&lt;/statement&gt;, which would produce an
!      intermediate &array;.  &lt;statement&gt;Ar operator*(double,
!      const Ar&amp;)&lt;/statement&gt; would produce another intermediate
!      &array; holding &lt;statement&gt;2*B&lt;/statement&gt;.  Yet another
       intermediate container would hold their sum, all before
       performing the assignment.  Thus, three intermediate containers
       would be created and destroyed.  Below, we show these are
--- 934,945 ----
       &lt;para&gt;Using overloaded arithmetic operators would require using
       intermediate containers to evaluate the statement.  For example,
       &lt;!-- FIXME: What is the proper tag for an inline function
!      prototype? --&gt; the sum's left operand &lt;literal&gt;-A&lt;/literal&gt;
!      would be computed by the overloaded unary operator &lt;literal&gt;Ar
!      operator-(const Ar&amp;)&lt;/literal&gt;, which would produce an
!      intermediate &array;.  &lt;literal&gt;Ar operator*(double,
!      const Ar&amp;)&lt;/literal&gt; would produce another intermediate
!      &array; holding &lt;literal&gt;2*B&lt;/literal&gt;.  Yet another
       intermediate container would hold their sum, all before
       performing the assignment.  Thus, three intermediate containers
       would be created and destroyed.  Below, we show these are
*************** std::cout &openopen; A &openopen; std::e
*** 965,976 ****
       intermediate loops or temporary values are needed.&lt;/para&gt;
  
       &lt;para&gt;Before explaining the implementation, let us illustrate
!      using our example statement &lt;statement&gt;A += -A + 2*B&lt;/statement&gt;.
       Evaluating the right-hand side creates a parse tree similar to
       the one in &lt;xref
       linkend=&quot;data_parallel-implementation-pete-tree_figure&quot;&gt;&lt;/xref&gt;.
       For example, the overloaded unary minus operator yields a tree
!      node representing &lt;statement&gt;-A&lt;/statement&gt;, having a unary-minus
       function object, and having type
  &lt;programlisting&gt;
  Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;
--- 965,976 ----
       intermediate loops or temporary values are needed.&lt;/para&gt;
  
       &lt;para&gt;Before explaining the implementation, let us illustrate
!      using our example statement &lt;literal&gt;A += -A + 2*B&lt;/literal&gt;.
       Evaluating the right-hand side creates a parse tree similar to
       the one in &lt;xref
       linkend=&quot;data_parallel-implementation-pete-tree_figure&quot;&gt;&lt;/xref&gt;.
       For example, the overloaded unary minus operator yields a tree
!      node representing &lt;literal&gt;-A&lt;/literal&gt;, having a unary-minus
       function object, and having type
  &lt;programlisting&gt;
  Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;
*************** Expression&lt;BinaryNode&lt;OpAdd,
*** 984,990 ****
       representing&nbsp;&lt;varname&gt;A&lt;/varname&gt;.&lt;/para&gt;
  
       &lt;figure float=&quot;1&quot; id=&quot;data_parallel-implementation-pete-tree_figure&quot;&gt;
!       &lt;title&gt;Annotated Parse Tree for &lt;statement&gt;-A + 2*B&lt;/statement&gt;&lt;/title&gt;
         &lt;mediaobject&gt;
  	&lt;imageobject&gt;
  	 &lt;imagedata fileref=&quot;figures/data-parallel.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
--- 984,990 ----
       representing&nbsp;&lt;varname&gt;A&lt;/varname&gt;.&lt;/para&gt;
  
       &lt;figure float=&quot;1&quot; id=&quot;data_parallel-implementation-pete-tree_figure&quot;&gt;
!       &lt;title&gt;Annotated Parse Tree for &lt;literal&gt;-A + 2*B&lt;/literal&gt;&lt;/title&gt;
         &lt;mediaobject&gt;
  	&lt;imageobject&gt;
  	 &lt;imagedata fileref=&quot;figures/data-parallel.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
*************** Expression&lt;BinaryNode&lt;OpAdd,
*** 996,1009 ****
  	 &lt;phrase&gt;A parse tree for the statement is produced.&lt;/phrase&gt;
  	&lt;/textobject&gt;
  	&lt;caption&gt;
! 	 &lt;para&gt;The parse tree for &lt;statement&gt;-A + 2*B&lt;/statement&gt; with
          type annotations.  The complete type of a node equals the
          concatenation of the preorder traversal of annotated types.&lt;/para&gt;
  	&lt;/caption&gt;
         &lt;/mediaobject&gt;
        &lt;/figure&gt;
  
!      &lt;para&gt;Finally, the assignment operator &lt;statement&gt;+=&lt;/statement&gt;
       calls the &lt;function&gt;evaluate&lt;/function&gt; function corresponding to
       the left-hand side's type.  At compile time, it produces the code
       for the computation.  Since this templated function is
--- 996,1009 ----
  	 &lt;phrase&gt;A parse tree for the statement is produced.&lt;/phrase&gt;
  	&lt;/textobject&gt;
  	&lt;caption&gt;
! 	 &lt;para&gt;The parse tree for &lt;literal&gt;-A + 2*B&lt;/literal&gt; with
          type annotations.  The complete type of a node equals the
          concatenation of the preorder traversal of annotated types.&lt;/para&gt;
  	&lt;/caption&gt;
         &lt;/mediaobject&gt;
        &lt;/figure&gt;
  
!      &lt;para&gt;Finally, the assignment operator &lt;literal&gt;+=&lt;/literal&gt;
       calls the &lt;function&gt;evaluate&lt;/function&gt; function corresponding to
       the left-hand side's type.  At compile time, it produces the code
       for the computation.  Since this templated function is
*************** Expression&lt;BinaryNode&lt;OpAdd,
*** 1033,1039 ****
       the three things it must store:
       &lt;variablelist&gt;
  	&lt;varlistentry&gt;
! 	 &lt;term&gt;&lt;statement&gt;Op&lt;/statement&gt;&lt;/term&gt;
  	 &lt;listitem&gt;
  	  &lt;para&gt;the type of the node's operation.  For example, the
  	 &lt;type&gt;OpAdd&lt;/type&gt; type represents adding two operands
--- 1033,1039 ----
       the three things it must store:
       &lt;variablelist&gt;
  	&lt;varlistentry&gt;
! 	 &lt;term&gt;&lt;literal&gt;Op&lt;/literal&gt;&lt;/term&gt;
  	 &lt;listitem&gt;
  	  &lt;para&gt;the type of the node's operation.  For example, the
  	 &lt;type&gt;OpAdd&lt;/type&gt; type represents adding two operands
*************** Expression&lt;BinaryNode&lt;OpAdd,
*** 1041,1053 ****
  	 &lt;/listitem&gt;
  	&lt;/varlistentry&gt;
  	&lt;varlistentry&gt;
! 	 &lt;term&gt;&lt;statement&gt;Left&lt;/statement&gt;&lt;/term&gt;
  	 &lt;listitem&gt;
  	  &lt;para&gt;the type of the left child.&lt;/para&gt;
  	 &lt;/listitem&gt;
  	&lt;/varlistentry&gt;
  	&lt;varlistentry&gt;
! 	 &lt;term&gt;&lt;statement&gt;Right&lt;/statement&gt;&lt;/term&gt;
  	 &lt;listitem&gt;
  	  &lt;para&gt;the type of the right child.&lt;/para&gt;
  	 &lt;/listitem&gt;
--- 1041,1053 ----
  	 &lt;/listitem&gt;
  	&lt;/varlistentry&gt;
  	&lt;varlistentry&gt;
! 	 &lt;term&gt;&lt;literal&gt;Left&lt;/literal&gt;&lt;/term&gt;
  	 &lt;listitem&gt;
  	  &lt;para&gt;the type of the left child.&lt;/para&gt;
  	 &lt;/listitem&gt;
  	&lt;/varlistentry&gt;
  	&lt;varlistentry&gt;
! 	 &lt;term&gt;&lt;literal&gt;Right&lt;/literal&gt;&lt;/term&gt;
  	 &lt;listitem&gt;
  	  &lt;para&gt;the type of the right child.&lt;/para&gt;
  	 &lt;/listitem&gt;
*************** struct CreateLeaf
*** 1096,1102 ****
  };
  &lt;/programlisting&gt; The &lt;type&gt;Scalar&lt;/type&gt; class stores the scalar
      value.  The &lt;type&gt;CreateLeaf&lt;/type&gt;'s &lt;type&gt;Leaf_t&lt;/type&gt; type
!     indicates its type.  The &lt;statement&gt;static&lt;/statement&gt;
      &lt;function&gt;make&lt;/function&gt; function is invoked by an overloaded
      operator function when creating its children.&lt;/para&gt;
  
--- 1096,1102 ----
  };
  &lt;/programlisting&gt; The &lt;type&gt;Scalar&lt;/type&gt; class stores the scalar
      value.  The &lt;type&gt;CreateLeaf&lt;/type&gt;'s &lt;type&gt;Leaf_t&lt;/type&gt; type
!     indicates its type.  The &lt;literal&gt;static&lt;/literal&gt;
      &lt;function&gt;make&lt;/function&gt; function is invoked by an overloaded
      operator function when creating its children.&lt;/para&gt;
  
*************** CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;
*** 1149,1155 ****
      programmers to store trees in different formats.  The &pooma;
      implementation stores them as &lt;type&gt;Expression&lt;/type&gt;s.  The
      function's return type is similar to the
!     &lt;statement&gt;return&lt;/statement&gt; statement except it extracts the
      type from &lt;type&gt;Expression&lt;/type&gt;'s internal
      &lt;type&gt;Expression_t&lt;/type&gt; type.&lt;/para&gt;
  
--- 1149,1155 ----
      programmers to store trees in different formats.  The &pooma;
      implementation stores them as &lt;type&gt;Expression&lt;/type&gt;s.  The
      function's return type is similar to the
!     &lt;literal&gt;return&lt;/literal&gt; statement except it extracts the
      type from &lt;type&gt;Expression&lt;/type&gt;'s internal
      &lt;type&gt;Expression_t&lt;/type&gt; type.&lt;/para&gt;
  
*************** classes
*** 1171,1178 ****
      Inside the &array; class definition, each such operator just
      invokes the &lt;function&gt;assign&lt;/function&gt; function with a
      corresponding function object.  For example,
!     &lt;function&gt;operator+=&lt;/function&gt; invokes &lt;statement&gt;assign(*this,
!     rhs, OpAddAssign())&lt;/statement&gt;.  &lt;varname&gt;rhs&lt;/varname&gt; is the
      parse tree object for the right-hand side.  Calling this function
      invokes &lt;function&gt;evaluate&lt;/function&gt;, which begins the
      evaluation.&lt;/para&gt;
--- 1171,1178 ----
      Inside the &array; class definition, each such operator just
      invokes the &lt;function&gt;assign&lt;/function&gt; function with a
      corresponding function object.  For example,
!     &lt;function&gt;operator+=&lt;/function&gt; invokes &lt;literal&gt;assign(*this,
!     rhs, OpAddAssign())&lt;/literal&gt;.  &lt;varname&gt;rhs&lt;/varname&gt; is the
      parse tree object for the right-hand side.  Calling this function
      invokes &lt;function&gt;evaluate&lt;/function&gt;, which begins the
      evaluation.&lt;/para&gt;
*************** for (int i = a's domain[0].first(); i &lt; 
*** 1204,1210 ****
      assignment operation, and &lt;varname&gt;rhs&lt;/varname&gt; is the right-hand
      side's parse tree.&lt;/para&gt;
  
!      &lt;para&gt;Evaluating &lt;statement&gt;rhs.read(i)&lt;/statement&gt; inlines into a
      call to the &lt;function&gt;forEach&lt;/function&gt; function.  This function
      performs a &lt;emphasis&gt;compile-time&lt;/emphasis&gt; post-order parse-tree
      traversal.  Its general form is
--- 1204,1210 ----
      assignment operation, and &lt;varname&gt;rhs&lt;/varname&gt; is the right-hand
      side's parse tree.&lt;/para&gt;
  
!      &lt;para&gt;Evaluating &lt;literal&gt;rhs.read(i)&lt;/literal&gt; inlines into a
      call to the &lt;function&gt;forEach&lt;/function&gt; function.  This function
      performs a &lt;emphasis&gt;compile-time&lt;/emphasis&gt; post-order parse-tree
      traversal.  Its general form is
*************** struct ForEach&lt;UnaryNode&lt;Op, A&gt;
*** 1249,1255 ****
  };
  &lt;/programlisting&gt;  Since this structure is specialized for
      &lt;type&gt;UnaryNode&lt;/type&gt;s, the first parameter of its
!     &lt;statement&gt;static &lt;/statement&gt; &lt;function&gt;apply&lt;/function&gt; function
      is a &lt;type&gt;UnaryNode&lt;/type&gt;.  After recursively calling its child,
      it invokes the combination function indicated by the
      &lt;type&gt;Combine1&lt;/type&gt; traits class.  In our example, the
--- 1249,1255 ----
  };
  &lt;/programlisting&gt;  Since this structure is specialized for
      &lt;type&gt;UnaryNode&lt;/type&gt;s, the first parameter of its
!     &lt;literal&gt;static &lt;/literal&gt; &lt;function&gt;apply&lt;/function&gt; function
      is a &lt;type&gt;UnaryNode&lt;/type&gt;.  After recursively calling its child,
      it invokes the combination function indicated by the
      &lt;type&gt;Combine1&lt;/type&gt; traits class.  In our example, the
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.9
diff -c -p -r1.9 glossary.xml
*** glossary.xml	2002/01/25 02:28:26	1.9
--- glossary.xml	2002/01/30 23:47:32
***************
*** 227,233 ****
     &lt;glossdef&gt;
      &lt;para&gt;describes an expression involving a (non-singleton) subset
      of a container's values.  For example,
!     &lt;statement&gt;sin(&container;)&lt;/statement&gt; is an expression
      indicating that the &lt;function&gt;sin&lt;/function&gt; is applied to each
      value in container&nbsp;&container;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-element_wise&quot;&gt;element wise&lt;/glossseealso&gt;
--- 227,233 ----
     &lt;glossdef&gt;
      &lt;para&gt;describes an expression involving a (non-singleton) subset
      of a container's values.  For example,
!     &lt;literal&gt;sin(&container;)&lt;/literal&gt; is an expression
      indicating that the &lt;function&gt;sin&lt;/function&gt; is applied to each
      value in container&nbsp;&container;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-element_wise&quot;&gt;element wise&lt;/glossseealso&gt;
***************
*** 305,311 ****
     &lt;glossterm&gt;element wise&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;describes accesses to individual values within a container.
!     For example, &lt;statement&gt;&amp;container(-4,3)&lt;/statement&gt; represents one
      particular value in the container&nbsp;&container;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-relation&quot;&gt;relation&lt;/glossseealso&gt;
--- 305,311 ----
     &lt;glossterm&gt;element wise&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;describes accesses to individual values within a container.
!     For example, &lt;literal&gt;&amp;container(-4,3)&lt;/literal&gt; represents one
      particular value in the container&nbsp;&container;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-relation&quot;&gt;relation&lt;/glossseealso&gt;
***************
*** 413,419 ****
     &lt;glossdef&gt;
      &lt;para&gt;object that can behave as a function.  The object can store
      values that the function uses.  If its function is called
!     &lt;methodname&gt;operator()&lt;/methodname&gt;, the object can be invoked as
      a function.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
--- 413,419 ----
     &lt;glossdef&gt;
      &lt;para&gt;object that can behave as a function.  The object can store
      values that the function uses.  If its function is called
!     &lt;literal&gt;operator()&lt;/literal&gt;, the object can be invoked as
      a function.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
*************** guard layer&lt;/glossseealso&gt;
*** 602,608 ****
       &lt;/indexterm&gt;
      function defining a function invoked using a &cc; operator.  For
      example, the &lt;function&gt;operator+&lt;/function&gt; function defines the
!     result of using the &lt;operator&gt;+&lt;/operator&gt;.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
--- 602,608 ----
       &lt;/indexterm&gt;
      function defining a function invoked using a &cc; operator.  For
      example, the &lt;function&gt;operator+&lt;/function&gt; function defines the
!     result of using the &lt;literal&gt;+&lt;/literal&gt;.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
*************** guard layer&lt;/glossseealso&gt;
*** 814,822 ****
       &lt;primary&gt;template instantiation&lt;/primary&gt;
      &lt;/indexterm&gt;
      applying a template class to template parameter arguments to create a
!     type.  For example, &lt;statement&gt;foo&lt;double,3&gt;&lt;/statement&gt;
!     instantiates &lt;statement&gt;template &lt;typename T, int n&gt; class
!     foo&lt;/statement&gt; with the type &double; and the constant
      integer&nbsp;3.  Template instantiation is analogous to applying a
      function to function arguments.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-template&quot;&gt;template&lt;/glossseealso&gt;
--- 814,822 ----
       &lt;primary&gt;template instantiation&lt;/primary&gt;
      &lt;/indexterm&gt;
      applying a template class to template parameter arguments to create a
!     type.  For example, &lt;literal&gt;foo&lt;double,3&gt;&lt;/literal&gt;
!     instantiates &lt;literal&gt;template &lt;typename T, int n&gt; class
!     foo&lt;/literal&gt; with the type &double; and the constant
      integer&nbsp;3.  Template instantiation is analogous to applying a
      function to function arguments.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-template&quot;&gt;template&lt;/glossseealso&gt;
Index: introduction.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/introduction.xml,v
retrieving revision 1.6
diff -c -p -r1.6 introduction.xml
*** introduction.xml	2002/01/30 23:09:06	1.6
--- introduction.xml	2002/01/30 23:47:32
*************** A += -B + 2 * C;
*** 298,305 ****
  &lt;/programlisting&gt; where &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;C&lt;/varname&gt; are
    &lt;type&gt;vector&lt;double&gt;&lt;/type&gt;s and &lt;varname&gt;B&lt;/varname&gt; is a
    &lt;type&gt;vector&lt;int&gt;&lt;/type&gt;.  &naivecap; evaluation might introduce
!   intermediaries for &lt;statement&gt;-B&lt;/statement&gt;,
!   &lt;statement&gt;2*C&lt;/statement&gt;, and their sum.  The presence of these
    intermediaries in inner loops can measurably slow performance.  To
    produce a loop without intermediaries, &pete; stores each expression
    as a parse tree.  Using its templates, the parse tree is
--- 298,305 ----
  &lt;/programlisting&gt; where &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;C&lt;/varname&gt; are
    &lt;type&gt;vector&lt;double&gt;&lt;/type&gt;s and &lt;varname&gt;B&lt;/varname&gt; is a
    &lt;type&gt;vector&lt;int&gt;&lt;/type&gt;.  &naivecap; evaluation might introduce
!   intermediaries for &lt;literal&gt;-B&lt;/literal&gt;,
!   &lt;literal&gt;2*C&lt;/literal&gt;, and their sum.  The presence of these
    intermediaries in inner loops can measurably slow performance.  To
    produce a loop without intermediaries, &pete; stores each expression
    as a parse tree.  Using its templates, the parse tree is
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.12
diff -c -p -r1.12 manual.xml
*** manual.xml	2002/01/30 23:09:06	1.12
--- manual.xml	2002/01/30 23:47:35
***************
*** 108,114 ****
    &lt;!-- The &quot;DynamicArray&quot; type. --&gt;
  &lt;!ENTITY engine &quot;&lt;type&gt;Engine&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;Engine&quot; type. --&gt;
! &lt;!ENTITY false &quot;&lt;statement&gt;false&lt;/statement&gt;&quot;&gt;
    &lt;!-- The false Boolean value. --&gt;
    &lt;!-- Modify its tag to the appropriate one. --&gt;
  &lt;!ENTITY field &quot;&lt;type&gt;Field&lt;/type&gt;&quot;&gt;
--- 108,114 ----
    &lt;!-- The &quot;DynamicArray&quot; type. --&gt;
  &lt;!ENTITY engine &quot;&lt;type&gt;Engine&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;Engine&quot; type. --&gt;
! &lt;!ENTITY false &quot;&lt;literal&gt;false&lt;/literal&gt;&quot;&gt;
    &lt;!-- The false Boolean value. --&gt;
    &lt;!-- Modify its tag to the appropriate one. --&gt;
  &lt;!ENTITY field &quot;&lt;type&gt;Field&lt;/type&gt;&quot;&gt;
***************
*** 157,163 ****
    &lt;!-- The &quot;Stencil&quot; type. --&gt;
  &lt;!ENTITY tensor &quot;&lt;type&gt;Tensor&lt;/type&gt;&quot;&gt;
    &lt;!-- The Pooma tensor type. --&gt;
! &lt;!ENTITY true &quot;&lt;statement&gt;true&lt;/statement&gt;&quot;&gt;
    &lt;!-- The true Boolean value. --&gt;
    &lt;!-- Modify its tag to the appropriate one. --&gt;
  &lt;!ENTITY vector &quot;&lt;type&gt;Vector&lt;/type&gt;&quot;&gt;
--- 157,163 ----
    &lt;!-- The &quot;Stencil&quot; type. --&gt;
  &lt;!ENTITY tensor &quot;&lt;type&gt;Tensor&lt;/type&gt;&quot;&gt;
    &lt;!-- The Pooma tensor type. --&gt;
! &lt;!ENTITY true &quot;&lt;literal&gt;true&lt;/literal&gt;&quot;&gt;
    &lt;!-- The true Boolean value. --&gt;
    &lt;!-- Modify its tag to the appropriate one. --&gt;
  &lt;!ENTITY vector &quot;&lt;type&gt;Vector&lt;/type&gt;&quot;&gt;
***************
*** 446,454 ****
      and accessor functions returning individual elements.  The &pooma;
      &engine; class and its specializations implement the engine
      concept.  Given an index within the domain, an &engine;'s
!     &lt;methodname&gt;operator()&lt;/methodname&gt; function returns the
      associated value, which can be used or changed.  Its
!     &lt;methodname&gt;read&lt;/methodname&gt; member function returns the same
      value but permitting only use, not modification.  The acceptable
      indices are determined by each &engine;.  Most accept indices
      specified using &int; and &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt;
--- 446,454 ----
      and accessor functions returning individual elements.  The &pooma;
      &engine; class and its specializations implement the engine
      concept.  Given an index within the domain, an &engine;'s
!     &lt;literal&gt;operator()&lt;/literal&gt; function returns the
      associated value, which can be used or changed.  Its
!     &lt;literal&gt;read&lt;/literal&gt; member function returns the same
      value but permitting only use, not modification.  The acceptable
      indices are determined by each &engine;.  Most accept indices
      specified using &int; and &lt;type&gt;Loc&lt;&dim;&gt;&lt;/type&gt;
***************
*** 499,505 ****
      Thus, copying an &engine; or a container requires little execution
      time.  If an &engine; has the same data as another &engine; but it
      needs its own data to modify, the
!     &lt;methodname&gt;makeOwnCopy&lt;/methodname&gt; member function creates such
      a copy.&lt;/para&gt;
  
      &lt;para&gt;&engine;s are rarely explicitly declared.  Instead a
--- 499,505 ----
      Thus, copying an &engine; or a container requires little execution
      time.  If an &engine; has the same data as another &engine; but it
      needs its own data to modify, the
!     &lt;literal&gt;makeOwnCopy&lt;/literal&gt; member function creates such
      a copy.&lt;/para&gt;
  
      &lt;para&gt;&engine;s are rarely explicitly declared.  Instead a
***************
*** 517,524 ****
      &brick; &engine; tag indicates a &brick; &engine; should be used.
      Some &engine;s, such as &lt;type&gt;CompFwd&lt;/type&gt;, are rarely declared
      even using &engine; tags.  Instead the &array;'s
!     &lt;methodname&gt;comp&lt;/methodname&gt; and
!     &lt;methodname&gt;readComp&lt;/methodname&gt; member functions return views of
      containers using &lt;type&gt;CompFwd&lt;/type&gt; &engine;s.&lt;/para&gt;
     &lt;/section&gt;
  
--- 517,524 ----
      &brick; &engine; tag indicates a &brick; &engine; should be used.
      Some &engine;s, such as &lt;type&gt;CompFwd&lt;/type&gt;, are rarely declared
      even using &engine; tags.  Instead the &array;'s
!     &lt;literal&gt;comp&lt;/literal&gt; and
!     &lt;literal&gt;readComp&lt;/literal&gt; member functions return views of
      containers using &lt;type&gt;CompFwd&lt;/type&gt; &engine;s.&lt;/para&gt;
     &lt;/section&gt;
  
***************
*** 569,575 ****
  	 &lt;entry&gt;&lt;type&gt;CompFwd&lt;/type&gt;&lt;/entry&gt;
  	 &lt;entry&gt;extracts specified components of an engine's vectors,
  	 tensors, arrays, etc.; usually created using the
! 	 &lt;methodname&gt;comp&lt;/methodname&gt; container function.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;type&gt;ConstantFunction&lt;/type&gt;&lt;/entry&gt;
--- 569,575 ----
  	 &lt;entry&gt;&lt;type&gt;CompFwd&lt;/type&gt;&lt;/entry&gt;
  	 &lt;entry&gt;extracts specified components of an engine's vectors,
  	 tensors, arrays, etc.; usually created using the
! 	 &lt;literal&gt;comp&lt;/literal&gt; container function.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;&lt;type&gt;ConstantFunction&lt;/type&gt;&lt;/entry&gt;
***************
*** 644,652 ****
      value, not every value.  Using less storage space may also permit
      more useful values to be stored in cache, improving cache
      performance.  Reading a value in a compressed &engine; using the
!     &lt;methodname&gt;read&lt;/methodname&gt; member function is as fast as
      reading a value in a &brick; &engine;, but writing a value always
!     requires executing an additional &lt;keywordname&gt;if&lt;/keywordname&gt;
      conditional.  Thus, if an &engine; infrequently has multiple
      different values during its life time, a &compressiblebrick;
      &engine; may be faster than a &brick; &engine;.  If an &engine; is
--- 644,652 ----
      value, not every value.  Using less storage space may also permit
      more useful values to be stored in cache, improving cache
      performance.  Reading a value in a compressed &engine; using the
!     &lt;literal&gt;read&lt;/literal&gt; member function is as fast as
      reading a value in a &brick; &engine;, but writing a value always
!     requires executing an additional &lt;literal&gt;if&lt;/literal&gt;
      conditional.  Thus, if an &engine; infrequently has multiple
      different values during its life time, a &compressiblebrick;
      &engine; may be faster than a &brick; &engine;.  If an &engine; is
***************
*** 664,683 ****
      distributed computing.&lt;/para&gt;
  
      &lt;para&gt;Both &brick; and &compressiblebrick; &engine;s have
!     &lt;methodname&gt;read&lt;/methodname&gt; and
!     &lt;methodname&gt;operator()&lt;/methodname&gt; member functions taking &int;
      and &loc; parameters.  The parameters should match the &array;'s
      dimensionality.  For example, if &array; &lt;varname&gt;a&lt;/varname&gt; has
      dimensionality&nbsp;3, &lt;function&gt;a.read(int, int, int)&lt;/function&gt;
      and &lt;function&gt;a(int, int, int)&lt;/function&gt; should be used.  The
      former returns a value that cannot be modified, while the latter
!     can be changed.  Using the &lt;methodname&gt;read&lt;/methodname&gt; member
      function can lead to faster code.  Alternatively, an index can be
      specified using a &loc;.  For example,
!     &lt;statement&gt;a.read(Loc&lt;3&gt;(1,-2,5))&lt;/statement&gt; and
!     &lt;statement&gt;a(Loc&lt;3&gt;(1,-2,5))&lt;/statement&gt; are equivalent to
!     &lt;statement&gt;a.read(1,-2,5))&lt;/statement&gt; and
!     &lt;statement&gt;a(1,-2,5)&lt;/statement&gt;.&lt;/para&gt;
  
      &lt;para&gt;The &dynamic; &engine; supports changing domain sizes while
      a program is executing.  It is basically a one-dimensional
--- 664,683 ----
      distributed computing.&lt;/para&gt;
  
      &lt;para&gt;Both &brick; and &compressiblebrick; &engine;s have
!     &lt;literal&gt;read&lt;/literal&gt; and
!     &lt;literal&gt;operator()&lt;/literal&gt; member functions taking &int;
      and &loc; parameters.  The parameters should match the &array;'s
      dimensionality.  For example, if &array; &lt;varname&gt;a&lt;/varname&gt; has
      dimensionality&nbsp;3, &lt;function&gt;a.read(int, int, int)&lt;/function&gt;
      and &lt;function&gt;a(int, int, int)&lt;/function&gt; should be used.  The
      former returns a value that cannot be modified, while the latter
!     can be changed.  Using the &lt;literal&gt;read&lt;/literal&gt; member
      function can lead to faster code.  Alternatively, an index can be
      specified using a &loc;.  For example,
!     &lt;literal&gt;a.read(Loc&lt;3&gt;(1,-2,5))&lt;/literal&gt; and
!     &lt;literal&gt;a(Loc&lt;3&gt;(1,-2,5))&lt;/literal&gt; are equivalent to
!     &lt;literal&gt;a.read(1,-2,5))&lt;/literal&gt; and
!     &lt;literal&gt;a(1,-2,5)&lt;/literal&gt;.&lt;/para&gt;
  
      &lt;para&gt;The &dynamic; &engine; supports changing domain sizes while
      a program is executing.  It is basically a one-dimensional
***************
*** 685,695 ****
      order of stored values to change.  Thus, it supports the same
      interface as &brick; except that all member functions are
      restricted to their one-dimensional versions.  For example,
!     &lt;methodname&gt;read&lt;/methodname&gt; and
!     &lt;methodname&gt;operator()&lt;/methodname&gt; take &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;
      or one &int; parameter.  In addition, the one-dimensional domain
!     can be dynamically resized using &lt;methodname&gt;create&lt;/methodname&gt;
!     and &lt;methodname&gt;destroy&lt;/methodname&gt;.
  &lt;![%unfinished;[
  ; see .
  
--- 685,695 ----
      order of stored values to change.  Thus, it supports the same
      interface as &brick; except that all member functions are
      restricted to their one-dimensional versions.  For example,
!     &lt;literal&gt;read&lt;/literal&gt; and
!     &lt;literal&gt;operator()&lt;/literal&gt; take &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;
      or one &int; parameter.  In addition, the one-dimensional domain
!     can be dynamically resized using &lt;literal&gt;create&lt;/literal&gt;
!     and &lt;literal&gt;destroy&lt;/literal&gt;.
  &lt;![%unfinished;[
  ; see .
  
*************** a(I,J) = (1.0/9.0) *
*** 809,822 ****
     b(I-1,J+1) + b(I-1,J  ) + b(I-1,J-1));
  &lt;/programlisting&gt;  The last statement creates ten views.  For example,
  
!    &lt;statement&gt;a(I,J)&lt;/statement&gt; creates a view of
     &lt;varname&gt;a&lt;/varname&gt; using the smaller domain specified by
     &lt;varname&gt;I&lt;/varname&gt; and &lt;varname&gt;J&lt;/varname&gt;.  This omits the
     outermost rows of columns of&nbsp;&lt;varname&gt;a&lt;/varname&gt;.  The views
     of &lt;varname&gt;b&lt;/varname&gt; illustrate the use of views in
!    data-parallel statements.  &lt;statement&gt;b(I-1,J-1)&lt;/statement&gt; has a
     subset shifted up one row and left one column compared with
!    &lt;statement&gt;b(I,J)&lt;/statement&gt;.&lt;/para&gt;
  ]]&gt;  &lt;!-- end temporary --&gt;
  &lt;![%unfinished;[
     &lt;para&gt;Be sure to list the various arithmetic operations on domains
--- 809,822 ----
     b(I-1,J+1) + b(I-1,J  ) + b(I-1,J-1));
  &lt;/programlisting&gt;  The last statement creates ten views.  For example,
  
!    &lt;literal&gt;a(I,J)&lt;/literal&gt; creates a view of
     &lt;varname&gt;a&lt;/varname&gt; using the smaller domain specified by
     &lt;varname&gt;I&lt;/varname&gt; and &lt;varname&gt;J&lt;/varname&gt;.  This omits the
     outermost rows of columns of&nbsp;&lt;varname&gt;a&lt;/varname&gt;.  The views
     of &lt;varname&gt;b&lt;/varname&gt; illustrate the use of views in
!    data-parallel statements.  &lt;literal&gt;b(I-1,J-1)&lt;/literal&gt; has a
     subset shifted up one row and left one column compared with
!    &lt;literal&gt;b(I,J)&lt;/literal&gt;.&lt;/para&gt;
  ]]&gt;  &lt;!-- end temporary --&gt;
  &lt;![%unfinished;[
     &lt;para&gt;Be sure to list the various arithmetic operations on domains
*************** UNFINISHED&lt;/para&gt;
*** 1601,1607 ****
      &lt;/programlisting&gt; where &lt;varname&gt;A&lt;/varname&gt;, &lt;varname&gt;B&lt;/varname&gt; and
      &lt;varname&gt;C&lt;/varname&gt; are &array;s and &lt;function&gt;foo&lt;/function&gt; is
      a function taking an &array; as an argument.  The expression
!     &lt;statement&gt;&lt;varname&gt;A&lt;/varname&gt;*&lt;varname&gt;B&lt;/varname&gt;+&lt;varname&gt;C&lt;/varname&gt;&lt;/statement&gt;
      will only be evaluated by the expression engine as needed by
      &lt;function&gt;foo&lt;/function&gt;.&lt;/para&gt;
  
--- 1601,1607 ----
      &lt;/programlisting&gt; where &lt;varname&gt;A&lt;/varname&gt;, &lt;varname&gt;B&lt;/varname&gt; and
      &lt;varname&gt;C&lt;/varname&gt; are &array;s and &lt;function&gt;foo&lt;/function&gt; is
      a function taking an &array; as an argument.  The expression
!     &lt;literal&gt;&lt;varname&gt;A&lt;/varname&gt;*&lt;varname&gt;B&lt;/varname&gt;+&lt;varname&gt;C&lt;/varname&gt;&lt;/literal&gt;
      will only be evaluated by the expression engine as needed by
      &lt;function&gt;foo&lt;/function&gt;.&lt;/para&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 1718,1724 ****
        incorrect.  To help diagnose if calls to
        &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; are missing, invoke
        a &pooma; executable with the
!       &lt;statement&gt;&dashdash;pooma-blocking-expressions&lt;/statement&gt; option.
        This automatically causes
        &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; to be called after
        each statement.  Doing so ensures program correctness, but it
--- 1718,1724 ----
        incorrect.  To help diagnose if calls to
        &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; are missing, invoke
        a &pooma; executable with the
!       &lt;literal&gt;&dashdash;pooma-blocking-expressions&lt;/literal&gt; option.
        This automatically causes
        &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; to be called after
        each statement.  Doing so ensures program correctness, but it
*************** UNFINISHED&lt;/para&gt;
*** 1728,1741 ****
        important than execution speed.&lt;/para&gt;
  
        &lt;para&gt;If using
!       &lt;statement&gt;&dashdash;pooma-blocking-expressions&lt;/statement&gt; changes a
        program's output, it is missing one or more calls to
        &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt;.  To narrow the
        region with a missing call, surround the region in question with
!       calls to &lt;statement&gt;Pooma::blockingExpressions(true)&lt;/statement&gt;
!       and &lt;statement&gt;Pooma::blockingExpressions(false)&lt;/statement&gt;,
        but do not use the
!       &lt;statement&gt;&dashdash;pooma-blocking-expressions&lt;/statement&gt; option.
        Within the region, &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt;
        will be invoked after each statement.  Repeatedly reducing the
        region's size should reveal where calls are missing.&lt;/para&gt;
--- 1728,1741 ----
        important than execution speed.&lt;/para&gt;
  
        &lt;para&gt;If using
!       &lt;literal&gt;&dashdash;pooma-blocking-expressions&lt;/literal&gt; changes a
        program's output, it is missing one or more calls to
        &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt;.  To narrow the
        region with a missing call, surround the region in question with
!       calls to &lt;literal&gt;Pooma::blockingExpressions(true)&lt;/literal&gt;
!       and &lt;literal&gt;Pooma::blockingExpressions(false)&lt;/literal&gt;,
        but do not use the
!       &lt;literal&gt;&dashdash;pooma-blocking-expressions&lt;/literal&gt; option.
        Within the region, &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt;
        will be invoked after each statement.  Repeatedly reducing the
        region's size should reveal where calls are missing.&lt;/para&gt;
*************** UNFINISHED&lt;/para&gt;
*** 1767,1773 ****
     class=&quot;libraryfile&quot;&gt;.cmpl.cpp&lt;/filename&gt;, &lt;filename
     class=&quot;libraryfile&quot;&gt;.mk&lt;/filename&gt;, &lt;filename
     class=&quot;libraryfile&quot;&gt;.conf&lt;/filename&gt;.  Should we also explain use
!    of &lt;keywordname&gt;inline&lt;/keywordname&gt; even when necessary and the template
     model, e.g., including &lt;filename
     class=&quot;libraryfile&quot;&gt;.cpp&lt;/filename&gt; files.&lt;/para&gt;
  
--- 1767,1773 ----
     class=&quot;libraryfile&quot;&gt;.cmpl.cpp&lt;/filename&gt;, &lt;filename
     class=&quot;libraryfile&quot;&gt;.mk&lt;/filename&gt;, &lt;filename
     class=&quot;libraryfile&quot;&gt;.conf&lt;/filename&gt;.  Should we also explain use
!    of &lt;literal&gt;inline&lt;/literal&gt; even when necessary and the template
     model, e.g., including &lt;filename
     class=&quot;libraryfile&quot;&gt;.cpp&lt;/filename&gt; files.&lt;/para&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 2090,2096 ****
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;constructorsynopsis&gt;
! 	   &lt;methodname&gt;Array&lt;/methodname&gt;
  	   &lt;void&gt;&lt;/void&gt;
  	  &lt;/constructorsynopsis&gt;
           &lt;/entry&gt;
--- 2090,2096 ----
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;constructorsynopsis&gt;
! 	   &lt;literal&gt;Array&lt;/literal&gt;
  	   &lt;void&gt;&lt;/void&gt;
  	  &lt;/constructorsynopsis&gt;
           &lt;/entry&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2100,2106 ****
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;constructorsynopsis&gt;
! 	   &lt;methodname&gt;Array&lt;/methodname&gt;
  	   &lt;methodparam&gt;&lt;modifier&gt;const&lt;/modifier&gt; &lt;type&gt;Engine_t&amp;&lt;/type&gt;
  	    &lt;parameter&gt;engine&lt;/parameter&gt;&lt;/methodparam&gt;
  	  &lt;/constructorsynopsis&gt;
--- 2100,2106 ----
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;constructorsynopsis&gt;
! 	   &lt;literal&gt;Array&lt;/literal&gt;
  	   &lt;methodparam&gt;&lt;modifier&gt;const&lt;/modifier&gt; &lt;type&gt;Engine_t&amp;&lt;/type&gt;
  	    &lt;parameter&gt;engine&lt;/parameter&gt;&lt;/methodparam&gt;
  	  &lt;/constructorsynopsis&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2114,2120 ****
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;constructorsynopsis&gt;
! 	   &lt;methodname&gt;Array&lt;/methodname&gt;
  	   &lt;methodparam&gt;
  	    &lt;modifier&gt;const&lt;/modifier&gt;
  	    &lt;type&gt; Engine&lt;Dim2, T2, EngineTag2&gt;&amp;&lt;/type&gt;
--- 2114,2120 ----
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;constructorsynopsis&gt;
! 	   &lt;literal&gt;Array&lt;/literal&gt;
  	   &lt;methodparam&gt;
  	    &lt;modifier&gt;const&lt;/modifier&gt;
  	    &lt;type&gt; Engine&lt;Dim2, T2, EngineTag2&gt;&amp;&lt;/type&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2162,2168 ****
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;Element_t&lt;/type&gt; &lt;methodname&gt;read&lt;/methodname&gt;
  	   &lt;void&gt;&lt;/void&gt;
  	  &lt;/methodsynopsis&gt;
           &lt;/entry&gt;
--- 2162,2168 ----
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;Element_t&lt;/type&gt; &lt;literal&gt;read&lt;/literal&gt;
  	   &lt;void&gt;&lt;/void&gt;
  	  &lt;/methodsynopsis&gt;
           &lt;/entry&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2171,2177 ****
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;Element_t&lt;/type&gt; &lt;methodname&gt;read&lt;/methodname&gt;
  	   &lt;methodparam&gt;
  	    &lt;modifier&gt;const&lt;/modifier&gt;
  	    &lt;type&gt;Sub1&amp;&lt;/type&gt; &lt;parameter&gt;s1&lt;/parameter&gt;
--- 2171,2177 ----
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;Element_t&lt;/type&gt; &lt;literal&gt;read&lt;/literal&gt;
  	   &lt;methodparam&gt;
  	    &lt;modifier&gt;const&lt;/modifier&gt;
  	    &lt;type&gt;Sub1&amp;&lt;/type&gt; &lt;parameter&gt;s1&lt;/parameter&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2189,2195 ****
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;Element_t&lt;/type&gt; &lt;methodname&gt;operator()&lt;/methodname&gt;
  	   &lt;methodparam&gt;
  	    &lt;modifier&gt;const&lt;/modifier&gt;
  	    &lt;type&gt;Sub1&amp;&lt;/type&gt; &lt;parameter&gt;s1&lt;/parameter&gt;
--- 2189,2195 ----
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;Element_t&lt;/type&gt; &lt;literal&gt;operator()&lt;/literal&gt;
  	   &lt;methodparam&gt;
  	    &lt;modifier&gt;const&lt;/modifier&gt;
  	    &lt;type&gt;Sub1&amp;&lt;/type&gt; &lt;parameter&gt;s1&lt;/parameter&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2200,2207 ****
  	   &lt;/methodparam&gt;
  	  &lt;/methodsynopsis&gt;
           &lt;/entry&gt;
! 	 &lt;entry&gt;&lt;para&gt;How does this differ from &lt;statement&gt;read(const
!           Sub1&amp; s1, const Sub2&amp; s2)&lt;/statement&gt;?  &lt;/para&gt;&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;ADD ALL &lt;function&gt;read&lt;/function&gt;s and
--- 2200,2207 ----
  	   &lt;/methodparam&gt;
  	  &lt;/methodsynopsis&gt;
           &lt;/entry&gt;
! 	 &lt;entry&gt;&lt;para&gt;How does this differ from &lt;literal&gt;read(const
!           Sub1&amp; s1, const Sub2&amp; s2)&lt;/literal&gt;?  &lt;/para&gt;&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;ADD ALL &lt;function&gt;read&lt;/function&gt;s and
*************** UNFINISHED&lt;/para&gt;
*** 2218,2231 ****
  
       &lt;para&gt;When an array stores elements having components, e.g., an
       array of vectors, tensors, or arrays, the
!      &lt;methodname&gt;comp&lt;/methodname&gt; returns an array consisting of the
       specified components.  The original and component array share the
       same engine so changing the values in one affects values in the
       other.&lt;/para&gt;
  
       &lt;para&gt;For example, if &n; &times; &n; array &lt;varname&gt;a&lt;/varname&gt;
       consists of three-dimensional real-valued vectors,
!      &lt;statement&gt;a.comp(1)&lt;/statement&gt; returns a &n; &times; &n;
       real-valued array of all the middle vector components.  Assigning
       to the component array will also modify the middle components of
       the vectors in &lt;varname&gt;a&lt;/varname&gt;.&lt;/para&gt;
--- 2218,2231 ----
  
       &lt;para&gt;When an array stores elements having components, e.g., an
       array of vectors, tensors, or arrays, the
!      &lt;literal&gt;comp&lt;/literal&gt; returns an array consisting of the
       specified components.  The original and component array share the
       same engine so changing the values in one affects values in the
       other.&lt;/para&gt;
  
       &lt;para&gt;For example, if &n; &times; &n; array &lt;varname&gt;a&lt;/varname&gt;
       consists of three-dimensional real-valued vectors,
!      &lt;literal&gt;a.comp(1)&lt;/literal&gt; returns a &n; &times; &n;
       real-valued array of all the middle vector components.  Assigning
       to the component array will also modify the middle components of
       the vectors in &lt;varname&gt;a&lt;/varname&gt;.&lt;/para&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2245,2251 ****
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;UNKNOWN compute this&lt;/type&gt; &lt;methodname&gt;comp&lt;/methodname&gt;
  	   &lt;methodparam&gt;
  	    &lt;modifier&gt;const&lt;/modifier&gt;
  	    &lt;type&gt;int&amp;&lt;/type&gt;
--- 2245,2251 ----
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;UNKNOWN compute this&lt;/type&gt; &lt;literal&gt;comp&lt;/literal&gt;
  	   &lt;methodparam&gt;
  	    &lt;modifier&gt;const&lt;/modifier&gt;
  	    &lt;type&gt;int&amp;&lt;/type&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2256,2262 ****
  	 &lt;entry&gt;&lt;para&gt;unknown: See line 1989.&lt;/para&gt;&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;ADD ALL &lt;methodname&gt;comp&lt;/methodname&gt;s.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tbody&gt;
        &lt;/tgroup&gt;
--- 2256,2262 ----
  	 &lt;entry&gt;&lt;para&gt;unknown: See line 1989.&lt;/para&gt;&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;ADD ALL &lt;literal&gt;comp&lt;/literal&gt;s.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tbody&gt;
        &lt;/tgroup&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2281,2287 ****
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;int&lt;/type&gt; &lt;methodname&gt;first&lt;/methodname&gt;
  	   &lt;methodparam&gt;
  	    &lt;type&gt;int&lt;/type&gt;
  	    &lt;parameter&gt;d&lt;/parameter&gt;
--- 2281,2287 ----
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;int&lt;/type&gt; &lt;literal&gt;first&lt;/literal&gt;
  	   &lt;methodparam&gt;
  	    &lt;type&gt;int&lt;/type&gt;
  	    &lt;parameter&gt;d&lt;/parameter&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2292,2298 ****
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;ADD ALL other accessor methods, including
! 	 &lt;methodname&gt;engine&lt;/methodname&gt;.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tbody&gt;
        &lt;/tgroup&gt;
--- 2292,2298 ----
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;ADD ALL other accessor methods, including
! 	 &lt;literal&gt;engine&lt;/literal&gt;.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tbody&gt;
        &lt;/tgroup&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2327,2333 ****
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;void&lt;/type&gt; &lt;methodname&gt;makeOwnCopy&lt;/methodname&gt;
  	   &lt;void&gt;&lt;/void&gt;
  	  &lt;/methodsynopsis&gt;
           &lt;/entry&gt;
--- 2327,2333 ----
  	&lt;row&gt;
  	 &lt;entry&gt;
            &lt;methodsynopsis&gt;
! 	   &lt;type&gt;void&lt;/type&gt; &lt;literal&gt;makeOwnCopy&lt;/literal&gt;
  	   &lt;void&gt;&lt;/void&gt;
  	  &lt;/methodsynopsis&gt;
           &lt;/entry&gt;
*************** UNFINISHED&lt;/para&gt;
*** 2346,2353 ****
       &lt;title&gt;Implementation Details&lt;/title&gt;
  
       &lt;para&gt;As a container, an &array;'s implementation is quite
!      simple.  Its &lt;keywordname&gt;private&lt;/keywordname&gt;data consists of
!      an engine, and it has no &lt;keywordname&gt;private&lt;/keywordname&gt;
       functions.&lt;/para&gt;
  
       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
--- 2346,2353 ----
       &lt;title&gt;Implementation Details&lt;/title&gt;
  
       &lt;para&gt;As a container, an &array;'s implementation is quite
!      simple.  Its &lt;literal&gt;private&lt;/literal&gt;data consists of
!      an engine, and it has no &lt;literal&gt;private&lt;/literal&gt;
       functions.&lt;/para&gt;
  
       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
*************** UNFINISHED&lt;/para&gt;
*** 2406,2413 ****
       &lt;title&gt;Implementation Details&lt;/title&gt;
  
       &lt;para&gt;&lt;type&gt;DynamicArray&lt;/type&gt; has no
!      &lt;keywordname&gt;protected&lt;/keywordname&gt; or
!      &lt;keywordname&gt;private&lt;/keywordname&gt; members.&lt;/para&gt;
      &lt;/section&gt;
     &lt;/section&gt;
  
--- 2406,2413 ----
       &lt;title&gt;Implementation Details&lt;/title&gt;
  
       &lt;para&gt;&lt;type&gt;DynamicArray&lt;/type&gt; has no
!      &lt;literal&gt;protected&lt;/literal&gt; or
!      &lt;literal&gt;private&lt;/literal&gt; members.&lt;/para&gt;
      &lt;/section&gt;
     &lt;/section&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 2456,2462 ****
      &lt;para&gt;In &pooma;, expressions may contain entire &array;s.  That
      is, &array;s are first-class objects with respect to expressions.
      For example, given &array;s &lt;varname&gt;a&lt;/varname&gt; and
!     &lt;varname&gt;b&lt;/varname&gt;, the expression &lt;statement&gt;a + b&lt;/statement&gt;
      is equivalent to an array containing the element-wise sum of the
      two arrays.&lt;/para&gt;
  
--- 2456,2462 ----
      &lt;para&gt;In &pooma;, expressions may contain entire &array;s.  That
      is, &array;s are first-class objects with respect to expressions.
      For example, given &array;s &lt;varname&gt;a&lt;/varname&gt; and
!     &lt;varname&gt;b&lt;/varname&gt;, the expression &lt;literal&gt;a + b&lt;/literal&gt;
      is equivalent to an array containing the element-wise sum of the
      two arrays.&lt;/para&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 2696,2702 ****
       &lt;title&gt;Element Access&lt;/title&gt;
  
       &lt;para&gt;ADD: a table ala &array;.  Be sure to include
!      &lt;methodname&gt;all&lt;/methodname&gt;.&lt;/para&gt;
      &lt;/section&gt;
  
  
--- 2696,2702 ----
       &lt;title&gt;Element Access&lt;/title&gt;
  
       &lt;para&gt;ADD: a table ala &array;.  Be sure to include
!      &lt;literal&gt;all&lt;/literal&gt;.&lt;/para&gt;
      &lt;/section&gt;
  
  
*************** UNFINISHED&lt;/para&gt;
*** 2718,2726 ****
  
       &lt;para&gt;See &lt;filename
  			 class=&quot;headerfile&quot;&gt;src/Field/Field.h&lt;/filename&gt;'s
!       &lt;methodname&gt;operator[]&lt;/methodname&gt;,
!       &lt;methodname&gt;subField&lt;/methodname&gt;, &hellip;,
!       &lt;methodname&gt;material&lt;/methodname&gt;.&lt;/para&gt;
      &lt;/section&gt;
  
  
--- 2718,2726 ----
  
       &lt;para&gt;See &lt;filename
  			 class=&quot;headerfile&quot;&gt;src/Field/Field.h&lt;/filename&gt;'s
!       &lt;literal&gt;operator[]&lt;/literal&gt;,
!       &lt;literal&gt;subField&lt;/literal&gt;, &hellip;,
!       &lt;literal&gt;material&lt;/literal&gt;.&lt;/para&gt;
      &lt;/section&gt;
  
  
*************** UNFINISHED&lt;/para&gt;
*** 2728,2737 ****
       &lt;title&gt;Supporting Relations&lt;/title&gt;
  
       &lt;para&gt;ADD: a table with the member functions including
!      &lt;methodname&gt;addRelation&lt;/methodname&gt;,
!      &lt;methodname&gt;removeRelations&lt;/methodname&gt;,
!      &lt;methodname&gt;applyRelations&lt;/methodname&gt;, and
!      &lt;methodname&gt;setDirty&lt;/methodname&gt;.&lt;/para&gt;
      &lt;/section&gt;
  
  
--- 2728,2737 ----
       &lt;title&gt;Supporting Relations&lt;/title&gt;
  
       &lt;para&gt;ADD: a table with the member functions including
!      &lt;literal&gt;addRelation&lt;/literal&gt;,
!      &lt;literal&gt;removeRelations&lt;/literal&gt;,
!      &lt;literal&gt;applyRelations&lt;/literal&gt;, and
!      &lt;literal&gt;setDirty&lt;/literal&gt;.&lt;/para&gt;
      &lt;/section&gt;
  
  
*************** UNFINISHED&lt;/para&gt;
*** 2747,2753 ****
       &lt;title&gt;Utility Methods&lt;/title&gt;
  
       &lt;para&gt;ADD: a table including
!       &lt;methodname&gt;makeOwnCopy&lt;/methodname&gt;.&lt;/para&gt;
      &lt;/section&gt;
  
  
--- 2747,2753 ----
       &lt;title&gt;Utility Methods&lt;/title&gt;
  
       &lt;para&gt;ADD: a table including
!       &lt;literal&gt;makeOwnCopy&lt;/literal&gt;.&lt;/para&gt;
      &lt;/section&gt;
  
  
*************** UNFINISHED&lt;/para&gt;
*** 2767,2773 ****
      &lt;para&gt;Be sure to relate to &array; views.  Note only three
      dimensions are supported.&lt;/para&gt;
  
!     &lt;para&gt;Be sure to describe &lt;statement&gt;f[i]&lt;/statement&gt;.  Does this
      refer to a particular material or a particular value within a
      cell?  I do not remember.  See &lt;type&gt;SubFieldView&lt;/type&gt; in
      &lt;filename class=&quot;headerfile&quot;&gt;src/Field/Field.h&lt;/filename&gt;.&lt;/para&gt;
--- 2767,2773 ----
      &lt;para&gt;Be sure to relate to &array; views.  Note only three
      dimensions are supported.&lt;/para&gt;
  
!     &lt;para&gt;Be sure to describe &lt;literal&gt;f[i]&lt;/literal&gt;.  Does this
      refer to a particular material or a particular value within a
      cell?  I do not remember.  See &lt;type&gt;SubFieldView&lt;/type&gt; in
      &lt;filename class=&quot;headerfile&quot;&gt;src/Field/Field.h&lt;/filename&gt;.&lt;/para&gt;
*************** UNFINISHED&lt;/para&gt;
*** 3180,3187 ****
     &lt;section id=&quot;engines_ref-access&quot;&gt;
      &lt;title&gt;Element Access&lt;/title&gt;
  
!     &lt;para&gt;ADD: a table with &lt;methodname&gt;read&lt;/methodname&gt; and
!     &lt;methodname&gt;operator()&lt;/methodname&gt;.&lt;/para&gt;
     &lt;/section&gt;
  
  
--- 3180,3187 ----
     &lt;section id=&quot;engines_ref-access&quot;&gt;
      &lt;title&gt;Element Access&lt;/title&gt;
  
!     &lt;para&gt;ADD: a table with &lt;literal&gt;read&lt;/literal&gt; and
!     &lt;literal&gt;operator()&lt;/literal&gt;.&lt;/para&gt;
     &lt;/section&gt;
  
  
*************** UNFINISHED&lt;/para&gt;
*** 3204,3213 ****
      &lt;title&gt;Utility Methods&lt;/title&gt;
  
      &lt;para&gt;ADD: a table including
!     &lt;methodname&gt;makeOwnCopy&lt;/methodname&gt;.&lt;/para&gt;
  
!     &lt;para&gt;QUESTION: What are &lt;methodname&gt;dataObject&lt;/methodname&gt;,
!     &lt;methodname&gt;isShared&lt;/methodname&gt;, and related methods?&lt;/para&gt;
     &lt;/section&gt;
  
  
--- 3204,3213 ----
      &lt;title&gt;Utility Methods&lt;/title&gt;
  
      &lt;para&gt;ADD: a table including
!     &lt;literal&gt;makeOwnCopy&lt;/literal&gt;.&lt;/para&gt;
  
!     &lt;para&gt;QUESTION: What are &lt;literal&gt;dataObject&lt;/literal&gt;,
!     &lt;literal&gt;isShared&lt;/literal&gt;, and related methods?&lt;/para&gt;
     &lt;/section&gt;
  
  
*************** UNFINISHED&lt;/para&gt;
*** 3226,3232 ****
  
      &lt;para&gt;ADD: description of what a brick means.  ADD: whatever
      specializations the class has, e.g.,
!     &lt;methodname&gt;offset&lt;/methodname&gt;.&lt;/para&gt;
  
      &lt;para&gt;QUESTION: What does &lt;type&gt;DoubleSliceHelper&lt;/type&gt; do?&lt;/para&gt;
     &lt;/section&gt;
--- 3226,3232 ----
  
      &lt;para&gt;ADD: description of what a brick means.  ADD: whatever
      specializations the class has, e.g.,
!     &lt;literal&gt;offset&lt;/literal&gt;.&lt;/para&gt;
  
      &lt;para&gt;QUESTION: What does &lt;type&gt;DoubleSliceHelper&lt;/type&gt; do?&lt;/para&gt;
     &lt;/section&gt;
*************** UNFINISHED&lt;/para&gt;
*** 3375,3381 ****
      created by &lt;function&gt;Pooma::initialize&lt;/function&gt;, storing
      run-time configurable values found in &lt;varname&gt;argv&lt;/varname&gt;.
      Default options are found in
!     &lt;methodname&gt;Options::usage&lt;/methodname&gt;.&lt;/para&gt;
  
      &lt;para&gt;See &lt;filename
      class=&quot;headerfile&quot;&gt;src/Utilities/Options.h&lt;/filename&gt; and
--- 3375,3381 ----
      created by &lt;function&gt;Pooma::initialize&lt;/function&gt;, storing
      run-time configurable values found in &lt;varname&gt;argv&lt;/varname&gt;.
      Default options are found in
!     &lt;literal&gt;Options::usage&lt;/literal&gt;.&lt;/para&gt;
  
      &lt;para&gt;See &lt;filename
      class=&quot;headerfile&quot;&gt;src/Utilities/Options.h&lt;/filename&gt; and
*************** UNFINISHED&lt;/para&gt;
*** 3593,3599 ****
       class=&quot;headerfile&quot;&gt;src/Utilities/DerefIterator.h&lt;/filename&gt;:
       &lt;type&gt;DerefIterator&lt;T&gt;&lt;/type&gt; and
       &lt;type&gt;ConstDerefIterator&lt;T&gt;&lt;/type&gt; automatically
!      dereference themselves to maintain &lt;keywordname&gt;const&lt;/keywordname&gt;
       correctness.&lt;/para&gt;
      &lt;/listitem&gt;
  
--- 3593,3599 ----
       class=&quot;headerfile&quot;&gt;src/Utilities/DerefIterator.h&lt;/filename&gt;:
       &lt;type&gt;DerefIterator&lt;T&gt;&lt;/type&gt; and
       &lt;type&gt;ConstDerefIterator&lt;T&gt;&lt;/type&gt; automatically
!      dereference themselves to maintain &lt;literal&gt;const&lt;/literal&gt;
       correctness.&lt;/para&gt;
      &lt;/listitem&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 3896,3902 ****
         modification.  However, if you are using &mm;, ensure
         &lt;varname&gt;shmem_default_dir&lt;/varname&gt; specifies its location.
         For example, the &author; modified the value to
!        &lt;statement&gt;&quot;/home/oldham/pooma/mm-1.1.3&quot;&lt;/statement&gt;.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
         &lt;para&gt;Prepare to compile the source code by configuring it
--- 3896,3902 ----
         modification.  However, if you are using &mm;, ensure
         &lt;varname&gt;shmem_default_dir&lt;/varname&gt; specifies its location.
         For example, the &author; modified the value to
!        &lt;literal&gt;&quot;/home/oldham/pooma/mm-1.1.3&quot;&lt;/literal&gt;.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
         &lt;para&gt;Prepare to compile the source code by configuring it
Index: template.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/template.xml,v
retrieving revision 1.4
diff -c -p -r1.4 template.xml
*** template.xml	2002/01/30 23:09:06	1.4
--- template.xml	2002/01/30 23:47:36
***************
*** 95,101 ****
      its dimension, the type of its values, and its &engine; type.  To
      use this, a programmer specifies values for the template
      parameters:
!     &lt;statement&gt;&lt;type&gt;Array&lt;2,double,Brick&gt;&lt;/type&gt;&lt;/statement&gt;
      specifies a dimension of 2, a value type of &double;, and the
      &brick; &engine; type.  At compile time, the compiler creates a
      type definition by substituting the values for the template
--- 95,101 ----
      its dimension, the type of its values, and its &engine; type.  To
      use this, a programmer specifies values for the template
      parameters:
!     &lt;literal&gt;&lt;type&gt;Array&lt;2,double,Brick&gt;&lt;/type&gt;&lt;/literal&gt;
      specifies a dimension of 2, a value type of &double;, and the
      &brick; &engine; type.  At compile time, the compiler creates a
      type definition by substituting the values for the template
***************
*** 195,201 ****
      these concrete types with a template
      parameter&nbsp;&lt;varname&gt;T&lt;/varname&gt;.  We
      &lt;emphasis&gt;precede&lt;/emphasis&gt;, not follow, the class definition
!     with &lt;statement&gt;template &lt;typename T&gt;&lt;/statement&gt;.  The
      constructor's parameters' types are changed
      to&nbsp;&lt;varname&gt;T&lt;/varname&gt;, as are the data members'
      types.&lt;/para&gt;
--- 195,201 ----
      these concrete types with a template
      parameter&nbsp;&lt;varname&gt;T&lt;/varname&gt;.  We
      &lt;emphasis&gt;precede&lt;/emphasis&gt;, not follow, the class definition
!     with &lt;literal&gt;template &lt;typename T&gt;&lt;/literal&gt;.  The
      constructor's parameters' types are changed
      to&nbsp;&lt;varname&gt;T&lt;/varname&gt;, as are the data members'
      types.&lt;/para&gt;
***************
*** 223,236 ****
         arearefs=&quot;template_programming-template_use-templated_pair_program-use&quot;&gt;
         &lt;para&gt;To use a templated class, specify the template
         parameter's argument after the class's name and surrounded by
!        angle brackets&nbsp;(&lt;statement&gt;&lt;&gt;&lt;/statement&gt;).&lt;/para&gt;
        &lt;/callout&gt;
       &lt;/calloutlist&gt;
       &lt;/example&gt;
  
      &lt;para&gt;To use a template class definition, template arguments
      follow the class name surrounded by angle
!     brackets&nbsp;(&lt;statement&gt;&lt;&gt;&lt;/statement&gt;).  For example,
      &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; &lt;glossterm
      linkend=&quot;glossary-template_instantiation&quot;&gt;&lt;firstterm&gt;instantiates&lt;/firstterm&gt;&lt;/glossterm&gt;
      &lt;indexterm&gt;
--- 223,236 ----
         arearefs=&quot;template_programming-template_use-templated_pair_program-use&quot;&gt;
         &lt;para&gt;To use a templated class, specify the template
         parameter's argument after the class's name and surrounded by
!        angle brackets&nbsp;(&lt;literal&gt;&lt;&gt;&lt;/literal&gt;).&lt;/para&gt;
        &lt;/callout&gt;
       &lt;/calloutlist&gt;
       &lt;/example&gt;
  
      &lt;para&gt;To use a template class definition, template arguments
      follow the class name surrounded by angle
!     brackets&nbsp;(&lt;literal&gt;&lt;&gt;&lt;/literal&gt;).  For example,
      &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; &lt;glossterm
      linkend=&quot;glossary-template_instantiation&quot;&gt;&lt;firstterm&gt;instantiates&lt;/firstterm&gt;&lt;/glossterm&gt;
      &lt;indexterm&gt;
***************
*** 242,249 ****
      creates a definition for &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; by copying
      &lt;classname&gt;pair&lt;/classname&gt;'s template definition and substituting
      &int; for each occurrence of&nbsp;&lt;varname&gt;T&lt;/varname&gt;.  The copy
!     omits the template parameter declaration &lt;statement&gt;template
!     &lt;typename T&gt;&lt;/statement&gt; at the beginning of its definition.
      The result is a definition exactly the same as
      &lt;classname&gt;pairOfInts&lt;/classname&gt;.&lt;/para&gt;
  
--- 242,249 ----
      creates a definition for &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; by copying
      &lt;classname&gt;pair&lt;/classname&gt;'s template definition and substituting
      &int; for each occurrence of&nbsp;&lt;varname&gt;T&lt;/varname&gt;.  The copy
!     omits the template parameter declaration &lt;literal&gt;template
!     &lt;typename T&gt;&lt;/literal&gt; at the beginning of its definition.
      The result is a definition exactly the same as
      &lt;classname&gt;pairOfInts&lt;/classname&gt;.&lt;/para&gt;
  
***************
*** 273,279 ****
      compile-time operations use these types.  For both run-time and
      compile-time programming, &cc; defines default sets of values that
      all conforming compilers must support.  For example,
!     &lt;statement&gt;3&lt;/statement&gt; and &lt;statement&gt;6.022e+23&lt;/statement&gt; are
      run-time values that any &cc; compiler must accept.  It must also
      accept the &int;, &bool;, and &lt;type&gt;int*&lt;/type&gt; types.&lt;/para&gt;
  
--- 273,279 ----
      compile-time operations use these types.  For both run-time and
      compile-time programming, &cc; defines default sets of values that
      all conforming compilers must support.  For example,
!     &lt;literal&gt;3&lt;/literal&gt; and &lt;literal&gt;6.022e+23&lt;/literal&gt; are
      run-time values that any &cc; compiler must accept.  It must also
      accept the &int;, &bool;, and &lt;type&gt;int*&lt;/type&gt; types.&lt;/para&gt;
  
*************** maxOut(0, 3);
*** 422,450 ****
      with the templated class in &lt;xref
      linkend=&quot;template_programming-template_use-templated_pair_example&quot;&gt;&lt;/xref&gt;.
      Note the notation for the template class parameters.
!     &lt;statement&gt;template &lt;typename T&gt;&lt;/statement&gt;
      &lt;emphasis&gt;precedes&lt;/emphasis&gt; the class definition.  The keyword
!     &lt;keywordname&gt;typename&lt;/keywordname&gt;
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;keywordname&gt;typename&lt;/keywordname&gt;&lt;/primary&gt;
      &lt;/indexterm&gt;
      indicates the template
      parameter is a type.  &lt;varname&gt;T&lt;/varname&gt;&nbsp;is the template
      parameter's name.  (We could have used any other identifier such
      as &lt;varname&gt;pairElementType&lt;/varname&gt; or &lt;varname&gt;foo&lt;/varname&gt;.)
!     Note that using &lt;keywordname&gt;class&lt;/keywordname&gt;
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;keywordname&gt;class&lt;/keywordname&gt;&lt;/primary&gt;
      &lt;/indexterm&gt;
      is equivalent to
!     using &lt;keywordname&gt;typename&lt;/keywordname&gt; so &lt;statement&gt;template
!     &lt;class T&gt;&lt;/statement&gt; is equivalent to &lt;statement&gt;template
!     &lt;typename T&gt;&lt;/statement&gt;.  While declaring a template class
      requires prefix notation, using a templated class requires postfix
      notation.  The class's name precedes angle
      brackets&nbsp;(&lt;&gt;) surrounding specific values, i.e., types,
      for its parameters.  As we showed above,
!     &lt;statement&gt;pair&lt;int&gt;&lt;/statement&gt; &lt;glossterm
      linkend=&quot;glossary-template_instantiation&quot;&gt;instantiates&lt;/glossterm&gt;
      &lt;indexterm&gt;
       &lt;primary&gt;template&lt;/primary&gt;
--- 422,450 ----
      with the templated class in &lt;xref
      linkend=&quot;template_programming-template_use-templated_pair_example&quot;&gt;&lt;/xref&gt;.
      Note the notation for the template class parameters.
!     &lt;literal&gt;template &lt;typename T&gt;&lt;/literal&gt;
      &lt;emphasis&gt;precedes&lt;/emphasis&gt; the class definition.  The keyword
!     &lt;literal&gt;typename&lt;/literal&gt;
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;literal&gt;typename&lt;/literal&gt;&lt;/primary&gt;
      &lt;/indexterm&gt;
      indicates the template
      parameter is a type.  &lt;varname&gt;T&lt;/varname&gt;&nbsp;is the template
      parameter's name.  (We could have used any other identifier such
      as &lt;varname&gt;pairElementType&lt;/varname&gt; or &lt;varname&gt;foo&lt;/varname&gt;.)
!     Note that using &lt;literal&gt;class&lt;/literal&gt;
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;literal&gt;class&lt;/literal&gt;&lt;/primary&gt;
      &lt;/indexterm&gt;
      is equivalent to
!     using &lt;literal&gt;typename&lt;/literal&gt; so &lt;literal&gt;template
!     &lt;class T&gt;&lt;/literal&gt; is equivalent to &lt;literal&gt;template
!     &lt;typename T&gt;&lt;/literal&gt;.  While declaring a template class
      requires prefix notation, using a templated class requires postfix
      notation.  The class's name precedes angle
      brackets&nbsp;(&lt;&gt;) surrounding specific values, i.e., types,
      for its parameters.  As we showed above,
!     &lt;literal&gt;pair&lt;int&gt;&lt;/literal&gt; &lt;glossterm
      linkend=&quot;glossary-template_instantiation&quot;&gt;instantiates&lt;/glossterm&gt;
      &lt;indexterm&gt;
       &lt;primary&gt;template&lt;/primary&gt;
*************** maxOut(0, 3);
*** 471,479 ****
      domain:
  &lt;programlisting&gt;
  typedef typename Engine_t::Domain_t Domain_t;
! &lt;/programlisting&gt; This &lt;keywordname&gt;typedef&lt;/keywordname&gt;,
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;keywordname&gt;typedef&lt;/keywordname&gt;&lt;/primary&gt;
       &lt;see&gt;type, definition.&lt;/see&gt;
      &lt;/indexterm&gt;
      &lt;indexterm&gt;
--- 471,479 ----
      domain:
  &lt;programlisting&gt;
  typedef typename Engine_t::Domain_t Domain_t;
! &lt;/programlisting&gt; This &lt;literal&gt;typedef&lt;/literal&gt;,
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;literal&gt;typedef&lt;/literal&gt;&lt;/primary&gt;
       &lt;see&gt;type, definition.&lt;/see&gt;
      &lt;/indexterm&gt;
      &lt;indexterm&gt;
*************** typedef typename Engine_t::Domain_t Doma
*** 483,491 ****
      i.e., type
      definition, defines the type &lt;type&gt;Domain_t&lt;/type&gt; as equivalent
      to &lt;type&gt;Engine_t::Domain_t&lt;/type&gt;.  The
!     &lt;operator&gt;::&lt;/operator&gt;&nbsp;operator
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;operator&gt;::&lt;/operator&gt;&nbsp;operator&lt;/primary&gt;
      &lt;/indexterm&gt;
      selects the &lt;type&gt;Domain_t&lt;/type&gt; nested type from inside the
      &lt;type&gt;Engine_t&lt;/type&gt; type.  This illustrates how to access
--- 483,491 ----
      i.e., type
      definition, defines the type &lt;type&gt;Domain_t&lt;/type&gt; as equivalent
      to &lt;type&gt;Engine_t::Domain_t&lt;/type&gt;.  The
!     &lt;literal&gt;::&lt;/literal&gt;&nbsp;operator
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;literal&gt;::&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;
      &lt;/indexterm&gt;
      selects the &lt;type&gt;Domain_t&lt;/type&gt; nested type from inside the
      &lt;type&gt;Engine_t&lt;/type&gt; type.  This illustrates how to access
*************** typedef typename Engine_t::Domain_t Doma
*** 544,557 ****
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;operations on values&lt;/entry&gt;
! 	&lt;entry&gt;Integral values support &lt;operator&gt;+&lt;/operator&gt;,
! 	&lt;operator&gt;-&lt;/operator&gt;, &lt;operator&gt;&gt;&lt;/operator&gt;,
! 	&lt;operator&gt;==&lt;/operator&gt;, &hellip;.  String values support
! 	&lt;operator&gt;[]&lt;/operator&gt;, &lt;operator&gt;==&lt;/operator&gt;, &hellip;.&lt;/entry&gt;
  	&lt;entry&gt;Types may be declared and used.  Constant integral and
! 	enumeration values can be combined using &lt;operator&gt;+&lt;/operator&gt;,
! 	&lt;operator&gt;-&lt;/operator&gt;, &lt;operator&gt;&gt;&lt;/operator&gt;,
! 	&lt;operator&gt;==&lt;/operator&gt;, &hellip;.  There are no permitted
  	operations on code.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
--- 544,557 ----
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;operations on values&lt;/entry&gt;
! 	&lt;entry&gt;Integral values support &lt;literal&gt;+&lt;/literal&gt;,
! 	&lt;literal&gt;-&lt;/literal&gt;, &lt;literal&gt;&gt;&lt;/literal&gt;,
! 	&lt;literal&gt;==&lt;/literal&gt;, &hellip;.  String values support
! 	&lt;literal&gt;[]&lt;/literal&gt;, &lt;literal&gt;==&lt;/literal&gt;, &hellip;.&lt;/entry&gt;
  	&lt;entry&gt;Types may be declared and used.  Constant integral and
! 	enumeration values can be combined using &lt;literal&gt;+&lt;/literal&gt;,
! 	&lt;literal&gt;-&lt;/literal&gt;, &lt;literal&gt;&gt;&lt;/literal&gt;,
! 	&lt;literal&gt;==&lt;/literal&gt;, &hellip;.  There are no permitted
  	operations on code.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
*************** typedef typename Engine_t::Domain_t Doma
*** 572,586 ****
         &lt;row&gt;
  	&lt;entry&gt;extracting values from collections&lt;/entry&gt;
  	&lt;entry&gt;An object's named values are extracted using the
! 	&lt;operator&gt;.&lt;/operator&gt;&nbsp;operator.
          &lt;indexterm&gt;
!          &lt;primary&gt;&lt;operator&gt;.&lt;/operator&gt;&nbsp;operator&lt;/primary&gt;
          &lt;/indexterm&gt;
          &lt;/entry&gt;
  	&lt;entry&gt;A class's nested types and classes are extracted using
! 	the &lt;operator&gt;::&lt;/operator&gt;&nbsp;operator.
          &lt;indexterm&gt;
!          &lt;primary&gt;&lt;operator&gt;::&lt;/operator&gt;&nbsp;operator&lt;/primary&gt;
          &lt;/indexterm&gt;
          &lt;/entry&gt;
         &lt;/row&gt;
--- 572,586 ----
         &lt;row&gt;
  	&lt;entry&gt;extracting values from collections&lt;/entry&gt;
  	&lt;entry&gt;An object's named values are extracted using the
! 	&lt;literal&gt;.&lt;/literal&gt;&nbsp;operator.
          &lt;indexterm&gt;
!          &lt;primary&gt;&lt;literal&gt;.&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;
          &lt;/indexterm&gt;
          &lt;/entry&gt;
  	&lt;entry&gt;A class's nested types and classes are extracted using
! 	the &lt;literal&gt;::&lt;/literal&gt;&nbsp;operator.
          &lt;indexterm&gt;
!          &lt;primary&gt;&lt;literal&gt;::&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;
          &lt;/indexterm&gt;
          &lt;/entry&gt;
         &lt;/row&gt;
*************** typedef typename Engine_t::Domain_t Doma
*** 590,596 ****
           &lt;primary&gt;control flow&lt;/primary&gt;
          &lt;/indexterm&gt;
          to choose among operations&lt;/entry&gt;
! 	&lt;entry&gt;&lt;keywordname&gt;if&lt;/keywordname&gt;, &lt;keywordname&gt;while&lt;/keywordname&gt;, &lt;keywordname&gt;goto&lt;/keywordname&gt;, &hellip;&lt;/entry&gt;
  	&lt;entry&gt;template class specializations with pattern matching&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
--- 590,596 ----
           &lt;primary&gt;control flow&lt;/primary&gt;
          &lt;/indexterm&gt;
          to choose among operations&lt;/entry&gt;
! 	&lt;entry&gt;&lt;literal&gt;if&lt;/literal&gt;, &lt;literal&gt;while&lt;/literal&gt;, &lt;literal&gt;goto&lt;/literal&gt;, &hellip;&lt;/entry&gt;
  	&lt;entry&gt;template class specializations with pattern matching&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
*************** typedef typename Engine_t::Domain_t Doma
*** 609,615 ****
      &lt;/indexterm&gt;
      The only compile-time values described in the previous
      section were types, but any compile-time constant can also be used.
!     Integral literals, &lt;keywordname&gt;const&lt;/keywordname&gt; variables, and
      other constructs can be used, but the main use is enumerations.
      An &lt;glossterm
      linkend=&quot;glossary-enumeration&quot;&gt;&lt;firstterm&gt;enumeration&lt;/firstterm&gt;&lt;/glossterm&gt;
--- 609,615 ----
      &lt;/indexterm&gt;
      The only compile-time values described in the previous
      section were types, but any compile-time constant can also be used.
!     Integral literals, &lt;literal&gt;const&lt;/literal&gt; variables, and
      other constructs can be used, but the main use is enumerations.
      An &lt;glossterm
      linkend=&quot;glossary-enumeration&quot;&gt;&lt;firstterm&gt;enumeration&lt;/firstterm&gt;&lt;/glossterm&gt;
*************** struct usuallySimpleClass {
*** 741,747 ****
      should be true only if the constructor must perform some very
      complicated, time-expensive computation.  When instantiated with
      &false;, the compiler substitutes this value into the template
!     class definition.  Since the &lt;keywordname&gt;if&lt;/keywordname&gt;
      statement's conditional is false, the compiler optimizer can
      eliminate the statement, yielding internal code similar to
  &lt;programlisting&gt;
--- 741,747 ----
      should be true only if the constructor must perform some very
      complicated, time-expensive computation.  When instantiated with
      &false;, the compiler substitutes this value into the template
!     class definition.  Since the &lt;literal&gt;if&lt;/literal&gt;
      statement's conditional is false, the compiler optimizer can
      eliminate the statement, yielding internal code similar to
  &lt;programlisting&gt;
*************** struct usuallySimpleClass&lt;false&gt; {
*** 774,791 ****
  
      &lt;para&gt;Each category&lt;firstterm&gt;&lt;/firstterm&gt; of values supports a
      distinct set of operations.  For example, the run-time category of
!     integer values supports combination using &lt;operator&gt;+&lt;/operator&gt;
!     and &lt;operator&gt;-&lt;/operator&gt; and comparison using
!     &lt;operator&gt;&gt;&lt;/operator&gt; and &lt;operator&gt;==&lt;/operator&gt;.  At run
      time, the category of strings can be compared using
!     &lt;operator&gt;==&lt;/operator&gt; and characters can be extracted using
!     subscripts with the &lt;operator&gt;[]&lt;/operator&gt; operator.  Compile-time
      operations are more limited.  Types may be declared and used.  The
!     &lt;keywordname&gt;sizeof&lt;/keywordname&gt; operator yields the number of
      bytes to represent an object of the specified type.  Enumerations,
!     constant integers, &lt;keywordname&gt;sizeof&lt;/keywordname&gt; expressions,
      and simple arithmetic and comparison operators such as
!     &lt;operator&gt;+&lt;/operator&gt; and &lt;operator&gt;==&lt;/operator&gt; can form
      constant expressions that can be used at compile time.  These
      values can initialize enumerations and integer constants and be
      used as template arguments.  At compile time, pointers and
--- 774,791 ----
  
      &lt;para&gt;Each category&lt;firstterm&gt;&lt;/firstterm&gt; of values supports a
      distinct set of operations.  For example, the run-time category of
!     integer values supports combination using &lt;literal&gt;+&lt;/literal&gt;
!     and &lt;literal&gt;-&lt;/literal&gt; and comparison using
!     &lt;literal&gt;&gt;&lt;/literal&gt; and &lt;literal&gt;==&lt;/literal&gt;.  At run
      time, the category of strings can be compared using
!     &lt;literal&gt;==&lt;/literal&gt; and characters can be extracted using
!     subscripts with the &lt;literal&gt;[]&lt;/literal&gt; operator.  Compile-time
      operations are more limited.  Types may be declared and used.  The
!     &lt;literal&gt;sizeof&lt;/literal&gt; operator yields the number of
      bytes to represent an object of the specified type.  Enumerations,
!     constant integers, &lt;literal&gt;sizeof&lt;/literal&gt; expressions,
      and simple arithmetic and comparison operators such as
!     &lt;literal&gt;+&lt;/literal&gt; and &lt;literal&gt;==&lt;/literal&gt; can form
      constant expressions that can be used at compile time.  These
      values can initialize enumerations and integer constants and be
      used as template arguments.  At compile time, pointers and
*************** struct usuallySimpleClass&lt;false&gt; {
*** 809,822 ****
      can store multiple values, each
      having its own name.  For example, a &lt;type&gt;pair&lt;int&gt;&lt;/type&gt;
      object&nbsp;&lt;varname&gt;p&lt;/varname&gt; stores two &int;s named
!     &lt;methodname&gt;left_&lt;/methodname&gt; and
!     &lt;methodname&gt;right_&lt;/methodname&gt;.  The &lt;operator&gt;.&lt;/operator&gt;
      operator
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;operator&gt;.&lt;/operator&gt;&nbsp;operator&lt;/primary&gt;
      &lt;/indexterm&gt;
      extracts a named member from an object:
!     &lt;statement&gt;p.left_&lt;/statement&gt;.  At compile time, a class can
      store multiple values, each having its own name.  These are
      sometimes called &lt;glossterm
      linkend=&quot;glossary-traits_class&quot;&gt;&lt;firstterm&gt;traits
--- 809,822 ----
      can store multiple values, each
      having its own name.  For example, a &lt;type&gt;pair&lt;int&gt;&lt;/type&gt;
      object&nbsp;&lt;varname&gt;p&lt;/varname&gt; stores two &int;s named
!     &lt;literal&gt;left_&lt;/literal&gt; and
!     &lt;literal&gt;right_&lt;/literal&gt;.  The &lt;literal&gt;.&lt;/literal&gt;
      operator
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;literal&gt;.&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;
      &lt;/indexterm&gt;
      extracts a named member from an object:
!     &lt;literal&gt;p.left_&lt;/literal&gt;.  At compile time, a class can
      store multiple values, each having its own name.  These are
      sometimes called &lt;glossterm
      linkend=&quot;glossary-traits_class&quot;&gt;&lt;firstterm&gt;traits
*************** struct ExpressionTraits&lt;BinaryNode&amp;lt
*** 848,863 ****
  
      &lt;para id=&quot;template_programming-pooma_implementation-double_colon_operator&quot;&gt;
      &lt;indexterm zone=&quot;template_programming-pooma_implementation-double_colon_operator&quot;&gt;
!      &lt;primary&gt;&lt;operator&gt;::&lt;/operator&gt;&nbsp;operator&lt;/primary&gt;
      &lt;/indexterm&gt;
!     The example also illustrates using the &lt;operator&gt;::&lt;/operator&gt;
      operator to extract a member of a traits class.  The type
      &lt;type&gt;ExpressionTraits&lt;Left&gt;&lt;/type&gt; contains an internal
      type definition of &lt;type&gt;Type_t&lt;/type&gt;.  Using the
!     &lt;operator&gt;::&lt;/operator&gt; operator extracts it:
!     &lt;statement&gt;ExpressionTraits&lt;Left&gt;::Type_t&lt;/statement&gt;.
      Enumerations and other values can also be extracted.  For example,
!     &lt;statement&gt;Array&lt;2, int, Brick&gt;::dimensions&lt;/statement&gt;
      yields the dimension of the array's domain.&lt;/para&gt;
  
      &lt;para id=&quot;template_programming-pooma_implementation-template_specialization&quot;&gt;
--- 848,863 ----
  
      &lt;para id=&quot;template_programming-pooma_implementation-double_colon_operator&quot;&gt;
      &lt;indexterm zone=&quot;template_programming-pooma_implementation-double_colon_operator&quot;&gt;
!      &lt;primary&gt;&lt;literal&gt;::&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;
      &lt;/indexterm&gt;
!     The example also illustrates using the &lt;literal&gt;::&lt;/literal&gt;
      operator to extract a member of a traits class.  The type
      &lt;type&gt;ExpressionTraits&lt;Left&gt;&lt;/type&gt; contains an internal
      type definition of &lt;type&gt;Type_t&lt;/type&gt;.  Using the
!     &lt;literal&gt;::&lt;/literal&gt; operator extracts it:
!     &lt;literal&gt;ExpressionTraits&lt;Left&gt;::Type_t&lt;/literal&gt;.
      Enumerations and other values can also be extracted.  For example,
!     &lt;literal&gt;Array&lt;2, int, Brick&gt;::dimensions&lt;/literal&gt;
      yields the dimension of the array's domain.&lt;/para&gt;
  
      &lt;para id=&quot;template_programming-pooma_implementation-template_specialization&quot;&gt;
*************** struct ExpressionTraits&lt;BinaryNode&amp;lt
*** 869,877 ****
       &lt;primary&gt;control flow&lt;/primary&gt;
      &lt;/indexterm&gt;
      Control flow determines which code is used.  At run time,
!     control-flow statements such as &lt;keywordname&gt;if&lt;/keywordname&gt;,
!     &lt;keywordname&gt;while&lt;/keywordname&gt;, and
!     &lt;keywordname&gt;goto&lt;/keywordname&gt; determine which statements to
      execute.  Template programming uses two mechanisms: template class
      specializations and pattern matching.  These are similar to
      control flow in functional programming languages.  A &lt;glossterm
--- 869,877 ----
       &lt;primary&gt;control flow&lt;/primary&gt;
      &lt;/indexterm&gt;
      Control flow determines which code is used.  At run time,
!     control-flow statements such as &lt;literal&gt;if&lt;/literal&gt;,
!     &lt;literal&gt;while&lt;/literal&gt;, and
!     &lt;literal&gt;goto&lt;/literal&gt; determine which statements to
      execute.  Template programming uses two mechanisms: template class
      specializations and pattern matching.  These are similar to
      control flow in functional programming languages.  A &lt;glossterm
*************** struct CreateLeaf&lt;Expression&lt;T&amp;clo
*** 932,943 ****
      &lt;type&gt;Expression&lt;int&gt;&lt;/type&gt;.&lt;/para&gt;
  
      &lt;para&gt;Control flow using template specializations and pattern
!     matching is similar to &lt;keywordname&gt;switch&lt;/keywordname&gt;
      statements.
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;keywordname&gt;switch&lt;/keywordname&gt;&lt;/primary&gt;
      &lt;/indexterm&gt;
!     A &lt;keywordname&gt;switch&lt;/keywordname&gt; statement has a
      condition and one or more pairs of case labels and associated
      code.  The code associated with the the case label whose value
      matches the condition is executed.  If no case label matches the
--- 932,943 ----
      &lt;type&gt;Expression&lt;int&gt;&lt;/type&gt;.&lt;/para&gt;
  
      &lt;para&gt;Control flow using template specializations and pattern
!     matching is similar to &lt;literal&gt;switch&lt;/literal&gt;
      statements.
      &lt;indexterm&gt;
!      &lt;primary&gt;&lt;literal&gt;switch&lt;/literal&gt;&lt;/primary&gt;
      &lt;/indexterm&gt;
!     A &lt;literal&gt;switch&lt;/literal&gt; statement has a
      condition and one or more pairs of case labels and associated
      code.  The code associated with the the case label whose value
      matches the condition is executed.  If no case label matches the
*************** CreateLeaf&lt;Expression&lt;int&amp;closeclo
*** 949,959 ****
      the condition.  The set of template parameters for the indicated
      template class, e.g., &lt;type&gt;CreateLeaf&lt;/type&gt;, are analogous to
      the case labels, and each has an associated definition.  In our
!     example, the set of template parameters are &lt;statement&gt;&lt;class
!     T&gt;&lt;/statement&gt; and &lt;statement&gt;&lt;Expression&lt;class
!     T&closeclose;&lt;/statement&gt;.  The &lt;quote&gt;best match&lt;/quote&gt;, if any,
      indicates the matching code that will be used.  In our example,
!     the &lt;statement&gt;&lt;class T&gt;&lt;/statement&gt; parameter serves as the
      default label since it matches any arguments.  If no set of
      template parameters match (which is impossible for our example) or
      if more than one set are best matches, the code is
--- 949,959 ----
      the condition.  The set of template parameters for the indicated
      template class, e.g., &lt;type&gt;CreateLeaf&lt;/type&gt;, are analogous to
      the case labels, and each has an associated definition.  In our
!     example, the set of template parameters are &lt;literal&gt;&lt;class
!     T&gt;&lt;/literal&gt; and &lt;literal&gt;&lt;Expression&lt;class
!     T&closeclose;&lt;/literal&gt;.  The &lt;quote&gt;best match&lt;/quote&gt;, if any,
      indicates the matching code that will be used.  In our example,
!     the &lt;literal&gt;&lt;class T&gt;&lt;/literal&gt; parameter serves as the
      default label since it matches any arguments.  If no set of
      template parameters match (which is impossible for our example) or
      if more than one set are best matches, the code is
*************** class F {
*** 1012,1018 ****
  &lt;/programlisting&gt;  Both the templated class and the templated function
      take the same template arguments, but the class uses a static
      member function.  Thus, the notation to invoke it is slightly more
!     verbose: &lt;statement&gt;F&lt;T&gt;::f(t)&lt;/statement&gt;.&lt;/para&gt;
  
      &lt;para id=&quot;template_programming-pooma_implementation-function_template-overloaded&quot;&gt;
      &lt;indexterm zone=&quot;template_programming-pooma_implementation-function_template-overloaded&quot;&gt;
--- 1012,1018 ----
  &lt;/programlisting&gt;  Both the templated class and the templated function
      take the same template arguments, but the class uses a static
      member function.  Thus, the notation to invoke it is slightly more
!     verbose: &lt;literal&gt;F&lt;T&gt;::f(t)&lt;/literal&gt;.&lt;/para&gt;
  
      &lt;para id=&quot;template_programming-pooma_implementation-function_template-overloaded&quot;&gt;
      &lt;indexterm zone=&quot;template_programming-pooma_implementation-function_template-overloaded&quot;&gt;
*************** class F {
*** 1025,1031 ****
      &lt;/indexterm&gt;
      The advantage of a function template is that it can be overloaded,
      particularly operator functions.  For example, the
!     &lt;operator&gt;+&lt;/operator&gt; operator is overloaded to add two &array;s,
      which require template parameters to specify:
  &lt;programlisting&gt;
  template &lt;int D1,class T1,class E1,
--- 1025,1031 ----
      &lt;/indexterm&gt;
      The advantage of a function template is that it can be overloaded,
      particularly operator functions.  For example, the
!     &lt;literal&gt;+&lt;/literal&gt; operator is overloaded to add two &array;s,
      which require template parameters to specify:
  &lt;programlisting&gt;
  template &lt;int D1,class T1,class E1,
*************** template &lt;int D1,class T1,class E1,
*** 1034,1041 ****
  operator+(const Array&lt;D1,T1,E1&gt; &amp; l,
            const Array&lt;D2,T2,E2&gt; &amp; r);
  &lt;/programlisting&gt;  Without using function templates, it would not be
!     possible to write expressions such as &lt;statement&gt;a1 +
!     a2&lt;/statement&gt;.  Member functions can also be templated.  This
      permits, for example, overloading of assignment operators defined
      within templated classes.
      &lt;indexterm class=&quot;endofrange&quot; startref=&quot;template_programming-pooma_implementation-function_template&quot;&gt;
--- 1034,1041 ----
  operator+(const Array&lt;D1,T1,E1&gt; &amp; l,
            const Array&lt;D2,T2,E2&gt; &amp; r);
  &lt;/programlisting&gt;  Without using function templates, it would not be
!     possible to write expressions such as &lt;literal&gt;a1 +
!     a2&lt;/literal&gt;.  Member functions can also be templated.  This
      permits, for example, overloading of assignment operators defined
      within templated classes.
      &lt;indexterm class=&quot;endofrange&quot; startref=&quot;template_programming-pooma_implementation-function_template&quot;&gt;
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.9
diff -c -p -r1.9 tutorial.xml
*** tutorial.xml	2002/01/30 23:09:06	1.9
--- tutorial.xml	2002/01/30 23:47:37
***************
*** 215,221 ****
    value is assigned the average of its corresponding value in
    &lt;varname&gt;b&lt;/varname&gt; and the latter's neighbors.  Values in the
    two-dimensional grids are accessed using two sets of brackets, e.g.,
!   &lt;statement&gt;a[i][j]&lt;/statement&gt;.  After assigning values to
    &lt;varname&gt;a&lt;/varname&gt;, a second averaging reads values in
    &lt;varname&gt;a&lt;/varname&gt;, writing values in &lt;varname&gt;b&lt;/varname&gt;.&lt;/para&gt;
  
--- 215,221 ----
    value is assigned the average of its corresponding value in
    &lt;varname&gt;b&lt;/varname&gt; and the latter's neighbors.  Values in the
    two-dimensional grids are accessed using two sets of brackets, e.g.,
!   &lt;literal&gt;a[i][j]&lt;/literal&gt;.  After assigning values to
    &lt;varname&gt;a&lt;/varname&gt;, a second averaging reads values in
    &lt;varname&gt;a&lt;/varname&gt;, writing values in &lt;varname&gt;b&lt;/varname&gt;.&lt;/para&gt;
  
***************
*** 250,256 ****
       &lt;para&gt;Initially, all grid values are zero except for the one
       nonzero value at the center of the second array.  Array
       positions are indicated using two brackets, e.g.,
!      &lt;statement&gt;a[i][j]&lt;/statement&gt;.  A better implementation might
       initialize only the outermost values of the
       &lt;varname&gt;a&lt;/varname&gt; array.&lt;/para&gt;
      &lt;/callout&gt;
--- 250,256 ----
       &lt;para&gt;Initially, all grid values are zero except for the one
       nonzero value at the center of the second array.  Array
       positions are indicated using two brackets, e.g.,
!      &lt;literal&gt;a[i][j]&lt;/literal&gt;.  A better implementation might
       initialize only the outermost values of the
       &lt;varname&gt;a&lt;/varname&gt; array.&lt;/para&gt;
      &lt;/callout&gt;
***************
*** 335,342 ****
       its value type, and how the values will be stored or computed.
       The &brick; &engine; type indicates values will be directly
       stored.  It is responsible for allocating and deallocating
!      storage so &lt;statement&gt;new&lt;/statement&gt; and
!      &lt;statement&gt;delete&lt;/statement&gt; statements are not necessary.
       The &lt;varname&gt;vertDomain&lt;/varname&gt; specifies the array index
       domain.&lt;/para&gt;
      &lt;/callout&gt;
--- 335,342 ----
       its value type, and how the values will be stored or computed.
       The &brick; &engine; type indicates values will be directly
       stored.  It is responsible for allocating and deallocating
!      storage so &lt;literal&gt;new&lt;/literal&gt; and
!      &lt;literal&gt;delete&lt;/literal&gt; statements are not necessary.
       The &lt;varname&gt;vertDomain&lt;/varname&gt; specifies the array index
       domain.&lt;/para&gt;
      &lt;/callout&gt;
***************
*** 345,351 ****
       same scalar value.  The second statement
       illustrates assigning one &array; value.  Indices, separated by
       commas, are surrounded by parentheses rather than surrounded by
!      square brackets (&lt;statement&gt;[]&lt;/statement&gt;).&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-first_write&quot;&gt;
       &lt;para&gt;&array; element access uses parentheses, rather than
--- 345,351 ----
       same scalar value.  The second statement
       illustrates assigning one &array; value.  Indices, separated by
       commas, are surrounded by parentheses rather than surrounded by
!      square brackets (&lt;literal&gt;[]&lt;/literal&gt;).&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-first_write&quot;&gt;
       &lt;para&gt;&array; element access uses parentheses, rather than
***************
*** 394,413 ****
  
    &lt;para&gt;&array;s support both element-wise access and scalar
    assignment.  Element-wise access uses parentheses, not square
!   brackets.  For example, &lt;statement&gt;b(n/2,n/2)&lt;/statement&gt;
!   specifies the central element.  The scalar assignment &lt;statement&gt;b
!   = 0.0&lt;/statement&gt; assigns the same 0.0 value to all array
    elements.  This is possible because the array knows the extent of
    its domain.  We illustrate these data-parallel statements in the
    next section.&lt;/para&gt;
  
    &lt;para&gt;Any program using the &poomatoolkit; must initialize the
    &toolkit;'s data structures using
!   &lt;statement&gt;Pooma::initialize(argc,argv)&lt;/statement&gt;.  This extracts
    &pooma;-specific command-line options from the program's
    command-line arguments and initializes the interprocessor
    communication and other data structures.  When finished,
!   &lt;statement&gt;Pooma::finalize()&lt;/statement&gt; ensures all computation and
    communication has finished and the data structures are
    destructed.&lt;/para&gt;
   &lt;/section&gt;
--- 394,413 ----
  
    &lt;para&gt;&array;s support both element-wise access and scalar
    assignment.  Element-wise access uses parentheses, not square
!   brackets.  For example, &lt;literal&gt;b(n/2,n/2)&lt;/literal&gt;
!   specifies the central element.  The scalar assignment &lt;literal&gt;b
!   = 0.0&lt;/literal&gt; assigns the same 0.0 value to all array
    elements.  This is possible because the array knows the extent of
    its domain.  We illustrate these data-parallel statements in the
    next section.&lt;/para&gt;
  
    &lt;para&gt;Any program using the &poomatoolkit; must initialize the
    &toolkit;'s data structures using
!   &lt;literal&gt;Pooma::initialize(argc,argv)&lt;/literal&gt;.  This extracts
    &pooma;-specific command-line options from the program's
    command-line arguments and initializes the interprocessor
    communication and other data structures.  When finished,
!   &lt;literal&gt;Pooma::finalize()&lt;/literal&gt; ensures all computation and
    communication has finished and the data structures are
    destructed.&lt;/para&gt;
   &lt;/section&gt;
***************
*** 443,449 ****
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_parallel-doof2d-first_write&quot;&gt;
       &lt;para&gt;Data-parallel expressions replace nested loops and array
!      element accesses.  For example, &lt;statement&gt;a(I,J)&lt;/statement&gt;
       represents the subset of the &lt;varname&gt;a&lt;/varname&gt; array having
       a domain equal to the Cartesian product of &lt;varname&gt;I&lt;/varname&gt;
       and &lt;varname&gt;J&lt;/varname&gt;.  Intervals can shifted by an additive
--- 443,449 ----
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_parallel-doof2d-first_write&quot;&gt;
       &lt;para&gt;Data-parallel expressions replace nested loops and array
!      element accesses.  For example, &lt;literal&gt;a(I,J)&lt;/literal&gt;
       represents the subset of the &lt;varname&gt;a&lt;/varname&gt; array having
       a domain equal to the Cartesian product of &lt;varname&gt;I&lt;/varname&gt;
       and &lt;varname&gt;J&lt;/varname&gt;.  Intervals can shifted by an additive
***************
*** 454,483 ****
  
    &lt;para&gt;Data-parallel expressions use containers and domain objects to
    indicate a set of parallel expressions.  For example, in the program
!   listed above, &lt;statement&gt;a(I,J)&lt;/statement&gt; specifies the subset of
    &lt;varname&gt;a&lt;/varname&gt; array omitting the outermost elements.  The
    array's &lt;varname&gt;vertDomain&lt;/varname&gt; domain consists of the
    Cartesian product of {0, 1, 2, &hellip;, n-1} with itself, while
    &lt;varname&gt;I&lt;/varname&gt; and &lt;varname&gt;J&lt;/varname&gt; each specify {1, 2,
!   &hellip;, n-2}.  Thus, &lt;statement&gt;a(I,J)&lt;/statement&gt; is the subset
    with a domain of the Cartesian product of {1, 2, &hellip;, n-2} with
    itself.  It is called a &lt;firstterm&gt;view&lt;/firstterm&gt; of an array.  It
    is itself an &array;, with a domain and supporting element access, but
    its storage is the same as &lt;varname&gt;a&lt;/varname&gt;'s.  Changing a value
!   in &lt;statement&gt;a(I,J)&lt;/statement&gt; also changes the same value in
    &lt;varname&gt;a&lt;/varname&gt;.  Changing a value in the latter also changes
    the former if the value is not one of &lt;varname&gt;a&lt;/varname&gt;'s
    outermost elements.  The expression
!   &lt;statement&gt;b(I+1,J+1)&lt;/statement&gt; indicates the subset of
    &lt;varname&gt;b&lt;/varname&gt; with a domain consisting of the Cartesian
    product of {2, 3, &hellip;, n-1}, i.e., the same domain as
!   &lt;statement&gt;a(I,J)&lt;/statement&gt; but shifted up one unit and to the
    right one unit.  Only an &interval;'s value, not its name, is
    important so all uses of &lt;varname&gt;J&lt;/varname&gt; in this program
    could be replaced by &lt;varname&gt;I&lt;/varname&gt; without changing the
    semantics.&lt;/para&gt;
  
!   &lt;para&gt;The statement assigning to &lt;statement&gt;a(I,J)&lt;/statement&gt;
    illustrates that &array;s may participate in expressions.  Each
    addend is a view of an array, which is itself an array.  The views'
    indices are zero-based so their sum can be formed by adding
--- 454,483 ----
  
    &lt;para&gt;Data-parallel expressions use containers and domain objects to
    indicate a set of parallel expressions.  For example, in the program
!   listed above, &lt;literal&gt;a(I,J)&lt;/literal&gt; specifies the subset of
    &lt;varname&gt;a&lt;/varname&gt; array omitting the outermost elements.  The
    array's &lt;varname&gt;vertDomain&lt;/varname&gt; domain consists of the
    Cartesian product of {0, 1, 2, &hellip;, n-1} with itself, while
    &lt;varname&gt;I&lt;/varname&gt; and &lt;varname&gt;J&lt;/varname&gt; each specify {1, 2,
!   &hellip;, n-2}.  Thus, &lt;literal&gt;a(I,J)&lt;/literal&gt; is the subset
    with a domain of the Cartesian product of {1, 2, &hellip;, n-2} with
    itself.  It is called a &lt;firstterm&gt;view&lt;/firstterm&gt; of an array.  It
    is itself an &array;, with a domain and supporting element access, but
    its storage is the same as &lt;varname&gt;a&lt;/varname&gt;'s.  Changing a value
!   in &lt;literal&gt;a(I,J)&lt;/literal&gt; also changes the same value in
    &lt;varname&gt;a&lt;/varname&gt;.  Changing a value in the latter also changes
    the former if the value is not one of &lt;varname&gt;a&lt;/varname&gt;'s
    outermost elements.  The expression
!   &lt;literal&gt;b(I+1,J+1)&lt;/literal&gt; indicates the subset of
    &lt;varname&gt;b&lt;/varname&gt; with a domain consisting of the Cartesian
    product of {2, 3, &hellip;, n-1}, i.e., the same domain as
!   &lt;literal&gt;a(I,J)&lt;/literal&gt; but shifted up one unit and to the
    right one unit.  Only an &interval;'s value, not its name, is
    important so all uses of &lt;varname&gt;J&lt;/varname&gt; in this program
    could be replaced by &lt;varname&gt;I&lt;/varname&gt; without changing the
    semantics.&lt;/para&gt;
  
!   &lt;para&gt;The statement assigning to &lt;literal&gt;a(I,J)&lt;/literal&gt;
    illustrates that &array;s may participate in expressions.  Each
    addend is a view of an array, which is itself an array.  The views'
    indices are zero-based so their sum can be formed by adding
***************
*** 581,587 ****
    Applying the stencil's function call &lt;function&gt;operator()&lt;/function&gt;
    yields the computed value.  To compute multiple &array; values,
    apply a stencil to the array and a domain object:
!   &lt;statement&gt;stencil(b, interiorDomain)&lt;/statement&gt;.  This applies the
    stencil to each position in the domain.  The user must ensure that
    applying the stencil does not access nonexistent &array;
    values.&lt;/para&gt;
--- 581,587 ----
    Applying the stencil's function call &lt;function&gt;operator()&lt;/function&gt;
    yields the computed value.  To compute multiple &array; values,
    apply a stencil to the array and a domain object:
!   &lt;literal&gt;stencil(b, interiorDomain)&lt;/literal&gt;.  This applies the
    stencil to each position in the domain.  The user must ensure that
    applying the stencil does not access nonexistent &array;
    values.&lt;/para&gt;
***************
*** 611,632 ****
  
    &lt;para&gt;To create a stencil object, apply the &stencil; type to a
    function object class.  For example,
!   &lt;statement&gt;Stencil&lt;DoofNinePt&gt; stencil&lt;/statement&gt; declares
    the &lt;varname&gt;stencil&lt;/varname&gt; object.  The function object class
    must define a function call &lt;function&gt;operator()&lt;/function&gt; with a
    container parameter and index parameters.  The number of index
    parameters, indicating the stencil's center, must equal the
    container's dimension.  For example, &lt;type&gt;DoofNinePt&lt;/type&gt; defines
!   &lt;methodname&gt;operator()(const C&amp; c, int i, int j)&lt;/methodname&gt;.  We
    templated the container type &lt;varname&gt;C&lt;/varname&gt; although this is
    not strictly necessary.  The two index parameters
    &lt;varname&gt;i&lt;/varname&gt; and &lt;varname&gt;j&lt;/varname&gt; ensure the stencil
    works with two-dimensional containers.  The
!   &lt;methodname&gt;lowerExtent&lt;/methodname&gt; function indicates how far to
    the left (or below) the stencil extends beyond its center.  Its
    parameter indicates a particular dimension.  Index parameters
    &lt;varname&gt;i&lt;/varname&gt; and &lt;varname&gt;j&lt;/varname&gt; are in dimension 0
!   and&nbsp;1.  &lt;methodname&gt;upperExtent&lt;/methodname&gt; serves an
    analogous purpose.  The &poomatoolkit; uses these functions when
    distributing computation among various processors, but it does not
    use these functions to ensure nonexistent &array; values are not
--- 611,632 ----
  
    &lt;para&gt;To create a stencil object, apply the &stencil; type to a
    function object class.  For example,
!   &lt;literal&gt;Stencil&lt;DoofNinePt&gt; stencil&lt;/literal&gt; declares
    the &lt;varname&gt;stencil&lt;/varname&gt; object.  The function object class
    must define a function call &lt;function&gt;operator()&lt;/function&gt; with a
    container parameter and index parameters.  The number of index
    parameters, indicating the stencil's center, must equal the
    container's dimension.  For example, &lt;type&gt;DoofNinePt&lt;/type&gt; defines
!   &lt;literal&gt;operator()(const C&amp; c, int i, int j)&lt;/literal&gt;.  We
    templated the container type &lt;varname&gt;C&lt;/varname&gt; although this is
    not strictly necessary.  The two index parameters
    &lt;varname&gt;i&lt;/varname&gt; and &lt;varname&gt;j&lt;/varname&gt; ensure the stencil
    works with two-dimensional containers.  The
!   &lt;literal&gt;lowerExtent&lt;/literal&gt; function indicates how far to
    the left (or below) the stencil extends beyond its center.  Its
    parameter indicates a particular dimension.  Index parameters
    &lt;varname&gt;i&lt;/varname&gt; and &lt;varname&gt;j&lt;/varname&gt; are in dimension 0
!   and&nbsp;1.  &lt;literal&gt;upperExtent&lt;/literal&gt; serves an
    analogous purpose.  The &poomatoolkit; uses these functions when
    distributing computation among various processors, but it does not
    use these functions to ensure nonexistent &array; values are not
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000896.html">Manual Patch: Figure Code
</A></li>
	<LI>Next message: <A HREF="000898.html">Manual Patch: Formatting Changes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#897">[ date ]</a>
              <a href="thread.html#897">[ thread ]</a>
              <a href="subject.html#897">[ subject ]</a>
              <a href="author.html#897">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
