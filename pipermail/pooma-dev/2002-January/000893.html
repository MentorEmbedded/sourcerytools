<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Patch: Fix Typos in Comments
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Patch%3A%20Fix%20Typos%20in%20Comments&In-Reply-To=%3C20020129095947.A21227%40vaio.codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000892.html">
   <LINK REL="Next"  HREF="000894.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Patch: Fix Typos in Comments</H1>
    <B>Jeffrey</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Patch%3A%20Fix%20Typos%20in%20Comments&In-Reply-To=%3C20020129095947.A21227%40vaio.codesourcery.com%3E"
       TITLE="Patch: Fix Typos in Comments">oldham at mail.codesourcery.com
       </A><BR>
    <I>Tue Jan 29 17:59:47 UTC 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="000892.html">Manual: Illustrative Programs
</A></li>
        <LI>Next message: <A HREF="000894.html">Manual Patch: More Wordsmithing and Formatting
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#893">[ date ]</a>
              <a href="thread.html#893">[ thread ]</a>
              <a href="subject.html#893">[ subject ]</a>
              <a href="author.html#893">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2002-Jan-29  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

	* Domain/Grid.h: Fix typos in comments.  Change &quot;bidirectional
	iterator&quot; to &quot;forward iterator&quot; in comment to reflect code.
	* Domain/IndirectionList.h: Likewise.
	* Domain/Interval.h: Likewise.
	* Domain/Loc.h: Likewise.
	* Domain/Range.h: Likewise.
	* Domain/Region.h: Likewise.
	* Domain/tests/grid.cpp: End comment with a period.
	* Engine/BrickBase.h (BrickBase&lt;Dim&gt;::first):
	s/direction/dimension/ in comment.
	(BrickBase&lt;Dim&gt;::strides_m): Likewise.
	(BrickViewBase&lt;Dim&gt;::first): Likewise.
	* Engine/DynamicEngine.h (Engine&lt;1,T,Dynamic&gt;::destroy): Remove
	incorrect space in comment.
	(Engine&lt;1,T,Dynamic&gt;::performDestroy): Remove incorrect apostrophe
	in comment.
	* Engine/RemoteDynamicEngine.h: End comment with a period.
	* Engine/Stencil.h: Remove non-existent 'ArrayStencil' from comment.
	* Field/DiffOps/FieldStencil.h: Fix spacing in comment.
	* Field/tests/TestBasicRelations.cpp: Fix spacing.
	* PETE/Combiners.h: Fix typos in comments.
	* PETE/TypeComputations.h: Fix typo in comment.
	* Tiny/VectorTensor.h: Likewise.
	* Utilities/DataBlockPtr.h (DataBlockController): Fix spelling
	mistake in comment.
	
Applied to	mainline
Approved by	Stephen Smith
Not tested.  Only comments (and one whitespace change) so no testing.

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: Domain/Grid.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Grid.h,v
retrieving revision 1.13
diff -c -p -r1.13 Grid.h
*** Domain/Grid.h	2002/01/14 16:48:21	1.13
--- Domain/Grid.h	2002/01/25 03:50:52
***************
*** 84,90 ****
  // in the constructor for Grid; it acts like a Loc&lt;1&gt; object
  // in that context.  The domain arguments for the Grid
  // constructors are combined together to form a single domain object with
! // a dimension equal to the sum of the arguments dimensions; for example,
  // if you try to create a Grid&lt;3&gt; from a Loc&lt;2&gt; and an Interval&lt;1&gt;, e.g.
  //   Grid&lt;3&gt; a(Loc&lt;2&gt;(1,2), Interval&lt;1&gt;(3,5));
  // the Loc&lt;2&gt; and Interval arguments are combined into a (2+1=3) dimensional
--- 84,90 ----
  // in the constructor for Grid; it acts like a Loc&lt;1&gt; object
  // in that context.  The domain arguments for the Grid
  // constructors are combined together to form a single domain object with
! // a dimension equal to the sum of the argument's dimensions; for example,
  // if you try to create a Grid&lt;3&gt; from a Loc&lt;2&gt; and an Interval&lt;1&gt;, e.g.
  //   Grid&lt;3&gt; a(Loc&lt;2&gt;(1,2), Interval&lt;1&gt;(3,5));
  // the Loc&lt;2&gt; and Interval arguments are combined into a (2+1=3) dimensional
***************
*** 116,122 ****
  // Grid&lt;N&gt; interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lenghts of the N 1D Grids
  //   bool empty() - return if any of the Grid&lt;1&gt; objects have length == 0
  //   Grid&lt;1&gt; operator[](int N) - return the Nth Grid&lt;1&gt; in a
  //      multidimensional Grid&lt;M&gt;.  For Grid&lt;1&gt; objects, this just
--- 116,122 ----
  // Grid&lt;N&gt; interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lengths of the N 1D Grids
  //   bool empty() - return if any of the Grid&lt;1&gt; objects have length == 0
  //   Grid&lt;1&gt; operator[](int N) - return the Nth Grid&lt;1&gt; in a
  //      multidimensional Grid&lt;M&gt;.  For Grid&lt;1&gt; objects, this just
***************
*** 124,130 ****
  //   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare a Grid&lt;N&gt; to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or substract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
--- 124,130 ----
  //   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare a Grid&lt;N&gt; to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or subtract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
***************
*** 134,140 ****
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Grid negates the endpoints and stride.
! //   binary arithmethic operators +, -, *, / : for + and -, adding a Grid
  //      to another Loc or int returns a new Grid.  For * and /, scaling
  //      by a Loc or int also returns a Grid object, since the stride may
  //      change.
--- 134,140 ----
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Grid negates the endpoints and stride.
! //   binary arithmetic operators +, -, *, / : for + and -, adding a Grid
  //      to another Loc or int returns a new Grid.  For * and /, scaling
  //      by a Loc or int also returns a Grid object, since the stride may
  //      change.
***************
*** 152,159 ****
  //   int first() - the beginning endpoint.
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
! //   Interval&lt;1&gt;::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) bidirectional iterators.
  //
  // For the special case of Grid&lt;1&gt;, there is a specialization given
  // after the general case that has different constructors.
--- 152,159 ----
  //   int first() - the beginning endpoint.
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
! //   Grid&lt;1&gt;::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) forward iterators.
  //
  // For the special case of Grid&lt;1&gt;, there is a specialization given
  // after the general case that has different constructors.
Index: Domain/IndirectionList.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/IndirectionList.h,v
retrieving revision 1.16
diff -c -p -r1.16 IndirectionList.h
*** Domain/IndirectionList.h	2001/04/13 02:12:59	1.16
--- Domain/IndirectionList.h	2002/01/25 03:50:52
***************
*** 85,91 ****
  // IndirectionList&lt;T&gt; interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lenghts of the N 1D IndirectionLists
  //   bool empty() - return if any of the IndirectionList objects have
  //      length == 0
  //   IndirectionList operator[](int N) - return the Nth IndirectionList
--- 85,91 ----
  // IndirectionList&lt;T&gt; interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lengths of the N 1D IndirectionLists
  //   bool empty() - return if any of the IndirectionList objects have
  //      length == 0
  //   IndirectionList operator[](int N) - return the Nth IndirectionList
***************
*** 94,100 ****
  //   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare a IndirectionList
  //      to another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or substract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
--- 94,100 ----
  //   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare a IndirectionList
  //      to another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or subtract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
***************
*** 120,126 ****
  //   int last() - the ending endpoint.  
  //   int min(), int max() - min or max of the endpoints.
  //   IndirectionList::iterator begin() and end() - return iterators for
! //   the 1D domain.  These act like (at least) bidirectional iterators.
  //
  //-----------------------------------------------------------------------------
  
--- 120,126 ----
  //   int last() - the ending endpoint.  
  //   int min(), int max() - min or max of the endpoints.
  //   IndirectionList::iterator begin() and end() - return iterators for
! //   the 1D domain.  These act like (at least) forward iterators.
  //
  //-----------------------------------------------------------------------------
  
Index: Domain/Interval.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Interval.h,v
retrieving revision 1.19
diff -c -p -r1.19 Interval.h
*** Domain/Interval.h	2002/01/14 16:48:21	1.19
--- Domain/Interval.h	2002/01/25 03:50:52
***************
*** 78,84 ****
  // in the constructor for Interval; it acts like a Loc&lt;1&gt; object
  // in that context.  The domain arguments for the Interval
  // constructors are combined together to form a single domain object with
! // a dimension equal to the sum of the arguments dimensions; for example,
  // if you try to create an Interval&lt;3&gt; from a Loc&lt;2&gt; and an Interval&lt;1&gt;, e.g.
  //   Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2), Interval&lt;1&gt;(3,5));
  // the Loc&lt;2&gt; and Interval arguments are combined into a (2+1=3) dimensional
--- 78,84 ----
  // in the constructor for Interval; it acts like a Loc&lt;1&gt; object
  // in that context.  The domain arguments for the Interval
  // constructors are combined together to form a single domain object with
! // a dimension equal to the sum of the arguments' dimensions; for example,
  // if you try to create an Interval&lt;3&gt; from a Loc&lt;2&gt; and an Interval&lt;1&gt;, e.g.
  //   Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2), Interval&lt;1&gt;(3,5));
  // the Loc&lt;2&gt; and Interval arguments are combined into a (2+1=3) dimensional
***************
*** 104,110 ****
  // Interval&lt;N&gt; interface:
  // ----------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lenghts of the N 1D Intervals
  //   bool empty() - return if any of the Interval&lt;1&gt; objects have length == 0
  //   Interval&lt;1&gt; operator[](int N) - return the Nth Interval&lt;1&gt; in a
  //      multidimensional Interval&lt;M&gt;.  For Interval&lt;1&gt; objects, this just
--- 104,110 ----
  // Interval&lt;N&gt; interface:
  // ----------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lengths of the N 1D Intervals
  //   bool empty() - return if any of the Interval&lt;1&gt; objects have length == 0
  //   Interval&lt;1&gt; operator[](int N) - return the Nth Interval&lt;1&gt; in a
  //      multidimensional Interval&lt;M&gt;.  For Interval&lt;1&gt; objects, this just
***************
*** 112,118 ****
  //   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare an Interval &lt;N&gt; to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -= : add or substract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
--- 112,118 ----
  //   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare an Interval &lt;N&gt; to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -= : add or subtract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
***************
*** 120,126 ****
  //      allowed, since these operators would change the stride and that is
  //      not allowed for Interval (it has a hard-coded stride of 1).
  //      The negation operator (operator-) is also NOT allowed for Interval.
! //   binary arithmethic operators +, -, *, / : for + and -, adding an Interval
  //      to another Loc or int returns a new Interval.  For * and /, scaling
  //      by a Loc or int returns a Range object, since the stride may
  //      change.
--- 120,126 ----
  //      allowed, since these operators would change the stride and that is
  //      not allowed for Interval (it has a hard-coded stride of 1).
  //      The negation operator (operator-) is also NOT allowed for Interval.
! //   binary arithmetic operators +, -, *, / : for + and -, adding an Interval
  //      to another Loc or int returns a new Interval.  For * and /, scaling
  //      by a Loc or int returns a Range object, since the stride may
  //      change.
***************
*** 135,141 ****
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
  //   Interval&lt;1&gt;::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) bidirectional iterators.
  //
  // Interval inherits much of its activity from Domain&lt;DomainTraits&lt;Interval&gt;&gt;.
  //
--- 135,141 ----
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
  //   Interval&lt;1&gt;::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) forward iterators.
  //
  // Interval inherits much of its activity from Domain&lt;DomainTraits&lt;Interval&gt;&gt;.
  //
Index: Domain/Loc.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Loc.h,v
retrieving revision 1.25
diff -c -p -r1.25 Loc.h
*** Domain/Loc.h	2002/01/14 16:48:21	1.25
--- Domain/Loc.h	2002/01/25 03:50:52
***************
*** 113,119 ****
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
  //      is true for Loc and int's). 
! //   binary arithmethic operators +, -, *, / : for + and -, adding a Loc
  //      to another Loc or int returns a new Loc object.  For * and /, scaling
  //      by a Loc or int returns a Range object, since the stride may
  //      change.
--- 113,119 ----
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
  //      is true for Loc and int's). 
! //   binary arithmetic operators +, -, *, / : for + and -, adding a Loc
  //      to another Loc or int returns a new Loc object.  For * and /, scaling
  //      by a Loc or int returns a Range object, since the stride may
  //      change.
***************
*** 129,135 ****
  //   int last() - the ending endpoint, for Loc&lt;1&gt; just the point itself.
  //   int min(), int max() - min or max of the endpoints.
  //   Loc&lt;1&gt;::iterator begin() and end() - return iterators for the 1D domain.
! //      These act like (at least) bidirectional iterators.
  //
  // Loc inherits much of its activity from Domain&lt;DomainTraits&lt;Loc&gt;,Dim&gt;.
  // Domain is a base class that uses the template argument as a traits class
--- 129,135 ----
  //   int last() - the ending endpoint, for Loc&lt;1&gt; just the point itself.
  //   int min(), int max() - min or max of the endpoints.
  //   Loc&lt;1&gt;::iterator begin() and end() - return iterators for the 1D domain.
! //      These act like (at least) forward iterators.
  //
  // Loc inherits much of its activity from Domain&lt;DomainTraits&lt;Loc&gt;,Dim&gt;.
  // Domain is a base class that uses the template argument as a traits class
Index: Domain/Range.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Range.h,v
retrieving revision 1.20
diff -c -p -r1.20 Range.h
*** Domain/Range.h	2002/01/14 16:48:21	1.20
--- Domain/Range.h	2002/01/25 03:50:52
*************** void fillRangeScalar(Range&lt;Dim&gt; &amp;r, cons
*** 111,117 ****
  // Range&lt;N&gt; interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lenghts of the N 1D Ranges
  //   bool empty() - return if any of the Range&lt;1&gt; objects have length == 0
  //   Range&lt;1&gt; operator[](int N) - return the Nth Range&lt;1&gt; in a
  //      multidimensional Range&lt;M&gt;.  For Range&lt;1&gt; objects, this just
--- 111,117 ----
  // Range&lt;N&gt; interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lengths of the N 1D Ranges
  //   bool empty() - return if any of the Range&lt;1&gt; objects have length == 0
  //   Range&lt;1&gt; operator[](int N) - return the Nth Range&lt;1&gt; in a
  //      multidimensional Range&lt;M&gt;.  For Range&lt;1&gt; objects, this just
*************** void fillRangeScalar(Range&lt;Dim&gt; &amp;r, cons
*** 119,125 ****
  //   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare a Range&lt;N&gt; to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or substract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
--- 119,125 ----
  //   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare a Range&lt;N&gt; to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or subtract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
*************** void fillRangeScalar(Range&lt;Dim&gt; &amp;r, cons
*** 129,135 ****
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Range negates the endpoints and stride.
! //   binary arithmethic operators +, -, *, / : for + and -, adding a Range
  //      to another Loc or int returns a new Range.  For * and /, scaling
  //      by a Loc or int also returns a Range object, since the stride may
  //      change.
--- 129,135 ----
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Range negates the endpoints and stride.
! //   binary arithmetic operators +, -, *, / : for + and -, adding a Range
  //      to another Loc or int returns a new Range.  For * and /, scaling
  //      by a Loc or int also returns a Range object, since the stride may
  //      change.
*************** void fillRangeScalar(Range&lt;Dim&gt; &amp;r, cons
*** 147,154 ****
  //   int first() - the beginning endpoint.
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
! //   Interval&lt;1&gt;::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) bidirectional iterators.
  //
  // For the special case of Range&lt;1&gt;, there is a specialization given
  // after the general case that has different constructors.
--- 147,154 ----
  //   int first() - the beginning endpoint.
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
! //   Range&lt;1&gt;::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) forward iterators.
  //
  // For the special case of Range&lt;1&gt;, there is a specialization given
  // after the general case that has different constructors.
Index: Domain/Region.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Region.h,v
retrieving revision 1.23
diff -c -p -r1.23 Region.h
*** Domain/Region.h	2001/04/13 02:12:59	1.23
--- Domain/Region.h	2002/01/25 03:50:52
***************
*** 78,84 ****
  //
  // You can construct a Region object using other domain objects.
  // The constructors accept up to 7 domain objects of various types.
! // Domain types are, for example, Loc, Region, Interval. an int, double, or
  // float may also be used
  // in the constructor for Region; it acts like a Loc&lt;1&gt; object
  // in that context.  The domain arguments for the Region
--- 78,84 ----
  //
  // You can construct a Region object using other domain objects.
  // The constructors accept up to 7 domain objects of various types.
! // Domain types are, for example, Loc, Region, Interval. An int, double, or
  // float may also be used
  // in the constructor for Region; it acts like a Loc&lt;1&gt; object
  // in that context.  The domain arguments for the Region
***************
*** 117,123 ****
  // Region&lt;N,T&gt; interface:
  // -------------------
  //   T size() - return the 'volume' of the domain, which is the product
! //      of the lenghts of the N 1D Regions
  //   bool empty() - always false here
  //   Region&lt;1,T&gt; operator[](int N) - return the Nth Region&lt;1,T&gt; in a
  //      multidimensional Region&lt;M,T&gt;.  For Region&lt;1,T&gt; objects, this just
--- 117,123 ----
  // Region&lt;N,T&gt; interface:
  // -------------------
  //   T size() - return the 'volume' of the domain, which is the product
! //      of the lengths of the N 1D Regions
  //   bool empty() - always false here
  //   Region&lt;1,T&gt; operator[](int N) - return the Nth Region&lt;1,T&gt; in a
  //      multidimensional Region&lt;M,T&gt;.  For Region&lt;1,T&gt; objects, this just
***************
*** 125,131 ****
  //   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare a Region&lt;N,T&gt; to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or substract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
--- 125,131 ----
  //   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare a Region&lt;N,T&gt; to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or subtract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
***************
*** 135,141 ****
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Region negates the endpoints and stride.
! //   binary arithmethic operators +, -, *, / : for + and -, adding a Region
  //      to another Loc or int returns a new Region.  For * and /, scaling
  //      by a Loc or int also returns a Region object, since the stride may
  //      change.
--- 135,141 ----
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Region negates the endpoints and stride.
! //   binary arithmetic operators +, -, *, / : for + and -, adding a Region
  //      to another Loc or int returns a new Region.  For * and /, scaling
  //      by a Loc or int also returns a Region object, since the stride may
  //      change.
***************
*** 147,162 ****
  //   all the methods for Region&lt;N,T&gt; are also available for Region&lt;1,T&gt;. Plus:
  //   T length() - number of elements (including endpoints) of the domain.
  //     Really, this should be either 1 or infinity, but it defined here
! //     somewhat differently, as just the distance betweent the endpoints.  So
  //     a length of zero really means this just refers to one point, not that
! //     this is empty.  A Region cannot be empty, it must refer to SOME point(s)
  //   T first() - the beginning endpoint.
  //   T last() - the ending endpoint.
  //   T stride() - here, the same as the length()
  //   T min(), T max() - min or max of the endpoints.
  //   bool empty() - always false for a Region
  //   Region&lt;1,T&gt;::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) bidirectional iterators.
  //
  // For the special case of Region&lt;1,T&gt;, there is a specialization given
  // after the general case that has different constructors.
--- 147,162 ----
  //   all the methods for Region&lt;N,T&gt; are also available for Region&lt;1,T&gt;. Plus:
  //   T length() - number of elements (including endpoints) of the domain.
  //     Really, this should be either 1 or infinity, but it defined here
! //     somewhat differently, as just the distance between the endpoints.  So
  //     a length of zero really means this just refers to one point, not that
! //     this is empty.  A Region cannot be empty, it must refer to SOME point(s).
  //   T first() - the beginning endpoint.
  //   T last() - the ending endpoint.
  //   T stride() - here, the same as the length()
  //   T min(), T max() - min or max of the endpoints.
  //   bool empty() - always false for a Region
  //   Region&lt;1,T&gt;::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) forward iterators.
  //
  // For the special case of Region&lt;1,T&gt;, there is a specialization given
  // after the general case that has different constructors.
Index: Domain/tests/grid.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/tests/grid.cpp,v
retrieving revision 1.5
diff -c -p -r1.5 grid.cpp
*** Domain/tests/grid.cpp	2000/03/07 13:16:42	1.5
--- Domain/tests/grid.cpp	2002/01/25 03:50:53
*************** int main(int argc, char *argv[]) {
*** 60,66 ****
  
    tester.out() &lt;&lt; &quot;Created Range = &quot; &lt;&lt; range &lt;&lt; std::endl;
  
!   // Construct a 1D Grid from the IndirectionList, and from the range
  
    Grid&lt;1&gt; g1(list);
    Grid&lt;1&gt; g2(range);
--- 60,66 ----
  
    tester.out() &lt;&lt; &quot;Created Range = &quot; &lt;&lt; range &lt;&lt; std::endl;
  
!   // Construct a 1D Grid from the IndirectionList and from the range.
  
    Grid&lt;1&gt; g1(list);
    Grid&lt;1&gt; g2(range);
Index: Engine/BrickBase.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/BrickBase.h,v
retrieving revision 1.13
diff -c -p -r1.13 BrickBase.h
*** Engine/BrickBase.h	2001/10/24 15:39:42	1.13
--- Engine/BrickBase.h	2002/01/25 03:50:53
*************** public:
*** 173,179 ****
    
    inline const int *originalStrides() const { return &amp;ostrides_m[0]; }
  
!   // Return the first index value for the specified direction.
    
    int first(int i) const;
    
--- 173,179 ----
    
    inline const int *originalStrides() const { return &amp;ostrides_m[0]; }
  
!   // Return the first index value for the specified dimension.
    
    int first(int i) const;
    
*************** protected:
*** 315,321 ****
  
    Layout_t layout_m;
  
!   // Strides through actual data block when stepping in different directions.
    // We keep two copies - strides_m is used by the offset calculations. 
    // If we are compressible, then when compressed, these will all be 
    // set to zero. 
--- 315,321 ----
  
    Layout_t layout_m;
  
!   // Strides through actual data block when stepping in different dimensions.
    // We keep two copies - strides_m is used by the offset calculations. 
    // If we are compressible, then when compressed, these will all be 
    // set to zero. 
*************** public:
*** 538,544 ****
    
    inline const int *originalStrides() const { return &amp;ostrides_m[0]; }
  
!   // Return the first index value for the specified direction.
    // (Always zero since views are zero-based).
    
    inline int first(int) const { return 0; }
--- 538,544 ----
    
    inline const int *originalStrides() const { return &amp;ostrides_m[0]; }
  
!   // Return the first index value for the specified dimension.
    // (Always zero since views are zero-based).
    
    inline int first(int) const { return 0; }
*************** protected:
*** 663,669 ****
    
    Domain_t domain_m;
  
!   // Strides through actual data block when stepping in each direction.
    // We keep two copies - strides_m is used by the offset calculations. 
    // If we are compressible, then when compressed, these will all be 
    // set to zero. 
--- 663,669 ----
    
    Domain_t domain_m;
  
!   // Strides through actual data block when stepping in each dimension.
    // We keep two copies - strides_m is used by the offset calculations. 
    // If we are compressible, then when compressed, these will all be 
    // set to zero. 
Index: Engine/DynamicEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/DynamicEngine.h,v
retrieving revision 1.16
diff -c -p -r1.16 DynamicEngine.h
*** Engine/DynamicEngine.h	2001/04/09 21:34:27	1.16
--- Engine/DynamicEngine.h	2002/01/25 03:50:53
*************** public:
*** 275,281 ****
    void destroy(const Dom &amp;killList);
  
    // Same, but with iterators into some container holding the
!   // points of the domain. These must be random-access iterators ( a
    // requirement of the underlying delete algorithm).
    
    template &lt;class Iter&gt;
--- 275,281 ----
    void destroy(const Dom &amp;killList);
  
    // Same, but with iterators into some container holding the
!   // points of the domain. These must be random-access iterators (a
    // requirement of the underlying delete algorithm).
    
    template &lt;class Iter&gt;
*************** private:
*** 359,365 ****
    // versions that take iterators into the killList. This allows one
    // to use many more data structures for holding the kill list.
    
!   // If offsetFlag is true (delete default's it to false), the domain 
    // is interpreted as a list of offsets rather than a subset of 
    // the engine's domain.
  
--- 359,365 ----
    // versions that take iterators into the killList. This allows one
    // to use many more data structures for holding the kill list.
    
!   // If offsetFlag is true (delete defaults it to false), the domain 
    // is interpreted as a list of offsets rather than a subset of 
    // the engine's domain.
  
Index: Engine/RemoteDynamicEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/RemoteDynamicEngine.h,v
retrieving revision 1.16
diff -c -p -r1.16 RemoteDynamicEngine.h
*** Engine/RemoteDynamicEngine.h	2001/05/16 21:21:06	1.16
--- Engine/RemoteDynamicEngine.h	2002/01/25 03:50:54
***************
*** 40,46 ****
  //
  //   Engine&lt;1, T, Remote&lt;Dynamic&gt; &gt;
  //    - A wrapper engine that remotifies an Engine&lt;1, T, Dynamic&gt;.
! //      The remote version belongs to a particular context
  //
  //-----------------------------------------------------------------------------
  
--- 40,46 ----
  //
  //   Engine&lt;1, T, Remote&lt;Dynamic&gt; &gt;
  //    - A wrapper engine that remotifies an Engine&lt;1, T, Dynamic&gt;.
! //      The remote version belongs to a particular context.
  //
  //-----------------------------------------------------------------------------
  
Index: Engine/Stencil.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/Stencil.h,v
retrieving revision 1.44
diff -c -p -r1.44 Stencil.h
*** Engine/Stencil.h	2001/09/14 22:37:56	1.44
--- Engine/Stencil.h	2002/01/25 03:50:54
***************
*** 30,37 ****
  // Classes: 
  //   Stencil               - Base class for defining stencils
  //   StencilEngine         - An tag for an engine for representing a stencil
- //   ArrayStencil          - contains utility functions for building stencils
- //                           on arrays
  //   View1                 - Specialization for Stencil
  //   Engine                - Specialization for StencilEngine
  //   NewEngine             - Specialization for StencilEngine
--- 30,35 ----
Index: Field/DiffOps/FieldStencil.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Field/DiffOps/FieldStencil.h,v
retrieving revision 1.1
diff -c -p -r1.1 FieldStencil.h
*** Field/DiffOps/FieldStencil.h	2001/08/30 01:15:09	1.1
--- Field/DiffOps/FieldStencil.h	2002/01/25 03:50:54
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, ApplyF
*** 716,722 ****
  };
  
  //---------------------------------------------------------------------------
! // Specialization of  DataObjectRequest engineFunctor to pass the request to
  // the contained engine.
  //---------------------------------------------------------------------------
  
--- 716,722 ----
  };
  
  //---------------------------------------------------------------------------
! // Specialization of DataObjectRequest engineFunctor to pass the request to
  // the contained engine.
  //---------------------------------------------------------------------------
  
Index: Field/tests/TestBasicRelations.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Field/tests/TestBasicRelations.cpp,v
retrieving revision 1.2
diff -c -p -r1.2 TestBasicRelations.cpp
*** Field/tests/TestBasicRelations.cpp	2001/10/12 02:09:27	1.2
--- Field/tests/TestBasicRelations.cpp	2002/01/25 03:50:54
*************** struct ComputeVelocity
*** 63,69 ****
  {
    void doit(const Field_t &amp;v, const Field_t &amp;p, const Field_t &amp;m)
    {
!     v = p /  m;
    }
  };
  
--- 63,69 ----
  {
    void doit(const Field_t &amp;v, const Field_t &amp;p, const Field_t &amp;m)
    {
!     v = p / m;
    }
  };
  
Index: PETE/Combiners.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/PETE/Combiners.h,v
retrieving revision 1.10
diff -c -p -r1.10 Combiners.h
*** PETE/Combiners.h	2000/12/04 21:19:37	1.10
--- PETE/Combiners.h	2002/01/25 03:50:55
*************** peteCombine(const A &amp;a, const B &amp;b, cons
*** 158,164 ****
  //   back with modified leaves.
  //
  //   This type of operation is useful when expressions are being
! //   passed around.  For example, you might subset and expression and pass
  //   that result to another function.  The type of expression tree that you
  //   are passing has subsetted nodes, and could be a different type from the
  //   original expression.
--- 158,164 ----
  //   back with modified leaves.
  //
  //   This type of operation is useful when expressions are being
! //   passed around.  For example, you might subset an expression and pass
  //   that result to another function.  The type of expression tree that you
  //   are passing has subsetted nodes, and could be a different type from the
  //   original expression.
*************** struct Combine2&lt;bool, bool, Op, OrCombin
*** 311,317 ****
  //
  // DESCRIPTION
  //   This combiner doesn't do anything. Used when the combination isn't meant
! //   return anything since combiners cannot return void.
  //
  //-----------------------------------------------------------------------------
  
--- 311,317 ----
  //
  // DESCRIPTION
  //   This combiner doesn't do anything. Used when the combination isn't meant
! //   to return anything since combiners cannot return void.
  //
  //-----------------------------------------------------------------------------
  
Index: PETE/TypeComputations.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/PETE/TypeComputations.h,v
retrieving revision 1.11
diff -c -p -r1.11 TypeComputations.h
*** PETE/TypeComputations.h	2000/08/08 17:34:09	1.11
--- PETE/TypeComputations.h	2002/01/25 03:50:55
***************
*** 44,50 ****
  //        function/operation. For example, operator-(T) should return a T.
  //      o return a type based entirely on the operation. 
  //        For example, operator! always returns a bool.
! //      o sythesize a type based on the type of the argument and the operation.
  //    The first case is most common. We therefore make it the behavior
  //    for the base template. The other cases are handled by partial
  //    specialization.
--- 44,50 ----
  //        function/operation. For example, operator-(T) should return a T.
  //      o return a type based entirely on the operation. 
  //        For example, operator! always returns a bool.
! //      o synthesize a type based on the type of the argument and the operation.
  //    The first case is most common. We therefore make it the behavior
  //    for the base template. The other cases are handled by partial
  //    specialization.
Index: Tiny/VectorTensor.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Tiny/VectorTensor.h,v
retrieving revision 1.14
diff -c -p -r1.14 VectorTensor.h
*** Tiny/VectorTensor.h	2000/03/07 13:18:16	1.14
--- Tiny/VectorTensor.h	2002/01/25 03:50:55
*************** dot( const Tensor&lt;D,T1,E1&gt;&amp; v1 , const V
*** 297,303 ****
  //
  // Full Description:
  //
! // Subroutine for taking outper product between two vectors, yielding a tensor.
  // Takes the outer product of vector of type V1 and vector of type V2
  //
  // The chain of operations is:
--- 297,303 ----
  //
  // Full Description:
  //
! // Subroutine for taking outer product between two vectors, yielding a tensor.
  // Takes the outer product of vector of type V1 and vector of type V2
  //
  // The chain of operations is:
Index: Utilities/DataBlockPtr.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Utilities/DataBlockPtr.h,v
retrieving revision 1.20
diff -c -p -r1.20 DataBlockPtr.h
*** Utilities/DataBlockPtr.h	2001/05/04 15:41:29	1.20
--- Utilities/DataBlockPtr.h	2002/01/25 03:50:55
*************** public:
*** 190,196 ****
    //   Ordinarily, this will NOT be used. However, if one
    //   wants to have a RefCountedBlockPtr&lt;T1&gt; where T1 itself
    //   is or contains a RefCountedBlockPtr&lt;T2&gt;, then this
!   //   may occaisionally be used. When it IS used, a DEEP
    //   copy is required. The RefCounted base class's copy
    //   constructor properly sets the count of the new
    //   class to zero.
--- 190,196 ----
    //   Ordinarily, this will NOT be used. However, if one
    //   wants to have a RefCountedBlockPtr&lt;T1&gt; where T1 itself
    //   is or contains a RefCountedBlockPtr&lt;T2&gt;, then this
!   //   may occasionally be used. When it IS used, a DEEP
    //   copy is required. The RefCounted base class's copy
    //   constructor properly sets the count of the new
    //   class to zero.
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000892.html">Manual: Illustrative Programs
</A></li>
	<LI>Next message: <A HREF="000894.html">Manual Patch: More Wordsmithing and Formatting
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#893">[ date ]</a>
              <a href="thread.html#893">[ thread ]</a>
              <a href="subject.html#893">[ subject ]</a>
              <a href="author.html#893">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
