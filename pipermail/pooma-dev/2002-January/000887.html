<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Manual: Wordsmithing Changes to First Four Chapters
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%3A%20Wordsmithing%20Changes%20to%20First%20Four%20Chapters&In-Reply-To=%3C20020123211851.A4304%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000886.html">
   <LINK REL="Next"  HREF="000888.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Manual: Wordsmithing Changes to First Four Chapters</H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%3A%20Wordsmithing%20Changes%20to%20First%20Four%20Chapters&In-Reply-To=%3C20020123211851.A4304%40codesourcery.com%3E"
       TITLE="Manual: Wordsmithing Changes to First Four Chapters">oldham at codesourcery.com
       </A><BR>
    <I>Thu Jan 24 05:18:51 UTC 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="000886.html">Manual Patch: DynamicArrays and Part of Engines
</A></li>
        <LI>Next message: <A HREF="000888.html">[pooma-dev] Manual: Wordsmithing Changes to First Four Chapte	rs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#887">[ date ]</a>
              <a href="thread.html#887">[ thread ]</a>
              <a href="subject.html#887">[ subject ]</a>
              <a href="author.html#887">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2002-Jan-23  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

        These changes move the manual toward delivery.  Unfinished
        sections remain in the DocBook source code but are not printed.
        The first two chapters were indexed.  Wordsmithing throughout the
        document (hopefully) improved the exposition.

        * arrays.xml: Wordsmithing.  Finish describing the Domain use
        section.
        * concepts.xml: Wordsmithing.
        * data-parallel.xml: Rewrite &quot;naive&quot;.
        * glossary.xml: Add some indexing.
        (stride): Fix definition.
        (template): New definition.
        * introduction.xml: Index.  Wordsmith.
        * manual.xml: Add 'unfinished', 'temporary', and 'naive', and
        'naivecap' entities.  Change names of entities that used capital
        letters.  Write short description of container views.  Comment out
        unfinished sections.
        * template.xml: Index.  s/&lt;&lt;/&openopen;/g.  Wordsmith.
        * tutorial.xml: Wordsmith.

Applied to	mainline.
Approved by	Bill Clinton.

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.2
diff -c -p -r1.2 arrays.xml
*** arrays.xml	2002/01/22 15:48:49	1.2
--- arrays.xml	2002/01/24 04:56:31
***************
*** 1,3 ****
--- 1,4 ----
+ &lt;!-- FIXME: Index this file. --&gt;
    &lt;chapter id=&quot;arrays&quot;&gt;
     &lt;title&gt;&array; Containers&lt;/title&gt;
  
***************
*** 961,967 ****
       &lt;para&gt;Since an &array; can be queried for its domain, we briefly
       describe some &domain; operations.  A fuller description,
       including arithmetic operations, occur in &lt;xref
!      linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-use-table&quot;&gt;
--- 962,973 ----
       &lt;para&gt;Since an &array; can be queried for its domain, we briefly
       describe some &domain; operations.  A fuller description,
       including arithmetic operations, occur in &lt;xref
!      linkend=&quot;views&quot;&gt;&lt;/xref&gt;.  As we mentioned in &lt;xref
!      linkend=&quot;arrays-domains-declarations&quot;&gt;&lt;/xref&gt;, the &lt;filename
!      class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt; header file
!      declares &domain;s, but most container header files automatically
!      include &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Domains.h&lt;/filename&gt;
!      so no explicit inclusion of is usually necessary.&lt;/para&gt;
  
       &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;arrays-domains-use-table&quot;&gt;
***************
*** 976,983 ****
         &lt;/thead&gt;
         &lt;tfoot&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;Other &domain; accessors are described in &lt;xref
! 	 linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tfoot&gt;
         &lt;tbody&gt;
--- 982,990 ----
         &lt;/thead&gt;
         &lt;tfoot&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;&lt;type&gt;D&lt;/type&gt; abbreviates the particular &domain;
! 	 type, e.g., &interval; or &grid;.  Other &domain; accessors
! 	 are described in &lt;xref linkend=&quot;views&quot;&gt;&lt;/xref&gt;.&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/tfoot&gt;
         &lt;tbody&gt;
***************
*** 1037,1053 ****
  
       &lt;para&gt;&domain; member functions are listed in &lt;xref
       linkend=&quot;arrays-domains-use-table&quot;&gt;&lt;/xref&gt;.  Functions applicable
!      to one-dimensional and multidimensional &domain;s are listed
       before functions that only applicable to one-dimensional
       &domain;s.  The &lt;methodname&gt;size&lt;/methodname&gt; member function
       yields the total number of indices in a given &domain;.  If and
       only if this number is zero, &lt;methodname&gt;empty&lt;/methodname&gt; will
       yield &true;.  A multidimensional
       &lt;type&gt;domain&lt;&dim;&gt;&lt;/type&gt; is the direct product of &dim;
!      one-dimensional &domain;s.
! 
! HERE&lt;/para&gt;
!    &lt;/section&gt;
     &lt;/section&gt;
  
  
--- 1044,1087 ----
  
       &lt;para&gt;&domain; member functions are listed in &lt;xref
       linkend=&quot;arrays-domains-use-table&quot;&gt;&lt;/xref&gt;.  Functions applicable
!      to both one-dimensional and multidimensional &domain;s are listed
       before functions that only applicable to one-dimensional
       &domain;s.  The &lt;methodname&gt;size&lt;/methodname&gt; member function
       yields the total number of indices in a given &domain;.  If and
       only if this number is zero, &lt;methodname&gt;empty&lt;/methodname&gt; will
       yield &true;.  A multidimensional
       &lt;type&gt;domain&lt;&dim;&gt;&lt;/type&gt; is the direct product of &dim;
!      one-dimensional &domain;s.  The &lt;methodname&gt;operator[](int
!      dimension)&lt;/methodname&gt; operator extracts the one-dimensional
!      &domain; corresponding to its parameter.  For example, the three
!      &lt;type&gt;Range&lt;1&gt;&lt;/type&gt; (one-dimensional) &domain;s can be
!      extracted from a &lt;type&gt;Range&lt;3&gt;&lt;/type&gt;
!      object&nbsp;&lt;varname&gt;r&lt;/varname&gt; using
!      &lt;statement&gt;r[0]&lt;/statement&gt;, &lt;statement&gt;r[1]&lt;/statement&gt;, and
!      &lt;statement&gt;r[2]&lt;/statement&gt;.&lt;/para&gt;
! 
!      &lt;para&gt;&domain; accessors applicable only to one-dimensional
!      &domain;s are listed in the second half of &lt;xref
!      linkend=&quot;arrays-domains-use-table&quot;&gt;&lt;/xref&gt;.  The
!      &lt;methodname&gt;length&lt;/methodname&gt; member function, analogous to the
!      multidimensional &lt;methodname&gt;size&lt;/methodname&gt; function, returns
!      the number of indices in the &domain;.  The
!      &lt;methodname&gt;first&lt;/methodname&gt; and &lt;methodname&gt;last&lt;/methodname&gt;
!      member functions return the domain's beginning and ending
!      indices.  The &lt;methodname&gt;begin&lt;/methodname&gt; and
!      &lt;methodname&gt;end&lt;/methodname&gt; member functions return input
!      iterators pointing to these respective locations.  They have type
!      &lt;type&gt;D&lt;1&gt;::iterator&lt;/type&gt;, where &lt;type&gt;D&lt;/type&gt;
!      abbreviates the &domain;'s type, e.g., &interval; or &grid;.
!      &lt;!-- FIXME: Do I need to explain input iterators and their use?
!      --&gt; The &lt;methodname&gt;min&lt;/methodname&gt; and
!      &lt;methodname&gt;max&lt;/methodname&gt; member functions return the minimum
!      and maximum indices in the &domain; object, respectively.  For
!      &locone; and &intervalone;, these are the same as
!      &lt;methodname&gt;first&lt;/methodname&gt; and &lt;methodname&gt;last&lt;/methodname&gt;,
!      but &rangeone; and &gridone; can have their largest index at the
!      beginning of their &domain;s.&lt;/para&gt;
!     &lt;/section&gt;
     &lt;/section&gt;
  
  
*************** std::cout &openopen; a.read(2,-2) &amp;openo
*** 1814,1820 ****
  
  
     &lt;section id=&quot;arrays-dynamic_arrays&quot;&gt;
!     &lt;title&gt;&dynamicarray;s: Dynamically Changing Domain Sizes&lt;/title&gt;
  
      &lt;para&gt;&array;s have fixed domains so the set of valid indices
      remains fixed after declaration.  The &dynamicarray; class
--- 1848,1854 ----
  
  
     &lt;section id=&quot;arrays-dynamic_arrays&quot;&gt;
!     &lt;title&gt;&dynamicarray;s&lt;/title&gt;
  
      &lt;para&gt;&array;s have fixed domains so the set of valid indices
      remains fixed after declaration.  The &dynamicarray; class
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.7
diff -c -p -r1.7 concepts.xml
*** concepts.xml	2002/01/22 15:48:49	1.7
--- concepts.xml	2002/01/24 04:56:32
***************
*** 1,3 ****
--- 1,4 ----
+ &lt;!-- FIXME: Index this file. --&gt;
  &lt;chapter id=&quot;concepts&quot;&gt;
   &lt;title&gt;Overview of &pooma; Concepts&lt;/title&gt;
  
***************
*** 13,22 ****
   separate categories:
   &lt;variablelist&gt;
    &lt;varlistentry&gt;
!     &lt;term&gt;container&lt;/term&gt;
      &lt;listitem&gt;
!      &lt;para&gt;data structure holding one or more values and usually addressed
!      by indices&lt;/para&gt;
      &lt;/listitem&gt;
     &lt;/varlistentry&gt;
     &lt;varlistentry&gt;
--- 14,23 ----
   separate categories:
   &lt;variablelist&gt;
    &lt;varlistentry&gt;
!     &lt;term&gt;containers&lt;/term&gt;
      &lt;listitem&gt;
!      &lt;para&gt;data structures holding one or more values and usually accessed
!      using indices&lt;/para&gt;
      &lt;/listitem&gt;
     &lt;/varlistentry&gt;
     &lt;varlistentry&gt;
***************
*** 34,41 ****
      &lt;/listitem&gt;
     &lt;/varlistentry&gt;
    &lt;/variablelist&gt;
!   See &lt;xref linkend=&quot;concepts-table&quot;&gt;&lt;/xref&gt;.  Many &pooma; programs
!   select one possibility from each column.  For example, &lt;xref
    linkend=&quot;tutorial-array_stencil-doof2d&quot;&gt;&lt;/xref&gt; used &array;
    containers and stencils for sequential computation, while &lt;xref
    linkend=&quot;tutorial-field_distributed-doof2d&quot;&gt;&lt;/xref&gt; used &field;
--- 35,43 ----
      &lt;/listitem&gt;
     &lt;/varlistentry&gt;
    &lt;/variablelist&gt;
!   &lt;xref linkend=&quot;concepts-table&quot;&gt;&lt;/xref&gt; categorizes the &pooma;
!   concepts.  Many &pooma; programs select one possibility from each
!   category.  For example, &lt;xref
    linkend=&quot;tutorial-array_stencil-doof2d&quot;&gt;&lt;/xref&gt; used &array;
    containers and stencils for sequential computation, while &lt;xref
    linkend=&quot;tutorial-field_distributed-doof2d&quot;&gt;&lt;/xref&gt; used &field;
***************
*** 103,115 ****
    &lt;para&gt;Most &pooma; programs use &lt;firstterm&gt;containers&lt;/firstterm&gt; to
    store groups of values.  &pooma; containers are objects that store
    other objects such as numbers or vectors.  They control allocation
!   and deallocation of and access to these stored objects.  They are a
!   generalization of &c; arrays, but &pooma; containers are first-class
!   objects so they can be used directly in expressions.  They are
!   similar to &cc; containers such as &lt;type&gt;vector&lt;/type&gt;,
!   &lt;type&gt;list&lt;/type&gt;, and &lt;type&gt;stack&lt;/type&gt;.  See &lt;xref
!   linkend=&quot;concepts-containers-table&quot;&gt;&lt;/xref&gt; for a summary of the
!   containers.&lt;/para&gt;
  
    &lt;para&gt;This section describes many concepts, but one need not
    understand them all to begin programming with the &poomatoolkit;.
--- 105,117 ----
    &lt;para&gt;Most &pooma; programs use &lt;firstterm&gt;containers&lt;/firstterm&gt; to
    store groups of values.  &pooma; containers are objects that store
    other objects such as numbers or vectors.  They control allocation
!   and deallocation of these stored objects and access to them.  They
!   are a generalization of &c; arrays, but &pooma; containers are
!   first-class objects so they can be used directly in expressions.
!   They are also similar to &cc; containers such as
!   &lt;type&gt;vector&lt;/type&gt;, &lt;type&gt;list&lt;/type&gt;, and &lt;type&gt;stack&lt;/type&gt;.  See
!   &lt;xref linkend=&quot;concepts-containers-table&quot;&gt;&lt;/xref&gt; for a summary of
!   the containers.&lt;/para&gt;
  
    &lt;para&gt;This section describes many concepts, but one need not
    understand them all to begin programming with the &poomatoolkit;.
***************
*** 126,131 ****
--- 128,137 ----
    multiple processors.  The programs in the previous chapter
    illustrate many of these concepts.&lt;/para&gt;
  
+   &lt;para&gt;&lt;xref linkend=&quot;concepts-containers-table&quot;&gt;&lt;/xref&gt; briefly
+   describes the six &pooma; containers.  They are more fully described
+   in the paragraphs below.&lt;/para&gt;
+ 
    &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-table&quot;&gt;
     &lt;title&gt;&pooma; Container Summary&lt;/title&gt;
***************
*** 201,210 ****
    to &array;s, each cell may contain multiple values and multiple
    materials.  A &field;'s &lt;glossterm
    linkend=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossterm&gt; stores its spatial
!   characteristics and can map yield, e.g., the cell at a particular
!   point, the distance between two cells, or a cell's normals.  A
!   &field; should be used whenever geometric or spatial computations
!   are needed, multiple values per index are desired, or a computation
    involves more than one material.&lt;/para&gt;
  
  &lt;!-- FIXME: Want firstterm around tensor. --&gt;
--- 207,216 ----
    to &array;s, each cell may contain multiple values and multiple
    materials.  A &field;'s &lt;glossterm
    linkend=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossterm&gt; stores its spatial
!   characteristics and can yield, e.g., the cell at a particular point,
!   the distance between two cells, or a cell's normals.  A &field;
!   should be used whenever geometric or spatial computations are
!   needed, multiple values per index are desired, or a computation
    involves more than one material.&lt;/para&gt;
  
  &lt;!-- FIXME: Want firstterm around tensor. --&gt;
***************
*** 230,254 ****
    multiplying a &matrix; and a &vector;.&lt;/para&gt;
  
    &lt;para&gt;The data of an &array;, &dynamicarray;, or &field; can be
!   viewed using more than one container by taking a view.  A &lt;glossterm
    linkend=&quot;glossary-view&quot;&gt;&lt;firstterm&gt;view&lt;/firstterm&gt;&lt;/glossterm&gt; of
    an existing container&nbsp;&container; is a container whose domain
!   is a subset of&nbsp;&container;.  The subset can equal the original
!   domain.  A view acts like a reference in that changing any of the
!   view's values also changes the original container's and vice versa.
!   While users sometimes explicitly create views, they are perhaps more
!   frequently created as temporaries in expressions.  For example, if
!   &lt;varname&gt;A&lt;/varname&gt; is an &array; and &lt;varname&gt;I&lt;/varname&gt; is a
!   domain, &lt;statement&gt;A(I) - A(I-1)&lt;/statement&gt; uses two views to form
!   the difference between adjacent values.&lt;/para&gt;
  
  
    &lt;section id=&quot;concepts-containers-choosing&quot;&gt;
     &lt;title&gt;Choosing a Container&lt;/title&gt;
  
     &lt;para&gt;The two most commonly used &pooma; containers are &array;s
!    and &field;s, while &vector;, &matrix;, or &tensor; frequently
!    represent mathematical objects.  &lt;xref
     linkend=&quot;concepts-containers-choice_table&quot;&gt;&lt;/xref&gt; contains a
     decision tree describing how to choose an appropriate
     container.&lt;/para&gt;
--- 236,262 ----
    multiplying a &matrix; and a &vector;.&lt;/para&gt;
  
    &lt;para&gt;The data of an &array;, &dynamicarray;, or &field; can be
!   accessed using more than one container by taking a view.  A
!   &lt;glossterm
    linkend=&quot;glossary-view&quot;&gt;&lt;firstterm&gt;view&lt;/firstterm&gt;&lt;/glossterm&gt; of
    an existing container&nbsp;&container; is a container whose domain
!   is a subset of&nbsp;&container;'s domain.  The subset can equal the
!   original domain.  A view acts like a reference in that changing any
!   of the view's values also changes the original container's and vice
!   versa.  While users sometimes explicitly create views, they are
!   perhaps more frequently created as temporaries in expressions.  For
!   example, if &lt;varname&gt;A&lt;/varname&gt; is an &array; and
!   &lt;varname&gt;I&lt;/varname&gt; is a domain, &lt;statement&gt;A(I) -
!   A(I-1)&lt;/statement&gt; uses two views to form the difference between
!   adjacent values.&lt;/para&gt;
  
  
    &lt;section id=&quot;concepts-containers-choosing&quot;&gt;
     &lt;title&gt;Choosing a Container&lt;/title&gt;
  
     &lt;para&gt;The two most commonly used &pooma; containers are &array;s
!    and &field;s, while &vector;, &matrix;, and &tensor; represent
!    mathematical objects.  &lt;xref
     linkend=&quot;concepts-containers-choice_table&quot;&gt;&lt;/xref&gt; contains a
     decision tree describing how to choose an appropriate
     container.&lt;/para&gt;
***************
*** 299,304 ****
--- 307,324 ----
     in declaring them.  Concepts specific to distributed computation
     are described in the next section.&lt;/para&gt;
  
+    &lt;para&gt;&lt;xref
+    linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
+    illustrates the containers and the concepts involved in their
+    declarations.  The containers are listed in the top row.  Lines
+    connect these containers to the components necessary for their
+    declarations.  For example, an &array; declaration requires an
+    engine and a layout.  These, in turn, can depend on other &pooma;
+    concepts.  Declarations necessary only for distributed, or
+    multiprocessor, computation are also indicated.  Given a desired
+    container, one can use this figure to determine the concepts needed
+    to declare a particular container.&lt;/para&gt;
+ 
     &lt;figure float=&quot;1&quot; id=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;
      &lt;title&gt;Concepts For Declaring Containers&lt;/title&gt;
      &lt;mediaobject&gt;
***************
*** 311,328 ****
      &lt;/mediaobject&gt;
     &lt;/figure&gt;
  
-    &lt;para&gt;&lt;xref
-    linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
-    illustrates the containers and the concepts involved in their
-    declarations.  The containers are listed in the top row.  Lines
-    connect these containers to the components necessary for their
-    declarations.  For example, an &array; declaration requires an
-    &engine; and a layout.  These, in turn, can depend on other &pooma;
-    concepts.  Declarations necessary only for distributed, or
-    multiprocessor, computation are surrounded by dashed lines.  These
-    dependences to indicate the concepts needed for a particular
-    container.&lt;/para&gt;
- 
     &lt;para&gt;An &lt;glossterm
     linkend=&quot;glossary-engine&quot;&gt;&lt;firstterm&gt;engine&lt;/firstterm&gt;&lt;/glossterm&gt;
     stores and, if necessary, computes a container's values.  A
--- 331,336 ----
***************
*** 332,338 ****
     for all indices can use a constant engine, which need only store
     one value for the entire domain.  A &compressiblebrick; &engine;
     reduces its space requirements to a constant whenever all its
!    values are the same.  The separation also permits taking &lt;link
     linkend=&quot;glossary-view&quot;&gt;view&lt;/link&gt;s of containers without copying
     storage.&lt;/para&gt;
  
--- 340,347 ----
     for all indices can use a constant engine, which need only store
     one value for the entire domain.  A &compressiblebrick; &engine;
     reduces its space requirements to a constant whenever all its
!    values are the same.  The separation between a container and its
!    engine also permits taking &lt;link
     linkend=&quot;glossary-view&quot;&gt;view&lt;/link&gt;s of containers without copying
     storage.&lt;/para&gt;
  
***************
*** 350,360 ****
  
     &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-layout&quot;&gt;&lt;firstterm&gt;layout&lt;/firstterm&gt;&lt;/glossterm&gt;
!    maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; &lt;glossterm linkend=&quot;glossary-index&quot;&gt;indices&lt;/glossterm&gt; to the
!    processors and computer memory used by a container's engines.  See
!    &lt;xref
     linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
!    A program computes a container's values using a processor and
     memory.  The layout specifies the processors and memory to use for
     each particular index.  A container's layout for a uniprocessor
     implementation consists of its domain, the processor, and its
--- 359,369 ----
  
     &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-layout&quot;&gt;&lt;firstterm&gt;layout&lt;/firstterm&gt;&lt;/glossterm&gt;
!    maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; &lt;glossterm
!    linkend=&quot;glossary-index&quot;&gt;indices&lt;/glossterm&gt; to the processors and
!    computer memory used by a container's engines.  See &lt;xref
     linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
!    A program computes a container's values using these processors and
     memory.  The layout specifies the processors and memory to use for
     each particular index.  A container's layout for a uniprocessor
     implementation consists of its domain, the processor, and its
***************
*** 378,388 ****
     interval [0,n).  A domain need not contain all integral points
     between its endpoints.  A &lt;glossterm
     linkend=&quot;glossary-stride&quot;&gt;&lt;firstterm&gt;stride&lt;/firstterm&gt;&lt;/glossterm&gt;
!    is a subset of an interval consisting of regularly-spaced points.
!    A &lt;glossterm
     linkend=&quot;glossary-range&quot;&gt;&lt;firstterm&gt;range&lt;/firstterm&gt;&lt;/glossterm&gt;
     is a subset of an interval of regularly-spaced points specified by
!    strides.&lt;/para&gt;
  
     &lt;para&gt;A &field;'s &lt;glossterm
     linkend=&quot;glossary-mesh&quot;&gt;&lt;firstterm&gt;mesh&lt;/firstterm&gt;&lt;/glossterm&gt;
--- 387,396 ----
     interval [0,n).  A domain need not contain all integral points
     between its endpoints.  A &lt;glossterm
     linkend=&quot;glossary-stride&quot;&gt;&lt;firstterm&gt;stride&lt;/firstterm&gt;&lt;/glossterm&gt;
!    indicates a regular spacing between points.  A &lt;glossterm
     linkend=&quot;glossary-range&quot;&gt;&lt;firstterm&gt;range&lt;/firstterm&gt;&lt;/glossterm&gt;
     is a subset of an interval of regularly-spaced points specified by
!    a stride.&lt;/para&gt;
  
     &lt;para&gt;A &field;'s &lt;glossterm
     linkend=&quot;glossary-mesh&quot;&gt;&lt;firstterm&gt;mesh&lt;/firstterm&gt;&lt;/glossterm&gt;
***************
*** 399,422 ****
     linkend=&quot;glossary-point&quot;&gt;point&lt;/link&gt; in &space; corresponding to
     the cell in the lower, left corner of its &lt;link
     linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt;.  Combining this, the
!    domain, and the cell size fully specifies the mesh's map from
!    indices to &space;.&lt;/para&gt;
  
     &lt;para&gt;A mesh's &lt;glossterm
     linkend=&quot;glossary-cell_size&quot;&gt;&lt;firstterm&gt;cell
!    size&lt;/firstterm&gt;&lt;/glossterm&gt; specifies the spatial dimensions of
!    a &field; &lt;link linkend=&quot;glossary-cell&quot;&gt;cell&lt;/link&gt;, e.g., its
!    width, height, and depth, in&nbsp;&space;.  Combining this, the
!    domain, and the corner position fully specifies the mesh's map
!    from indices to &space;.&lt;/para&gt;
    &lt;/section&gt;
  
  
    &lt;section id=&quot;concepts-containers-distributed_declarations&quot;&gt;
     &lt;title&gt;Declaring Distributed Containers&lt;/title&gt;
  
!    &lt;para&gt;In the previous section, we introduced the concepts important
!    when declaring containers for use on uniprocessor computers.  When
     using multiprocessor computers, we augment these concepts with
     those for distributed computation.  Reading this section is
     important only for running a program on multiple processors.  Many
--- 407,430 ----
     linkend=&quot;glossary-point&quot;&gt;point&lt;/link&gt; in &space; corresponding to
     the cell in the lower, left corner of its &lt;link
     linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt;.  Combining this, the
!    domain, and the cell size can specify the mesh's map from indices
!    to &space;.&lt;/para&gt;
  
     &lt;para&gt;A mesh's &lt;glossterm
     linkend=&quot;glossary-cell_size&quot;&gt;&lt;firstterm&gt;cell
!    size&lt;/firstterm&gt;&lt;/glossterm&gt; specifies the spatial dimensions of a
!    &field; &lt;link linkend=&quot;glossary-cell&quot;&gt;cell&lt;/link&gt;, e.g., its width,
!    height, and depth, in&nbsp;&space;.  Combining this, the domain,
!    and the corner position can specify the mesh's map from indices to
!    &space;.&lt;/para&gt;
    &lt;/section&gt;
  
  
    &lt;section id=&quot;concepts-containers-distributed_declarations&quot;&gt;
     &lt;title&gt;Declaring Distributed Containers&lt;/title&gt;
  
!    &lt;para&gt;In the previous section, we introduced the important concepts
!    for declaring containers for use on uniprocessor computers.  When
     using multiprocessor computers, we augment these concepts with
     those for distributed computation.  Reading this section is
     important only for running a program on multiple processors.  Many
***************
*** 457,463 ****
     linkend=&quot;glossary-external_guard_layer&quot;&gt;&lt;firstterm&gt;external guard
     layer&lt;/firstterm&gt;&lt;/glossterm&gt; specifies values surrounding the
     entire domain.  Its presence eases computation along the domain's
!    edges by permitting the same computations as for more internal
     computations.  An &lt;glossterm
     linkend=&quot;glossary-internal_guard_layer&quot;&gt;&lt;firstterm&gt;internal guard
     layer&lt;/firstterm&gt;&lt;/glossterm&gt; duplicates values from adjacent
--- 465,471 ----
     linkend=&quot;glossary-external_guard_layer&quot;&gt;&lt;firstterm&gt;external guard
     layer&lt;/firstterm&gt;&lt;/glossterm&gt; specifies values surrounding the
     entire domain.  Its presence eases computation along the domain's
!    edges by permitting the same computations as for more-internal
     computations.  An &lt;glossterm
     linkend=&quot;glossary-internal_guard_layer&quot;&gt;&lt;firstterm&gt;internal guard
     layer&lt;/firstterm&gt;&lt;/glossterm&gt; duplicates values from adjacent
***************
*** 488,503 ****
  
    &lt;para&gt;&pooma; computations can be expressed using a variety of
    modes.  Many &pooma; computations involve &array; or &field;
!   containers, but how their values are accessed and the associated
!   algorithms using them varies.  For example, element-wise computation
    involves explicitly accessing a container's values.  A data-parallel
!   computation uses expressions to represent larger subsets of a
!   container's values.  Stencil-based computations express a
!   computation as repeatedly applying a local computation to each
!   element of an array.  A relation among containers establishes a
!   dependency among them so the values of one container are updated
!   whenever any other's values change.  A program may use any or all of
!   these styles, which are described below.&lt;/para&gt;
  
    &lt;para&gt;&lt;glossterm
    linkend=&quot;glossary-element_wise&quot;&gt;&lt;firstterm&gt;Element-wise&lt;/firstterm&gt;&lt;/glossterm&gt;
--- 496,511 ----
  
    &lt;para&gt;&pooma; computations can be expressed using a variety of
    modes.  Many &pooma; computations involve &array; or &field;
!   containers, but how their values are accessed and how the associated
!   algorithms use them varies.  For example, element-wise computation
    involves explicitly accessing a container's values.  A data-parallel
!   computation operates on larger subsets of a container's values.
!   Stencil-based computations express a computation as repeatedly
!   applying a local computation to each element of an array.  A
!   relation among containers establishes a dependency among them so the
!   values of one container are updated whenever any other's values
!   change.  A program may use any or all of these styles, which are
!   described below.&lt;/para&gt;
  
    &lt;para&gt;&lt;glossterm
    linkend=&quot;glossary-element_wise&quot;&gt;&lt;firstterm&gt;Element-wise&lt;/firstterm&gt;&lt;/glossterm&gt;
***************
*** 515,524 ****
    linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;,
    &lt;statement&gt;a(I,J)&lt;/statement&gt; represents the subset of &array;
    &lt;varname&gt;a&lt;/varname&gt;'s values having coordinates in the domain
!   specified by the one-dimensional &interval;s &lt;varname&gt;I&lt;/varname&gt;
!   and &lt;varname&gt;J&lt;/varname&gt;.  Using data-parallel expressions
!   frequently eliminates the need for writing explicit loops in
!   code.&lt;/para&gt;
  
    &lt;para&gt;A &lt;glossterm
    linkend=&quot;glossary-stencil&quot;&gt;&lt;firstterm&gt;stencil&lt;/firstterm&gt;&lt;/glossterm&gt;
--- 523,532 ----
    linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;,
    &lt;statement&gt;a(I,J)&lt;/statement&gt; represents the subset of &array;
    &lt;varname&gt;a&lt;/varname&gt;'s values having coordinates in the domain
!   specified by the direct product of one-dimensional &interval;s
!   &lt;varname&gt;I&lt;/varname&gt; and&nbsp;&lt;varname&gt;J&lt;/varname&gt;.  Using
!   data-parallel expressions frequently eliminates the need for writing
!   explicit loops.&lt;/para&gt;
  
    &lt;para&gt;A &lt;glossterm
    linkend=&quot;glossary-stencil&quot;&gt;&lt;firstterm&gt;stencil&lt;/firstterm&gt;&lt;/glossterm&gt;
***************
*** 550,557 ****
   &lt;section id=&quot;concepts-computation_environment&quot;&gt;
    &lt;title&gt;Computation Environment&lt;/title&gt;
  
!   &lt;para&gt;A &pooma; program can execute on a wide variety of computers.
!    The default &lt;glossterm
     linkend=&quot;glossary-sequential&quot;&gt;&lt;firstterm&gt;sequential computing
     environment&lt;/firstterm&gt;&lt;/glossterm&gt; consists of one processor and
     its associated memory, as found on a personal computer.  In
--- 558,565 ----
   &lt;section id=&quot;concepts-computation_environment&quot;&gt;
    &lt;title&gt;Computation Environment&lt;/title&gt;
  
!   &lt;para&gt;The same &pooma; program can execute on a wide variety of
!    computers.  The default &lt;glossterm
     linkend=&quot;glossary-sequential&quot;&gt;&lt;firstterm&gt;sequential computing
     environment&lt;/firstterm&gt;&lt;/glossterm&gt; consists of one processor and
     its associated memory, as found on a personal computer.  In
***************
*** 574,580 ****
        library.&lt;/para&gt;
       &lt;/listitem&gt;
       &lt;listitem&gt;
!       &lt;para&gt;The &pooma; executable must be run using the library.&lt;/para&gt;
      &lt;/listitem&gt;
     &lt;/orderedlist&gt;
     All of these were illustrated in &lt;xref
--- 582,589 ----
        library.&lt;/para&gt;
       &lt;/listitem&gt;
       &lt;listitem&gt;
!       &lt;para&gt;The &pooma; executable must be run using the
!       communications library.&lt;/para&gt;
      &lt;/listitem&gt;
     &lt;/orderedlist&gt;
     All of these were illustrated in &lt;xref
***************
*** 611,619 ****
     contexts, all of which is hidden from both the programmer and the
     user.  &pooma; works with the Message Passing Interface (&mpi;)
     Communications Library 
! &lt;!-- FIXME: xref linkend=&quot;mpi99&quot; --&gt;
!    (&lt;ulink url=&quot;<A HREF="http://www-unix.mcs.anl.gov/mpi/">http://www-unix.mcs.anl.gov/mpi/</A>&quot;&gt;&lt;/ulink&gt;) and the &mm;
!    Shared Memory Library.  See &lt;xref
!    linkend=&quot;installation-distributed_computing&quot;&gt;&lt;/xref&gt; for details.&lt;/para&gt;
    &lt;/section&gt;
  &lt;/chapter&gt;
--- 620,628 ----
     contexts, all of which is hidden from both the programmer and the
     user.  &pooma; works with the Message Passing Interface (&mpi;)
     Communications Library 
! &lt;!-- FIXME: xref linkend=&quot;mpi99&quot; (&lt;ulink url=&quot;<A HREF="http://www-unix.mcs.anl.gov/mpi/">http://www-unix.mcs.anl.gov/mpi/</A>&quot;&gt;&lt;/ulink&gt;) --&gt;
!    and the &mm; Shared Memory Library.  See &lt;xref
!    linkend=&quot;installation-distributed_computing&quot;&gt;&lt;/xref&gt; for
!    details.&lt;/para&gt;
    &lt;/section&gt;
  &lt;/chapter&gt;
Index: data-parallel.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/data-parallel.xml,v
retrieving revision 1.1
diff -c -p -r1.1 data-parallel.xml
*** data-parallel.xml	2002/01/14 17:33:33	1.1
--- data-parallel.xml	2002/01/24 04:56:34
***************
*** 14,20 ****
  
     &lt;para&gt;After introducing data-parallel expressions and statements,
     we present the corresponding &pooma; syntax.  Then we present its
!    implementation, which uses expression-template technology.  A naive
     data-parallel implementation might generate temporary variables,
     cluttering a program's inner loops and slowing its execution.
     Instead, &pooma; uses &amp;pete, the Portable Expression Template
--- 14,20 ----
  
     &lt;para&gt;After introducing data-parallel expressions and statements,
     we present the corresponding &pooma; syntax.  Then we present its
!    implementation, which uses expression-template technology.  A &naive;
     data-parallel implementation might generate temporary variables,
     cluttering a program's inner loops and slowing its execution.
     Instead, &pooma; uses &amp;pete, the Portable Expression Template
***************
*** 51,57 ****
      height&nbsp;h and to an entire field of particles with
      masses&nbsp;m and heights&nbsp;h.  Our algorithm works with
      data-parallel syntax, and we would like to write the corresponding
!     computer program using data-parallel syntax as well..&lt;/para&gt;
     &lt;/section&gt;
  
  
--- 51,57 ----
      height&nbsp;h and to an entire field of particles with
      masses&nbsp;m and heights&nbsp;h.  Our algorithm works with
      data-parallel syntax, and we would like to write the corresponding
!     computer program using data-parallel syntax as well.&lt;/para&gt;
     &lt;/section&gt;
  
  
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 881,887 ****
  
      &lt;para&gt;Data-parallel statements involving containers occur
      frequently in the inner loops of scientific programs so their
!     efficient execution is important.  A naive implementation for
      these statements may create and destroy containers holding
      intermediate values, slowing execution considerably.
      In&nbsp;1995, Todd &lt;!-- FIXME: Add citations to vandevoorde-95 and
--- 881,887 ----
  
      &lt;para&gt;Data-parallel statements involving containers occur
      frequently in the inner loops of scientific programs so their
!     efficient execution is important.  A &naive; implementation for
      these statements may create and destroy containers holding
      intermediate values, slowing execution considerably.
      In&nbsp;1995, Todd &lt;!-- FIXME: Add citations to vandevoorde-95 and
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 894,900 ****
      framework, is also available separately from &pooma; at
      &lt;ulink url=&quot;<A HREF="http://www.acl.lanl.gov/pete/">http://www.acl.lanl.gov/pete/</A>&quot;&gt;&lt;/ulink&gt;.&lt;/para&gt;
  
!     &lt;para&gt;In this section, we first describe how a naive
      implementation may slow execution.  Then, we describe &pete;'s
      faster implementation.  A data-parallel statement is converted
      into a parse tree, rather than immediately evaluating it.  The
--- 894,900 ----
      framework, is also available separately from &pooma; at
      &lt;ulink url=&quot;<A HREF="http://www.acl.lanl.gov/pete/">http://www.acl.lanl.gov/pete/</A>&quot;&gt;&lt;/ulink&gt;.&lt;/para&gt;
  
!     &lt;para&gt;In this section, we first describe how a &naive;
      implementation may slow execution.  Then, we describe &pete;'s
      faster implementation.  A data-parallel statement is converted
      into a parse tree, rather than immediately evaluating it.  The
*************** std::cout &lt;&lt; A-B &lt;&lt; std::endl;
*** 909,918 ****
      types are traversed and code is produced without the need for any
      intermediate values.  We present the implementation in &lt;xref
  								 linkend=&quot;data_parallel-implementation-pete&quot;&gt;&lt;/xref&gt;, but first we
!     explain the difficulties caused by the naive implementation.&lt;/para&gt;
  
      &lt;section id=&quot;data_parallel-implementation-naive&quot;&gt;
!      &lt;title&gt;Naive Implementation&lt;/title&gt;
  
       &lt;para&gt;A conventional implementation to evaluate data-parallel
       expressions might overload arithmetic operator functions.
--- 909,918 ----
      types are traversed and code is produced without the need for any
      intermediate values.  We present the implementation in &lt;xref
  								 linkend=&quot;data_parallel-implementation-pete&quot;&gt;&lt;/xref&gt;, but first we
!     explain the difficulties caused by the &naive; implementation.&lt;/para&gt;
  
      &lt;section id=&quot;data_parallel-implementation-naive&quot;&gt;
!      &lt;title&gt;&naivecap; Implementation&lt;/title&gt;
  
       &lt;para&gt;A conventional implementation to evaluate data-parallel
       expressions might overload arithmetic operator functions.
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.7
diff -c -p -r1.7 glossary.xml
*** glossary.xml	2002/01/22 15:48:49	1.7
--- glossary.xml	2002/01/24 04:56:35
***************
*** 99,105 ****
    &lt;glossentry id=&quot;glossary-compile_time&quot;&gt;
     &lt;glossterm&gt;compile time&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;time in the process from writing a program to executing it
      when the program is compiled by a compiler.  This is also called
      &lt;firstterm&gt;compilation time&lt;/firstterm&gt;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-programming_time&quot;&gt;programming time&lt;/glossseealso&gt;
--- 99,113 ----
    &lt;glossentry id=&quot;glossary-compile_time&quot;&gt;
     &lt;glossterm&gt;compile time&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!     &lt;indexterm zone=&quot;glossary-compile_time&quot;&gt;
!      &lt;primary&gt;compile time&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;compilation time&lt;/primary&gt;
!      &lt;see&gt;compile time.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     in the process from writing a program to executing it, the time
      when the program is compiled by a compiler.  This is also called
      &lt;firstterm&gt;compilation time&lt;/firstterm&gt;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-programming_time&quot;&gt;programming time&lt;/glossseealso&gt;
***************
*** 306,316 ****
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
- &lt;!-- HERE --&gt;
    &lt;glossentry id=&quot;glossary-enumeration&quot;&gt;
     &lt;glossterm&gt;enumeration&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;distinct &cc; integral type with named constants.  These are
      frequently used in template programming because they can be used
      as template arguments.&lt;/para&gt;
     &lt;/glossdef&gt;
--- 314,327 ----
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
    &lt;glossentry id=&quot;glossary-enumeration&quot;&gt;
     &lt;glossterm&gt;enumeration&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!     &lt;indexterm zone=&quot;glossary-enumeration&quot;&gt;
!      &lt;primary&gt;enumeration&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     &cc; integral type with named constants.  These are
      frequently used in template programming because they can be used
      as template arguments.&lt;/para&gt;
     &lt;/glossdef&gt;
***************
*** 324,330 ****
    &lt;glossentry id=&quot;glossary-external_guard_layer&quot;&gt;
     &lt;glossterm&gt;external guard layer&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;&lt;link linkend=&quot;glossary-guard_layer&quot;&gt;guard layer&lt;/link&gt;
      surrounding a container's domain used to ease computation along
      the domain's edges by permitting the same computations as for
      more internal computations.  It is an optimization, not required
--- 335,350 ----
    &lt;glossentry id=&quot;glossary-external_guard_layer&quot;&gt;
     &lt;glossterm&gt;external guard layer&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!      &lt;indexterm zone=&quot;glossary-external_guard_layer&quot;&gt;
!       &lt;primary&gt;guard layer&lt;/primary&gt;
!       &lt;secondary&gt;external&lt;/secondary&gt;
!      &lt;/indexterm&gt;
!      &lt;indexterm&gt;
!       &lt;primary&gt;external guard layer&lt;/primary&gt;
!       &lt;see&gt;guard layer, external.&lt;/see&gt; 
!      &lt;/indexterm&gt;
!     &lt;link linkend=&quot;glossary-guard_layer&quot;&gt;guard layer&lt;/link&gt;
      surrounding a container's domain used to ease computation along
      the domain's edges by permitting the same computations as for
      more internal computations.  It is an optimization, not required
***************
*** 382,394 ****
    &lt;glossentry id=&quot;glossary-function_template&quot;&gt;
     &lt;glossterm&gt;function template&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a definition of an unbounded set of related functions, all
!     having the same name but whose parameter types can depend on
!     template parameters.  They are particularly useful when
!     overloading &lt;glossterm
!     linkend=&quot;glossary-operator_function&quot;&gt;operator
!     functions&lt;/glossterm&gt; to accept parameters that themselves depend
!     on templates.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
--- 402,434 ----
    &lt;glossentry id=&quot;glossary-function_template&quot;&gt;
     &lt;glossterm&gt;function template&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!     &lt;indexterm zone=&quot;glossary-function_template&quot;&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;template&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     a definition of an unbounded set of related functions, all having
!     the same name but whose types can depend on template parameters.
!     They are particularly useful when overloading
!     &lt;indexterm&gt;
!      &lt;primary&gt;overloaded function&lt;/primary&gt;
!      &lt;see&gt;function, overloaded.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;overloaded&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;glossterm linkend=&quot;glossary-operator_function&quot;&gt;operator
!     functions&lt;/glossterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;operator function&lt;/primary&gt;
!      &lt;see&gt;function, operator.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;operator&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     to accept parameters that themselves depend on templates.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
***************
*** 399,417 ****
    &lt;glossentry id=&quot;glossary-guard_layer&quot;&gt;
     &lt;glossterm&gt;guard layer&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;domain surrounding each patch of a container's domain.  It
      contains read-only values.  &lt;link
      linkend=&quot;glossary-external_guard_layer&quot;&gt;External guard
      layer&lt;/link&gt;s ease programming, while &lt;link
      linkend=&quot;glossary-internal_guard_layer&quot;&gt;internal guard
      layer&lt;/link&gt;s permit each patch's computation to be occur without
      copying values from adjacent patches.  They are optimizations, not
!     required for program correctness.&lt;/para&gt; &lt;glossseealso
!     otherterm=&quot;glossary-external_guard_layer&quot;&gt;external guard
!     layer&lt;/glossseealso&gt; &lt;glossseealso
!     otherterm=&quot;glossary-internal_guard_layer&quot;&gt;internal guard
!     layer&lt;/glossseealso&gt; &lt;glossseealso
!     otherterm=&quot;glossary-partition&quot;&gt;partition&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-patch&quot;&gt;patch&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
--- 439,460 ----
    &lt;glossentry id=&quot;glossary-guard_layer&quot;&gt;
     &lt;glossterm&gt;guard layer&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!      &lt;indexterm zone=&quot;glossary-guard_layer&quot;&gt;
!       &lt;primary&gt;guard layer&lt;/primary&gt;
!      &lt;/indexterm&gt;
!     domain surrounding each patch of a container's domain.  It
      contains read-only values.  &lt;link
      linkend=&quot;glossary-external_guard_layer&quot;&gt;External guard
      layer&lt;/link&gt;s ease programming, while &lt;link
      linkend=&quot;glossary-internal_guard_layer&quot;&gt;internal guard
      layer&lt;/link&gt;s permit each patch's computation to be occur without
      copying values from adjacent patches.  They are optimizations, not
!     required for program correctness.&lt;/para&gt;
!     &lt;glossseealso otherterm=&quot;glossary-external_guard_layer&quot;&gt;external guard layer&lt;/glossseealso&gt;
!     &lt;glossseealso otherterm=&quot;glossary-internal_guard_layer&quot;&gt;internal
! guard layer&lt;/glossseealso&gt;
!     &lt;glossseealso otherterm=&quot;glossary-partition&quot;&gt;partition&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-patch&quot;&gt;patch&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
***************
*** 448,454 ****
    &lt;glossentry id=&quot;glossary-internal_guard_layer&quot;&gt;
     &lt;glossterm&gt;internal guard layer&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;&lt;link linkend=&quot;glossary-guard_layer&quot;&gt;guard layer&lt;/link&gt;
      containing copies of adjacent patches' values.  These copies can
      permit an individual patch's computation to occur without asking
      adjacent patches for values.  This can speed computation but are
--- 491,506 ----
    &lt;glossentry id=&quot;glossary-internal_guard_layer&quot;&gt;
     &lt;glossterm&gt;internal guard layer&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!      &lt;indexterm zone=&quot;glossary-internal_guard_layer&quot;&gt;
!       &lt;primary&gt;guard layer&lt;/primary&gt;
!       &lt;secondary&gt;internal&lt;/secondary&gt;
!      &lt;/indexterm&gt;
!      &lt;indexterm&gt;
!       &lt;primary&gt;internal guard layer&lt;/primary&gt;
!       &lt;see&gt;guard layer, internal.&lt;/see&gt; 
!      &lt;/indexterm&gt;
!     &lt;link linkend=&quot;glossary-guard_layer&quot;&gt;guard layer&lt;/link&gt;
      containing copies of adjacent patches' values.  These copies can
      permit an individual patch's computation to occur without asking
      adjacent patches for values.  This can speed computation but are
***************
*** 498,503 ****
--- 550,560 ----
   &lt;glossdiv id=&quot;glossary-m&quot;&gt;
    &lt;title&gt;M&lt;/title&gt;
  
+   &lt;glossentry id=&quot;glossary-real_matrix&quot;&gt;
+    &lt;glossterm&gt;matrix&lt;/glossterm&gt;
+    &lt;glosssee otherterm=&quot;glossary-matrix&quot;&gt;&lt;/glosssee&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-mesh&quot;&gt;
     &lt;glossterm&gt;mesh&lt;/glossterm&gt;
     &lt;glossdef&gt;
***************
*** 516,524 ****
    &lt;glossentry id=&quot;glossary-operator_function&quot;&gt;
     &lt;glossterm&gt;operator function&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;function defining an operator's code.  For example,
!     &lt;function&gt;operator+&lt;/function&gt; defines the result of using the
!     &lt;operator&gt;+&lt;/operator&gt;.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
--- 573,586 ----
    &lt;glossentry id=&quot;glossary-operator_function&quot;&gt;
     &lt;glossterm&gt;operator function&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!      &lt;indexterm zone=&quot;glossary-operator_function&quot;&gt;
!       &lt;primary&gt;function&lt;/primary&gt;
!       &lt;secondary&gt;operator&lt;/secondary&gt;
!      &lt;/indexterm&gt;
!     function defining a function invoked using a &cc; operator.  For
!     example, the &lt;function&gt;operator+&lt;/function&gt; function defines the
!     result of using the &lt;operator&gt;+&lt;/operator&gt;.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
***************
*** 545,551 ****
    &lt;glossentry id=&quot;glossary-patch&quot;&gt;
     &lt;glossterm&gt;patch&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;subset of a container's domain with values computed by a
      particular context.  A partition splits a domain into patches.  It
      may be surrounded by external and internal guard layers.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-partition&quot;&gt;partition&lt;/glossseealso&gt;
--- 607,617 ----
    &lt;glossentry id=&quot;glossary-patch&quot;&gt;
     &lt;glossterm&gt;patch&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!      &lt;indexterm zone=&quot;glossary-patch&quot;&gt;
!       &lt;primary&gt;patch&lt;/primary&gt;
!      &lt;/indexterm&gt;
!     subset of a container's domain with values computed by a
      particular context.  A partition splits a domain into patches.  It
      may be surrounded by external and internal guard layers.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-partition&quot;&gt;partition&lt;/glossseealso&gt;
***************
*** 568,574 ****
    &lt;glossentry id=&quot;glossary-programming_time&quot;&gt;
     &lt;glossterm&gt;programming time&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;time in the process from writing a program to executing it
      when the program is being written by a programmer.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-compile_time&quot;&gt;compile time&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-run_time&quot;&gt;run time&lt;/glossseealso&gt;
--- 634,644 ----
    &lt;glossentry id=&quot;glossary-programming_time&quot;&gt;
     &lt;glossterm&gt;programming time&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!     &lt;indexterm zone=&quot;glossary-programming_time&quot;&gt;
!      &lt;primary&gt;programming time&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     in the process from writing a program to executing it, the time
      when the program is being written by a programmer.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-compile_time&quot;&gt;compile time&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-run_time&quot;&gt;run time&lt;/glossseealso&gt;
***************
*** 613,619 ****
    &lt;glossentry id=&quot;glossary-run_time&quot;&gt;
     &lt;glossterm&gt;run time&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;time in the process from writing a program to executing it
      when the program is executed.  This is also called
      &lt;firstterm&gt;execution time&lt;/firstterm&gt;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-compile_time&quot;&gt;compile time&lt;/glossseealso&gt;
--- 683,697 ----
    &lt;glossentry id=&quot;glossary-run_time&quot;&gt;
     &lt;glossterm&gt;run time&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!     &lt;indexterm zone=&quot;glossary-run_time&quot;&gt;
!      &lt;primary&gt;run time&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;execution time&lt;/primary&gt;
!      &lt;see&gt;run time.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     in the process from writing a program to executing it, the time
      when the program is executed.  This is also called
      &lt;firstterm&gt;execution time&lt;/firstterm&gt;.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-compile_time&quot;&gt;compile time&lt;/glossseealso&gt;
***************
*** 654,665 ****
    &lt;glossentry id=&quot;glossary-stride&quot;&gt;
     &lt;glossterm&gt;stride&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a subset of regularly-spaced points in an integral
!     interval.  For example, the set of points a, a+2, a+4, &hellip;,
!     b-2, b is specified by [a,b] with stride&nbsp;2.  It is a
!     domain.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-range&quot;&gt;range&lt;/glossseealso&gt;
!     &lt;glossseealso otherterm=&quot;glossary-interval&quot;&gt;interval&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
--- 732,743 ----
    &lt;glossentry id=&quot;glossary-stride&quot;&gt;
     &lt;glossterm&gt;stride&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;spacing between regularly-spaced points in a domain.  For
!     example, the set of points a, a+2, a+4, &hellip;, b-2, b is
!     specified by [a,b] with stride&nbsp;2.  It is a domain.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-range&quot;&gt;range&lt;/glossseealso&gt;
!     &lt;glossseealso
!     otherterm=&quot;glossary-interval&quot;&gt;interval&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
***************
*** 681,690 ****
   &lt;glossdiv id=&quot;glossary-t&quot;&gt;
    &lt;title&gt;T&lt;/title&gt;
  
    &lt;glossentry id=&quot;glossary-template_instantiation&quot;&gt;
     &lt;glossterm&gt;template instantiation&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;applying a template class to template parameters to create a
      type.  For example, &lt;statement&gt;foo&lt;double,3&gt;&lt;/statement&gt;
      instantiates &lt;statement&gt;template &lt;typename T, int n&gt; class
      foo&lt;/statement&gt; with the type &double; and the constant
--- 759,788 ----
   &lt;glossdiv id=&quot;glossary-t&quot;&gt;
    &lt;title&gt;T&lt;/title&gt;
  
+   &lt;glossentry id=&quot;glossary-template&quot;&gt;
+    &lt;glossterm&gt;template&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;
+     &lt;indexterm zone=&quot;glossary-template&quot;&gt;
+      &lt;primary&gt;template&lt;/primary&gt;
+     &lt;/indexterm&gt;
+     class or function definition having template parameters.
+     These parameters' values are used at compile time, not run time,
+     so they may include types and other compile-time values.
+     &lt;!-- FIXME: Strengthen this definition. --&gt;&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-template_instantiation&quot;&gt;template instantiation&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-template_specialization&quot;&gt;template specialization&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-template_instantiation&quot;&gt;
     &lt;glossterm&gt;template instantiation&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!     &lt;indexterm zone=&quot;glossary-template_instantiation&quot;&gt;
!      &lt;primary&gt;template instantiation&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     applying a template class to template parameter arguments to create a
      type.  For example, &lt;statement&gt;foo&lt;double,3&gt;&lt;/statement&gt;
      instantiates &lt;statement&gt;template &lt;typename T, int n&gt; class
      foo&lt;/statement&gt; with the type &double; and the constant
***************
*** 696,702 ****
    &lt;glossentry id=&quot;glossary-template_specialization&quot;&gt;
     &lt;glossterm&gt;template specialization&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;class or function definition for a particular (special)
      subset of template arguments.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
--- 794,804 ----
    &lt;glossentry id=&quot;glossary-template_specialization&quot;&gt;
     &lt;glossterm&gt;template specialization&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!     &lt;indexterm zone=&quot;glossary-template_specialization&quot;&gt;
!      &lt;primary&gt;template specialization&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     class or function definition for a particular (special)
      subset of template arguments.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
***************
*** 724,730 ****
    &lt;glossentry id=&quot;glossary-trait&quot;&gt;
     &lt;glossterm&gt;trait&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a characteristic of a type.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-traits_class&quot;&gt;traits class&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
--- 826,836 ----
    &lt;glossentry id=&quot;glossary-trait&quot;&gt;
     &lt;glossterm&gt;trait&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!     &lt;indexterm zone=&quot;glossary-trait&quot;&gt;
!      &lt;primary&gt;trait&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     a characteristic of a type.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-traits_class&quot;&gt;traits class&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
***************
*** 732,739 ****
    &lt;glossentry id=&quot;glossary-traits_class&quot;&gt;
     &lt;glossterm&gt;traits class&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a class containing one or more traits all describing a
!     particular type's chacteristics.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-trait&quot;&gt;trait&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
--- 838,849 ----
    &lt;glossentry id=&quot;glossary-traits_class&quot;&gt;
     &lt;glossterm&gt;traits class&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
!     &lt;indexterm zone=&quot;glossary-traits_class&quot;&gt;
!      &lt;primary&gt;traits class&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     a class containing one or more traits all describing a particular
!     type's chacteristics.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-trait&quot;&gt;trait&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
***************
*** 771,783 ****
    &lt;glossentry id=&quot;glossary-view&quot;&gt;
     &lt;glossterm&gt;view of a container&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a container derived from another.  The former's domain is a
      subset of the latter's, but, where the domains intersect,
      accessing a value through the view is the same as accessing it
      through the original container.  In Fortran&nbsp;90, these are
      called array sections.  Only &array;s, &dynamicarray;s, and
!     &field;s support views.&lt;/para&gt; &lt;glossseealso
!     otherterm=&quot;glossary-container&quot;&gt;container&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
--- 881,893 ----
    &lt;glossentry id=&quot;glossary-view&quot;&gt;
     &lt;glossterm&gt;view of a container&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a container derived from another.  The view's domain is a
      subset of the latter's, but, where the domains intersect,
      accessing a value through the view is the same as accessing it
      through the original container.  In Fortran&nbsp;90, these are
      called array sections.  Only &array;s, &dynamicarray;s, and
!     &field;s support views.&lt;/para&gt;
!     &lt;glossseealso otherterm=&quot;glossary-container&quot;&gt;container&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
Index: introduction.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/introduction.xml,v
retrieving revision 1.3
diff -c -p -r1.3 introduction.xml
*** introduction.xml	2002/01/14 17:33:34	1.3
--- introduction.xml	2002/01/24 04:56:35
***************
*** 20,32 ****
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;automatic creation of all interprocessor communication for
!     parallel and distributed programs&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
-     &lt;para&gt;several container storage classes to reduce a program's
-     storage requirements, and&lt;/para&gt;
-    &lt;/listitem&gt;
-    &lt;listitem&gt;
      &lt;para&gt;automatic out-of-order execution and loop rearrangement
      for fast program execution.&lt;/para&gt;
     &lt;/listitem&gt;
--- 20,28 ----
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;automatic creation of all interprocessor communication for
!     parallel and distributed programs, and&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
      &lt;para&gt;automatic out-of-order execution and loop rearrangement
      for fast program execution.&lt;/para&gt;
     &lt;/listitem&gt;
***************
*** 44,50 ****
   &lt;section id=&quot;introduction-goals&quot;&gt;
    &lt;title&gt;&pooma; Goals&lt;/title&gt;
  
!   &lt;para&gt;The goals for the &poomatoolkit; have remained unchanged
    since its conception in 1994:
    &lt;orderedlist&gt;
     &lt;listitem&gt;
--- 40,50 ----
   &lt;section id=&quot;introduction-goals&quot;&gt;
    &lt;title&gt;&pooma; Goals&lt;/title&gt;
  
!   &lt;para&gt;&lt;indexterm zone=&quot;introduction-goals&quot;&gt;
!          &lt;primary&gt;&pooma;&lt;/primary&gt;
!          &lt;secondary&gt;goals&lt;/secondary&gt;
!         &lt;/indexterm&gt;
!   The goals for the &poomatoolkit; have remained unchanged
    since its conception in 1994:
    &lt;orderedlist&gt;
     &lt;listitem&gt;
***************
*** 74,89 ****
  
    &lt;bridgehead id=&quot;introduction-goals-portability&quot; renderas=&quot;sect2&quot;&gt;Code Portability for Sequential and Distributed Programs&lt;/bridgehead&gt;
  
!   &lt;para&gt;The same &pooma; programs run on sequential, distributed, and
    parallel computers.  No change in source code is required.  Two or
!   three lines specifying how each container's domain should be
    distributed among available processors.  Using these directives and
    run-time information about the computer's configuration, the
    &toolkit; automatically distributes pieces of the container domains,
    called &lt;link
    linkend=&quot;glossary-patch&quot;&gt;&lt;firstterm&gt;patches&lt;/firstterm&gt;&lt;/link&gt;,
    among the available processors.  If a computation needs values from
!   another patch, &pooma; automatically passes the value to the patch
    where it is needed.  The same program, and even the same executable,
    works regardless of the number of the available processors and the
    size of the containers' domains.  A programmer interested in only
--- 74,92 ----
  
    &lt;bridgehead id=&quot;introduction-goals-portability&quot; renderas=&quot;sect2&quot;&gt;Code Portability for Sequential and Distributed Programs&lt;/bridgehead&gt;
  
!   &lt;para&gt;&lt;indexterm zone=&quot;introduction-goals-portability&quot;&gt;
!          &lt;primary&gt;code portability&lt;/primary&gt;
!         &lt;/indexterm&gt;
!   The same &pooma; programs run on sequential, distributed, and
    parallel computers.  No change in source code is required.  Two or
!   three lines specify how each container's domain should be
    distributed among available processors.  Using these directives and
    run-time information about the computer's configuration, the
    &toolkit; automatically distributes pieces of the container domains,
    called &lt;link
    linkend=&quot;glossary-patch&quot;&gt;&lt;firstterm&gt;patches&lt;/firstterm&gt;&lt;/link&gt;,
    among the available processors.  If a computation needs values from
!   another patch, &pooma; automatically passes the values to the patch
    where it is needed.  The same program, and even the same executable,
    works regardless of the number of the available processors and the
    size of the containers' domains.  A programmer interested in only
***************
*** 92,116 ****
  
    &lt;bridgehead id=&quot;introduction-goals-rapid_development&quot; renderas=&quot;sect2&quot;&gt;Rapid Application Development&lt;/bridgehead&gt;
  
!   &lt;para&gt;The &poomatoolkit; is designed to enable rapid development of
    scientific and distributed applications.  For example, its vector,
    matrix, and tensor classes model the corresponding mathematical
    concepts.  Its &array; and &field; classes model the discrete spaces
!   and mathematical arrays frequently found in computational science and
!   math.  See &lt;xref linkend=&quot;introduction-science_algorithms&quot;&gt;&lt;/xref&gt;.
!   The left column indicates theoretical science and math concepts, the
!   middle column computational science and math concepts, and the right
!   column computer science implementations.  For example, theoretical
!   physics frequently uses continuous fields in three-dimension space,
!   while algorithms for a corresponding computational physics problem
!   usually uses discrete fields.  &pooma; containers, classes, and
!   functions ease engineering computer programs for these algorithms.
!   For example, the &pooma; &field; container models discrete fields;
!   both map locations in discrete space to values and permit
!   computations of spatial distances and values.  The &pooma; &array;
!   container models the mathematical concept of an array, used in
!   numerical analysis.&lt;/para&gt;
  
    &lt;figure float=&quot;1&quot; id=&quot;introduction-science_algorithms&quot;&gt;
     &lt;title&gt;How &pooma; Fits Into the Scientific Process&lt;/title&gt;
     &lt;mediaobject&gt;
--- 95,125 ----
  
    &lt;bridgehead id=&quot;introduction-goals-rapid_development&quot; renderas=&quot;sect2&quot;&gt;Rapid Application Development&lt;/bridgehead&gt;
  
!   &lt;para&gt;&lt;indexterm zone=&quot;introduction-goals-rapid_development&quot;&gt;
!          &lt;primary&gt;rapid development&lt;/primary&gt;
!         &lt;/indexterm&gt;
!   The &poomatoolkit; is designed to enable rapid development of
    scientific and distributed applications.  For example, its vector,
    matrix, and tensor classes model the corresponding mathematical
    concepts.  Its &array; and &field; classes model the discrete spaces
!   and mathematical arrays frequently found in computational science
!   and math.  See &lt;xref
!   linkend=&quot;introduction-science_algorithms&quot;&gt;&lt;/xref&gt;.  The left column
!   indicates theoretical science and math concepts, the middle column
!   computational science and math concepts, and the right column
!   computer science implementations.  For example, theoretical physics
!   frequently uses continuous fields in three-dimension space, while
!   algorithms for a corresponding computational physics problem usually
!   uses discrete fields.  &pooma; containers, classes, and functions
!   ease engineering computer programs for these algorithms.  For
!   example, the &pooma; &field; container models discrete fields: both
!   map locations in discrete space to values and permit computations of
!   spatial distances and values.  The &pooma; &array; container models
!   the mathematical concept of an array, frequently used in numerical
!   analysis.&lt;/para&gt;
  
+   &lt;!-- FIXME: How can we include this figure in the HTML version? --&gt;
+ 
    &lt;figure float=&quot;1&quot; id=&quot;introduction-science_algorithms&quot;&gt;
     &lt;title&gt;How &pooma; Fits Into the Scientific Process&lt;/title&gt;
     &lt;mediaobject&gt;
***************
*** 121,129 ****
       &lt;phrase&gt;&pooma; helps translate algorithms into programs.&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
!      &lt;para&gt;In the translation from theoretical science and math to
!      computational science and math to computer programs, &pooma; eases
!      the implementation of algorithms as computer programs.&lt;/para&gt;
      &lt;/caption&gt;
     &lt;/mediaobject&gt;
    &lt;/figure&gt;
--- 130,138 ----
       &lt;phrase&gt;&pooma; helps translate algorithms into programs.&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
!      &lt;para&gt;In the translation from theoretical science to
!      computational science to computer programs, &pooma; eases the
!      implementation of algorithms as computer programs.&lt;/para&gt;
      &lt;/caption&gt;
     &lt;/mediaobject&gt;
    &lt;/figure&gt;
***************
*** 131,191 ****
    &lt;para&gt;&pooma; containers support a variety of computation modes,
    easing translation of algorithms into code.  For example, many
    algorithms for solving partial differential equations use
!   stencil-based computations.  &pooma; supports stencil-based
!   computations on &array;s and &field;s.  It also supports
!   data-parallel computation similar to &amp;fortran&nbsp;90 syntax.  For
!   computations where one &field;'s values is a function of several
!   other &field;'s values, the programmer can specify a relation.
!   Relations are lazily evaluated: whenever the dependent &field;'s
!   values are needed and it is dependent on a &field; whose values have
!   changed, its values are computed.  Lazy evaluation also assists
!   correctness by eliminating the frequently forgotten need for a
!   programmer to ensure a &field;'s values are up-to-date before being
!   used.&lt;/para&gt;
  
    &lt;bridgehead id=&quot;introduction-goals-efficient&quot; renderas=&quot;sect2&quot;&gt;Efficient Code&lt;/bridgehead&gt;
  
    &lt;para&gt;&pooma; incorporates a variety of techniques to ensure it
!   produces code that executes as quickly as special-case,
!   hand-written code.
!  &lt;!-- FIXME: Do I present execution numbers here? --&gt;
!   These techniques include extensive use of templates, out-of-order
!   evaluation, use of guard layers, and production of fast inner loops.&lt;/para&gt;
! 
!   &lt;para&gt;&pooma;'s uses of &cc; templates permits the expressiveness
!   from using pointers and function arguments but ensures as much as
!   work as possible occurs at compile time, not run time.  This speeds
!   programs' execution.  Since more code is produced at compile time,
!   more code is available to the compiler's optimizer, further speeding
!   execution.  The &pooma; &array; container benefits from the use of
!   template parameters.  Their use permits the use of specialized data
!   storage classes called &lt;link
    linkend=&quot;glossary-engine&quot;&gt;&lt;firstterm&gt;engines&lt;/firstterm&gt;&lt;/link&gt;.  An
!   &array;'s &engine; template parameter specifies how data is stored and
!   indexed.  Some &array;s expect almost all values to be used, while
!   others might be mostly vacant.  In the latter case, using a
    specialized engine storing the few nonzero values greatly reduces
!   space requirements.  Using engines also permits fast creation of
!   container views, known as &lt;firstterm&gt;array sections&lt;/firstterm&gt; in
!   Fortran&nbsp;90.  A view's engine is the same as the original
!   container's engine, but the view object maps its restricted domain to
!   the original domain.  Space requirements and execution time to use
!   views are minimal.  Using templates also permits containers to
!   support polymorphic indexing, e.g., indexing both by integers and by
!   three-dimensional coordinates.  A container defers indexing
!   operations to its engine's templatized index operator.  Since it uses
!   templates, the &engine; can define indexing functions with different
!   function arguments, without the need to add corresponding container
!   functions.  Some of these benefits of using templates can be
!   expressed without them, but doing so increases execution time.  For
!   example, a container could have a pointer to an engine object, but
!   this requires a pointer dereference for each operation.  Implementing
!   polymorphic indexing without templates would require adding virtual
!   functions corresponding to each of the indexing functions.&lt;/para&gt;
  
   &lt;!-- FIXME: Are the claims concerning out-of-order evaluation I make true? --&gt;
  
!   &lt;para&gt;To ensure multiprocessor &pooma; programs execute quickly, it
    is important that interprocessor communication overlaps with
    intraprocessor computations as much as possible and that
    communication is minimized.  Asynchronous communication, out-of-order
--- 140,235 ----
    &lt;para&gt;&pooma; containers support a variety of computation modes,
    easing translation of algorithms into code.  For example, many
    algorithms for solving partial differential equations use
!   stencil-based computations so &pooma; supports stencil-based
!   computations on &array;s and &field;s.  &pooma; also supports
!   data-parallel computation similar to &amp;fortran&nbsp;90 syntax.
!   &lt;indexterm class=&quot;startofrange&quot;
!   id=&quot;introduction-goals-rapid_development-index-relations&quot;&gt;
!    &lt;primary&gt;relation&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   To ease implementing computations where one &field;'s values are a
!   function of several other &field;'s values, the programmer can
!   specify a &lt;glossterm
!   linkend=&quot;glossary-relation&quot;&gt;relation&lt;/glossterm&gt;.  Relations are
!   lazily evaluated: whenever the dependent &field;'s values are needed
!   and they are dependent on a &field; whose values have changed, the
!   values are computed.  Relations also assists correctness by
!   eliminating the frequently forgotten need for a programmer to ensure
!   a &field;'s values are up-to-date before being used.&lt;indexterm
!   class=&quot;endofrange&quot;
!   startref=&quot;introduction-goals-rapid_development-index-relations&quot;&gt;&lt;/indexterm&gt;&lt;/para&gt;
  
    &lt;bridgehead id=&quot;introduction-goals-efficient&quot; renderas=&quot;sect2&quot;&gt;Efficient Code&lt;/bridgehead&gt;
  
    &lt;para&gt;&pooma; incorporates a variety of techniques to ensure it
!   produces code that executes as quickly as special-case, hand-written
!   code.  These techniques include extensive use of templates,
!   out-of-order evaluation, use of guard layers, and production of fast
!   inner loops.&lt;/para&gt;
! 
!   &lt;para&gt;&lt;indexterm class=&quot;startofrange&quot;
!   id=&quot;introduction-goals-efficient-index-templates_use&quot;&gt;
!    &lt;primary&gt;templates&lt;/primary&gt;
!    &lt;secondary&gt;use&lt;/secondary&gt;
!   &lt;/indexterm&gt;
!   &pooma;'s uses of &cc; templates ensures as much as work as possible
!   occurs at compile time, not run time.  This speeds programs'
!   execution.  Since more code is produced at compile time, more code
!   is available to the compiler's optimizer, further speeding
!   execution.
!   &lt;indexterm class=&quot;startofrange&quot;
!   id=&quot;introduction-goals-efficient-index-templates-engines&quot;&gt;
!    &lt;primary&gt;engines&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   The &pooma; &array; container benefits from the use of template
!   parameters.  Their use permits the use of specialized data storage
!   classes called &lt;link
    linkend=&quot;glossary-engine&quot;&gt;&lt;firstterm&gt;engines&lt;/firstterm&gt;&lt;/link&gt;.  An
!   &array;'s &engine; template parameter specifies how data is stored
!   and indexed.  Some &array;s expect almost all values to be used,
!   while others might be mostly empty.  In the latter case, using a
    specialized engine storing the few nonzero values greatly reduces
!   storage requirements.  Using engines also permits fast creation of
!   container views, known as &lt;indexterm&gt;&lt;primary&gt;array
!   sections&lt;/primary&gt;&lt;/indexterm&gt;&lt;firstterm&gt;array sections&lt;/firstterm&gt;
!   in &fortran;&nbsp;90.  A view's engine is the same as the original
!   container's engine, but the view object's restricted domain is a
!   subset of the original domain.  Space requirements and execution
!   time to use views are minimal.  &lt;indexterm class=&quot;endofrange&quot;
!   startref=&quot;introduction-goals-efficient-index-templates-engines&quot;&gt;&lt;/indexterm&gt;
!   &lt;/para&gt;
  
+   &lt;para id=&quot;introduction-goals-efficient-polymorphic_indexing&quot;&gt;
+   &lt;indexterm zone=&quot;introduction-goals-efficient-polymorphic_indexing&quot;&gt;
+    &lt;primary&gt;polymorphic indexing&lt;/primary&gt;
+   &lt;/indexterm&gt;
+   Using templates also permits containers to support polymorphic
+   indexing, e.g., indexing both by integers and by three-dimensional
+   coordinates.  A container uses templatized indexing functions that
+   defer indexing operations to its engine's index operators.  Since
+   the container uses templates, the &engine; can define indexing
+   functions with different function arguments, without the need to add
+   corresponding container functions.  Some of these benefits of using
+   templates can be expressed without them, but doing so increases
+   execution time.  For example, a container could have a pointer to an
+   engine object, but this requires a pointer dereference for each
+   operation.  Implementing polymorphic indexing without templates
+   would require adding virtual functions corresponding to each of the
+   indexing functions.
+   &lt;indexterm class=&quot;endofrange&quot;
+   startref=&quot;introduction-goals-efficient-index-templates_use&quot;&gt;&lt;/indexterm&gt;
+   &lt;/para&gt;
+ 
   &lt;!-- FIXME: Are the claims concerning out-of-order evaluation I make true? --&gt;
  
!   &lt;para id=&quot;introduction-goals-efficient-asynchronous_communication&quot;&gt;
!   &lt;indexterm zone=&quot;introduction-goals-efficient-asynchronous_communication&quot;&gt;
!    &lt;primary&gt;asynchronous communication&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   &lt;indexterm zone=&quot;introduction-goals-efficient-asynchronous_communication&quot;&gt;
!    &lt;primary&gt;&cheetah;&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   To ensure multiprocessor &pooma; programs execute quickly, it
    is important that interprocessor communication overlaps with
    intraprocessor computations as much as possible and that
    communication is minimized.  Asynchronous communication, out-of-order
***************
*** 199,241 ****
    sender to put and get data without synchronizing with the recipient
    processor, and it also permits invoking functions at remote sites to
    ensure desired data is up-to-date.  Thus, out-of-order evaluation
    must be supported.  Out-of-order evaluation also has another benefit:
    Only computations directly or indirectly related to values that are
!   printed need occur.&lt;/para&gt;
  
!   &lt;para&gt;Surrounding a patch with &lt;link
    linkend=&quot;glossary-guard_layer&quot;&gt;&lt;firstterm&gt;guard
    layers&lt;/firstterm&gt;&lt;/link&gt; can help reduce interprocessor
    communication.  For distributed computation, each container's domain
    is split into pieces distributed among the available processors.
    Frequently, computing a container value is local, involving just the
!   value itself and a few neighbors, but computing a value near the edge
!   of a processor's domain may require knowing a few values from a
    neighboring domain.  Guard layers permit these values to be copied
    locally so they need not be repeatedly communicated.&lt;/para&gt;
  
!   &lt;para&gt;&pooma; uses &pete; technology to ensure inner loops involving
    &pooma;'s object-oriented containers run as quickly as hand-coded
!   &lt;!-- FIXME: Add a citation to Dr. Dobb's Journal article pete-99. --&gt;
!   loops.  &pete; (the Portable Expression Template Engine) uses
!   expression-template technology to convert data-parallel statements
!   in the inner loops of programs into efficient loops
!   without any intermediate computations.  For example, consider
!   evaluating the statement
!   &lt;programlisting&gt;
!   A += -B + 2 * C;&lt;/programlisting&gt;
!   where &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;C&lt;/varname&gt; are
    &lt;type&gt;vector&lt;double&gt;&lt;/type&gt;s and &lt;varname&gt;B&lt;/varname&gt; is a
!   &lt;type&gt;vector&lt;int&gt;&lt;/type&gt;.  Naive evaluation might introduce
    intermediaries for &lt;statement&gt;-B&lt;/statement&gt;,
    &lt;statement&gt;2*C&lt;/statement&gt;, and their sum.  The presence of these
!   intermediaries in inner loops can measurably slow evaluation.  To
    produce a loop without intermediaries, &pete; stores each expression
!   as a parse tree.  The resulting parse trees can be combined into a
!   larger parse tree.  Using its templates, the parse tree is converted,
!   at compile time, to a loop evaluating each component of the result.
!   Thus, no intermediate values are computed or stored.  For example,
!   the code corresponding to the statement above is
    &lt;programlisting&gt;
    vector&lt;double&gt;::iterator iterA = A.begin();
    vector&lt;int&gt;::const_iterator iterB = B.begin();
--- 243,308 ----
    sender to put and get data without synchronizing with the recipient
    processor, and it also permits invoking functions at remote sites to
    ensure desired data is up-to-date.  Thus, out-of-order evaluation
+   &lt;indexterm&gt;
+    &lt;primary&gt;out-of-order evaluation&lt;/primary&gt;
+   &lt;/indexterm&gt;
+   &lt;indexterm&gt;
+    &lt;primary&gt;evaluation&lt;/primary&gt;
+    &lt;secondary&gt;out-of-order&lt;/secondary&gt;
+    &lt;see&gt;out-of-order evaluation.&lt;/see&gt;
+   &lt;/indexterm&gt;
+ &lt;!-- FIXME: Add glossary entry for out-of-order evaluation. --&gt;
    must be supported.  Out-of-order evaluation also has another benefit:
    Only computations directly or indirectly related to values that are
!   printed need occur.
!   &lt;/para&gt;
  
!   &lt;para id=&quot;introduction-goals-efficient-guard_layers&quot;&gt;
!   &lt;indexterm zone=&quot;introduction-goals-efficient-guard_layers&quot;&gt;
!    &lt;primary&gt;guard layer&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   Surrounding a patch with &lt;link
    linkend=&quot;glossary-guard_layer&quot;&gt;&lt;firstterm&gt;guard
    layers&lt;/firstterm&gt;&lt;/link&gt; can help reduce interprocessor
    communication.  For distributed computation, each container's domain
    is split into pieces distributed among the available processors.
    Frequently, computing a container value is local, involving just the
!   value itself and a few neighbors, but computing a value near the
!   edge of a processor's domain may require knowing a few values from a
    neighboring domain.  Guard layers permit these values to be copied
    locally so they need not be repeatedly communicated.&lt;/para&gt;
  
!   &lt;para id=&quot;introduction-goals-efficient-pete&quot;&gt;
!   &lt;indexterm zone=&quot;introduction-goals-efficient-pete&quot;&gt;
!    &lt;primary&gt;&pete;&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   &lt;indexterm&gt;
!    &lt;primary&gt;&lt;application class=&quot;software&quot;&gt;Portable Expression Template Engine&lt;/application&gt;&lt;/primary&gt;
!    &lt;see&gt;&pete;.&lt;/see&gt;
!   &lt;/indexterm&gt;
!   &lt;indexterm zone=&quot;introduction-goals-efficient-pete&quot;&gt;
!    &lt;primary&gt;inner-loop evaluation&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   &pooma; uses &pete; technology to ensure inner loops involving
    &pooma;'s object-oriented containers run as quickly as hand-coded
!   &lt;!-- FIXME: Add a citation to Dr. Dobb's Journal article
!   pete-99. --&gt; loops.  &pete; (the &lt;application&gt;Portable Expression Template
!   Engine&lt;/application&gt;) uses expression-template technology to convert data-parallel
!   statements into efficient loops without any intermediate
!   computations.  For example, consider evaluating the statement
! &lt;programlisting&gt;
! A += -B + 2 * C;
! &lt;/programlisting&gt; where &lt;varname&gt;A&lt;/varname&gt; and &lt;varname&gt;C&lt;/varname&gt; are
    &lt;type&gt;vector&lt;double&gt;&lt;/type&gt;s and &lt;varname&gt;B&lt;/varname&gt; is a
!   &lt;type&gt;vector&lt;int&gt;&lt;/type&gt;.  &naivecap; evaluation might introduce
    intermediaries for &lt;statement&gt;-B&lt;/statement&gt;,
    &lt;statement&gt;2*C&lt;/statement&gt;, and their sum.  The presence of these
!   intermediaries in inner loops can measurably slow performance.  To
    produce a loop without intermediaries, &pete; stores each expression
!   as a parse tree.  Using its templates, the parse tree is
!   converted, at compile time, to a loop directly evaluating each component of
!   the result without computing intermediate values.
!   For example, the code corresponding to the statement above is
    &lt;programlisting&gt;
    vector&lt;double&gt;::iterator iterA = A.begin();
    vector&lt;int&gt;::const_iterator iterB = B.begin();
***************
*** 244,267 ****
      *iterA += -*iterB + 2 * *iterC;
      ++iterA; ++iterB; ++iterC;
    }&lt;/programlisting&gt;
!   Furthermore, since the code is available at compile, not run, time,
    it can be further optimized, e.g., moving any loop-invariant code out
    of the loop.&lt;/para&gt;
  
    &lt;bridgehead id=&quot;introduction-goals-scientific&quot; renderas=&quot;sect2&quot;&gt;Used for Diverse Set of Scientific Problems&lt;/bridgehead&gt;
  
    &lt;para&gt;&pooma; has been used to solve a wide variety of scientific
    problems.  Most recently, physicists at Los Alamos National
!   Laboratory implemented an entire library of hydrodynamics codes as
    part of the U.S. government's science-based Stockpile Stewardship
!   Program to simulate nuclear weapons.  Other applications include a
    matrix solver, an accelerator code simulating the dynamics of
    high-intensity charged particle beams in linear accelerators, and a
!   Monte Carlo neutron transport code.&lt;/para&gt;
  
    &lt;bridgehead id=&quot;introduction-goals-easy_implementation&quot; renderas=&quot;sect2&quot;&gt;Easy Implementation&lt;/bridgehead&gt;
  
!   &lt;para&gt;&pooma;'s tools greatly reduce the time to implement
    applications.  As we noted above, &pooma;'s containers and expression
    syntax model the computational models and algorithms most frequently
    found in scientific programs.  These high-level tools are known to be
--- 311,357 ----
      *iterA += -*iterB + 2 * *iterC;
      ++iterA; ++iterB; ++iterC;
    }&lt;/programlisting&gt;
!   Furthermore, since the code is available at compile time, not run time,
    it can be further optimized, e.g., moving any loop-invariant code out
    of the loop.&lt;/para&gt;
  
+ 
    &lt;bridgehead id=&quot;introduction-goals-scientific&quot; renderas=&quot;sect2&quot;&gt;Used for Diverse Set of Scientific Problems&lt;/bridgehead&gt;
  
    &lt;para&gt;&pooma; has been used to solve a wide variety of scientific
    problems.  Most recently, physicists at Los Alamos National
!   Laboratory
!   &lt;indexterm&gt;
!    &lt;primary&gt;Los Alamos National Laboratory&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   implemented an entire library of hydrodynamics codes
!   &lt;indexterm&gt;
!    &lt;primary&gt;hydrodynamics&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   as
    part of the U.S. government's science-based Stockpile Stewardship
!   Program
!   &lt;indexterm&gt;
!    &lt;primary&gt;Stockpile Stewardship Program&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   to simulate nuclear weapons.  Other applications include a
    matrix solver, an accelerator code simulating the dynamics of
    high-intensity charged particle beams in linear accelerators, and a
!   Monte Carlo
!   &lt;indexterm&gt;
!    &lt;primary&gt;Monte Carlo simulation&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   neutron transport code.&lt;/para&gt;
  
+ 
    &lt;bridgehead id=&quot;introduction-goals-easy_implementation&quot; renderas=&quot;sect2&quot;&gt;Easy Implementation&lt;/bridgehead&gt;
  
!   &lt;para id=&quot;introduction-goals-easy_implementation-ease&quot;&gt;
!   &lt;indexterm zone=&quot;introduction-goals-easy_implementation-ease&quot;&gt;
!    &lt;primary&gt;&pooma;&lt;/primary&gt;
!    &lt;secondary&gt;ease of writing programs&lt;/secondary&gt;
!   &lt;/indexterm&gt;
!   &pooma;'s tools greatly reduce the time to implement
    applications.  As we noted above, &pooma;'s containers and expression
    syntax model the computational models and algorithms most frequently
    found in scientific programs.  These high-level tools are known to be
***************
*** 271,280 ****
    computers.  With no additional work, the same program runs on
    computers with hundreds of processors; the code is exactly the same,
    and the &toolkit; automatically handles distribution of the data, all
!   data communication, and all synchronization.  The net results is a
    significant reduction in programming time.  For example, a team of
    two physicists and two support people at Los Alamos National
!   Laboratory implemented a suite of hydrodynamics kernels in six
    months.  Their work replaced a previous suite of less-powerful
    kernels which had taken sixteen people several years to implement and
    debug.  Despite not have previously implemented any of the kernels,
--- 361,378 ----
    computers.  With no additional work, the same program runs on
    computers with hundreds of processors; the code is exactly the same,
    and the &toolkit; automatically handles distribution of the data, all
!   data communication, and all synchronization.  The net result is a
    significant reduction in programming time.  For example, a team of
    two physicists and two support people at Los Alamos National
!   Laboratory
!   &lt;indexterm&gt;
!    &lt;primary&gt;Los Alamos National Laboratory&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   implemented a suite of hydrodynamics kernels
!   &lt;indexterm&gt;
!    &lt;primary&gt;hydrodynamics&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   in six
    months.  Their work replaced a previous suite of less-powerful
    kernels which had taken sixteen people several years to implement and
    debug.  Despite not have previously implemented any of the kernels,
***************
*** 283,352 ****
   &lt;/section&gt;&lt;!-- introduction-goals --&gt;
  
  
   &lt;section id=&quot;introduction-performance&quot;&gt;
    &lt;title&gt;&pooma; Produces Fast Programs&lt;/title&gt;
  
    &lt;para&gt;almost as fast as &c;.  wide variety of configurations: one
    processor, many processors, give performance data for at least two
!   different programs
! HERE&lt;/para&gt;
  
!   &lt;para&gt;describe &amp;doof2d; here
  
    &amp;doof2d; is a two-dimensional diffusion simulation program.
    Initially, all values in the square two-dimensional grid are zero
!   except for the central value.  
! 
! HERE&lt;/para&gt;
  
   &lt;/section&gt;
  
- &lt;!-- HERE --&gt;
  
   &lt;section id=&quot;introduction-open_source&quot;&gt;
    &lt;title&gt;&pooma; is Free, Open-Source Software&lt;/title&gt;
  
    &lt;para&gt;The &poomatoolkit; is open-source software.  Anyone may
    download, read, redistribute, and modify the &pooma; source code.
!   If an application requires a specialized container, any programmer
!   may add it.  Any programmer can extend it to solve problems in
!   previously unsupported domains.  Companies using the &toolkit; can
!   read the source code to ensure it has no hidden back doors or
!   security holes.  It may be downloaded for free and used for
!   perpetuity.  There are no annual licenses and no on-going costs.  By
!   keeping their own copies, companies are guaranteed the software will
!   never disappear.  In summary, the &poomatoolkit; is free, low-risk
!   software.&lt;/para&gt;
   &lt;/section&gt;
  
  
   &lt;section id=&quot;introduction-pooma_history&quot;&gt;
    &lt;title&gt;History of &pooma;&lt;/title&gt;
  
    &lt;para&gt;The &poomatoolkit; was developed at Los Alamos National
!   Laboratory to assist nuclear fusion and fission research.
    In&nbsp;1994, the &toolkit; grew out of the &lt;application
    class='software'&gt;Object-Oriented Particle Simulation&lt;/application&gt;
!   class library developed for particle-in-cell simulations.  The goals
    of the Framework, as it was called at the time, were driven by the
!   Numerical Tokamak's &lt;quote&gt;Parallel Platform Paradox&lt;/quote&gt;:
    &lt;blockquote&gt;
     &lt;para&gt;The average time required to implement a moderate-sized
     application on a parallel computer architecture is equivalent to
     the half-life of the latest parallel supercomputer.&lt;/para&gt;
    &lt;/blockquote&gt;
    The framework's goal of being able to quickly write efficient
    scientific code that could be run on a wide variety of platforms
    remains unchanged today.  Development, mainly at the
!   Advanced Computing Laboratory at Los Alamos, proceeded rapidly.
!   A matrix solver application was written using the framework.
  &lt;!-- FIXME: Add citation to pooma-sc95. --&gt;
!   Support for hydrodynamics, Monte Carlo simulations, and molecular
!   dynamics modeling soon followed.&lt;/para&gt;
! 
!   &lt;para&gt;By&nbsp;1998, &pooma; was part of the U.S. Department of
!   Energy's Accelerated Strategic Computing Initiative
!   (&lt;acronym&gt;ASCI&lt;/acronym&gt;).  The Comprehensive Test Ban Treaty forbid
    nuclear weapons testing so they were instead simulated using
    computers.  &lt;acronym&gt;ASCI&lt;/acronym&gt;'s goal was to radically advance
    the state of the art in high-performance computing and numerical
--- 381,516 ----
   &lt;/section&gt;&lt;!-- introduction-goals --&gt;
  
  
+ &lt;![%unfinished;[
   &lt;section id=&quot;introduction-performance&quot;&gt;
    &lt;title&gt;&pooma; Produces Fast Programs&lt;/title&gt;
  
    &lt;para&gt;almost as fast as &c;.  wide variety of configurations: one
    processor, many processors, give performance data for at least two
!   different programs UNFINISHED&lt;/para&gt;
  
!   &lt;para&gt;describe &amp;doof2d; at this location
  
    &amp;doof2d; is a two-dimensional diffusion simulation program.
    Initially, all values in the square two-dimensional grid are zero
!   except for the central value.  UNFINISHED&lt;/para&gt;
  
   &lt;/section&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
  
   &lt;section id=&quot;introduction-open_source&quot;&gt;
    &lt;title&gt;&pooma; is Free, Open-Source Software&lt;/title&gt;
  
+   &lt;indexterm zone=&quot;introduction-open_source&quot;&gt;
+    &lt;primary&gt;open-source software&lt;/primary&gt;
+   &lt;/indexterm&gt;
+   &lt;indexterm zone=&quot;introduction-open_source&quot;&gt;
+    &lt;primary&gt;&pooma;&lt;/primary&gt;
+    &lt;secondary&gt;open-source&lt;/secondary&gt;
+   &lt;/indexterm&gt;
+ 
    &lt;para&gt;The &poomatoolkit; is open-source software.  Anyone may
    download, read, redistribute, and modify the &pooma; source code.
!   If an application requires a specialized container not already
!   available, any programmer may add it.  Any programmer can extend it
!   to solve problems in previously unsupported domains.  Companies
!   using the &toolkit; can read the source code to ensure it has no
!   security holes.  It may be downloaded for free
!   and used for perpetuity.  There are no annual licenses and no
!   on-going costs.  By keeping their own copies, companies are
!   guaranteed the software will never disappear.  In summary, the
!   &poomatoolkit; is free, low-risk software.&lt;/para&gt;
   &lt;/section&gt;
  
  
   &lt;section id=&quot;introduction-pooma_history&quot;&gt;
    &lt;title&gt;History of &pooma;&lt;/title&gt;
  
+   &lt;indexterm zone=&quot;introduction-pooma_history&quot;&gt;
+    &lt;primary&gt;&pooma;&lt;/primary&gt;
+    &lt;secondary&gt;history&lt;/secondary&gt;
+   &lt;/indexterm&gt;
+   &lt;indexterm zone=&quot;introduction-pooma_history&quot;&gt;
+    &lt;primary&gt;Los Alamos National Laboratory&lt;/primary&gt;
+   &lt;/indexterm&gt;
+ 
    &lt;para&gt;The &poomatoolkit; was developed at Los Alamos National
!   Laboratory to assist nuclear fusion
!   &lt;indexterm&gt;
!    &lt;primary&gt;fusion&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   and fission
!   &lt;indexterm&gt;
!    &lt;primary&gt;fission&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   research.
    In&nbsp;1994, the &toolkit; grew out of the &lt;application
    class='software'&gt;Object-Oriented Particle Simulation&lt;/application&gt;
!   &lt;indexterm&gt;
!    &lt;primary&gt;Object-Oriented Particle Simulation Library&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   Class Library developed for particle-in-cell simulations.  The goals
    of the Framework, as it was called at the time, were driven by the
!   Numerical Tokamak's 
!   &lt;indexterm&gt;
!    &lt;primary&gt;Tokamak&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   &lt;quote&gt;Parallel Platform Paradox&lt;/quote&gt;:
    &lt;blockquote&gt;
     &lt;para&gt;The average time required to implement a moderate-sized
     application on a parallel computer architecture is equivalent to
     the half-life of the latest parallel supercomputer.&lt;/para&gt;
    &lt;/blockquote&gt;
+   &lt;indexterm&gt;
+    &lt;primary&gt;Parallel Platform Paradox&lt;/primary&gt;
+   &lt;/indexterm&gt;
    The framework's goal of being able to quickly write efficient
    scientific code that could be run on a wide variety of platforms
    remains unchanged today.  Development, mainly at the
!   Advanced Computing Laboratory
!   &lt;indexterm&gt;
!    &lt;primary&gt;Los Alamos National Laboratory&lt;/primary&gt;
!    &lt;secondary&gt;Advanced Computing Laboratory&lt;/secondary&gt;
!   &lt;/indexterm&gt;
!   at Los Alamos, proceeded rapidly.  A matrix solver application was
!   written using the framework.
  &lt;!-- FIXME: Add citation to pooma-sc95. --&gt;
!   Support for hydrodynamics,
!   &lt;indexterm&gt;
!    &lt;primary&gt;hydrodynamics&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   Monte Carlo simulations,
!   &lt;indexterm&gt;
!    &lt;primary&gt;Monte Carlo simulation&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   and molecular dynamics
!   &lt;indexterm&gt;
!    &lt;primary&gt;molecular dynamics modeling&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   modeling soon followed.&lt;/para&gt;
! 
!   &lt;para id=&quot;introduction-pooma_history-asci&quot;&gt;
!   By&nbsp;1998, &pooma; was part of the U.S. Department of
!   Energy's
!   &lt;indexterm&gt;
!    &lt;primary&gt;Department of Energy&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   Accelerated Strategic Computing Initiative
!   (&lt;acronym&gt;ASCI&lt;/acronym&gt;).
!   &lt;indexterm zone=&quot;introduction-pooma_history-asci&quot;&gt;
!    &lt;primary&gt;Department of Energy&lt;/primary&gt;
!    &lt;secondary&gt;Accelerated Strategic Computing Initiative&lt;/secondary&gt;
!   &lt;/indexterm&gt;
!   &lt;indexterm&gt;
!    &lt;primary&gt;Accelerated Strategic Computing Initiative&lt;/primary&gt;
!    &lt;see&gt;Department of Energy, Accelerated Strategic Computing Initiative.&lt;/see&gt;
!   &lt;/indexterm&gt;
!   The Comprehensive Test Ban Treaty
!   &lt;indexterm&gt;
!    &lt;primary&gt;Comprehensive Test Ban Treaty&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   forbid
    nuclear weapons testing so they were instead simulated using
    computers.  &lt;acronym&gt;ASCI&lt;/acronym&gt;'s goal was to radically advance
    the state of the art in high-performance computing and numerical
*************** HERE&lt;/para&gt;
*** 361,388 ****
    &lt;para&gt;&pooma;&nbsp;2 involved a new conceptual framework and a
    complete rewriting of the source code to improve performance.  The
  &lt;!-- FIXME: Add a citation to iscope98.pdf. --&gt;
!   &array; class was introduced with its use of &engine;s, separating
!   container use from container storage.  An asynchronous scheduler
!   permitted out-of-order execution to improve cache coherency.
    Incorporating the &lt;application class=&quot;software&quot;&gt;Portable
    Expression Template Engine&lt;/application&gt; (&lt;acronym&gt;PETE&lt;/acronym&gt;)
!   permitted faster loop execution.  Soon, container views and
!   &lt;type&gt;ConstantFunction&lt;/type&gt; and &lt;type&gt;IndexFunction&lt;/type&gt;
!   &engine;s were added.  Release&nbsp;2.1.0 included &field;s with
!   their spatial extent and &dynamicarray;s with the ability to
!   dynamically change its domain size.  Support for particles and
    their interaction with &field;s were added.  The &pooma; messaging
    implementation was revised in release&nbsp;2.3.0.  Use of the
!   &cheetah; Library separated &pooma; from the actual messaging
    library used, and support for applications running on clusters of
    computers was added.  &lt;ulink
!   url=&quot;<A HREF="http://www.codesourcery.com">http://www.codesourcery.com</A>&quot;&gt;CodeSourcery, LLC&lt;/ulink&gt;, and
!   &lt;ulink url=&quot;www.proximation.com&quot;&gt;Proximation, LLC&lt;/ulink&gt;, took
    over &pooma; development from Los Alamos National Laboratory.
    During the past two years, the &field;
!   abstraction and implementation was improved to increase its
    flexibility, add support for multiple values and materials in the
!   same cell, and permit lazy evaluation.  Simultaneously, the
    execution speed of the inner loops was greatly increased.&lt;/para&gt;
   &lt;/section&gt;
  
--- 525,609 ----
    &lt;para&gt;&pooma;&nbsp;2 involved a new conceptual framework and a
    complete rewriting of the source code to improve performance.  The
  &lt;!-- FIXME: Add a citation to iscope98.pdf. --&gt;
!   &array; class
!   &lt;indexterm&gt;
!    &lt;primary&gt;&array;&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   was introduced with its use of &engine;s,
!   &lt;indexterm&gt;
!    &lt;primary&gt;&engine;&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   separating
!   container use from container storage.  A new asynchronous scheduler
!   permitted out-of-order execution
!   &lt;indexterm&gt;
!    &lt;primary&gt;out-of-order evaluation&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   to improve cache coherency.
    Incorporating the &lt;application class=&quot;software&quot;&gt;Portable
    Expression Template Engine&lt;/application&gt; (&lt;acronym&gt;PETE&lt;/acronym&gt;)
!   &lt;indexterm&gt;
!    &lt;primary&gt;&pete;&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   permitted faster loop execution.  Soon, container views
!   &lt;indexterm&gt;
!    &lt;primary&gt;container&lt;/primary&gt;
!    &lt;secondary&gt;view&lt;/secondary&gt;
!   &lt;/indexterm&gt;
!   and
!   &lt;type&gt;ConstantFunction&lt;/type&gt;
!   &lt;indexterm&gt;
!    &lt;primary&gt;&engine;&lt;/primary&gt;
!    &lt;secondary&gt;&lt;type&gt;ConstantFunction&lt;/type&gt;&lt;/secondary&gt;
!   &lt;/indexterm&gt;
!   and &lt;type&gt;IndexFunction&lt;/type&gt;
!   &lt;indexterm&gt;
!    &lt;primary&gt;&engine;&lt;/primary&gt;
!    &lt;secondary&gt;&lt;type&gt;IndexFunction&lt;/type&gt;&lt;/secondary&gt;
!   &lt;/indexterm&gt;
!   &engine;s were added.  Release&nbsp;2.1.0 included &field;s
!   &lt;indexterm&gt;
!    &lt;primary&gt;&field;&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   with
!   their spatial extent and &dynamicarray;s
!   &lt;indexterm&gt;
!    &lt;primary&gt;&dynamicarray;&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   with the ability to
!   dynamically change domain size.  Support for particles and
    their interaction with &field;s were added.  The &pooma; messaging
    implementation was revised in release&nbsp;2.3.0.  Use of the
!   &cheetah; Library
!   &lt;indexterm&gt;
!    &lt;primary&gt;&cheetah;&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   separated &pooma; from the actual messaging
    library used, and support for applications running on clusters of
    computers was added.  &lt;ulink
!   url=&quot;<A HREF="http://www.codesourcery.com/">http://www.codesourcery.com/</A>&quot;&gt;CodeSourcery, LLC&lt;/ulink&gt;,
!   &lt;indexterm&gt;
!    &lt;primary&gt;CodeSourcery, LLC&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   and
!   &lt;ulink url=&quot;<A HREF="http://www.proximation.com/">http://www.proximation.com/</A>&quot;&gt;Proximation, LLC&lt;/ulink&gt;,
!   &lt;indexterm&gt;
!    &lt;primary&gt;Proximation, LLC&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   took
    over &pooma; development from Los Alamos National Laboratory.
    During the past two years, the &field;
!   abstraction
!   &lt;indexterm&gt;
!    &lt;primary&gt;&field;&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   and implementation was improved to increase its
    flexibility, add support for multiple values and materials in the
!   same cell, and permit lazy evaluation.
!   &lt;indexterm&gt;
!    &lt;primary&gt;lazy evaluation&lt;/primary&gt;
!   &lt;/indexterm&gt;
!   Simultaneously, the
    execution speed of the inner loops was greatly increased.&lt;/para&gt;
   &lt;/section&gt;
  
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.8
diff -c -p -r1.8 manual.xml
*** manual.xml	2002/01/22 15:48:49	1.8
--- manual.xml	2002/01/24 04:56:38
***************
*** 1,4 ****
--- 1,6 ----
  &lt;?xml version=&quot;1.0&quot;?&gt;
+ &lt;!-- FIXME: Index this file. --&gt;
+ &lt;!-- FIXME: What font does DocBook/JadeTeX use?  Can we use it for the figures? --&gt;
  
  &lt;!DOCTYPE book PUBLIC &quot;-//OASIS//DTD DocBook XML V4.1.2//EN&quot; &quot;<A HREF="file://usr/lib/sgml/docbookx.dtd">file://usr/lib/sgml/docbookx.dtd</A>&quot; [
  
***************
*** 7,12 ****
--- 9,20 ----
    &lt;!-- UPDATE: Check before publishing to see if any needs changing. --&gt;
    &lt;!-- ADD: Write more material. --&gt;
  
+ &lt;!-- Conditional Inclusion Entity Declarations --&gt;
+ &lt;!ENTITY % unfinished &quot;IGNORE&quot;&gt;
+   &lt;!-- Unfinished sections should not be included in published versions. --&gt;
+ &lt;!ENTITY % temporary &quot;INCLUDE&quot;&gt;
+   &lt;!-- Temporary sections to be included in published versions until the final version is written. --&gt;
+ 
  &lt;!-- Index Entity Declarations --&gt;
  &lt;!ENTITY genindex.sgm SYSTEM &quot;genindex.sgm&quot;&gt;
  
***************
*** 158,163 ****
--- 166,173 ----
  
  &lt;!ENTITY container &quot;C&quot;&gt;
    &lt;!-- an abbreviation for a canonical container --&gt;
+ &lt;!ENTITY containerdomain &quot;D&quot;&gt;
+   &lt;!-- an abbreviation for a canonical container domain --&gt;
  &lt;!ENTITY n &quot;n&quot;&gt;
    &lt;!-- the size of one dimension of an array --&gt;
  &lt;!ENTITY space &quot;&real;&lt;superscript&gt;d&lt;/superscript&gt;&quot;&gt;
***************
*** 173,194 ****
  
  &lt;!-- &pooma; URLs and Files --&gt;
  
! &lt;!ENTITY poomaDownloadPage '&lt;ulink url=&quot;<A HREF="http://pooma.codesourcery.com/pooma/download">http://pooma.codesourcery.com/pooma/download</A>&quot;&gt;<A HREF="http://pooma.codesourcery.com/pooma/download&lt;/ulink">http://pooma.codesourcery.com/pooma/download&lt;/ulink</A>&gt;'&gt;
    &lt;!-- The WWW page supporting downloading the &pooma; source code. --&gt;
    &lt;!-- UPDATE this URL. --&gt;
! &lt;!ENTITY poomaHomePage '&lt;ulink url=&quot;<A HREF="http://www.pooma.com/">http://www.pooma.com/</A>&quot;&gt;<A HREF="http://www.pooma.com/&lt;/ulink">http://www.pooma.com/&lt;/ulink</A>&gt;'&gt;
    &lt;!-- The canonical Pooma home page. --&gt;
    &lt;!-- UPDATE this filename. --&gt;
! &lt;!ENTITY poomaSource &quot;pooma-2.3.0&quot;&gt;
    &lt;!-- The Pooma source code directory. --&gt;
! &lt;!ENTITY poomaSourceFile &quot;&poomaSource;.tgz&quot;&gt;
    &lt;!-- The Pooma source code archive. --&gt;
! &lt;!ENTITY poomaExampleDirectory &quot;examples/Manual&quot;&gt;
    &lt;!-- The directory holding this manual's example codes. --&gt;
  
  &lt;!-- Spelling and Formatting Decisions --&gt;
  &lt;!ENTITY author &quot;author&quot;&gt;
    &lt;!-- A word describing an author xor authors. --&gt;
    &lt;!-- spelling: dependence, not dependency --&gt;
    &lt;!-- spelling: element-wise, not elementwise --&gt;
    &lt;!-- phrase: function object, not functor --&gt;
--- 183,210 ----
  
  &lt;!-- &pooma; URLs and Files --&gt;
  
! &lt;!ENTITY poomadownloadpage '&lt;ulink url=&quot;<A HREF="http://pooma.codesourcery.com/pooma/download">http://pooma.codesourcery.com/pooma/download</A>&quot;&gt;<A HREF="http://pooma.codesourcery.com/pooma/download&lt;/ulink">http://pooma.codesourcery.com/pooma/download&lt;/ulink</A>&gt;'&gt;
    &lt;!-- The WWW page supporting downloading the &pooma; source code. --&gt;
    &lt;!-- UPDATE this URL. --&gt;
! &lt;!ENTITY poomahomepage '&lt;ulink url=&quot;<A HREF="http://www.pooma.com/">http://www.pooma.com/</A>&quot;&gt;<A HREF="http://www.pooma.com/&lt;/ulink">http://www.pooma.com/&lt;/ulink</A>&gt;'&gt;
    &lt;!-- The canonical Pooma home page. --&gt;
    &lt;!-- UPDATE this filename. --&gt;
! &lt;!ENTITY poomasource &quot;pooma-2.3.0&quot;&gt;
    &lt;!-- The Pooma source code directory. --&gt;
!   &lt;!-- UPDATE this filename. --&gt;
! &lt;!ENTITY poomasourcefile &quot;&poomasource;.tgz&quot;&gt;
    &lt;!-- The Pooma source code archive. --&gt;
! &lt;!ENTITY poomaexampledirectory &quot;examples/Manual&quot;&gt;
    &lt;!-- The directory holding this manual's example codes. --&gt;
  
  &lt;!-- Spelling and Formatting Decisions --&gt;
  &lt;!ENTITY author &quot;author&quot;&gt;
    &lt;!-- A word describing an author xor authors. --&gt;
+ &lt;!ENTITY naive &quot;na&iuml;ve&quot;&gt;
+   &lt;!-- The word &quot;na\&quot;{\i}ve.&quot; --&gt;
+ &lt;!ENTITY naivecap &quot;Na&iuml;ve&quot;&gt;
+   &lt;!-- The word &quot;Na\&quot;{\i}ve,&quot; i.e., the capitalized &naive;. --&gt;
+   &lt;!-- The Pooma source code directory. --&gt;
    &lt;!-- spelling: dependence, not dependency --&gt;
    &lt;!-- spelling: element-wise, not elementwise --&gt;
    &lt;!-- phrase: function object, not functor --&gt;
***************
*** 260,277 ****
      &lt;orgname&gt;CodeSourcery, LLC&lt;/orgname&gt;
     &lt;/affiliation&gt;
    &lt;/author&gt;
!   &lt;copyright&gt;&lt;year&gt;2001&lt;/year&gt;&lt;holder&gt;CodeSourcery, LLC (&lt;ulink url=&quot;<A HREF="http://www.codesourcery.com">http://www.codesourcery.com</A>&quot;&gt;&lt;/ulink&gt;)&lt;/holder&gt;&lt;/copyright&gt;
!   &lt;contractsponsor&gt;Los Alamos National Laboratory&lt;ulink url=&quot;<A HREF="http://www.lanl.gov">http://www.lanl.gov</A>&quot;&gt;&lt;/ulink&gt;&lt;/contractsponsor&gt;
    &lt;legalnotice&gt;
     &lt;!-- FIXME: What is the correct legal notice? --&gt;
     &lt;para&gt;All rights reserved.  This document may not be redistributed in any form without the express permission of the author.&lt;/para&gt;
    &lt;/legalnotice&gt;
    &lt;revhistory&gt;
     &lt;revision&gt;
!     &lt;revnumber&gt;0.01&lt;/revnumber&gt;
!     &lt;date&gt;2002 Jan 14&lt;/date&gt;
      &lt;authorinitials&gt;jdo&lt;/authorinitials&gt;
!     &lt;revremark&gt;first draft&lt;/revremark&gt;
     &lt;/revision&gt;
    &lt;/revhistory&gt;
   &lt;/bookinfo&gt;
--- 276,293 ----
      &lt;orgname&gt;CodeSourcery, LLC&lt;/orgname&gt;
     &lt;/affiliation&gt;
    &lt;/author&gt;
!   &lt;copyright&gt;&lt;year&gt;2002&lt;/year&gt;&lt;holder&gt;CodeSourcery, LLC (&lt;ulink url=&quot;<A HREF="http://www.codesourcery.com/">http://www.codesourcery.com/</A>&quot;&gt;&lt;/ulink&gt;)&lt;/holder&gt;&lt;/copyright&gt;
!   &lt;contractsponsor&gt;Los Alamos National Laboratory&lt;ulink url=&quot;<A HREF="http://www.lanl.gov/">http://www.lanl.gov/</A>&quot;&gt;&lt;/ulink&gt;&lt;/contractsponsor&gt;
    &lt;legalnotice&gt;
     &lt;!-- FIXME: What is the correct legal notice? --&gt;
     &lt;para&gt;All rights reserved.  This document may not be redistributed in any form without the express permission of the author.&lt;/para&gt;
    &lt;/legalnotice&gt;
    &lt;revhistory&gt;
     &lt;revision&gt;
!     &lt;revnumber&gt;1.00&lt;/revnumber&gt;
!     &lt;date&gt;2002 Jan 23&lt;/date&gt;
      &lt;authorinitials&gt;jdo&lt;/authorinitials&gt;
!     &lt;revremark&gt;First publication.&lt;/revremark&gt;
     &lt;/revision&gt;
    &lt;/revhistory&gt;
   &lt;/bookinfo&gt;
***************
*** 279,284 ****
--- 295,301 ----
   &lt;!-- FINISH: May we have a short table of contents followed by a --&gt;
   &lt;!-- complete table of contents? --&gt;
  
+ &lt;![%unfinished;[
   &lt;preface id=&quot;preface&quot;&gt;
    &lt;title&gt;Preface&lt;/title&gt;
  
***************
*** 338,349 ****
--- 355,369 ----
    &lt;/section&gt;
  
   &lt;/preface&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
  
+ &lt;![%unfinished;[
   &lt;part id=&quot;programming&quot;&gt;
    &lt;title&gt;Programming with &pooma;&lt;/title&gt;
  
  &lt;!-- FIXME: Add a partintro to the part above? --&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
    &amp;introductory-chapter; 
  
***************
*** 420,429 ****
      components of each vector in an &array; to form its own &array;.
      Since each container has one or more &engine;s, we can also
      describe the latter category as containers that compute their
!     values using other containers' values.  A &lt;type&gt;MultiPatch&lt;/type&gt;
!     &engine; distributes its domain among various processors and
!     memory spaces, each responsible for computing values associated
!     with a portion, or patch, of the domain.&lt;/para&gt;
  
      &lt;para&gt;Just as multiple containers can use the same engine,
      multiple &engine;s can use the same underlying data.  As we
--- 440,449 ----
      components of each vector in an &array; to form its own &array;.
      Since each container has one or more &engine;s, we can also
      describe the latter category as containers that compute their
!     values using other containers' values.  A &multipatch; &engine;
!     distributes its domain among various processors and memory spaces,
!     each responsible for computing values associated with a portion,
!     or patch, of the domain.&lt;/para&gt;
  
      &lt;para&gt;Just as multiple containers can use the same engine,
      multiple &engine;s can use the same underlying data.  As we
***************
*** 491,497 ****
  	&lt;row&gt;
  	 &lt;entry&gt;&dynamic;&lt;/entry&gt;
  	 &lt;entry&gt;is a one-dimensional &brick; with dynamically
!          resizable domain.  HERE ever explicitly declare these?&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row rowsep=&quot;1&quot;&gt;
  	 &lt;entry&gt;&engine;s That Compute&lt;/entry&gt;
--- 511,518 ----
  	&lt;row&gt;
  	 &lt;entry&gt;&dynamic;&lt;/entry&gt;
  	 &lt;entry&gt;is a one-dimensional &brick; with dynamically
!          resizable domain.  This should be used with &dynamicarray;,
! 	 not &array;.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row rowsep=&quot;1&quot;&gt;
  	 &lt;entry&gt;&engine;s That Compute&lt;/entry&gt;
***************
*** 620,626 ****
      &lt;methodname&gt;operator()&lt;/methodname&gt; take &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;
      or one &int; parameter.  In addition, the one-dimensional domain
      can be dynamically resized using &lt;methodname&gt;create&lt;/methodname&gt;
!     and &lt;methodname&gt;destroy&lt;/methodname&gt;; see .  
  
  HERE Dynamic. How does one change the domain size?  What is the model?&lt;/para&gt;
  
--- 641,647 ----
      &lt;methodname&gt;operator()&lt;/methodname&gt; take &lt;type&gt;Loc&lt;1&gt;&lt;/type&gt;
      or one &int; parameter.  In addition, the one-dimensional domain
      can be dynamically resized using &lt;methodname&gt;create&lt;/methodname&gt;
!     and &lt;methodname&gt;destroy&lt;/methodname&gt;; see .
  
  HERE Dynamic. How does one change the domain size?  What is the model?&lt;/para&gt;
  
*************** HERE Dynamic. How does one change the do
*** 696,708 ****
--- 717,780 ----
    &lt;chapter id=&quot;views&quot;&gt;
     &lt;title&gt;Container Views&lt;/title&gt;
  
+    &lt;indexterm zone=&quot;views&quot;&gt;
+     &lt;primary&gt;container&lt;/primary&gt;
+     &lt;secondary&gt;view&lt;/secondary&gt;
+    &lt;/indexterm&gt;
+    &lt;indexterm&gt;
+     &lt;primary&gt;view of a container&lt;/primary&gt;
+     &lt;see&gt;container, view.&lt;/see&gt;
+    &lt;/indexterm&gt;
+ 
+ &lt;![%temporary;[
+ 
+    &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-view&quot;&gt;&lt;firstterm&gt;view of a
+    container&nbsp;&container;&lt;/firstterm&gt;&lt;/glossterm&gt; is a container
+    accessing a subset of &container;'s domain&nbsp;&containerdomain;
+    and values.  The subset can include all of&nbsp;&containerdomain;.
+    A &lt;quote&gt;view&lt;/quote&gt; is so named because it is a different way to
+    access, or view, another container's values.  Both the container
+    and its view share the same underlying engine so changing values in
+    one also changes them in the other.&lt;/para&gt;
+ 
+    &lt;para&gt;A view is created by following a container's name by
+    parentheses containing a domain&nbsp;&containerdomain;.  For
+    example, consider this code extracted from &lt;xref
+    linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt; in &lt;xref
+    linkend=&quot;tutorial-array_data_parallel&quot;&gt;&lt;/xref&gt;.
+ &lt;programlisting&gt;
+ Interval&lt;1&gt; N(0, n-1);
+ Interval&lt;2&gt; vertDomain(N, N);
+ Interval&lt;1&gt; I(1,n-2);
+ Interval&lt;1&gt; J(1,n-2);
+ Array&lt;2, double, Brick&gt; a(vertDomain);
+ Array&lt;2, double, Brick&gt; b(vertDomain);
+ a(I,J) = (1.0/9.0) *
+   (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+    b(I  ,J+1) + b(I  ,J  ) + b(I  ,J-1) +
+    b(I-1,J+1) + b(I-1,J  ) + b(I-1,J-1));
+ &lt;/programlisting&gt;  The last statement creates ten views.  For example,
+ 
+    &lt;statement&gt;a(I,J)&lt;/statement&gt; creates a view of
+    &lt;varname&gt;a&lt;/varname&gt; using the smaller domain specified by
+    &lt;varname&gt;I&lt;/varname&gt; and &lt;varname&gt;J&lt;/varname&gt;.  This omits the
+    outermost rows of columns of&nbsp;&lt;varname&gt;a&lt;/varname&gt;.  The views
+    of &lt;varname&gt;b&lt;/varname&gt; illustrate the use of views in
+    data-parallel statements.  &lt;statement&gt;b(I-1,J-1)&lt;/statement&gt; has a
+    subset shifted up one row and left one column compared with
+    &lt;statement&gt;b(I,J)&lt;/statement&gt;.&lt;/para&gt;
+ ]]&gt;  &lt;!-- end temporary --&gt;
+ &lt;![%unfinished;[
     &lt;para&gt;Be sure to list the various arithmetic operations on domains
     that can be used.  This was deferred from the &array; and domain
     chapter.  Explain &array;'s &lt;function&gt;comp&lt;/function&gt; function.&lt;/para&gt;
  
  &lt;!-- FIXME: Finish this chapter. --&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
    &lt;/chapter&gt;
  
+ 
+ &lt;![%unfinished;[
    &lt;chapter id=&quot;sequential&quot;&gt;
     &lt;title&gt;Writing Sequential Programs&lt;/title&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 1086,1095 ****
      dependence computations, so the &author; recommends calling
      &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; before each access to
      a particular value in an &array; or &field;.  Omitting a necessary
!     call may lead to a race condition.  See &lt;xref
      linkend=&quot;debugging_profiling-missing_blockandevaluate&quot;&gt;&lt;/xref&gt; for
      instructions how to diagnose and eliminate these race
!     conditions.&lt;/para&gt;
  
      &lt;para&gt;Where talk about various &pooma; streams?&lt;/para&gt;
  
--- 1158,1171 ----
      dependence computations, so the &author; recommends calling
      &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; before each access to
      a particular value in an &array; or &field;.  Omitting a necessary
!     call may lead to a race condition.
! &lt;![%unfinished;[
!     See &lt;xref
      linkend=&quot;debugging_profiling-missing_blockandevaluate&quot;&gt;&lt;/xref&gt; for
      instructions how to diagnose and eliminate these race
!     conditions.
! ]]&gt;  &lt;!-- end unfinished --&gt;
! &lt;/para&gt;
  
      &lt;para&gt;Where talk about various &pooma; streams?&lt;/para&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 1193,1199 ****
        in the input domain: A(i1, i2, ..., iN).&lt;/para&gt;
  
       &lt;para&gt;The &pooma; multidimensional Array concept is similar to
!       the &fortran; 90 array facility, but extends it in several
        ways. Both &pooma; and &fortran; arrays can have up to seven
        dimensions, and can serve as containers for arbitrary
        types. Both support the notion of views of a portion of the
--- 1269,1275 ----
        in the input domain: A(i1, i2, ..., iN).&lt;/para&gt;
  
       &lt;para&gt;The &pooma; multidimensional Array concept is similar to
!       the &fortran;&nbsp;90 array facility, but extends it in several
        ways. Both &pooma; and &fortran; arrays can have up to seven
        dimensions, and can serve as containers for arbitrary
        types. Both support the notion of views of a portion of the
*************** UNFINISHED&lt;/para&gt;
*** 1492,1498 ****
      &pooma;&nbsp;II's expression trees and expression engines.&lt;/para&gt;
  
      &lt;variablelist&gt;
!      &lt;varlistentry&gt;&lt;term&gt;&lt;type&gt;MultiPatch&lt;/type&gt; Engine&lt;/term&gt;
        &lt;listitem&gt;&lt;para&gt;From &lt;filename
        class=&quot;libraryfile&quot;&gt;README&lt;/filename&gt;: To actually use multiple
        contexts effectively, you need to use the MultiPatch engine with
--- 1568,1574 ----
      &pooma;&nbsp;II's expression trees and expression engines.&lt;/para&gt;
  
      &lt;variablelist&gt;
!      &lt;varlistentry&gt;&lt;term&gt;&multipatch; Engine&lt;/term&gt;
        &lt;listitem&gt;&lt;para&gt;From &lt;filename
        class=&quot;libraryfile&quot;&gt;README&lt;/filename&gt;: To actually use multiple
        contexts effectively, you need to use the MultiPatch engine with
*************** UNFINISHED&lt;/para&gt;
*** 1508,1515 ****
--- 1584,1593 ----
  
     &lt;/section&gt;
    &lt;/chapter&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
  
+ &lt;![%unfinished;[
    &lt;chapter id=&quot;parallel&quot;&gt;
     &lt;title&gt;Writing Distributed Programs&lt;/title&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 1562,1569 ****
--- 1640,1649 ----
     &lt;/section&gt;
  
    &lt;/chapter&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
  
+ &lt;![%unfinished;[
    &lt;chapter id=&quot;debugging_profiling&quot;&gt;
     &lt;title&gt;Debugging and Profiling &pooma; Programs&lt;/title&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 1607,1615 ****
--- 1687,1700 ----
        region's size should reveal where calls are missing.&lt;/para&gt;
      &lt;/section&gt;
    &lt;/chapter&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
+ 
  
+ &lt;![%unfinished;[
   &lt;/part&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
+ &lt;![%unfinished;[
   &lt;part id=&quot;reference&quot;&gt;
    &lt;title&gt;&pooma; Reference Manual&lt;/title&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 3489,3496 ****
--- 3574,3583 ----
     &lt;/itemizedlist&gt;
    &lt;/chapter&gt;
   &lt;/part&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
  
+ &lt;![%unfinished;[
   &lt;appendix id=&quot;future_development&quot;&gt;
    &lt;title&gt;Future Development&lt;/title&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 3610,3615 ****
--- 3697,3703 ----
    &lt;/section&gt;
  
   &lt;/appendix&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
  
   &lt;appendix id=&quot;installation&quot;&gt;
*************** UNFINISHED&lt;/para&gt;
*** 3644,3650 ****
       &lt;orderedlist spacing=&quot;compact&quot;&gt;
  	&lt;listitem&gt;
  	 &lt;para&gt;Download the library from the &pooma; Download page
!          available off the &pooma; home page (&poomaHomePage;).&lt;/para&gt;
  	&lt;/listitem&gt;
  	&lt;listitem&gt;
  	 &lt;para&gt;Extract the source code using &lt;command&gt;tar xzvf
--- 3732,3738 ----
       &lt;orderedlist spacing=&quot;compact&quot;&gt;
  	&lt;listitem&gt;
  	 &lt;para&gt;Download the library from the &pooma; Download page
!          available off the &pooma; home page (&poomahomepage;).&lt;/para&gt;
  	&lt;/listitem&gt;
  	&lt;listitem&gt;
  	 &lt;para&gt;Extract the source code using &lt;command&gt;tar xzvf
*************** UNFINISHED&lt;/para&gt;
*** 3715,3721 ****
       &lt;orderedlist spacing=&quot;compact&quot;&gt;
        &lt;listitem&gt;
         &lt;para&gt;Download the library from the &pooma; Download page
!        available off the &pooma; home page (&poomaHomePage;).&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
         &lt;para&gt;Extract the source code using &lt;command&gt;tar xzvf
--- 3803,3809 ----
       &lt;orderedlist spacing=&quot;compact&quot;&gt;
        &lt;listitem&gt;
         &lt;para&gt;Download the library from the &pooma; Download page
!        available off the &pooma; home page (&poomahomepage;).&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
         &lt;para&gt;Extract the source code using &lt;command&gt;tar xzvf
*************** UNFINISHED&lt;/para&gt;
*** 3863,3868 ****
--- 3951,3957 ----
   &lt;/appendix&gt;
  
  
+ &lt;![%unfinished;[
   &lt;appendix id=&quot;compilation_errors&quot;&gt;
    &lt;title&gt;Dealing with Compilation Errors&lt;/title&gt;
  
*************** UNFINISHED&lt;/para&gt;
*** 4039,4044 ****
--- 4128,4134 ----
    &lt;/section&gt;
  
   &lt;/appendix&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
  
   &amp;bibliography-chapter;
Index: template.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/template.xml,v
retrieving revision 1.1
diff -c -p -r1.1 template.xml
*** template.xml	2002/01/14 17:33:34	1.1
--- template.xml	2002/01/24 04:56:39
***************
*** 1,7 ****
    &lt;chapter id=&quot;template_programming&quot;&gt;
     &lt;title&gt;Programming with Templates&lt;/title&gt;
  
!    &lt;para&gt;&pooma; extensively uses &cc; templates to support type
     polymorphism without incurring any run-time cost.  In this chapter,
     we briefly introduce using templates in &cc; programs by relating
     them to &lt;quote&gt;ordinary&lt;/quote&gt; &cc; constructs such as values,
--- 1,16 ----
    &lt;chapter id=&quot;template_programming&quot;&gt;
     &lt;title&gt;Programming with Templates&lt;/title&gt;
  
!    &lt;indexterm zone=&quot;template_programming&quot;&gt;
!     &lt;primary&gt;templates&lt;/primary&gt;
!    &lt;/indexterm&gt;
!    &lt;indexterm&gt;
!     &lt;primary&gt;template programming&lt;/primary&gt;
!     &lt;see&gt;templates&lt;/see&gt;
!    &lt;/indexterm&gt;
! 
!    &lt;para&gt;&pooma; extensively uses &cc; &lt;glossterm
!    linkend=&quot;glossary-template&quot;&gt;template&lt;/glossterm&gt;s to support type
     polymorphism without incurring any run-time cost.  In this chapter,
     we briefly introduce using templates in &cc; programs by relating
     them to &lt;quote&gt;ordinary&lt;/quote&gt; &cc; constructs such as values,
***************
*** 9,69 ****
     templates will occur repeatedly:
     &lt;itemizedlist&gt;
       &lt;listitem&gt;
!       &lt;para&gt;Template programming occurs at compile time, not run time.
!       That is, template operations occur within the compiler, not when
!       a program runs.&lt;/para&gt;
       &lt;/listitem&gt;
       &lt;listitem&gt;
!       &lt;para&gt;Templates permit declaring families of classes using a
!       single declaration.  For example, the &array; template
!       declaration permits using arrays with many different value
        types, e.g., arrays of integers, arrays of floating point
        numbers, and arrays of arrays.&lt;/para&gt;
      &lt;/listitem&gt;
     &lt;/itemizedlist&gt;
!    For those interested in the implementation of &pooma;, we close
!    with a discussion of some template programming concepts used in the
!    implementation but not likely to be used by &pooma; users.&lt;/para&gt;
  
  
     &lt;section id=&quot;template_programming-compile_time&quot;&gt;
!     &lt;title&gt;Templates Occur at Compile-Time&lt;/title&gt;
  
      &lt;para&gt;&pooma; uses &cc; templates to support type polymorphism
      without incurring any run-time cost as a program executes.  All
      template operations are performed at compile time by the
      compiler.&lt;/para&gt;
  
!     &lt;para&gt;Prior to the introduction of templates, almost all a
      program's interesting computation occurred when it was executed.
      When writing the program, the programmer, at &lt;glossterm
      linkend=&quot;glossary-programming_time&quot;&gt;&lt;firstterm&gt;programming
!     time&lt;/firstterm&gt;&lt;/glossterm&gt;, would specify which statements and
!     expressions would occur and which types to use.  At &lt;glossterm
      linkend=&quot;glossary-compile_time&quot;&gt;&lt;firstterm&gt;compile
      time&lt;/firstterm&gt;&lt;/glossterm&gt;, the compiler would convert the
      program's source code into an executable program.  Even though the
      compiler uses the types to produce the executable, no interesting
      computation would occur.  At &lt;glossterm
      linkend=&quot;glossary-run_time&quot;&gt;&lt;firstterm&gt;run
!     time&lt;/firstterm&gt;&lt;/glossterm&gt;, the resulting executable program
      would actually perform the operations.&lt;/para&gt;
  
      &lt;para&gt;The introduction of templates permits interesting
      computation to occur while the compiler produces the executable.
!     Most interesting is template instantiation, which produces a type
      at compile time.  For example, the &array; &lt;quote&gt;type&lt;/quote&gt;
      definition requires template parameters &lt;varname&gt;Dim&lt;/varname&gt;,
      &lt;varname&gt;T&lt;/varname&gt;, and &lt;varname&gt;EngineTag&lt;/varname&gt;, specifying
!     its dimension, the type of its elements, and its &engine; type.  To
      use this, a programmer specifies values for the template
      parameters:
      &lt;statement&gt;&lt;type&gt;Array&lt;2,double,Brick&gt;&lt;/type&gt;&lt;/statement&gt;
!     specifies a dimension of 2, an element type of &double;, and the
!     &brick; &engine; type.  At compile time, the compiler creates a type
!     definition by substituting the values for the template parameters
!     in the template definition.  The substitution is analogous to the
!     run-time application of a function to specific values.&lt;/para&gt;
  
      &lt;para&gt;All computation not involving run-time input or output can
      occur at program time, compile time, or run time, whichever is
--- 18,107 ----
     templates will occur repeatedly:
     &lt;itemizedlist&gt;
       &lt;listitem&gt;
!       &lt;para&gt;Template programming constructs execute at compile time,
!       not run time.  That is, template operations occur within the
!       compiler, not when a program runs.&lt;/para&gt;
       &lt;/listitem&gt;
       &lt;listitem&gt;
!       &lt;para id=&quot;template_programming-introduction-main_uses-type_polymorphism&quot;&gt;Templates permit declaring families of classes using a
!       single declaration.  For example, the &array;
!       &lt;indexterm&gt;
!        &lt;primary&gt;&array;&lt;/primary&gt;
!       &lt;/indexterm&gt;
!       &lt;indexterm zone=&quot;template_programming-introduction-main_uses-type_polymorphism&quot;&gt;
!        &lt;primary&gt;type polymorphism&lt;/primary&gt;
!       &lt;/indexterm&gt;
!       template
!       declaration permits using &array;s with many different value
        types, e.g., arrays of integers, arrays of floating point
        numbers, and arrays of arrays.&lt;/para&gt;
      &lt;/listitem&gt;
     &lt;/itemizedlist&gt;
!    For those interested in the implementation of &pooma;, we close the
!    section with a discussion of some template programming concepts
!    used in the implementation but not likely to be used by &pooma;
!    users.&lt;/para&gt;
  
  
     &lt;section id=&quot;template_programming-compile_time&quot;&gt;
!     &lt;title&gt;Templates Execute at Compile-Time&lt;/title&gt;
! 
!     &lt;indexterm zone=&quot;template_programming-compile_time&quot;&gt;
!      &lt;primary&gt;compile time&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm zone=&quot;template_programming-compile_time&quot;&gt;
!      &lt;primary&gt;compiler&lt;/primary&gt;
!     &lt;/indexterm&gt;
  
      &lt;para&gt;&pooma; uses &cc; templates to support type polymorphism
      without incurring any run-time cost as a program executes.  All
      template operations are performed at compile time by the
      compiler.&lt;/para&gt;
  
!     &lt;para&gt;Prior to the introduction of templates, almost all of a
      program's interesting computation occurred when it was executed.
      When writing the program, the programmer, at &lt;glossterm
      linkend=&quot;glossary-programming_time&quot;&gt;&lt;firstterm&gt;programming
!     time&lt;/firstterm&gt;&lt;/glossterm&gt;,
!     &lt;indexterm&gt;
!      &lt;primary&gt;programming time&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     would specify which statements and expressions will occur and
!     which types to use.  At &lt;glossterm
      linkend=&quot;glossary-compile_time&quot;&gt;&lt;firstterm&gt;compile
      time&lt;/firstterm&gt;&lt;/glossterm&gt;, the compiler would convert the
      program's source code into an executable program.  Even though the
      compiler uses the types to produce the executable, no interesting
      computation would occur.  At &lt;glossterm
      linkend=&quot;glossary-run_time&quot;&gt;&lt;firstterm&gt;run
!     time&lt;/firstterm&gt;&lt;/glossterm&gt;,
!     &lt;indexterm&gt;
!      &lt;primary&gt;run time&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     the resulting executable program
      would actually perform the operations.&lt;/para&gt;
  
      &lt;para&gt;The introduction of templates permits interesting
      computation to occur while the compiler produces the executable.
!     Most interesting is template instantiation,
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;instantiation&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     which produces a type
      at compile time.  For example, the &array; &lt;quote&gt;type&lt;/quote&gt;
      definition requires template parameters &lt;varname&gt;Dim&lt;/varname&gt;,
      &lt;varname&gt;T&lt;/varname&gt;, and &lt;varname&gt;EngineTag&lt;/varname&gt;, specifying
!     its dimension, the type of its values, and its &engine; type.  To
      use this, a programmer specifies values for the template
      parameters:
      &lt;statement&gt;&lt;type&gt;Array&lt;2,double,Brick&gt;&lt;/type&gt;&lt;/statement&gt;
!     specifies a dimension of 2, a value type of &double;, and the
!     &brick; &engine; type.  At compile time, the compiler creates a
!     type definition by substituting the values for the template
!     parameters in the templatized type definition.  The substitution
!     is analogous to the run-time application of a function to specific
!     values.&lt;/para&gt;
  
      &lt;para&gt;All computation not involving run-time input or output can
      occur at program time, compile time, or run time, whichever is
***************
*** 71,83 ****
      computations by hand rather than writing code to compute it.  &cc;
      templates are Turing-complete so they can compute anything
      computable.  Unfortunately, syntax for compile-time computation is
!     more difficult than for run-time computation, and also current
      compilers are not as efficient as code executed by hardware.
!     Run-time &cc; constructs are Turing-complete so using templates is
      unnecessary.  Thus, we can shift computation to the time which
      best trades off the ease of expressing syntax with the speed of
      computation by programmer, compiler, or computer chip.  For
!     example, &pooma; uses expression template technology to speed
      run-time execution of data-parallel statements.  The &pooma;
      developers decided to shift some of the computation from run-time
      to compile-time using template computations.  The resulting
--- 109,129 ----
      computations by hand rather than writing code to compute it.  &cc;
      templates are Turing-complete so they can compute anything
      computable.  Unfortunately, syntax for compile-time computation is
!     more difficult than for run-time computation.  Also current
      compilers are not as efficient as code executed by hardware.
!     Run-time &cc; constructs are Turing-complete
!     &lt;indexterm&gt;
!      &lt;primary&gt;Turing complete&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     so using templates is
      unnecessary.  Thus, we can shift computation to the time which
      best trades off the ease of expressing syntax with the speed of
      computation by programmer, compiler, or computer chip.  For
!     example, &pooma; uses expression template technology
!     &lt;indexterm&gt;
!      &lt;primary&gt;expression templates&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     to speed
      run-time execution of data-parallel statements.  The &pooma;
      developers decided to shift some of the computation from run-time
      to compile-time using template computations.  The resulting
***************
*** 100,111 ****
         parameters, both of which are used in this book.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
!        &lt;para&gt;template instantiation, i.e., specifying a particular
!        type by specifying values for template parameters.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
!        &lt;para&gt;nested type names, which are types specified within a
!        class definition.&lt;/para&gt;
        &lt;/listitem&gt;
       &lt;/itemizedlist&gt;
      We discuss each of these below.&lt;/para&gt;
--- 146,170 ----
         parameters, both of which are used in this book.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
!        &lt;para&gt;template instantiation,
!        &lt;indexterm&gt;
! 	&lt;primary&gt;template&lt;/primary&gt;
! 	&lt;secondary&gt;instantiation&lt;/secondary&gt;
!        &lt;/indexterm&gt;
!        i.e., specifying a particular type by specifying values for
!        template parameters.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
!        &lt;para&gt;nested type names,
!        &lt;indexterm&gt;
! 	&lt;primary&gt;nested type&lt;/primary&gt;
! 	&lt;see&gt;type, nested.&lt;/see&gt;
!        &lt;/indexterm&gt;
!        &lt;indexterm&gt;
! 	&lt;primary&gt;type&lt;/primary&gt;
! 	&lt;secondary&gt;nested&lt;/secondary&gt;
!        &lt;/indexterm&gt;
!        which are types specified within a class definition.&lt;/para&gt;
        &lt;/listitem&gt;
       &lt;/itemizedlist&gt;
      We discuss each of these below.&lt;/para&gt;
***************
*** 174,179 ****
--- 233,242 ----
      brackets&nbsp;(&lt;statement&gt;&lt;&gt;&lt;/statement&gt;).  For example,
      &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; &lt;glossterm
      linkend=&quot;glossary-template_instantiation&quot;&gt;&lt;firstterm&gt;instantiates&lt;/firstterm&gt;&lt;/glossterm&gt;
+     &lt;indexterm&gt;
+      &lt;primary&gt;template&lt;/primary&gt;
+      &lt;secondary&gt;instantiation&lt;/secondary&gt;
+     &lt;/indexterm&gt;
      the &lt;classname&gt;pair&lt;/classname&gt; template class definition with
      &lt;varname&gt;T&lt;/varname&gt; equal to &int;.  That is, the compiler
      creates a definition for &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; by copying
***************
*** 184,193 ****
      The result is a definition exactly the same as
      &lt;classname&gt;pairOfInts&lt;/classname&gt;.&lt;/para&gt;
  
!      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	    orient=&quot;port&quot; pgwide=&quot;0&quot;
! 	    id=&quot;template_programming-template_use-correspondence_table&quot;&gt;
!       &lt;title&gt;Correspondences Between Run-Time and Compile-Time
       Programming Constructs&lt;/title&gt;
        
        &lt;tgroup cols=&quot;3&quot; align=&quot;left&quot;&gt;
--- 247,286 ----
      The result is a definition exactly the same as
      &lt;classname&gt;pairOfInts&lt;/classname&gt;.&lt;/para&gt;
  
!     &lt;para&gt;As we mentioned above, template instantiation
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;instantiation&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     is analogous to function application.
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;application&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     A template class is analogous to a
!     function.  The analogy between compile-time and run-time
!     programming constructs can be extended.  &lt;xref
!     linkend=&quot;template_programming-template_use-correspondence_table&quot;&gt;&lt;/xref&gt;
!     lists these correspondences.  For example, at run time, values
!     consist of things such as integers, floating point numbers,
!     pointers, functions, and objects.  Programs compute by operating
!     on these values.  The compile-time values
!     &lt;indexterm&gt;
!      &lt;primary&gt;compile time&lt;/primary&gt;
!      &lt;secondary&gt;value&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     include types, and
!     compile-time operations use these types.  For both run-time and
!     compile-time programming, &cc; defines default sets of values that
!     all conforming compilers must support.  For example,
!     &lt;statement&gt;3&lt;/statement&gt; and &lt;statement&gt;6.022e+23&lt;/statement&gt; are
!     run-time values that any &cc; compiler must accept.  It must also
!     accept the &int;, &bool;, and &lt;type&gt;int*&lt;/type&gt; types.&lt;/para&gt;
! 
!     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	   orient=&quot;port&quot; pgwide=&quot;0&quot;
! 	   id=&quot;template_programming-template_use-correspondence_table&quot;&gt;
!      &lt;title&gt;Correspondences Between Run-Time and Compile-Time
       Programming Constructs&lt;/title&gt;
        
        &lt;tgroup cols=&quot;3&quot; align=&quot;left&quot;&gt;
***************
*** 198,204 ****
  	 &lt;entry&gt;compile time&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;values&lt;/entry&gt;
  	 &lt;entry&gt;integers, strings, objects, functions, &hellip;&lt;/entry&gt;
--- 291,297 ----
  	 &lt;entry&gt;compile time&lt;/entry&gt;
  	&lt;/row&gt;
         &lt;/thead&gt;
!        &lt;tbody valign=&quot;top&quot;&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;values&lt;/entry&gt;
  	 &lt;entry&gt;integers, strings, objects, functions, &hellip;&lt;/entry&gt;
***************
*** 222,236 ****
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;packaging repeated operations&lt;/entry&gt;
! 	 &lt;entry&gt;A function generalizes a particular operation applied to
! 	different values.  The function parameters are placeholders
! 	for particular values.&lt;/entry&gt;
! 	 &lt;entry&gt;A template class generalizes a particular class
! 	definition using different types.  The template parameters are
! 	placeholders for particular values.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;application&lt;/entry&gt;
  	 &lt;entry&gt;Use a function by appending function arguments
  	surrounded by parentheses.&lt;/entry&gt;
  	 &lt;entry&gt;Use a template class by appending template arguments
--- 315,342 ----
  	&lt;/row&gt;
  	&lt;row&gt;
  	 &lt;entry&gt;packaging repeated operations&lt;/entry&gt;
! 	 &lt;entry&gt;A function
!          &lt;indexterm&gt;
!           &lt;primary&gt;function&lt;/primary&gt;
!          &lt;/indexterm&gt;
!          generalizes a particular operation applied to different
!          values.  The function parameters are placeholders for
!          particular values.&lt;/entry&gt;
!          &lt;entry&gt;A template class generalizes a particular class
!          definition using different types.  The template parameters
!          are placeholders for particular values.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;application
!          &lt;indexterm&gt;
!           &lt;primary&gt;function&lt;/primary&gt;
!           &lt;secondary&gt;application&lt;/secondary&gt;
!          &lt;/indexterm&gt;
!          &lt;indexterm&gt;
!           &lt;primary&gt;application&lt;/primary&gt;
!           &lt;see&gt;function, application.&lt;/see&gt;
!          &lt;/indexterm&gt;
!          &lt;/entry&gt;
  	 &lt;entry&gt;Use a function by appending function arguments
  	surrounded by parentheses.&lt;/entry&gt;
  	 &lt;entry&gt;Use a template class by appending template arguments
***************
*** 239,262 ****
         &lt;/tbody&gt;
        &lt;/tgroup&gt;
       &lt;/table&gt;
- 
-     &lt;para&gt;As we mentioned above, template instantiation is analogous
-     to function application.  A template class is analogous to a
-     function.  The analogy between compile-time and run-time
-     programming constructs can be extended.  &lt;xref
-     linkend=&quot;template_programming-template_use-correspondence_table&quot;&gt;&lt;/xref&gt;
-     lists these correspondences.  For example, at run time, values
-     consist of things such as integers, floating point numbers,
-     pointers, functions, and objects.  Programs compute by operating
-     on these values.  The compile-time values include types, and
-     compile-time operations use these types.  For both run-time and
-     compile-time programming, &cc; defines default sets of values that
-     all conforming compilers must support.  For example,
-     &lt;statement&gt;3&lt;/statement&gt; and &lt;statement&gt;6.022e+23&lt;/statement&gt; are
-     run-time values that any &cc; compiler must accept.  It must also
-     accept the &int;, &bool;, and &lt;type&gt;int*&lt;/type&gt; types.&lt;/para&gt;
  
!     &lt;para&gt;The set of supported run-time and compile-time values can be
      extended.  Run-time values can be extended by creating new
      objects.  Although not part of the default set of values, these
      objects are treated and operated on as values.  To extend the set
--- 345,359 ----
         &lt;/tbody&gt;
        &lt;/tgroup&gt;
       &lt;/table&gt;
  
!     &lt;para id=&quot;template_programming-template_use-extensions&quot;&gt;
!     &lt;indexterm zone=&quot;template_programming-template_use-extensions&quot;&gt;
!      &lt;primary&gt;object&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm zone=&quot;template_programming-template_use-extensions&quot;&gt;
!      &lt;primary&gt;class definition&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     The set of supported run-time and compile-time values can be
      extended.  Run-time values can be extended by creating new
      objects.  Although not part of the default set of values, these
      objects are treated and operated on as values.  To extend the set
***************
*** 268,282 ****
      built-in types, these types can be used in the same way that any
      other types can be used, e.g., declaring variables.&lt;/para&gt;
  
!     &lt;para&gt;Functions generalize similar run-time operations, while
      template class generalize similar class definitions.  A function
      definition generalizes a repeated run-time operation.  For
      example, consider repeatedly printing the largest of two numbers:
  &lt;programlisting&gt;
! std::cout &lt;&lt; (3 &gt; 4 ? 3 : 4) &lt;&lt; std::endl;
! std::cout &lt;&lt; (4 &gt; -13 ? 4 : -13) &lt;&lt; std::endl;
! std::cout &lt;&lt; (23 &gt; 4 ? 23 : 4) &lt;&lt; std::endl;
! std::cout &lt;&lt; (0 &gt; 3 ? 0 : 3) &lt;&lt; std::endl;
  &lt;/programlisting&gt;  Each statement is exactly the same except for the
  repeated two values.  Thus, we can generalize these statements writing
  a function:
--- 365,383 ----
      built-in types, these types can be used in the same way that any
      other types can be used, e.g., declaring variables.&lt;/para&gt;
  
!     &lt;para id=&quot;template_programming-template_use-functions&quot;&gt;
!     &lt;indexterm zone=&quot;template_programming-template_use-functions&quot;&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     Functions generalize similar run-time operations, while
      template class generalize similar class definitions.  A function
      definition generalizes a repeated run-time operation.  For
      example, consider repeatedly printing the largest of two numbers:
  &lt;programlisting&gt;
! std::cout &openopen; (3 &gt; 4 ? 3 : 4) &openopen; std::endl;
! std::cout &openopen; (4 &gt; -13 ? 4 : -13) &openopen; std::endl;
! std::cout &openopen; (23 &gt; 4 ? 23 : 4) &openopen; std::endl;
! std::cout &openopen; (0 &gt; 3 ? 0 : 3) &openopen; std::endl;
  &lt;/programlisting&gt;  Each statement is exactly the same except for the
  repeated two values.  Thus, we can generalize these statements writing
  a function:
*************** void maxOut(int a, int b)
*** 285,294 ****
  { std::cout &openopen; (a &gt; b ? a : b) &openopen; std::endl; }
  &lt;/programlisting&gt;  The function's body consists of the statement with
  variables substituted for the two particular values.  Each parameter
! is a placeholder that, when used, holds one particular value among the
! set of possible integral values.  The function must be named to permit
! its use, and declarations for its two parameters follow.  Using the
! function simplifies the code:
  &lt;programlisting&gt;
  maxOut(3, 4);
  maxOut(4, -13);
--- 386,395 ----
  { std::cout &openopen; (a &gt; b ? a : b) &openopen; std::endl; }
  &lt;/programlisting&gt;  The function's body consists of the statement with
  variables substituted for the two particular values.  Each parameter
! variable is a placeholder that, when used, holds one particular value
! among the set of possible integral values.  The function must be named
! to permit its use, and declarations for its two parameters follow.
! Using the function simplifies the code:
  &lt;programlisting&gt;
  maxOut(3, 4);
  maxOut(4, -13);
*************** maxOut(0, 3);
*** 298,306 ****
      parentheses surrounding specific values for its parameters, but
      the function's return type is omitted.&lt;/para&gt;
  
!     &lt;para&gt;A template class definition generalizes repeated class
      definitions.  If two class definitions differ only in a few types,
!     template parameters can be substituted.  Each parameter is a
      placeholder that, when used, holds one particular value, i.e.,
      type, among the set of possible values.  The class definition is
      named to permit its use, and declarations for its parameters
--- 399,417 ----
      parentheses surrounding specific values for its parameters, but
      the function's return type is omitted.&lt;/para&gt;
  
!     &lt;para id=&quot;template_programming-template_use-template_class&quot;&gt;
!     &lt;indexterm zone=&quot;template_programming-template_use-template_class&quot;&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;definition&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     A template class definition generalizes repeated class
      definitions.  If two class definitions differ only in a few types,
!     template parameters
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;parameter&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     can be substituted.  Each parameter is a
      placeholder that, when used, holds one particular value, i.e.,
      type, among the set of possible values.  The class definition is
      named to permit its use, and declarations for its parameters
*************** maxOut(0, 3);
*** 313,323 ****
      Note the notation for the template class parameters.
      &lt;statement&gt;template &lt;typename T&gt;&lt;/statement&gt;
      &lt;emphasis&gt;precedes&lt;/emphasis&gt; the class definition.  The keyword
!     &lt;keywordname&gt;typename&lt;/keywordname&gt; indicates the template
      parameter is a type.  &lt;varname&gt;T&lt;/varname&gt;&nbsp;is the template
      parameter's name.  (We could have used any other identifier such
      as &lt;varname&gt;pairElementType&lt;/varname&gt; or &lt;varname&gt;foo&lt;/varname&gt;.)
!     Note that using &lt;keywordname&gt;class&lt;/keywordname&gt; is equivalent to
      using &lt;keywordname&gt;typename&lt;/keywordname&gt; so &lt;statement&gt;template
      &lt;class T&gt;&lt;/statement&gt; is equivalent to &lt;statement&gt;template
      &lt;typename T&gt;&lt;/statement&gt;.  While declaring a template class
--- 424,442 ----
      Note the notation for the template class parameters.
      &lt;statement&gt;template &lt;typename T&gt;&lt;/statement&gt;
      &lt;emphasis&gt;precedes&lt;/emphasis&gt; the class definition.  The keyword
!     &lt;keywordname&gt;typename&lt;/keywordname&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;keywordname&gt;typename&lt;/keywordname&gt;&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     indicates the template
      parameter is a type.  &lt;varname&gt;T&lt;/varname&gt;&nbsp;is the template
      parameter's name.  (We could have used any other identifier such
      as &lt;varname&gt;pairElementType&lt;/varname&gt; or &lt;varname&gt;foo&lt;/varname&gt;.)
!     Note that using &lt;keywordname&gt;class&lt;/keywordname&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;keywordname&gt;class&lt;/keywordname&gt;&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     is equivalent to
      using &lt;keywordname&gt;typename&lt;/keywordname&gt; so &lt;statement&gt;template
      &lt;class T&gt;&lt;/statement&gt; is equivalent to &lt;statement&gt;template
      &lt;typename T&gt;&lt;/statement&gt;.  While declaring a template class
*************** maxOut(0, 3);
*** 327,336 ****
      for its parameters.  As we showed above,
      &lt;statement&gt;pair&lt;int&gt;&lt;/statement&gt; &lt;glossterm
      linkend=&quot;glossary-template_instantiation&quot;&gt;instantiates&lt;/glossterm&gt;
      the template class &lt;classname&gt;pair&lt;/classname&gt; with &int; for its
      type parameter&nbsp;&lt;varname&gt;T&lt;/varname&gt;.&lt;/para&gt;
  
!     &lt;para&gt;In template programming, nested type names store
      compile-time data that can be used within template classes.  Since
      compile-time class definitions are analogous to run-time objects
      and the latter stores named values, nested type names are values,
--- 446,468 ----
      for its parameters.  As we showed above,
      &lt;statement&gt;pair&lt;int&gt;&lt;/statement&gt; &lt;glossterm
      linkend=&quot;glossary-template_instantiation&quot;&gt;instantiates&lt;/glossterm&gt;
+     &lt;indexterm&gt;
+      &lt;primary&gt;template&lt;/primary&gt;
+      &lt;secondary&gt;instantiation&lt;/secondary&gt;
+     &lt;/indexterm&gt;
      the template class &lt;classname&gt;pair&lt;/classname&gt; with &int; for its
      type parameter&nbsp;&lt;varname&gt;T&lt;/varname&gt;.&lt;/para&gt;
  
!     &lt;para id=&quot;template_programming-template_use-nested_types&quot;&gt;
!     &lt;indexterm zone=&quot;template_programming-template_use-nested_types&quot;&gt;
!      &lt;primary&gt;type&lt;/primary&gt;
!      &lt;secondary&gt;nested&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;nested type&lt;/primary&gt;
!      &lt;see&gt;type, nested.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     In template programming, nested type names store
      compile-time data that can be used within template classes.  Since
      compile-time class definitions are analogous to run-time objects
      and the latter stores named values, nested type names are values,
*************** maxOut(0, 3);
*** 338,349 ****
      template class &array; has an nested type name for the type of its
      domain:
  &lt;programlisting&gt;
! 		 typedef typename Engine_t::Domain_t Domain_t;
! &lt;/programlisting&gt; This &lt;keywordname&gt;typedef&lt;/keywordname&gt;, i.e., type
      definition, defines the type &lt;type&gt;Domain_t&lt;/type&gt; as equivalent
      to &lt;type&gt;Engine_t::Domain_t&lt;/type&gt;.  The
!     &lt;operator&gt;::&lt;/operator&gt;&nbsp;operator selects the
!     &lt;type&gt;Domain_t&lt;/type&gt; nested type from inside the
      &lt;type&gt;Engine_t&lt;/type&gt; type.  This illustrates how to access
      &array;'s &lt;type&gt;Domain_t&lt;/type&gt; when not within &array;'s scope:
      &lt;type&gt;Array&lt;Dim, T, EngineTag&gt;::Domain_t&lt;/type&gt;.  The
--- 470,493 ----
      template class &array; has an nested type name for the type of its
      domain:
  &lt;programlisting&gt;
! typedef typename Engine_t::Domain_t Domain_t;
! &lt;/programlisting&gt; This &lt;keywordname&gt;typedef&lt;/keywordname&gt;,
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;keywordname&gt;typedef&lt;/keywordname&gt;&lt;/primary&gt;
!      &lt;see&gt;type, definition.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;type&lt;/primary&gt;
!      &lt;secondary&gt;definition&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     i.e., type
      definition, defines the type &lt;type&gt;Domain_t&lt;/type&gt; as equivalent
      to &lt;type&gt;Engine_t::Domain_t&lt;/type&gt;.  The
!     &lt;operator&gt;::&lt;/operator&gt;&nbsp;operator
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;operator&gt;::&lt;/operator&gt;&nbsp;operator&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     selects the &lt;type&gt;Domain_t&lt;/type&gt; nested type from inside the
      &lt;type&gt;Engine_t&lt;/type&gt; type.  This illustrates how to access
      &array;'s &lt;type&gt;Domain_t&lt;/type&gt; when not within &array;'s scope:
      &lt;type&gt;Array&lt;Dim, T, EngineTag&gt;::Domain_t&lt;/type&gt;.  The
*************** maxOut(0, 3);
*** 363,371 ****
      &poomatoolkit;.  In this section, we present template programming
      techniques used to implement &pooma;.  We extend the
      correspondence between compile-time template programming
!     constructs and run-time constructs.  Reading this section is not
!     necessary unless you wish to understand how &pooma; is
!     implemented.&lt;/para&gt;
  
      &lt;para&gt;In the previous section, we used a correspondence between
      run-time and compile-time programming constructs to introduce
--- 507,515 ----
      &poomatoolkit;.  In this section, we present template programming
      techniques used to implement &pooma;.  We extend the
      correspondence between compile-time template programming
!     constructs and run-time constructs started in the previous
!     section.  Reading this section is not necessary unless you wish to
!     understand how &pooma; is implemented.&lt;/para&gt;
  
      &lt;para&gt;In the previous section, we used a correspondence between
      run-time and compile-time programming constructs to introduce
*************** maxOut(0, 3);
*** 390,396 ****
  	&lt;entry&gt;compile time&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody&gt;
         &lt;row&gt;
  	&lt;entry&gt;values&lt;/entry&gt;
  	&lt;entry&gt;integers, strings, objects, functions, &hellip;&lt;/entry&gt;
--- 534,540 ----
  	&lt;entry&gt;compile time&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/thead&gt;
!       &lt;tbody valign=&quot;top&quot;&gt;
         &lt;row&gt;
  	&lt;entry&gt;values&lt;/entry&gt;
  	&lt;entry&gt;integers, strings, objects, functions, &hellip;&lt;/entry&gt;
*************** maxOut(0, 3);
*** 414,430 ****
  	&lt;entry&gt;values stored in a collection&lt;/entry&gt;
  	&lt;entry&gt;An object stores values.&lt;/entry&gt;
  	&lt;entry&gt;A &lt;glossterm linkend=&quot;glossary-traits_class&quot;&gt;traits
! 	class&lt;/glossterm&gt; contains values describing a type.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;extracting values from collections&lt;/entry&gt;
  	&lt;entry&gt;An object's named values are extracted using the
! 	&lt;operator&gt;.&lt;/operator&gt;&nbsp;operator&lt;/entry&gt;
  	&lt;entry&gt;A class's nested types and classes are extracted using
! 	the &lt;operator&gt;::&lt;/operator&gt;&nbsp;operator.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;control flow to choose among operations&lt;/entry&gt;
  	&lt;entry&gt;&lt;keywordname&gt;if&lt;/keywordname&gt;, &lt;keywordname&gt;while&lt;/keywordname&gt;, &lt;keywordname&gt;goto&lt;/keywordname&gt;, &hellip;&lt;/entry&gt;
  	&lt;entry&gt;template class specializations with pattern matching&lt;/entry&gt;
         &lt;/row&gt;
--- 558,595 ----
  	&lt;entry&gt;values stored in a collection&lt;/entry&gt;
  	&lt;entry&gt;An object stores values.&lt;/entry&gt;
  	&lt;entry&gt;A &lt;glossterm linkend=&quot;glossary-traits_class&quot;&gt;traits
! 	class&lt;/glossterm&gt;
!         &lt;indexterm&gt;
!          &lt;primary&gt;traits class&lt;/primary&gt;
!         &lt;/indexterm&gt;
!         &lt;indexterm&gt;
!          &lt;primary&gt;class&lt;/primary&gt;
!          &lt;secondary&gt;traits&lt;/secondary&gt;
!          &lt;see&gt;traits class&lt;/see&gt;
!         &lt;/indexterm&gt;
!         contains values describing a type.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
  	&lt;entry&gt;extracting values from collections&lt;/entry&gt;
  	&lt;entry&gt;An object's named values are extracted using the
! 	&lt;operator&gt;.&lt;/operator&gt;&nbsp;operator.
!         &lt;indexterm&gt;
!          &lt;primary&gt;&lt;operator&gt;.&lt;/operator&gt;&nbsp;operator&lt;/primary&gt;
!         &lt;/indexterm&gt;
!         &lt;/entry&gt;
  	&lt;entry&gt;A class's nested types and classes are extracted using
! 	the &lt;operator&gt;::&lt;/operator&gt;&nbsp;operator.
!         &lt;indexterm&gt;
!          &lt;primary&gt;&lt;operator&gt;::&lt;/operator&gt;&nbsp;operator&lt;/primary&gt;
!         &lt;/indexterm&gt;
!         &lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;control flow
!         &lt;indexterm&gt;
!          &lt;primary&gt;control flow&lt;/primary&gt;
!         &lt;/indexterm&gt;
!         to choose among operations&lt;/entry&gt;
  	&lt;entry&gt;&lt;keywordname&gt;if&lt;/keywordname&gt;, &lt;keywordname&gt;while&lt;/keywordname&gt;, &lt;keywordname&gt;goto&lt;/keywordname&gt;, &hellip;&lt;/entry&gt;
  	&lt;entry&gt;template class specializations with pattern matching&lt;/entry&gt;
         &lt;/row&gt;
*************** maxOut(0, 3);
*** 432,444 ****
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
!     &lt;para&gt;The only compile-time value described in the previous
!     section was types, but any compile-time constant can also be used.
      Integral literals, &lt;keywordname&gt;const&lt;/keywordname&gt; variables, and
      other constructs can be used, but the main use is enumerations.
      An &lt;glossterm
      linkend=&quot;glossary-enumeration&quot;&gt;&lt;firstterm&gt;enumeration&lt;/firstterm&gt;&lt;/glossterm&gt;
!     enumeration is a distinct integral type with named constants.  For
      example, the &array; declaration declares two separate
      enumerations:
  &lt;programlisting&gt;
--- 597,619 ----
       &lt;/tgroup&gt;
      &lt;/table&gt;
  
!     &lt;para&gt;
!     &lt;indexterm class=&quot;startofrange&quot;
! 	       id=&quot;template_programming-pooma_implementation-index-enumeration&quot;&gt;
!      &lt;primary&gt;enumeration&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm class=&quot;startofrange&quot;
! 	       id=&quot;template_programming-pooma_implementation-index-compile_time_values&quot;&gt;
!      &lt;primary&gt;compile time&lt;/primary&gt;
!      &lt;secondary&gt;value&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     The only compile-time values described in the previous
!     section were types, but any compile-time constant can also be used.
      Integral literals, &lt;keywordname&gt;const&lt;/keywordname&gt; variables, and
      other constructs can be used, but the main use is enumerations.
      An &lt;glossterm
      linkend=&quot;glossary-enumeration&quot;&gt;&lt;firstterm&gt;enumeration&lt;/firstterm&gt;&lt;/glossterm&gt;
!     is a distinct integral type with named constants.  For
      example, the &array; declaration declares two separate
      enumerations:
  &lt;programlisting&gt;
*************** enum { dimensionPlusRank = dimensions + 
*** 480,502 ****
       &lt;/listitem&gt;
      &lt;/itemizedlist&gt;
      The use of non-integral constant values such as floating-point
!     numbers at compile time is restricted.&lt;/para&gt;
! 
!     &lt;para&gt;Other compile-time values include pointers and references to
!     objects and functions and executable code.  For example, a pointer
!     to a function sometimes is passed to a template function to
!     perform a specific task.  Even though executable code cannot be
!     directly represented in a program, it is a compile-time value
!     which the compiler uses.  A simple example is a class that is
!     created by template instantiation, e.g.,
!     &lt;type&gt;pair&lt;int&gt;&lt;/type&gt;.  Conceptually, the &int; template
      argument is substituted throughout the &lt;type&gt;pair&lt;/type&gt; template
      class to produce a class definition.  Although neither the
      programmer nor the user sees this class definition, it is
      represented inside the compiler, which can use and manipulate the
      code.&lt;/para&gt;
! 
!     &lt;para&gt;Through template programming, the compiler's optimizer can
      transform complicated code into much simpler code.  In &lt;xref
      linkend=&quot;data_parallel-implementation&quot;&gt;&lt;/xref&gt;, we describe the
      complicated template code used to implement efficiently
--- 655,723 ----
       &lt;/listitem&gt;
      &lt;/itemizedlist&gt;
      The use of non-integral constant values such as floating-point
!     numbers at compile time is restricted.
!     &lt;indexterm class=&quot;endofrange&quot;
! 	       startref=&quot;template_programming-pooma_implementation-index-enumeration&quot;&gt;
!     &lt;/indexterm&gt;
!     &lt;/para&gt;
! 
!     &lt;para&gt;Other compile-time values include pointers
!     &lt;indexterm&gt;
!      &lt;primary&gt;pointer&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     to objects and
!     functions, references
!     &lt;indexterm&gt;
!      &lt;primary&gt;reference&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     to objects and functions, and executable
!     code.  For example, a pointer to a function
!     &lt;indexterm&gt;
!      &lt;primary&gt;pointer&lt;/primary&gt;
!      &lt;secondary&gt;function&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;function pointer&lt;/primary&gt;
!      &lt;see&gt;pointer, function.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     sometimes is passed to
!     a template function to perform a specific task.  Even though
!     executable code
!     &lt;indexterm&gt;
!      &lt;primary&gt;executable code&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     cannot be directly represented in a program, it is
!     a compile-time value which the compiler uses.  A simple example is
!     a class that is created by template instantiation,
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;instantiation&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     e.g., &lt;type&gt;pair&lt;int&gt;&lt;/type&gt;.  Conceptually, the &int; template
      argument is substituted throughout the &lt;type&gt;pair&lt;/type&gt; template
      class to produce a class definition.  Although neither the
      programmer nor the user sees this class definition, it is
      represented inside the compiler, which can use and manipulate the
      code.&lt;/para&gt;
!     &lt;indexterm class=&quot;endofrange&quot;
! 	       startref=&quot;template_programming-pooma_implementation-index-compile_time_values&quot;&gt;
!     &lt;/indexterm&gt;
! 
!     &lt;para id=&quot;template_programming-pooma_implementation-optimization&quot;&gt;
!     Through template programming, the compiler's optimizer
!     &lt;indexterm&gt;
!      &lt;primary&gt;optimizer&lt;/primary&gt;
!      &lt;see&gt;compiler, optimizer.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;optimization&lt;/primary&gt;
!      &lt;see&gt;compiler, optimizer.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm zone=&quot;template_programming-pooma_implementation-optimization&quot;&gt;
!      &lt;primary&gt;compiler&lt;/primary&gt;
!      &lt;secondary&gt;optimizer&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     can
      transform complicated code into much simpler code.  In &lt;xref
      linkend=&quot;data_parallel-implementation&quot;&gt;&lt;/xref&gt;, we describe the
      complicated template code used to implement efficiently
*************** struct usuallySimpleClass&lt;false&gt; {
*** 537,544 ****
      compilers that translate &cc; code into &c; code may permit
      inspecting the resulting code.  For example, using the
      &lt;option&gt;&dashdash;keep_gen_c&lt;/option&gt; command-line option with the
!     KAI &cc; compiler&lt;!-- FIXME: Reference or link? --&gt; creates a file
!     containing the result of intermediate code.  Unfortunately,
      reading and understanding the code is frequently difficult.
      Perhaps future &cc; compilers will support easy inspection of
      optimized code.&lt;/para&gt;
--- 758,775 ----
      compilers that translate &cc; code into &c; code may permit
      inspecting the resulting code.  For example, using the
      &lt;option&gt;&dashdash;keep_gen_c&lt;/option&gt; command-line option with the
!     &lt;application class=&quot;software&quot;&gt;KAI &cc; compiler&lt;/application&gt;
!     &lt;!-- FIXME: Reference or link? --&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;compiler&lt;/primary&gt;
!      &lt;secondary&gt;KAI&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;application class=&quot;software&quot;&gt;KAI &cc; compiler&lt;/application&gt;&lt;/primary&gt;
!      &lt;see&gt;compiler, KAI.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     creates a file
!     containing the intermediate code.  Unfortunately,
      reading and understanding the code is frequently difficult.
      Perhaps future &cc; compilers will support easy inspection of
      optimized code.&lt;/para&gt;
*************** struct usuallySimpleClass&lt;false&gt; {
*** 550,556 ****
      &lt;operator&gt;&gt;&lt;/operator&gt; and &lt;operator&gt;==&lt;/operator&gt;.  At run
      time, the category of strings can be compared using
      &lt;operator&gt;==&lt;/operator&gt; and characters can be extracted using
!     subscripts and the &lt;operator&gt;[]&lt;/operator&gt; operator.  Compile-time
      operations are more limited.  Types may be declared and used.  The
      &lt;keywordname&gt;sizeof&lt;/keywordname&gt; operator yields the number of
      bytes to represent an object of the specified type.  Enumerations,
--- 781,787 ----
      &lt;operator&gt;&gt;&lt;/operator&gt; and &lt;operator&gt;==&lt;/operator&gt;.  At run
      time, the category of strings can be compared using
      &lt;operator&gt;==&lt;/operator&gt; and characters can be extracted using
!     subscripts with the &lt;operator&gt;[]&lt;/operator&gt; operator.  Compile-time
      operations are more limited.  Types may be declared and used.  The
      &lt;keywordname&gt;sizeof&lt;/keywordname&gt; operator yields the number of
      bytes to represent an object of the specified type.  Enumerations,
*************** struct usuallySimpleClass&lt;false&gt; {
*** 562,582 ****
      used as template arguments.  At compile time, pointers and
      references to objects and functions can be used as template
      arguments, while the category of executable code supports no
!     operations.  (The compiler's optimizer may simplify it,
!     though.)&lt;/para&gt;
! 
!     &lt;para&gt;At run time, an object can store multiple values, each
      having its own name.  For example, a &lt;type&gt;pair&lt;int&gt;&lt;/type&gt;
      object&nbsp;&lt;varname&gt;p&lt;/varname&gt; stores two &int;s named
      &lt;methodname&gt;left_&lt;/methodname&gt; and
      &lt;methodname&gt;right_&lt;/methodname&gt;.  The &lt;operator&gt;.&lt;/operator&gt;
!     operator extracts a named member from an object:
      &lt;statement&gt;p.left_&lt;/statement&gt;.  At compile time, a class can
      store multiple values, each having its own name.  These are
      sometimes called &lt;glossterm
      linkend=&quot;glossary-traits_class&quot;&gt;&lt;firstterm&gt;traits
      classes&lt;/firstterm&gt;&lt;/glossterm&gt;.  For example, implementing
!     data-parallel operations requiring storing the a tree of types.
      The &lt;type&gt;ExpressionTraits&lt;BinaryNode&lt;Op, Left,
      Right&closeclose;&lt;/type&gt; traits class stores the types of a binary
      node representing the operation of &lt;varname&gt;Op&lt;/varname&gt; on left
--- 793,829 ----
      used as template arguments.  At compile time, pointers and
      references to objects and functions can be used as template
      arguments, while the category of executable code supports no
!     operations.  (The compiler's optimizer
!     &lt;indexterm&gt;
!      &lt;primary&gt;compiler&lt;/primary&gt;
!      &lt;secondary&gt;optimizer&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     may simplify it, though.)&lt;/para&gt;
! 
!     &lt;para id=&quot;template_programming-pooma_implementation-traits_class&quot;&gt;
!     &lt;indexterm zone=&quot;template_programming-pooma_implementation-traits_class&quot;&gt;
!      &lt;primary&gt;traits class&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     At run time, an object
!     &lt;indexterm&gt;
!      &lt;primary&gt;object&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     can store multiple values, each
      having its own name.  For example, a &lt;type&gt;pair&lt;int&gt;&lt;/type&gt;
      object&nbsp;&lt;varname&gt;p&lt;/varname&gt; stores two &int;s named
      &lt;methodname&gt;left_&lt;/methodname&gt; and
      &lt;methodname&gt;right_&lt;/methodname&gt;.  The &lt;operator&gt;.&lt;/operator&gt;
!     operator
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;operator&gt;.&lt;/operator&gt;&nbsp;operator&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     extracts a named member from an object:
      &lt;statement&gt;p.left_&lt;/statement&gt;.  At compile time, a class can
      store multiple values, each having its own name.  These are
      sometimes called &lt;glossterm
      linkend=&quot;glossary-traits_class&quot;&gt;&lt;firstterm&gt;traits
      classes&lt;/firstterm&gt;&lt;/glossterm&gt;.  For example, implementing
!     data-parallel operations requiring storing a tree of types.
      The &lt;type&gt;ExpressionTraits&lt;BinaryNode&lt;Op, Left,
      Right&closeclose;&lt;/type&gt; traits class stores the types of a binary
      node representing the operation of &lt;varname&gt;Op&lt;/varname&gt; on left
*************** struct ExpressionTraits&lt;BinaryNode&amp;lt
*** 590,629 ****
    typedef typename CombineExpressionTraits&lt;Left_t, Right_t&gt;::Type_t Type_t;
  };
  &lt;/programlisting&gt; consists of a class definition and internal type
! 
!     definitions.  This traits class contains three values, all types,
!     named &lt;type&gt;Left_t&lt;/type&gt;, &lt;type&gt;Right_t&lt;/type&gt;, and
      &lt;type&gt;Type_t&lt;/type&gt;, representing the type of the left child, the
!     right child, and the entire node, respectively.  No enumerations
!     or constant values occur.  See &lt;xref
      linkend=&quot;data_parallel-implementation&quot;&gt;&lt;/xref&gt; for more details
!     regarding the implementation of data-parallel operators.  Many
!     traits classes, such as this one, use internal type definitions to
!     store values.&lt;/para&gt;
! 
!     &lt;para&gt;The example also illustrates using the
!     &lt;operator&gt;::&lt;/operator&gt; operator to extract a member of a traits
!     class.  The type &lt;type&gt;ExpressionTraits&lt;Left&gt;&lt;/type&gt;
!     contains an internal type definition of &lt;type&gt;Type_t&lt;/type&gt;.
!     Using the &lt;operator&gt;::&lt;/operator&gt; operator extracts it:
      &lt;statement&gt;ExpressionTraits&lt;Left&gt;::Type_t&lt;/statement&gt;.
      Enumerations and other values can also be extracted.  For example,
      &lt;statement&gt;Array&lt;2, int, Brick&gt;::dimensions&lt;/statement&gt;
      yields the dimension of the array's domain.&lt;/para&gt;
  
!     &lt;para&gt;Control flow determines which code is used.  At run time,
      control-flow statements such as &lt;keywordname&gt;if&lt;/keywordname&gt;,
      &lt;keywordname&gt;while&lt;/keywordname&gt;, and
      &lt;keywordname&gt;goto&lt;/keywordname&gt; determine which statements to
      execute.  Template programming uses two mechanisms: template class
      specializations and pattern matching.  These are similar to
!     control flow for functional programming languages.  A &lt;glossterm
      linkend=&quot;glossary-traits_class&quot;&gt;&lt;firstterm&gt;template class
      specialization&lt;/firstterm&gt;&lt;/glossterm&gt; is a class definition
      specific to one or more template arguments.  For example, the
!     implementation for data-parallel operations uses the templated
!     &lt;type&gt;CreateLeaf&lt;/type&gt;.  The default definition works for any
!     template argument&nbsp;&lt;varname&gt;T&lt;/varname&gt;:
  &lt;programlisting&gt;
  template&lt;class T&gt;
  struct CreateLeaf
--- 837,891 ----
    typedef typename CombineExpressionTraits&lt;Left_t, Right_t&gt;::Type_t Type_t;
  };
  &lt;/programlisting&gt; consists of a class definition and internal type
!     definitions.  This traits class contains three values, all types
!     and named &lt;type&gt;Left_t&lt;/type&gt;, &lt;type&gt;Right_t&lt;/type&gt;, and
      &lt;type&gt;Type_t&lt;/type&gt;, representing the type of the left child, the
!     right child, and the entire node, respectively.  Many traits
!     classes, such as this one, use internal type definitions to store
!     values.  No enumerations or constant values occur in this traits
!     class, but other such classes include them.  See &lt;xref
      linkend=&quot;data_parallel-implementation&quot;&gt;&lt;/xref&gt; for more details
!     regarding the implementation of data-parallel operators.&lt;/para&gt;
! 
!     &lt;para id=&quot;template_programming-pooma_implementation-double_colon_operator&quot;&gt;
!     &lt;indexterm zone=&quot;template_programming-pooma_implementation-double_colon_operator&quot;&gt;
!      &lt;primary&gt;&lt;operator&gt;::&lt;/operator&gt;&nbsp;operator&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     The example also illustrates using the &lt;operator&gt;::&lt;/operator&gt;
!     operator to extract a member of a traits class.  The type
!     &lt;type&gt;ExpressionTraits&lt;Left&gt;&lt;/type&gt; contains an internal
!     type definition of &lt;type&gt;Type_t&lt;/type&gt;.  Using the
!     &lt;operator&gt;::&lt;/operator&gt; operator extracts it:
      &lt;statement&gt;ExpressionTraits&lt;Left&gt;::Type_t&lt;/statement&gt;.
      Enumerations and other values can also be extracted.  For example,
      &lt;statement&gt;Array&lt;2, int, Brick&gt;::dimensions&lt;/statement&gt;
      yields the dimension of the array's domain.&lt;/para&gt;
  
!     &lt;para id=&quot;template_programming-pooma_implementation-template_specialization&quot;&gt;
!     &lt;indexterm zone=&quot;template_programming-pooma_implementation-template_specialization&quot;&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;specialization&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm class=&quot;startofrange&quot; id=&quot;template_programming-pooma_implementation-index-control_flow&quot;&gt;
!      &lt;primary&gt;control flow&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     Control flow determines which code is used.  At run time,
      control-flow statements such as &lt;keywordname&gt;if&lt;/keywordname&gt;,
      &lt;keywordname&gt;while&lt;/keywordname&gt;, and
      &lt;keywordname&gt;goto&lt;/keywordname&gt; determine which statements to
      execute.  Template programming uses two mechanisms: template class
      specializations and pattern matching.  These are similar to
!     control flow in functional programming languages.  A &lt;glossterm
      linkend=&quot;glossary-traits_class&quot;&gt;&lt;firstterm&gt;template class
      specialization&lt;/firstterm&gt;&lt;/glossterm&gt; is a class definition
      specific to one or more template arguments.  For example, the
!     implementation for data-parallel operations
!     &lt;indexterm&gt;
!      &lt;primary&gt;data-parallel operation&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     uses the templated &lt;type&gt;CreateLeaf&lt;/type&gt;.  The default
!     definition works for any template
!     argument&nbsp;&lt;varname&gt;T&lt;/varname&gt;:
  &lt;programlisting&gt;
  template&lt;class T&gt;
  struct CreateLeaf
*************** struct CreateLeaf&lt;Expression&lt;T&amp;clo
*** 644,650 ****
      &lt;type&gt;CreateLeaf&lt;/type&gt;'s template argument is an
      &lt;type&gt;Expression&lt;/type&gt; type.&lt;/para&gt;
  
!     &lt;para&gt;Pattern matching of template arguments to template
      parameters determines which template code is used.  The code
      associated with the match that is most specific is the one that is
      used.  For example, &lt;type&gt;CreateLeaf&lt;int&gt;&lt;/type&gt; uses the
--- 906,921 ----
      &lt;type&gt;CreateLeaf&lt;/type&gt;'s template argument is an
      &lt;type&gt;Expression&lt;/type&gt; type.&lt;/para&gt;
  
!     &lt;para id=&quot;template_programming-pooma_implementation-pattern_matching&quot;&gt;
!     &lt;indexterm zone=&quot;template_programming-pooma_implementation-pattern_matching&quot;&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;pattern matching&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;pattern matching&lt;/primary&gt;
!      &lt;see&gt;template, pattern matching.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     Pattern matching of template arguments to template
      parameters determines which template code is used.  The code
      associated with the match that is most specific is the one that is
      used.  For example, &lt;type&gt;CreateLeaf&lt;int&gt;&lt;/type&gt; uses the
*************** struct CreateLeaf&lt;Expression&lt;T&amp;clo
*** 663,672 ****
  
      &lt;para&gt;Control flow using template specializations and pattern
      matching is similar to &lt;keywordname&gt;switch&lt;/keywordname&gt;
!     statements.  A &lt;keywordname&gt;switch&lt;/keywordname&gt; statement has a
      condition and one or more pairs of case labels and associated
      code.  The code associated with the the case label whose value
!     matched the condition is executed.  If no case label matches the
      condition, the default code, if present, is used.  In template
      programming, instantiating a template, e.g.,
      &lt;type&gt;CreateLeaf&lt;Expression&lt;int&closeclose;&lt;/type&gt; serves as
--- 934,947 ----
  
      &lt;para&gt;Control flow using template specializations and pattern
      matching is similar to &lt;keywordname&gt;switch&lt;/keywordname&gt;
!     statements.
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;keywordname&gt;switch&lt;/keywordname&gt;&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     A &lt;keywordname&gt;switch&lt;/keywordname&gt; statement has a
      condition and one or more pairs of case labels and associated
      code.  The code associated with the the case label whose value
!     matches the condition is executed.  If no case label matches the
      condition, the default code, if present, is used.  In template
      programming, instantiating a template, e.g.,
      &lt;type&gt;CreateLeaf&lt;Expression&lt;int&closeclose;&lt;/type&gt; serves as
*************** struct CreateLeaf&lt;Expression&lt;T&amp;clo
*** 681,689 ****
      default label since it matches any arguments.  If no set of
      template parameters match (which is impossible for our example) or
      if more than one set are best matches, the code is
!     incorrect.&lt;/para&gt;
! 
!     &lt;para&gt;Functions as well as classes may be templated.  All the
      concepts needed to understand function templates have already been
      introduced so we illustrate using an example.  The templated
      function &lt;function&gt;f&lt;/function&gt; takes one parameter of any type:
--- 956,975 ----
      default label since it matches any arguments.  If no set of
      template parameters match (which is impossible for our example) or
      if more than one set are best matches, the code is
!     incorrect.
!     &lt;indexterm class=&quot;endofrange&quot; startref=&quot;template_programming-pooma_implementation-index-control_flow&quot;&gt;
!     &lt;/indexterm&gt;&lt;/para&gt;
! 
!     &lt;para&gt;
!     &lt;indexterm class=&quot;startofrange&quot; id=&quot;template_programming-pooma_implementation-function_template&quot;&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;function&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;function template&lt;/primary&gt;
!      &lt;see&gt;function, template.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     Functions as well as classes may be templated.  All the
      concepts needed to understand function templates have already been
      introduced so we illustrate using an example.  The templated
      function &lt;function&gt;f&lt;/function&gt; takes one parameter of any type:
*************** void f(const T&amp; t) { &hellip; }
*** 697,704 ****
      functions equivalent to &lt;function&gt;f(const int&amp;amp)&lt;/function&gt;,
      &lt;function&gt;f(const bool&amp;amp)&lt;/function&gt;, &lt;function&gt;f(const
      int*&amp;amp)&lt;/function&gt;, &hellip;.  Using a templated class
!     definition with a static member function, we can define an
!     equivalent function:
  &lt;programlisting&gt;
  template &lt;typename T&gt;
  class F {
--- 983,1008 ----
      functions equivalent to &lt;function&gt;f(const int&amp;amp)&lt;/function&gt;,
      &lt;function&gt;f(const bool&amp;amp)&lt;/function&gt;, &lt;function&gt;f(const
      int*&amp;amp)&lt;/function&gt;, &hellip;.  Using a templated class
!     definition with a static member function,
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;static member&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;static member function&lt;/primary&gt;
!      &lt;see&gt;function, static member&lt;/see&gt;
!     &lt;/indexterm&gt;
!     we can define an equivalent function:
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;static member&lt;/secondary&gt;
!      &lt;tertiary&gt;equivalence with function template&lt;/tertiary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;function&lt;/secondary&gt;
!      &lt;tertiary&gt;equivalence with static member function&lt;/tertiary&gt;
!     &lt;/indexterm&gt;
  &lt;programlisting&gt;
  template &lt;typename T&gt;
  class F {
*************** class F {
*** 706,735 ****
  };
  &lt;/programlisting&gt;  Both the templated class and the templated function
      take the same template arguments, but the class uses a static
!     member function so the notation to invoke it is slightly more
!     verbose: &lt;statement&gt;F&lt;T&gt;::f(t)&lt;/statement&gt;.  The advantage
!     of a function template is that it can be overloaded, particularly
!     operator functions.  For example, the &lt;operator&gt;+&lt;/operator&gt;
!     operator is overloaded to add two &array;s, which require template
!     parameters to specify:
  &lt;programlisting&gt;
  template &lt;int D1,class T1,class E1,int D2,class T2,class E2&gt;
  // complicated return type omitted
  operator+(const Array&lt;D1,T1,E1&gt; &amp; l,const Array&lt;D2,T2,E2&gt; &amp; r);
  &lt;/programlisting&gt;  Without using function templates, it would not be
- 
      possible to write expressions such as &lt;statement&gt;a1 +
      a2&lt;/statement&gt;.  Member functions can also be templated.  This
      permits, for example, overloading of assignment operators defined
!     within templated classes.&lt;/para&gt;
! 
!     &lt;para&gt;Function objects are frequently useful in run-time code.
      They consist of a function plus some additional storage and are
      usually implemented as structures with data members and a function
!     call operator.  Analogous classes can be used at compile time.
!     Using the transformation introduced in the previous paragraph, we
      see that any function can be transformed into a class containing a
!     static member function.  Internal type definitions, enumerations,
      and static constant values can be added to the class.  The static
      member function can use these values during its computation.  The
      &lt;type&gt;CreateLeaf&lt;/type&gt; structure, introduced above, illustrates this.
--- 1010,1077 ----
  };
  &lt;/programlisting&gt;  Both the templated class and the templated function
      take the same template arguments, but the class uses a static
!     member function.  Thus, the notation to invoke it is slightly more
!     verbose: &lt;statement&gt;F&lt;T&gt;::f(t)&lt;/statement&gt;.&lt;/para&gt;
! 
!     &lt;para id=&quot;template_programming-pooma_implementation-function_template-overloaded&quot;&gt;
!     &lt;indexterm zone=&quot;template_programming-pooma_implementation-function_template-overloaded&quot;&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;overloaded&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm zone=&quot;template_programming-pooma_implementation-function_template-overloaded&quot;&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;operator&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     The advantage of a function template is that it can be overloaded,
!     particularly operator functions.  For example, the
!     &lt;operator&gt;+&lt;/operator&gt; operator is overloaded to add two &array;s,
!     which require template parameters to specify:
  &lt;programlisting&gt;
  template &lt;int D1,class T1,class E1,int D2,class T2,class E2&gt;
  // complicated return type omitted
  operator+(const Array&lt;D1,T1,E1&gt; &amp; l,const Array&lt;D2,T2,E2&gt; &amp; r);
  &lt;/programlisting&gt;  Without using function templates, it would not be
      possible to write expressions such as &lt;statement&gt;a1 +
      a2&lt;/statement&gt;.  Member functions can also be templated.  This
      permits, for example, overloading of assignment operators defined
!     within templated classes.
!     &lt;indexterm class=&quot;endofrange&quot; startref=&quot;template_programming-pooma_implementation-function_template&quot;&gt;
!     &lt;/indexterm&gt;
!     &lt;/para&gt;
! 
!     &lt;para&gt;Function objects
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;object&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     are frequently useful in run-time code.
      They consist of a function plus some additional storage and are
      usually implemented as structures with data members and a function
!     call operator.
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;call operator&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     Analogous classes can be used at compile time.
!     Using the transformation
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;static member&lt;/secondary&gt;
!      &lt;tertiary&gt;equivalence with function template&lt;/tertiary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;function&lt;/secondary&gt;
!      &lt;tertiary&gt;equivalence with static member function&lt;/tertiary&gt;
!     &lt;/indexterm&gt;
!     introduced in the previous paragraph, we
      see that any function can be transformed into a class containing a
!     static member function.
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;static member&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     Internal type definitions, enumerations,
      and static constant values can be added to the class.  The static
      member function can use these values during its computation.  The
      &lt;type&gt;CreateLeaf&lt;/type&gt; structure, introduced above, illustrates this.
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.6
diff -c -p -r1.6 tutorial.xml
*** tutorial.xml	2002/01/22 15:48:49	1.6
--- tutorial.xml	2002/01/24 04:56:40
***************
*** 1,17 ****
  &lt;chapter id=&quot;tutorial&quot;&gt;
   &lt;title&gt;A Tutorial Introduction&lt;/title&gt;
  
-  &lt;para&gt;UPDATE: In the following paragraph, fix the cross-reference
-  to the actual section.&lt;/para&gt;
- 
   &lt;para&gt;&pooma; provides different containers and processor
   configurations and supports different implementation styles, as
!  described in &lt;xref linkend=&quot;introduction&quot;&gt;&lt;/xref&gt;.  In this
!  chapter, we present several different implementations of the
!  &amp;doof2d; two-dimensional diffusion simulation program:
    &lt;itemizedlist spacing=&quot;compact&quot;&gt;
     &lt;listitem&gt;
!     &lt;para&gt;a C-style implementation omitting any use of &pooma;
      computing each array element individually,&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
--- 1,15 ----
+ &lt;!-- FIXME: Index this file. --&gt;
  &lt;chapter id=&quot;tutorial&quot;&gt;
   &lt;title&gt;A Tutorial Introduction&lt;/title&gt;
  
   &lt;para&gt;&pooma; provides different containers and processor
   configurations and supports different implementation styles, as
!  described in &lt;xref linkend=&quot;introduction-goals&quot;&gt;&lt;/xref&gt;.  In this
!  chapter, we present several different implementations of the &amp;doof2d;
!  two-dimensional diffusion simulation program:
    &lt;itemizedlist spacing=&quot;compact&quot;&gt;
     &lt;listitem&gt;
!     &lt;para&gt;a C-style implementation omitting any use of &pooma; and
      computing each array element individually,&lt;/para&gt;
     &lt;/listitem&gt;
     &lt;listitem&gt;
***************
*** 40,52 ****
     &lt;/listitem&gt;
    &lt;/itemizedlist&gt;
   &lt;/para&gt;
!  &lt;para&gt;These illustrate the &array;, &field;, &engine;, layout,
!  mesh, and domain data types.  They also illustrate various
!  immediate computation styles (element-wise accesses, data-parallel
!  expressions, and stencil computation) and various processor
!  configurations (one sequential processor and multiple
!  processors).&lt;/para&gt;
  
   &lt;figure float=&quot;1&quot; id=&quot;tutorial-doof2d_averagings&quot;&gt;
    &lt;title&gt;&amp;doof2d; Averagings&lt;/title&gt;
    &lt;mediaobject&gt;
--- 38,68 ----
     &lt;/listitem&gt;
    &lt;/itemizedlist&gt;
   &lt;/para&gt;
!  &lt;para&gt;These illustrate the &array;, &field;, &engine;, layout, mesh,
!  and &domain; data types.  They also illustrate various immediate
!  computation styles (element-wise accesses, data-parallel expressions,
!  and stencil computation) and various processor configurations (one
!  processor and multiple processors).&lt;/para&gt;
! 
!  &lt;para&gt;The &amp;doof2d; diffusion program starts with a two-dimensional
!  grid of values.  To model an initial density, all grid values are
!  zero except for one nonzero value in the center.  Each averaging,
!  each grid element, except the outermost ones, updates its value by
!  averaging its value and its eight neighbors.  To avoid overwriting
!  grid values before all their uses occur, we use two arrays, reading
!  the first and writing the second and then reversing their roles
!  within each iteration.&lt;/para&gt;
! 
!  &lt;para&gt;We illustrate the averagings in &lt;xref
!  linkend=&quot;tutorial-doof2d_averagings&quot;&gt;&lt;/xref&gt;.  Initially, only the
!  center element has nonzero value.  To form the first averaging, each
!  element's new value equals the average of its and its neighbors'
!  previous values.  Thus, the initial nonzero value spreads to a
!  three-by-three grid.  The averaging continues, spreading to a
!  five-by-five grid of nonzero values.  Values in the outermost grid cells
!  are always zero.&lt;/para&gt;
  
+ &lt;!-- FIXME: Fix the layout, somehow. --&gt;
   &lt;figure float=&quot;1&quot; id=&quot;tutorial-doof2d_averagings&quot;&gt;
    &lt;title&gt;&amp;doof2d; Averagings&lt;/title&gt;
    &lt;mediaobject&gt;
***************
*** 75,177 ****
    &lt;/mediaobject&gt;
   &lt;/figure&gt;
  
!  &lt;para&gt;The &amp;doof2d; diffusion program starts with a two-dimensional
!  grid of values.  To model an initial density, all grid values are
!  zero except for one nonzero value in the center.  Each averaging,
!  each grid element, except the outermost ones, updates its value by
!  averaging its value and its eight neighbors.  To avoid overwriting
!  grid values before all their uses occur, we use two arrays, reading
!  the first and writing the second and then reversing their roles
!  within each iteration.&lt;/para&gt;
! 
!  &lt;para&gt;Figure &lt;xref linkend=&quot;tutorial-doof2d_averagings&quot;&gt;&lt;/xref&gt;
!  illustrates the averagings.  Initially, only the center element has
!  nonzero value.  To form the first averaging, each element's new
!  value equals the average of its and its neighbors' previous values.
!  Thus, the initial nonzero value spreads to a three-by-three grid.
!  The averaging continues, spreading to a five-by-five grid of
!  nonzero values.  Values in outermost grid cells are always
!  zero.&lt;/para&gt;
! 
!  &lt;para&gt;Before presenting various implementations of %doof2d;, we
   explain how to install the &poomatoolkit;.&lt;/para&gt;
  
   &lt;para&gt;REMOVE: &amp;doof2d; algorithm and code is illustrated in
   Section&nbsp;4.1 of
   &lt;filename&gt;pooma-publications/pooma.ps&lt;/filename&gt;.  It includes a
   figure illustrating parallel communication of data.&lt;/para&gt;
  
   &lt;section id=&quot;tutorial-installation&quot;&gt;
    &lt;title&gt;Installing &pooma;&lt;/title&gt;
  
    &lt;para&gt;ADD: How does one install &pooma; using Windows or Mac?&lt;/para&gt;
  
    &lt;para&gt;UPDATE: Make a more recent &pooma; source code file
!   available on &poomaDownloadPage;.  For example,
    &lt;quote&gt;LINUXgcc.conf&lt;/quote&gt; is not available.&lt;/para&gt;
  
    &lt;para&gt;In this section, we describe how to obtain, build, and
    install the &poomatoolkit;.  We focus on installing under the
!   Unix operating system.  Instructions for installing on computers
    running Microsoft Windows or MacOS, as well as more extensive
    instructions for Unix, appear in &lt;xref
!   linkend=&quot;installation&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
    &lt;para&gt;Obtain the &pooma; source code &lt;filename
!   path=&quot;<A HREF="http://www.codesourcery.com/pooma/downloads_folder/">http://www.codesourcery.com/pooma/downloads_folder/</A>&quot;&gt;&poomaSourceFile;&lt;/filename&gt;
!   from the &pooma; download page (&poomaDownloadPage;) available off
!   the &pooma; home page (&poomaHomePage;).  The &lt;quote&gt;tgz&lt;/quote&gt;
    indicates this is a compressed tar archive file.  To extract the
!   source files, use &lt;command&gt;tar xzvf &poomaSourceFile;&lt;/command&gt;.
    Move into the source code directory &lt;filename
!   class=&quot;directory&quot;&gt;&poomaSource;&lt;/filename&gt; directory; e.g.,
!   &lt;command&gt;cd &poomaSource;&lt;/command&gt;.&lt;/para&gt;
  
!   &lt;para&gt;Configuring the source code prepares the necessary paths for
!   compilation.  First, determine a configuration file in
!   corresponding to your operating system and compiler in the
!   &lt;filename class=&quot;directory&quot;&gt;config/arch/&lt;/filename&gt; directory.
!   For example, &lt;filename
    class=&quot;libraryfile&quot;&gt;LINUXgcc.conf&lt;/filename&gt; supports compiling
!   under a &linux; operating system with &gcc; and &lt;filename
    class=&quot;libraryfile&quot;&gt;SGI64KCC.conf&lt;/filename&gt; supports compiling
!   under a 64-bit &lt;application&gt;SGI&lt;/application&gt; Unix operating
!   system with &kcc;.  Then, configure the source code:
!   &lt;command&gt;./configure &dashdash;arch LINUXgcc &dashdash;opt &dashdash;suite
    LINUXgcc-opt&lt;/command&gt;.  The architecture argument to the
!   &lt;command&gt;&dashdash;arch&lt;/command&gt; option is the name of the corresponding
!   configuration file, omitting its &lt;filename
    class=&quot;libraryfile&quot;&gt;.conf&lt;/filename&gt; suffix.  The
    &lt;command&gt;&dashdash;opt&lt;/command&gt; indicates the &poomatoolkit; will
!   contain optimized source code, which makes the code run more
!   quickly but may impede debugging.  Alternatively, the
!   &lt;command&gt;&dashdash;debug&lt;/command&gt; option supports debugging.  The
!   &lt;glossterm linkend=&quot;glossary-suite_name&quot;&gt;suite name&lt;/glossterm&gt;
    can be any arbitrary string.  We chose
!   &lt;command&gt;LINUXgcc-opt&lt;/command&gt; to remind us of the architecture
!   and optimization choice.  &lt;filename
    class=&quot;libraryfile&quot;&gt;configure&lt;/filename&gt; creates subdirectories
!   named by the suite name &lt;quote&gt;LINUXgcc-opt&lt;/quote&gt; for use when
!   compiling the source files.  Comments at the beginning of
!   &lt;filename
    class=&quot;libraryfile&quot;&gt;lib/&lt;replaceable&gt;suiteName&lt;/replaceable&gt;/PoomaConfiguration.h&lt;/filename&gt;
    record the configuration arguments.&lt;/para&gt;
  
!   &lt;para&gt;To compile the source code, set the
!   &lt;envar&gt;POOMASUITE&lt;/envar&gt; environment variable to the suite name
!   and then type &lt;command&gt;make&lt;/command&gt;.  To set the environment
!   variable for the &lt;application&gt;bash&lt;/application&gt; shell use
!   &lt;command&gt;export
    POOMASUITE=&lt;replaceable&gt;suiteName&lt;/replaceable&gt;&lt;/command&gt;,
!   substituting the suite name's
!   &lt;replaceable&gt;suiteName&lt;/replaceable&gt;.  For the
!   &lt;application&gt;csh&lt;/application&gt; shell, use &lt;command&gt;setenv
    POOMASUITE LINUXgcc-opt&lt;/command&gt;.  Issuing the
    &lt;command&gt;make&lt;/command&gt; command compiles the &pooma; source code
    files to create the &pooma; library.  The &pooma; makefiles assume
!   the &lt;trademark&gt;GNU&lt;/trademark&gt; &make; so substitute the proper
!   command if necessary.  The &pooma; library can be found in, e.g.,
!   &lt;filename
    class=&quot;libraryfile&quot;&gt;lib/LINUXgcc-opt/libpooma-gcc.a&lt;/filename&gt;.&lt;/para&gt;
   &lt;/section&gt;
  
--- 91,183 ----
    &lt;/mediaobject&gt;
   &lt;/figure&gt;
  
!  &lt;para&gt;Before presenting the various implementations of &amp;doof2d;, we
   explain how to install the &poomatoolkit;.&lt;/para&gt;
  
+ &lt;![%unfinished;[
   &lt;para&gt;REMOVE: &amp;doof2d; algorithm and code is illustrated in
   Section&nbsp;4.1 of
   &lt;filename&gt;pooma-publications/pooma.ps&lt;/filename&gt;.  It includes a
   figure illustrating parallel communication of data.&lt;/para&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
+ 
   &lt;section id=&quot;tutorial-installation&quot;&gt;
    &lt;title&gt;Installing &pooma;&lt;/title&gt;
  
+ &lt;![%unfinished;[
    &lt;para&gt;ADD: How does one install &pooma; using Windows or Mac?&lt;/para&gt;
  
    &lt;para&gt;UPDATE: Make a more recent &pooma; source code file
!   available on &poomadownloadpage;.  For example,
    &lt;quote&gt;LINUXgcc.conf&lt;/quote&gt; is not available.&lt;/para&gt;
+ ]]&gt;  &lt;!-- end unfinished --&gt;
  
    &lt;para&gt;In this section, we describe how to obtain, build, and
    install the &poomatoolkit;.  We focus on installing under the
!   Unix operating system.
! &lt;![%unfinished;[
!   Instructions for installing on computers
    running Microsoft Windows or MacOS, as well as more extensive
    instructions for Unix, appear in &lt;xref
!   linkend=&quot;installation&quot;&gt;&lt;/xref&gt;.
! ]]&gt;  &lt;!-- end unfinished --&gt;
!   &lt;/para&gt;
  
    &lt;para&gt;Obtain the &pooma; source code &lt;filename
!   path=&quot;<A HREF="http://www.codesourcery.com/pooma/downloads_folder/">http://www.codesourcery.com/pooma/downloads_folder/</A>&quot;&gt;&poomasourcefile;&lt;/filename&gt;
!   from the &pooma; download page (&poomadownloadpage;) available off
!   the &pooma; home page (&poomahomepage;).  The &lt;quote&gt;tgz&lt;/quote&gt;
    indicates this is a compressed tar archive file.  To extract the
!   source files, use &lt;command&gt;tar xzvf &poomasourcefile;&lt;/command&gt;.
    Move into the source code directory &lt;filename
!   class=&quot;directory&quot;&gt;&poomasource;&lt;/filename&gt; directory; e.g.,
!   &lt;command&gt;cd &poomasource;&lt;/command&gt;.&lt;/para&gt;
  
!   &lt;para&gt;Configuring the source code determines file names needed for
!   compilation.  First, determine a configuration file in the &lt;filename
!   class=&quot;directory&quot;&gt;config/arch/&lt;/filename&gt; directory corresponding to
!   your operating system and compiler.  For example, &lt;filename
    class=&quot;libraryfile&quot;&gt;LINUXgcc.conf&lt;/filename&gt; supports compiling
!   under a &linux; operating system with &gcc;, while &lt;filename
    class=&quot;libraryfile&quot;&gt;SGI64KCC.conf&lt;/filename&gt; supports compiling
!   under a 64-bit &lt;application&gt;SGI&lt;/application&gt; Unix operating system
! &lt;!-- FIXME: Center the following command. --&gt;
!   with &kcc;.  Next, configure the source code: &lt;command&gt;./configure
!   &dashdash;arch LINUXgcc &dashdash;opt &dashdash;suite
    LINUXgcc-opt&lt;/command&gt;.  The architecture argument to the
!   &lt;command&gt;&dashdash;arch&lt;/command&gt; option is the name of the
!   corresponding configuration file, omitting its &lt;filename
    class=&quot;libraryfile&quot;&gt;.conf&lt;/filename&gt; suffix.  The
    &lt;command&gt;&dashdash;opt&lt;/command&gt; indicates the &poomatoolkit; will
!   contain optimized source code, which makes the code run more quickly
!   but may impede debugging.  Alternatively, use the
!   &lt;command&gt;&dashdash;debug&lt;/command&gt; option which supports debugging.
!   The &lt;glossterm linkend=&quot;glossary-suite_name&quot;&gt;suite name&lt;/glossterm&gt;
    can be any arbitrary string.  We chose
!   &lt;command&gt;LINUXgcc-opt&lt;/command&gt; to remind us of the architecture and
!   optimization choice.  &lt;filename
    class=&quot;libraryfile&quot;&gt;configure&lt;/filename&gt; creates subdirectories
!   named &lt;quote&gt;LINUXgcc-opt&lt;/quote&gt; for use when compiling the source
!   files.  Comments at the beginning of &lt;filename
    class=&quot;libraryfile&quot;&gt;lib/&lt;replaceable&gt;suiteName&lt;/replaceable&gt;/PoomaConfiguration.h&lt;/filename&gt;
    record the configuration arguments.&lt;/para&gt;
  
!   &lt;para&gt;To compile the source code, set the &lt;envar&gt;POOMASUITE&lt;/envar&gt;
!   environment variable to the suite name and then type
!   &lt;command&gt;make&lt;/command&gt;.  To set the environment variable for the
! &lt;!-- FIXME: Center the following command. --&gt;
!   &lt;application&gt;bash&lt;/application&gt; shell use &lt;command&gt;export
    POOMASUITE=&lt;replaceable&gt;suiteName&lt;/replaceable&gt;&lt;/command&gt;,
!   substituting the suite name's &lt;replaceable&gt;suiteName&lt;/replaceable&gt;.
! &lt;!-- FIXME: Center the following command. --&gt;
!   For the &lt;application&gt;csh&lt;/application&gt; shell, use &lt;command&gt;setenv
    POOMASUITE LINUXgcc-opt&lt;/command&gt;.  Issuing the
    &lt;command&gt;make&lt;/command&gt; command compiles the &pooma; source code
    files to create the &pooma; library.  The &pooma; makefiles assume
!   the &lt;trademark&gt;GNU&lt;/trademark&gt; &make; is available so substitute the
!   proper command to run &lt;trademark&gt;GNU&lt;/trademark&gt; &make; if
!   necessary.  The &pooma; library can be found in, e.g., &lt;filename
    class=&quot;libraryfile&quot;&gt;lib/LINUXgcc-opt/libpooma-gcc.a&lt;/filename&gt;.&lt;/para&gt;
   &lt;/section&gt;
  
***************
*** 181,209 ****
    &lt;para&gt;Before implementing &amp;doof2d; using the &poomatoolkit;, we
    present a hand-coded implementation of &amp;doof2d;.  See &lt;xref
    linkend=&quot;tutorial-hand_coded-doof2d&quot;&gt;&lt;/xref&gt;.  After querying the
!   user for the number of averagings, the arrays' memory is
!   allocated.  Since the arrays' size is not known at compile time,
!   the arrays are accesses via pointers to allocated dynamic memory.
!   This memory is deallocated at the program's end to avoid memory
!   leaks.  The arrays are initialized with initial conditions.  For
!   the &lt;varname&gt;b&lt;/varname&gt; array, all values except the central ones
!   have nonzero values.  Only the outermost values of the
    &lt;varname&gt;a&lt;/varname&gt; array need be initialized to zero, but we
!   instead initialize them all using the loop used by
!   &lt;varname&gt;b&lt;/varname&gt;.&lt;/para&gt;
  
!   &lt;para&gt;The simulation's kernel consists of triply nested loops.
!   The outermost loop controls the number of iterations.  The inner
    nested loops iterate through the arrays' elements, excepting the
!   outermost elements; note the loop indices range from 1 to n-2
!   while the array indices range from 0 to n-1.  Each
!   &lt;varname&gt;a&lt;/varname&gt; value is assigned the average of its
!   corresponding value in &lt;varname&gt;b&lt;/varname&gt; and the latter's
!   neighbors.  Values in the two-dimensional grids are accessed using
!   two sets of brackets, e.g., &lt;statement&gt;a[i][j]&lt;/statement&gt;.  After
!   assigning values to &lt;varname&gt;a&lt;/varname&gt;, a second averaging reads
!   values in &lt;varname&gt;a&lt;/varname&gt;, writing values in
!   &lt;varname&gt;b&lt;/varname&gt;.&lt;/para&gt;
  
    &lt;para&gt;After the kernel finishes, the final central value is
    printed.  If the desired number of averagings is even, the value
--- 187,214 ----
    &lt;para&gt;Before implementing &amp;doof2d; using the &poomatoolkit;, we
    present a hand-coded implementation of &amp;doof2d;.  See &lt;xref
    linkend=&quot;tutorial-hand_coded-doof2d&quot;&gt;&lt;/xref&gt;.  After querying the
!   user for the number of averagings, the arrays' memory is allocated.
!   Since the arrays' size is not known at compile time, the arrays are
!   accessed via pointers to allocated dynamic memory.  This memory is
!   deallocated at the program's end to avoid memory leaks.  The arrays
!   are initialized with initial conditions.  For the
!   &lt;varname&gt;b&lt;/varname&gt; array, all values except the central ones have
!   nonzero values.  Only the outermost values of the
    &lt;varname&gt;a&lt;/varname&gt; array need be initialized to zero, but we
!   instead initialize them all using the same loop
!   initializing&nbsp;&lt;varname&gt;b&lt;/varname&gt;.&lt;/para&gt;
  
!   &lt;para&gt;The simulation's kernel consists of triply nested loops.  The
!   outermost loop controls the number of iterations.  The two inner
    nested loops iterate through the arrays' elements, excepting the
!   outermost elements; note the loop indices range from 1 to n-2 while
!   the array indices range from 0 to n-1.  Each &lt;varname&gt;a&lt;/varname&gt;
!   value is assigned the average of its corresponding value in
!   &lt;varname&gt;b&lt;/varname&gt; and the latter's neighbors.  Values in the
!   two-dimensional grids are accessed using two sets of brackets, e.g.,
!   &lt;statement&gt;a[i][j]&lt;/statement&gt;.  After assigning values to
!   &lt;varname&gt;a&lt;/varname&gt;, a second averaging reads values in
!   &lt;varname&gt;a&lt;/varname&gt;, writing values in &lt;varname&gt;b&lt;/varname&gt;.&lt;/para&gt;
  
    &lt;para&gt;After the kernel finishes, the final central value is
    printed.  If the desired number of averagings is even, the value
***************
*** 241,248 ****
       &lt;varname&gt;a&lt;/varname&gt; array.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-hand_coded-doof2d-constants&quot;&gt;
!      &lt;para&gt;These constants indicate the number of iterations, and
!      the average weighting.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-hand_coded-doof2d-first_write&quot;&gt;
       &lt;para&gt;Each &lt;varname&gt;a&lt;/varname&gt; value, except an outermost one,
--- 246,252 ----
       &lt;varname&gt;a&lt;/varname&gt; array.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-hand_coded-doof2d-constants&quot;&gt;
!      &lt;para&gt;This constants indicates the average's weighting.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-hand_coded-doof2d-first_write&quot;&gt;
       &lt;para&gt;Each &lt;varname&gt;a&lt;/varname&gt; value, except an outermost one,
***************
*** 268,289 ****
  
    &lt;para&gt;To compile the executable, change directories to the &pooma;
    &lt;filename
!   class=&quot;directory&quot;&gt;&poomaExampleDirectory;/Doof2d&lt;/filename&gt;
    directory.  Ensure the &lt;envar&gt;POOMASUITE&lt;/envar&gt; environment
    variable specifies the desired suite name
    &lt;replaceable&gt;suiteName&lt;/replaceable&gt;, as we did when compiling
!   &pooma; in the previous section &lt;xref
!   linkend=&quot;tutorial-installation&quot;&gt;&lt;/xref&gt;.  Issuing the
!   &lt;command&gt;make Doof2d-C-element&lt;/command&gt; command creates the
    executable
    &lt;command&gt;&lt;replaceable&gt;suiteName&lt;/replaceable&gt;/Doof2d-C-element&lt;/command&gt;.&lt;/para&gt;
  
!   &lt;para&gt;When running the executable, specify the desired a
!   nonnegative number of averagings and the nonnegative number of
!   grid cells along any dimension.  The resulting grid has the same
!   number of cells along each dimension.  After the executable
!   finishes, the resulting value of the central element is
!   printed.&lt;/para&gt;
   &lt;/section&gt;
  
  
--- 272,291 ----
  
    &lt;para&gt;To compile the executable, change directories to the &pooma;
    &lt;filename
!   class=&quot;directory&quot;&gt;&poomaexampledirectory;/Doof2d&lt;/filename&gt;
    directory.  Ensure the &lt;envar&gt;POOMASUITE&lt;/envar&gt; environment
    variable specifies the desired suite name
    &lt;replaceable&gt;suiteName&lt;/replaceable&gt;, as we did when compiling
!   &pooma; in &lt;xref linkend=&quot;tutorial-installation&quot;&gt;&lt;/xref&gt;.  Issuing
!   the &lt;command&gt;make Doof2d-C-element&lt;/command&gt; command creates the
    executable
    &lt;command&gt;&lt;replaceable&gt;suiteName&lt;/replaceable&gt;/Doof2d-C-element&lt;/command&gt;.&lt;/para&gt;
  
!   &lt;para&gt;When running the executable, specify the desired nonnegative
!   number of averagings and the nonnegative number of grid cells along
!   any dimension.  The resulting grid has the same number of cells
!   along each dimension.  After the executable finishes, the resulting
!   value of the central element is printed.&lt;/para&gt;
   &lt;/section&gt;
  
  
***************
*** 314,323 ****
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-domain&quot;&gt;
       &lt;para&gt;Before creating an &array;, its domain must be specified.
!      The &lt;varname&gt;N&lt;/varname&gt; interval represents the
!      one-dimensional integral set {0, 1, 2, &hellip;, n-1}.  An
!      &lt;type&gt;Interval&lt;2&gt;&lt;/type&gt; object represents the entire
!      two-dimensional index domain.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-array_creation&quot;&gt;
       &lt;para&gt;An &array;'s template parameters indicate its dimension,
--- 316,325 ----
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-domain&quot;&gt;
       &lt;para&gt;Before creating an &array;, its domain must be specified.
!      The &lt;varname&gt;N&lt;/varname&gt; &interval; represents the
!      one-dimensional integral set {0, 1, 2, &hellip;, n-1}.  The
!      &lt;type&gt;Interval&lt;2&gt;&lt;/type&gt; &lt;varname&gt;vertDomain&lt;/varname&gt;
!      object represents the entire two-dimensional index domain.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-array_creation&quot;&gt;
       &lt;para&gt;An &array;'s template parameters indicate its dimension,
***************
*** 330,349 ****
       domain.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-initialization&quot;&gt;
!      &lt;para&gt;The first statement initializes all &array; values to the
!      same scalar value.  This is possible because each &array;
!      &lt;quote&gt;knows&lt;/quote&gt; its domain.  The second statement
!      illustrates &array; element access.  Indices, separated by
       commas, are surrounded by parentheses rather than surrounded by
       square brackets (&lt;statement&gt;[]&lt;/statement&gt;).&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-first_write&quot;&gt;
       &lt;para&gt;&array; element access uses parentheses, rather than
!      square brackets&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-deallocation&quot;&gt;
!      &lt;para&gt;Since &array;s are first-class objects, they
!      automatically deallocate any memory they require, eliminating
       memory leaks.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-pooma_finish&quot;&gt;
--- 332,349 ----
       domain.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-initialization&quot;&gt;
!      &lt;para&gt;The first loop initializes all &array; values to the
!      same scalar value.  The second statement
!      illustrates assigning one &array; value.  Indices, separated by
       commas, are surrounded by parentheses rather than surrounded by
       square brackets (&lt;statement&gt;[]&lt;/statement&gt;).&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-first_write&quot;&gt;
       &lt;para&gt;&array; element access uses parentheses, rather than
!      square brackets.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-deallocation&quot;&gt;
!      &lt;para&gt;The &array;s deallocate any memory they require, eliminating
       memory leaks.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_elementwise-doof2d-pooma_finish&quot;&gt;
***************
*** 364,370 ****
    &lt;para&gt;The creation of the &lt;varname&gt;a&lt;/varname&gt; and
    &lt;varname&gt;b&lt;/varname&gt; &array;s requires an object specifying their
    index domains.  Since these are two-dimensional arrays, their
!   index domains are also two dimensional.  The two-dimensional
    &lt;type&gt;Interval&lt;2&gt;&lt;/type&gt; object is the Cartesian product of
    two one-dimensional &lt;type&gt;Interval&lt;1&gt;&lt;/type&gt; objects, each
    specifying the integral set {0, 1, 2, &hellip;, n-1}.&lt;/para&gt;
--- 364,370 ----
    &lt;para&gt;The creation of the &lt;varname&gt;a&lt;/varname&gt; and
    &lt;varname&gt;b&lt;/varname&gt; &array;s requires an object specifying their
    index domains.  Since these are two-dimensional arrays, their
!   index domains are also two-dimensional.  The two-dimensional
    &lt;type&gt;Interval&lt;2&gt;&lt;/type&gt; object is the Cartesian product of
    two one-dimensional &lt;type&gt;Interval&lt;1&gt;&lt;/type&gt; objects, each
    specifying the integral set {0, 1, 2, &hellip;, n-1}.&lt;/para&gt;
***************
*** 373,387 ****
    type of its values, and how the values are stored.  Both
    &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt; are two-dimension
    arrays storing &double;s so their &lt;varname&gt;dimension&lt;/varname&gt;
!   is&nbsp;2 and its element type is &double;.  An &engine; stores an
!   &array;'s values.  For example, a &brick; &engine; explicitly
!   stores all values.  A &compressiblebrick; &engine; also explicitly
!   stores values if more than value is present, but, if all values
!   are the same, storage for just that value is required.  Since an
!   engine can store its values any way it desires, it might instead
!   compute its values using a function or compute the values stored
!   in separate engines.  In practice, most explicitly specified
!   &engine;s are either &brick; or &compressiblebrick;.&lt;/para&gt;
  
    &lt;para&gt;&array;s support both element-wise access and scalar
    assignment.  Element-wise access uses parentheses, not square
--- 373,387 ----
    type of its values, and how the values are stored.  Both
    &lt;varname&gt;a&lt;/varname&gt; and &lt;varname&gt;b&lt;/varname&gt; are two-dimension
    arrays storing &double;s so their &lt;varname&gt;dimension&lt;/varname&gt;
!   is&nbsp;2 and their value type is &double;.  An &engine; stores an
!   &array;'s values.  For example, a &brick; &engine; explicitly stores
!   all values.  A &compressiblebrick; &engine; also explicitly stores
!   values if more than one value is present, but, if all values are the
!   same, storage for just that value is required.  Since an engine can
!   store its values any way it desires, it might instead compute its
!   values using a function or compute using values stored in separate
!   engines.  In practice, most explicitly specified &engine;s are
!   either &brick; or &compressiblebrick;.&lt;/para&gt;
  
    &lt;para&gt;&array;s support both element-wise access and scalar
    assignment.  Element-wise access uses parentheses, not square
***************
*** 389,405 ****
    specifies the central element.  The scalar assignment &lt;statement&gt;b
    = 0.0&lt;/statement&gt; assigns the same 0.0 value to all array
    elements.  This is possible because the array knows the extent of
!   its domain.&lt;/para&gt;
  
    &lt;para&gt;Any program using the &poomatoolkit; must initialize the
    &toolkit;'s data structures using
!   &lt;statement&gt;Pooma::initialize(argc,argv)&lt;/statement&gt;.  This
!   extracts &pooma;-specific command-line options from the
!   command-line arguments in &lt;varname&gt;argv&lt;/varname&gt; and initializes
!   the inter-processor communication and other data structures.  When
!   finished, &lt;statement&gt;Pooma::finalize()&lt;/statement&gt; ensures all
!   computation has finished and the communication and other data
!   structures are destructed.&lt;/para&gt;
   &lt;/section&gt;
  
  
--- 389,406 ----
    specifies the central element.  The scalar assignment &lt;statement&gt;b
    = 0.0&lt;/statement&gt; assigns the same 0.0 value to all array
    elements.  This is possible because the array knows the extent of
!   its domain.  We illustrate these data-parallel statements in the
!   next section.&lt;/para&gt;
  
    &lt;para&gt;Any program using the &poomatoolkit; must initialize the
    &toolkit;'s data structures using
!   &lt;statement&gt;Pooma::initialize(argc,argv)&lt;/statement&gt;.  This extracts
!   &pooma;-specific command-line options from the program's
!   command-line arguments and initializes the interprocessor
!   communication and other data structures.  When finished,
!   &lt;statement&gt;Pooma::finalize()&lt;/statement&gt; ensures all computation and
!   communication has finished and the data structures are
!   destructed.&lt;/para&gt;
   &lt;/section&gt;
  
  
***************
*** 408,437 ****
  
    &lt;para&gt;&pooma; supports data-parallel &array; accesses.  Many
    algorithms are more easily expressed using data-parallel
!   expressions.  Also, the &poomatoolkit; might be able to reorder
!   the data-parallel computations to be more efficient or distribute
!   them among various processors.  In this section, we concentrate
!   the differences between the data-parallel implementation of
!   &amp;doof2d; listed in &lt;xref
!   linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt; and the
!   element-wise implementation listed in the previous section &lt;xref
!   linkend=&quot;tutorial-array_elementwise&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
    &lt;example id=&quot;tutorial-array_parallel-doof2d&quot;&gt;
     &lt;title&gt;Data-Parallel &array; Implementation of &amp;doof2d;&lt;/title&gt;
     &amp;doof2d-array-parallel;
     &lt;calloutlist&gt;
      &lt;callout arearefs=&quot;tutorial-array_parallel-doof2d-blockAndEvaluate&quot;&gt;
       &lt;para&gt;&pooma; may reorder computation of statements.  Calling
       &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; ensures all
       computation finishes before accessing a particular array
       element.&lt;/para&gt;
      &lt;/callout&gt;
-     &lt;callout arearefs=&quot;tutorial-array_parallel-doof2d-innerdomain&quot;&gt;
-      &lt;para&gt;These variables specify one-dimensional domains {1, 2,
-      &hellip;, n-2}.  Their Cartesian product specifies the domain
-      of the array values that are modified.&lt;/para&gt;
-     &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_parallel-doof2d-first_write&quot;&gt;
       &lt;para&gt;Data-parallel expressions replace nested loops and array
       element accesses.  For example, &lt;statement&gt;a(I,J)&lt;/statement&gt;
--- 409,437 ----
  
    &lt;para&gt;&pooma; supports data-parallel &array; accesses.  Many
    algorithms are more easily expressed using data-parallel
!   expressions.  Also, the &poomatoolkit; can sometimes reorder the
!   data-parallel computations to be more efficient or distribute them
!   among various processors.  In this section, we concentrate on the
!   differences between the data-parallel implementation of &amp;doof2d;
!   listed in &lt;xref linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt; and
!   the element-wise implementation listed in the previous
!   section.&lt;/para&gt;
  
    &lt;example id=&quot;tutorial-array_parallel-doof2d&quot;&gt;
     &lt;title&gt;Data-Parallel &array; Implementation of &amp;doof2d;&lt;/title&gt;
     &amp;doof2d-array-parallel;
     &lt;calloutlist&gt;
+     &lt;callout arearefs=&quot;tutorial-array_parallel-doof2d-innerdomain&quot;&gt;
+      &lt;para&gt;These variables specify one-dimensional domains {1, 2,
+      &hellip;, n-2}.  Their Cartesian product specifies the domain
+      of the array values that are modified.&lt;/para&gt;
+     &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_parallel-doof2d-blockAndEvaluate&quot;&gt;
       &lt;para&gt;&pooma; may reorder computation of statements.  Calling
       &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; ensures all
       computation finishes before accessing a particular array
       element.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_parallel-doof2d-first_write&quot;&gt;
       &lt;para&gt;Data-parallel expressions replace nested loops and array
       element accesses.  For example, &lt;statement&gt;a(I,J)&lt;/statement&gt;
***************
*** 443,462 ****
     &lt;/calloutlist&gt;
    &lt;/example&gt;
  
!   &lt;para&gt;Data-parallel expressions apply domain objects to containers
!   to indicate a set of parallel expressions.  For example, in the
!   program listed above, &lt;statement&gt;a(I,J)&lt;/statement&gt; specifies all
!   of &lt;varname&gt;a&lt;/varname&gt; array excepting the outermost elements.
!   The array's &lt;varname&gt;vertDomain&lt;/varname&gt; domain consists of the
!   Cartesian product of {0, 1, 2, &hellip;, n-1} and itself, while
    &lt;varname&gt;I&lt;/varname&gt; and &lt;varname&gt;J&lt;/varname&gt; each specify {1, 2,
    &hellip;, n-2}.  Thus, &lt;statement&gt;a(I,J)&lt;/statement&gt; is the subset
!   with a domain of the Cartesian product of {1, 2, &hellip;, n-2}
!   and itself.  It is called a &lt;firstterm&gt;view&lt;/firstterm&gt; of an
!   array.  It is itself an array, with a domain and supporting
!   element access, but its storage is the same as
!   &lt;varname&gt;a&lt;/varname&gt;'s.  Changing a value in
!   &lt;statement&gt;a(I,J)&lt;/statement&gt; also changes the same value in
    &lt;varname&gt;a&lt;/varname&gt;.  Changing a value in the latter also changes
    the former if the value is not one of &lt;varname&gt;a&lt;/varname&gt;'s
    outermost elements.  The expression
--- 443,461 ----
     &lt;/calloutlist&gt;
    &lt;/example&gt;
  
!   &lt;para&gt;Data-parallel expressions use containers and domain objects to
!   indicate a set of parallel expressions.  For example, in the program
!   listed above, &lt;statement&gt;a(I,J)&lt;/statement&gt; specifies the subset of
!   &lt;varname&gt;a&lt;/varname&gt; array omitting the outermost elements.  The
!   array's &lt;varname&gt;vertDomain&lt;/varname&gt; domain consists of the
!   Cartesian product of {0, 1, 2, &hellip;, n-1} with itself, while
    &lt;varname&gt;I&lt;/varname&gt; and &lt;varname&gt;J&lt;/varname&gt; each specify {1, 2,
    &hellip;, n-2}.  Thus, &lt;statement&gt;a(I,J)&lt;/statement&gt; is the subset
!   with a domain of the Cartesian product of {1, 2, &hellip;, n-2} with
!   itself.  It is called a &lt;firstterm&gt;view&lt;/firstterm&gt; of an array.  It
!   is itself an &array;, with a domain and supporting element access, but
!   its storage is the same as &lt;varname&gt;a&lt;/varname&gt;'s.  Changing a value
!   in &lt;statement&gt;a(I,J)&lt;/statement&gt; also changes the same value in
    &lt;varname&gt;a&lt;/varname&gt;.  Changing a value in the latter also changes
    the former if the value is not one of &lt;varname&gt;a&lt;/varname&gt;'s
    outermost elements.  The expression
***************
*** 465,474 ****
    product of {2, 3, &hellip;, n-1}, i.e., the same domain as
    &lt;statement&gt;a(I,J)&lt;/statement&gt; but shifted up one unit and to the
    right one unit.  Only an &interval;'s value, not its name, is
!   important.  Thus, all uses of &lt;varname&gt;J&lt;/varname&gt; in this program
    could be replaced by &lt;varname&gt;I&lt;/varname&gt; without changing the
    semantics.&lt;/para&gt;
  
    &lt;figure float=&quot;1&quot; id=&quot;tutorial-array_parallel-doof2d-adding_arrays&quot;&gt;
     &lt;title&gt;Adding &array;s&lt;/title&gt;
     &lt;mediaobject&gt;
--- 464,483 ----
    product of {2, 3, &hellip;, n-1}, i.e., the same domain as
    &lt;statement&gt;a(I,J)&lt;/statement&gt; but shifted up one unit and to the
    right one unit.  Only an &interval;'s value, not its name, is
!   important so all uses of &lt;varname&gt;J&lt;/varname&gt; in this program
    could be replaced by &lt;varname&gt;I&lt;/varname&gt; without changing the
    semantics.&lt;/para&gt;
  
+   &lt;para&gt;The statement assigning to &lt;statement&gt;a(I,J)&lt;/statement&gt;
+   illustrates that &array;s may participate in expressions.  Each
+   addend is a view of an array, which is itself an array.  The views'
+   indices are zero-based so their sum can be formed by adding
+   identically indexed elements of each array.  For example, the lower,
+   left element of the result equals the sum of the lower, left
+   elements of the addend arrays.  &lt;xref
+   linkend=&quot;tutorial-array_parallel-doof2d-adding_arrays&quot;&gt;&lt;/xref&gt;
+   illustrates adding two arrays.&lt;/para&gt;
+ 
    &lt;figure float=&quot;1&quot; id=&quot;tutorial-array_parallel-doof2d-adding_arrays&quot;&gt;
     &lt;title&gt;Adding &array;s&lt;/title&gt;
     &lt;mediaobject&gt;
***************
*** 476,528 ****
       &lt;imagedata fileref=&quot;figures/doof2d.210&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
      &lt;/imageobject&gt;
      &lt;textobject&gt;
!      &lt;phrase&gt;Adding two arrays with different domains is supported.&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
!      &lt;para&gt;When adding arrays, values in corresponding positions are
!      added even if they have different indices, indicated by the
!      small numbers adjacent to the arrays.&lt;/para&gt;
      &lt;/caption&gt;
     &lt;/mediaobject&gt;
    &lt;/figure&gt;
  
-   &lt;para&gt;The statement assigning to &lt;statement&gt;a(I,J)&lt;/statement&gt;
-   illustrates that &array;s may participate in expressions.  Each
-   addend is a view of an array, which is itself an array.  Each view
-   has the same domain size so their sum can be formed by
-   corresponding elements of each array.  For example, the lower,
-   left element of the result equals the sum of the lower, left
-   elements of the addend arrays.  For the computation, indices are
-   ignored; only the relative positions within each domain are used.
-   &lt;xref
-   linkend=&quot;tutorial-array_parallel-doof2d-adding_arrays&quot;&gt;&lt;/xref&gt;
-   illustrates adding two arrays with different domain indices.  The
-   indices are indicated by the small numbers to the left and the
-   bottom of the arrays.  Even though 9 and 3 have different indices
-   (1,1) and (2,0), they are added to each other because they have
-   the same relative positions within the addends.&lt;/para&gt;
- 
    &lt;para&gt;Just before accessing individual &array; values, the code
    contains calls to &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt;.
    &pooma; may reorder computation or distribute them among various
    processors.  Before reading an individual &array; value, calling
!   the function ensures all computations affecting its value have
!   finished, i.e., it has the correct value.  Calling this function
!   is necessary only when accessing individual array elements because
!   &pooma; cannot determine when to call the function itself. For
!   example, before printing an array, &pooma; will call
!   &lt;function&gt;blockAndEvaluate&lt;/function&gt; itself.&lt;/para&gt;
   &lt;/section&gt;
  
  
   &lt;section id=&quot;tutorial-array_stencil&quot;&gt;
    &lt;title&gt;Stencil &array; Implementation&lt;/title&gt;
  
!   &lt;para&gt;Many computations are local, computing an &array;'s value by
!   using close-by &array; values.  Encapsulating this computation in
!   a stencil can yield faster code because the compiler can determine
!   all accesses come from the same array.  Each stencil consists of a
!   function object and an indication of the stencil's extent.&lt;/para&gt;
  
    &lt;example id=&quot;tutorial-array_stencil-doof2d&quot;&gt;
     &lt;title&gt;Stencil &array; Implementation of &amp;doof2d;&lt;/title&gt;
--- 485,523 ----
       &lt;imagedata fileref=&quot;figures/doof2d.210&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
      &lt;/imageobject&gt;
      &lt;textobject&gt;
!      &lt;phrase&gt;Adding two arrays is supported.&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
!      &lt;para&gt;When adding arrays, values with the same indices, indicated
!      by the small numbers adjacent to the arrays, are added.&lt;/para&gt;
      &lt;/caption&gt;
     &lt;/mediaobject&gt;
    &lt;/figure&gt;
  
    &lt;para&gt;Just before accessing individual &array; values, the code
    contains calls to &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt;.
    &pooma; may reorder computation or distribute them among various
    processors.  Before reading an individual &array; value, calling
!   this function ensures all computations affecting its value have
!   finished, i.e., it has the correct value.  Calling this function is
!   necessary only when accessing individual array elements.  For
!   example, before the data-parallel operation of printing an array,
!   &pooma; will call &lt;function&gt;blockAndEvaluate&lt;/function&gt;
!   itself.&lt;/para&gt;
   &lt;/section&gt;
  
  
   &lt;section id=&quot;tutorial-array_stencil&quot;&gt;
    &lt;title&gt;Stencil &array; Implementation&lt;/title&gt;
  
!   &lt;para&gt;Many scientific computations are localized, computing an
!   array's value by using neighboring values.  Encapsulating this local
!   computation in a &lt;glossterm
!   linkend=&quot;glossary-stencil&quot;&gt;&lt;firstterm&gt;stencil&lt;/firstterm&gt;&lt;/glossterm&gt;
!   can yield faster code because the compiler can determine that all
!   array accesses use the same array.  Each stencil consists of a
!   function object and an indication of which neighbors participate in
!   the function's computation.&lt;/para&gt;
  
    &lt;example id=&quot;tutorial-array_stencil-doof2d&quot;&gt;
     &lt;title&gt;Stencil &array; Implementation of &amp;doof2d;&lt;/title&gt;
***************
*** 546,552 ****
      &lt;callout arearefs=&quot;tutorial-array_stencil-doof2d-stencil_extent&quot;&gt;
       &lt;para&gt;These two functions indicate the stencil's size.  For
       each dimension, the stencil extends one cell to the left of (or
!      below) its center and also one call to the right (or above) its
       center.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout
--- 541,547 ----
      &lt;callout arearefs=&quot;tutorial-array_stencil-doof2d-stencil_extent&quot;&gt;
       &lt;para&gt;These two functions indicate the stencil's size.  For
       each dimension, the stencil extends one cell to the left of (or
!      below) its center and also one cell to the right (or above) its
       center.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout
***************
*** 564,584 ****
     &lt;/calloutlist&gt;
    &lt;/example&gt;
  
!   &lt;para&gt;Before we describe how to create a stencil, we describe how
!   to apply a stencil to an array, yielding values.  To compute the
!   value associated with index position (1,3), the stencil's center
!   is placed at (1,3).  The stencil's
!   &lt;function&gt;upperExtent&lt;/function&gt; and
!   &lt;function&gt;lowerExtent&lt;/function&gt; functions indicate which &array;
!   values the stencil's function will use.  See &lt;xref
    linkend=&quot;tutorial-array_stencil-doof2d-apply_stencil&quot;&gt;&lt;/xref&gt;.
!   Applying the stencil's function call
!   &lt;function&gt;operator()&lt;/function&gt; yields the computed value.  To
!   compute multiple &array; values, apply a stencil to the array and
!   a domain object: &lt;statement&gt;stencil(b,
!   interiorDomain)&lt;/statement&gt;.  This applies the stencil to each
!   position in the domain.  The user must ensure that applying the
!   stencil does not access nonexistent &array; values.&lt;/para&gt;
  
    &lt;figure float=&quot;1&quot; id=&quot;tutorial-array_stencil-doof2d-apply_stencil&quot;&gt;
     &lt;title&gt;Applying a Stencil to an &array;&lt;/title&gt;
--- 559,578 ----
     &lt;/calloutlist&gt;
    &lt;/example&gt;
  
!   &lt;para&gt;Before we describe how to create a stencil, we describe how to
!   apply a stencil to an array, yielding computed values.  To compute
!   the value associated with index position (1,3), the stencil's center
!   is placed at (1,3).  The stencil's &lt;function&gt;upperExtent&lt;/function&gt;
!   and &lt;function&gt;lowerExtent&lt;/function&gt; functions indicate which
!   &array; values the stencil's function will use.  See &lt;xref
    linkend=&quot;tutorial-array_stencil-doof2d-apply_stencil&quot;&gt;&lt;/xref&gt;.
!   Applying the stencil's function call &lt;function&gt;operator()&lt;/function&gt;
!   yields the computed value.  To compute multiple &array; values,
!   apply a stencil to the array and a domain object:
!   &lt;statement&gt;stencil(b, interiorDomain)&lt;/statement&gt;.  This applies the
!   stencil to each position in the domain.  The user must ensure that
!   applying the stencil does not access nonexistent &array;
!   values.&lt;/para&gt;
  
    &lt;figure float=&quot;1&quot; id=&quot;tutorial-array_stencil-doof2d-apply_stencil&quot;&gt;
     &lt;title&gt;Applying a Stencil to an &array;&lt;/title&gt;
***************
*** 592,598 ****
      &lt;caption&gt;
       &lt;para&gt;To compute the value associated with index position (1,3)
       of an array, place the stencil's center, indicated with dashed
!      lines, at the position.  The computation involves the array
       values covered by the array and delineated by
       &lt;function&gt;upperExtent&lt;/function&gt; and
       &lt;function&gt;lowerExtent&lt;/function&gt;.&lt;/para&gt;
--- 586,592 ----
      &lt;caption&gt;
       &lt;para&gt;To compute the value associated with index position (1,3)
       of an array, place the stencil's center, indicated with dashed
!      lines, at the position&nbsp;(1,3).  The computation involves the array
       values covered by the array and delineated by
       &lt;function&gt;upperExtent&lt;/function&gt; and
       &lt;function&gt;lowerExtent&lt;/function&gt;.&lt;/para&gt;
***************
*** 607,625 ****
    must define a function call &lt;function&gt;operator()&lt;/function&gt; with a
    container parameter and index parameters.  The number of index
    parameters, indicating the stencil's center, must equal the
!   container's dimension.  For example, &lt;type&gt;DoofNinePt&lt;/type&gt;
!   defines &lt;methodname&gt;operator()(const C&amp; c, int i, int
!   j)&lt;/methodname&gt;.  We templated the container type
!   &lt;varname&gt;C&lt;/varname&gt; although this is not strictly necessary.  The
!   two index parameters &lt;varname&gt;i&lt;/varname&gt; and &lt;varname&gt;j&lt;/varname&gt;
!   ensure the stencil works with two-dimensional containers.  The
!   &lt;methodname&gt;lowerExtent&lt;/methodname&gt; indicates how far to the left
!   (or below) the stencil extends beyond its center.  Its parameter
!   indicates a particular dimension.  Index parameters
    &lt;varname&gt;i&lt;/varname&gt; and &lt;varname&gt;j&lt;/varname&gt; are in dimension 0
    and&nbsp;1.  &lt;methodname&gt;upperExtent&lt;/methodname&gt; serves an
    analogous purpose.  The &poomatoolkit; uses these functions when
!   distribution computation among various processors, but it does not
    use these functions to ensure nonexistent &array; values are not
    accessed.  Caveat stencil user!&lt;/para&gt;
   &lt;/section&gt;
--- 601,619 ----
    must define a function call &lt;function&gt;operator()&lt;/function&gt; with a
    container parameter and index parameters.  The number of index
    parameters, indicating the stencil's center, must equal the
!   container's dimension.  For example, &lt;type&gt;DoofNinePt&lt;/type&gt; defines
!   &lt;methodname&gt;operator()(const C&amp; c, int i, int j)&lt;/methodname&gt;.  We
!   templated the container type &lt;varname&gt;C&lt;/varname&gt; although this is
!   not strictly necessary.  The two index parameters
!   &lt;varname&gt;i&lt;/varname&gt; and &lt;varname&gt;j&lt;/varname&gt; ensure the stencil
!   works with two-dimensional containers.  The
!   &lt;methodname&gt;lowerExtent&lt;/methodname&gt; function indicates how far to
!   the left (or below) the stencil extends beyond its center.  Its
!   parameter indicates a particular dimension.  Index parameters
    &lt;varname&gt;i&lt;/varname&gt; and &lt;varname&gt;j&lt;/varname&gt; are in dimension 0
    and&nbsp;1.  &lt;methodname&gt;upperExtent&lt;/methodname&gt; serves an
    analogous purpose.  The &poomatoolkit; uses these functions when
!   distributing computation among various processors, but it does not
    use these functions to ensure nonexistent &array; values are not
    accessed.  Caveat stencil user!&lt;/para&gt;
   &lt;/section&gt;
***************
*** 634,640 ****
    only specify how each container's domain should be split into
    &lt;quote&gt;patches&lt;/quote&gt;.  The &poomatoolkit; automatically
    distributes the data among the available processors and handles
!   any required communication among processors.&lt;/para&gt;
  
    &lt;example id=&quot;tutorial-array_distributed-doof2d&quot;&gt;
     &lt;title&gt;Distributed Stencil &array; Implementation of &amp;doof2d;&lt;/title&gt;
--- 628,637 ----
    only specify how each container's domain should be split into
    &lt;quote&gt;patches&lt;/quote&gt;.  The &poomatoolkit; automatically
    distributes the data among the available processors and handles
!   any required communication among processors.  &lt;xref
!   linkend=&quot;tutorial-array_distributed-doof2d&quot;&gt;&lt;/xref&gt; illustrates how
!   to write a distributed version of the stencil program (&lt;xref
!   linkend=&quot;tutorial-array_stencil-doof2d&quot;&gt;&lt;/xref&gt;).&lt;/para&gt;
  
    &lt;example id=&quot;tutorial-array_distributed-doof2d&quot;&gt;
     &lt;title&gt;Distributed Stencil &array; Implementation of &amp;doof2d;&lt;/title&gt;
***************
*** 644,655 ****
       &lt;para&gt;Multiple copies of a distributed program may
       simultaneously run, perhaps each having its own input and
       output.  Thus, we use command-line arguments to pass input to
!      the program.  Using an &inform; object ensures only one program
       produces output.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_distributed-doof2d-layout&quot;&gt;
       &lt;para&gt;The &lt;type&gt;UniformGridPartition&lt;/type&gt; declaration
!      specifies how an array's domain will be partition, of split,
       into patches.  Guard layers are an optimization that can reduce
       data communication between patches.  The
       &lt;type&gt;UniformGridLayout&lt;/type&gt; declaration applies the
--- 641,652 ----
       &lt;para&gt;Multiple copies of a distributed program may
       simultaneously run, perhaps each having its own input and
       output.  Thus, we use command-line arguments to pass input to
!      the program.  Using an &inform; object ensures only one copy
       produces output.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_distributed-doof2d-layout&quot;&gt;
       &lt;para&gt;The &lt;type&gt;UniformGridPartition&lt;/type&gt; declaration
!      specifies how an array's domain will be partitioned, or split,
       into patches.  Guard layers are an optimization that can reduce
       data communication between patches.  The
       &lt;type&gt;UniformGridLayout&lt;/type&gt; declaration applies the
***************
*** 657,664 ****
       patches among various processors.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_distributed-doof2d-remote&quot;&gt;
!      &lt;para&gt;The &lt;type&gt;MultiPatch&lt;/type&gt; &engine; distributes requests
!      for &array; values to the associated patch.  Since a patch may
       associated with a different processor, its
       &lt;quote&gt;remote&lt;/quote&gt; &engine; has type
       &lt;type&gt;Remote&lt;Brick&gt;&lt;/type&gt;.  &pooma; automatically
--- 654,661 ----
       patches among various processors.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-array_distributed-doof2d-remote&quot;&gt;
!      &lt;para&gt;The &multipatch; &engine; distributes requests
!      for &array; values to the associated patches.  Since a patch may
       associated with a different processor, its
       &lt;quote&gt;remote&lt;/quote&gt; &engine; has type
       &lt;type&gt;Remote&lt;Brick&gt;&lt;/type&gt;.  &pooma; automatically
***************
*** 675,690 ****
  
    &lt;para&gt;Supporting distributed computation requires only minor code
    changes.  These changes specify how each container's domain is
!   distributed among the available processors and how input and
!   output occurs.  The rest of the program, including all the
!   computations, remains the same.  When running, the &pooma;
!   executable interacts with the run-time library to determine which
!   processors are available, distributes the containers' domains, and
!   automatically handles all necessary interprocessor communication.
!   The same executable runs on one or many processors.  Thus, the
!   programmer can write one program, debugging it on a uniprocessor
!   computer and running it on a supercomputer.&lt;/para&gt;
  
    &lt;figure float=&quot;1&quot; id=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;
     &lt;title&gt;The &pooma; Distributed Computation Model&lt;/title&gt;
     &lt;mediaobject&gt;
--- 672,713 ----
  
    &lt;para&gt;Supporting distributed computation requires only minor code
    changes.  These changes specify how each container's domain is
!   distributed among the available processors and how input and output
!   occurs.  The rest of the program, including all the computations,
!   remains the same.  When running, the &pooma; executable interacts
!   with the run-time library to determine which processors are
!   available, distributes the containers' domains, and automatically
!   handles all necessary interprocessor communication.  The same
!   executable runs on one or many processors.  Thus, the programmer can
!   write one program, debugging it on a uniprocessor computer and run
!   it on a supercomputer.&lt;/para&gt;
! 
!   &lt;para&gt;&pooma;'s distributed computing model separates container
!   domain concepts from computer configuration concepts.  See &lt;xref
!   linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;.
!   The statements in the program indicate how each container's domain
!   will be partitioned.  This process is represented in the upper left
!   corner of the figure.  A user-specified
!   &lt;firstterm&gt;partition&lt;/firstterm&gt; specifies how to split the domain
!   into pieces.  For example, the illustrated partition splits the
!   domain into three equal-sized pieces along the x-dimension and two
!   equal-sized pieces along the y-dimension.  Applying the partition to
!   the domain creates &lt;firstterm&gt;patches&lt;/firstterm&gt;.  The partition
!   also specifies external and internal guard layers.  A
!   &lt;firstterm&gt;guard layer&lt;/firstterm&gt; is a domain surrounding a patch.
!   A patch's computation only reads but does not write these guarded
!   values.  An &lt;firstterm&gt;external guard layer&lt;/firstterm&gt; conceptually
!   surrounds the entire container domain with boundary values whose
!   presence permits all domain computations to be performed the same
!   way even for computed values along the domain's edge.  An
!   &lt;firstterm&gt;internal guard layer&lt;/firstterm&gt; duplicates values from
!   adjacent patches so communication need not occur during a patch's
!   computation.  The use of guard layers is an optimization; using
!   external guard layers eases programming and using internal guard
!   layers reduces communication among processors.  Their use is not
!   required.&lt;/para&gt;
  
+ &lt;!-- FIXME: Fix the &quot;Computer Configuration&quot; text layout so it does not overlap the box. --&gt;
    &lt;figure float=&quot;1&quot; id=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;
     &lt;title&gt;The &pooma; Distributed Computation Model&lt;/title&gt;
     &lt;mediaobject&gt;
***************
*** 695,732 ****
       &lt;phrase&gt;the &pooma; distributed computation model&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
!      &lt;para&gt;The &pooma; distributed computation model combines
!      partitioning containers' domains and the computer configuration
!      to create a layout.&lt;/para&gt;
      &lt;/caption&gt;
     &lt;/mediaobject&gt;
    &lt;/figure&gt;
  
-   &lt;para&gt;&pooma;'s distributed computing model separates container
-   domain concepts from computer configuration concepts.  See &lt;xref
-   linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;.
-   The program indicates how each container's domain will be
-   partitioned.  This process is represented in the upper left corner
-   of the figure.  A user-specified &lt;firstterm&gt;partition&lt;/firstterm&gt;
-   specifies how to split the domain into pieces.  For example, the
-   illustrated partition splits the domain into three equal-sized
-   pieces along the x-dimension and two equal-sized pieces along the
-   y-dimension.  Thus, the domain is split into
-   &lt;firstterm&gt;patches&lt;/firstterm&gt;.  The partition also specifies
-   external and internal guard layers.  A &lt;firstterm&gt;guard
-   layer&lt;/firstterm&gt; is a domain surrounding a patch.  A patch's
-   computation only reads but does not write these guarded values.
-   An &lt;firstterm&gt;external guard layer&lt;/firstterm&gt; conceptually
-   surrounds the entire container domain with boundary values whose
-   presence permits all domain computations to be performed the same
-   way even for values along the domain's edge.  An
-   &lt;firstterm&gt;internal guard layer&lt;/firstterm&gt; duplicates values from
-   adjacent patches so communication need not occur during a patch's
-   computation.  The use of guard layers is an optimization; using
-   external guard layers eases programming and using internal guard
-   layers reduces communication among processors.  Their use is not
-   required.&lt;/para&gt;
- 
    &lt;para&gt;The computer configuration of shared memory and processors
    is determined by the run-time system.  See the upper right portion
    of &lt;xref
--- 718,730 ----
       &lt;phrase&gt;the &pooma; distributed computation model&lt;/phrase&gt;
      &lt;/textobject&gt;
      &lt;caption&gt;
!      &lt;para&gt;The &pooma; distributed computation model creates a layout
!      by combining a partitioning of the containers' domains and the
!      computer configuration.&lt;/para&gt;
      &lt;/caption&gt;
     &lt;/mediaobject&gt;
    &lt;/figure&gt;
  
    &lt;para&gt;The computer configuration of shared memory and processors
    is determined by the run-time system.  See the upper right portion
    of &lt;xref
***************
*** 738,765 ****
    supercomputer consisting of desktop computers networked together
    might have as many contexts as computers.  The run-time system,
    e.g., the Message Passing Interface (&mpi;) Communications Library
!   (FIXME: xref linkend=&quot;mpi99&quot;, &lt;ulink
!   url=&quot;<A HREF="http://www-unix.mcs.anl.gov/mpi/">http://www-unix.mcs.anl.gov/mpi/</A>&quot;&gt;&lt;/ulink&gt;) or the &mm;
    Shared Memory Library (&lt;ulink
    url=&quot;<A HREF="http://www.engelschall.com/sw/mm/">http://www.engelschall.com/sw/mm/</A>&quot;&gt;&lt;/ulink&gt;), communicates
    the available contexts to the executable.  &pooma; must be
!   configured for the particular run-time system.  See &lt;xref
    linkend=&quot;installation-distributed_computing&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
    &lt;para&gt;A &lt;firstterm&gt;layout&lt;/firstterm&gt; combines patches with contexts
    so the program can be executed.  If &distributedtag; is specified,
    the patches are distributed among the available contexts.  If
!   &replicatedtag; is specified, each set of patches is replicated
!   among each context.  Regardless, the containers' domains are now
    distributed among the contexts so the program can run.  When a patch
    needs data from another patch, the &poomatoolkit; sends messages to
!   the desired patch uses a message-passing library.  All such
!   communication is automatically performed by the &toolkit; with no need
!   for programmer or user input.&lt;/para&gt;
! 
!   &lt;para&gt;FIXME: The two previous paragraphs demonstrate confusion
!   between &lt;quote&gt;run-time system&lt;/quote&gt; and &lt;quote&gt;message-passing
!   library&lt;/quote&gt;.&lt;/para&gt;
  
    &lt;para&gt;Incorporating &pooma;'s distributed computation model into a
    program requires writing very few lines of code.  &lt;xref
--- 736,759 ----
    supercomputer consisting of desktop computers networked together
    might have as many contexts as computers.  The run-time system,
    e.g., the Message Passing Interface (&mpi;) Communications Library
!   &lt;!-- FIXME: xref linkend=&quot;mpi99&quot;, &lt;ulink
!   url=&quot;<A HREF="http://www-unix.mcs.anl.gov/mpi/">http://www-unix.mcs.anl.gov/mpi/</A>&quot;&gt;&lt;/ulink&gt; --&gt; or the &mm;
    Shared Memory Library (&lt;ulink
    url=&quot;<A HREF="http://www.engelschall.com/sw/mm/">http://www.engelschall.com/sw/mm/</A>&quot;&gt;&lt;/ulink&gt;), communicates
    the available contexts to the executable.  &pooma; must be
!   configured for the particular run-time system in use.  See &lt;xref
    linkend=&quot;installation-distributed_computing&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
    &lt;para&gt;A &lt;firstterm&gt;layout&lt;/firstterm&gt; combines patches with contexts
    so the program can be executed.  If &distributedtag; is specified,
    the patches are distributed among the available contexts.  If
!   &replicatedtag; is specified, each set of patches is replicated on
!   each context.  Regardless, the containers' domains are now
    distributed among the contexts so the program can run.  When a patch
    needs data from another patch, the &poomatoolkit; sends messages to
!   the desired patch uses the message-passing library.  All such
!   communication is automatically performed by the &toolkit; with no
!   need for programmer or user input.&lt;/para&gt;
  
    &lt;para&gt;Incorporating &pooma;'s distributed computation model into a
    program requires writing very few lines of code.  &lt;xref
***************
*** 772,783 ****
    copy of adjacent patches' outermost values.  This may speed
    computation because a patch need not synchronize its computation
    with other patches' processors.  Since each value's computation
!   requires knowing its surrounding neighbors, the internal guard
    layer is one layer deep.  The second &lt;type&gt;GuardLayers&lt;/type&gt;
    argument specifies no external guard layer.  External guard layers
!   simplify computing values along the edges of domains.  Since the
!   program already uses only the interior domain for computation, we
!   do not use this feature.&lt;/para&gt;
  
    &lt;para&gt;The &lt;varname&gt;layout&lt;/varname&gt; declaration creates a
    &lt;type&gt;UniformGridLayout&lt;/type&gt; layout.  As &lt;xref
--- 766,777 ----
    copy of adjacent patches' outermost values.  This may speed
    computation because a patch need not synchronize its computation
    with other patches' processors.  Since each value's computation
!   requires knowing its surrounding neighbors, this internal guard
    layer is one layer deep.  The second &lt;type&gt;GuardLayers&lt;/type&gt;
    argument specifies no external guard layer.  External guard layers
!   simplify computing values along the edges of domains.  Since our
!   program already uses only the interior domain for computation, we do
!   not use this feature.&lt;/para&gt;
  
    &lt;para&gt;The &lt;varname&gt;layout&lt;/varname&gt; declaration creates a
    &lt;type&gt;UniformGridLayout&lt;/type&gt; layout.  As &lt;xref
***************
*** 787,843 ****
    comprise &lt;varname&gt;layout&lt;/varname&gt;'s three parameters; the
    contexts are implicitly supplied by the run-time system.&lt;/para&gt;
  
!   &lt;para&gt;To create a distributed &array;, it should be created using
!   a &layout; object and have a &multipatch; &engine;.  Prior
!   implementations designed for uniprocessors constructed the
!   container using a &domain; object.  A distributed implementation
!   uses a &layout; object, which conceptually specifies a &domain;
!   object and its distribution throughout the computer.  A
!   &multipatch; &engine; supports computations using multiple patches.
!   The &lt;type&gt;UniformTag&lt;/type&gt; indicates the patches all have the
!   same size.  Since patches may reside on different contexts, the
!   second template parameter is &lt;type&gt;Remote&lt;/type&gt;.  Its
!   &lt;type&gt;Brick&lt;/type&gt; template parameter specifies the &engine; for a
!   particular patch on a particular context.  Most distributed
!   programs use &lt;type&gt;MultiPatch&lt;UniformTag, Remote&lt;Brick&gt;
!   &gt;&lt;/type&gt; or &lt;type&gt;MultiPatch&lt;UniformTag,
!   Remote&lt;CompressibleBrick&gt; &gt;&lt;/type&gt; &engine;s.&lt;/para&gt;
  
    &lt;para&gt;The computations for a distributed implementation are exactly
    the same as for a sequential implementation.  The &poomatoolkit; and
!   a message-passing library automatically perform all
    computation.&lt;/para&gt;
  
    &lt;para&gt;Input and output for distributed programs is different than
!   for sequential programs.  Although the same instructions run on
!   each context, each context may have its own input and output
!   streams.  To avoid dealing with multiple input streams, we pass
!   the input via command-line arguments, which are replicated for
!   each context.  Using &inform; streams avoids having multiple
!   output streams print.  Any context can print to an &inform; stream
!   but only text sent to context&nbsp;0 is sent.  At the beginning of
!   the program, we create an &inform; object.  Throughout the rest of
!   the program, we use it instead of &lt;varname&gt;std::cout&lt;/varname&gt; and
    &lt;varname&gt;std::cerr&lt;/varname&gt;.&lt;/para&gt;
  
    &lt;para&gt;The command to run the program is dependent on the run-time
    system.  To use &mpi; with the Irix&nbsp;6.5 operating system, one
    can use the &lt;command&gt;mpirun&lt;/command&gt; command.  For example,
!   &lt;statement&gt;mpirun -np 4 Doof2d-Array-distributed -mpi 2 10
!   1000&lt;/statement&gt; invokes the &mpi; run-time system with four
!   processors.  The &lt;statement&gt;-mpi&lt;/statement&gt; option tells the
!   &pooma; executable &lt;command&gt;Doof2d-Array-distributed&lt;/command&gt; to
!   use the &mpi; Library.  The remaining arguments specify the number
!   of processors, the number of averagings, and the array size.  The
!   first and last values are used for each dimension.  For example,
!   if three processors are specified, then the x-dimension will have
!   three processors and the y-dimension will have three processors,
!   totalling nine processors.  The command
!   &lt;statement&gt;Doof2d-Array-distributed -shmem -np 4 2 10
!   1000&lt;/statement&gt; uses the &mm; Shared Memory Library
!   (&lt;statement&gt;-shmem&lt;/statement&gt;) and four processors.  As for
!   &mpi;, the remaining command-line arguments are specified on a
!   per-dimension basis for the two-dimensional program.&lt;/para&gt;
   &lt;/section&gt;
  
  
--- 781,837 ----
    comprise &lt;varname&gt;layout&lt;/varname&gt;'s three parameters; the
    contexts are implicitly supplied by the run-time system.&lt;/para&gt;
  
!   &lt;para&gt;To create a distributed &array;, it should be created using a
!   &layout; object and have a &multipatch; &engine; rather than using a
!   &domain; object and a &brick; &engine; as we did for the
!   uniprocessor implementations.  A distributed implementation uses a
!   &layout; object, which conceptually specifies a &domain; object and
!   its distribution throughout the computer.  A &multipatch; &engine;
!   supports computations using multiple patches.  The
!   &lt;type&gt;UniformTag&lt;/type&gt; indicates the patches all have the same
!   size.  Since patches may reside on different contexts, the second
!   template parameter is &lt;type&gt;Remote&lt;/type&gt;.  Its &lt;type&gt;Brick&lt;/type&gt;
!   template parameter specifies the &engine; for a particular patch on
!   a particular context.  Most distributed programs use
!   &lt;type&gt;MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt;&lt;/type&gt; or
!   &lt;type&gt;MultiPatch&lt;UniformTag, Remote&lt;CompressibleBrick&gt;
!   &gt;&lt;/type&gt; &engine;s.&lt;/para&gt;
  
    &lt;para&gt;The computations for a distributed implementation are exactly
    the same as for a sequential implementation.  The &poomatoolkit; and
!   a message-passing library automatically perform all the
    computation.&lt;/para&gt;
  
    &lt;para&gt;Input and output for distributed programs is different than
!   for sequential programs.  Although the same instructions run on each
!   context, each context may have its own input and output streams.  To
!   avoid dealing with multiple input streams, we pass the input via
!   command-line arguments, which are replicated for each context.
!   Using &inform; streams avoids having multiple output streams print.
!   Any context can print to an &inform; stream but only text sent to
!   context&nbsp;0 is displayed.  At the beginning of the program, we
!   create an &inform; object named &lt;varname&gt;output&lt;/varname&gt;.
!   Throughout the rest of the program, we use it instead of
!   &lt;varname&gt;std::cout&lt;/varname&gt; and
    &lt;varname&gt;std::cerr&lt;/varname&gt;.&lt;/para&gt;
  
    &lt;para&gt;The command to run the program is dependent on the run-time
    system.  To use &mpi; with the Irix&nbsp;6.5 operating system, one
    can use the &lt;command&gt;mpirun&lt;/command&gt; command.  For example,
!   &lt;command&gt;mpirun -np 4 Doof2d-Array-distributed -mpi 2 10
!   1000&lt;/command&gt; invokes the &mpi; run-time system with four
!   processors.  The &lt;option&gt;-mpi&lt;/option&gt; option tells the &pooma;
!   executable &lt;command&gt;Doof2d-Array-distributed&lt;/command&gt; to use the
!   &mpi; Library.  The remaining arguments specify the number of
!   processors, the number of averagings, and the array size.  The first
!   and last values are the same for each dimension.  For example, if three
!   processors are specified, then the x-dimension will have three
!   processors and the y-dimension will have three processors, totaling
!   nine processors.  The command &lt;command&gt;Doof2d-Array-distributed
!   -shmem -np 4 2 10 1000&lt;/command&gt; uses the &mm; Shared Memory Library
!   (&lt;option&gt;-shmem&lt;/option&gt;) and four processors.  As for &mpi;, the
!   remaining command-line arguments are specified on a per-dimension
!   basis for the two-dimensional program.&lt;/para&gt;
   &lt;/section&gt;
  
  
***************
*** 845,851 ****
    &lt;title&gt;Data-Parallel &field; Implementation&lt;/title&gt;
  
    &lt;para&gt;&pooma; &array;s support many scientific computations, but
!   many scientific computations require values distributed throughout
    space, and &array;s have no spatial extent.  &pooma; &field;s,
    supporting a superset of &array; functionality, model values
    distributed throughout space.&lt;/para&gt;
--- 839,845 ----
    &lt;title&gt;Data-Parallel &field; Implementation&lt;/title&gt;
  
    &lt;para&gt;&pooma; &array;s support many scientific computations, but
!   other scientific computations require values distributed throughout
    space, and &array;s have no spatial extent.  &pooma; &field;s,
    supporting a superset of &array; functionality, model values
    distributed throughout space.&lt;/para&gt;
***************
*** 861,869 ****
  
    &lt;para&gt;In this section, we implement the &amp;doof2d; two-dimensional
    diffusion simulation program using &field;s.  This simulation does
!   not require any &field;-specific features, but we chose to present
    this program rather than one using &field;-specific features to
!   permit comparisons with the &array; versions, especially &lt;xref
    linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
    &lt;example id=&quot;tutorial-field_parallel-doof2d&quot;&gt;
--- 855,863 ----
  
    &lt;para&gt;In this section, we implement the &amp;doof2d; two-dimensional
    diffusion simulation program using &field;s.  This simulation does
!   not require any &field;-specific features, but we present
    this program rather than one using &field;-specific features to
!   facilitate comparison with the &array; versions, especially &lt;xref
    linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
    &lt;example id=&quot;tutorial-field_parallel-doof2d&quot;&gt;
***************
*** 876,886 ****
       included.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-field_parallel-doof2d-mesh&quot;&gt;
!      &lt;para&gt;These statements specify the spacing and number of
!      &field; values.  First, a layout is explicitly.  Then, a mesh,
!      which specifies the spacing between cells, is created.  The
!      &field;'s centering specifies one cell-centered value per
!      cell.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-field_parallel-doof2d-field_creation&quot;&gt;
       &lt;para&gt;&field;'s first template parameter specifies the type of
--- 870,879 ----
       included.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-field_parallel-doof2d-mesh&quot;&gt;
!      &lt;para&gt;These statements specify the spacing and number of &field;
!      values.  First, a layout is specified.  Then, a mesh, which
!      specifies the spacing between cells, is created.  The &field;'s
!      centering specifies one cell-centered value per cell.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-field_parallel-doof2d-field_creation&quot;&gt;
       &lt;para&gt;&field;'s first template parameter specifies the type of
***************
*** 907,931 ****
    Since the above program is designed for uniprocessor computation,
    specifying the domain specifies the layout.  A &field;'s
    &lt;firstterm&gt;mesh&lt;/firstterm&gt; specifies its spatial extent.  For
!   example, one can ask the mesh for the distance between two cells
!   or for the normals to a particular cell.  Cells in a
    &lt;type&gt;UniformRectilinearMesh&lt;/type&gt; all have the same size and are
!   parallelepipeds.  To create the mesh, one specifies the layout,
!   the location of the spatial point corresponding to the lower, left
    domain location, and the size of a particular cell.  Since this
!   program does not use mesh computations, our choices do not much
!   matter.  We specify the domain's lower, left corner is at spatial
!   location (0.0, 0.0) and each cell's width and height is&nbsp;1.
!   Thus, the middle of the cell at domain position (3,4) is (3.5,
!   4.5).&lt;/para&gt;
  
    &lt;para&gt;A &field; cell can contain one or more values although each
!   cell must have the same arrangement.  For this simulation, we
!   desire one value per cell so we place that position at the cell's
    center, i.e., a cell centering.  The
    &lt;function&gt;canonicalCentering&lt;/function&gt; function returns such a
!   centering.  We defer discussion of the latter two arguments to
!   &lt;xref linkend=&quot;sequential&quot;&gt;&lt;/xref&gt;.&lt;/para&gt;
  
    &lt;para&gt;A &field; declaration is analogous to an &array; declaration
    but must also specify a centering and a mesh.  In &lt;xref
--- 900,924 ----
    Since the above program is designed for uniprocessor computation,
    specifying the domain specifies the layout.  A &field;'s
    &lt;firstterm&gt;mesh&lt;/firstterm&gt; specifies its spatial extent.  For
!   example, one can ask the mesh for the distance between two cells or
!   for the normals to a particular cell.  Cells in a
    &lt;type&gt;UniformRectilinearMesh&lt;/type&gt; all have the same size and are
!   parallelepipeds.  To create the mesh, one specifies the layout, the
!   location of the spatial point corresponding to the lower, left
    domain location, and the size of a particular cell.  Since this
!   program does not use mesh computations, our choices do not matter.
!   We specify the domain's lower, left corner as spatial location (0.0,
!   0.0) and each cell's width and height as&nbsp;1.  Thus, the middle
!   of the cell at domain position (3,4) is (3.5, 4.5).&lt;/para&gt;
  
    &lt;para&gt;A &field; cell can contain one or more values although each
!   cell must have the same arrangement of values.  For this simulation,
!   we desire one value per cell so we place that position at the cell's
    center, i.e., a cell centering.  The
    &lt;function&gt;canonicalCentering&lt;/function&gt; function returns such a
!   centering.  &lt;![%unfinished;[ We defer discussion of the latter two arguments
!   to &lt;xref linkend=&quot;sequential&quot;&gt;&lt;/xref&gt; ]]&gt; &lt;!-- FIXME
!   unfinished --&gt; .&lt;/para&gt;
  
    &lt;para&gt;A &field; declaration is analogous to an &array; declaration
    but must also specify a centering and a mesh.  In &lt;xref
***************
*** 938,954 ****
    the &engine; type.  Since a &field; has a centering and a mesh in
    addition to a layout, those arguments are also necessary.&lt;/para&gt;
  
!   &lt;para&gt;&field; operations are a superset of &array; operations so
!   the &amp;doof2d; computations are the same as for &lt;xref
!   linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;.  &field;
!   accesses require parentheses, not square brackets, and accesses to
!   particular values should be preceded by calls to
    &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt;.&lt;/para&gt;
  
    &lt;para&gt;To summarize, &field;s support multiple values per cell and
    have spatial extent.  Thus, their declarations must specify a
    centering and a mesh.  Otherwise, a &field; program is similar to
!   one with &array;s.&lt;/para&gt;
   &lt;/section&gt;
  
  
--- 931,947 ----
    the &engine; type.  Since a &field; has a centering and a mesh in
    addition to a layout, those arguments are also necessary.&lt;/para&gt;
  
!   &lt;para&gt;&field; operations are a superset of &array; operations so the
!   &amp;doof2d; computations are the same as in &lt;xref
!   linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;.  &field; accesses
!   require parentheses, not square brackets, and accesses to individual
!   values should be preceded by calls to
    &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt;.&lt;/para&gt;
  
    &lt;para&gt;To summarize, &field;s support multiple values per cell and
    have spatial extent.  Thus, their declarations must specify a
    centering and a mesh.  Otherwise, a &field; program is similar to
!   one using &array;s.&lt;/para&gt;
   &lt;/section&gt;
  
  
***************
*** 956,970 ****
    &lt;title&gt;Distributed &field; Implementation&lt;/title&gt;
  
    &lt;para&gt;A &pooma; program using &field;s can execute on one or more
!   processors.  In &lt;xref
!   linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt;, we demonstrated how
!   to modify a uniprocessor stencil &array; implementation to run on
!   multiple processors.  In this section, we demonstrate that the
!   uniprocessor data-parallel &field; implementation of the previous
!   section can be converted.  Only the container declarations change;
!   the computations do not.  Since the changes are exactly analogous
!   to those in &lt;xref linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt;,
!   our exposition here will be shorter.&lt;/para&gt;
  
    &lt;example id=&quot;tutorial-field_distributed-doof2d&quot;&gt;
     &lt;title&gt;Distributed Data-Parallel &field; Implementation of &amp;doof2d;&lt;/title&gt;
--- 949,963 ----
    &lt;title&gt;Distributed &field; Implementation&lt;/title&gt;
  
    &lt;para&gt;A &pooma; program using &field;s can execute on one or more
!   processors.  In &lt;xref linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt;,
!   we demonstrated how to modify a uniprocessor stencil &array;
!   implementation to run on multiple processors.  In this section, we
!   demonstrate that the uniprocessor data-parallel &field;
!   implementation of the previous section can be similarly converted.
!   Only the container declarations change; the computations do not.
!   Since the changes are exactly analogous to those in &lt;xref
!   linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt;, our exposition here
!   will be shorter.&lt;/para&gt;
  
    &lt;example id=&quot;tutorial-field_distributed-doof2d&quot;&gt;
     &lt;title&gt;Distributed Data-Parallel &field; Implementation of &amp;doof2d;&lt;/title&gt;
***************
*** 974,985 ****
       &lt;para&gt;Multiple copies of a distributed program may
       simultaneously run, perhaps each having its own input and
       output.  Thus, we use command-line arguments to pass input to
!      the program.  Using an &inform; stream ensures only one program
       produces output.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-field_distributed-doof2d-layout&quot;&gt;
       &lt;para&gt;The &lt;type&gt;UniformGridPartition&lt;/type&gt; declaration
!      specifies how an array's domain will be partition, of split,
       into patches.  Guard layers are an optimization that can reduce
       data communication between patches.  The
       &lt;type&gt;UniformGridLayout&lt;/type&gt; declaration applies the
--- 967,978 ----
       &lt;para&gt;Multiple copies of a distributed program may
       simultaneously run, perhaps each having its own input and
       output.  Thus, we use command-line arguments to pass input to
!      the program.  Using an &inform; stream ensures only one copy
       produces output.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-field_distributed-doof2d-layout&quot;&gt;
       &lt;para&gt;The &lt;type&gt;UniformGridPartition&lt;/type&gt; declaration
!      specifies how an array's domain will be partitioned, or split,
       into patches.  Guard layers are an optimization that can reduce
       data communication between patches.  The
       &lt;type&gt;UniformGridLayout&lt;/type&gt; declaration applies the
***************
*** 991,998 ****
       uniprocessor and multiprocessor implementations.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-field_distributed-doof2d-remote&quot;&gt;
!      &lt;para&gt;The &lt;type&gt;MultiPatch&lt;/type&gt; &engine; distributes requests
!      for &array; values to the associated patch.  Since a patch may
       associated with a different processor, its
       &lt;quote&gt;remote&lt;/quote&gt; engine has type
       &lt;type&gt;Remote&lt;Brick&gt;&lt;/type&gt;.  &pooma; automatically
--- 984,991 ----
       uniprocessor and multiprocessor implementations.&lt;/para&gt;
      &lt;/callout&gt;
      &lt;callout arearefs=&quot;tutorial-field_distributed-doof2d-remote&quot;&gt;
!      &lt;para&gt;The &multipatch; &engine; distributes requests
!      for &field; values to the associated patch.  Since a patch may
       associated with a different processor, its
       &lt;quote&gt;remote&lt;/quote&gt; engine has type
       &lt;type&gt;Remote&lt;Brick&gt;&lt;/type&gt;.  &pooma; automatically
***************
*** 1038,1051 ****
      &lt;/listitem&gt;
      &lt;listitem&gt;
       &lt;para&gt;The command to invoke a distributed program is
!      system-dependent.  For example, the &lt;statement&gt;mpirun -np 4
!      Doof2d-Field-distributed -mpi 2 10 1000&lt;/statement&gt; command
       might use &mpi; communication.
!      &lt;statement&gt;Doof2d-Field-distributed -shmem -np 4 2 10
!      1000&lt;/statement&gt; might use the &mm; Shared Memory Library.&lt;/para&gt;
      &lt;/listitem&gt;
    &lt;/itemizedlist&gt;
    &lt;/para&gt;
   &lt;/section&gt;
! &lt;!-- FIXME: Do I need a chapter conclusion? --&gt;
  &lt;/chapter&gt;
--- 1031,1044 ----
      &lt;/listitem&gt;
      &lt;listitem&gt;
       &lt;para&gt;The command to invoke a distributed program is
!      system-dependent.  For example, the &lt;command&gt;mpirun -np 4
!      Doof2d-Field-distributed -mpi 2 10 1000&lt;/command&gt; command
       might use &mpi; communication.
!      &lt;command&gt;Doof2d-Field-distributed -shmem -np 4 2 10
!      1000&lt;/command&gt; might use the &mm; Shared Memory Library.&lt;/para&gt;
      &lt;/listitem&gt;
    &lt;/itemizedlist&gt;
    &lt;/para&gt;
   &lt;/section&gt;
! &lt;!-- FIXME: Add a chapter conclusion. --&gt;
  &lt;/chapter&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000886.html">Manual Patch: DynamicArrays and Part of Engines
</A></li>
	<LI>Next message: <A HREF="000888.html">[pooma-dev] Manual: Wordsmithing Changes to First Four Chapte	rs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#887">[ date ]</a>
              <a href="thread.html#887">[ thread ]</a>
              <a href="subject.html#887">[ subject ]</a>
              <a href="author.html#887">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
