<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] Add RectilinearMesh
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20%5BPATCH%5D%20Add%20RectilinearMesh&In-Reply-To=%3C40F2DBA6.3020907%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001623.html">
   <LINK REL="Next"  HREF="001624.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] Add RectilinearMesh</H1>
    <B>Jeffrey D. Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20%5BPATCH%5D%20Add%20RectilinearMesh&In-Reply-To=%3C40F2DBA6.3020907%40codesourcery.com%3E"
       TITLE="[PATCH] Add RectilinearMesh">oldham at codesourcery.com
       </A><BR>
    <I>Mon Jul 12 18:42:46 UTC 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001623.html">[PATCH] Add RectilinearMesh
</A></li>
        <LI>Next message: <A HREF="001624.html">grads
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1626">[ date ]</a>
              <a href="thread.html#1626">[ thread ]</a>
              <a href="subject.html#1626">[ subject ]</a>
              <a href="author.html#1626">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Richard Guenther wrote:

&gt;<i> Richard Guenther wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> This moves the particle tests to new Field.  RectilinearMesh still
</I>&gt;&gt;<i> missing for 2 and 4, though.  Hm, I remembered submitting that long time
</I>&gt;&gt;<i> ago.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Indeed I have.  This is mainly RectilinearMesh from v2.1 fixed for v2.4.
</I>&gt;<i> particle_test[24] will then work, too (after some minor fix).
</I>&gt;<i>
</I>&gt;<i> Ok?
</I>
Yes.  I wonder why I am listed as the last author to touch the file 
since I do not remember modifying it.  It's been a long time.

&gt;<i> Richard.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 2004Jul11  Richard Guenther &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">richard.guenther at uni-tuebingen.de</A>&gt;
</I>&gt;<i>
</I>&gt;<i>     * src/Field/Mesh/RectilinearMesh.h: new.
</I>&gt;<i>     src/Pooma/Fields.h: include RectilinearMesh.h.
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>Index: Pooma/Fields.h
</I>&gt;<i>===================================================================
</I>&gt;<i>RCS file: /home/pooma/Repository/r2/src/Pooma/Fields.h,v
</I>&gt;<i>retrieving revision 1.16
</I>&gt;<i>diff -u -u -r1.16 Fields.h
</I>&gt;<i>--- Pooma/Fields.h	21 Nov 2003 17:36:10 -0000	1.16
</I>&gt;<i>+++ Pooma/Fields.h	11 Jul 2004 17:05:25 -0000
</I>&gt;<i>@@ -55,6 +55,7 @@
</I>&gt;<i> 
</I>&gt;<i> #include &quot;Field/Mesh/NoMesh.h&quot;
</I>&gt;<i> #include &quot;Field/Mesh/UniformRectilinearMesh.h&quot;
</I>&gt;<i>+#include &quot;Field/Mesh/RectilinearMesh.h&quot;
</I>&gt;<i> #include &quot;Field/Mesh/MeshFunctions.h&quot;
</I>&gt;<i> #include &quot;Field/Mesh/PositionFunctions.h&quot;
</I>&gt;<i> 
</I>&gt;<i>Index: Field/Mesh/RectilinearMesh.h
</I>&gt;<i>===================================================================
</I>&gt;<i>RCS file: Field/Mesh/RectilinearMesh.h
</I>&gt;<i>diff -N Field/Mesh/RectilinearMesh.h
</I>&gt;<i>--- /dev/null	1 Jan 1970 00:00:00 -0000
</I>&gt;<i>+++ Field/Mesh/RectilinearMesh.h	11 Jul 2004 17:05:27 -0000
</I>&gt;<i>@@ -0,0 +1,904 @@
</I>&gt;<i>+// -*- C++ -*-
</I>&gt;<i>+// ACL:license
</I>&gt;<i>+// ----------------------------------------------------------------------
</I>&gt;<i>+// This software and ancillary information (herein called &quot;SOFTWARE&quot;)
</I>&gt;<i>+// called POOMA (Parallel Object-Oriented Methods and Applications) is
</I>&gt;<i>+// made available under the terms described here.  The SOFTWARE has been
</I>&gt;<i>+// approved for release with associated LA-CC Number LA-CC-98-65.
</I>&gt;<i>+// 
</I>&gt;<i>+// Unless otherwise indicated, this SOFTWARE has been authored by an
</I>&gt;<i>+// employee or employees of the University of California, operator of the
</I>&gt;<i>+// Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
</I>&gt;<i>+// the U.S. Department of Energy.  The U.S. Government has rights to use,
</I>&gt;<i>+// reproduce, and distribute this SOFTWARE. The public may copy, distribute,
</I>&gt;<i>+// prepare derivative works and publicly display this SOFTWARE without 
</I>&gt;<i>+// charge, provided that this Notice and any statement of authorship are 
</I>&gt;<i>+// reproduced on all copies.  Neither the Government nor the University 
</I>&gt;<i>+// makes any warranty, express or implied, or assumes any liability or 
</I>&gt;<i>+// responsibility for the use of this SOFTWARE.
</I>&gt;<i>+// 
</I>&gt;<i>+// If SOFTWARE is modified to produce derivative works, such modified
</I>&gt;<i>+// SOFTWARE should be clearly marked, so as not to confuse it with the
</I>&gt;<i>+// version available from LANL.
</I>&gt;<i>+// 
</I>&gt;<i>+// For more information about POOMA, send e-mail to <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">pooma at acl.lanl.gov</A>,
</I>&gt;<i>+// or visit the POOMA web page at <A HREF="http://www.acl.lanl.gov/pooma/.">http://www.acl.lanl.gov/pooma/.</A>
</I>&gt;<i>+// ----------------------------------------------------------------------
</I>&gt;<i>+// ACL:license
</I>&gt;<i>+
</I>&gt;<i>+/** @file
</I>&gt;<i>+ * @ingroup Mesh
</I>&gt;<i>+ * @brief
</I>&gt;<i>+ * A rectilinear mesh without uniform spacing between vertices.
</I>&gt;<i>+ */
</I>&gt;<i>+
</I>&gt;<i>+#ifndef POOMA_FIELD_MESH_RECTILINEARMESH_H
</I>&gt;<i>+#define POOMA_FIELD_MESH_RECTILINEARMESH_H
</I>&gt;<i>+
</I>&gt;<i>+//-----------------------------------------------------------------------------
</I>&gt;<i>+// Includes:
</I>&gt;<i>+//-----------------------------------------------------------------------------
</I>&gt;<i>+
</I>&gt;<i>+#include &lt;iostream&gt;
</I>&gt;<i>+
</I>&gt;<i>+#include &quot;Engine/ConstantFunctionEngine.h&quot;         // Used in functors
</I>&gt;<i>+#include &quot;Engine/IndexFunctionEngine.h&quot;            // Used in functors
</I>&gt;<i>+#include &quot;Layout/INode.h&quot;                          // Used in ctors
</I>&gt;<i>+#include &quot;Field/FieldEngine/FieldEnginePatch.h&quot; // Used in ctors
</I>&gt;<i>+#include &quot;Field/Mesh/NoMesh.h&quot;                  // Base class
</I>&gt;<i>+#include &quot;Field/FieldCentering.h&quot;               // Centering&lt;Dim&gt; inline
</I>&gt;<i>+#include &quot;Tiny/Vector.h&quot;                        // Class member
</I>&gt;<i>+#include &quot;Field/Mesh/MeshTraits.h&quot;              // Template parameter
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+//-----------------------------------------------------------------------------
</I>&gt;<i>+/// Holds the data for a rectilinear mesh. That class has a ref-counted
</I>&gt;<i>+/// instance of this class.
</I>&gt;<i>+//-----------------------------------------------------------------------------
</I>&gt;<i>+
</I>&gt;<i>+template &lt;class MeshTraits&gt;
</I>&gt;<i>+class RectilinearMeshData : public NoMeshData&lt;MeshTraits::dimensions&gt;
</I>&gt;<i>+{
</I>&gt;<i>+public:
</I>&gt;<i>+
</I>&gt;<i>+  // shortcuts to MeshTraits types
</I>&gt;<i>+  typedef typename MeshTraits::Domain_t Domain_t;
</I>&gt;<i>+  typedef typename MeshTraits::MeshData_t MeshData_t;
</I>&gt;<i>+  typedef typename MeshTraits::Scalar_t Scalar_t;
</I>&gt;<i>+  typedef typename MeshTraits::PointType_t PointType_t;
</I>&gt;<i>+  typedef typename MeshTraits::VectorType_t VectorType_t;
</I>&gt;<i>+  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
</I>&gt;<i>+  typedef typename MeshTraits::PositionsType_t PositionsType_t;
</I>&gt;<i>+
</I>&gt;<i>+  enum { dimensions = MeshTraits::dimensions };
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  // Constructors.
</I>&gt;<i>+
</I>&gt;<i>+  /// We provide a default constructor that creates the object with empty
</I>&gt;<i>+  /// domains. To be useful, this object must be replaced by another 
</I>&gt;<i>+  /// version via assignment.
</I>&gt;<i>+  
</I>&gt;<i>+  RectilinearMeshData()
</I>&gt;<i>+    { 
</I>&gt;<i>+      // This space intentionally left blank.
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// This constructor fully constructs the object. It uses the layout to
</I>&gt;<i>+  /// compute domains and also initializes the origin and the spacings in each
</I>&gt;<i>+  /// coordinate direction. The indices in the layout refer to VERTEX
</I>&gt;<i>+  /// positions.
</I>&gt;<i>+
</I>&gt;<i>+  template&lt;class Layout, class EngineTag&gt;
</I>&gt;<i>+  RectilinearMeshData(
</I>&gt;<i>+    const Layout &amp;layout,
</I>&gt;<i>+    const PointType_t &amp;origin,
</I>&gt;<i>+    const Vector&lt;dimensions, Array&lt;1, Scalar_t, EngineTag&gt; &gt; &amp;spacings)
</I>&gt;<i>+  : NoMeshData&lt;dimensions&gt;(layout), 
</I>&gt;<i>+    origin_m(origin)
</I>&gt;<i>+    //spacings_m(spacings)
</I>&gt;<i>+    {
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++) {
</I>&gt;<i>+	spacings_m(i).engine() = spacings(i).engine(); // init
</I>&gt;<i>+	spacings_m(i).engine().makeOwnCopy(); // FIXME? Do we want this?
</I>&gt;<i>+	Interval&lt;1&gt; I(layout.domain()[i]);
</I>&gt;<i>+	positions_m(i).engine() = Engine&lt;1, Scalar_t, Brick&gt;(I);
</I>&gt;<i>+	positions_m(i)(0) = origin_m(i);
</I>&gt;<i>+	// initialize from origin downward the ghost cells
</I>&gt;<i>+	for (int j=-1; j&gt;=I.min(); j--)
</I>&gt;<i>+	  positions_m(i)(j) = positions_m(i).read(j+1) - spacings_m(i).read(j);
</I>&gt;<i>+	// initialize from origin upward
</I>&gt;<i>+	for (int j=1; j&lt;=I.max(); j++)
</I>&gt;<i>+	  positions_m(i)(j) = positions_m(i).read(j-1) + spacings_m(i).read(j-1);
</I>&gt;<i>+      }
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// Constructor for constructing evenly spaced rectilinear meshes just
</I>&gt;<i>+  /// like UniformRectilinearMesh does.
</I>&gt;<i>+
</I>&gt;<i>+  template&lt;class Layout&gt;
</I>&gt;<i>+  RectilinearMeshData(
</I>&gt;<i>+    const Layout &amp;layout,
</I>&gt;<i>+    const PointType_t &amp;origin,
</I>&gt;<i>+    const VectorType_t &amp;spacings)
</I>&gt;<i>+  : NoMeshData&lt;dimensions&gt;(layout), 
</I>&gt;<i>+    origin_m(origin)
</I>&gt;<i>+    {
</I>&gt;<i>+      // for each dimension we allocate engines for spacings &amp; positions
</I>&gt;<i>+      // and initialize them according to origin/spacings
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++) {
</I>&gt;<i>+	Interval&lt;1&gt; I(layout.domain()[i]);
</I>&gt;<i>+	// allocate and assign spacings
</I>&gt;<i>+	spacings_m(i).engine() = Engine&lt;1, Scalar_t, Brick&gt;(I);
</I>&gt;<i>+	spacings_m(i)(I) = spacings(i); // no Array.all()
</I>&gt;<i>+	Pooma::blockAndEvaluate();
</I>&gt;<i>+	// allocate positions, assign origin
</I>&gt;<i>+	positions_m(i).engine() = Engine&lt;1, Scalar_t, Brick&gt;(I);
</I>&gt;<i>+	positions_m(i)(0) = origin_m(i);
</I>&gt;<i>+	// initialize from origin downward the ghost cells
</I>&gt;<i>+	for (int j=-1; j&gt;=I.min(); j--)
</I>&gt;<i>+	  positions_m(i)(j) = positions_m(i).read(j+1) - spacings_m(i).read(j);
</I>&gt;<i>+	// initialize from origin upward
</I>&gt;<i>+	for (int j=1; j&lt;=I.max(); j++)
</I>&gt;<i>+	  positions_m(i)(j) = positions_m(i).read(j-1) + spacings_m(i).read(j-1);
</I>&gt;<i>+      }
</I>&gt;<i>+    }
</I>&gt;<i>+    
</I>&gt;<i>+  /// Copy constructor.
</I>&gt;<i>+
</I>&gt;<i>+  RectilinearMeshData(const MeshData_t &amp;model)
</I>&gt;<i>+  : NoMeshData&lt;dimensions&gt;(model), 
</I>&gt;<i>+    origin_m(model.origin_m)
</I>&gt;<i>+    //spacings_m(model.spacings_m),
</I>&gt;<i>+    //positions_m(model.positions_m)
</I>&gt;<i>+    {
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++) {
</I>&gt;<i>+	spacings_m(i).engine() = model.spacings_m(i).engine();
</I>&gt;<i>+	positions_m(i).engine() = model.positions_m(i).engine();
</I>&gt;<i>+      }
</I>&gt;<i>+      // This space intentionally left blank.
</I>&gt;<i>+    } 
</I>&gt;<i>+    
</I>&gt;<i>+  /// @name View constructors.
</I>&gt;<i>+  //@{
</I>&gt;<i>+  
</I>&gt;<i>+  /// Interval view. This means that we simply need to adjust the
</I>&gt;<i>+  /// origin by the amount the view is offset from the model's physical
</I>&gt;<i>+  /// cell domain. We rely on the base class to do the heavy lifting
</I>&gt;<i>+  /// with respect to figuring out the domains correctly.
</I>&gt;<i>+  ///
</I>&gt;<i>+  /// The Interval supplied must refer to VERTEX positions.
</I>&gt;<i>+  
</I>&gt;<i>+  RectilinearMeshData(const MeshData_t &amp;model, 
</I>&gt;<i>+		      const Interval&lt;dimensions&gt; &amp;d)
</I>&gt;<i>+  : NoMeshData&lt;dimensions&gt;(d)
</I>&gt;<i>+    {
</I>&gt;<i>+      for (int i = 0; i &lt; dimensions; i++) {
</I>&gt;<i>+	// FIXME: Wheeee ;) (we cant store a BrickView...
</I>&gt;<i>+	// and still dont want to copy)
</I>&gt;<i>+	spacings_m(i).engine() = Engine&lt;1, Scalar_t, Brick&gt;(&amp;model.spacings_m(i)(d[i])(0), d[i]);
</I>&gt;<i>+	positions_m(i).engine() = Engine&lt;1, Scalar_t, Brick&gt;(&amp;model.positions_m(i)(d[i])(0), d[i]);
</I>&gt;<i>+	origin_m(i) = positions_m(i)(d[i].min());
</I>&gt;<i>+      }
</I>&gt;<i>+    }
</I>&gt;<i>+#if 0  
</I>&gt;<i>+  /// FieldEnginePatch view. We don't fiddle with the origin because we are not
</I>&gt;<i>+  /// making the domain zero-based.
</I>&gt;<i>+  ///
</I>&gt;<i>+  /// The domain supplied by the FieldEnginePatch must refer to VERTEX
</I>&gt;<i>+  /// positions.
</I>&gt;<i>+  
</I>&gt;<i>+  RectilinearMeshData(const MeshData_t &amp;model, 
</I>&gt;<i>+		      const FieldEnginePatch&lt;dimensions&gt; &amp;p)
</I>&gt;<i>+  : NoMeshData&lt;dimensions&gt;(model, p),
</I>&gt;<i>+    origin_m(model.origin_m),
</I>&gt;<i>+    spacings_m(model.spacings_m),
</I>&gt;<i>+    positions_m(model.spacings_m)
</I>&gt;<i>+    {
</I>&gt;<i>+      std::cerr &lt;&lt; &quot;RectilinearMeshData(FieldEnginePatch) constructor called&quot; &lt;&lt; std::endl;
</I>&gt;<i>+      abort();
</I>&gt;<i>+      // FIXME: what does FieldEnginePatch do???
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++) {
</I>&gt;<i>+	spacings_m(i).engine() = model.spacings_m(i).engine();
</I>&gt;<i>+	positions_m(i).engine() = model.positions_m(i).engine();
</I>&gt;<i>+      }
</I>&gt;<i>+    }
</I>&gt;<i>+#endif
</I>&gt;<i>+  //@}
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  /// Copy assignment operator.
</I>&gt;<i>+  
</I>&gt;<i>+  MeshData_t &amp;
</I>&gt;<i>+  operator=(const MeshData_t &amp;rhs)
</I>&gt;<i>+    {
</I>&gt;<i>+      if (this != &amp;rhs)
</I>&gt;<i>+        {
</I>&gt;<i>+          NoMeshData&lt;dimensions&gt;::operator=(rhs);
</I>&gt;<i>+          origin_m = rhs.origin_m;
</I>&gt;<i>+	  for (int i=0; i&lt;dimensions; i++) {
</I>&gt;<i>+	    spacings_m(i).engine() = rhs.spacings_m(i).engine();
</I>&gt;<i>+	    positions_m(i).engine() = rhs.positions_m(i).engine();
</I>&gt;<i>+	  }
</I>&gt;<i>+        }
</I>&gt;<i>+        
</I>&gt;<i>+      return *this;
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  /// Empty destructor is fine. Note, however, that NoMeshData does not have
</I>&gt;<i>+  /// a virtual destructor. We must be careful to delete these puppies as
</I>&gt;<i>+  /// RectilinearMeshData.
</I>&gt;<i>+
</I>&gt;<i>+  ~RectilinearMeshData() { }
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  /// @name General accessors.
</I>&gt;<i>+  //@{
</I>&gt;<i>+
</I>&gt;<i>+  /// The mesh spacing.
</I>&gt;<i>+  
</I>&gt;<i>+  inline const SpacingsType_t &amp;spacings() const 
</I>&gt;<i>+    { 
</I>&gt;<i>+      return spacings_m; 
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The mesh vertex positions.
</I>&gt;<i>+  
</I>&gt;<i>+  inline const PositionsType_t &amp;positions() const 
</I>&gt;<i>+    { 
</I>&gt;<i>+      return positions_m; 
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The mesh origin.
</I>&gt;<i>+
</I>&gt;<i>+  inline const PointType_t &amp;origin() const 
</I>&gt;<i>+    { 
</I>&gt;<i>+      return origin_m; 
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  //@}
</I>&gt;<i>+
</I>&gt;<i>+private:
</I>&gt;<i>+
</I>&gt;<i>+  /// Origin of mesh (coordinate vector of first vertex).
</I>&gt;<i>+
</I>&gt;<i>+  PointType_t origin_m;
</I>&gt;<i>+
</I>&gt;<i>+  /// Spacings between vertices.
</I>&gt;<i>+
</I>&gt;<i>+  SpacingsType_t spacings_m;
</I>&gt;<i>+
</I>&gt;<i>+  /// Vertex positions.
</I>&gt;<i>+
</I>&gt;<i>+  PositionsType_t positions_m;
</I>&gt;<i>+
</I>&gt;<i>+};
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+///
</I>&gt;<i>+/// RectilinearMesh is a rectilinear mesh sometimes called a 
</I>&gt;<i>+/// &quot;cartesian product&quot; or &quot;tensor product&quot; mesh. Each dimension has a
</I>&gt;<i>+/// spacing value between every pair of vertices along that dimension;
</I>&gt;<i>+/// these spacings can all be different.
</I>&gt;<i>+///
</I>&gt;<i>+template&lt;class MeshTraits&gt;
</I>&gt;<i>+class RectilinearMesh : public MeshTraits::CoordinateSystem_t
</I>&gt;<i>+{
</I>&gt;<i>+public:
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  // Exported typedefs and enumerations.
</I>&gt;<i>+
</I>&gt;<i>+  typedef MeshTraits MeshTraits_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type of the mesh class.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::Mesh_t Mesh_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type of the mesh data class.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::MeshData_t MeshData_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type of the coordinate system.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::CoordinateSystem_t CoordinateSystem_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type of domains.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::Domain_t Domain_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type of locations.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::Loc_t Loc_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type T, used to represent, for example, volumes &amp; areas, etc.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::T_t T_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type of scalars.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::Scalar_t Scalar_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type of mesh points.
</I>&gt;<i>+    
</I>&gt;<i>+  typedef typename MeshTraits::PointType_t PointType_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type of vectors used to represent, for example, normals.
</I>&gt;<i>+  
</I>&gt;<i>+  typedef typename MeshTraits::VectorType_t VectorType_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type used to store spacings.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type used to store positions.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::PositionsType_t PositionsType_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The number of indices required to select a point in this mesh.
</I>&gt;<i>+
</I>&gt;<i>+  enum { dimensions = MeshTraits::dimensions };
</I>&gt;<i>+
</I>&gt;<i>+  /// The number of components of a position vector inside the mesh.
</I>&gt;<i>+
</I>&gt;<i>+  enum { coordinateDimensions = MeshTraits::coordinateDimensions };
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  // Constructors.
</I>&gt;<i>+  
</I>&gt;<i>+  /// We supply a default constructor, but it doesn't generate a useful mesh.
</I>&gt;<i>+  /// This is accomplished through assignment.
</I>&gt;<i>+  
</I>&gt;<i>+  RectilinearMesh() 
</I>&gt;<i>+  : data_m(new MeshData_t)
</I>&gt;<i>+    { 
</I>&gt;<i>+      // This space intentionally left blank.
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// This constructor fully constructs the object. It uses the layout to
</I>&gt;<i>+  /// compute domains and also initializes the origin and the spacings in each
</I>&gt;<i>+  /// coordinate direction.
</I>&gt;<i>+  ///
</I>&gt;<i>+  /// The Layout supplied must refer to VERTEX positions.
</I>&gt;<i>+  
</I>&gt;<i>+  template&lt;class Layout, class EngineTag&gt;
</I>&gt;<i>+  inline RectilinearMesh(const Layout &amp;layout, 
</I>&gt;<i>+			 const PointType_t &amp;origin,
</I>&gt;<i>+			 const Vector&lt;coordinateDimensions, Array&lt;1, T_t, EngineTag&gt; &gt; &amp;spacings)
</I>&gt;<i>+  : data_m(new MeshData_t(layout, origin, spacings))
</I>&gt;<i>+    { 
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// Constructor compatible to UniformRectilinearMesh.
</I>&gt;<i>+
</I>&gt;<i>+  template&lt;class Layout&gt;
</I>&gt;<i>+  inline RectilinearMesh(const Layout &amp;layout,
</I>&gt;<i>+			 const PointType_t &amp;origin,
</I>&gt;<i>+			 const PointType_t &amp;spacings)
</I>&gt;<i>+  : data_m(new MeshData_t(layout, origin, spacings))
</I>&gt;<i>+    { 
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  template&lt;class Layout&gt;
</I>&gt;<i>+  inline explicit RectilinearMesh(const Layout &amp;layout)
</I>&gt;<i>+  : data_m(new MeshData_t(layout, 
</I>&gt;<i>+					   PointType_t(0), 
</I>&gt;<i>+					   PointType_t(1)))
</I>&gt;<i>+    { 
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// Copy constructor. 
</I>&gt;<i>+  
</I>&gt;<i>+  inline RectilinearMesh(const Mesh_t &amp;model)
</I>&gt;<i>+  : data_m(model.data_m)
</I>&gt;<i>+    {
</I>&gt;<i>+    }
</I>&gt;<i>+    
</I>&gt;<i>+  /// @name View constructors
</I>&gt;<i>+  /// These are the only possible views of this
</I>&gt;<i>+  /// mesh. Other views will make a NoMesh.
</I>&gt;<i>+  //@{ 
</I>&gt;<i>+  
</I>&gt;<i>+  /// Interval view.
</I>&gt;<i>+  ///
</I>&gt;<i>+  /// The Interval supplied must refer to VERTEX positions.
</I>&gt;<i>+  
</I>&gt;<i>+  inline RectilinearMesh(const Mesh_t &amp;model, 
</I>&gt;<i>+			 const Domain_t &amp;d)
</I>&gt;<i>+  : data_m(new MeshData_t(*model.data_m, d))
</I>&gt;<i>+    {
</I>&gt;<i>+    }
</I>&gt;<i>+  
</I>&gt;<i>+  /// INode view.
</I>&gt;<i>+  ///
</I>&gt;<i>+  /// The INode supplied must refer to VERTEX positions.
</I>&gt;<i>+  
</I>&gt;<i>+  inline RectilinearMesh(const Mesh_t &amp;model, 
</I>&gt;<i>+			 const INode&lt;dimensions&gt; &amp;i)
</I>&gt;<i>+  : data_m(new MeshData_t(*model.data_m, i.domain()))
</I>&gt;<i>+    {
</I>&gt;<i>+    }
</I>&gt;<i>+#if 0
</I>&gt;<i>+  /// FieldEnginePatch view.
</I>&gt;<i>+  ///
</I>&gt;<i>+  /// The FieldEnginePatch supplied must refer to VERTEX positions.
</I>&gt;<i>+  
</I>&gt;<i>+  inline RectilinearMesh(const Mesh_t &amp;model, 
</I>&gt;<i>+			 const FieldEnginePatch&lt;dimensions&gt; &amp;p)
</I>&gt;<i>+  : data_m(new MeshData_t(*model.data_m, p))
</I>&gt;<i>+    {
</I>&gt;<i>+    }
</I>&gt;<i>+#endif
</I>&gt;<i>+  //@}
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  /// Copy assignment operator.
</I>&gt;<i>+  
</I>&gt;<i>+  inline Mesh_t &amp;
</I>&gt;<i>+  operator=(const Mesh_t &amp;rhs)
</I>&gt;<i>+    {
</I>&gt;<i>+      if (&amp;rhs != this)
</I>&gt;<i>+        {
</I>&gt;<i>+          data_m = rhs.data_m;
</I>&gt;<i>+        }
</I>&gt;<i>+      
</I>&gt;<i>+      return *this;
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  /// Empty destructor is fine. The pointer to the data is ref-counted so its
</I>&gt;<i>+  /// lifetime is correctly managed.
</I>&gt;<i>+  
</I>&gt;<i>+  ~RectilinearMesh()
</I>&gt;<i>+    {
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// Data member access.
</I>&gt;<i>+  const MeshData_t&amp; data() const
</I>&gt;<i>+    {
</I>&gt;<i>+      return *data_m;
</I>&gt;<i>+    }
</I>&gt;<i>+  
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  /// @name Domain functions.
</I>&gt;<i>+  //@{
</I>&gt;<i>+  
</I>&gt;<i>+  /// The vertex domain, as the mesh was constructed with.
</I>&gt;<i>+
</I>&gt;<i>+  inline const Domain_t &amp;physicalVertexDomain() const
</I>&gt;<i>+    {
</I>&gt;<i>+      return data_m-&gt;physicalVertexDomain(); 
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// Function that returns a domain adjusted to give the indices of the cells.
</I>&gt;<i>+
</I>&gt;<i>+  inline const Domain_t &amp;physicalCellDomain() const
</I>&gt;<i>+    {
</I>&gt;<i>+      return data_m-&gt;physicalCellDomain(); 
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The total vertex domain, including mesh guard vertices.
</I>&gt;<i>+
</I>&gt;<i>+  inline const Domain_t &amp;totalVertexDomain() const
</I>&gt;<i>+    {
</I>&gt;<i>+      return data_m-&gt;totalVertexDomain(); 
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The total cell domain, including mesh guard cells.
</I>&gt;<i>+
</I>&gt;<i>+  inline const Domain_t &amp;totalCellDomain() const
</I>&gt;<i>+    {
</I>&gt;<i>+      return data_m-&gt;totalCellDomain(); 
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  //@}
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  /// @name General accessors.
</I>&gt;<i>+  //@{
</I>&gt;<i>+
</I>&gt;<i>+  /// The mesh origin.
</I>&gt;<i>+
</I>&gt;<i>+  inline const PointType_t &amp;origin() const 
</I>&gt;<i>+    { 
</I>&gt;<i>+      return data_m-&gt;origin();
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The mesh spacing. Return type is dependend on mesh type.
</I>&gt;<i>+
</I>&gt;<i>+  inline const SpacingsType_t &amp;spacings() const 
</I>&gt;<i>+    { 
</I>&gt;<i>+      return data_m-&gt;spacings();
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The mesh positions. Return type is dependend on mesh type.
</I>&gt;<i>+
</I>&gt;<i>+  inline const PositionsType_t &amp;positions() const 
</I>&gt;<i>+    { 
</I>&gt;<i>+      return data_m-&gt;positions();
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The cell containing a particular point.
</I>&gt;<i>+
</I>&gt;<i>+  inline Loc_t cellContaining(const PointType_t &amp;point) const
</I>&gt;<i>+    {
</I>&gt;<i>+      /// FIXME
</I>&gt;<i>+      Loc_t loc((0, Pooma::NoInit()));	// Avoid a g++ parse error.
</I>&gt;<i>+      for (int i = 0; i &lt; dimensions; i++)
</I>&gt;<i>+	{
</I>&gt;<i>+	  const T_t *start = &amp;positions()(i)(0);
</I>&gt;<i>+	  const T_t *finish = start + positions()(i).physicalDomain()[i].length();
</I>&gt;<i>+	  const T_t *p = std::lower_bound(start, finish, point(i));
</I>&gt;<i>+#if POOMA_BOUNDS_CHECK
</I>&gt;<i>+	  PInsist(p != finish,
</I>&gt;<i>+		  &quot;Rectilinear::cellContaining(): point is outside mesh.&quot;);
</I>&gt;<i>+#endif
</I>&gt;<i>+	  // The lower_bound function returns the first element that is not
</I>&gt;<i>+	  // less than the point we're searching for.
</I>&gt;<i>+	  int j = static_cast&lt;int&gt;(std::distance(start, p));
</I>&gt;<i>+	  if (*p == point(i))
</I>&gt;<i>+	    loc[i] = j;
</I>&gt;<i>+	  else
</I>&gt;<i>+	    loc[i] = j-1;
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i>+      return loc;
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The lower-left vertex associated with a given cell location.
</I>&gt;<i>+    
</I>&gt;<i>+  inline PointType_t vertexPosition(const Loc_t &amp;loc) const
</I>&gt;<i>+    {
</I>&gt;<i>+      PointType_t point;
</I>&gt;<i>+      for (int i = 0; i &lt; dimensions; i++)
</I>&gt;<i>+        point(i) = positions()(i)(loc[i]); 
</I>&gt;<i>+      return point;
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  inline Scalar_t vertexPosition(int dim, int i) const
</I>&gt;<i>+    {
</I>&gt;<i>+      return positions()(dim)(i);
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The position of a given cell location for canonical cell centering.
</I>&gt;<i>+
</I>&gt;<i>+  inline PointType_t cellPosition(const Loc_t &amp;loc) const
</I>&gt;<i>+    {
</I>&gt;<i>+      PointType_t point;
</I>&gt;<i>+
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++)
</I>&gt;<i>+	point(i) = positions()(i)(loc[i]) + 0.5*spacings()(i)(loc[i]);
</I>&gt;<i>+
</I>&gt;<i>+      return point;
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  inline Scalar_t cellPosition(int dim, int i) const
</I>&gt;<i>+    {
</I>&gt;<i>+      return positions()(dim)(i) + 0.5*spacings()(dim)(i);
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The vertex spacing for a given cell location.
</I>&gt;<i>+
</I>&gt;<i>+  inline VectorType_t vertexSpacing(const Loc_t &amp;loc) const
</I>&gt;<i>+    {
</I>&gt;<i>+      VectorType_t delta;
</I>&gt;<i>+
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++)
</I>&gt;<i>+	delta(i) = spacings()(i)(loc[i]);
</I>&gt;<i>+
</I>&gt;<i>+      return delta;
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  inline Scalar_t vertexSpacing(int dim, int i) const
</I>&gt;<i>+    {
</I>&gt;<i>+      return spacings()(dim)(i);
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  /// The cell spacing for a given cell location.
</I>&gt;<i>+
</I>&gt;<i>+  inline VectorType_t cellSpacing(const Loc_t &amp;loc) const
</I>&gt;<i>+    {
</I>&gt;<i>+      VectorType_t delta;
</I>&gt;<i>+
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++)
</I>&gt;<i>+	delta(i) = 0.5 * (spacings()(i)(loc[i]) + spacings()(i)(loc[i]+1));
</I>&gt;<i>+
</I>&gt;<i>+      return delta;
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  inline Scalar_t cellSpacing(int dim, int i) const
</I>&gt;<i>+    {
</I>&gt;<i>+      return 0.5*(spacings()(dim)(i) + spacings()(dim)(i+1));
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  //@}
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+private:
</I>&gt;<i>+
</I>&gt;<i>+  /// Our data, stored as a ref-counted pointer to simplify memory management.
</I>&gt;<i>+  
</I>&gt;<i>+  RefCountedPtr&lt;MeshData_t&gt; data_m;
</I>&gt;<i>+};
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+///
</I>&gt;<i>+/// GenericRM contains mesh functions related functors that are applicapble
</I>&gt;<i>+/// regardless of the coordinate system type.
</I>&gt;<i>+///
</I>&gt;<i>+template &lt;class MeshTraits&gt;
</I>&gt;<i>+struct GenericRM {
</I>&gt;<i>+
</I>&gt;<i>+  /// The coordinate type.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::T_t T_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The mesh data class.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::Mesh_t Mesh_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type to represent points.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::PointType_t PointType_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type to represent vectors.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::VectorType_t VectorType_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type to represent the spacings.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::SpacingsType_t SpacingsType_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type used to store positions.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::PositionsType_t PositionsType_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// The type of locations.
</I>&gt;<i>+
</I>&gt;<i>+  typedef typename MeshTraits::Loc_t Loc_t;
</I>&gt;<i>+
</I>&gt;<i>+  /// Dimensionality of the mesh.
</I>&gt;<i>+
</I>&gt;<i>+  enum { dimensions = MeshTraits::dimensions };
</I>&gt;<i>+  enum { coordinateDimensions = MeshTraits::coordinateDimensions };
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  /// Support for the positions() function. We need to provide a functor for
</I>&gt;<i>+  /// use with IndexFunction-engine. We also need to export the
</I>&gt;<i>+  /// PositionsEngineTag_t typedef and the positionsFunctor() member function,
</I>&gt;<i>+  /// which computes the positions using the centering point positions.
</I>&gt;<i>+  /// The indices passed in refer to cells.
</I>&gt;<i>+  
</I>&gt;<i>+  class PositionsFunctor {
</I>&gt;<i>+  public:
</I>&gt;<i>+  
</I>&gt;<i>+    /// Need to be able to default construct since we fill in the details
</I>&gt;<i>+    /// after the fact.
</I>&gt;<i>+
</I>&gt;<i>+    // WARNING! For Arrays to be initialized (copy constructed, assigned,
</I>&gt;<i>+    //          etc.) correctly, even in the case of uninitialized targets
</I>&gt;<i>+    //          we need to copy the engines explicitly rather than rely
</I>&gt;<i>+    //          on the compiler generating correct copy constructors and
</I>&gt;<i>+    //          assignment operators.
</I>&gt;<i>+    // FIXME! Technically we either can dump the copy constructor or the
</I>&gt;<i>+    //        assignment operator.
</I>&gt;<i>+
</I>&gt;<i>+    PositionsFunctor() { }
</I>&gt;<i>+    
</I>&gt;<i>+    PositionsFunctor(const Mesh_t &amp;m, 
</I>&gt;<i>+                     const Centering&lt;dimensions&gt; &amp;c)
</I>&gt;<i>+      : centering_m(c.position(0))
</I>&gt;<i>+      {
</I>&gt;<i>+	for (int i=0; i&lt;dimensions; i++) {
</I>&gt;<i>+	  positions_m(i).engine() = m.positions()(i).engine();
</I>&gt;<i>+	  spacings_m(i).engine() = m.spacings()(i).engine();
</I>&gt;<i>+	}
</I>&gt;<i>+      }
</I>&gt;<i>+
</I>&gt;<i>+    PositionsFunctor(const PositionsFunctor &amp;m)
</I>&gt;<i>+      :	centering_m(m.centering_m)
</I>&gt;<i>+    {
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++) {
</I>&gt;<i>+	positions_m(i).engine() = m.positions_m(i).engine();
</I>&gt;<i>+	spacings_m(i).engine() = m.spacings_m(i).engine();
</I>&gt;<i>+      }
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+    PositionsFunctor&amp; operator=(const PositionsFunctor &amp;m)
</I>&gt;<i>+    {
</I>&gt;<i>+      centering_m = m.centering_m;
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++) {
</I>&gt;<i>+	positions_m(i).engine() = m.positions_m(i).engine();
</I>&gt;<i>+	spacings_m(i).engine() = m.spacings_m(i).engine();
</I>&gt;<i>+      }
</I>&gt;<i>+
</I>&gt;<i>+      return *this;
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+    inline PointType_t operator()(int i0) const
</I>&gt;<i>+      {
</I>&gt;<i>+        return PointType_t(positions_m(0).read(i0) + spacings_m(0).read(i0)*centering_m(0));
</I>&gt;<i>+      }
</I>&gt;<i>+      
</I>&gt;<i>+    inline PointType_t operator()(int i0, int i1) const
</I>&gt;<i>+      {
</I>&gt;<i>+        return PointType_t(positions_m(0).read(i0) + spacings_m(0).read(i0)*centering_m(0),
</I>&gt;<i>+			   positions_m(1).read(i1) + spacings_m(1).read(i1)*centering_m(1));
</I>&gt;<i>+      }
</I>&gt;<i>+
</I>&gt;<i>+    inline PointType_t operator()(int i0, int i1, int i2) const
</I>&gt;<i>+      {
</I>&gt;<i>+        return PointType_t(positions_m(0).read(i0) + spacings_m(0).read(i0)*centering_m(0),
</I>&gt;<i>+			   positions_m(1).read(i1) + spacings_m(1).read(i1)*centering_m(1),
</I>&gt;<i>+			   positions_m(2).read(i2) + spacings_m(2).read(i2)*centering_m(2));
</I>&gt;<i>+      }
</I>&gt;<i>+
</I>&gt;<i>+  private:
</I>&gt;<i>+
</I>&gt;<i>+    PositionsType_t positions_m;
</I>&gt;<i>+    SpacingsType_t spacings_m;
</I>&gt;<i>+    typename Centering&lt;dimensions&gt;::Position centering_m;
</I>&gt;<i>+
</I>&gt;<i>+  };
</I>&gt;<i>+  
</I>&gt;<i>+  typedef IndexFunction&lt;PositionsFunctor&gt; PositionsEngineTag_t;
</I>&gt;<i>+
</I>&gt;<i>+  template &lt;class PositionsEngineTag&gt;
</I>&gt;<i>+  void initializePositions(
</I>&gt;<i>+    Engine&lt;dimensions, PointType_t, PositionsEngineTag&gt; &amp;e, 
</I>&gt;<i>+    const Centering&lt;dimensions&gt; &amp;c) const
</I>&gt;<i>+    {
</I>&gt;<i>+      e.setFunctor(typename PositionsEngineTag::Functor_t(static_cast&lt;const Mesh_t&amp;&gt;(*this), c));
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  /// Support for the spacings() function. We need to provide a functor for
</I>&gt;<i>+  /// use with IndexFunction-engine. We also need to export the
</I>&gt;<i>+  /// SpacingsEngineTag_t typedef and the spacingsFunctor() member function,
</I>&gt;<i>+  /// which computes the spacings using the centering point positions.
</I>&gt;<i>+  /// The indices passed in refer to cells.
</I>&gt;<i>+  
</I>&gt;<i>+  class SpacingsFunctor {
</I>&gt;<i>+  public:
</I>&gt;<i>+  
</I>&gt;<i>+    /// Need to be able to default construct since we fill in the details
</I>&gt;<i>+    /// after the fact.
</I>&gt;<i>+
</I>&gt;<i>+    // WARNING! For Arrays to be initialized (copy constructed, assigned,
</I>&gt;<i>+    //          etc.) correctly, even in the case of uninitialized targets
</I>&gt;<i>+    //          we need to copy the engines explicitly rather than rely
</I>&gt;<i>+    //          on the compiler generating correct copy constructors and
</I>&gt;<i>+    //          assignment operators.
</I>&gt;<i>+    // FIXME! Technically we either can dump the copy constructor or the
</I>&gt;<i>+    //        assignment operator.
</I>&gt;<i>+
</I>&gt;<i>+    SpacingsFunctor() { }
</I>&gt;<i>+    
</I>&gt;<i>+    SpacingsFunctor(const Mesh_t &amp;m, 
</I>&gt;<i>+		    const Centering&lt;dimensions&gt; &amp;c)
</I>&gt;<i>+      : centering_m(c.position(0))
</I>&gt;<i>+      {
</I>&gt;<i>+	for (int i=0; i&lt;dimensions; i++)
</I>&gt;<i>+	  spacings_m(i).engine() = m.spacings()(i).engine();
</I>&gt;<i>+      }
</I>&gt;<i>+
</I>&gt;<i>+    SpacingsFunctor(const SpacingsFunctor &amp;m)
</I>&gt;<i>+      :	centering_m(m.centering_m)
</I>&gt;<i>+    {
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++)
</I>&gt;<i>+	spacings_m(i).engine() = m.spacings_m(i).engine();
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+    SpacingsFunctor&amp; operator=(const SpacingsFunctor &amp;m)
</I>&gt;<i>+    {
</I>&gt;<i>+      centering_m = m.centering_m;
</I>&gt;<i>+      for (int i=0; i&lt;dimensions; i++)
</I>&gt;<i>+	spacings_m(i).engine() = m.spacings_m(i).engine();
</I>&gt;<i>+
</I>&gt;<i>+      return *this;
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+    /* FIXME: the following may cause an out of bound condition, if
</I>&gt;<i>+     *        the spacings is queried for the last cell - spacings
</I>&gt;<i>+     *        for non-existing cells are used then.
</I>&gt;<i>+     */
</I>&gt;<i>+
</I>&gt;<i>+    inline VectorType_t operator()(int i0) const
</I>&gt;<i>+      {
</I>&gt;<i>+        return VectorType_t(spacings_m(0).read(i0)
</I>&gt;<i>+			   + (spacings_m(0).read(i0+1)-spacings_m(0).read(i0))*centering_m(0));
</I>&gt;<i>+      }
</I>&gt;<i>+      
</I>&gt;<i>+    inline VectorType_t operator()(int i0, int i1) const
</I>&gt;<i>+      {
</I>&gt;<i>+        return VectorType_t(spacings_m(0).read(i0)
</I>&gt;<i>+			   + (spacings_m(0).read(i0+1)-spacings_m(0).read(i0))*centering_m(0),
</I>&gt;<i>+			   spacings_m(1).read(i1)
</I>&gt;<i>+			   + (spacings_m(1).read(i1+1)-spacings_m(1).read(i1))*centering_m(1));
</I>&gt;<i>+      }
</I>&gt;<i>+
</I>&gt;<i>+    inline VectorType_t operator()(int i0, int i1, int i2) const
</I>&gt;<i>+      {
</I>&gt;<i>+        return VectorType_t(spacings_m(0).read(i0)
</I>&gt;<i>+			   + (spacings_m(0).read(i0+1)-spacings_m(0).read(i0))*centering_m(0),
</I>&gt;<i>+			   spacings_m(1).read(i1)
</I>&gt;<i>+			   + (spacings_m(1).read(i1+1)-spacings_m(1).read(i1))*centering_m(1),
</I>&gt;<i>+			   spacings_m(2).read(i2)
</I>&gt;<i>+			   + (spacings_m(2).read(i2+1)-spacings_m(2).read(i2))*centering_m(2));
</I>&gt;<i>+      }
</I>&gt;<i>+
</I>&gt;<i>+  private:
</I>&gt;<i>+
</I>&gt;<i>+    SpacingsType_t spacings_m;
</I>&gt;<i>+    typename Centering&lt;dimensions&gt;::Position centering_m;
</I>&gt;<i>+
</I>&gt;<i>+  };
</I>&gt;<i>+  
</I>&gt;<i>+  typedef IndexFunction&lt;SpacingsFunctor&gt; SpacingsEngineTag_t;
</I>&gt;<i>+  
</I>&gt;<i>+  void initializeSpacings(
</I>&gt;<i>+    Engine&lt;dimensions, PointType_t, SpacingsEngineTag_t&gt; &amp;e, 
</I>&gt;<i>+    const Centering&lt;dimensions&gt; &amp;c) const
</I>&gt;<i>+    {
</I>&gt;<i>+      e.setFunctor(SpacingsFunctor(static_cast&lt;const Mesh_t&amp;&gt;(*this), c));
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+  
</I>&gt;<i>+  //---------------------------------------------------------------------------
</I>&gt;<i>+  /// Support for the outwardNormals() and coordinateNormals() functions. 
</I>&gt;<i>+  /// We also need to export the NormalsEngineTag_t typedef and the 
</I>&gt;<i>+  /// initializeNormals() member function, which sets the appropriate constant 
</I>&gt;<i>+  /// value (since the normals exactly align with the coordinate axes).
</I>&gt;<i>+  /// The boolean value passed is true if we are asking for outward normals,
</I>&gt;<i>+  /// as opposed to coordinate normals. The indices passed in refer to cells.
</I>&gt;<i>+
</I>&gt;<i>+  typedef ConstantFunction NormalsEngineTag_t;
</I>&gt;<i>+  
</I>&gt;<i>+  void initializeNormals(
</I>&gt;<i>+    Engine&lt;dimensions, VectorType_t, NormalsEngineTag_t&gt; &amp;e, 
</I>&gt;<i>+    const Centering&lt;dimensions&gt; &amp;c,
</I>&gt;<i>+    bool outward = true) const
</I>&gt;<i>+    {
</I>&gt;<i>+      // Check some pre-conditions. We need there to be a single centering
</I>&gt;<i>+      // point and it must be face-centered.
</I>&gt;<i>+      
</I>&gt;<i>+      PAssert(c.size() == 1);
</I>&gt;<i>+      PAssert(c.centeringType() == FaceType);
</I>&gt;<i>+      
</I>&gt;<i>+      // Generate the normals. The coordinate normals are computed from
</I>&gt;<i>+      // 1 - orientation. Then, if we are on the near face, indicated by
</I>&gt;<i>+      // position == 0.0, we need to multiply by -1.0 if we are doing
</I>&gt;<i>+      // outward normals.
</I>&gt;<i>+      
</I>&gt;<i>+      VectorType_t normal;
</I>&gt;<i>+      for (int i = 0; i &lt; dimensions; i++)
</I>&gt;<i>+        {
</I>&gt;<i>+          normal(i) = static_cast&lt;T_t&gt;(1 - c.orientation(0)[i].first());
</I>&gt;<i>+          if (outward &amp;&amp; c.position(0)(i) == 0.0)
</I>&gt;<i>+            normal(i) *= static_cast&lt;T_t&gt;(-1);
</I>&gt;<i>+        }
</I>&gt;<i>+        
</I>&gt;<i>+      e.setConstant(normal);
</I>&gt;<i>+    }
</I>&gt;<i>+
</I>&gt;<i>+};
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+#endif // POOMA_FIELD_MESH_RECTILINEARMESH_H
</I>&gt;<i>+
</I>&gt;<i>+// ACL:rcsinfo
</I>&gt;<i>+// ----------------------------------------------------------------------
</I>&gt;<i>+// $RCSfile: RectilinearMesh.h,v $   $Author: oldham $
</I>&gt;<i>+// $Revision: 1.4 $   $Date: 2001/12/11 20:43:30 $
</I>&gt;<i>+// ----------------------------------------------------------------------
</I>&gt;<i>+// ACL:rcsinfo
</I>&gt;<i>+
</I>&gt;<i>  
</I>&gt;<i>
</I>

-- 
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001623.html">[PATCH] Add RectilinearMesh
</A></li>
	<LI>Next message: <A HREF="001624.html">grads
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1626">[ date ]</a>
              <a href="thread.html#1626">[ thread ]</a>
              <a href="subject.html#1626">[ subject ]</a>
              <a href="author.html#1626">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
