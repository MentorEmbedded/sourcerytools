<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [pooma-dev] Patch: ScalarCode fixes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20%5Bpooma-dev%5D%20Patch%3A%20ScalarCode%20fixes&In-Reply-To=%3C3AC25DD2.F349F045%40cybermesa.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000100.html">
   <LINK REL="Next"  HREF="000102.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[pooma-dev] Patch: ScalarCode fixes</H1>
    <B>Stephen A. Smith</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20%5Bpooma-dev%5D%20Patch%3A%20ScalarCode%20fixes&In-Reply-To=%3C3AC25DD2.F349F045%40cybermesa.com%3E"
       TITLE="[pooma-dev] Patch: ScalarCode fixes">sasmith at cybermesa.com
       </A><BR>
    <I>Wed Mar 28 21:55:30 UTC 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000100.html">Patch: Ensure All Preprocessor Symbols Defined: Configuration Files
</A></li>
        <LI>Next message: <A HREF="000102.html">RFA: Add typenames (1 of 3)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#101">[ date ]</a>
              <a href="thread.html#101">[ thread ]</a>
              <a href="subject.html#101">[ subject ]</a>
              <a href="author.html#101">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>* IndirectionEngine.h
        minor fix to reflect a change in PETE from last fall

* Evaluator/LoopApply.h
* Evaluator/MultiArgEvaluator.h
* Evaluator/ScalarCode.h
* Evaluator/ScalarCodeInfo.h
* Functions/MultiArg.h
* NewField/tests/ScalarCode.cpp
* NewField/tests/makefile
       fixed a problem that John Hall found with ScalarCode
       that index into guard layers.  The problem came from
       the loops in LoopApply.h (currently this is only used
       by ScalarCode).  Also, fixed the evaluator to apply
       updaters to the fields used, and made sure the interior
       guard layers are filled.  While working on this, I expanded
       the test code ScalarCode.cpp to test for these issues
       and filled in the MultiArg structures and functions for
       4,5, and 6 arguments.

       Note: NewField is still missing a couple features to
       support messaging, so ScalarCode has yet to be tested
       in parallel.

Tested on  sequential, Linux, with egcs-2.95.2
Reviewed by Scott Haney

     Stephen Smith


-------------- next part --------------
? EB
? EO
? EP
? EPO
? difs
? difs2
? difs3
? Array/tests/EB
? Array/tests/EO
? Array/tests/EP
? Array/tests/EPO
? BConds/tests/EB
? BConds/tests/EO
? BConds/tests/EP
? BConds/tests/EPO
? Connect/EB
? Connect/EO
? Connect/EP
? Connect/EPO
? Connect/Lux/EB
? Connect/Lux/EO
? Connect/Lux/EP
? Connect/Lux/EPO
? Connect/Lux/tests/EB
? Connect/Lux/tests/EO
? Connect/Lux/tests/EP
? Connect/Lux/tests/EPO
? Connect/Paws/EB
? Connect/Paws/EO
? Connect/Paws/EP
? Connect/Paws/EPO
? Connect/Paws/tests/EB
? Connect/Paws/tests/EO
? Connect/Paws/tests/EP
? Connect/Paws/tests/EPO
? CoordinateSystems/tests/EB
? CoordinateSystems/tests/EO
? CoordinateSystems/tests/EP
? CoordinateSystems/tests/EPO
? DataBrowser/EB
? DataBrowser/EO
? DataBrowser/EP
? DataBrowser/EPO
? DataBrowser/tests/EB
? DataBrowser/tests/EO
? DataBrowser/tests/EP
? DataBrowser/tests/EPO
? Domain/EB
? Domain/EO
? Domain/EP
? Domain/EPO
? Domain/tests/EB
? Domain/tests/EO
? Domain/tests/EP
? Domain/tests/EPO
? DynamicArray/tests/EB
? DynamicArray/tests/EO
? DynamicArray/tests/EP
? DynamicArray/tests/EPO
? Engine/EB
? Engine/EO
? Engine/EP
? Engine/EPO
? Engine/tests/EB
? Engine/tests/EO
? Engine/tests/EP
? Engine/tests/EPO
? Evaluator/tests/EB
? Evaluator/tests/EO
? Evaluator/tests/EP
? Evaluator/tests/EPO
? Field/DiffOps/tests/EB
? Field/DiffOps/tests/EO
? Field/DiffOps/tests/EP
? Field/DiffOps/tests/EPO
? Field/tests/EB
? Field/tests/EO
? Field/tests/EP
? Field/tests/EPO
? Functions/tests/EB
? Functions/tests/EO
? Functions/tests/EP
? Functions/tests/EPO
? Geometry/EB
? Geometry/EO
? Geometry/EP
? Geometry/EPO
? Geometry/tests/EB
? Geometry/tests/EO
? Geometry/tests/EP
? Geometry/tests/EPO
? IO/EB
? IO/EO
? IO/EP
? IO/EPO
? IO/tests/EB
? IO/tests/EO
? IO/tests/EP
? IO/tests/EPO
? Layout/EB
? Layout/EO
? Layout/EP
? Layout/EPO
? Layout/tests/EB
? Layout/tests/EO
? Layout/tests/EP
? Layout/tests/EPO
? Meshes/tests/EB
? Meshes/tests/EO
? Meshes/tests/EP
? Meshes/tests/EPO
? NewField/tests/EB
? NewField/tests/EO
? NewField/tests/EP
? NewField/tests/EPO
? NewField/tests/BasicTest1.out
? NewField/tests/scalar.cpp
? Particles/EB
? Particles/EO
? Particles/EP
? Particles/EPO
? Particles/tests/EB
? Particles/tests/EO
? Particles/tests/EP
? Particles/tests/EPO
? Partition/EB
? Partition/EO
? Partition/EP
? Partition/EPO
? Partition/tests/EB
? Partition/tests/EO
? Partition/tests/EP
? Partition/tests/EPO
? Pooma/EB
? Pooma/EO
? Pooma/EP
? Pooma/EPO
? Pooma/tests/EB
? Pooma/tests/EO
? Pooma/tests/EP
? Pooma/tests/EPO
? Threads/EB
? Threads/EO
? Threads/EP
? Threads/EPO
? Threads/IterateSchedulers/EB
? Threads/IterateSchedulers/EO
? Threads/IterateSchedulers/EP
? Threads/IterateSchedulers/EPO
? Threads/tests/EB
? Threads/tests/EO
? Threads/tests/EP
? Threads/tests/EPO
? Tiny/tests/EB
? Tiny/tests/EO
? Tiny/tests/EP
? Tiny/tests/EPO
? Transform/tests/EB
? Transform/tests/EO
? Transform/tests/EP
? Transform/tests/EPO
? Tulip/EB
? Tulip/EO
? Tulip/EP
? Tulip/EPO
? Tulip/tests/EB
? Tulip/tests/EO
? Tulip/tests/EP
? Tulip/tests/EPO
? Utilities/EB
? Utilities/EO
? Utilities/EP
? Utilities/EPO
? Utilities/tests/EB
? Utilities/tests/EO
? Utilities/tests/EP
? Utilities/tests/EPO
Index: Engine/IndirectionEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/IndirectionEngine.h,v
retrieving revision 1.21
diff -r1.21 IndirectionEngine.h
302c302
&lt; 			  OpAdd(), Combine_t()
---
&gt;<i> 			  Combine_t()
</I>Index: Evaluator/LoopApply.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Evaluator/LoopApply.h,v
retrieving revision 1.2
diff -r1.2 LoopApply.h
102,103c102,103
&lt;     int e0 = domain[0].length();
&lt;     for (int i0 = f0; i0&lt;e0; ++i0)
---
&gt;<i>     int e0 = domain[0].last();
</I>&gt;<i>     for (int i0 = f0; i0 &lt;= e0; ++i0)
</I>113,116c113,116
&lt;     int e0 = domain[0].length();
&lt;     int e1 = domain[1].length();
&lt;     for (int i1 = f1; i1&lt;e1; ++i1)
&lt;       for (int i0 = f0; i0&lt;e0; ++i0)
---
&gt;<i>     int e0 = domain[0].last();
</I>&gt;<i>     int e1 = domain[1].last();
</I>&gt;<i>     for (int i1 = f1; i1 &lt;= e1; ++i1)
</I>&gt;<i>       for (int i0 = f0; i0 &lt;= e0; ++i0)
</I>127,132c127,132
&lt;     int e0 = domain[0].length();
&lt;     int e1 = domain[1].length();
&lt;     int e2 = domain[2].length();
&lt;     for (int i2 = f2; i2&lt;e2; ++i2)
&lt;       for (int i1 = f1; i1&lt;e1; ++i1)
&lt; 	for (int i0 = f0; i0&lt;e0; ++i0)
---
&gt;<i>     int e0 = domain[0].last();
</I>&gt;<i>     int e1 = domain[1].last();
</I>&gt;<i>     int e2 = domain[2].last();
</I>&gt;<i>     for (int i2 = f2; i2 &lt;= e2; ++i2)
</I>&gt;<i>       for (int i1 = f1; i1 &lt;= e1; ++i1)
</I>&gt;<i> 	for (int i0 = f0; i0 &lt;= e0; ++i0)
</I>144,151c144,151
&lt;     int e0 = domain[0].length();
&lt;     int e1 = domain[1].length();
&lt;     int e2 = domain[2].length();
&lt;     int e3 = domain[3].length();
&lt;     for (int i3 = f3; i3&lt;e3; ++i3)
&lt;       for (int i2 = f2; i2&lt;e2; ++i2)
&lt; 	for (int i1 = f1; i1&lt;e1; ++i1)
&lt; 	  for (int i0 = f0; i0&lt;e0; ++i0)
---
&gt;<i>     int e0 = domain[0].last();
</I>&gt;<i>     int e1 = domain[1].last();
</I>&gt;<i>     int e2 = domain[2].last();
</I>&gt;<i>     int e3 = domain[3].last();
</I>&gt;<i>     for (int i3 = f3; i3 &lt;= e3; ++i3)
</I>&gt;<i>       for (int i2 = f2; i2 &lt;= e2; ++i2)
</I>&gt;<i> 	for (int i1 = f1; i1 &lt;= e1; ++i1)
</I>&gt;<i> 	  for (int i0 = f0; i0 &lt;= e0; ++i0)
</I>164,173c164,173
&lt;     int e0 = domain[0].length();
&lt;     int e1 = domain[1].length();
&lt;     int e2 = domain[2].length();
&lt;     int e3 = domain[3].length();
&lt;     int e4 = domain[4].length();
&lt;     for (int i4 = f4; i4&lt;e4; ++i4)
&lt;       for (int i3 = f3; i3&lt;e3; ++i3)
&lt; 	for (int i2 = f2; i2&lt;e2; ++i2)
&lt; 	  for (int i1 = f1; i1&lt;e1; ++i1)
&lt; 	    for (int i0 = f0; i0&lt;e0; ++i0)
---
&gt;<i>     int e0 = domain[0].last();
</I>&gt;<i>     int e1 = domain[1].last();
</I>&gt;<i>     int e2 = domain[2].last();
</I>&gt;<i>     int e3 = domain[3].last();
</I>&gt;<i>     int e4 = domain[4].last();
</I>&gt;<i>     for (int i4 = f4; i4 &lt;= e4; ++i4)
</I>&gt;<i>       for (int i3 = f3; i3 &lt;= e3; ++i3)
</I>&gt;<i> 	for (int i2 = f2; i2 &lt;= e2; ++i2)
</I>&gt;<i> 	  for (int i1 = f1; i1 &lt;= e1; ++i1)
</I>&gt;<i> 	    for (int i0 = f0; i0 &lt;= e0; ++i0)
</I>187,198c187,198
&lt;     int e0 = domain[0].length();
&lt;     int e1 = domain[1].length();
&lt;     int e2 = domain[2].length();
&lt;     int e3 = domain[3].length();
&lt;     int e4 = domain[4].length();
&lt;     int e5 = domain[5].length();
&lt;     for (int i5 = f5; i5&lt;e5; ++i5)
&lt;       for (int i4 = f4; i4&lt;e4; ++i4)
&lt; 	for (int i3 = f3; i3&lt;e3; ++i3)
&lt; 	  for (int i2 = f2; i2&lt;e2; ++i2)
&lt; 	    for (int i1 = f1; i1&lt;e1; ++i1)
&lt; 	      for (int i0 = f0; i0&lt;e0; ++i0)
---
&gt;<i>     int e0 = domain[0].last();
</I>&gt;<i>     int e1 = domain[1].last();
</I>&gt;<i>     int e2 = domain[2].last();
</I>&gt;<i>     int e3 = domain[3].last();
</I>&gt;<i>     int e4 = domain[4].last();
</I>&gt;<i>     int e5 = domain[5].last();
</I>&gt;<i>     for (int i5 = f5; i5 &lt;= e5; ++i5)
</I>&gt;<i>       for (int i4 = f4; i4 &lt;= e4; ++i4)
</I>&gt;<i> 	for (int i3 = f3; i3 &lt;= e3; ++i3)
</I>&gt;<i> 	  for (int i2 = f2; i2 &lt;= e2; ++i2)
</I>&gt;<i> 	    for (int i1 = f1; i1 &lt;= e1; ++i1)
</I>&gt;<i> 	      for (int i0 = f0; i0 &lt;= e0; ++i0)
</I>213,226c213,226
&lt;     int e0 = domain[0].length();
&lt;     int e1 = domain[1].length();
&lt;     int e2 = domain[2].length();
&lt;     int e3 = domain[3].length();
&lt;     int e4 = domain[4].length();
&lt;     int e5 = domain[5].length();
&lt;     int e6 = domain[6].length();
&lt;     for (int i6 = f6; i6&lt;e6; ++i6)
&lt;       for (int i5 = f5; i5&lt;e5; ++i5)
&lt; 	for (int i4 = f4; i4&lt;e4; ++i4)
&lt; 	  for (int i3 = f3; i3&lt;e3; ++i3)
&lt; 	    for (int i2 = f2; i2&lt;e2; ++i2)
&lt; 	      for (int i1 = f1; i1&lt;e1; ++i1)
&lt; 		for (int i0 = f0; i0&lt;e0; ++i0)
---
&gt;<i>     int e0 = domain[0].last();
</I>&gt;<i>     int e1 = domain[1].last();
</I>&gt;<i>     int e2 = domain[2].last();
</I>&gt;<i>     int e3 = domain[3].last();
</I>&gt;<i>     int e4 = domain[4].last();
</I>&gt;<i>     int e5 = domain[5].last();
</I>&gt;<i>     int e6 = domain[6].last();
</I>&gt;<i>     for (int i6 = f6; i6 &lt;= e6; ++i6)
</I>&gt;<i>       for (int i5 = f5; i5 &lt;= e5; ++i5)
</I>&gt;<i> 	for (int i4 = f4; i4 &lt;= e4; ++i4)
</I>&gt;<i> 	  for (int i3 = f3; i3 &lt;= e3; ++i3)
</I>&gt;<i> 	    for (int i2 = f2; i2 &lt;= e2; ++i2)
</I>&gt;<i> 	      for (int i1 = f1; i1 &lt;= e1; ++i1)
</I>&gt;<i> 		for (int i0 = f0; i0 &lt;= e0; ++i0)
</I>Index: Evaluator/MultiArgEvaluator.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Evaluator/MultiArgEvaluator.h,v
retrieving revision 1.5
diff -r1.5 MultiArgEvaluator.h
75a76
&gt;<i> struct PerformUpdateTag;
</I>122a124,136
&gt;<i> struct UpdateNotifier
</I>&gt;<i> {
</I>&gt;<i>   UpdateNotifier()
</I>&gt;<i>   {
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   template&lt;class A&gt;
</I>&gt;<i>   void operator()(const A &amp;a) const
</I>&gt;<i>   {
</I>&gt;<i>     forEach(a, PerformUpdateTag(), NullCombine());
</I>&gt;<i>   }
</I>&gt;<i> };
</I>&gt;<i> 
</I>149a164,165
&gt;<i>     applyMultiArg(multiArg, UpdateNotifier());
</I>&gt;<i> 
</I>247d262
&lt;     ExpressionApply&lt;Inter_t&gt; tag(inter);
249c264
&lt;     applyMultiArg(multiArg, inter, info.writers());
---
&gt;<i>     applyMultiArg(multiArg, inter, info.useGuards());
</I>295a311,313
&gt;<i>     // This code is still untested.  NewField doesn't
</I>&gt;<i>     // support remote engines yet.
</I>&gt;<i> 
</I>346,348c364,365
&lt;     typedef Intersector&lt;Dim&gt; Inter_t;
&lt;     Inter_t inter;
&lt;     ExpressionApply&lt;Inter_t&gt; tag(inter);
---
&gt;<i>     typedef SimpleIntersector&lt;Dim&gt; Inter_t;
</I>&gt;<i>     Inter_t inter(domain);
</I>350c367
&lt;     applyMultiArg(multiArg, inter, info.writers());
---
&gt;<i>     applyMultiArg(multiArg, inter, info.useGuards());
</I>354a372,374
&gt;<i>       INode&lt;Dim&gt; inode = info.extendDomain(*i);
</I>&gt;<i>       Interval&lt;Dim&gt; evalDom = info.evaluationDomain((*i).domain());
</I>&gt;<i> 
</I>356c376
&lt; 	evaluate(multiArg(*i),
---
&gt;<i> 	evaluate(multiArg(inode),
</I>385a406,447
&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4&gt;
</I>&gt;<i> struct MultiArgEvaluatorTag&lt;MultiArg4&lt;A1, A2, A3, A4&gt; &gt;
</I>&gt;<i> {
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A1&gt;::Evaluator_t Eval1_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A2&gt;::Evaluator_t Eval2_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A3&gt;::Evaluator_t Eval3_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A4&gt;::Evaluator_t Eval4_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval1_t, Eval2_t&gt;::Evaluator_t Eval12_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval3_t, Eval4_t&gt;::Evaluator_t  Eval34_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval12_t, Eval34_t&gt;::Evaluator_t  Evaluator_t;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5&gt;
</I>&gt;<i> struct MultiArgEvaluatorTag&lt;MultiArg5&lt;A1, A2, A3, A4, A5&gt; &gt;
</I>&gt;<i> {
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A1&gt;::Evaluator_t Eval1_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A2&gt;::Evaluator_t Eval2_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A3&gt;::Evaluator_t Eval3_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A4&gt;::Evaluator_t Eval4_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A5&gt;::Evaluator_t Eval5_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval1_t, Eval2_t&gt;::Evaluator_t Eval12_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval3_t, Eval4_t&gt;::Evaluator_t  Eval34_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval12_t, Eval34_t&gt;::Evaluator_t  Eval1234_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval1234_t, Eval5_t&gt;::Evaluator_t  Evaluator_t;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class A6&gt;
</I>&gt;<i> struct MultiArgEvaluatorTag&lt;MultiArg6&lt;A1, A2, A3, A4, A5, A6&gt; &gt;
</I>&gt;<i> {
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A1&gt;::Evaluator_t Eval1_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A2&gt;::Evaluator_t Eval2_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A3&gt;::Evaluator_t Eval3_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A4&gt;::Evaluator_t Eval4_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A5&gt;::Evaluator_t Eval5_t;
</I>&gt;<i>   typedef typename EvaluatorTag1&lt;A6&gt;::Evaluator_t Eval6_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval1_t, Eval2_t&gt;::Evaluator_t Eval12_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval3_t, Eval4_t&gt;::Evaluator_t  Eval34_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval5_t, Eval6_t&gt;::Evaluator_t  Eval56_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval12_t, Eval34_t&gt;::Evaluator_t  Eval1234_t;
</I>&gt;<i>   typedef typename EvaluatorCombine&lt;Eval1234_t, Eval56_t&gt;::Evaluator_t  Evaluator_t;
</I>Index: Evaluator/ScalarCode.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Evaluator/ScalarCode.h,v
retrieving revision 1.5
diff -r1.5 ScalarCode.h
211a212,334
&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class A6, class Function&gt;
</I>&gt;<i> struct ApplyMultiArgLoc&lt;MultiArg6&lt;A1, A2, A3, A4, A5, A6&gt;, Function&gt;
</I>&gt;<i> {
</I>&gt;<i>   ApplyMultiArgLoc(const MultiArg6&lt;A1, A2, A3, A4, A5, A6&gt; &amp;multiArg,
</I>&gt;<i> 		   const Function &amp;function)
</I>&gt;<i>     : multiArg_m(multiArg), function_m(function)
</I>&gt;<i>   {
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
</I>&gt;<i>                Loc&lt;1&gt;(i0));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0, int i1)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
</I>&gt;<i>                 Loc&lt;2&gt;(i0, i1));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0, int i1, int i2)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
</I>&gt;<i>                Loc&lt;3&gt;(i0, i1, i2));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0, int i1, int i2, int i3)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
</I>&gt;<i>                Loc&lt;4&gt;(i0, i1, i2, i3));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   const MultiArg6&lt;A1, A2, A3, A4, A5, A6&gt; &amp;multiArg_m;
</I>&gt;<i>   const Function &amp;function_m;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class Function&gt;
</I>&gt;<i> struct ApplyMultiArgLoc&lt;MultiArg4&lt;A1, A2, A3, A4&gt;, Function&gt;
</I>&gt;<i> {
</I>&gt;<i>   ApplyMultiArgLoc(const MultiArg4&lt;A1, A2, A3, A4&gt; &amp;multiArg,
</I>&gt;<i> 		   const Function &amp;function)
</I>&gt;<i>     : multiArg_m(multiArg), function_m(function)
</I>&gt;<i>   {
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m,
</I>&gt;<i>                Loc&lt;1&gt;(i0));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0, int i1)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m,
</I>&gt;<i>                 Loc&lt;2&gt;(i0, i1));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0, int i1, int i2)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m,
</I>&gt;<i>                Loc&lt;3&gt;(i0, i1, i2));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0, int i1, int i2, int i3)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m,
</I>&gt;<i>                Loc&lt;4&gt;(i0, i1, i2, i3));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   const MultiArg4&lt;A1, A2, A3, A4&gt; &amp;multiArg_m;
</I>&gt;<i>   const Function &amp;function_m;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class Function&gt;
</I>&gt;<i> struct ApplyMultiArgLoc&lt;MultiArg5&lt;A1, A2, A3, A4, A5&gt;, Function&gt;
</I>&gt;<i> {
</I>&gt;<i>   ApplyMultiArgLoc(const MultiArg5&lt;A1, A2, A3, A4, A5&gt; &amp;multiArg,
</I>&gt;<i> 		   const Function &amp;function)
</I>&gt;<i>     : multiArg_m(multiArg), function_m(function)
</I>&gt;<i>   {
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m, multiArg_m.a5_m,
</I>&gt;<i>                Loc&lt;1&gt;(i0));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0, int i1)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m, multiArg_m.a5_m,
</I>&gt;<i>                 Loc&lt;2&gt;(i0, i1));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0, int i1, int i2)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m, multiArg_m.a5_m,
</I>&gt;<i>                Loc&lt;3&gt;(i0, i1, i2));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void operator()(int i0, int i1, int i2, int i3)
</I>&gt;<i>   {
</I>&gt;<i>     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
</I>&gt;<i>                multiArg_m.a4_m, multiArg_m.a5_m,
</I>&gt;<i>                Loc&lt;4&gt;(i0, i1, i2, i3));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   const MultiArg5&lt;A1, A2, A3, A4, A5&gt; &amp;multiArg_m;
</I>&gt;<i>   const Function &amp;function_m;
</I>&gt;<i> };
</I>&gt;<i> 
</I>281a405,443
&gt;<i> 	       f1.physicalDomain(),
</I>&gt;<i> 	       kernel);
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   template&lt;class F1, class F2, class F3, class F4&gt;
</I>&gt;<i>   void operator()(const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4)
</I>&gt;<i>   {
</I>&gt;<i>     enum { dimensions = F1::dimensions };
</I>&gt;<i>     MultiArg4&lt;F1, F2, F3, F4&gt; multiArg(f1, f2, f3, f4);
</I>&gt;<i>     EvaluateLocLoop&lt;Function, dimensions&gt; kernel(function_m,f1.physicalDomain());
</I>&gt;<i> 
</I>&gt;<i>     MultiArgEvaluator&lt;MainEvaluatorTag&gt;().
</I>&gt;<i>       evaluate&lt;MultiArg4&lt;F1, F2, F3, F4&gt; &gt;(multiArg, function_m,
</I>&gt;<i> 	       f1.physicalDomain(),
</I>&gt;<i> 	       kernel);
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   template&lt;class F1, class F2, class F3, class F4, class F5&gt;
</I>&gt;<i>   void operator()(const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5)
</I>&gt;<i>   {
</I>&gt;<i>     enum { dimensions = F1::dimensions };
</I>&gt;<i>     MultiArg5&lt;F1, F2, F3, F4, F5&gt; multiArg(f1, f2, f3, f4, f5);
</I>&gt;<i>     EvaluateLocLoop&lt;Function, dimensions&gt; kernel(function_m,f1.physicalDomain());
</I>&gt;<i> 
</I>&gt;<i>     MultiArgEvaluator&lt;MainEvaluatorTag&gt;().
</I>&gt;<i>       evaluate&lt;MultiArg5&lt;F1, F2, F3, F4, F5&gt; &gt;(multiArg, function_m,
</I>&gt;<i> 	       f1.physicalDomain(),
</I>&gt;<i> 	       kernel);
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   template&lt;class F1, class F2, class F3, class F4, class F5, class F6&gt;
</I>&gt;<i>   void operator()(const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6)
</I>&gt;<i>   {
</I>&gt;<i>     enum { dimensions = F1::dimensions };
</I>&gt;<i>     MultiArg6&lt;F1, F2, F3, F4, F5, F6&gt; multiArg(f1, f2, f3, f4, f5, f6);
</I>&gt;<i>     EvaluateLocLoop&lt;Function, dimensions&gt; kernel(function_m,f1.physicalDomain());
</I>&gt;<i> 
</I>&gt;<i>     MultiArgEvaluator&lt;MainEvaluatorTag&gt;().
</I>&gt;<i>       evaluate&lt;MultiArg6&lt;F1, F2, F3, F4, F5, F6&gt; &gt;(multiArg, function_m,
</I>Index: Evaluator/ScalarCodeInfo.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Evaluator/ScalarCodeInfo.h,v
retrieving revision 1.2
diff -r1.2 ScalarCodeInfo.h
163c163
&lt;     		    domain[d].last() - domain[d].first() + upper_m[d]
---
&gt;<i>     		    domain[d].last() + upper_m[d]
</I>178,180c178,180
&lt; //		    lower_m[d],
&lt;             domain[d].first(),
&lt; 		    domain[d].last() - domain[d].first() // + lower_m[d]
---
&gt;<i> 		    lower_m[d],
</I>&gt;<i> 		    //            domain[d].first(),
</I>&gt;<i> 		    domain[d].last() - domain[d].first()  + lower_m[d]
</I>Index: Functions/MultiArg.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Functions/MultiArg.h,v
retrieving revision 1.4
diff -r1.4 MultiArg.h
33a34,35
&gt;<i> // Functions:
</I>&gt;<i> // applyMultiArg
</I>83a86,88
&gt;<i> template&lt;class A1, class A2, class A3, class A4&gt; struct MultiArg4;
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5&gt; struct MultiArg5;
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class A6&gt; struct MultiArg6;
</I>113a119,151
&gt;<i> template&lt;class A1, class A2, class A3, class A4, class Dom&gt;
</I>&gt;<i> struct MultiArgView4
</I>&gt;<i> {
</I>&gt;<i>   typedef typename View1&lt;A1, Dom&gt;::Type_t A1_t;
</I>&gt;<i>   typedef typename View1&lt;A2, Dom&gt;::Type_t A2_t;
</I>&gt;<i>   typedef typename View1&lt;A3, Dom&gt;::Type_t A3_t;
</I>&gt;<i>   typedef typename View1&lt;A4, Dom&gt;::Type_t A4_t;
</I>&gt;<i>   typedef MultiArg4&lt;A1_t, A2_t, A3_t, A4_t&gt; Type_t;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class Dom&gt;
</I>&gt;<i> struct MultiArgView5
</I>&gt;<i> {
</I>&gt;<i>   typedef typename View1&lt;A1, Dom&gt;::Type_t A1_t;
</I>&gt;<i>   typedef typename View1&lt;A2, Dom&gt;::Type_t A2_t;
</I>&gt;<i>   typedef typename View1&lt;A3, Dom&gt;::Type_t A3_t;
</I>&gt;<i>   typedef typename View1&lt;A4, Dom&gt;::Type_t A4_t;
</I>&gt;<i>   typedef typename View1&lt;A5, Dom&gt;::Type_t A5_t;
</I>&gt;<i>   typedef MultiArg5&lt;A1_t, A2_t, A3_t, A4_t, A5_t&gt; Type_t;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class A6, class Dom&gt;
</I>&gt;<i> struct MultiArgView6
</I>&gt;<i> {
</I>&gt;<i>   typedef typename View1&lt;A1, Dom&gt;::Type_t A1_t;
</I>&gt;<i>   typedef typename View1&lt;A2, Dom&gt;::Type_t A2_t;
</I>&gt;<i>   typedef typename View1&lt;A3, Dom&gt;::Type_t A3_t;
</I>&gt;<i>   typedef typename View1&lt;A4, Dom&gt;::Type_t A4_t;
</I>&gt;<i>   typedef typename View1&lt;A5, Dom&gt;::Type_t A5_t;
</I>&gt;<i>   typedef typename View1&lt;A6, Dom&gt;::Type_t A6_t;
</I>&gt;<i>   typedef MultiArg6&lt;A1_t, A2_t, A3_t, A4_t, A5_t, A6_t&gt; Type_t;
</I>&gt;<i> };
</I>&gt;<i> 
</I>144a183,200
&gt;<i> template&lt;class A1, class A2, class A3, class A4, class Dom&gt;
</I>&gt;<i> struct View1&lt;MultiArg4&lt;A1, A2, A3, A4&gt;, Dom&gt;
</I>&gt;<i> {
</I>&gt;<i>   typedef typename MultiArgView4&lt;A1, A2, A3, A4, Dom&gt;::Type_t Type_t;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class Dom&gt;
</I>&gt;<i> struct View1&lt;MultiArg5&lt;A1, A2, A3, A4, A5&gt;, Dom&gt;
</I>&gt;<i> {
</I>&gt;<i>   typedef typename MultiArgView5&lt;A1, A2, A3, A4, A5, Dom&gt;::Type_t Type_t;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class A6, class Dom&gt;
</I>&gt;<i> struct View1&lt;MultiArg6&lt;A1, A2, A3, A4, A5, A6&gt;, Dom&gt;
</I>&gt;<i> {
</I>&gt;<i>   typedef typename MultiArgView6&lt;A1, A2, A3, A4, A5, A6, Dom&gt;::Type_t Type_t;
</I>&gt;<i> };
</I>&gt;<i> 
</I>216a273,323
&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5&gt;
</I>&gt;<i> struct MultiArg5
</I>&gt;<i> {
</I>&gt;<i>   enum { size = 5 };
</I>&gt;<i> 
</I>&gt;<i>   MultiArg5(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)
</I>&gt;<i>     : a1_m(a1), a2_m(a2), a3_m(a3), a4_m(a4), a5_m(a5)
</I>&gt;<i>   {
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   template&lt;class Dom&gt;
</I>&gt;<i>   typename View1&lt;MultiArg5&lt;A1, A2, A3, A4, A5&gt;, Dom&gt;::Type_t
</I>&gt;<i>   operator()(Dom &amp;dom) const
</I>&gt;<i>   {
</I>&gt;<i>     typedef typename View1&lt;MultiArg5&lt;A1, A2, A3, A4, A5&gt;, Dom&gt;::Type_t Ret_t;
</I>&gt;<i>     return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom), a4_m(dom), a5_m(dom));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   A1 a1_m;
</I>&gt;<i>   A2 a2_m;
</I>&gt;<i>   A3 a3_m;
</I>&gt;<i>   A4 a4_m;
</I>&gt;<i>   A5 a5_m;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class A6&gt;
</I>&gt;<i> struct MultiArg6
</I>&gt;<i> {
</I>&gt;<i>   enum { size = 6 };
</I>&gt;<i> 
</I>&gt;<i>   MultiArg6(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)
</I>&gt;<i>     : a1_m(a1), a2_m(a2), a3_m(a3), a4_m(a4), a5_m(a5), a6_m(a6)
</I>&gt;<i>   {
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   template&lt;class Dom&gt;
</I>&gt;<i>   typename View1&lt;MultiArg6&lt;A1, A2, A3, A4, A5, A6&gt;, Dom&gt;::Type_t
</I>&gt;<i>   operator()(Dom &amp;dom) const
</I>&gt;<i>   {
</I>&gt;<i>     typedef typename View1&lt;MultiArg6&lt;A1, A2, A3, A4, A5, A6&gt;, Dom&gt;::Type_t Ret_t;
</I>&gt;<i>     return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom), a4_m(dom), a5_m(dom), a6_m(dom));
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   A1 a1_m;
</I>&gt;<i>   A2 a2_m;
</I>&gt;<i>   A3 a3_m;
</I>&gt;<i>   A4 a4_m;
</I>&gt;<i>   A5 a5_m;
</I>&gt;<i>   A6 a6_m;
</I>&gt;<i> };
</I>&gt;<i> 
</I>246c353,354
&lt; 	       const Function &amp;f, int i1)
---
&gt;<i> 		   const Function &amp;f,
</I>&gt;<i> 		   const std::vector&lt;bool&gt; &amp;condition)
</I>248,262c356
&lt;   f(node.a1_m, i1);
&lt; }
&lt; 
&lt; template&lt;class A1, class Function&gt;
&lt; void applyMultiArg(const MultiArg1&lt;A1&gt; &amp;node,
&lt; 	       const Function &amp;f, int i1, int i2)
&lt; {
&lt;   f(node.a1_m, i1, i2);
&lt; }
&lt; 
&lt; template&lt;class A1, class A2, class Function&gt;
&lt; void applyMultiArg(const MultiArg2&lt;A1, A2&gt; &amp;node,
&lt; 	       const Function &amp;f, int i1)
&lt; {
&lt;   f(node.a1_m, node.a2_m, i1);
---
&gt;<i>   f(node.a1_m, condition[0]);
</I>267c361,362
&lt; 	       const Function &amp;f, int i1, int i2)
---
&gt;<i> 		   const Function &amp;f,
</I>&gt;<i> 		   const std::vector&lt;bool&gt; &amp;condition)
</I>269c364,365
&lt;   f(node.a1_m, node.a2_m, i1, i2);
---
&gt;<i>   f(node.a1_m, condition[0]);
</I>&gt;<i>   f(node.a2_m, condition[1]);
</I>274c370,371
&lt; 	       const Function &amp;f, int i1)
---
&gt;<i> 		   const Function &amp;f,
</I>&gt;<i> 		   const std::vector&lt;bool&gt; &amp;condition)
</I>276c373,375
&lt;   f(node.a1_m, node.a2_m, node.a3_m, i1);
---
&gt;<i>   f(node.a1_m, condition[0]);
</I>&gt;<i>   f(node.a2_m, condition[1]);
</I>&gt;<i>   f(node.a3_m, condition[2]);
</I>279,281c378,381
&lt; template&lt;class A1, class A2, class A3, class Function&gt;
&lt; void applyMultiArg(const MultiArg3&lt;A1, A2, A3&gt; &amp;node,
&lt; 	       const Function &amp;f, int i1, int i2)
---
&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class Function&gt;
</I>&gt;<i> void applyMultiArg(const MultiArg5&lt;A1, A2, A3, A4, A5&gt; &amp;node,
</I>&gt;<i> 		   const Function &amp;f,
</I>&gt;<i> 		   const std::vector&lt;bool&gt; &amp;condition)
</I>283c383,387
&lt;   f(node.a1_m, node.a2_m, node.a3_m, i1, i2);
---
&gt;<i>   f(node.a1_m, condition[0]);
</I>&gt;<i>   f(node.a2_m, condition[1]);
</I>&gt;<i>   f(node.a3_m, condition[2]);
</I>&gt;<i>   f(node.a4_m, condition[3]);
</I>&gt;<i>   f(node.a5_m, condition[4]);
</I>286,288c390,393
&lt; template&lt;class A1, class A2, class A3, class A4, class A5, class A6, class A7, class Function&gt;
&lt; void applyMultiArg(const MultiArg7&lt;A1, A2, A3, A4, A5, A6, A7&gt; &amp;node,
&lt; 	       const Function &amp;f, int i1)
---
&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class A6, class Function&gt;
</I>&gt;<i> void applyMultiArg(const MultiArg6&lt;A1, A2, A3, A4, A5, A6&gt; &amp;node,
</I>&gt;<i> 		   const Function &amp;f,
</I>&gt;<i> 		   const std::vector&lt;bool&gt; &amp;condition)
</I>290c395,400
&lt;   f(node.a1_m, node.a2_m, node.a3_m, node.a4_m, node.a5_m, node.a6_m, node.a7_m, i1);
---
&gt;<i>   f(node.a1_m, condition[0]);
</I>&gt;<i>   f(node.a2_m, condition[1]);
</I>&gt;<i>   f(node.a3_m, condition[2]);
</I>&gt;<i>   f(node.a4_m, condition[3]);
</I>&gt;<i>   f(node.a5_m, condition[4]);
</I>&gt;<i>   f(node.a6_m, condition[5]);
</I>295c405,406
&lt; 	       const Function &amp;f, int i1, int i2)
---
&gt;<i> 		   const Function &amp;f,
</I>&gt;<i> 		   const std::vector&lt;bool&gt; &amp;condition)
</I>297c408,414
&lt;   f(node.a1_m, node.a2_m, node.a3_m, node.a4_m, node.a5_m, node.a6_m, node.a7_m, i1, i2);
---
&gt;<i>   f(node.a1_m, condition[0]);
</I>&gt;<i>   f(node.a2_m, condition[1]);
</I>&gt;<i>   f(node.a3_m, condition[2]);
</I>&gt;<i>   f(node.a4_m, condition[3]);
</I>&gt;<i>   f(node.a5_m, condition[4]);
</I>&gt;<i>   f(node.a6_m, condition[5]);
</I>&gt;<i>   f(node.a7_m, condition[6]);
</I>302,303c419
&lt; 	       const Function &amp;f,
&lt; 	       const std::vector&lt;bool&gt; &amp;condition)
---
&gt;<i> 		   const Function &amp;f)
</I>305c421
&lt;   f(node.a1_m, condition[0]);
---
&gt;<i>   f(node.a1_m);
</I>310,311c426
&lt; 	       const Function &amp;f,
&lt; 	       const std::vector&lt;bool&gt; &amp;condition)
---
&gt;<i> 		   const Function &amp;f)
</I>313,314c428,429
&lt;   f(node.a1_m, condition[0]);
&lt;   f(node.a2_m, condition[1]);
---
&gt;<i>   f(node.a1_m);
</I>&gt;<i>   f(node.a2_m);
</I>319,320c434
&lt; 	       const Function &amp;f,
&lt; 	       const std::vector&lt;bool&gt; &amp;condition)
---
&gt;<i> 		   const Function &amp;f)
</I>322,324c436,471
&lt;   f(node.a1_m, condition[0]);
&lt;   f(node.a2_m, condition[1]);
&lt;   f(node.a3_m, condition[2]);
---
&gt;<i>   f(node.a1_m);
</I>&gt;<i>   f(node.a2_m);
</I>&gt;<i>   f(node.a3_m);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class Function&gt;
</I>&gt;<i> void applyMultiArg(const MultiArg4&lt;A1, A2, A3, A4&gt; &amp;node,
</I>&gt;<i> 		   const Function &amp;f)
</I>&gt;<i> {
</I>&gt;<i>   f(node.a1_m);
</I>&gt;<i>   f(node.a2_m);
</I>&gt;<i>   f(node.a3_m);
</I>&gt;<i>   f(node.a4_m);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class Function&gt;
</I>&gt;<i> void applyMultiArg(const MultiArg5&lt;A1, A2, A3, A4, A5&gt; &amp;node,
</I>&gt;<i> 		   const Function &amp;f)
</I>&gt;<i> {
</I>&gt;<i>   f(node.a1_m);
</I>&gt;<i>   f(node.a2_m);
</I>&gt;<i>   f(node.a3_m);
</I>&gt;<i>   f(node.a4_m);
</I>&gt;<i>   f(node.a5_m);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class A6, class Function&gt;
</I>&gt;<i> void applyMultiArg(const MultiArg6&lt;A1, A2, A3, A4, A5, A6&gt; &amp;node,
</I>&gt;<i> 		   const Function &amp;f)
</I>&gt;<i> {
</I>&gt;<i>   f(node.a1_m);
</I>&gt;<i>   f(node.a2_m);
</I>&gt;<i>   f(node.a3_m);
</I>&gt;<i>   f(node.a4_m);
</I>&gt;<i>   f(node.a5_m);
</I>&gt;<i>   f(node.a6_m);
</I>329,330c476
&lt; 	       const Function &amp;f,
&lt; 	       const std::vector&lt;bool&gt; &amp;condition)
---
&gt;<i> 		   const Function &amp;f)
</I>332,338c478,484
&lt;   f(node.a1_m, condition[0]);
&lt;   f(node.a2_m, condition[1]);
&lt;   f(node.a3_m, condition[2]);
&lt;   f(node.a4_m, condition[3]);
&lt;   f(node.a5_m, condition[4]);
&lt;   f(node.a6_m, condition[5]);
&lt;   f(node.a7_m, condition[6]);
---
&gt;<i>   f(node.a1_m);
</I>&gt;<i>   f(node.a2_m);
</I>&gt;<i>   f(node.a3_m);
</I>&gt;<i>   f(node.a4_m);
</I>&gt;<i>   f(node.a5_m);
</I>&gt;<i>   f(node.a6_m);
</I>&gt;<i>   f(node.a7_m);
</I>375a522,585
&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class Function&gt;
</I>&gt;<i> void applyMultiArgIf(const MultiArg4&lt;A1, A2, A3, A4&gt; &amp;node,
</I>&gt;<i> 		 const Function &amp;f,
</I>&gt;<i> 		 const std::vector&lt;bool&gt; &amp;condition)
</I>&gt;<i> {
</I>&gt;<i>   if (condition[0])
</I>&gt;<i>     f(node.a1_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[1])
</I>&gt;<i>     f(node.a2_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[2])
</I>&gt;<i>     f(node.a3_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[3])
</I>&gt;<i>     f(node.a4_m);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class Function&gt;
</I>&gt;<i> void applyMultiArgIf(const MultiArg5&lt;A1, A2, A3, A4, A5&gt; &amp;node,
</I>&gt;<i> 		 const Function &amp;f,
</I>&gt;<i> 		 const std::vector&lt;bool&gt; &amp;condition)
</I>&gt;<i> {
</I>&gt;<i>   if (condition[0])
</I>&gt;<i>     f(node.a1_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[1])
</I>&gt;<i>     f(node.a2_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[2])
</I>&gt;<i>     f(node.a3_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[3])
</I>&gt;<i>     f(node.a4_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[4])
</I>&gt;<i>     f(node.a5_m);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> template&lt;class A1, class A2, class A3, class A4, class A5, class A6, class Function&gt;
</I>&gt;<i> void applyMultiArgIf(const MultiArg6&lt;A1, A2, A3, A4, A5, A6&gt; &amp;node,
</I>&gt;<i> 		 const Function &amp;f,
</I>&gt;<i> 		 const std::vector&lt;bool&gt; &amp;condition)
</I>&gt;<i> {
</I>&gt;<i>   if (condition[0])
</I>&gt;<i>     f(node.a1_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[1])
</I>&gt;<i>     f(node.a2_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[2])
</I>&gt;<i>     f(node.a3_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[3])
</I>&gt;<i>     f(node.a4_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[4])
</I>&gt;<i>     f(node.a5_m);
</I>&gt;<i> 
</I>&gt;<i>   if (condition[5])
</I>&gt;<i>     f(node.a6_m);
</I>&gt;<i> }
</I>&gt;<i> 
</I>Index: NewField/tests/ScalarCode.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/ScalarCode.cpp,v
retrieving revision 1.3
diff -r1.3 ScalarCode.cpp
40a41,42
&gt;<i> #include &quot;NewField/Updater/ConstantFaceBC.h&quot;
</I>&gt;<i> #include &quot;Engine/RemoteEngine.h&quot;
</I>43a46,126
&gt;<i> // Example provided by John Hall
</I>&gt;<i> //-----------------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> template&lt;int Dim&gt;
</I>&gt;<i> struct EdgeQPressureInfo
</I>&gt;<i> {
</I>&gt;<i>   void scalarCodeInfo(ScalarCodeInfo &amp;info) const
</I>&gt;<i>   {
</I>&gt;<i>     info.arguments(5);
</I>&gt;<i> 
</I>&gt;<i>     info.write(0, true );
</I>&gt;<i>     info.write(1, false);
</I>&gt;<i>     info.write(2, false);
</I>&gt;<i>     info.write(3, false);
</I>&gt;<i>     info.write(4, false);
</I>&gt;<i> 
</I>&gt;<i>     // Does this operation index neighboring
</I>&gt;<i>     // cells?  (Do we need to update the internal
</I>&gt;<i>     // guard layers.)
</I>&gt;<i> 
</I>&gt;<i>     info.useGuards(0, false);
</I>&gt;<i>     info.useGuards(1, false);
</I>&gt;<i>     info.useGuards(2, false);
</I>&gt;<i>     info.useGuards(3, false);
</I>&gt;<i>     info.useGuards(4, false);
</I>&gt;<i> 
</I>&gt;<i>     info.dimensions(Dim);
</I>&gt;<i> 
</I>&gt;<i>     for (int i = 0; i &lt; Dim; ++i)
</I>&gt;<i>     {
</I>&gt;<i>       info.lowerExtent(i) = 0;
</I>&gt;<i>       info.upperExtent(i) = 0;
</I>&gt;<i>     }
</I>&gt;<i>   }
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> typedef double Real;
</I>&gt;<i> 
</I>&gt;<i> template&lt;int Dim&gt;
</I>&gt;<i> struct ScalarEdgeQPressure
</I>&gt;<i>   : public EdgeQPressureInfo&lt;Dim&gt;
</I>&gt;<i> {
</I>&gt;<i>   ScalarEdgeQPressure(const Real&amp; inLinearQ )
</I>&gt;<i>       : EdgeQPressureInfo&lt;Dim&gt;(),
</I>&gt;<i>     linearQ(inLinearQ)
</I>&gt;<i>   {
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   template&lt;class F1, class F2, class F3, class F4, class F5&gt;
</I>&gt;<i>   void operator()(const F1&amp; EdgeQPressure,     const F2&amp; EdgeGammaConstant,
</I>&gt;<i> 		  const F3&amp; EdgeSoundSpeed,    const F4&amp; EdgeVelocity,
</I>&gt;<i> 		  const F5&amp; EdgePsiLimiter,    const 
</I>&gt;<i> 		  Loc&lt;Dim&gt; &amp;loc) const
</I>&gt;<i>        {
</I>&gt;<i> 	 if( EdgePsiLimiter(loc) &lt; 0.2 ) {  // epsilon
</I>&gt;<i> 	   EdgeQPressure(loc) = 0.0;
</I>&gt;<i> 	   return;
</I>&gt;<i> 	 }
</I>&gt;<i> 
</I>&gt;<i> 	 Real edgeVelocityMagnitude = 
</I>&gt;<i> 	   sqrt(dot(EdgeVelocity(loc),EdgeVelocity(loc)));
</I>&gt;<i> 	 
</I>&gt;<i> 	 EdgeQPressure(loc) = edgeVelocityMagnitude * 
</I>&gt;<i> 	   EdgePsiLimiter(loc) *
</I>&gt;<i> 	   (EdgeGammaConstant(loc) * 
</I>&gt;<i> 	    edgeVelocityMagnitude +
</I>&gt;<i> 	    sqrt( linearQ * linearQ * 
</I>&gt;<i> 		  EdgeSoundSpeed(loc) * EdgeSoundSpeed(loc) +
</I>&gt;<i> 		  EdgeGammaConstant(loc) * 
</I>&gt;<i> 		  EdgeGammaConstant(loc) *
</I>&gt;<i> 		  edgeVelocityMagnitude * 
</I>&gt;<i> 		  edgeVelocityMagnitude));
</I>&gt;<i>        }
</I>&gt;<i> 
</I>&gt;<i> private:
</I>&gt;<i>   Real linearQ;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> //-----------------------------------------------------------------------------
</I>46a130,140
&gt;<i> // This example averages the values from an all-face field and puts the
</I>&gt;<i> // result in a cell-centered field.
</I>&gt;<i> // The example is interesting for 2 reasons:
</I>&gt;<i> // -useGuards for the input field is true, because we will need to
</I>&gt;<i> // index into the guard layers---you need the same face on two different
</I>&gt;<i> // processors, so one of the values comes from the guard layer.
</I>&gt;<i> // -on the other hand, we've written the code to operate on views of
</I>&gt;<i> // the all-face field, so the extents are actually 0.  The view of the
</I>&gt;<i> // all-face field take the cell-based domain and include all the relevant
</I>&gt;<i> // faces.
</I>&gt;<i> 
</I>69c163
&lt;       info.upperExtent(i) = 1;
---
&gt;<i>       info.upperExtent(i) = 0;
</I>109a204,266
&gt;<i> // Gradient example.  (This example exists to test operations that use
</I>&gt;<i> // guard layers and have a left extent to make sure we compute on the
</I>&gt;<i> // correct region.)
</I>&gt;<i> //-----------------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> struct EdgeFromCenterDerivativeInfo
</I>&gt;<i> {
</I>&gt;<i>   EdgeFromCenterDerivativeInfo(int dimensions)
</I>&gt;<i>     : dimensions_m(dimensions)
</I>&gt;<i>   {
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   void scalarCodeInfo(ScalarCodeInfo &amp;info) const
</I>&gt;<i>   {
</I>&gt;<i>     info.arguments(2);
</I>&gt;<i> 
</I>&gt;<i>     info.write(0, true );
</I>&gt;<i>     info.write(1, false);
</I>&gt;<i>     info.useGuards(0, false);
</I>&gt;<i>     info.useGuards(1, true);
</I>&gt;<i> 
</I>&gt;<i>     info.dimensions(dimensions_m);
</I>&gt;<i> 
</I>&gt;<i>     int i;
</I>&gt;<i>     for (i = 0; i &lt; dimensions_m; ++i)
</I>&gt;<i>     {
</I>&gt;<i>       info.lowerExtent(i) = 1;
</I>&gt;<i>       info.upperExtent(i) = 0;
</I>&gt;<i>     }
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   int dimensions_m;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> template&lt;int Dim&gt;
</I>&gt;<i> struct EdgeFromCenterDerivative
</I>&gt;<i>   : public  EdgeFromCenterDerivativeInfo
</I>&gt;<i> {
</I>&gt;<i>   EdgeFromCenterDerivative()
</I>&gt;<i>     : EdgeFromCenterDerivativeInfo(Dim),
</I>&gt;<i>       off_m(0)
</I>&gt;<i>   {
</I>&gt;<i>     off_m[0] = 1;
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   template&lt;class F1, class F2&gt;
</I>&gt;<i>   inline
</I>&gt;<i>   void operator()(F1 &amp;f1, const F2 &amp;f2, const Loc&lt;Dim&gt; &amp;loc) const
</I>&gt;<i>   {
</I>&gt;<i>     if (f2(loc) &gt; 4.0)
</I>&gt;<i>     {
</I>&gt;<i>       f1(loc) = f2(loc) - 2.0 * f2(loc - off_m);
</I>&gt;<i>     }
</I>&gt;<i>     else
</I>&gt;<i>     {
</I>&gt;<i>       f1(loc) = f2(loc) - 1.1 * f2(loc - off_m);
</I>&gt;<i>     }
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i>   Loc&lt;Dim&gt; off_m;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> //-----------------------------------------------------------------------------
</I>112a270,271
&gt;<i> // set the problem dimension here:  must be &gt;= 2
</I>&gt;<i> 
</I>114a274,280
&gt;<i> // switch the definitions here to test the distributed case.
</I>&gt;<i> 
</I>&gt;<i> typedef ReplicatedTag LayoutTag_t;
</I>&gt;<i> typedef Brick BrickTag_t;
</I>&gt;<i> //typedef DistributedTag LayoutTag_t;
</I>&gt;<i> //typedef Remote&lt;Brick&gt; BrickTag_t;
</I>&gt;<i> 
</I>144c310
&lt; 			    GuardLayers&lt;dim&gt;(1));
---
&gt;<i> 			    GuardLayers&lt;dim&gt;(0));
</I>147,148c313,314
&lt; 			  GuardLayers&lt;dim&gt;(1), GuardLayers&lt;dim&gt;(1),
&lt; 			  ReplicatedTag());
---
&gt;<i> 			  GuardLayers&lt;dim&gt;(1), GuardLayers&lt;dim&gt;(0),
</I>&gt;<i> 			  LayoutTag_t());
</I>152c318
&lt;   typedef MultiPatch&lt;GridTag, Brick&gt; MP2_t;
---
&gt;<i>   typedef MultiPatch&lt;GridTag, BrickTag_t&gt; MP2_t;
</I>153a320
&gt;<i>   typedef Field&lt;UniformRectilinear&lt;dim&gt;, Vector&lt;dim&gt;, MP2_t&gt; FieldV_t;
</I>158a326
&gt;<i>   f.addUpdaters(AllConstantFaceBC&lt;double&gt;(4.0, true));
</I>167a336,338
&gt;<i>   tester.out() &lt;&lt; &quot;input field:&quot; &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; f &lt;&lt; std::endl;
</I>&gt;<i> 
</I>176,177d346
&lt;   tester.out() &lt;&lt; &quot;input field:&quot; &lt;&lt; std::endl
&lt; 	       &lt;&lt; f &lt;&lt; std::endl;
180a350,447
&gt;<i>   Field_t fgCheck(cell, layout2, origin, spacings);
</I>&gt;<i> 
</I>&gt;<i>   Interval&lt;dim&gt; cellDomain = f.physicalCellDomain();
</I>&gt;<i> 
</I>&gt;<i>   fgCheck = 0.0;
</I>&gt;<i>   for(d = 0; d &lt; dim; ++d)
</I>&gt;<i>   {
</I>&gt;<i>     Loc&lt;dim&gt; off(0);
</I>&gt;<i>     off[d] = 1;
</I>&gt;<i>     fgCheck(cellDomain) += f[d](cellDomain) + f[d](cellDomain + off);
</I>&gt;<i>   }
</I>&gt;<i>   fgCheck /= (2.0 * dim);
</I>&gt;<i> 
</I>&gt;<i>   tester.out() &lt;&lt; &quot;input field:&quot; &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; f &lt;&lt; std::endl;
</I>&gt;<i> 
</I>&gt;<i>   tester.out() &lt;&lt; &quot;check:&quot; &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; fgCheck &lt;&lt; std::endl;  
</I>&gt;<i> 
</I>&gt;<i>   tester.check(&quot;scalar code differs from explicit computation&quot;,
</I>&gt;<i> 	       sum(fgCheck - fg) &lt; 0.001);
</I>&gt;<i> 
</I>&gt;<i>   // Now try a problem relevant to Blanca:
</I>&gt;<i> 
</I>&gt;<i>   GridLayout&lt;dim&gt; layout3(physicalVertexDomain, blocks, 
</I>&gt;<i> 			  GuardLayers&lt;dim&gt;(1), GuardLayers&lt;dim&gt;(1),
</I>&gt;<i> 			  LayoutTag_t());
</I>&gt;<i> 
</I>&gt;<i>   Edge edge(dim - 1);
</I>&gt;<i> 
</I>&gt;<i>   Field_t EdgeQPressure(edge, layout3, origin, spacings);
</I>&gt;<i>   Field_t EdgeGammaConstant(edge, layout3, origin, spacings);
</I>&gt;<i>   Field_t EdgeSoundSpeed(edge, layout3, origin, spacings);
</I>&gt;<i>   FieldV_t EdgeVelocity(edge, layout3, origin, spacings);
</I>&gt;<i>   Field_t EdgePsiLimiter(edge, layout3, origin, spacings);
</I>&gt;<i> 
</I>&gt;<i>   DomainLayout&lt;dim&gt; layout4(physicalVertexDomain, GuardLayers&lt;dim&gt;(1));
</I>&gt;<i>   XField&lt;Geometry_t&gt;::Type_t xEdge(edge, layout4, origin, spacings);
</I>&gt;<i>   setXField(xEdge);
</I>&gt;<i> 
</I>&gt;<i>   EdgeGammaConstant = 1.4;
</I>&gt;<i>   EdgeSoundSpeed = 42.0 + xEdge.comp(1);
</I>&gt;<i>   EdgeVelocity = 3.0 * xEdge;
</I>&gt;<i>   EdgePsiLimiter = 1.0;
</I>&gt;<i> 
</I>&gt;<i>   typedef ScalarEdgeQPressure&lt;dim&gt; SEQP_t;
</I>&gt;<i>   SEQP_t sEQP(3.4);
</I>&gt;<i>   ScalarCode&lt;SEQP_t&gt; edgeQcompute(sEQP);
</I>&gt;<i> 
</I>&gt;<i>   edgeQcompute(EdgeQPressure,
</I>&gt;<i> 	       EdgeGammaConstant, EdgeSoundSpeed,
</I>&gt;<i> 	       EdgeVelocity, EdgePsiLimiter);
</I>&gt;<i> 
</I>&gt;<i>   tester.out() &lt;&lt; &quot;EdgeQPressure&quot; &lt;&lt; EdgeQPressure &lt;&lt; std::endl;
</I>&gt;<i>   tester.out() &lt;&lt; &quot;EdgeGamma&quot; &lt;&lt; EdgeGammaConstant &lt;&lt; std::endl;
</I>&gt;<i>   tester.out() &lt;&lt; &quot;EdgeSound&quot; &lt;&lt; EdgeSoundSpeed &lt;&lt; std::endl;
</I>&gt;<i>   tester.out() &lt;&lt; &quot;EdgeV&quot; &lt;&lt; EdgeVelocity &lt;&lt; std::endl;
</I>&gt;<i>   tester.out() &lt;&lt; &quot;EdgePsi&quot; &lt;&lt; EdgePsiLimiter &lt;&lt; std::endl;
</I>&gt;<i> 
</I>&gt;<i>   // 2) scalar code with extents (lower extent in particular)
</I>&gt;<i> 
</I>&gt;<i>   Edge edgeX(1);
</I>&gt;<i>   Field_t edgeValues(edgeX, layout3, origin, spacings);
</I>&gt;<i>   Field_t cellValues(cell, layout3, origin, spacings);
</I>&gt;<i> 
</I>&gt;<i>   XField&lt;Geometry_t&gt;::Type_t xEdgeX(edgeX, layout4, origin, spacings);
</I>&gt;<i>   setXField(xEdgeX);
</I>&gt;<i> 
</I>&gt;<i>   edgeValues.all() = 42.0;
</I>&gt;<i>   cellValues.all() = 5.0;
</I>&gt;<i>   cellValues = xEdgeX.comp(0);
</I>&gt;<i> 
</I>&gt;<i>   tester.out() &lt;&lt; &quot;starting cell values: &quot; &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; cellValues &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; &quot;all&quot; &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; cellValues.all() &lt;&lt; std::endl;
</I>&gt;<i>   tester.out() &lt;&lt; &quot;starting edge values: &quot; &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; edgeValues &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; &quot;all&quot; &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; edgeValues.all() &lt;&lt; std::endl;
</I>&gt;<i> 
</I>&gt;<i>   ScalarCode&lt;EdgeFromCenterDerivative&lt;dim&gt; &gt; edgeFromCenter;
</I>&gt;<i> 
</I>&gt;<i>   edgeFromCenter(edgeValues, cellValues);
</I>&gt;<i> 
</I>&gt;<i>   tester.out() &lt;&lt; &quot;final edge values: &quot; &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; edgeValues &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; &quot;all&quot; &lt;&lt; std::endl
</I>&gt;<i> 	       &lt;&lt; edgeValues.all() &lt;&lt; std::endl;
</I>&gt;<i> 
</I>&gt;<i>   double check2 = sum(edgeValues * edgeValues);
</I>&gt;<i>   tester.out() &lt;&lt; &quot;check value: &quot; &lt;&lt; check2 &lt;&lt; std::endl;
</I>&gt;<i> 
</I>&gt;<i>   tester.check(&quot;value from derivative computation&quot;, abs(check2 - 134.8) &lt; 0.2);
</I>&gt;<i> 
</I>&gt;<i>   // final cases to consider:
</I>&gt;<i>   // 1) replicated fields
</I>&gt;<i> 
</I>191a459,460
&gt;<i> 
</I>&gt;<i> 
</I>Index: NewField/tests/makefile
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/makefile,v
retrieving revision 1.7
diff -r1.7 makefile
53a54
&gt;<i> 	$(ODIR)/ScalarCode $(TSTOPTS) 1&gt;ScalarCode.out 2&gt;&amp;1
</I>57c58,59
&lt; 	$(ODIR)/WhereTest $(ODIR)/VectorTest
---
&gt;<i> 	$(ODIR)/WhereTest $(ODIR)/VectorTest \
</I>&gt;<i> 	$(ODIR)/ScalarCode
</I>118a121,128
&gt;<i> .PHONY: ScalarCode
</I>&gt;<i> 
</I>&gt;<i> ScalarCode: $(ODIR)/ScalarCode
</I>&gt;<i> 
</I>&gt;<i> $(ODIR)/ScalarCode: $(ODIR)/ScalarCode.o
</I>&gt;<i> 	$(LinkToSuite)
</I>&gt;<i> 
</I>&gt;<i> 
</I>133,140d142
&lt; 	$(LinkToSuite)
&lt; 
&lt; 
&lt; .PHONY: ScalarCode
&lt; 
&lt; ScalarCode: $(ODIR)/ScalarCode
&lt; 
&lt; $(ODIR)/ScalarCode: $(ODIR)/ScalarCode.o
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000100.html">Patch: Ensure All Preprocessor Symbols Defined: Configuration Files
</A></li>
	<LI>Next message: <A HREF="000102.html">RFA: Add typenames (1 of 3)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#101">[ date ]</a>
              <a href="thread.html#101">[ thread ]</a>
              <a href="subject.html#101">[ subject ]</a>
              <a href="author.html#101">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
