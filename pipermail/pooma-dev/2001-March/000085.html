<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Patch: Tutorial Typographical Errors
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Patch%3A%20Tutorial%20Typographical%20Errors&In-Reply-To=%3C20010326155144.A1707%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000084.html">
   <LINK REL="Next"  HREF="000087.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Patch: Tutorial Typographical Errors</H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Patch%3A%20Tutorial%20Typographical%20Errors&In-Reply-To=%3C20010326155144.A1707%40codesourcery.com%3E"
       TITLE="Patch: Tutorial Typographical Errors">oldham at codesourcery.com
       </A><BR>
    <I>Mon Mar 26 23:51:44 UTC 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000084.html">Patch: More Minor Changes to Tutorials
</A></li>
        <LI>Next message: <A HREF="000087.html">RFA: s/VectorFace/VectorFaceRCTag/g
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#85">[ date ]</a>
              <a href="thread.html#85">[ thread ]</a>
              <a href="subject.html#85">[ subject ]</a>
              <a href="author.html#85">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Mon Mar 26 15:50:55 2001  Jeffrey D. Oldham &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

	* background.html (struct AddOp): Match parameter name with
	parameter use.
	(struct MulOp): Likewise.
	* tut-02.html: Add several missing spaces.
	(RBJacobi): Change array's name to match previous line.
	(Periodic Boundary Conditions): Fix line numbers for ApplyPeriodic.
	* tut-04.html: Move sentence regarding component forwarding from
	next paragraph to preceding paragraph concerning component
	forwarding.
	Remove an extra space and an extraneous comma.  Add a missing
	parenthesis.  Fix array's name to match the other text.
	Emphasize &quot;ghost,&quot; which is implicitly defined.
	Reword last sentence to de\&quot;{e}mphasize Pooma developers' programming
	expertise.
	(accumulateWithLoop): Substitute &quot;first0&quot; and &quot;last0&quot; for &quot;f0&quot; and
	&quot;l0&quot;. &quot;l0&quot; looks like the number 10.
	Remove some extraneous words.
	* tut-06.html: &quot;Recurring,&quot; not &quot;recursing.&quot;
	* tut-07.html: Remove extraneous word.  Fix a comma.  Fix
	capitalization.  Remove one of double word.
	Add space between closing &quot;&gt;&quot; in nested template.
	Change expression font to typewriter.
	s/&gt;/&lt;/ in line 016 of n-D scalar advection.
	* tut-08.html: (average): Change second &quot;Expression1_t&quot; to
	&quot;Expression2_t&quot;.
	(Exported typedefs): Remove second, extraneous
	&quot;SurfaceNormalsArray_t&quot;.
	Fix typo.  Remove second of two contiguous periods.  Remove second
	of repeated world.
	Suggested substitution s/right/correct/ to avoid confusion with
	&quot;left&quot;.
	(FieldStencil example): Add ending &quot;;&quot;.  s/fv/vv/ to match
	previous variable declaration.
	Fix misspelled words.  Add period at the end of a sentence.

Tested on	Netscape 4.75 on Linux
Reviewed by	Allan Stokes  (Thanks!)

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: background.html
===================================================================
RCS file: /home/pooma/Repository/r2/docs/background.html,v
retrieving revision 1.1
diff -c -p -r1.1 background.html
*** background.html	2001/03/19 16:11:13	1.1
--- background.html	2001/03/21 19:59:59
*************** arithmetic operations:
*** 761,767 ****
  &lt;blockquote&gt;&lt;pre&gt;
  struct AddOp
  {
!     static inline double apply(const double &amp; left, const double &amp; y)
      {
          return x + y;
      }
--- 761,767 ----
  &lt;blockquote&gt;&lt;pre&gt;
  struct AddOp
  {
!     static inline double apply(const double &amp; x, const double &amp; y)
      {
          return x + y;
      }
*************** struct AddOp
*** 769,775 ****
  
  struct MulOp
  {
!     static inline double apply(const double &amp; left, const double &amp; y)
      {
          return x * y;
      }
--- 769,775 ----
  
  struct MulOp
  {
!     static inline double apply(const double &amp; x, const double &amp; y)
      {
          return x * y;
      }
Index: tut-02.html
===================================================================
RCS file: /home/pooma/Repository/r2/docs/tut-02.html,v
retrieving revision 1.1
diff -c -p -r1.1 tut-02.html
*** tut-02.html	2001/03/19 16:11:13	1.1
--- tut-02.html	2001/03/21 19:59:59
*************** objects in some way.
*** 445,451 ****
  &lt;p&gt;In POOMA, that way is to use a 2-dimensional
  &lt;tt&gt;Interval&lt;/tt&gt; or &lt;tt&gt;Range&lt;/tt&gt; instead of a pair
  of 1-dimensional &lt;tt&gt;Interval&lt;/tt&gt;s or
! &lt;tt&gt;Range&lt;/tt&gt;s.  A 2-dimensional&lt;tt&gt;Interval&lt;/tt&gt; is
  just the cross-product of its 1-dimensional constituents: it specifies
  a dense rectangular patch of an array.  Similarly, a 2-dimensional
  &lt;tt&gt;Range&lt;/tt&gt; is a generalization of the red or black squares
--- 445,451 ----
  &lt;p&gt;In POOMA, that way is to use a 2-dimensional
  &lt;tt&gt;Interval&lt;/tt&gt; or &lt;tt&gt;Range&lt;/tt&gt; instead of a pair
  of 1-dimensional &lt;tt&gt;Interval&lt;/tt&gt;s or
! &lt;tt&gt;Range&lt;/tt&gt;s.  A 2-dimensional &lt;tt&gt;Interval&lt;/tt&gt; is
  just the cross-product of its 1-dimensional constituents: it specifies
  a dense rectangular patch of an array.  Similarly, a 2-dimensional
  &lt;tt&gt;Range&lt;/tt&gt; is a generalization of the red or black squares
*************** need not have the same spacing along dif
*** 455,461 ****
  &lt;p&gt;An N-dimensional&lt;tt&gt;Interval&lt;/tt&gt; is declared in the same
  way as its 1-dimensional cousin.  An N-dimensional
  &lt;tt&gt;Interval&lt;/tt&gt; is usually initialized by giving its
! constructor N 1-dimensional&lt;tt&gt;Interval&lt;/tt&gt;s as arguments,
  as shown in the following example:
  
  &lt;blockquote&gt;&lt;pre&gt;
--- 455,461 ----
  &lt;p&gt;An N-dimensional&lt;tt&gt;Interval&lt;/tt&gt; is declared in the same
  way as its 1-dimensional cousin.  An N-dimensional
  &lt;tt&gt;Interval&lt;/tt&gt; is usually initialized by giving its
! constructor N 1-dimensional &lt;tt&gt;Interval&lt;/tt&gt;s as arguments,
  as shown in the following example:
  
  &lt;blockquote&gt;&lt;pre&gt;
*************** using 2-dimensional subscripting:
*** 537,543 ****
  32
  33      // &lt;em&gt;The array we'll be solving for.&lt;/em&gt;
  34      Array&lt;2&gt; V(guarded);
! 35      x = 0.0;
  36
  37      // &lt;em&gt;The right hand side of the equation.&lt;/em&gt;
  38      Array&lt;2&gt; b(calc);
--- 537,543 ----
  32
  33      // &lt;em&gt;The array we'll be solving for.&lt;/em&gt;
  34      Array&lt;2&gt; V(guarded);
! 35      V = 0.0;
  36
  37      // &lt;em&gt;The right hand side of the equation.&lt;/em&gt;
  38      Array&lt;2&gt; b(calc);
*************** used to ensure zero boundary conditions.
*** 577,584 ****
  condition could be represented equally well by assigning values to
  these padding elements.
  
! &lt;p&gt;Using&lt;tt&gt;Interval&lt;/tt&gt; objects that run from 1 to N-2 to
! specify the dimensions of the&lt;tt&gt;Interval&lt;/tt&gt; object
  &lt;tt&gt;calc&lt;/tt&gt; defined on line&nbsp;28 means that when the array
  &lt;tt&gt;b&lt;/tt&gt; is defined (line&nbsp;38), its legal indices also run from
  1 to N-2 along each axis.  While POOMA uses 0..N-1 indexing by
--- 577,584 ----
  condition could be represented equally well by assigning values to
  these padding elements.
  
! &lt;p&gt;Using &lt;tt&gt;Interval&lt;/tt&gt; objects that run from 1 to N-2 to
! specify the dimensions of the &lt;tt&gt;Interval&lt;/tt&gt; object
  &lt;tt&gt;calc&lt;/tt&gt; defined on line&nbsp;28 means that when the array
  &lt;tt&gt;b&lt;/tt&gt; is defined (line&nbsp;38), its legal indices also run from
  1 to N-2 along each axis.  While POOMA uses 0..N-1 indexing by
*************** either axis are padding, and are to be o
*** 632,638 ****
  iteration.
  
  &lt;p&gt;The function that actually updates the periodic boundary conditions
! is called &lt;tt&gt;ApplyPeriodic()&lt;/tt&gt;, and is shown on lines 20-28 below.
  The key to understanding this code is that when a &quot;naked&quot; integer is
  used to subscript a POOMA array, the result of that
  subscripting operation is reduced by one dimension in relation to that
--- 632,638 ----
  iteration.
  
  &lt;p&gt;The function that actually updates the periodic boundary conditions
! is called &lt;tt&gt;ApplyPeriodic()&lt;/tt&gt;, and is shown on lines 20-33 below.
  The key to understanding this code is that when a &quot;naked&quot; integer is
  used to subscript a POOMA array, the result of that
  subscripting operation is reduced by one dimension in relation to that
*************** point yields an &lt;tt&gt;Array&lt;/tt&gt; with just
*** 650,656 ****
  zero-dimensional &lt;tt&gt;Array&lt;/tt&gt; (at least not in this release of
  POOMA), which is what the &lt;tt&gt;Loc&lt;2&gt;&lt;/tt&gt; would have returned.
  The reduction in rank has to come from compile-time information, so
! &lt;tt&gt;Loc&lt;/tt&gt; and integers reduce dimensionality, but&lt;tt&gt;Interval&lt;/tt&gt;
  and &lt;tt&gt;Range&lt;/tt&gt; do not.
  
  &lt;blockquote&gt;&lt;pre&gt;
--- 650,656 ----
  zero-dimensional &lt;tt&gt;Array&lt;/tt&gt; (at least not in this release of
  POOMA), which is what the &lt;tt&gt;Loc&lt;2&gt;&lt;/tt&gt; would have returned.
  The reduction in rank has to come from compile-time information, so
! &lt;tt&gt;Loc&lt;/tt&gt; and integers reduce dimensionality, but &lt;tt&gt;Interval&lt;/tt&gt;
  and &lt;tt&gt;Range&lt;/tt&gt; do not.
  
  &lt;blockquote&gt;&lt;pre&gt;
*************** this, using the declarations:
*** 788,794 ****
  
  &lt;TR&gt;
      &lt;TD&gt;
!       Taking a view using an&lt;tt&gt;Interval&lt;/tt&gt;
      &lt;TD&gt;
        &lt;center&gt;&lt;tt&gt;a(I)&lt;/tt&gt;&lt;/center&gt;
      &lt;TD&gt;
--- 788,794 ----
  
  &lt;TR&gt;
      &lt;TD&gt;
!       Taking a view using an &lt;tt&gt;Interval&lt;/tt&gt;
      &lt;TD&gt;
        &lt;center&gt;&lt;tt&gt;a(I)&lt;/tt&gt;&lt;/center&gt;
      &lt;TD&gt;
*************** this, using the declarations:
*** 833,839 ****
  
  &lt;TR&gt;
      &lt;TD WIDTH=&quot;32%&quot;&gt;
!       Taking a read-only view using an&lt;tt&gt;Interval&lt;/tt&gt;
      &lt;TD WIDTH=&quot;18%&quot;&gt;
        &lt;CENTER&gt;&lt;tt&gt;a.read(I)&lt;/tt&gt;&lt;/CENTER&gt;
      &lt;TD WIDTH=&quot;50%&quot;&gt;
--- 833,839 ----
  
  &lt;TR&gt;
      &lt;TD WIDTH=&quot;32%&quot;&gt;
!       Taking a read-only view using an &lt;tt&gt;Interval&lt;/tt&gt;
      &lt;TD WIDTH=&quot;18%&quot;&gt;
        &lt;CENTER&gt;&lt;tt&gt;a.read(I)&lt;/tt&gt;&lt;/CENTER&gt;
      &lt;TD WIDTH=&quot;50%&quot;&gt;
Index: tut-04.html
===================================================================
RCS file: /home/pooma/Repository/r2/docs/tut-04.html,v
retrieving revision 1.1
diff -c -p -r1.1 tut-04.html
*** tut-04.html	2001/03/19 16:11:14	1.1
--- tut-04.html	2001/03/21 20:00:00
*************** supported.  Please contact &lt;a
*** 404,411 ****
  href=&quot;mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">pooma-devel at lanl.gov</A>&quot;&gt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">pooma-devel at lanl.gov</A>&lt;/a&gt; for
  information on using other, more complicated types.
  
! &lt;p&gt;The &lt;tt&gt;Array::comp()&lt;/tt&gt; method used on line&nbsp;16 does
! &lt;a name=&quot;component-forwarding&quot;&gt;&lt;em&gt;component forwarding&lt;/em&gt;&lt;/a&gt;.  The
  expression &lt;tt&gt;rays.comp(2)&lt;/tt&gt; returns an
  &lt;tt&gt;Array&lt;double&gt;&lt;/tt&gt; that supports writing into the second
  component of each vector element of rays. This is a data-parallel
--- 404,411 ----
  href=&quot;mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">pooma-devel at lanl.gov</A>&quot;&gt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">pooma-devel at lanl.gov</A>&lt;/a&gt; for
  information on using other, more complicated types.
  
! &lt;p&gt;The &lt;tt&gt;Array::comp()&lt;/tt&gt; method used on line&nbsp;16 does &lt;a
! name=&quot;component-forwarding&quot;&gt;&lt;em&gt;component forwarding&lt;/em&gt;&lt;/a&gt;.  The
  expression &lt;tt&gt;rays.comp(2)&lt;/tt&gt; returns an
  &lt;tt&gt;Array&lt;double&gt;&lt;/tt&gt; that supports writing into the second
  component of each vector element of rays. This is a data-parallel
*************** statement that works in a way analogous 
*** 413,421 ****
  except that the POOMA evaluator will calculate patches in
  parallel. Thus, if a program had an array of tensors &lt;tt&gt;T&lt;/tt&gt;, it
  could change the element in the 0th row, 1st column with &lt;tt&gt;T.comp(0,
! 1)&lt;/tt&gt;.  Note that, unlike &lt;tt&gt;Array&lt;/tt&gt;, both
! &lt;tt&gt;Vector&lt;/tt&gt; and &lt;tt&gt;Tensor&lt;/tt&gt; always index from
! zero.
  
  &lt;p&gt;Line&nbsp;24 shows that, as expected, the i&lt;sup&gt;th&lt;/sup&gt; component
  of a &lt;tt&gt;Vector&lt;/tt&gt; &lt;tt&gt;V&lt;/tt&gt; can be accessed for both
--- 413,422 ----
  except that the POOMA evaluator will calculate patches in
  parallel. Thus, if a program had an array of tensors &lt;tt&gt;T&lt;/tt&gt;, it
  could change the element in the 0th row, 1st column with &lt;tt&gt;T.comp(0,
! 1)&lt;/tt&gt;.  Note that, unlike &lt;tt&gt;Array&lt;/tt&gt;, both &lt;tt&gt;Vector&lt;/tt&gt; and
! &lt;tt&gt;Tensor&lt;/tt&gt; always index from zero.  Component forwarding is
! intimately related to the notion of component views, which are
! discussed &lt;a href=&quot;#componentviews&quot;&gt;below&lt;/a&gt;.
  
  &lt;p&gt;Line&nbsp;24 shows that, as expected, the i&lt;sup&gt;th&lt;/sup&gt; component
  of a &lt;tt&gt;Vector&lt;/tt&gt; &lt;tt&gt;V&lt;/tt&gt; can be accessed for both
*************** reading and writing using the syntax &lt;tt
*** 424,431 ****
  the first subscript in the expression &lt;tt&gt;rays(i)(0)&lt;/tt&gt; returns the
  i&lt;sup&gt;th&lt;/sup&gt; element of the &lt;tt&gt;Vector&lt;/tt&gt; &lt;tt&gt;rays&lt;/tt&gt;,
  while the second subscript returns the zeroth component of that vector.
- Component forwarding is intimately related to the notion of component
- views, which are discussed &lt;a href=&quot;#componentviews&quot;&gt;below&lt;/a&gt;.
  
  &lt;p&gt;Line&nbsp;28 shows that &lt;tt&gt;Vector&lt;/tt&gt;s can be initialized
  with &lt;tt&gt;Size&lt;/tt&gt; element values. Similarly, instances of
--- 425,430 ----
*************** as are the following named functions on 
*** 508,524 ****
  (&lt;em&gt;i,j&lt;/em&gt;) of the transpose is equal to element (&lt;em&gt;j,i&lt;/em&gt;) of the 
  input tensor &lt;tt&gt;t&lt;/tt&gt;.
  
! &lt;p&gt;&lt;dt&gt; &lt;tt&gt;template&lt;class OutputEngineTag, int D, class T, class EngineTag&gt;
  &lt;br&gt;Tensor&lt;D,T,OutputEngineTag&gt; &amp;symmetrize(Tensor&lt;D,T,E&gt; &amp;t)&lt;/tt&gt;: 
  &lt;dd&gt;Returns a tensor of type
! &lt;tt&gt;Tensor&lt;D,T,E&gt;&lt;/tt&gt;, applying a n appropriate symmetrizing operation
  to convert from the symmetry of the input &lt;tt&gt;EngineTag&lt;/tt&gt; (for example, 
  &lt;tt&gt;Full&lt;/tt&gt;) to the symmetry of the &lt;tt&gt;OutputEngineTag&lt;/tt&gt; (for example,
! &lt;tt&gt;Antisymmetric&lt;/tt&gt;. This is invoked using explicit template instantiation
  for the desired &lt;tt&gt;OutputEngineTag&lt;/tt&gt;. For example:
  &lt;pre&gt;
! Tensor&gt;2,double,Full&gt; t(1.0, 2.0, 3.0, 4.0);
! Tensor&gt;2,double,Antisymmetric&gt; at = symmetrize&lt;Antisymmetric&gt;(t);
  std::cout &lt;&lt; &quot; t = &quot; &lt;&lt; t &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;at = &quot; &lt;&lt; at &lt;&lt; std::endl;
  &lt;/blockquote&gt;&lt;/pre&gt;
--- 507,523 ----
  (&lt;em&gt;i,j&lt;/em&gt;) of the transpose is equal to element (&lt;em&gt;j,i&lt;/em&gt;) of the 
  input tensor &lt;tt&gt;t&lt;/tt&gt;.
  
! &lt;p&gt;&lt;dt&gt; &lt;tt&gt;template&lt;class OutputEngineTag, int D, class T, class E&gt;
  &lt;br&gt;Tensor&lt;D,T,OutputEngineTag&gt; &amp;symmetrize(Tensor&lt;D,T,E&gt; &amp;t)&lt;/tt&gt;: 
  &lt;dd&gt;Returns a tensor of type
! &lt;tt&gt;Tensor&lt;D,T,E&gt;&lt;/tt&gt;, applying an appropriate symmetrizing operation
  to convert from the symmetry of the input &lt;tt&gt;EngineTag&lt;/tt&gt; (for example, 
  &lt;tt&gt;Full&lt;/tt&gt;) to the symmetry of the &lt;tt&gt;OutputEngineTag&lt;/tt&gt; (for example,
! &lt;tt&gt;Antisymmetric&lt;/tt&gt;). This is invoked using explicit template instantiation
  for the desired &lt;tt&gt;OutputEngineTag&lt;/tt&gt;. For example:
  &lt;pre&gt;
! Tensor&lt;2,double,Full&gt; t(1.0, 2.0, 3.0, 4.0);
! Tensor&lt;2,double,Antisymmetric&gt; at = symmetrize&lt;Antisymmetric&gt;(t);
  std::cout &lt;&lt; &quot; t = &quot; &lt;&lt; t &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;at = &quot; &lt;&lt; at &lt;&lt; std::endl;
  &lt;/blockquote&gt;&lt;/pre&gt;
*************** via matrix-matrix product of the two arg
*** 547,553 ****
  &lt;/dl&gt;
  
  These functions also operate on &lt;tt&gt;Array&lt;/tt&gt;s of &lt;tt&gt;Tensor&lt;/tt&gt; 
! and &lt;tt&gt;Vector&lt;/tt&gt; elements (and &lt;tt&gt;DynamicArray&lt;/tt&gt;s, and &lt;tt&gt;Field&lt;/tt&gt;s.)
  
  &lt;p&gt; Lines 37-39 show construction of a diagonal tensor using the
  &lt;tt&gt;Tensor&lt;/tt&gt; class with &lt;tt&gt;Diagonal&lt;/tt&gt; for the &lt;tt&gt;EngineTag&lt;/tt&gt;
--- 546,552 ----
  &lt;/dl&gt;
  
  These functions also operate on &lt;tt&gt;Array&lt;/tt&gt;s of &lt;tt&gt;Tensor&lt;/tt&gt; 
! and &lt;tt&gt;Vector&lt;/tt&gt; elements (and &lt;tt&gt;DynamicArray&lt;/tt&gt;s and &lt;tt&gt;Field&lt;/tt&gt;s).
  
  &lt;p&gt; Lines 37-39 show construction of a diagonal tensor using the
  &lt;tt&gt;Tensor&lt;/tt&gt; class with &lt;tt&gt;Diagonal&lt;/tt&gt; for the &lt;tt&gt;EngineTag&lt;/tt&gt;
*************** like arrays of any other type.
*** 568,574 ****
  
  &lt;P&gt;Accumulation operators such as &lt;tt&gt;operator*=()&lt;/tt&gt; acting on
  &lt;tt&gt;Tensor&lt;D,T,EngineTag&gt;&lt;/tt&gt; may result in a &lt;tt&gt;Tensor&lt;/tt&gt; having
! different symmetry (different &lt;tt&gt;EngineTag&lt;/tt&gt; than what you are accumulating into.  For example,
  &lt;blockquote&gt;&lt;pre&gt;
  Tensor&lt;2,double,Antisymmetric&gt; t1, t2;
  // ... assign values
--- 567,573 ----
  
  &lt;P&gt;Accumulation operators such as &lt;tt&gt;operator*=()&lt;/tt&gt; acting on
  &lt;tt&gt;Tensor&lt;D,T,EngineTag&gt;&lt;/tt&gt; may result in a &lt;tt&gt;Tensor&lt;/tt&gt; having
! different symmetry (different &lt;tt&gt;EngineTag&lt;/tt&gt; than what you are accumulating into).  For example,
  &lt;blockquote&gt;&lt;pre&gt;
  Tensor&lt;2,double,Antisymmetric&gt; t1, t2;
  // ... assign values
*************** Array&lt; 2, double, MultiPatch&lt;Unifo
*** 611,617 ****
  logical domain of the array being created.  The 10&times;10
  &lt;tt&gt;Loc&lt;/tt&gt; is then used in the &lt;tt&gt;UniformGridLayout&lt;/tt&gt;
  declaration to specify that the total domain is to be managed using a
! total of 100 patches.  When the &lt;tt&gt;Array&lt;/tt&gt; &lt;tt&gt;a&lt;/tt&gt; is
  finally declared, &lt;tt&gt;Array&lt;/tt&gt;'s third template parameter is
  explicitly instantiated using &lt;tt&gt;MultiPatch&lt;/tt&gt;, and
  the layout object &lt;tt&gt;layout&lt;/tt&gt; is used as a constructor parameter.
--- 610,616 ----
  logical domain of the array being created.  The 10&times;10
  &lt;tt&gt;Loc&lt;/tt&gt; is then used in the &lt;tt&gt;UniformGridLayout&lt;/tt&gt;
  declaration to specify that the total domain is to be managed using a
! total of 100 patches.  When the &lt;tt&gt;Array&lt;/tt&gt; &lt;tt&gt;A&lt;/tt&gt; is
  finally declared, &lt;tt&gt;Array&lt;/tt&gt;'s third template parameter is
  explicitly instantiated using &lt;tt&gt;MultiPatch&lt;/tt&gt;, and
  the layout object &lt;tt&gt;layout&lt;/tt&gt; is used as a constructor parameter.
*************** patch. As the overhead for evaluating a 
*** 752,758 ****
  small sub-patch evaluations hurt efficiency.
  
  &lt;p&gt;One mechanism for fixing this problem is to introduce
! &lt;em&gt;guard&lt;/em&gt; (or ghost) layers. This done by having the individual
  patches overlap slightly. Each patch still &quot;owns&quot; the same data as
  before, but surrounds that data with a layer of guards. These guards
  duplicate data that is owned by other patches, and can only be read
--- 751,757 ----
  small sub-patch evaluations hurt efficiency.
  
  &lt;p&gt;One mechanism for fixing this problem is to introduce
! &lt;em&gt;guard&lt;/em&gt; (or &lt;em&gt;ghost&lt;/em&gt;) layers. This done by having the individual
  patches overlap slightly. Each patch still &quot;owns&quot; the same data as
  before, but surrounds that data with a layer of guards. These guards
  duplicate data that is owned by other patches, and can only be read
*************** glossed over, since the main intent of t
*** 815,829 ****
  intermediate or advanced users of the library can tailor it to their
  needs.
  
! &lt;p&gt;The most common array layout in POOMA is called a brick
! layout, and is signaled by the use of the class &lt;tt&gt;Brick&lt;/tt&gt; as an
! engine specifier in template instantiation.  Conceptually, a brick is
! a dense, rectangular patch of multi-dimensional space, such as the
! area [0..10]&times;[0..10].  Programs written by the typical user
! access the elements of bricks using nested loops, the indices of which
! sweep through the brick's extent along a particular axis.  Programs
! written by POOMA's developers use more complicated access
! loops in order to take full advantage of cache behavior.
  
  &lt;p&gt;The three functions &lt;tt&gt;accumulateWithLoop()&lt;/tt&gt; defined below are
  the guts of the general-purpose adding routine that we will build up
--- 814,828 ----
  intermediate or advanced users of the library can tailor it to their
  needs.
  
! &lt;p&gt;The most common array layout in POOMA is called a brick layout, and
! is signaled by the use of the class &lt;tt&gt;Brick&lt;/tt&gt; as an engine
! specifier in template instantiation.  Conceptually, a brick is a
! dense, rectangular patch of multi-dimensional space, such as the area
! [0..10]&times;[0..10].  Programs written by the typical user access
! the elements of bricks using nested loops, the indices of which sweep
! through the brick's extent along a particular axis.  POOMA code uses
! more complicated access loops in order to take full advantage of cache
! behavior.
  
  &lt;p&gt;The three functions &lt;tt&gt;accumulateWithLoop()&lt;/tt&gt; defined below are
  the guts of the general-purpose adding routine that we will build up
*************** inline T accumulateWithLoop(
*** 844,851 ****
      const ConstArray&lt;1,T,E&gt;&amp; x
  ){
      T sum = 0;
!     int f0 = x.first(0), l0 = x.last(0);
!     for (int i0=f0; i0&lt;=l0; ++i0)
          sum += x(i0);
      return sum;
  }
--- 843,850 ----
      const ConstArray&lt;1,T,E&gt;&amp; x
  ){
      T sum = 0;
!     int first0 = x.first(0), last0 = x.last(0);
!     for (int i0=first0; i0&lt;=last0; ++i0)
          sum += x(i0);
      return sum;
  }
*************** inline T accumulateWithLoop(
*** 855,864 ****
      const ConstArray&lt;2,T,E&gt;&amp; x
  ){
      T sum = 0;
!     int f0 = x.first(0), f1 = x.first(1);
!     int l0 = x.last(0),  l1 = x.last(1);
      for (int i1=f1; i1&lt;=l1; ++i1)
!         for (int i0=f0; i0&lt;=l0; ++i0)
              sum += x(i0, i1);
      return sum;
  }
--- 854,863 ----
      const ConstArray&lt;2,T,E&gt;&amp; x
  ){
      T sum = 0;
!     int first0 = x.first(0), f1 = x.first(1);
!     int last0 = x.last(0),  l1 = x.last(1);
      for (int i1=f1; i1&lt;=l1; ++i1)
!         for (int i0=first0; i0&lt;=last0; ++i0)
              sum += x(i0, i1);
      return sum;
  }
*************** inline T accumulateWithLoop(
*** 868,878 ****
      const ConstArray&lt;3,T,E&gt;&amp; x
  ){
      T sum = 0;
!     int f0 = x.first(0), f1 = x.first(1), f2 = x.first(2);
!     int l0 = x.last(0),  l1 = x.last(1),  l2 = x.last(2);
      for (int i2=f2; i2&lt;=l2; ++i2)
          for (int i1=f1; i1&lt;=l1; ++i1)
!             for (int i0=f0; i0&lt;=l0; ++i0)
                  sum += x(i0, i1, i2);
      return sum;
  }
--- 867,877 ----
      const ConstArray&lt;3,T,E&gt;&amp; x
  ){
      T sum = 0;
!     int first0 = x.first(0), f1 = x.first(1), f2 = x.first(2);
!     int last0 = x.last(0),  l1 = x.last(1),  l2 = x.last(2);
      for (int i2=f2; i2&lt;=l2; ++i2)
          for (int i1=f1; i1&lt;=l1; ++i1)
!             for (int i0=first0; i0&lt;=last0; ++i0)
                  sum += x(i0, i1, i2);
      return sum;
  }
*************** T accumulate(
*** 894,900 ****
  }
  &lt;/pre&gt;&lt;/blockquote&gt;
  
! &lt;p&gt;This function just calls through to whichever version of
  &lt;tt&gt;accumulateWithLoop()&lt;/tt&gt; handles arrays of dimension &lt;tt&gt;D&lt;/tt&gt;.
  Since &lt;tt&gt;accumulateWithLoop()&lt;/tt&gt; is an &lt;tt&gt;inline&lt;/tt&gt; function,
  this one extra function call will be eliminated by the compiler when
--- 893,899 ----
  }
  &lt;/pre&gt;&lt;/blockquote&gt;
  
! &lt;p&gt;This function just calls whichever version of
  &lt;tt&gt;accumulateWithLoop()&lt;/tt&gt; handles arrays of dimension &lt;tt&gt;D&lt;/tt&gt;.
  Since &lt;tt&gt;accumulateWithLoop()&lt;/tt&gt; is an &lt;tt&gt;inline&lt;/tt&gt; function,
  this one extra function call will be eliminated by the compiler when
Index: tut-06.html
===================================================================
RCS file: /home/pooma/Repository/r2/docs/tut-06.html,v
retrieving revision 1.1
diff -c -p -r1.1 tut-06.html
*** tut-06.html	2001/03/19 16:11:14	1.1
--- tut-06.html	2001/03/21 20:00:01
*************** in the &lt;math.h&gt; header file.)
*** 215,221 ****
  &lt;p&gt;The second version of &lt;tt&gt;fft()&lt;/tt&gt; does the real
  number-crunching.  If the computation has reached its final stage, odd
  and even elements are combined directly (lines 106-111).  If the
! computation is still recursing, the elements are shuffled, a
  half-sized transform is applied on each subsection, and the results
  are combined (lines 100-102).  All of these operations use indirect
  addressing to move data values around.  Most of the rest of the
--- 215,221 ----
  &lt;p&gt;The second version of &lt;tt&gt;fft()&lt;/tt&gt; does the real
  number-crunching.  If the computation has reached its final stage, odd
  and even elements are combined directly (lines 106-111).  If the
! computation is still recurring, the elements are shuffled, a
  half-sized transform is applied on each subsection, and the results
  are combined (lines 100-102).  All of these operations use indirect
  addressing to move data values around.  Most of the rest of the
Index: tut-07.html
===================================================================
RCS file: /home/pooma/Repository/r2/docs/tut-07.html,v
retrieving revision 1.1
diff -c -p -r1.1 tut-07.html
*** tut-07.html	2001/03/19 16:11:14	1.1
--- tut-07.html	2001/03/21 20:00:02
*************** class RectilinearCentering
*** 339,345 ****
  &lt;/pre&gt;&lt;/blockquote&gt;
  
  &lt;P&gt;The &lt;tt&gt;RectilinearCenteringTag&lt;/tt&gt; template parameter can be
! instantiated using a class whose centerings which are defined
  componentwise.  This means that each component of a multicomponent
  field element type such as &lt;tt&gt;Vector&lt;/tt&gt; or &lt;tt&gt;Tensor&lt;/tt&gt; can have
  its own independent centering position.  The value of the Boolean
--- 339,345 ----
  &lt;/pre&gt;&lt;/blockquote&gt;
  
  &lt;P&gt;The &lt;tt&gt;RectilinearCenteringTag&lt;/tt&gt; template parameter can be
! instantiated using a class whose centerings are defined
  componentwise.  This means that each component of a multicomponent
  field element type such as &lt;tt&gt;Vector&lt;/tt&gt; or &lt;tt&gt;Tensor&lt;/tt&gt; can have
  its own independent centering position.  The value of the Boolean
*************** mesh with complete set of centering poin
*** 426,432 ****
  &lt;/table&gt;&lt;/center&gt;
  
  &lt;P&gt;As an example of componentwise centering, consider
! &lt;tt&gt;RectilinearCentering&lt;2,VectorFaceRCTag&lt;2&gt;&gt;&lt;/tt&gt;.  The
  &lt;em&gt;Y&lt;/em&gt; components of a field element of &lt;tt&gt;Vector&lt;/tt&gt; type are
  centered on the faces perpendicular to the &lt;em&gt;Y&lt;/em&gt; axis, while the
  &lt;em&gt;X&lt;/em&gt; components are centered on the faces perpendicular to
--- 426,432 ----
  &lt;/table&gt;&lt;/center&gt;
  
  &lt;P&gt;As an example of componentwise centering, consider
! &lt;tt&gt;RectilinearCentering&lt;2,VectorFaceRCTag&lt;2&gt; &gt;&lt;/tt&gt;.  The
  &lt;em&gt;Y&lt;/em&gt; components of a field element of &lt;tt&gt;Vector&lt;/tt&gt; type are
  centered on the faces perpendicular to the &lt;em&gt;Y&lt;/em&gt; axis, while the
  &lt;em&gt;X&lt;/em&gt; components are centered on the faces perpendicular to
*************** WIDTH=&quot;451&quot;&gt;&lt;/a&gt;&lt;/tr&gt;
*** 448,454 ****
  
  &lt;tr&gt;&lt;td align=&quot;center&quot; width=&quot;536&quot;&gt;&lt;em&gt;Figure&nbsp;4: Example of
        componentwise centering, showing
!       RectilinearCentering&lt;2,VectorFace&lt;2&gt;&gt;&lt;/em&gt;
  &lt;/tr&gt;
  
  &lt;/table&gt;&lt;/center&gt;
--- 448,454 ----
  
  &lt;tr&gt;&lt;td align=&quot;center&quot; width=&quot;536&quot;&gt;&lt;em&gt;Figure&nbsp;4: Example of
        componentwise centering, showing
!       RectilinearCentering&lt;2,VectorFace&lt;2&gt;&gt;&lt;/em&gt;
  &lt;/tr&gt;
  
  &lt;/table&gt;&lt;/center&gt;
*************** WIDTH=&quot;451&quot;&gt;&lt;/a&gt;&lt;/tr&gt;
*** 457,463 ****
  &lt;a name=&quot;centeringalloc&quot;&gt;&lt;h3&gt;A Note on Allocation&lt;/h3&gt;&lt;/a&gt;
  
  &lt;P&gt;For componentwise rectilinear centerings such as
! &lt;tt&gt;RectilinearCentering&lt;2,VectorFace&lt;2&gt; &gt;&lt;/tt&gt;, POOMA
  currently allocates &lt;tt&gt;Field&lt;/tt&gt; domains (and &lt;tt&gt;Array&lt;/tt&gt; domains
  in the associated &lt;tt&gt;DiscreteGeometry&lt;/tt&gt;) with storage for
  &lt;tt&gt;nVerts&lt;/tt&gt; elements in each dimension, so storage for a
--- 457,463 ----
  &lt;a name=&quot;centeringalloc&quot;&gt;&lt;h3&gt;A Note on Allocation&lt;/h3&gt;&lt;/a&gt;
  
  &lt;P&gt;For componentwise rectilinear centerings such as
! &lt;tt&gt;RectilinearCentering&lt;2,VectorFaceRCTag&lt;2&gt; &gt;&lt;/tt&gt;, POOMA
  currently allocates &lt;tt&gt;Field&lt;/tt&gt; domains (and &lt;tt&gt;Array&lt;/tt&gt; domains
  in the associated &lt;tt&gt;DiscreteGeometry&lt;/tt&gt;) with storage for
  &lt;tt&gt;nVerts&lt;/tt&gt; elements in each dimension, so storage for a
*************** following methods:
*** 593,599 ****
    representation, such as a parameterized function object defining the
    bounding surface of the domain, with a method to determine whether a
    point in the space is inside or outside the set.  The type of this
!   object must be &lt;tt&gt;Domain_t&lt;/tt&gt;,
  
    &lt;dt&gt;&lt;tt&gt;totalDomain()&lt;/tt&gt;:
  
--- 593,599 ----
    representation, such as a parameterized function object defining the
    bounding surface of the domain, with a method to determine whether a
    point in the space is inside or outside the set.  The type of this
!   object must be &lt;tt&gt;Domain_t&lt;/tt&gt;.
  
    &lt;dt&gt;&lt;tt&gt;totalDomain()&lt;/tt&gt;:
  
*************** following methods:
*** 604,610 ****
  
    &lt;a name=&quot;geomxmethod&quot;&gt;&lt;/a&gt;&lt;DT&gt;&lt;tt&gt;x()&lt;/tt&gt;:
  
!   &lt;DD&gt;returns an array of centering positions corresponding to the
    total domain.
  
  &lt;/DL&gt;
--- 604,610 ----
  
    &lt;a name=&quot;geomxmethod&quot;&gt;&lt;/a&gt;&lt;DT&gt;&lt;tt&gt;x()&lt;/tt&gt;:
  
!   &lt;DD&gt;Returns an array of centering positions corresponding to the
    total domain.
  
  &lt;/DL&gt;
*************** told to update themselves if necessary.
*** 765,771 ****
  &lt;tt&gt;Field&lt;/tt&gt;s that are based on its rectilinear mesh geometry
  classes.  The current release provides periodic, reflecting, constant,
  and linear-extrapolation boundary condition types; future releases may
! may include others.  More importantly, the required interface for the
  boundary condition classes is meant to make it easy for users to
  implement their own special boundary conditions.  By following this
  interface prescription, applications can attach their own boundary
--- 765,771 ----
  &lt;tt&gt;Field&lt;/tt&gt;s that are based on its rectilinear mesh geometry
  classes.  The current release provides periodic, reflecting, constant,
  and linear-extrapolation boundary condition types; future releases may
! include others.  More importantly, the required interface for the
  boundary condition classes is meant to make it easy for users to
  implement their own special boundary conditions.  By following this
  interface prescription, applications can attach their own boundary
*************** volumes by making use of the fact that t
*** 795,801 ****
  beyond the number of vertices at the other side.  The existence of
  guard layers affects the information that &lt;tt&gt;Field&lt;/tt&gt;s provide
  about &lt;a href=&quot;#fieldlocdef&quot;&gt;the spatial position of their
! elements&lt;/a&gt;.  The expression f.x(0) is actually the position of one
  corner of the total domain of the &lt;tt&gt;Field&lt;/tt&gt; &lt;tt&gt;f&lt;/tt&gt; only if
  &lt;tt&gt;f&lt;/tt&gt; has no guard layers, since the rule is that the physical
  domain of a &lt;tt&gt;Field&lt;/tt&gt; is always zero-based. This means that in
--- 795,801 ----
  beyond the number of vertices at the other side.  The existence of
  guard layers affects the information that &lt;tt&gt;Field&lt;/tt&gt;s provide
  about &lt;a href=&quot;#fieldlocdef&quot;&gt;the spatial position of their
! elements&lt;/a&gt;.  The expression &lt;tt&gt;f.x(0)&lt;/tt&gt; is actually the position of one
  corner of the total domain of the &lt;tt&gt;Field&lt;/tt&gt; &lt;tt&gt;f&lt;/tt&gt; only if
  &lt;tt&gt;f&lt;/tt&gt; has no guard layers, since the rule is that the physical
  domain of a &lt;tt&gt;Field&lt;/tt&gt; is always zero-based. This means that in
*************** line 13 in the following source code:
*** 1165,1171 ****
  013    const int Dim    = 2;
  014    const int nVerts = 129;
  015    const int nCells = nVerts - 1;
! 016    Interval&gt;Dim&gt; vertexDomain;
  017    int d;
  018    for (d = 0; d &lt; Dim; d++)
  019    {
--- 1165,1171 ----
  013    const int Dim    = 2;
  014    const int nVerts = 129;
  015    const int nCells = nVerts - 1;
! 016    Interval&lt;Dim&gt; vertexDomain;
  017    int d;
  018    for (d = 0; d &lt; Dim; d++)
  019    {
Index: tut-08.html
===================================================================
RCS file: /home/pooma/Repository/r2/docs/tut-08.html,v
retrieving revision 1.1
diff -c -p -r1.1 tut-08.html
*** tut-08.html	2001/03/19 16:11:14	1.1
--- tut-08.html	2001/03/21 20:00:03
*************** average(const ConstField&lt;Geometry, T,
*** 228,234 ****
      TW, MeshTraits&lt;typename Geometry::Mesh_t&gt;::isLogicallyRectilinear&gt; &gt;
      Functor_t;
    typedef ConstField&lt;Geometry, T, EngineTag&gt; Expression1_t;
!   typedef ConstField&lt;Geometry, TW, EngineTagW&gt; Expression1_t;
    typedef View2&lt;Functor_t, Expression1_t, Expression2_t&gt; Ret_t;
    return Ret_t::make(Functor_t(), f, weight);
  }
--- 228,234 ----
      TW, MeshTraits&lt;typename Geometry::Mesh_t&gt;::isLogicallyRectilinear&gt; &gt;
      Functor_t;
    typedef ConstField&lt;Geometry, T, EngineTag&gt; Expression1_t;
!   typedef ConstField&lt;Geometry, TW, EngineTagW&gt; Expression2_t;
    typedef View2&lt;Functor_t, Expression1_t, Expression2_t&gt; Ret_t;
    return Ret_t::make(Functor_t(), f, weight);
  }
*************** files.
*** 308,319 ****
  &lt;/tr&gt;
  
  &lt;tr&gt;
- 	&lt;td&gt;&lt;tt&gt;SurfaceNormalsArray_t&lt;/tt&gt;
- 	&lt;td&gt;The type of &lt;tt&gt;ConstArray&lt;/tt&gt; returned by
- 	&lt;tt&gt;cellSurfaceNormals()&lt;/tt&gt;.
- &lt;/tr&gt;
- 
- &lt;tr&gt;
  	&lt;td&gt;&lt;tt&gt;This_t&lt;/tt&gt;
  	&lt;td&gt;The type of this class. 
  &lt;/tr&gt;
--- 308,313 ----
*************** href=&quot;#dimension-def&quot;&gt;dimensions&lt;/a&gt;&lt;/tt
*** 452,458 ****
  logically-rectilinear mesh classes is the &lt;tt&gt;Dim&lt;/tt&gt; template
  parameter for their &lt;tt&gt;Array&lt;/tt&gt; data members, such as the array of
  vertex-vertex mesh spacings returned by &lt;tt&gt;vertexDeltas()&lt;/tt&gt;. This
! value is also the number of integers require to index a single mesh
  element.  While the mesh class's dimension and its spatial
  dimensionality are the same for logically-rectilinear meshes, an
  unstructured mesh might well use one-dimensional &lt;tt&gt;Array&lt;/tt&gt;s to
--- 446,452 ----
  logically-rectilinear mesh classes is the &lt;tt&gt;Dim&lt;/tt&gt; template
  parameter for their &lt;tt&gt;Array&lt;/tt&gt; data members, such as the array of
  vertex-vertex mesh spacings returned by &lt;tt&gt;vertexDeltas()&lt;/tt&gt;. This
! value is also the number of integers required to index a single mesh
  element.  While the mesh class's dimension and its spatial
  dimensionality are the same for logically-rectilinear meshes, an
  unstructured mesh might well use one-dimensional &lt;tt&gt;Array&lt;/tt&gt;s to
*************** are lost. POOMA represents this notion b
*** 578,584 ****
  geometry, there is no way to know what the geometry of the resulting
  &lt;tt&gt;Field&lt;/tt&gt; should be.  (The library could make an arbitrary
  choice, such as always using the geometry from the left operand, but
! this would be wrong as often as it was right). If the two
  &lt;tt&gt;Field&lt;/tt&gt;s have the same geometry type, it is still not possible
  to know until run-time whether they really hold equivalent geometry
  objects. Lacking a clear idea of how to construct the geometry, the
--- 572,578 ----
  geometry, there is no way to know what the geometry of the resulting
  &lt;tt&gt;Field&lt;/tt&gt; should be.  (The library could make an arbitrary
  choice, such as always using the geometry from the left operand, but
! this would be wrong as often as it was correct). If the two
  &lt;tt&gt;Field&lt;/tt&gt;s have the same geometry type, it is still not possible
  to know until run-time whether they really hold equivalent geometry
  objects. Lacking a clear idea of how to construct the geometry, the
*************** example&lt;/a&gt;:
*** 985,991 ****
  
  &lt;blockquote&gt;&lt;pre&gt;
  // &lt;em&gt;Create the geometries, assuming RectilinearMesh object mesh:&lt;/em&gt;
! typedef RectilinearMesh&lt;Dim, Cartesian&lt;Dim&gt; &gt; Mesh_t
  DiscreteGeometry&lt;Vert, Mesh_t&gt; geomv(mesh, GuardLayers&lt;Dim&gt;(1));
  DiscreteGeometry&lt;Cell, Mesh_t&gt; geomc(mesh, GuardLayers&lt;Dim&gt;(1));
  
--- 979,985 ----
  
  &lt;blockquote&gt;&lt;pre&gt;
  // &lt;em&gt;Create the geometries, assuming RectilinearMesh object mesh:&lt;/em&gt;
! typedef RectilinearMesh&lt;Dim, Cartesian&lt;Dim&gt; &gt; Mesh_t;
  DiscreteGeometry&lt;Vert, Mesh_t&gt; geomv(mesh, GuardLayers&lt;Dim&gt;(1));
  DiscreteGeometry&lt;Cell, Mesh_t&gt; geomc(mesh, GuardLayers&lt;Dim&gt;(1));
  
*************** typedef Div&lt;Cell, DiscreteGeometry&amp;lt
*** 998,1004 ****
  FieldStencil&lt;Div_t&gt; divVV2SC();
  
  // &lt;em&gt;Divergence, Vector/Vert--&gt;Scalar/Cell&lt;/em&gt;
! sc = divV2SC(fv);
  &lt;/pre&gt;&lt;/blockquote&gt;
  
  &lt;p&gt; Programmers may also find it convenient to create wrappers by
--- 992,998 ----
  FieldStencil&lt;Div_t&gt; divVV2SC();
  
  // &lt;em&gt;Divergence, Vector/Vert--&gt;Scalar/Cell&lt;/em&gt;
! sc = divV2SC(vv);
  &lt;/pre&gt;&lt;/blockquote&gt;
  
  &lt;p&gt; Programmers may also find it convenient to create wrappers by
*************** the scalar loop; and
*** 1044,1050 ****
  &lt;p&gt;In addition, boundary conditions are not automatically evaluated
  before a field is printed. Applications should therefore call
  &lt;tt&gt;applyBoundaryConditions()&lt;/tt&gt; before output statements to ensure
! that the boundary values displayed are up to date..
  
  &lt;a name=&quot;bdryprebuilt&quot;&gt;&lt;h3&gt;Using Pre-Built Boundary Conditions&lt;/h3&gt;&lt;/a&gt;
  
--- 1038,1044 ----
  &lt;p&gt;In addition, boundary conditions are not automatically evaluated
  before a field is printed. Applications should therefore call
  &lt;tt&gt;applyBoundaryConditions()&lt;/tt&gt; before output statements to ensure
! that the boundary values displayed are up to date.
  
  &lt;a name=&quot;bdryprebuilt&quot;&gt;&lt;h3&gt;Using Pre-Built Boundary Conditions&lt;/h3&gt;&lt;/a&gt;
  
*************** conditions are added in the functor's &lt;t
*** 1214,1220 ****
  which is called internally by the field.
  
  &lt;p&gt;This release of POOMA predefines the functors listed below. Their
! effects can be inferred by comparing them with the the boundary
  conditions given in the &lt;a href=&quot;#builtinbc&quot;&gt;previous table&lt;/a&gt;.
  
  &lt;ul&gt;
--- 1208,1214 ----
  which is called internally by the field.
  
  &lt;p&gt;This release of POOMA predefines the functors listed below. Their
! effects can be inferred by comparing them with the boundary
  conditions given in the &lt;a href=&quot;#builtinbc&quot;&gt;previous table&lt;/a&gt;.
  
  &lt;ul&gt;
*************** with operators. The source code below, t
*** 1555,1564 ****
  170  }
  &lt;/pre&gt;&lt;/blockquote&gt;
  
! &lt;p&gt;This is a simple Jacobi saolver for Laplace's equation using the &lt;tt&gt;PositionFaceBC&lt;/tt&gt;
  boundary condition discussed above. Lines&nbsp;110-130 set up the mesh, the geometry, and the
  &lt;tt&gt;Brick&lt;/tt&gt;-engine-based &lt;tt&gt;Field&lt;/tt&gt;. Notice that we do not add any boundary conditions
! to this field, but we do reserve one layer of external guard layers (line&nbsp;125)
  We then initialize the &lt;tt&gt;Field&lt;/tt&gt; &lt;tt&gt;v&lt;/tt&gt; and begin iterating. Since we need a 
  temporary field to store the result of the Laplacian stencil, we can efficiently perform
  two applications of the stencil for each loop (lines&nbsp;147 and 148). We know
--- 1549,1558 ----
  170  }
  &lt;/pre&gt;&lt;/blockquote&gt;
  
! &lt;p&gt;This is a simple Jacobi solver for Laplace's equation using the &lt;tt&gt;PositionFaceBC&lt;/tt&gt;
  boundary condition discussed above. Lines&nbsp;110-130 set up the mesh, the geometry, and the
  &lt;tt&gt;Brick&lt;/tt&gt;-engine-based &lt;tt&gt;Field&lt;/tt&gt;. Notice that we do not add any boundary conditions
! to this field, but we do reserve one layer of external guard layers (line&nbsp;125).
  We then initialize the &lt;tt&gt;Field&lt;/tt&gt; &lt;tt&gt;v&lt;/tt&gt; and begin iterating. Since we need a 
  temporary field to store the result of the Laplacian stencil, we can efficiently perform
  two applications of the stencil for each loop (lines&nbsp;147 and 148). We know
*************** to monitor wall-clock time (lines&nbsp;1
*** 1568,1574 ****
  
  &lt;p&gt;The function &lt;tt&gt;applyLaplacian&lt;/tt&gt; (lines&nbsp;97-101) takes a &lt;tt&gt;Field&lt;/tt&gt; to assign 
  to and a &lt;tt&gt;Field&lt;/tt&gt; to stencil as arguments. This is where the boundary conditions are
! applied, follwed by the stencil. The &lt;tt&gt;Field&lt;/tt&gt; stencil object &lt;tt&gt;Laplace&lt;/tt&gt; is
  straightforward, except for the static function &lt;tt&gt;applyBoundaryConditions&lt;/tt&gt; that,
  on the fly, creates boundary conditions for each face of the input field &lt;tt&gt;f&lt;/tt&gt; and
  applies them.&lt;/p&gt;
--- 1562,1568 ----
  
  &lt;p&gt;The function &lt;tt&gt;applyLaplacian&lt;/tt&gt; (lines&nbsp;97-101) takes a &lt;tt&gt;Field&lt;/tt&gt; to assign 
  to and a &lt;tt&gt;Field&lt;/tt&gt; to stencil as arguments. This is where the boundary conditions are
! applied, followed by the stencil. The &lt;tt&gt;Field&lt;/tt&gt; stencil object &lt;tt&gt;Laplace&lt;/tt&gt; is
  straightforward, except for the static function &lt;tt&gt;applyBoundaryConditions&lt;/tt&gt; that,
  on the fly, creates boundary conditions for each face of the input field &lt;tt&gt;f&lt;/tt&gt; and
  applies them.&lt;/p&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000084.html">Patch: More Minor Changes to Tutorials
</A></li>
	<LI>Next message: <A HREF="000087.html">RFA: s/VectorFace/VectorFaceRCTag/g
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#85">[ date ]</a>
              <a href="thread.html#85">[ thread ]</a>
              <a href="subject.html#85">[ subject ]</a>
              <a href="author.html#85">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
