From oldham at codesourcery.com  Fri Jan  4 10:44:00 2002
From: oldham at codesourcery.com (Jeffrey Oldham)
Date: Fri, 4 Jan 2002 02:44:00 -0800
Subject: Patch: Recent Manual Changes
Message-ID: <20020104024400.A6343@codesourcery.com>

This patch mainly adds (mostly finished) chapters on understanding and
using data-parallel operators and templates to the R2 manual that is
being written.

2002-Jan-04  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* bibliography.xml: New file containing bibliographic information.
	* concepts.xml: Clarify containers that map indices to values.
	* glossary.xml: Add entries for compilation time, compile time,
	conformable containers, conformable domains, execution time,
	instantiation, programming time, run time, template instantiation,
	trait, traits class, Turing complete.
	* introduction.xml: Many minor changes mainly involving formatting
	and word choice.  Add sections discussing program execution speed
	and open-source software.
	* manual.xml: Add several new entity definitions.  Add unfinished
	chapter discussing writing programs using templates.  Add unfinished
	data-parallel operator chapter.  Many other minor changes.  Move
	bibliography to separate file.
	* tutorial.xml: Minor wordsmithing changes.
	* figures/box-macros.mp: New file containing macros to create
	boxes in illustrations.
	* figures/data-parallel.mp: New file illustrating data-parallel
	operations.
	* figures/doof2d.mp: Replace definitions with inclusion of
	grid-macros.mp.
	* figures/grid-macros.mp: New file containing macros to create
	grids.
	* figures/introduction.mp: Use box-macros.mp.
	* programs/Doof2d-Array-distributed-annotated.patch: Moved to
	different directory.
	* programs/Doof2d-Array-element-annotated.patch: Likewise.
	* programs/Doof2d-Array-parallel-annotated.patch: Likewise.
	* programs/Doof2d-Array-stencil-annotated.patch: Likewise.
	* programs/Doof2d-C-element-annotated.patch: Likewise.
	* programs/Doof2d-Field-distributed-annotated.patch: Likewise.
	* programs/Doof2d-Field-parallel-annotated.patch: Likewise.
	* programs/makefile: Likewise.

Applied to	mainline.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: bibliography.xml
===================================================================
RCS file: bibliography.xml
diff -N bibliography.xml
*** /dev/null	Fri Mar 23 21:37:44 2001
--- bibliography.xml	Fri Jan  4 10:14:05 2002
***************
*** 0 ****
--- 1,277 ----
+ <!-- Bibliography -->
+ 
+ <bibliography id="bibliography">
+  <title>Bibliography</title>
+ 
+  <para>FIXME: How do I process these entries?</para>
+ 
+  <biblioentry>
+   <abbrev>mpi99</abbrev>
+   <authorgroup>
+    <author>
+     <firstname>William</firstname><surname>Gropp</surname>
+    </author>
+    <author>
+     <firstname>Ewing</firstname><surname>Lusk</surname>
+    </author>
+    <author>
+     <firstname>Anthony</firstname><surname>Skjellum</surname>
+    </author>
+   </authorgroup>
+   <copyright>
+    <year>1999</year>
+    <holder>Massachusetts Institute of Technology</holder>
+   </copyright>
+   <isbn>0-262-57132-3</isbn>
+   <publisher>
+    <publishername>The MIT Press</publishername>
+    <address>Cambridge, MA</address>
+   </publisher>
+   <title>Using MPI</title>
+   <subtitle>Portable Parallel Programming with the Message-Passing Interface</subtitle>
+   <edition>second edition</edition>
+  </biblioentry>
+ 
+  <biblioentry>
+   <abbrev>pooma95</abbrev>
+   <authorgroup>
+    <author>
+     <firstname>John</firstname><othername role="mi">V. W.</othername><surname>Reynders</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Paul</firstname><othername role="mi">J.</othername><surname>Hinker</surname>
+     <affiliation>
+      <orgname>Dakota Software Systems, Inc.</orgname>
+      <address><city>Rapid City</city><state>SD</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Julian</firstname><othername role="mi">C.</othername><surname>Cummings</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Susan</firstname><othername role="mi">R.</othername><surname>Atlas</surname>
+     <affiliation>
+      <orgname>Parallel Solutions, Inc.</orgname>
+      <address><city>Santa Fe</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Subhankar</firstname><surname>Banerjee</surname>
+     <affiliation>
+      <orgname>New Mexico State University</orgname>
+      <address><city>Las Cruces</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>William</firstname><othername role="mi">F.</othername><surname>Humphrey</surname>
+     <affiliation>
+      <orgname>University of Illinois at Urbana-Champaign</orgname>
+      <address><city>Urbana-Champaign</city><state>IL</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Steve</firstname><othername role="mi">R.</othername><surname>Karmesin</surname>
+     <affiliation>
+      <orgname>California Institute of Technology</orgname>
+      <address><city>Pasadena</city><state>CA</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Katarzyna</firstname><surname>Keahey</surname>
+     <affiliation>
+      <orgname>Indiana University</orgname>
+      <address><city>Bloomington</city><state>IN</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Marydell</firstname><surname>Tholburn</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+   </authorgroup>
+   <title>&pooma;</title>
+   <subtitle>A Framework for Scientific Simulation on Parallel Architectures</subtitle>
+   <releaseinfo>unpublished</releaseinfo>
+  </biblioentry>
+ 
+  <biblioentry>
+   <abbrev>pooma-sc95</abbrev>
+   <authorgroup>
+    <author>
+     <firstname>Susan</firstname><surname>Atlas</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Subhankar</firstname><surname>Banerjee</surname>
+     <affiliation>
+      <orgname>New Mexico State University</orgname>
+      <address><city>Las Cruces</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Julian</firstname><othername role="mi">C.</othername><surname>Cummings</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Paul</firstname><othername role="mi">J.</othername><surname>Hinker</surname>
+     <affiliation>
+      <orgname>Advanced Computing Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>M.</firstname><surname>Srikant</surname>
+     <affiliation>
+      <orgname>New Mexico State University</orgname>
+      <address><city>Las Cruces</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>John</firstname><othername role="mi">V. W.</othername><surname>Reynders</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Marydell</firstname><surname>Tholburn</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+   </authorgroup>
+   <title>&pooma;</title>
+   <subtitle>A High Performance Distributed Simulation Environment for
+   Scientific Applications</subtitle>
+ <!-- FIXME: Where list Supercomputing 1995? -->
+  </biblioentry>
+ 
+  <biblioentry>
+   <abbrev>pooma-siam98</abbrev>
+   <authorgroup>
+    <author>
+     <firstname>Julian</firstname><othername role="mi">C.</othername><surname>Cummings</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>James</firstname><othername role="mi">A.</othername><surname>Crotinger</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Scott</firstname><othername role="mi">W.</othername><surname>Haney</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>William</firstname><othername role="mi">F.</othername><surname>Humphrey</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Steve</firstname><othername role="mi">R.</othername><surname>Karmesin</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>John</firstname><othername role="mi">V. W.</othername><surname>Reynders</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Stephen</firstname><othername role="mi">A.</othername><surname>Smith</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+    <author>
+     <firstname>Timothy</firstname><othername role="mi">J.</othername><surname>Williams</surname>
+     <affiliation>
+      <orgname>Los Alamos National Laboratory</orgname>
+      <address><city>Los Alamos</city><state>NM</state></address>
+     </affiliation>
+    </author>
+   </authorgroup>
+   <title>Raid Application Development and Enhanced Code
+   Interoperability using the &pooma; Framework</title>
+ <!-- FIXME: Where list SIAM Workshop ... 1998? -->
+  </biblioentry>
+ 
+  <biblioentry>
+   <abbrev>pete-99</abbrev>
+   <authorgroup>
+    <author>
+     <firstname>Scott</firstname><surname>Haney</surname>
+    </author>
+    <author>
+     <firstname>James</firstname><surname>Crotinger</surname>
+    </author>
+    <author>
+     <firstname>Steve</firstname><surname>Karmesin</surname>
+    </author>
+    <author>
+     <firstname>Stephen</firstname><surname>Smith</surname>
+    </author>
+   </authorgroup>
+   <title>&pete;: The Portable Expression Template Engine.  1999 October,
+ \emph{Dr. Dobb's Journal}, vol.24, nu.10, pp.88--95</title>
+ <!-- FIXME: Fix the tagging. -->
+  </biblioentry>
+ 
+  <biblioentry>
+   <abbrev>veldhuizen-95</abbrev>
+   <authorgroup>
+    <author>
+     <firstname>Todd</firstname><surname>Veldhuizen</surname>
+    </author>
+   </authorgroup>
+   <title>Expression Templates.  1995 June, \emph{&cc; Report}, vol.7,
+ nu.5, pp.26--31.  Also available at http://osl.iu.edu/~tveldhui/papers/Expression-Templates/exprtmpl.html</title>
+ <!-- FIXME: Fix the tagging. -->
+  </biblioentry>
+ 
+  <biblioentry>
+   <abbrev>vandevoorde-95</abbrev>
+   <authorgroup>
+    <author>
+     <firstname>David</firstname><surname>Vandevoorde</surname>
+    </author>
+   </authorgroup>
+   <title>\texttt{valarray&lt;Troy&gt;}: An Implementation of a Numerical
+ Array.  1995.  unpublished.  Available at ftp://ftp.cs.rpi.edu/pub/vandevod/Valarray/Documents/valarray.ps.</title>
+ <!-- FIXME: Fix the tagging. -->
+  </biblioentry>
+ 
+ 
+ </bibliography>
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.3
diff -c -p -r1.3 concepts.xml
*** concepts.xml	2001/12/17 17:27:41	1.3
--- concepts.xml	2002/01/04 17:14:05
***************
*** 343,349 ****
  	<imagedata fileref="figures/concepts.101" format="EPS" align="center"></imagedata>
       </imageobject>
       <textobject>
! 	<phrase>maps from indices to values</phrase>
       </textobject>
      </mediaobject>
     </figure>
--- 343,349 ----
  	<imagedata fileref="figures/concepts.101" format="EPS" align="center"></imagedata>
       </imageobject>
       <textobject>
! 	<phrase>&array;s and &field;s map from indices to values.</phrase>
       </textobject>
      </mediaobject>
     </figure>
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.4
diff -c -p -r1.4 glossary.xml
*** glossary.xml	2001/12/17 17:27:41	1.4
--- glossary.xml	2002/01/04 17:14:06
***************
*** 91,96 ****
--- 91,112 ----
     </glossdef>
    </glossentry>
  
+   <glossentry id="glossary-compilation_time">
+    <glossterm>compilation time</glossterm>
+    <glosssee otherterm="glossary-compilation_time"></glosssee>
+   </glossentry>
+ 
+   <glossentry id="glossary-compile_time">
+    <glossterm>compile time</glossterm>
+    <glossdef>
+     <para>time in the process from writing a program to executing it
+     when the program is compiled by a compiler.  This is also called
+     <firstterm>compilation time</firstterm>.</para>
+     <glossseealso otherterm="glossary-programming_time">programming time</glossseealso>
+     <glossseealso otherterm="glossary-run_time">run time</glossseealso>
+    </glossdef>
+   </glossentry>
+ 
    <glossentry id="glossary-computing_environment">
     <glossterm>computing environment</glossterm>
     <glossdef>
***************
*** 102,107 ****
--- 118,145 ----
     </glossdef>
    </glossentry>
  
+   <glossentry id="glossary-conformable_containers">
+    <glossterm>conformable containers</glossterm>
+    <glossdef>
+     <para>containers with conformable domains.</para>
+     <glossseealso otherterm="glossary-conformable_domains">conformable domains</glossseealso>
+     <glossseealso otherterm="glossary-data_parallel">data parallel</glossseealso>
+    </glossdef>
+   </glossentry>
+ 
+   <glossentry id="glossary-conformable_domains">
+    <glossterm>conformable domains</glossterm>
+    <glossdef>
+     <para>domains with the <quote>same shape</quote> so that
+     corresponding dimensions have the same number of elements.
+     Scalars, deemed conformable with any domain, get
+     <quote>expanded</quote> to the domain's shape.  Binary operators
+     can operate on containers with conformable domains.</para>
+     <glossseealso otherterm="glossary-conformable_containers">conformable containers</glossseealso>
+     <glossseealso otherterm="glossary-data_parallel">data parallel</glossseealso>
+    </glossdef>
+   </glossentry>
+ 
    <glossentry id="glossary-container">
     <glossterm>container</glossterm>
     <glossdef>
***************
*** 240,245 ****
--- 278,288 ----
     </glossdef>
    </glossentry>
  
+   <glossentry id="glossary-execution_time">
+    <glossterm>execution time</glossterm>
+    <glosssee otherterm="glossary-run_time"></glosssee>
+   </glossentry>
+ 
    <glossentry id="glossary-external_guard_layer">
     <glossterm>external guard layer</glossterm>
     <glossdef>
***************
*** 297,311 ****
     <glossdef>
      <para>domain surrounding each patch of a container's domain.  It
      contains read-only values.  <link
! 				       linkend="glossary-external_guard_layer">External guard
      layer</link>s ease programming, while <link
! 						 linkend="glossary-internal_guard_layer">internal guard
      layer</link>s permit each patch's computation to be occur without
!     copying values from adjacent patches.  They are optimizations,
!     not required for program correctness.</para>
!     <glossseealso otherterm="glossary-external_guard_layer">external guard layer</glossseealso>
!     <glossseealso otherterm="glossary-internal_guard_layer">internal guard layer</glossseealso>
!     <glossseealso otherterm="glossary-partition">partition</glossseealso>
      <glossseealso otherterm="glossary-patch">patch</glossseealso>
      <glossseealso otherterm="glossary-domain">domain</glossseealso>
     </glossdef>
--- 340,356 ----
     <glossdef>
      <para>domain surrounding each patch of a container's domain.  It
      contains read-only values.  <link
!     linkend="glossary-external_guard_layer">External guard
      layer</link>s ease programming, while <link
!     linkend="glossary-internal_guard_layer">internal guard
      layer</link>s permit each patch's computation to be occur without
!     copying values from adjacent patches.  They are optimizations, not
!     required for program correctness.</para> <glossseealso
!     otherterm="glossary-external_guard_layer">external guard
!     layer</glossseealso> <glossseealso
!     otherterm="glossary-internal_guard_layer">internal guard
!     layer</glossseealso> <glossseealso
!     otherterm="glossary-partition">partition</glossseealso>
      <glossseealso otherterm="glossary-patch">patch</glossseealso>
      <glossseealso otherterm="glossary-domain">domain</glossseealso>
     </glossdef>
***************
*** 319,331 ****
     <glossterm>index</glossterm>
     <glossdef>
      <para>a position in a <link
! 				 linkend="glossary-domain">domain</link> usually denoted by an
      ordered tuple.  More than one index are called <link
! 							  linkend="glossary-indices">indices</link>.</para>
!     <glossseealso otherterm="glossary-domain">domain</glossseealso>
     </glossdef>
    </glossentry>
  
    <glossentry id="glossary-indices">
     <glossterm>indices</glossterm>
     <glossdef>
--- 364,381 ----
     <glossterm>index</glossterm>
     <glossdef>
      <para>a position in a <link
!     linkend="glossary-domain">domain</link> usually denoted by an
      ordered tuple.  More than one index are called <link
!     linkend="glossary-indices">indices</link>.</para> <glossseealso
!     otherterm="glossary-domain">domain</glossseealso>
     </glossdef>
    </glossentry>
  
+   <glossentry id="glossary-instantiation">
+    <glossterm>instantiation</glossterm>
+    <glosssee>template instantiation</glosssee>
+   </glossentry>
+ 
    <glossentry id="glossary-indices">
     <glossterm>indices</glossterm>
     <glossdef>
***************
*** 439,444 ****
--- 489,504 ----
      <glossseealso otherterm="glossary-index">index</glossseealso>
     </glossdef>
    </glossentry>
+ 
+   <glossentry id="glossary-programming_time">
+    <glossterm>programming time</glossterm>
+    <glossdef>
+     <para>time in the process from writing a program to executing it
+     when the program is being written by a programmer.</para>
+     <glossseealso otherterm="glossary-compile_time">compile time</glossseealso>
+     <glossseealso otherterm="glossary-run_time">run time</glossseealso>
+    </glossdef>
+   </glossentry>
   </glossdiv>
  
   <glossdiv id="glossary-r">
***************
*** 480,485 ****
--- 540,556 ----
      <glossseealso otherterm="glossary-stencil">stencil</glossseealso>
     </glossdef>
    </glossentry>
+ 
+   <glossentry id="glossary-run_time">
+    <glossterm>run time</glossterm>
+    <glossdef>
+     <para>time in the process from writing a program to executing it
+     when the program is executed.  This is also called
+     <firstterm>execution time</firstterm>.</para>
+     <glossseealso otherterm="glossary-compile_time">compile time</glossseealso>
+     <glossseealso otherterm="glossary-programming_time">programming time</glossseealso>
+    </glossdef>
+   </glossentry>
   </glossdiv>
  
   <glossdiv id="glossary-s">
***************
*** 541,546 ****
--- 612,629 ----
   <glossdiv id="glossary-t">
    <title>T</title>
  
+   <glossentry id="glossary-template_instantiation">
+    <glossterm>template instantiation</glossterm>
+    <glossdef>
+     <para>applying a template class to template parameters to create a
+     type.  For example, <statement>foo&lt;double,3&gt;</statement>
+     instantiates <statement>template &lt;typename T, int n&gt; class
+     foo</statement> with the type &double; and the constant
+     integer&nbsp;3.  Template instantiation is analogous to applying a
+     function to function arguments.</para>
+    </glossdef>
+   </glossentry>
+ 
    <glossentry id="glossary-tensor">
     <glossterm>&tensor;</glossterm>
     <glossdef>
***************
*** 558,563 ****
--- 641,673 ----
      mathematical matrices as first-class objects.</para>
      <glossseealso otherterm="glossary-tensor">&tensor;</glossseealso>
      <glossseealso otherterm="glossary-vector">&vector;</glossseealso>
+    </glossdef>
+   </glossentry>
+ 
+   <glossentry id="glossary-trait">
+    <glossterm>trait</glossterm>
+    <glossdef>
+     <para>a characteristic of a type.</para>
+     <glossseealso otherterm="glossary-traits_class">traits class</glossseealso>
+    </glossdef>
+   </glossentry>
+ 
+   <glossentry id="glossary-traits_class">
+    <glossterm>traits class</glossterm>
+    <glossdef>
+     <para>a class containing one or more traits all describing a
+     particular type's chacteristics.</para>
+     <glossseealso otherterm="glossary-trait">trait</glossseealso>
+    </glossdef>
+   </glossentry>
+ 
+   <glossentry id="glossary-Turing_complete">
+    <glossterm>Turing complete</glossterm>
+    <glossdef>
+     <para>describes a language that can compute anything that can be
+     computed.  That is, the language for computation is as powerful as
+     it can be.  Most wide-spread programming languages are
+     Turing-complete, including &cc;, &c;, and &fortran;.</para>
     </glossdef>
    </glossentry>
   </glossdiv>
Index: introduction.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/introduction.xml,v
retrieving revision 1.1
diff -c -p -r1.1 introduction.xml
*** introduction.xml	2001/12/17 17:27:41	1.1
--- introduction.xml	2002/01/04 17:14:06
***************
*** 2,21 ****
   <title>Introduction</title>
  
   <para>The Parallel Object-Oriented Methods and Applications
!  <acronym>POOMA</acronym> &toolkitcap; is a &cc; &toolkit; for
!  writing high-performance scientific programs for sequential and
!  distributed computation.  The &toolkit; provides a variety of
!  tools:
   <itemizedlist spacing="compact">
     <listitem>
      <para>containers and other abstractions suitable for scientific
      computation,</para>
     </listitem>
     <listitem>
-     <para>several container storage classes to reduce a program's
-     storage requirements,</para>
-    </listitem>
-    <listitem>
      <para>support for a variety of computation modes including
      data-parallel expressions, stencil-based computations, and lazy
      evaluation,</para>
--- 2,16 ----
   <title>Introduction</title>
  
   <para>The Parallel Object-Oriented Methods and Applications
!  (<acronym>POOMA</acronym>) &toolkitcap; is a &cc; &toolkit; for
!  writing high-performance scientific programs.  The &toolkit; provides
!  a variety of tools:
   <itemizedlist spacing="compact">
     <listitem>
      <para>containers and other abstractions suitable for scientific
      computation,</para>
     </listitem>
     <listitem>
      <para>support for a variety of computation modes including
      data-parallel expressions, stencil-based computations, and lazy
      evaluation,</para>
***************
*** 25,31 ****
     </listitem>
     <listitem>
      <para>automatic creation of all interprocessor communication for
!     parallel and distributed programs, and</para>
     </listitem>
     <listitem>
      <para>automatic out-of-order execution and loop rearrangement
--- 20,30 ----
     </listitem>
     <listitem>
      <para>automatic creation of all interprocessor communication for
!     parallel and distributed programs</para>
!    </listitem>
!    <listitem>
!     <para>several container storage classes to reduce a program's
!     storage requirements, and</para>
     </listitem>
     <listitem>
      <para>automatic out-of-order execution and loop rearrangement
***************
*** 34,53 ****
    </itemizedlist>
   Since the &toolkit; provides high-level abstractions, &pooma;
   programs are much shorter than corresponding &fortran; or &c;
!  programs, requiring less time to write and less time to debug.
!  Using these high-level abstractions, the same code runs on a wide
!  variety of computers almost as fast as carefully crafted
!  machine-specific hand-written programs.  The &toolkit; is freely
!  available, open-source software compatible with any modern &cc;
!  compiler.</para>
  
!  <formalpara><title>&pooma; Goals.</title>
    <para>The goals for the &poomatoolkit; have remained unchanged
!   since its inception in 1994:
    <orderedlist>
     <listitem>
      <para>Code portability across serial, distributed, and parallel
!     architectures with no change to source code.</para>
     </listitem>
     <listitem>
      <para>Development of reusable, cross-problem-domain components
--- 33,55 ----
    </itemizedlist>
   Since the &toolkit; provides high-level abstractions, &pooma;
   programs are much shorter than corresponding &fortran; or &c;
!  programs and require less time to write and less time to debug.
!  Using these high-level abstractions, the same code runs on a
!  sequential, parallel, and distributed computers.  It runs almost as
!  fast as carefully crafted machine-specific hand-written programs.
!  The &toolkit; is freely available, open-source software compatible
!  with any modern &cc; compiler.</para>
  
! 
!  <section id="introduction-goals">
!   <title>&pooma; Goals</title>
! 
    <para>The goals for the &poomatoolkit; have remained unchanged
!   since its conception in 1994:
    <orderedlist>
     <listitem>
      <para>Code portability across serial, distributed, and parallel
!     architectures without any change to the source code.</para>
     </listitem>
     <listitem>
      <para>Development of reusable, cross-problem-domain components
***************
*** 58,66 ****
      scientific simulation.</para>
     </listitem>
     <listitem>
!     <para>[&toolkitcap;] design and development driven by
!     applications from a diverse set of scientific problem
!     domains.</para>
     </listitem>
     <listitem>
      <para>Shorter time from problem inception to working parallel
--- 60,67 ----
      scientific simulation.</para>
     </listitem>
     <listitem>
!     <para>&toolkitcap; design and development driven by applications
!     from a diverse set of scientific problem domains.</para>
     </listitem>
     <listitem>
      <para>Shorter time from problem inception to working parallel
***************
*** 68,296 ****
  <!-- FIXME: Add citation to pooma95, p.&nbsp;3 -->
     </listitem>
    </orderedlist>
!  </para>
!  </formalpara>
  
-  <formalpara><title>Code Portability for Sequential and Distributed Programs.</title>
-  <para>&pooma; programs run on sequential, distributed, and parallel
-  computers with no change in source code.  The programmer writes two
-  or three lines specifying how each container's domain should be
-  distributed among available processors.  Using these directives and
-  run-time information about the computer's configuration, the
-  &toolkit; automatically distributes pieces of the container
-  domains, called <firstterm>patch</firstterm>es, among the available
-  processors.  If a computation needs values from another patch,
-  &pooma; automatically passes the value to the place it is needed.
-  The same program, and even the same executable, works regardless of
-  the number of the available processors and the size of the
-  containers' domains.  A programmer interested in only sequential
-  execution can omit the two or three lines specifying how the
-  domains are to be distributed.</para>
-  </formalpara>
- 
-  <figure float="1" id="introduction-science_algorithms">
-   <title>Science, Algorithms, Engineering, and &pooma;</title>
-   <mediaobject>
-    <imageobject>
-     <imagedata fileref="figures/introduction.101" format="EPS" align="center"></imagedata>
-    </imageobject>
-    <textobject>
-     <phrase>how &pooma; helps translate algorithms into programs</phrase>
-    </textobject>
-    <caption>
-     <para>In the translation from theoretical science and math to
-     computational science and math to computer programs, &pooma;
-     containers eases the translation of algorithms to computer
-     programs.</para>
-    </caption>
-   </mediaobject>
-  </figure>
- 
-  <formalpara><title>Rapid Application Development.</title>
-  <para>The &poomatoolkit; is designed to enable rapid development of
-  scientific and distributed applications.  For example, its vector,
-  matrix, and tensor classes model the corresponding mathematical
-  concepts.  Its &array; and &field; classes model the discrete
-  spaces and mathematical arrays frequently found in computational
-  science and math.  See <xref
-  linkend="introduction-science_algorithms"></xref>.  The left column
-  illustrates theoretical science and math, the middle column
-  computational science and math, and the right column computer
-  science implementations.  For example, theoretical physics
-  frequently uses continuous fields in three-dimension space, while
-  algorithms for the corresponding computational physics problem
-  usually uses discrete fields.  &pooma; containers, classes, and
-  functions ease the engineering to map these algorithms to computer
-  programs.  For example, the &pooma; &field; container models
-  discrete fields; both map locations in discrete space to values and
-  permit computations of spatial distances and values.  The &pooma;
-  &array; container models the mathematical concept of an array, used
-  in numerical analysis.</para>
-  </formalpara>
- 
-  <para>&pooma; containers support a variety of computation modes,
-  easing transition of algorithms into code.  For example, many
-  algorithms for solving partial differential equations use
-  stencil-based computations.  &pooma; supports stencil-based
-  computations on &array;s and &field;s.  It also supports
-  data-parallel computation.  For computations where one &field;'s
-  values is a function of several other &field;'s values, the
-  programmer can specify a relation.  Relations are lazily evaluated;
-  whenever the dependent &field;'s values are needed and it is
-  related to a &field; whose values have changed, the former
-  &field;'s values are computed.  Lazy evaluation also assists
-  correctness by eliminating the (frequently forgotten) need for a
-  programmer to ensure a &field;'s values are up-to-date before being
-  used.</para>
- 
-  <formalpara><title>Efficient Code.</title>
-  <para>&pooma; incorporates a variety of techniques to ensure it
-  produces code that executes as quickly as special-case,
-  hand-written code.
- <!-- FIXME: Do I present execution numbers here? -->
-  These techniques include extensive use of templates, out-of-order
-  evaluation to permit communication and computation to overlap,
-  availability of guard layers to reduce processors' synchronicity,
-  and use of &pete; to produce fast inner loops.</para>
-  </formalpara>
- 
-  <para>Using templates permits the expressiveness of using pointers
-  and function arguments but ensures as much as work as possible
-  occurs at compile time, not run time.  Also, more code is exposed
-  to the compiler's optimizer, further speeding execution.  For
-  example, use of template parameters to define the &pooma; &array;
-  container permits the use of specialized data storage classes
-  called engines, fast creation of views of a portion of an &array;,
-  and polymorphic indexing.  An &array;'s engine template parameter
-  specifies how data is stored and indexed.  Some &array;s expect
-  almost all values to be used, while others might be mostly empty.
-  In the latter case, using a specialized engine storing the few
-  nonzero values would greatly reduce space requirements.  Using
-  engines also permits fast creation of container views, known as
-  <firstterm>array sections</firstterm> in Fortran&nbsp;90.  A view's
-  engine is the same as the original container's engine, while the
-  view object maps its restricted domain to the original domain.
-  Space requirements and execution time are minimal.  Using templates
-  also permits containers to support polymorphic indexing, e.g.,
-  indexing both by integers and by three-dimensional coordinates.
-  For example, a container defers returning values to its engine
-  using a templatized index operator.  The engine can define indexing
-  functions with different function arguments, without the need to
-  add corresponding container functions.  Some of these features can
-  be expressed without using templates, but doing so increases
-  execution time.  For example, a container could have a pointer to
-  an engine object, but this requires a pointer dereference for each
-  operation.  Implementing polymorphic indexing without templates
-  would require adding virtual function corresponding to each of the
-  indexing functions.</para>
- 
- <!-- FIXME: Are the claims concerning out-of-order evaluation I make true? -->
- 
-  <para>To ensure multiprocessor &pooma; programs execute quickly, it
-  is important that interprocessor communication overlaps with
-  intraprocessor computation as much as possible and communication is
-  minimized.  Asynchronous communication, out-of-order evaluation, and
-  use of guard layers all help achieve this.  &pooma; uses the
-  asynchronous communication facilities of the &cheetah; communication
-  library.  When a processor needs data stored or computed by another
-  processor, a message is sent between the two.  For synchronous
-  communication, the sender must issue an explicit send, and the
-  recipient must issue an explicit receive.  This synchronizes them.
-  &cheetah; permits the sender to put and get data without the
-  intervention of the remote site and also invoke functions at the
-  remote site to ensure the data is up-to-date.  Thus, out-of-order
-  evaluation must be supported.  Out-of-order evaluation has another
-  benefit: only computations directly or indirectly related to values
-  that are printed need occur.</para>
- 
-  <para>Using guard layers also helps overlap communication and
-  computation.  For distributed computation, each container's domain is
-  split into pieces distributed among the available processors.
-  Frequently, computing a container value is local, involving just the
-  value itself and a few neighbors.  Computing a value near the edge of
-  a processor's domain may require knowing a few values from a
-  neighboring domain.  Guard layers permit these values to be copied
-  locally so they need not be repeatedly communicated.</para>
- 
-  <para>&pooma; uses &pete; technology to ensure inner loops using
-  &pooma;'s object-oriented containers run as quickly as hand-coded
-  <!-- FIXME: Add a citation to Dr. Dobb's Journal article
-  pete-99. --> loops.  &pete; (the Portable Expression Template
-  Engine) uses expression-template technology to convert
-  data-parallel statements frequently found in the inner loops of
-  programs into efficient loops without any intermediate
-  computations.  For example, consider evaluating the <statement>A +=
-  -B + 2 * C;</statement> statement where <varname>A</varname> and
-  <varname>C</varname> are <type>vector&lt;double&gt;</type>s and
-  <varname>B</varname> is a <type>vector&lt;int&gt;</type>s.
-  Ordinary evaluation might introduce intermediaries for
-  <statement>-B</statement>, <statement>2*C</statement>, and their
-  sum.  The presence of these intermediaries in inner loops can
-  measurably slow evaluation.  To produce a loop without
-  intermediaries, &pete; stores each expression as a parse tree.  The
-  resulting parse trees can be combined into a larger parse tree.
-  Using its templates, the parse tree is converted, at compile time,
-  to an outer loop with contents corresponding to evaluating each
-  component of the result.  Thus, no intermediate values are computed
-  or stored.  For example, the code corresponding to <statement>A +=
-  -B + 2 * C;</statement> is 
-  <programlisting>
-  vector&lt;double&gt;::iterator iterA = A.begin();
-  vector&lt;int&gt;::const_iterator iterB = B.begin();
-  vector&lt;double&gt;::const_iterator iterC = C.begin();
-  while (iterA != A.end()) {
-    *iterA += -*iterB + 2 * *iterC;
-    ++iterA; ++iterB; ++iterC;
-  }
-  </programlisting>
-  Furthermore, since the code is available at compile-, not run-, time,
-  it can be further optimized, e.g., moving any loop-invariant code out
-  of the loop.</para>
- 
-  <formalpara><title>Used for Diverse Set of Scientific Problems.</title>
-  <para>&pooma; has been used to solve a wide variety of scientific
-  problems.  Most recently, physicists at Los Alamos National
-  Laboratory implemented an entire library of hydrodynamics codes as
-  part of the U.S. government's Science-based Stockpile Stewardship
-  (<acronym>SBSS</acronym>) program to simulate nuclear weapons.
-  Other applications include a matrix solver, an accelerator code
-  simulating the dynamics of high-intensity charged particle beams in
-  linear accelerators, and a Monte Carlo neutron transport
-  code.</para>
-  </formalpara>
- 
-  <formalpara><title>Easy Implementation.</title>
-  <para>&pooma;'s tools greatly reduce the time to implement
-  applications.  As we noted above, &pooma;'s containers and
-  expression syntax model the computational models and algorithms
-  most frequently found in scientific programs.  Using these
-  high-level tools which are known to be correct reduce the time
-  needed to debug programs.  Programmers can write and test programs
-  using their one or two-processor personal computers.  With no
-  additional work, the same program runs on computers with hundreds
-  of processors; the code is exactly the same, and the &toolkit;
-  automatically handles distribution of the data, all data
-  communication, and all synchronization.  Using all these tools
-  greatly reduces programming time.  For example, a team of two
-  physicists and two support people at Los Alamos National Laboratory
-  implemented a suite of hydrodynamics kernels in six months.  Their
-  work replaced the previous suite of less-powerful kernels which had
-  taken sixteen people several years to implement and debug.  Despite
-  not previously implementing any of the kernels, they averaged one
-  new kernel every three days, including the time to read the
-  corresponding scientific papers!</para>
-  </formalpara>
  
   <section id="introduction-pooma_history">
    <title>History of &pooma;</title>
  
!   <para>The &poomatoolkit; developed at Los Alamos National
    Laboratory to assist nuclear fusion and fission research.
!   In&nbsp;1994, the &toolkit; grew out of the Object-Oriented
!   Particle Simulation (OOPS) class library developed for
!   particle-in-cell simulations.  The goals of the Framework, as it
!   was called at the time, were driven by the Numerical Tokamak's
!   <quote>Parallel Platform Paradox</quote>:
    <blockquote>
     <para>The average time required to implement a moderate-sized
     application on a parallel computer architecture is equivalent to
--- 69,335 ----
  <!-- FIXME: Add citation to pooma95, p.&nbsp;3 -->
     </listitem>
    </orderedlist>
!   Below, we discuss how &pooma; achieves these goals.
!   </para>
! 
!   <bridgehead id="introduction-goals-portability" renderas="sect2">Code Portability for Sequential and Distributed Programs</bridgehead>
! 
!   <para>The same &pooma; programs run on sequential, distributed, and
!   parallel computers.  No change in source code is required.  Two or
!   three lines specifying how each container's domain should be
!   distributed among available processors.  Using these directives and
!   run-time information about the computer's configuration, the
!   &toolkit; automatically distributes pieces of the container domains,
!   called <link
!   linkend="glossary-patch"><firstterm>patches</firstterm></link>,
!   among the available processors.  If a computation needs values from
!   another patch, &pooma; automatically passes the value to the patch
!   where it is needed.  The same program, and even the same executable,
!   works regardless of the number of the available processors and the
!   size of the containers' domains.  A programmer interested in only
!   sequential execution can omit the two or three lines specifying how
!   the domains are to be distributed.</para>
! 
!   <bridgehead id="introduction-goals-rapid_development" renderas="sect2">Rapid Application Development</bridgehead>
! 
!   <para>The &poomatoolkit; is designed to enable rapid development of
!   scientific and distributed applications.  For example, its vector,
!   matrix, and tensor classes model the corresponding mathematical
!   concepts.  Its &array; and &field; classes model the discrete spaces
!   and mathematical arrays frequently found in computational science and
!   math.  See <xref linkend="introduction-science_algorithms"></xref>.
!   The left column indicates theoretical science and math concepts, the
!   middle column computational science and math concepts, and the right
!   column computer science implementations.  For example, theoretical
!   physics frequently uses continuous fields in three-dimension space,
!   while algorithms for a corresponding computational physics problem
!   usually uses discrete fields.  &pooma; containers, classes, and
!   functions ease engineering computer programs for these algorithms.
!   For example, the &pooma; &field; container models discrete fields;
!   both map locations in discrete space to values and permit
!   computations of spatial distances and values.  The &pooma; &array;
!   container models the mathematical concept of an array, used in
!   numerical analysis.</para>
! 
!   <figure float="1" id="introduction-science_algorithms">
!    <title>How &pooma; Fits Into the Scientific Process</title>
!    <mediaobject>
!     <imageobject>
!      <imagedata fileref="figures/introduction.101" format="EPS" align="center"></imagedata>
!     </imageobject>
!     <textobject>
!      <phrase>&pooma; helps translate algorithms into programs.</phrase>
!     </textobject>
!     <caption>
!      <para>In the translation from theoretical science and math to
!      computational science and math to computer programs, &pooma; eases
!      the implementation of algorithms as computer programs.</para>
!     </caption>
!    </mediaobject>
!   </figure>
! 
!   <para>&pooma; containers support a variety of computation modes,
!   easing translation of algorithms into code.  For example, many
!   algorithms for solving partial differential equations use
!   stencil-based computations.  &pooma; supports stencil-based
!   computations on &array;s and &field;s.  It also supports
!   data-parallel computation similar to &fortran&nbsp;90 syntax.  For
!   computations where one &field;'s values is a function of several
!   other &field;'s values, the programmer can specify a relation.
!   Relations are lazily evaluated: whenever the dependent &field;'s
!   values are needed and it is dependent on a &field; whose values have
!   changed, its values are computed.  Lazy evaluation also assists
!   correctness by eliminating the frequently forgotten need for a
!   programmer to ensure a &field;'s values are up-to-date before being
!   used.</para>
! 
!   <bridgehead id="introduction-goals-efficient" renderas="sect2">Efficient Code</bridgehead>
! 
!   <para>&pooma; incorporates a variety of techniques to ensure it
!   produces code that executes as quickly as special-case,
!   hand-written code.
!  <!-- FIXME: Do I present execution numbers here? -->
!   These techniques include extensive use of templates, out-of-order
!   evaluation, use of guard layers, and production of fast inner loops.</para>
! 
!   <para>&pooma;'s uses of &cc; templates permits the expressiveness
!   from using pointers and function arguments but ensures as much as
!   work as possible occurs at compile time, not run time.  This speeds
!   programs' execution.  Since more code is produced at compile time,
!   more code is available to the compiler's optimizer, further speeding
!   execution.  The &pooma; &array; container benefits from the use of
!   template parameters.  Their use permits the use of specialized data
!   storage classes called <link
!   linkend="glossary-engine"><firstterm>engines</firstterm></link>.  An
!   &array;'s engine template parameter specifies how data is stored and
!   indexed.  Some &array;s expect almost all values to be used, while
!   others might be mostly vacant.  In the latter case, using a
!   specialized engine storing the few nonzero values greatly reduces
!   space requirements.  Using engines also permits fast creation of
!   container views, known as <firstterm>array sections</firstterm> in
!   Fortran&nbsp;90.  A view's engine is the same as the original
!   container's engine, but the view object maps its restricted domain to
!   the original domain.  Space requirements and execution time to use
!   views are minimal.  Using templates also permits containers to
!   support polymorphic indexing, e.g., indexing both by integers and by
!   three-dimensional coordinates.  A container defers indexing
!   operations to its engine's templatized index operator.  Since it uses
!   templates, the engine can define indexing functions with different
!   function arguments, without the need to add corresponding container
!   functions.  Some of these benefits of using templates can be
!   expressed without them, but doing so increases execution time.  For
!   example, a container could have a pointer to an engine object, but
!   this requires a pointer dereference for each operation.  Implementing
!   polymorphic indexing without templates would require adding virtual
!   functions corresponding to each of the indexing functions.</para>
! 
!  <!-- FIXME: Are the claims concerning out-of-order evaluation I make true? -->
! 
!   <para>To ensure multiprocessor &pooma; programs execute quickly, it
!   is important that interprocessor communication overlaps with
!   intraprocessor computations as much as possible and that
!   communication is minimized.  Asynchronous communication, out-of-order
!   evaluation, and use of guard layers all help achieve these goals.
!   &pooma; uses the asynchronous communication facilities of the
!   &cheetah; communication library.  When a processor needs data that is
!   stored or computed by another processor, a message is sent between
!   the two.  If synchronous communication was used, the sender must
!   issue an explicit send, and the recipient must issue an explicit
!   receive, synchronizing the two processors.  &cheetah; permits the
!   sender to put and get data without synchronizing with the recipient
!   processor, and it also permits invoking functions at remote sites to
!   ensure desired data is up-to-date.  Thus, out-of-order evaluation
!   must be supported.  Out-of-order evaluation also has another benefit:
!   Only computations directly or indirectly related to values that are
!   printed need occur.</para>
! 
!   <para>Surrounding a patch with <link
!   linkend="glossary-guard_layer"><firstterm>guard
!   layers</firstterm></link> can help reduce interprocessor
!   communication.  For distributed computation, each container's domain
!   is split into pieces distributed among the available processors.
!   Frequently, computing a container value is local, involving just the
!   value itself and a few neighbors, but computing a value near the edge
!   of a processor's domain may require knowing a few values from a
!   neighboring domain.  Guard layers permit these values to be copied
!   locally so they need not be repeatedly communicated.</para>
! 
!   <para>&pooma; uses &pete; technology to ensure inner loops involving
!   &pooma;'s object-oriented containers run as quickly as hand-coded
!   <!-- FIXME: Add a citation to Dr. Dobb's Journal article pete-99. -->
!   loops.  &pete; (the Portable Expression Template Engine) uses
!   expression-template technology to convert data-parallel statements
!   in the inner loops of programs into efficient loops
!   without any intermediate computations.  For example, consider
!   evaluating the statement
!   <programlisting>
!   A += -B + 2 * C;</programlisting>
!   where <varname>A</varname> and <varname>C</varname> are
!   <type>vector&lt;double&gt;</type>s and <varname>B</varname> is a
!   <type>vector&lt;int&gt;</type>.  Naive evaluation might introduce
!   intermediaries for <statement>-B</statement>,
!   <statement>2*C</statement>, and their sum.  The presence of these
!   intermediaries in inner loops can measurably slow evaluation.  To
!   produce a loop without intermediaries, &pete; stores each expression
!   as a parse tree.  The resulting parse trees can be combined into a
!   larger parse tree.  Using its templates, the parse tree is converted,
!   at compile time, to a loop evaluating each component of the result.
!   Thus, no intermediate values are computed or stored.  For example,
!   the code corresponding to the statement above is
!   <programlisting>
!   vector&lt;double&gt;::iterator iterA = A.begin();
!   vector&lt;int&gt;::const_iterator iterB = B.begin();
!   vector&lt;double&gt;::const_iterator iterC = C.begin();
!   while (iterA != A.end()) {
!     *iterA += -*iterB + 2 * *iterC;
!     ++iterA; ++iterB; ++iterC;
!   }</programlisting>
!   Furthermore, since the code is available at compile, not run, time,
!   it can be further optimized, e.g., moving any loop-invariant code out
!   of the loop.</para>
! 
!   <bridgehead id="introduction-goals-scientific" renderas="sect2">Used for Diverse Set of Scientific Problems</bridgehead>
! 
!   <para>&pooma; has been used to solve a wide variety of scientific
!   problems.  Most recently, physicists at Los Alamos National
!   Laboratory implemented an entire library of hydrodynamics codes as
!   part of the U.S. government's science-based Stockpile Stewardship
!   Program to simulate nuclear weapons.  Other applications include a
!   matrix solver, an accelerator code simulating the dynamics of
!   high-intensity charged particle beams in linear accelerators, and a
!   Monte Carlo neutron transport code.</para>
! 
!   <bridgehead id="introduction-goals-easy_implementation" renderas="sect2">Easy Implementation</bridgehead>
! 
!   <para>&pooma;'s tools greatly reduce the time to implement
!   applications.  As we noted above, &pooma;'s containers and expression
!   syntax model the computational models and algorithms most frequently
!   found in scientific programs.  These high-level tools are known to be
!   correct and reduce the time to debug programs.  Since the same
!   programs run on one processor and multiple processors, programmers
!   can write and test programs using their one or two-processor personal
!   computers.  With no additional work, the same program runs on
!   computers with hundreds of processors; the code is exactly the same,
!   and the &toolkit; automatically handles distribution of the data, all
!   data communication, and all synchronization.  The net results is a
!   significant reduction in programming time.  For example, a team of
!   two physicists and two support people at Los Alamos National
!   Laboratory implemented a suite of hydrodynamics kernels in six
!   months.  Their work replaced a previous suite of less-powerful
!   kernels which had taken sixteen people several years to implement and
!   debug.  Despite not have previously implemented any of the kernels,
!   they implemented one new kernel every three days, including the time
!   to read the corresponding scientific papers!</para>
!  </section><!-- introduction-goals -->
! 
! 
!  <section id="introduction-performance">
!   <title>&pooma; Produces Fast Programs</title>
! 
!   <para>almost as fast as &c;.  wide variety of configurations: one
!   processor, many processors, give performance data for at least two
!   different programs
! HERE</para>
! 
!   <para>describe &doof2d; here
! 
!   &doof2d; is a two-dimensional diffusion simulation program.
!   Initially, all values in the square two-dimensional grid are zero
!   except for the central value.  
! 
! HERE</para>
! 
!  </section>
! 
! <!-- HERE -->
! 
!  <section id="introduction-open_source">
!   <title>&pooma; is Free, Open-Source Software</title>
! 
!   <para>The &poomatoolkit; is open-source software.  Anyone may
!   download, read, redistribute, and modify the &pooma; source code.
!   If an application requires a specialized container, any programmer
!   may add it.  Any programmer can extend it to solve problems in
!   previously unsupported domains.  Companies using the &toolkit; can
!   read the source code to ensure it has no hidden back doors or
!   security holes.  It may be downloaded for free and used for
!   perpetuity.  There are no annual licenses and no on-going costs.  By
!   keeping their own copies, companies are guaranteed the software will
!   never disappear.  In summary, the &poomatoolkit; is free, low-risk
!   software.</para>
!  </section>
  
  
   <section id="introduction-pooma_history">
    <title>History of &pooma;</title>
  
!   <para>The &poomatoolkit; was developed at Los Alamos National
    Laboratory to assist nuclear fusion and fission research.
!   In&nbsp;1994, the &toolkit; grew out of the <application
!   class='software'>Object-Oriented Particle Simulation</application>
!   class library developed for particle-in-cell simulations.  The goals
!   of the Framework, as it was called at the time, were driven by the
!   Numerical Tokamak's <quote>Parallel Platform Paradox</quote>:
    <blockquote>
     <para>The average time required to implement a moderate-sized
     application on a parallel computer architecture is equivalent to
***************
*** 298,304 ****
    </blockquote>
    The framework's goal of being able to quickly write efficient
    scientific code that could be run on a wide variety of platforms
!   remains unchanged today.  Development, driven mainly by the
    Advanced Computing Laboratory at Los Alamos, proceeded rapidly.
    A matrix solver application was written using the framework.
  <!-- FIXME: Add citation to pooma-sc95. -->
--- 337,343 ----
    </blockquote>
    The framework's goal of being able to quickly write efficient
    scientific code that could be run on a wide variety of platforms
!   remains unchanged today.  Development, mainly at the
    Advanced Computing Laboratory at Los Alamos, proceeded rapidly.
    A matrix solver application was written using the framework.
  <!-- FIXME: Add citation to pooma-sc95. -->
***************
*** 307,321 ****
  
    <para>By&nbsp;1998, &pooma; was part of the U.S. Department of
    Energy's Accelerated Strategic Computing Initiative
!   (<acronym>ASCI</acronym>).  The Comprehensive Test Ban Treaty
!   forbid nuclear weapons testing so they were instead simulated.
!   <acronym>ASCI</acronym>'s goal was to radically advance the state
!   of the art in high-performance computing and numerical simulations
!   so the nuclear weapon simulations could use 100-teraflop
!   computers.  A linear accelerator code <application
    class='software'>linac</application> and a Monte Carlo neutron
!   transport code <application class='software'>MC++</application>
!   were written.
  <!-- FIXME: Add citation to pooma-siam98. -->
    </para>
  
--- 346,360 ----
  
    <para>By&nbsp;1998, &pooma; was part of the U.S. Department of
    Energy's Accelerated Strategic Computing Initiative
!   (<acronym>ASCI</acronym>).  The Comprehensive Test Ban Treaty forbid
!   nuclear weapons testing so they were instead simulated using
!   computers.  <acronym>ASCI</acronym>'s goal was to radically advance
!   the state of the art in high-performance computing and numerical
!   simulations so the nuclear weapon simulations could use 100-teraflop
!   parallel computers.  A linear accelerator code <application
    class='software'>linac</application> and a Monte Carlo neutron
!   transport code <application class='software'>MC++</application> were
!   among the codes written.
  <!-- FIXME: Add citation to pooma-siam98. -->
    </para>
  
***************
*** 332,348 ****
    engines were added.  Release&nbsp;2.1.0 included &field;s with
    their spatial extent and &dynamicarray;s with the ability to
    dynamically change its domain size.  Support for particles and
!   their interaction with &field;s was added.  The &pooma; messaging
    implementation was revised in release&nbsp;2.3.0.  Use of the
    &cheetah; Library separated &pooma; from the actual messaging
!   library used.  Support for applications running on clusters of
!   computers was added.  During the past two years, the &field;
    abstraction and implementation was improved to increase its
    flexibility, add support for multiple values and materials in the
    same cell, and permit lazy evaluation.  Simultaneously, the
!   execution speed of the inner loops was greatly increased.  The
!   particle code has not yet been ported to the new &field;
!   abstraction.</para>
   </section>
  
  </chapter>
--- 371,389 ----
    engines were added.  Release&nbsp;2.1.0 included &field;s with
    their spatial extent and &dynamicarray;s with the ability to
    dynamically change its domain size.  Support for particles and
!   their interaction with &field;s were added.  The &pooma; messaging
    implementation was revised in release&nbsp;2.3.0.  Use of the
    &cheetah; Library separated &pooma; from the actual messaging
!   library used, and support for applications running on clusters of
!   computers was added.  <ulink
!   url="http://www.codesourcery.com">CodeSourcery, LLC</ulink>, and
!   <ulink url="www.proximation.com">Proximation, LLC</ulink>, took
!   over &pooma; development from Los Alamos National Laboratory.
!   During the past two years, the &field;
    abstraction and implementation was improved to increase its
    flexibility, add support for multiple values and materials in the
    same cell, and permit lazy evaluation.  Simultaneously, the
!   execution speed of the inner loops was greatly increased.</para>
   </section>
  
  </chapter>
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.4
diff -c -p -r1.4 manual.xml
*** manual.xml	2001/12/17 17:27:41	1.4
--- manual.xml	2002/01/04 17:14:10
***************
*** 26,31 ****
--- 26,33 ----
    <!-- Modify this to the desired formatting. -->
  <!ENTITY cheetah "<application class='software'>Cheetah</application>" >
    <!-- Produce a notation for the Cheetah Library.  -->
+ <!ENTITY closeclose "&gt;&hairsp;&gt;" >
+   <!-- Produce a notation for ">>", which frequently occurs with templates.  Without this, TeX produces a shift symbol. -->
  <!ENTITY dashdash "-&hairsp;-" >
    <!-- Produce a notation for a double dash.  Without this, TeX produces an en-hyphen. -->
  <!ENTITY doof2d "<command>Doof2d</command>" >
***************
*** 38,47 ****
    <!-- Produce a notation for the MM Library.  -->
  <!ENTITY mpi "<application class='software'>MPI</application>">
    <!-- Produce a notation for the MPI package.  -->
  <!ENTITY pdt "<application class='software'>PDToolkit</application>">
    <!-- Produce a notation for the PDT software package.  -->
  <!ENTITY pete "<application class='software'>PETE</application>">
!   <!-- Produce a notation for the PETE library.  -->
  <!ENTITY pooma "<application class='software'>POOMA</application>">
    <!-- Produce a notation for Pooma software.  -->
  <!ENTITY poomatoolkit "<application class='software'>POOMA &toolkitcap;</application>">
--- 40,51 ----
    <!-- Produce a notation for the MM Library.  -->
  <!ENTITY mpi "<application class='software'>MPI</application>">
    <!-- Produce a notation for the MPI package.  -->
+ <!ENTITY openopen "&lt;&hairsp;&lt;" >
+   <!-- Produce a notation for "<<", which frequently occurs with output.  Without this, TeX produces a shift symbol. -->
  <!ENTITY pdt "<application class='software'>PDToolkit</application>">
    <!-- Produce a notation for the PDT software package.  -->
  <!ENTITY pete "<application class='software'>PETE</application>">
!   <!-- Produce a notation for the PETE framework.  -->
  <!ENTITY pooma "<application class='software'>POOMA</application>">
    <!-- Produce a notation for Pooma software.  -->
  <!ENTITY poomatoolkit "<application class='software'>POOMA &toolkitcap;</application>">
***************
*** 87,92 ****
--- 91,98 ----
    <!-- The "Field" type. -->
  <!ENTITY inform "<type>Inform</type>">
    <!-- The "Inform" output type. -->
+ <!ENTITY int "<type>int</type>">
+   <!-- The C "int" type. -->
  <!ENTITY interval "<type>Interval</type>">
    <!-- The "Interval" type. -->
  <!ENTITY layout "<type>Layout</type>">
***************
*** 155,162 ****
--- 161,172 ----
    <!-- spelling: nonzero, not non-zero -->
  
  <!-- External Chapters -->
+ <!ENTITY bibliography-chapter SYSTEM "bibliography.xml">
+   <!-- bibliography -->
  <!ENTITY concepts-chapter SYSTEM "concepts.xml">
    <!-- Pooma concepts chapter -->
+ <!ENTITY data-parallel-chapter SYSTEM "data-parallel.xml">
+   <!-- data-parallel expressions chapter -->
  <!ENTITY glossary-chapter SYSTEM "glossary.xml">
    <!-- glossary -->
  <!ENTITY introductory-chapter SYSTEM "introduction.xml">
***************
*** 183,189 ****
  
  <!-- Sequential Programs -->
  <!ENTITY initialize-finalize SYSTEM "./programs/examples/Sequential/initialize-finalize-annotated.cpp">
!   <!-- illustrate initialize() and finalize() -->
  ]>
  
  <book>
--- 193,205 ----
  
  <!-- Sequential Programs -->
  <!ENTITY initialize-finalize SYSTEM "./programs/examples/Sequential/initialize-finalize-annotated.cpp">
!   <!-- Illustrate initialize() and finalize(). -->
! 
! <!-- Template Programs -->
! <!ENTITY pairs-untemplated SYSTEM "./programs/examples/Templates/pairs-untemplated-annotated.cpp">
!   <!-- Illustrate defining classes with pairs of values of the same type. -->
! <!ENTITY pairs-templated SYSTEM "./programs/examples/Templates/pairs-templated-annotated.cpp">
!   <!-- Illustrate defining a template class with pairs of values of the same type. -->
  ]>
  
  <book>
***************
*** 205,211 ****
    <revhistory>
     <revision>
      <revnumber>0.01</revnumber>
!     <date>2001 Nov 26</date>
      <authorinitials>jdo</authorinitials>
      <revremark>first draft</revremark>
     </revision>
--- 221,227 ----
    <revhistory>
     <revision>
      <revnumber>0.01</revnumber>
!     <date>2001 Dec 18</date>
      <authorinitials>jdo</authorinitials>
      <revremark>first draft</revremark>
     </revision>
***************
*** 280,292 ****
    <title>Programming with &pooma;</title>
  
  <!-- FIXME: Add a partintro to the part above? -->
  
!   &introductory-chapter;
  
    &tutorial-chapter;
  
    &concepts-chapter;
  
  
    <chapter id="sequential">
     <title>Writing Sequential Programs</title>
--- 296,1819 ----
    <title>Programming with &pooma;</title>
  
  <!-- FIXME: Add a partintro to the part above? -->
+ 
+   &introductory-chapter; 
+ 
+ 
+   <chapter id="template_programming">
+    <title>Programming with Templates</title>
+ 
+    <para>&pooma; extensively uses &cc; templates to support type
+    polymorphism without any run-time cost.  In this chapter, we
+    briefly introduce using templates in &cc; programs by relating them
+    to <quote>ordinary</quote> &cc; constructs such as values, objects,
+    and classes.  The two main concepts underlying &cc; templates will
+    occur repeatedly:
+    <itemizedlist>
+     <listitem>
+      <para>Template programming occurs at compile time, not run
+      time.  That is, template operations occur inside the compiler,
+      not when a program runs.</para>
+     </listitem>
+     <listitem>
+      <para>Templates permit declaring families of classes with a
+      single declaration.  For example, the &array; template
+      declaration permits using arrays with many different element
+      types, e.g., arrays of integers, arrays of floating point
+      numbers, and arrays of arrays.</para>
+     </listitem>
+    </itemizedlist>
+    For those interested in the implementation of &pooma;, we close
+    with a discussion of some template programming concepts used in the
+    implementation but not likely to be used by &pooma; users.</para>
+ 
+    <section id="template_programming-compile_time">
+     <title>Templates Occur at Compile-Time</title>
+ 
+     <para>&pooma; uses templates to support type polymorphism without
+     incurring any run-time cost as a program executes.  All template
+     operations are performed at compile time by the compiler.</para>
+ 
+     <para>Prior to the introduction of templates, almost all a
+     program's interesting computation occurred when it was executed.
+     When writing the program, the programmer, at <glossterm
+     linkend="glossary-programming_time"><firstterm>programming
+     time</firstterm></glossterm>, would specify which statements and
+     expressions would occur and which types to use.  At <glossterm
+     linkend="glossary-compile_time"><firstterm>compile
+     time</firstterm></glossterm>, the compiler converts the program's
+     source code into an executable program.  Even though the compiler
+     uses the types to produce the executable, no interesting
+     computation occurs.  At <glossterm
+     linkend="glossary-run_time"><firstterm>run
+     time</firstterm></glossterm>, the resulting executable program
+     actually performs the operations.</para>
+ 
+     <para>The introduction of templates permits interesting
+     computation to occur while the compiler produces the executable.
+     Most interesting is template instantiation, which produces a type
+     at compile time.  For example, the &array; <quote>type</quote>
+     definition requires template parameters <varname>Dim</varname>,
+     <varname>T</varname>, and <varname>EngineTag</varname>, specifying
+     its dimension, the type of its elements, and its engine type.  To
+     use this, a programmer specifies values for the template
+     parameters:
+     <statement><type>Array&lt;2,double,Brick&gt;</type></statement>.
+     At compile time, the compiler creates a type definition by
+     substituting the values for the template parameters in the
+     template definition.  The substitution is analogous to the
+     run-time application of a function to specific values.</para>
+ 
+     <para>All computation not involving run-time input or output can
+     occur at program time, compile time, or run time, whichever is
+     more convenient.  At program time, a programmer can perform
+     computations by hand rather than writing code to compute it.  &cc;
+     templates are Turing-complete so they can compute anything.
+     Unfortunately, syntax for compile-time computation is more
+     difficult than for run-time computation, and also current compiler
+     are not as efficient as executables.  Run-time &cc; constructs are
+     Turing-complete so using templates is unnecessary.  Thus, we shift
+     computation to the time which best trades off the ease of
+     expressing syntax with the speed of computation by programmer,
+     compiler, or computer chip.  For example, &pooma; uses expression
+     template technology to speed run-time execution of data-parallel
+     statements.  The &pooma; developers decided to shift some of the
+     computation from run-time to compile-time using template
+     computations.  The resulting run-time code runs more quickly, but
+     compiling the code takes longer.  Also, programming time for the
+     &pooma; developers increased significantly, but, since most users
+     are most concerned about decreasing run times, they made this
+     choice.</para>
+ 
+    </section>
+ 
+ 
+    <section id="template_programming-template_use">
+     <title>Template Programming for &pooma; Users</title>
+ 
+     <para>Most &pooma; users need only understand a subset of
+     available tools for template programming.  These tools include
+     <itemizedlist>
+       <listitem>
+        <para>reading template declarations and understanding template
+        parameters, which are used in this book.</para>
+       </listitem>
+      <listitem>
+       <para>template instantiation, specifying a particular type by
+       specifying values for template parameters.</para>
+      </listitem>
+       <listitem>
+        <para>nested type names, which are types specified within a
+        class definition.</para>
+       </listitem>
+     </itemizedlist>
+     We discuss these below.</para>
  
!     <example id="template_programming-template_use-untemplated_pair_example">
!      <title>Classes Storing Pairs of Values</title>
! &pairs-untemplated;
!     </example>
! 
!     <para>Templates generalize writing class declarations by
!     permitting class declarations dependent on other types.  For
!     example, consider writing a class storing a pair of integers and a
!     class storing a pair of doubles.  See <xref
!     linkend="template_programming-template_use-untemplated_pair_example"></xref>.
!     Almost all of the code for the two definitions is the same.  Both
!     of these definitions define a class with a constructor and storing
!     two values named <varname>left</varname> and
!     <varname>right</varname> having the same type.  Only the classes'
!     names and its use of types differ.</para>
! 
!     <example id="template_programming-template_use-templated_pair_example">
!      <title>Templated Class Storing Pairs of Values</title>
! &pairs-templated;
!      <calloutlist>
!       <callout
!        arearefs="template_programming-template_use-templated_pair_program-template_declaration">
!        <para>Template parameters are written before, not after, a
!        class name.</para>
!       </callout>
!       <callout
!        arearefs="template_programming-template_use-templated_pair_program-constructor">
!        <para>The constructor has two parameters with the type&nbsp;<varname>T</varname>.</para>
!       </callout>
!       <callout
!        arearefs="template_programming-template_use-templated_pair_program-members">
!        <para>An object stores two values having type&nbsp;<varname>T</varname>.</para>
!       </callout>
!       <callout
!        arearefs="template_programming-template_use-templated_pair_program-use">
!        <para>To use a templated class, specify the template
!        parameter's argument after the class's name and surrounded by
!        angle brackets&nbsp;(<statement>&lt;&gt;</statement>).</para>
!       </callout>
!      </calloutlist>
!     </example>
! 
!     <para>Using templates, we can use a template parameter to
!     represent their different uses of types and write one templated
!     class definition.  See <xref
!     linkend="template_programming-template_use-templated_pair_example"></xref>.
!     The templated class definition is a copy of the common portions of
!     the two preceding definitions.  Because the two definitions differ
!     only in their use of the &int; and &double; types, we replace
!     these concrete types with a template
!     parameter&nbsp;<varname>T</varname>.  We
!     <emphasis>precede</emphasis>, not follow, the class definition
!     with <statement>template &lt;typename T&gt;</statement>.  The
!     constructor's parameters' types are changed
!     to&nbsp;<varname>T</varname> as are the data members'
!     types.</para>
! 
!     <para>To use a template class definition, template arguments
!     follow the class name surrounded by angle
!     brackets&nbsp;(<statement>&lt;&gt;</statement>).  For example,
!     <type>pair&lt;int&gt;</type> <glossterm
!     linkend="glossary-template_instantiation"><firstterm>instantiates</firstterm></glossterm>
!     <classname>pair</classname> template class definition with
!     <varname>T</varname> equal to &int;.  That is, the compiler
!     creates a definition for <type>pair&lt;int&gt;</type> by copying
!     <classname>pair</classname>'s template definition and substituting
!     &int; for each occurrence of&nbsp;<varname>T</varname>.  The copy
!     omits the template parameter declaration <statement>template
!     &lt;typename T&gt;</statement> at the beginning of its definition.
!     The result is a definition exactly the same as
!     <classname>pairOfInts</classname>.</para>
  
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+      orient="port" pgwide="0"
+      id="template_programming-template_use-correspondence_table">
+      <title>Correspondences Between Run-Time and Compile-Time
+      Programming Constructs</title>
+      
+      <tgroup cols="3" align="left">
+       <thead>
+        <row>
+ 	<entry></entry>
+ 	<entry>run time</entry>
+ 	<entry>compile time</entry>
+        </row>
+       </thead>
+       <tbody>
+        <row>
+ 	<entry>values</entry>
+ 	<entry>integers, strings, objects, functions, &hellip;</entry>
+ 	<entry>types, &hellip;</entry>
+        </row>
+        <row>
+ 	<entry>create a value to store multiple values</entry>
+ 	<entry>object creation</entry>
+ 	<entry>class definition</entry>
+        </row>
+        <row>
+ 	<entry>values stored in a collection</entry>
+ 	<entry>data member, member function</entry>
+ 	<entry>nested type name, nested class, static member function,
+ 	constant integral values</entry>
+        </row>
+        <row>
+ 	<entry>placeholder for <quote>any particular value</quote></entry>
+ 	<entry>variable, e.g., <quote>any int</quote></entry>
+ 	<entry>template argument, e.g., <quote>any type</quote></entry>
+        </row>
+        <row>
+ 	<entry>repeated operations</entry>
+ 	<entry>A function generalizes a particular operation applied to
+ 	different values.  The function parameters are placeholders
+ 	for particular values.</entry>
+ 	<entry>A template class generalizes a particular class
+ 	definition using different types.  The template parameters are
+ 	placeholders for particular values.</entry>
+        </row>
+        <row>
+ 	<entry>application</entry>
+ 	<entry>Use a function by appending function arguments
+ 	surrounded by parentheses.</entry>
+ 	<entry>Use a template class by appending template arguments
+ 	surrounded by angle brackets&nbsp;(&lt;&gt;).</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <para>As we mentioned above, template instantiation is analogous
+     to function application.  A template class is analogous to a
+     function.  The analogy between compile-time and run-time
+     programming constructs can be extended.  At run time, values used
+     consist of things such as integers, floating point numbers,
+     pointers, functions, and objects.  Programs compute by operating
+     on these values at run time.  At compile time, the values used
+     include types.  Compile-time operations use these types.  &cc;
+     defines default sets of values that all conforming compilers must
+     support.  Object creation extends the set of run-time values,
+     while a class definition extends the set of compile-time types.</para>
+ 
+     <para>Functions generalize similar run-time operations, while
+     template class generalize similar class definitions.  A function
+     definition generalizes a similar run-time operation.  For
+     example, consider repeatedly printing the largest of two numbers:
+ <programlisting>
+ std::cout << (3 &gt; 4 ? 3 : 4) << std::endl;
+ std::cout << (4 &gt; -13 ? 4 : -13) << std::endl;
+ std::cout << (23 &gt; 4 ? 23 : 4) << std::endl;
+ std::cout << (0 &gt; 3 ? 0 : 3) << std::endl;
+ </programlisting>  Each statement is exactly the same except for its
+ two values.  Thus, we can generalize these statements writing a function.
+ <programlisting>
+ void maxOut(int a, int b)
+ { std::cout &openopen; (a > b ? a : b) &openopen; std::endl; }
+ </programlisting>  The function's body consists of a statement with
+ variables substituted for the two particular values.  Each parameter
+ is a placeholder that, when used, holds one particular value among the
+ set of possible integral values.  The function must be named to permit
+ its use, and declarations for its two parameters follow.  Using the
+ function simplifies the code:
+ <programlisting>
+ maxOut(3, 4);
+ maxOut(4, -13);
+ maxOut(23, 4);
+ maxOut(0, 3);
+ </programlisting>  To use a function, the function's name precedes
+     parentheses surrounding specific values for its parameters.  The
+     function's return value does not appear.</para>
+ 
+     <para>A template class definition generalizes similar class
+     definitions.  If two class definitions differ only in a few types,
+     template parameters can be substituted.  Each parameter is a
+     placeholder that, when used, holds one particular value, i.e.,
+     type, among the set of possible values.  The class definition is
+     named to permit its use, and declarations for its parameters
+     precede it.  The example found in the previous section illustrates
+     this transformation.  Compare the original, untemplated classes in
+     <xref
+     linkend="template_programming-template_use-untemplated_pair_example"></xref>
+     with the templated class in <xref
+     linkend="template_programming-template_use-templated_pair_example"></xref>.
+     Note the notation for the template class parameters.
+     <statement>template &lt;typename T&gt;</statement>
+     <emphasis>precedes</emphasis> the class definition.  The keyword
+     <keywordname>typename</keywordname> indicates the template
+     parameter is a type.  <varname>T</varname>&nbsp;is the template
+     parameter's name.  Note that using
+     <keywordname>class</keywordname> is equivalent to using
+     <keywordname>typename</keywordname> so <statement>template
+     &lt;class T&gt;</statement> is equivalent to <statement>template
+     &lt;typename T&gt;</statement>.  Using a templated class requires
+     postfix, not prefix, notation.  The class's name precedes angle
+     brackets&nbsp;(&lt;&gt;) surrounding specific values (types) for
+     its parameters.  As we showed above,
+     <statement>pair&lt;int&gt;</statement> <glossterm
+     linkend="glossary-template_instantiation">instantiates</glossterm>
+     the template class <classname>pair</classname> with &int; for its
+     type parameter&nbsp;<varname>T</varname>.</para>
+ 
+     <para>In template programming, nested type names store
+     compile-time data that can be used within template classes.  Since
+     compile-time class definitions are analogous to run-time objects
+     and the latter stores named values, nested type names are values,
+     i.e., types, stores within class definitions.  For example, the
+     template class &array; has an nested type name for the type of its
+     domain:
+ <programlisting>
+ typedef typename Engine_t::Domain_t Domain_t;
+ </programlisting> This <keywordname>typedef</keywordname>, i.e., type
+     definition, defines the type <type>Domain_t</type> as equivalent
+     to <type>Engine_t::Domain_t</type>.  The <statement>::</statement>
+     operator selects the <type>Domain_t</type> nested type from inside
+     the <type>Engine_t</type> type.  This illustrates how to access
+     &array;'s <type>Domain_t</type> when not within &array;'s scope:
+     <type>Array&lt;Dim, T, EngineTag&gt;::Domain_t</type>.  The
+     analogy between object members and nested type names alludes to
+     its usefulness.  Just as run-time object members store information
+     for later use, nested type names store type information for later
+     use at compile time.  Using nested type names has no impact on the
+     speed of executing programs.</para>
+    </section>
+ 
+ 
+    <section id="template_programming-pooma_implementation">
+     <title>Template Programming Used to Write &pooma;</title>
+ 
+     <para>The preceding section presented template programming tools
+     needed to read this &book; and write programs using the
+     &poomatoolkit;.  In this section, we present template programming
+     techniques used to implement &pooma;.  We extend the
+     correspondence between compile-time template programming
+     constructs and run-time constructs.  Reading this section is not
+     necessary unless you wish to understand how &pooma; works.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+      orient="port" pgwide="0"
+      id="template_programming-pooma_implementation-correspondence_table">
+      <title>More Correspondences Between Compile-Time and Run-Time
+      Programming Constructs</title>
+      
+      <tgroup cols="3" align="left">
+       <thead>
+        <row>
+ 	<entry></entry>
+ 	<entry>run time</entry>
+ 	<entry>compile time</entry>
+        </row>
+       </thead>
+       <tbody>
+        <row>
+ 	<entry>values</entry>
+ 	<entry>integers, strings, objects, functions, &hellip;</entry>
+ 	<entry>types, constant integers and enumerations, &hellip;</entry>
+        </row>
+        <row>
+ 	<entry>control flow to choose among operations</entry>
+ 	<entry><keywordname>if</keywordname>, <keywordname>while</keywordname>, <keywordname>goto</keywordname>, &hellip;</entry>
+ 	<entry>template class specializations with pattern matching</entry>
+        </row>
+        <row>
+ 	<entry>values stored in a collection</entry>
+ 	<entry>An object stores values.</entry>
+ 	<entry>A <glossterm linkend="glossary-traits_class">traits
+ 	class</glossterm> contains values describing a type.</entry>
+        </row>
+        <row>
+ 	<entry></entry>
+ 	<entry></entry>
+ 	<entry></entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+ 
+     <para>
+ 
+ HERE</para>
+    </section>
+ 
+ <!-- HERE -->
+ 
+   </chapter>
+ 
+ 
    &tutorial-chapter;
  
    &concepts-chapter;
  
+   <!-- FIXME: Revert to &data-parallel-chapter; -->
+ 
+   <chapter id="data_parallel">
+    <title>Data-Parallel Expressions</title>
+ 
+    <para>In the previous sections, we accessed container values one at
+    a time.  Accessing more than one value in a container required a
+    writing an explicit loop.  Scientists and engineers commonly
+    operate on sets of values, treated as an aggregate.  For example, a
+    vector is a one-dimension collection of data and two vectors can be
+    added together.  A matrix is a two-dimensional collection of data,
+    and a scalar and a matrix are multiplied.  A <glossterm
+    linkend="glossary-data_parallel"><firstterm>data-parallel
+    expression</firstterm></glossterm> simultaneously uses multiple
+    container values.  &pooma; supports data-parallel syntax.</para>
+ 
+    <para>After introducing data-parallel expressions and statements,
+    we present the corresponding &pooma; syntax.  Then we present its
+    implementation, which uses expression-template technology.  A naive
+    data-parallel implementation might generate temporary variables,
+    cluttering a program's inner loops and slowing its execution.
+    Instead, &pooma; uses &pete, the Portable Expression Template
+    Engine.  Using expression templates, it constructs a parse tree of
+    expressions and corresponding types, which is then quickly
+    evaluated without the need for temporary variables.</para>
+ 
+ 
+    <section id="data_parallel-multiple_values">
+     <title>Expressions with More Than One Container Value</title>
+ 
+     <para>Science and math is filled with aggregated values.  A vector
+     contains several components, and a matrix is a two-dimensional
+     object.  Operations on individual values are frequently extended
+     to operations on these aggregated values.  For example, two
+     vectors having the same length are added by adding corresponding
+     components.  The product of two matrices is defined in terms of
+     sums and products on its components.  The sine of an array is an
+     array containing the sine of every value in it.</para>
+ 
+     <para>A <glossterm
+     linkend="glossary-data_parallel"><firstterm>data-parallel
+     expression</firstterm></glossterm> simultaneously refers to
+     multiple container values.  Data-parallel statements, i.e.,
+     statements using data-parallel expressions, frequently occur in
+     scientific programs.  For example, the sum of two vectors v and w
+     is written as v+w.  Algorithms frequently use data-parallel
+     syntax.  Consider, for example, computing the total energy&nbsp;E
+     as the sum of kinetic energy&nbsp;K and potential energy&nbsp;U.
+     For a simple particle subject to the earth's gravity, the kinetic
+     energy&nbsp;K equals mv<superscript>2</superscript>/2, and the
+     potential energy&nbsp;U equals mgh.  These formulae apply to both
+     an individual particle with a particular mass&nbsp;m and
+     height&nbsp;h and to an entire field of particles with
+     masses&nbsp;m and heights&nbsp;h.  Our algorithm works with
+     data-parallel syntax, and we would like to write the corresponding
+     computer program using data-parallel syntax as well..</para>
+    </section>
+ 
+ 
+    <section id="data_parallel-use">
+     <title>Their Use</title>
+ 
+     <para>&pooma; containers can be used in data-parallel expressions
+     and statements.  The basic guidelines are simple:
+     <itemizedlist>
+      <listitem>
+        <para>The &cc; built-in and mathematical operators operate on
+        an entire container by operating element-wise on its values.</para>
+      </listitem>
+      <listitem>
+       <para>Binary operators operate only on containers with the same
+       domain types by combining values with the same indices.  If the
+       result is a container, it has a domain equal to the left operand's
+       domain.</para>
+      </listitem>
+      <listitem>
+       <para>For assignment operators, the domains of the left
+       operand and the right operand must have the same type and
+       be conformable, i.e., have the <quote>same shape</quote>.</para>
+      </listitem>
+     </itemizedlist>
+     </para>
+ 
+     <para>The operators operate element-wise on containers' values.
+     For example, if <varname>A</varname> is a one-dimensional array,
+     <statement>-<varname>A</varname></statement> is a one-dimensional
+     array with the same size such that the value at the
+     i<superscript>th</superscript> position equals -A(i).  If
+     <varname>A</varname> and <varname>B</varname> are two-dimensional
+     &array;s on the same domain,
+     <statement><varname>A</varname>+<varname>B</varname></statement>
+     is an array on the same domain with values equaling the sum of
+     corresponding values in <varname>A</varname> and
+     <varname>B</varname>.</para>
+ 
+     <figure float="1" id="data_parallel-use-addition_example">
+      <title>Adding &array;s with Different Domains</title>
+      <mediaobject>
+       <imageobject>
+        <imagedata fileref="figures/data-parallel.212" format="EPS" align="center"></imagedata>
+       </imageobject>
+       <textobject>
+        <phrase>Adding two arrays with different domains adds values
+        with the same indices.</phrase>
+       </textobject>
+       <caption>
+        <para>Adding &array;s with different domains is supported.
+        Solid lines indicate the domains' extent.  Values with the same
+        indices are added.</para>
+       </caption>
+      </mediaobject>
+     </figure>
+ 
+     <para>Binary operators operate on containers with the same domain
+     types.  The domain's indices need not be the same, but the result
+     will have a domain equal to the left operand.  For example, the
+     sum of an &array;&nbsp;<varname>A</varname> with a one-dimensional
+     interval&nbsp;[0,3] and an &array;&nbsp;<varname>B</varname> with
+     a one-dimensional interval&nbsp;[1,2] is well-defined because both
+     domains are one-dimensional intervals.  The result is an &array;
+     with a one-dimensional interval&nbsp;[0,3].  Its first and last
+     entries equal <varname>A</varname>'s first and last entries, while
+     its middle two entries are the sums
+     <statement>A(1)+B(1)</statement> and
+     <statement>A(2)+B(2)</statement>.  We assume zero is the
+     default value for the type of values stored
+     in&nbsp;<varname>B</varname>.  A more complicated example of
+     adding two &array;s with different domains is illustrated in <xref
+     linkend="data_parallel-use-addition_example"></xref>.  Code for
+     these &array;s could be
+ <programlisting>
+ Interval<1> H(0,2), I(1,3), J(2,4);
+ Array<2, double, Brick> A(I,I), B(J,H);
+ // ... fill A and B with values ...
+ ... = A + B;
+ </programlisting>Both <varname>A</varname> and
+     <varname>B</varname> have domains of two-dimensional intervals so
+     they may be added, but their domains' extent differ, as indicated
+     by the solid lines in the figure.  The sum has domain equal to the
+     left operand's domain.  Values with the same indices are added.  For
+     example, <statement>A(2,2)</statement> and
+     <statement>B(2,2)</statement> are added.  <varname>B</varname>'s
+     domain does not include index (1,1) so, when adding
+     <statement>A(1,1)</statement> and <statement>B(1,1)</statement>,
+     the default value for <varname>B</varname>'s value type is used.
+     Usually this is&nbsp;0.  Thus, <statement>A(1,1) +
+     B(1,1)</statement> equals <statement>9 + 0</statement>.</para>
+ 
+     <para>Operations with &array;s and scalar values are supported.
+     Conceptually, a scalar value can be thought of as an &array; with
+     any desired domain and having the same value everywhere.  For
+     example, consider
+ <programlisting>
+ Array<1, double, Brick> D(Interval<1>(7,10));
+ D += 2*D + 7;
+ </programlisting><statement>2*D</statement> obeys the guidelines
+     because the scalar <statement>2</statement> can be thought of as
+     an array with the same domain as <varname>D</varname>.  It has the
+     same value <statement>2</statement> everywhere.  Likewise the
+     conceptual domain for the scalar <statement>7</statement> is the
+     same as <statement>2*D</statement>'s domain.  Thus,
+     <statement>2*D(i) + 7</statement> is added to
+     <statement>D(i)</statement> wherever index&nbsp;i is in
+     <varname>D</varname>'s domain.  In practice, the &toolkit; does
+     not first convert scalar values to arrays but instead uses them
+     directly in expressions.</para>
+ 
+     <para>Assignment to containers is also supported.  The domain
+     types of the assignment's left-hand side and its right-hand side
+     must be the same.  Their indices need not be the same, but they
+     must correspond.  That is, the domains must be <glossterm
+     linkend="glossary-conformable_domains"><firstterm>conformable
+     domains</firstterm></glossterm>, or have the <quote>same
+     shape</quote>, i.e., have the same number of indices for each
+     dimension.  For example, the one-dimensional interval [0,3] is
+     conformable to the one-dimensional interval [1,4] because they
+     both have the same number of indices in each dimension.  The
+     domains of <varname>A</varname> and <varname>B</varname>, as
+     declared
+ <programlisting>
+ Interval<1> H(0,2), I(1,3), J(2,4), K(0,4);
+ Array<2, double, Brick> A(I,I), B(H,J), C(I,K);
+ </programlisting> are conformable because each dimension has the same
+     number of indices.  <varname>A</varname> and <varname>C</varname>
+     are not conformable because, while their first dimensions are
+     conformable, their second dimensions are not conformable.  It has
+     three indices while the other has four.  We define <glossterm
+     linkend="glossary-conformable_containers"><firstterm>conformable
+     containers</firstterm></glossterm> to be containers with
+     conformable domains.</para>
+ 
+     <para>When assigning to a container, corresponding container
+     values are assigned.  (Since the left-hand side and the right-hand
+     side are conformable, corresponding values exist.)  In this code
+     fragment,
+ <programlisting>
+ Array<1, double, Brick> A(Interval<1>(0,1));
+ Array<1, double, Brick> B(Interval<1>(1,2));
+ A = B;
+ </programlisting> <statement>A(0)</statement> is assigned
+     <statement>B(1)</statement> and <statement>A(1)</statement> is
+     assigned <statement>B(2)</statement>.</para>
+ 
+     <para>Assigning a scalar value to an &array; also is supported,
+     but assigning an &array; to a scalar is not.  A scalar value is
+     conformable to any domain because, conceptually it can be viewed
+     as an &array; with any desired domain and having the same value
+     everywhere.  Thus, the assignment <statement>B = 3</statement>
+     ensures every value in <varname>B</varname> equals&nbsp;3.  Even
+     though a scalar value is conformable to any &array;, it is not an
+     l-value so it cannot appear on the left-hand side of an
+     assignment.</para>
+ 
+     <para>Data-parallel expressions can involve typical mathematical
+     functions and output operations.  For example,
+     <statement>sin(A)</statement> yields an &array; with values equal
+     to the sine of each of &array; <varname>A</varname>'s values.
+     <statement>dot(A,B)</statement> has values equaling the dot
+     product of corresponding values in &array;s <varname>A</varname>
+     and <varname>B</varname>.  The contents of an entire &array; can
+     be easily printed to standard output.  For example, the program
+ <programlisting>
+ Array<1, double, Brick> A(Interval<1>(0,2));
+ Array<1, double, Brick> B(Interval<1>(1,3));
+ A = 1.0;
+ B = 2.0;
+ std::cout << A-B << std::endl;
+ </programlisting> yields
+     <computeroutput>
+     (000:002:001) = 1 -1 -1</computeroutput>.  The initial
+     <computeroutput>(000:002:001)</computeroutput> indicates the
+     &array;'s domain ranges from 0 to 2 with a stride of&nbsp;1.  The
+     three values in <statement>A-B</statement> follow.</para>
+ 
+     <para>So far, all of the above examples illustrating data-parallel
+     expressions and statements operate on all of a container's values.
+     Frequently, operating on a subset is useful.  In &pooma;, a subset
+     of a container's values is called a view.  Combining views and
+     data-parallel expressions will enable us to more succinctly and more
+     easily write the diffusion program.  Views are discussed in the
+     next chapter.</para>
+ 
+ <!-- HERE -->
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0">
+      <title>Operators Permissible for Data-Parallel Expressions</title>
+      
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry></entry>
+ 	<entry>supported operators</entry>
+        </row>
+       </thead>
+       <tbody>
+        <row>
+ 	<entry>unary operators</entry>
+ 	<entry>+, -, ~, !
+ HERE</entry>
+        </row>
+        <row>
+ 	<entry>binary operators</entry>
+ 	<entry>+, -, *, /, %, &, |, ^
+ HERE</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0">
+       <title>Mathematical Operators Permissible for Data-Parallel Expressions</title>
+       
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>function</entry>
+ 	 <entry>effect</entry>
+ 	</row>
+        </thead>
+       <tfoot>
+        <row>
+ 	<entry>Every effort has been made to present accurate
+         information, but restrictions caused by the underlying
+         functions may further restriction the data-parallel
+         functions.</entry>
+        </row>
+       </tfoot>
+        <tbody>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; peteCast (const T1&amp;, const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the casting of the array's values to type <type>T1</type>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	<entry>Multiplies <varname>A</varname>'s values by the
+ 	corresponding integral power of two in&nbsp;<varname>B</varname>.</entry>
+        </row>
+ <!-- HERE Reorder the above to be more sensible and add headings. -->
+        <row rowsep="1">
+ 	<entry>Trigonometric and Hyperbolic Operators</entry>
+ 	<entry><statement>#include &lt;math.h&gt;</statement></entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; cos (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the cosines of the array's values.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; sin (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the sines of the array's values.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; tan (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the tangents of the array's values.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; acos (const Array&lt;T1&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the arc cosines of the array's values.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; asin (const Array&lt;T1&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the arc sines of the array's values.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; atan (const Array&lt;T1&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the arc tangents of the array's values.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; cosh (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the hyperbolic cosines of the array's values.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; sinh (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the hyperbolic sines of the array's values.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; tanh (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the hyperbolic tangents of the array's values.</entry>
+        </row>
+        <row rowsep="1">
+ 	<entry>Absolute Value and Rounding Operators</entry>
+ 	<entry><statement>#include &lt;math.h&gt;</statement></entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; fabs (const Array&lt;T1&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the absolute values of the floating point
+ 	numbers in the array.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)</statement></entry>
+ 	<entry>For each of the array's values, return the integer
+ 	larger than or equal to it (as a floating point number).</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)</statement></entry>
+ 	<entry>For each of the array's values, return the integer
+ 	larger than or equal to it (as a floating point number).</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; floor (const Array&lt;T1&gt;&amp; A)</statement></entry>
+ 	<entry>For each of the array's values, return the integer
+ 	smaller than or equal to it (as a floating point number).</entry>
+        </row>
+        <row rowsep="1">
+ 	<entry>Powers, Exponentiation, and Logarithmic Operators</entry>
+ 	<entry><statement>#include &lt;math.h&gt;</statement></entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; PETE_identity (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the array.  That is, it applies the identity operation.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; sqrt (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the square roots of the array's values.</entry>
+        </row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; pow2 (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns the squares of <varname>A</varname>'s values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; pow3 (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns the cubes of <varname>A</varname>'s values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; pow4 (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns the fourth powers of <varname>A</varname>'s values.</entry>
+ 	</row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; exp (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the exponentiations of the array's values.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; log (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the natural logarithms of the array's values.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;T&gt; log10 (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the base-10 logarithms of the array's values.</entry>
+        </row>
+        <row rowsep="1">
+ 	<entry>Operators Involving Complex Numbers</entry>
+ 	<entry><statement>#include &lt;complex&gt;</statement></entry>
+        </row>
+        <row>
+ 	 <entry><statement>Array&lt;T&gt; real (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
+ 	 <entry>Returns the real parts of <varname>A</varname>'s complex numbers.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; imag (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
+ 	 <entry>Returns the imaginary parts of <varname>A</varname>'s complex numbers.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; abs (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
+ 	<entry>Returns the absolute values (magnitudes) of
+ 	<varname>A</varname>'s complex numbers.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; abs (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the absolute values of <varname>A</varname>'s values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; arg (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
+ 	 <entry>Returns the angle representations (in radians) of the
+ 	 polar representations of <varname>A</varname>'s complex
+ 	 numbers.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; norm (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
+ 	 <entry>Returns the squared absolute values of
+ 	 <varname>A</varname>'s complex numbers.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;complex&lt;T&closeclose; conj (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
+ 	 <entry>Returns the complex conjugates of
+ 	 <varname>A</varname>'s complex numbers.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns the complex numbers created from polar
+ 	 coordinates (magnitudes and phase angles) in corresponding
+ 	 arrays.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;complex&lt;T&closeclose; polar (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns the complex numbers created from polar
+ 	 coordinates with magnitude&nbsp;<varname>l</varname> and
+ 	 phase angles in the array.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	 <entry>Returns the complex numbers created from polar
+ 	 coordinates with magnitudes in the array and phase
+ 	 angle&nbsp;<varname>r</varname>.</entry>
+ 	</row>
+         <row rowsep="1">
+ 	 <entry>Operators Involving Matrices and Tensors</entry>
+ 	 <entry><statement>#include "Pooma/Tiny.h"</statement></entry>
+         </row>
+ 	<row>
+ 	 <entry><statement>T trace (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns the sum of the <varname>A</varname>'s diagonal
+ 	 entries, viewed as a matrix.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>T det (const Array&lt;T&gt;&amp; A)</statement></entry>
+          <entry>Returns the determinant of <varname>A</varname>, viewed as a matrix.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; transpose (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns the transpose of <varname>A</varname>, viewed as a matrix.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; symmetrize (const Array&lt;T&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns the tensors of <varname>A</varname> with the
+ 	 requested output symmetry.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns the dot products of values in the two arrays.
+ 	 Value type <type>T</type> equals the type of the
+ 	 <function>dot</function> operating on <type>T1</type>
+ 	 and <type>T2</type>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	 <entry>Returns the dot products of values in the array
+ 	 with&nbsp;<varname>r</varname>.
+ 	 Value type <type>T</type> equals the type of the
+ 	 <function>dot</function> operating on <type>T1</type>
+ 	 and <type>T2</type>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; dot (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns the dot products of <varname>l</varname> with
+ 	 values in the array.  Value type <type>T</type> equals the type of the
+ 	 <function>dot</function> operating on <type>T1</type>
+ 	 and <type>T2</type>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; B)</statement></entry>
+ 	 <entry>Returns the dot products of values in the array
+ 	 Value type <type>T</type> equals the type of the
+ 	 <function>dot</function> operating on <type>T1</type>
+ 	 and <type>T2</type>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns tensors created by computing the outer product
+ 	 of corresponding vectors in the two arrays.  Value
+ 	 type&nbsp;<type>T</type> equals the type of the product of
+ 	 <type>T1</type> and <type>T2</type>.  The vectors
+ 	 must have the same length.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns tensors created by computing the outer product
+ 	 of <varname>l</varname> with the vectors in the array.  Value
+ 	 type&nbsp;<type>T</type> equals the type of the product of
+ 	 <type>T1</type> and <type>T2</type>.  The vectors
+ 	 must have the same length.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	 <entry>Returns tensors created by computing the outer product
+ 	 of vectors in the array with&nbsp;<varname>r</varname>.  Value
+ 	 type&nbsp;<type>T</type> equals the type of the product of
+ 	 <type>T1</type> and <type>T2</type>.  The vectors
+ 	 must have the same length.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const Array&lt;T1&gt;&amp; A, const
+ 	 Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns matrices created by computing the outer product
+ 	 of corresponding vectors in the two arrays.  Value
+ 	 type&nbsp;<type>T</type> equals the type of the product of
+ 	 <type>T1</type> and <type>T2</type>.  The vectors must have
+ 	 the same length.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const T1&amp; l, const
+ 	 Array&lt;T2&gt;&amp; A)</statement></entry>
+          <entry>Returns matrices created by computing the outer
+ 	 product of <varname>l</varname> with the vectors in the array.  Value
+ 	 type&nbsp;<type>T</type> equals the type of the product of
+ 	 <type>T1</type> and <type>T2</type>.  The vectors must
+ 	 have the same length.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const
+ 	 Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+          <entry>Returns matrices created by computing the outer
+ 	 product of the vectors in the array
+ 	 with&nbsp;<varname>r</varname>.  Value
+ 	 type&nbsp;<type>T</type> equals the type of the product of
+ 	 <type>T1</type> and <type>T2</type>.  The vectors must
+ 	 have the same length.</entry>
+ 	</row>
+         <row rowsep="1">
+ 	 <entry>Comparison Operators</entry>
+         </row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns the maximum of corresponding array values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; max (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the maximums of <varname>l</varname> with the array's values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	<entry>Returns the maximums of the array's values with&nbsp;<varname>r</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns the minimum of corresponding array values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; min (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	<entry>Returns the minimums of <varname>l</varname> with the array's values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	<entry>Returns the minimums of the array's values with&nbsp;<varname>r</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns booleans from using the less-than
+ 	 operator&nbsp;&lt; to compare corresponding array values in
+ 	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; LT (const T1&amp; r, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns booleans from using the less-than
+ 	 operator&nbsp;&lt; to compare <varname>l</varname> with the array's
+ 	 values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	 <entry>Returns booleans from using the less-than
+ 	 operator&nbsp;&lt; to compare the array's
+ 	 values with&nbsp;<varname>r</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns booleans from using the less-than-or-equal
+ 	 operator&nbsp;&le; to compare array values in
+ 	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; LE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns booleans from using the less-than-or-equal
+ 	 operator&nbsp;&le; to compare <varname>l</varname> with the array's values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	 <entry>Returns booleans from using the less-than-or-equal
+ 	 operator&nbsp;&le; to compare the array's values
+ 	 with&nbsp;<varname>r</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns booleans from using the greater-than-or-equal
+ 	 operator&nbsp;&ge; to compare array values in
+ 	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; GE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns booleans from using the greater-than-or-equal
+ 	 operator&nbsp;&ge; to compare <varname>l</varname> with the array's values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	 <entry>Returns booleans from using the greater-than-or-equal
+ 	 operator&nbsp;&ge; to compare the array's values with&nbsp;<varname>r</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns booleans from using the greater-than
+ 	 operator&nbsp;&gt; to compare array values in
+ 	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; GT (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns booleans from using the greater-than
+ 	 operator&nbsp;&gt; to compare <varname>l</varname> with the array's values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	 <entry>Returns booleans from using the greater-than
+ 	 operator&nbsp;&gt; to compare the array's values with&nbsp;<varname>r</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns booleans from determining whether
+ 	 corresponding array values in <varname>A</varname> and
+ 	 <varname>B</varname> are equal.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; EQ (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns booleans from determining whether
+ 	 <varname>l</varname> equals the array's values..</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	 <entry>Returns booleans from determining whether the array's values equal&nbsp;<varname>r</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
+ 	 <entry>Returns booleans from determining whether
+ 	 corresponding array values in <varname>A</varname> and
+ 	 <varname>B</varname> are not equal.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; NE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
+ 	 <entry>Returns booleans from determining whether
+ 	 <varname>l</varname> does not equal the array's values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
+ 	 <entry>Returns booleans from determining whether the 
+ 	 array's values are not equal to&nbsp;<varname>r</varname>.</entry>
+ 	</row>
+ <!-- FIXME: Add dotdot from src/Array/PoomaArrayOperators.h if it is defined. -->
+        </tbody>
+       </tgroup>
+      </table>
+ 
+ <para>We need to explain that proper types must be chosen.  For
+ example, cos on complex and double works but ceil on complex does not.
+ HERE</para>
+ 
+ 
+ <!-- HERE -->
+ 
+    </section>
+ 
+ 
+    <section id="data_parallel-implementation">
+     <title>Implementation of Data-Parallel Statements</title>
+ 
+     <para>Data-parallel statements involving containers occur
+     frequently in the inner loops of scientific programs so their
+     efficient execution is important.  A naive implementation for
+     these statements may create and destroy containers holding
+     intermediate values, slowing execution considerably.
+     In&nbsp;1995, Todd <!-- FIXME: Add citations to vandevoorde-95 and
+     veldhuizen-95. --> Veldhuizen and David Vandevoorde developed an
+     expression-template technique to transform arithmetic expressions
+     involving array-like containers into efficient loops without using
+     temporaries.  Despite its perceived complexity, &pooma;
+     incorporated the technology.  The framework called &pete, the
+     <application>Portable Expression Template Engine</application>
+     framework, is also available separately from &pooma; at
+     <ulink url="http://www.acl.lanl.gov/pete/"></ulink>.</para>
+ 
+     <para>In this section, we first describe how a naive
+     implementation may slow execution.  Then, we describe &pete;'s
+     faster implementation.  A data-parallel statement is converted
+     into a parse tree, rather than immediately evaluating it.  The
+     parse tree has two representations.  Its run-time representation
+     holds run-time values.  Its compile-time representation records
+     the types of the tree's values.  After a parse tree for the entire
+     statement is constructed, it is evaluated.  Since it is a
+     data-parallel statement, this evaluation involves at least one
+     loop.  At run time, each loop iteration, the value of one
+     container value is computed and assigned.  At compile time, when
+     the code for the loop iteration is produced, the parse tree's
+     types are traversed and code is produced without the need for any
+     intermediate values.  We present the implementation in <xref
+     linkend="data_parallel-implementation-pete"></xref>, but first we
+     explain the difficulties caused by the naive implementation.</para>
+ 
+     <section id="data_parallel-implementation-naive">
+      <title>Naive Implementation</title>
+ 
+      <para>A conventional implementation to evaluate data-parallel
+      expressions might overload arithmetic operator functions.
+      Consider this program fragment:
+ <programlisting>
+ Interval<1> I(0,3);
+ Array<1, double, Brick> A(I), B(I);
+ A = 1.0;
+ B = 2.0;
+ A += -A + 2*B;
+ std::cout << A << std::endl;
+ </programlisting> Our goal is to transform the data-parallel
+      statement <statement>A += -A + 2*B</statement> into a single
+      loop, preferably without intermediary containers.  To simplify
+      notation, let <type>Ar</type> abbreviate the type
+      <type>Array&lt;1, double, Brick&gt;</type>.</para>
+      
+      <para>Using overloaded arithmetic operators would require using
+      intermediate containers to evaluate the statement.  For example,
+      <!-- FIXME: What is the proper tag for an inline function
+      prototype? --> the sum's left operand <statement>-A</statement>
+      would be computed by the overloaded unary operator <statement>Ar
+      operator-(const Ar&amp;)</statement>, which would produce an
+      intermediate &array;.  <statement>Ar operator*(double,
+      const Ar&amp;)</statement> would produce another intermediate
+      &array; holding <statement>2*B</statement>.  Yet another
+      intermediate container would hold their sum, all before
+      performing the assignment.  Thus, three intermediate containers
+      would be created and destroyed.  Below, we show these are
+      unnecessary.</para>
+     </section>
+ 
+     <section id="data_parallel-implementation-pete">
+      <title>Portable Expression Template Engine</title>
+ 
+      <para>&pooma; uses &pete;, the <application>Portable Expression
+      Template Engine</application> framework, to evaluate
+      data-parallel statements using efficient loops without
+      intermediate values.  &pete; uses expression-template technology.
+      Instead of aggressively evaluating a data-parallel statement's
+      subexpressions, it defers evaluation, instead building a parse
+      tree of the required computations.  The parse tree's type records
+      the types of each of its subtrees.  Then, the parse tree is
+      evaluated using an evaluator determined by the left-hand side's
+      type.  This container type determines how to loop through its
+      domain.  Each loop iteration, the corresponding value of the
+      right-hand side is evaluated.  No intermediate loops or temporary
+      values are needed.</para>
+ 
+      <figure float="1" id="data_parallel-implementation-pete-tree_figure">
+       <title>Annotated Parse Tree for <statement>-A + 2*B</statement></title>
+       <mediaobject>
+        <imageobject>
+ 	<imagedata fileref="figures/data-parallel.101" format="EPS" align="center"></imagedata>
+        </imageobject>
+        <textobject>
+ 	<phrase>A parse tree for the statement is produced.</phrase>
+        </textobject>
+        <caption>
+ 	<para>The parse tree for <statement>-A + 2*B</statement> with
+         type annotations.  The complete type of a node equals the
+         concatenation of the preorder traversal of annotated types.</para>
+        </caption>
+       </mediaobject>
+      </figure>
+ 
+      <para>Before explaining the implementation, let us illustrate
+      using our example statement <statement>A += -A + 2*B</statement>.
+      Evaluating the right-hand side creates a parse tree similar to
+      the one in <xref
+      linkend="data_parallel-implementation-pete-tree_figure"></xref>.
+      For example, the overloaded unary minus operator yields a tree
+      node representing <statement>-A</statement>, having a unary-minus
+      function object, and having type
+      <type>Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;</type>.
+      The binary nodes continue the construction process yielding a
+      parse tree object for the entire right-hand side and having type
+      <type>Expression&lt;BinaryNode&lt;OpAdd, UnaryNode&lt;OpMinus,
+      Ar&gt;,
+      BinaryNode&lt;OpMultiply&lt;Scalar&lt;int&gt;,Ar&closeclose;&hairsp;&gt;</type>.
+      Evaluating the left-hand side yields an object
+      representing&nbsp;<varname>A</varname>.</para>
+ 
+      <para>Finally, the assignment operator <statement>+=</statement>
+      calls the <function>evaluate</function> function corresponding to
+      the left-hand side's type.  At compile time, it produces the code
+      for the computation.  Since this templated function is
+      specialized on the type of the left-hand side, it generates a
+      loop through the left-hand side's container.  In the loop body,
+      the <function>forEach</function> function produces code for the
+      right-hand side expression at a specific position using a
+      post-order parse-tree traversal.  At a leaf, this evaluation
+      queries the leaf's container for a specified value or extracts a
+      scalar value.  At an interior node, its children's results are
+      combined using its function operator.  One loop performs the
+      entire assignment.  It is important to note that the type of the
+      entire right-hand side is known at compile time.  Thus, all of
+      these <function>evaluate</function>,
+      <function>forEach</function>, and function operator function
+      calls can be inlined at compile time to yield simple code without
+      any temporary containers and hopefully as fast as hand-written
+      loops!</para>
+ 
+      <para>To implement this scheme, we need &pooma; code to both
+      create the parse tree and to evaluate it.  We describe parse tree
+      creation first.  Parse trees consist of leaves,
+      <type>UnaryNode</type>s, <type>BinaryNode</type>s, and
+      <type>TrinaryNode</type>s.  Since <type>TrinaryNode</type>s are
+      similar to <type>BinaryNode</type>s, we omit describing them.  A
+      <type>BinaryNode</type>'s three template parameters correspond to
+      the three things it must store:
+      <variablelist>
+        <varlistentry>
+ 	<term><statement>Op</statement></term>
+ 	<listitem>
+ 	 <para>the type of the node's operation.  For example, the
+ 	 <type>OpAdd</type> type represents adding two operands
+ 	 together.</para>
+ 	</listitem>
+        </varlistentry>
+        <varlistentry>
+ 	<term><statement>Left</statement></term>
+ 	<listitem>
+ 	 <para>the type of the left child.</para>
+ 	</listitem>
+        </varlistentry>
+        <varlistentry>
+ 	<term><statement>Right</statement></term>
+ 	<listitem>
+ 	 <para>the type of the right child.</para>
+ 	</listitem>
+        </varlistentry>
+       </variablelist>
+     The node stores the left and right children's nodes.</para>
+ 
+     <para><type>BinaryNode</type> does not need to store any
+     representation of the node's operation.  Instead the
+     <type>Op</type> type is an empty structure declaring a function
+     object.  For example, <type>OpAdd</type>'s function object is
+     declared as
+ <programlisting>
+ template&lt;class T1, class T2&gt;
+ inline typename BinaryReturn&lt;T1, T2, OpAdd&gt;::Type_t
+ operator()(const T1 &amp;a, const T2 &amp;b) const
+ {
+   return (a + b);
+ }
+ </programlisting>  Since it has two template arguments, it can be
+     applied to operands of any type.  Because of &cc; type
+     conversions, the type of the result is determined using the
+     <type>BinaryReturn</type> traits class.  Consider adding an &int;
+     and a &double;.  <type>BinaryReturn&lt;int, double,
+     OpAdd&gt;::Type_t</type> equals &double;.  Inlining the function
+     ensures all this syntax is eliminated, leaving behind just an
+     addition.</para>
+ 
+     <para><type>UnaryNode</type>s are similar but have only two
+     template parameters and store only one child.</para>
+ 
+      <para>Parse tree leaves are created by the
+      <type>CreateLeaf</type> class and its specializations.  The
+      default leaf is a scalar so it has the most general definition:
+ <programlisting>
+ template&lt;class T&gt;
+ struct CreateLeaf
+ {
+   typedef Scalar&lt;T&gt; Leaf_t;
+ 
+   inline static
+   Leaf_t make(const T &amp;a)
+   {
+     return Scalar&lt;T&gt;(a);
+   }
+ };
+ </programlisting> The <type>Scalar</type> class stores the scalar
+     value.  The <type>CreateLeaf</type>'s <type>Leaf_t</type> type
+     indicates its type.  The <statement>static</statement>
+     <function>make</function> function is invoked by an overloaded
+     operator function when creating its children.</para>
+ 
+     <para>The <type>CreateLeaf</type> class is specialized for &array;s:
+ <programlisting>
+ template&lt;int Dim, class T, class EngineTag&gt;
+ struct CreateLeaf&lt;Array&lt;Dim, T, EngineTag&gt; &gt;
+ {
+   typedef Array&lt;Dim, T, EngineTag&gt; Input_t;
+   typedef Reference&lt;Input_t&gt; Leaf_t;
+   typedef Leaf_t Return_t;
+   inline static
+   Return_t make(const Input_t &amp;a)
+     {
+       return Leaf_t(a);
+     }
+ };
+ </programlisting>  The &array; object is stored as a
+     <type>Reference</type>, rather than directly as for scalars.</para>
+ 
+     <para>To simplify the next step of overloading arithmetic
+     operators, a parse tree's topmost type is an
+     <type>Expression</type>.</para>
+ 
+     <para>Now that we have defined the node classes, the &cc;
+     arithmetic operators must be overloaded to return the appropriate
+     parse tree.  For example, unary minus operator
+     <function>operator-</function> overloaded to accept an &array;
+     argument should create a <type>UnaryNode</type> having an &array;
+     as its child, which will be a leaf:
+ <programlisting>
+ template&lt;int D1,class T1,class E1&gt;
+ inline typename MakeReturn&lt;UnaryNode&lt;OpUnaryMinus,
+   typename CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::Leaf_t&gt; &gt;::Expression_t
+ operator-(const Array&lt;D1,T1,E1&gt; &amp; l)
+ {
+   typedef UnaryNode&lt;OpUnaryMinus,
+     typename CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::Leaf_t&gt; Tree_t;
+   return MakeReturn&lt;Tree_t&gt;::make(Tree_t(
+     CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::make(l)));
+ }
+ </programlisting>  <type>Tree_t</type> specifies the node's unique
+     type.  Constructing the object first involves creating a leaf
+     containing the &array; reference through the call to
+     <function>CreateLeaf&lt;Array&lt;D1,T1,E1&gt;
+     &gt;::make</function>.  The call to
+     <function>MakeReturn&lt;Tree_t&gt;::make</function> permits
+     programmers to store trees in different formats.  The &pooma;
+     implementation stores them as <type>Expression</type>s.  The
+     function's return type is similar to the
+     <statement>return</statement> statement except it extracts the
+     type from <type>Expression</type>'s internal
+     <type>Expression_t</type> type.</para>
+ 
+     <para>Specialized all the operators for &array;s using such
+     complicated is likely to be error-prone so &pete; provides a way
+     to automate it.  Using its <command>MakeOperators</command>
+     command with this input:
+ <programlisting>
+ classes
+ -----
+   ARG   = "int D[n],class T[n],class E[n]"
+   CLASS = "Array&lt;D[n],T[n],E[n]&gt;"
+ </programlisting> automatically generates code for all the needed operators.
+     The <quote>[n]</quote> strings are used to number arguments for binary
+     and ternary operators.</para>
+ 
+     <para>Assignment operators must also be specialized for &array;.
+     Inside the &array; class definition, each such operator just
+     invokes the <function>assign</function> function with a corresponding
+     function object.  For example, <function>operator+=</function>
+     invokes <statement>assign(*this, rhs, OpAddAssign())</statement>.
+     <varname>rhs</varname> is the parse tree object for the right-hand
+     side.  Calling this function invokes
+     <function>evaluate</function>, which begins the evaluation.</para>
+ 
+     <para>Before we explain the evaluation, let us summarize the
+     effect of the code so far described.  If we are considering run
+     time, parse trees for the left-hand and right-hand sides have been
+     constructed.  If we are considering compile time, the types of
+     these parse trees are known.  At compile time, the
+     <function>evaluate</function> function described below will
+     generate a loop through the left-hand side container's domain.
+     The loop's body will have code computing a container's value.  At
+     run time, this code will read values from containers, but the
+     run-time parse tree object itself will not traversed!</para>
+ 
+     <para>We now explore the evaluation, concentrating on compile
+     time, not run time.  <function>evaluate</function> is an
+     overloaded function specialized on the type of the left-hand side.
+     In our example, the left-hand side is a one-dimensional &array;,
+     so <function>evaluate(const Ar&amp; a, const Op&amp; op, const
+     RHS&amp; rhs)</function> is inlined into a loop like
+ <programlisting>
+ int end = a's domain[0].first() + a's domain[0].length();
+ for (int i = a's domain[0].first(); i < end; ++i)
+   op(a(i), rhs.read(i));
+ </programlisting>  <varname>a</varname> is the array,
+     <varname>op</varname> is a function object representing the
+     assignment operation, and <varname>rhs</varname> is the right-hand
+     side's parse tree.</para>
+ 
+     <para>Evaluating <statement>rhs.read(i)</statement> inlines into a
+     call to the <function>forEach</function> function.  This function
+     performs a <emphasis>compile-time</emphasis> post-order parse-tree
+     traversal.  Its general form is
+ <programlisting>
+ forEach(const Expression&amp; e, const LeafTag&amp; f, const CombineTag&amp; c).
+ </programlisting> That is, it traverses the nodes of the
+     <type>Expression</type> object&nbsp;<varname>e</varname>.  At
+     leaves, it applies the operation specified by
+     <type>LeafTag</type>&nbsp;<varname>f</varname>.  At interior
+     nodes, it combines the results using the <type>CombineTag</type>
+     operator&nbsp;<varname>c</varname>.  It inlines into a call to
+ <programlisting>
+     ForEach&lt;Expression, LeafTag, CombineTag&gt;::apply(e, f, c).
+ </programlisting>  The <function>apply</function> function continues
+     the traversal through the tree.  For our example,
+     <type>LeafTag</type> equals <type>EvalLeaf&lt;1&gt;</type>, and
+     <type>CombineTag</type> equals <type>OpCombine</type>.  The former
+     indicates that, when reaching a leaf, the leaf should be a
+     one-dimensional container which should be evaluated
+     at the position stored in the <type>EvalLeaf</type> object.  The
+     <type>OpCombine</type> class applies an interior node's
+     <type>Op</type> to the results of its children.</para>
+ 
+     <para><type>ForEach</type> structures are specialized for the
+     various node types.  For example, the specialization for
+     <type>UnaryNode</type> is
+ <programlisting>
+ template&lt;class Op, class A, class FTag, class CTag&gt;
+ struct ForEach&lt;UnaryNode&lt;Op, A&gt;, FTag, CTag&gt;
+ {
+   typedef typename ForEach&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
+   typedef typename Combine1&lt;TypeA_t, Op, CTag&gt;::Type_t Type_t;
+   inline static
+   Type_t apply(const UnaryNode&lt;Op, A&gt; &amp;expr, const FTag &amp;f, 
+     const CTag &amp;c) 
+   {
+     return Combine1&lt;TypeA_t, Op, CTag&gt;::
+       combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.child(), f, c), c);
+   }
+ };
+ </programlisting>  Since this structure is specialized for
+     <type>UnaryNode</type>s, the first parameter of its
+     <statement>static </statement> <function>apply</function> function
+     is a <type>UnaryNode</type>.  After recursively calling its child,
+     it invokes the combination function indicated by the
+     <type>Combine1</type> traits class.  In our example, the
+     <varname>c</varname> function object should be applied.  Other
+     combiners have different roles.  For example, using the
+     <type>NullCombine</type> tag indicates the child's result should
+     not be combined but occurs just for side effects.</para>
+ 
+     <para>Leaves are treated as the default behavior so they are not
+     specialized:
+ <programlisting>
+ template&lt;class Expr, class FTag, class CTag&gt;
+ struct ForEach
+ {
+   typedef typename LeafFunctor&lt;Expr, FTag&gt;::Type_t Type_t;
+   inline static
+   Type_t apply(const Expr &amp;expr, const FTag &amp;f, const CTag &amp;)
+   {
+     return LeafFunctor&lt;Expr, FTag&gt;::apply(expr, f);
+   }
+ };
+ </programlisting>  Thus, <type>LeafFunctor</type>'s
+     <function>apply</function> member is called.  <type>Expr</type>
+     represents the expression type, e.g., an &array;, and
+     <type>FTag</type> is the <type>LeafTag</type>, e.g.,
+     <type>EvalLeaf</type>.  The <type>LeafFunctor</type>specialization
+     for &array; passes the index stored by the <type>EvalLeaf</type>
+     object to the &array;'s engine, which returns the corresponding
+     value.</para>
+ 
+      <para>If one uses an aggressive optimizing compiler, code
+      resulting from the <function>evaluate</function> function
+      corresponds to this pseudocode:
+ <programlisting>
+ int end = A.domain[0].first() + A.domain[0].length();
+ for (int i = A.domain[0].first(); i < end; ++i)
+   A.engine(i) += -A.engine.read(i) + 2 * B.engine.read(i);
+ </programlisting>  The loop iterates through <varname>A</varname>'s
+     domain, using &array;'s engines to obtain values and assigning
+     values.  Notice there is no use of the run-time parse tree so the
+     optimizer can eliminate the code to construct it.  All the work to
+     construct the parse tree by overloading operators is unimportant
+     at run time, but it certainly helped the compiler produce improved
+     code.</para>
+ 
+      <para>&pete;'s expression template technology may be complicated,
+      using parse trees and their types, but the code they produce is
+      not.  Using the technology is also easy.  All data-parallel
+      statements are automatically converted.  In the next chapter, we
+      explore views of containers, permitting use of container subsets
+      and making data-parallel expressions even more useful.</para>
+     </section>
+ 
+    </section>
+ 
+   </chapter>
+   
+ 
  
    <chapter id="sequential">
     <title>Writing Sequential Programs</title>
*************** HERE</para>
*** 297,303 ****
     <para>FIXME: Explain the format of each section.
  HERE</para>
  
!    <para>FIXME: Explain the order  of the sections.
  HERE</para>
  
     <para>Proposed order.  Basically follow the order in the proposed
--- 1824,1830 ----
     <para>FIXME: Explain the format of each section.
  HERE</para>
  
!    <para>FIXME: Explain the order of the sections.
  HERE</para>
  
     <para>Proposed order.  Basically follow the order in the proposed
*************** HERE</para>
*** 475,490 ****
      <function>finalize</function>.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.</para>
  
!     <section id="sequential-begin_end-files">
!      <title>Files</title>
  
       <programlisting>
       #include "Pooma/Pooma.h"  // or "Pooma/Arrays.h" or "Pooma/Fields.h" or ...
       </programlisting>
-     </section>
  
!     <section id="sequential-begin_end-declarations">
!       <title>Declarations</title>
  
       <funcsynopsis>
        <funcprototype>
--- 2002,2014 ----
      <function>finalize</function>.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.</para>
  
!     <bridgehead id="sequential-begin_end-files" renderas="sect2">Files</bridgehead>
  
       <programlisting>
       #include "Pooma/Pooma.h"  // or "Pooma/Arrays.h" or "Pooma/Fields.h" or ...
       </programlisting>
  
!     <bridgehead id="sequential-begin_end-declarations" renderas="sect2">Declarations</bridgehead>
  
       <funcsynopsis>
        <funcprototype>
*************** HERE</para>
*** 520,529 ****
         </paramdef>
        </funcprototype>
       </funcsynopsis>
-     </section>
  
!     <section id="sequential-begin_end-description">
!      <title>Description</title>
  
       <para>Before its use, the &poomatoolkit; must be initialized by a
       call to <function>initialize</function>.  This usually occurs in
--- 2044,2051 ----
         </paramdef>
        </funcprototype>
       </funcsynopsis>
  
!     <bridgehead id="sequential-begin_end-description" renderas="sect2">Description</bridgehead>
  
       <para>Before its use, the &poomatoolkit; must be initialized by a
       call to <function>initialize</function>.  This usually occurs in
*************** HERE</para>
*** 572,581 ****
       <para>Including almost any &pooma; header file, rather than just
       <filename class="headerfile">Pooma/Pooma.h</filename> suffices
       since most other &pooma; header files include it.</para>
-     </section>
  
!     <section id="sequential-begin_end-example">
!      <title>Example Program</title>
  
       <para>Since every &pooma; program must call
       <function>initialize</function> and
--- 2094,2101 ----
       <para>Including almost any &pooma; header file, rather than just
       <filename class="headerfile">Pooma/Pooma.h</filename> suffices
       since most other &pooma; header files include it.</para>
  
!     <bridgehead id="sequential-begin_end-example" renderas="sect2">Example Program</bridgehead>
  
       <para>Since every &pooma; program must call
       <function>initialize</function> and
*************** HERE</para>
*** 584,599 ****
       use.</para>
  
       &initialize-finalize;
-     </section>
  
     </section><!-- end sequential-begin_end -->
  
     <section id="sequential-options">
      <title>&pooma; Command-line Options</title>
  
      <para>Every &pooma; program accepts a set of &pooma;-specific
      command-line options to set values at run-time.</para>
  
      <section id="sequential-options-list">
       <title>Options Summary</title>
  
--- 2104,2163 ----
       use.</para>
  
       &initialize-finalize;
  
     </section><!-- end sequential-begin_end -->
  
+ 
+    <section id="sequential-global">
+     <title>Global Variables</title>
+ 
+     <para>&pooma; makes a few global variables available after
+     initialization.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0">
+      <title>&pooma; Global Variables</title>
+      
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>variable</entry>
+ 	<entry>description</entry>
+        </row>
+       </thead>
+       <tbody>
+        <row>
+ 	<entry>&inform; <varname>pinfo</varname></entry>
+ 	<entry>output stream used to print informative messages to the
+ 	user while the program executes.  The stream accepts a
+ 	superset of standard output operations.</entry>
+        </row>
+        <row>
+ 	<entry>&inform; <varname>pwarn</varname></entry>
+ 	<entry>HERE output stream used to print informative messages to the
+ 	user while the program executes.  The stream accepts a
+ 	superset of standard output operations.</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+    </section>
+ 
+ <!-- HERE -->
+ 
     <section id="sequential-options">
      <title>&pooma; Command-line Options</title>
  
      <para>Every &pooma; program accepts a set of &pooma;-specific
      command-line options to set values at run-time.</para>
  
+     <para>QUESTION: Should I defer documenting &options; to the
+     reference manual, instead just listing commonly used options in
+     the previous section?
+ 
+ UNFINISHED</para>
+ 
      <section id="sequential-options-list">
       <title>Options Summary</title>
  
*************** HERE</para>
*** 601,614 ****
        <varlistentry>
         <term><parameter class="option">&dashdash;pooma-info</parameter></term>
         <listitem>
! 	<para>
! HERE  Who uses this?</para>
         </listitem>
        </varlistentry>
  <!-- HERE -->
       </variablelist>
  
       <para>FIXME: Be sure to list default values.</para>
  
  <!-- HERE -->
  
--- 2165,2181 ----
        <varlistentry>
         <term><parameter class="option">&dashdash;pooma-info</parameter></term>
         <listitem>
! 	<para>enable use of the <varname>pinfo</varname>, used to
! 	print informative messages to the user while the program
! 	executes.</para>
         </listitem>
        </varlistentry>
  <!-- HERE -->
       </variablelist>
  
       <para>FIXME: Be sure to list default values.</para>
+ <!-- HERE: need to describe the pinfo, pwarn, and perr streams somewhere.  To do so requires describing informs.-->
+ <!-- HERE: Which streams are buffered and which are not? -->
  
  <!-- HERE -->
  
*************** HERE  Who uses this?</para>
*** 616,627 ****
  
  <!-- HERE -->
  
-     <para>QUESTION: Should I defer documenting &options; to the
-     reference manual, instead just listing commonly used options in
-     the previous section?
- 
- UNFINISHED</para>
- 
     </section><!-- end sequential-options -->
  
     <section>
--- 2183,2188 ----
*************** UNFINISHED</para>
*** 740,746 ****
        code. An Array maps a fairly arbitrary input domain to an
        arbitrary range of outputs. When used by itself, an &array;
        object <varname>A</varname> refers to all of the values in its
! 				  domain. Element-wise mathematical operations or functions can be
        applied to an array using straightforward notation, like A + B
        or sin(A). Expressions involving Array objects are themselves
        Arrays. The operation A(d), where d is a domain object that
--- 2301,2307 ----
        code. An Array maps a fairly arbitrary input domain to an
        arbitrary range of outputs. When used by itself, an &array;
        object <varname>A</varname> refers to all of the values in its
!       domain. Element-wise mathematical operations or functions can be
        applied to an array using straightforward notation, like A + B
        or sin(A). Expressions involving Array objects are themselves
        Arrays. The operation A(d), where d is a domain object that
*************** UNFINISHED</para>
*** 1188,1195 ****
     class="libraryfile">.cmpl.cpp</filename>, <filename
     class="libraryfile">.mk</filename>, <filename
     class="libraryfile">.conf</filename>.  Should we also explain use
!    of <literal>inline</literal> even when necessary and the template
!    model, <!-- FIXME: s/literal/keyword/ --> e.g., including <filename
     class="libraryfile">.cpp</filename> files.</para>
  
     <para>QUESTION: What are the key concepts around which to organize
--- 2749,2756 ----
     class="libraryfile">.cmpl.cpp</filename>, <filename
     class="libraryfile">.mk</filename>, <filename
     class="libraryfile">.conf</filename>.  Should we also explain use
!    of <keywordname>inline</keywordname> even when necessary and the template
!    model, e.g., including <filename
     class="libraryfile">.cpp</filename> files.</para>
  
     <para>QUESTION: What are the key concepts around which to organize
*************** UNFINISHED</para>
*** 1420,1426 ****
  	<entry><para>dimension</para></entry>
         </row>
         <row>
! 	<entry><varname>T</varname></entry>
  	<entry><para>array element type</para></entry>
         </row>
         <row>
--- 2981,2987 ----
  	<entry><para>dimension</para></entry>
         </row>
         <row>
! 	<entry><type>T</type></entry>
  	<entry><para>array element type</para></entry>
         </row>
         <row>
*************** UNFINISHED</para>
*** 3014,3021 ****
       class="headerfile">src/Utilities/DerefIterator.h</filename>:
       <type>DerefIterator&lt;T&gt;</type> and
       <type>ConstDerefIterator&lt;T&gt;</type> automatically
!      dereference themselves to maintain <literal>const</literal>
!      correctness.  <!-- FIXME: s/literal/keyword/ --></para>
      </listitem>
  
      <listitem>
--- 4575,4582 ----
       class="headerfile">src/Utilities/DerefIterator.h</filename>:
       <type>DerefIterator&lt;T&gt;</type> and
       <type>ConstDerefIterator&lt;T&gt;</type> automatically
!      dereference themselves to maintain <keywordname>const</keywordname>
!      correctness.</para>
      </listitem>
  
      <listitem>
*************** UNFINISHED</para>
*** 3042,3048 ****
      <listitem>
       <para>Discuss &options; and related material.  Add developer
       command-line options listed in <filename
!      class="library">Utilities/Options.cmpl.cpp</filename> and also
       possibly <parameter class="option">&dashdash;pooma-threads
       <replaceable>n</replaceable></parameter>.</para>
      </listitem>
--- 4603,4609 ----
      <listitem>
       <para>Discuss &options; and related material.  Add developer
       command-line options listed in <filename
!      class="libraryfile">Utilities/Options.cmpl.cpp</filename> and also
       possibly <parameter class="option">&dashdash;pooma-threads
       <replaceable>n</replaceable></parameter>.</para>
      </listitem>
*************** UNFINISHED</para>
*** 3600,3859 ****
  
   </appendix>
  
- 
-  <!-- Bibliography -->
- 
-  <bibliography id="bibliography">
-   <title>Bibliography</title>
- 
-   <para>FIXME: How do I process these entries?</para>
- 
-   <biblioentry>
-    <abbrev>mpi99</abbrev>
-    <authorgroup>
-     <author>
-      <firstname>William</firstname><surname>Gropp</surname>
-     </author>
-     <author>
-      <firstname>Ewing</firstname><surname>Lusk</surname>
-     </author>
-     <author>
-      <firstname>Anthony</firstname><surname>Skjellum</surname>
-     </author>
-    </authorgroup>
-    <copyright>
-     <year>1999</year>
-     <holder>Massachusetts Institute of Technology</holder>
-    </copyright>
-    <isbn>0-262-57132-3</isbn>
-    <publisher>
-     <publishername>The MIT Press</publishername>
-     <address>Cambridge, MA</address>
-    </publisher>
-    <title>Using MPI</title>
-    <subtitle>Portable Parallel Programming with the Message-Passing Interface</subtitle>
-    <edition>second edition</edition>
-   </biblioentry>
- 
-   <biblioentry>
-    <abbrev>pooma95</abbrev>
-    <authorgroup>
-     <author>
-      <firstname>John</firstname><othername role="mi">V. W.</othername><surname>Reynders</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Paul</firstname><othername role="mi">J.</othername><surname>Hinker</surname>
-      <affiliation>
-       <orgname>Dakota Software Systems, Inc.</orgname>
-       <address><city>Rapid City</city><state>SD</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Julian</firstname><othername role="mi">C.</othername><surname>Cummings</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Susan</firstname><othername role="mi">R.</othername><surname>Atlas</surname>
-      <affiliation>
-       <orgname>Parallel Solutions, Inc.</orgname>
-       <address><city>Santa Fe</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Subhankar</firstname><surname>Banerjee</surname>
-      <affiliation>
-       <orgname>New Mexico State University</orgname>
-       <address><city>Las Cruces</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>William</firstname><othername role="mi">F.</othername><surname>Humphrey</surname>
-      <affiliation>
-       <orgname>University of Illinois at Urbana-Champaign</orgname>
-       <address><city>Urbana-Champaign</city><state>IL</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Steve</firstname><othername role="mi">R.</othername><surname>Karmesin</surname>
-      <affiliation>
-       <orgname>California Institute of Technology</orgname>
-       <address><city>Pasadena</city><state>CA</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Katarzyna</firstname><surname>Keahey</surname>
-      <affiliation>
-       <orgname>Indiana University</orgname>
-       <address><city>Bloomington</city><state>IN</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Marydell</firstname><surname>Tholburn</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-    </authorgroup>
-    <title>&pooma;</title>
-    <subtitle>A Framework for Scientific Simulation on Parallel Architectures</subtitle>
-    <releaseinfo>unpublished</releaseinfo>
-   </biblioentry>
- 
-   <biblioentry>
-    <abbrev>pooma-sc95</abbrev>
-    <authorgroup>
-     <author>
-      <firstname>Susan</firstname><surname>Atlas</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Subhankar</firstname><surname>Banerjee</surname>
-      <affiliation>
-       <orgname>New Mexico State University</orgname>
-       <address><city>Las Cruces</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Julian</firstname><othername role="mi">C.</othername><surname>Cummings</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Paul</firstname><othername role="mi">J.</othername><surname>Hinker</surname>
-      <affiliation>
-       <orgname>Advanced Computing Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>M.</firstname><surname>Srikant</surname>
-      <affiliation>
-       <orgname>New Mexico State University</orgname>
-       <address><city>Las Cruces</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>John</firstname><othername role="mi">V. W.</othername><surname>Reynders</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Marydell</firstname><surname>Tholburn</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-    </authorgroup>
-    <title>&pooma;</title>
-    <subtitle>A High Performance Distributed Simulation Environment for
-    Scientific Applications</subtitle>
- <!-- FIXME: Where list Supercomputing 1995? -->
-   </biblioentry>
- 
-   <biblioentry>
-    <abbrev>pooma-siam98</abbrev>
-    <authorgroup>
-     <author>
-      <firstname>Julian</firstname><othername role="mi">C.</othername><surname>Cummings</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>James</firstname><othername role="mi">A.</othername><surname>Crotinger</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Scott</firstname><othername role="mi">W.</othername><surname>Haney</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>William</firstname><othername role="mi">F.</othername><surname>Humphrey</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Steve</firstname><othername role="mi">R.</othername><surname>Karmesin</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>John</firstname><othername role="mi">V. W.</othername><surname>Reynders</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Stephen</firstname><othername role="mi">A.</othername><surname>Smith</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-     <author>
-      <firstname>Timothy</firstname><othername role="mi">J.</othername><surname>Williams</surname>
-      <affiliation>
-       <orgname>Los Alamos National Laboratory</orgname>
-       <address><city>Los Alamos</city><state>NM</state></address>
-      </affiliation>
-     </author>
-    </authorgroup>
-    <title>Raid Application Development and Enhanced Code
-    Interoperability using the &pooma; Framework</title>
- <!-- FIXME: Where list SIAM Workshop ... 1998? -->
-   </biblioentry>
- 
-   <biblioentry>
- <!-- FIXME: Change the year when we learn it. -->
-    <abbrev>pete-99</abbrev>
-    <authorgroup>
-     <author>
-      <firstname>Scott</firstname><surname>Haney</surname>
-     </author>
-     <author>
-      <firstname>James</firstname><surname>Crotinger</surname>
-     </author>
-     <author>
-      <firstname>Steve</firstname><surname>Karmesin</surname>
-     </author>
-     <author>
-      <firstname>Stephen</firstname><surname>Smith</surname>
-     </author>
-    </authorgroup>
-    <title>Easy Expression Templates Using &pete;: The Portable
-    Expression Template Engine</title>
- <!-- FIXME: When and where was this published? -->
-   </biblioentry>
-  </bibliography>
  
  
   &glossary-chapter; 
  
--- 5161,5168 ----
  
   </appendix>
  
  
+  &bibliography-chapter;
  
   &glossary-chapter; 
  
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.3
diff -c -p -r1.3 tutorial.xml
*** tutorial.xml	2001/12/17 17:27:42	1.3
--- tutorial.xml	2002/01/04 17:14:11
***************
*** 54,60 ****
      <imagedata fileref="figures/doof2d.201" format="EPS" align="center"></imagedata>
     </imageobject>
     <textobject>
!     <phrase>The Initial Configuration</phrase>
     </textobject>
    </mediaobject>
    <mediaobject>
--- 54,60 ----
      <imagedata fileref="figures/doof2d.201" format="EPS" align="center"></imagedata>
     </imageobject>
     <textobject>
!     <phrase>The Initial &doof2d; Configuration</phrase>
     </textobject>
    </mediaobject>
    <mediaobject>
***************
*** 476,482 ****
       <imagedata fileref="figures/doof2d.210" format="EPS" align="center"></imagedata>
      </imageobject>
      <textobject>
!      <phrase>Adding two arrays with different domains.</phrase>
      </textobject>
      <caption>
       <para>When adding arrays, values in corresponding positions are
--- 476,482 ----
       <imagedata fileref="figures/doof2d.210" format="EPS" align="center"></imagedata>
      </imageobject>
      <textobject>
!      <phrase>Adding two arrays with different domains is supported.</phrase>
      </textobject>
      <caption>
       <para>When adding arrays, values in corresponding positions are
***************
*** 587,593 ****
       <imagedata fileref="figures/doof2d.211" format="EPS" align="center"></imagedata>
      </imageobject>
      <textobject>
!      <phrase>Apply a stencil to position (1,3) of an array.</phrase>
      </textobject>
      <caption>
       <para>To compute the value associated with index position (1,3)
--- 587,593 ----
       <imagedata fileref="figures/doof2d.211" format="EPS" align="center"></imagedata>
      </imageobject>
      <textobject>
!      <phrase>Apply a stencil to position (1,3) of an &array;.</phrase>
      </textobject>
      <caption>
       <para>To compute the value associated with index position (1,3)
***************
*** 692,698 ****
       <imagedata fileref="figures/distributed.101" format="EPS" align="center"></imagedata>
      </imageobject>
      <textobject>
!      <phrase>the &pooma; distributed computation model.</phrase>
      </textobject>
      <caption>
       <para>The &pooma; distributed computation model combines
--- 692,698 ----
       <imagedata fileref="figures/distributed.101" format="EPS" align="center"></imagedata>
      </imageobject>
      <textobject>
!      <phrase>the &pooma; distributed computation model</phrase>
      </textobject>
      <caption>
       <para>The &pooma; distributed computation model combines
Index: figures/box-macros.mp
===================================================================
RCS file: box-macros.mp
diff -N box-macros.mp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- box-macros.mp	Fri Jan  4 10:14:11 2002
***************
*** 0 ****
--- 1,106 ----
+ %% Oldham, Jeffrey D.
+ %% 2001Dec20
+ %% Pooma
+ 
+ %% Macros to Improve Boxes
+ 
+ %% Assumes 'input boxes;'
+ 
+   % Ensure a list of boxes all have the same width.
+   % input <- suffixes for the boxes;
+   % output-> all boxes have the same width (maximum picture width + defaultdx)
+   vardef samewidth(suffix $)(text t) =
+     save p_; pair p_;
+     p_ = maxWidthAndHeight($)(t);
+     numericSetWidth(xpart(p_)+2defaultdx)($)(t);
+   enddef;
+   
+   % Ensure a list of boxes all have the same height.
+   % input <- suffixes for the boxes;
+   % output-> all boxes have the same height (maximum picture height + defaultdy)
+   vardef sameheight(suffix $)(text t) =
+     save p_; pair p_;
+     p_ = maxWidthAndHeight($)(t);
+     numericSetWidth(ypart(p_)+2defaultdy)($)(t);
+   enddef;
+   
+   % Given a list of boxes, determine the maximum picture width and
+   % maximum picture height.
+   % input <- suffixes for the boxes
+   % output-> pair of maximum picture width and height
+   vardef maxWidthAndHeight(suffix f)(text t) =
+     save w_, h_; numeric w_, h_;
+     w_ = xpart((urcorner pic_.f - llcorner pic_.f));
+     h_ = ypart((urcorner pic_.f - llcorner pic_.f));
+     forsuffixes uu = t:
+       if xpart((urcorner pic_.uu - llcorner pic_.uu)) > w_ :
+ 	w_ := xpart((urcorner pic_.uu - llcorner pic_.uu));
+       fi
+       if ypart((urcorner pic_.uu - llcorner pic_.uu)) > h_ :
+ 	h_ := ypart((urcorner pic_.uu - llcorner pic_.uu));
+       fi
+     endfor
+     (w_, h_)
+   enddef;
+ 
+   % Given a width, ensure a box has the given width.
+   % input <- box width
+   %          suffix for the one box
+   % output-> the box has the given width by setting its .dx
+   vardef numericSetWidthOne(expr width)(suffix f) =
+     f.dx = 0.5(width - xpart(urcorner pic_.f - llcorner pic_.f));
+   enddef;
+   
+   % Given a width, ensure all boxes have the given width.
+   % input <- box width
+   %          suffixes for the boxes
+   % output-> all boxes have the given width by setting their .dx
+   vardef numericSetWidth(expr width)(suffix f)(text t) =
+     f.dx = 0.5(width - xpart(urcorner pic_.f - llcorner pic_.f));
+     forsuffixes $ = t:
+       $.dx = 0.5(width - xpart(urcorner pic_.$ - llcorner pic_.$));
+     endfor
+   enddef;
+ 
+   % Given a height, ensure all boxes have the given height.
+   % input <- box height
+   %          suffixes for the boxes
+   % output-> all boxes have the given height by setting their .dx
+   vardef numericSetHeight(expr height)(suffix f)(text t) =
+     f.dy = 0.5(height - ypart(urcorner pic_.f - llcorner pic_.f));
+     forsuffixes $ = t:
+       $.dy = 0.5(height - ypart(urcorner pic_.$ - llcorner pic_.$));
+     endfor
+   enddef;
+   
+   % Ensure a list of boxes and circles all to have the same width, height,
+   % and diameter.
+   % input <- suffixes for the boxes and circles
+   % output-> all boxes have .dx and .dy set so they have the same width,
+   %           height, and radius
+   % The boxes are squares and the circles are circular, not oval.
+   vardef sameWidthAndHeight(suffix f)(text t) =
+     save p_; pair p_;
+     p_ = maxWidthAndHeight(f)(t);
+     if (xpart(p_)+2defaultdx >= ypart(p_)+2defaultdy):
+       numericSetWidth(xpart(p_)+2defaultdx)(f)(t);
+       numericSetHeight(xpart(p_)+2defaultdx)(f)(t);
+     else:
+       numericSetWidth(ypart(p_)+2defaultdy)(f)(t);
+       numericSetHeight(ypart(p_)+2defaultdy)(f)(t);
+     fi
+   enddef;
+ 
+   % Ensure a list of boxes and circles all to have the same width and
+   % the same height.  Unlike sameWidthAndHeight, the width and height
+   % can differ.
+   % input <- suffixes for the boxes and circles
+   % output-> all boxes have .dx and .dy set so they have the same width,
+   %           height, and radius
+   % The boxes are squares and the circles are circular, not oval.
+   vardef sameWidthSameHeight(suffix f)(text t) =
+     save p_; pair p_;
+     p_ = maxWidthAndHeight(f)(t);
+     numericSetWidth(xpart(p_)+2defaultdx)(f)(t);
+     numericSetHeight(ypart(p_)+2defaultdy)(f)(t);
+   enddef;
Index: figures/data-parallel.mp
===================================================================
RCS file: data-parallel.mp
diff -N data-parallel.mp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- data-parallel.mp	Fri Jan  4 10:14:11 2002
***************
*** 0 ****
--- 1,157 ----
+ %% Oldham, Jeffrey D.
+ %% 2001Dec20
+ %% Pooma
+ 
+ %% Illustrations for the Data-Parallel Chapter
+ 
+ %% Assumes TEX=latex.
+ 
+ input boxes;
+ input box-macros;
+ input grid-macros;
+ 
+ verbatimtex
+ \documentclass[10pt]{article}
+ \input{macros.ltx}
+ \begin{document}
+ etex
+ 
+ %% Parse Tree for Example Statement A += -A + 2*B
+ beginfig(101)
+   numeric unit; unit = 1.5cm;
+   numeric xunit; xunit = unit;
+   numeric yunit; yunit = unit;
+   
+   %% Create the tree nodes.
+   circleit.b0(btex \statement{+=} etex);
+   circleit.b1(btex \varname{A} etex);
+   circleit.b2(btex \statement{+} etex);
+   circleit.b3(btex \statement{-} etex);
+   circleit.b4(btex \varname{A} etex);
+   circleit.b5(btex \statement{*} etex);
+   circleit.b6(btex \statement{2} etex);
+   circleit.b7(btex \varname{B} etex);
+   numeric nuBoxes; nuBoxes = 7;
+   sameWidthAndHeight(b0,b1,b2,b3,b4,b5,b6,b7);
+   
+   %% Position the tree nodes.
+   b2.c = origin;
+   b0.c - 0.5[b1.c,b2.c] = (0,yunit);
+   b2.c - 0.5[b3.c,b5.c] = (0,yunit);
+   b3.c - 0.5[b4.c,b6.c] = (0,yunit);
+   b5.c - 0.5[b6.c,b7.c] = (0,yunit);
+   b1.c - b2.c = b3.c - b5.c = b4.c - b6.c = b6.c - b8.c = (-xunit,0);
+   
+   %% Draw the tree.
+   for t = 2 upto 7:
+     drawboxed(b[t]);
+   endfor
+   vardef drawEdge(expr start, stop) =
+     draw b[start].c -- b[stop].c cutbefore bpath b[start] cutafter bpath b[stop];
+   enddef;
+   for t = (2,3), (2,5), (3,4), (5,6), (5,7):
+     drawEdge(xpart(t),ypart(t));
+   endfor
+ 
+   %% Label the node's types.
+ % TMP  label.rt(btex \type{OpAddAssign} etex, b0.e);
+ % TMP  label.rt(btex \type{Expression} etex, 0.5[b0.c,b2.c]);
+   label.top(btex \type{Expression} etex, b2.n);
+ % TMP  label.lft(btex \type{Ar} etex, b1.w);
+   label.rt(btex \type{BinaryNode<OpAdd,} etex, b2.e);
+   label.lft(btex \type{UnaryNode<OpMinus,} etex, b3.w);
+   label.lft(btex \type{Ar} etex, b4.w);
+   label.rt(btex \type{BinaryNode<OpMultiply,} etex, b5.e);
+   label.bot(btex \type{Scalar<int>} etex, b6.s);
+   label.rt(btex \type{Ar} etex, b7.e);
+   
+ endfig;
+ 
+ 
+ %% An illustratation of the addition of arrays.
+ beginfig(212)
+   numeric unit; unit = 0.9cm;	% width or height of an individual grid cell
+   numeric nuCells; nuCells = 5;	% number of cells in each dimension
+ 				% This number should be odd.
+   numeric nuArrayCells; nuArrayCells = 3;
+ 				% number of cells in array in each dimension
+   numeric operatorWidth; operatorWidth = 1.5;
+   				% horizontal space for an operator as
+   				% a multiple of "unit"
+   
+   %% Determine the locations of the arrays.
+   z0 = origin;
+   z1 = z0 + unit * (nuCells+operatorWidth,0);
+   z2 - z1 = z1 - z0;
+ 
+   %% Draw the grid cells and the operators.
+   for t = 0 upto 2:
+     drawGridDashed(nuCells, unit, z[t]);
+   endfor
+   for t = 0 upto 1:
+     drawGrid(nuArrayCells, unit, z[t]+unit*(1,1));
+   endfor
+   drawGrid(nuArrayCells, unit, z2+unit*(2,0));
+  
+   label(btex = etex, z1 + unit*(-0.6operatorWidth, 0.5nuCells));
+   label(btex + etex, z2 + unit*(-0.6operatorWidth, 0.5nuCells));
+   
+   %% Label the indices.
+   % Label b(I,J) grid indices.
+   for t = 0 upto 2:
+     labelCellBottom(btex \footnotesize 0 etex, (0,0), z[t]);
+     labelCellBottom(btex \footnotesize 1 etex, (1,0), z[t]);
+     labelCellBottom(btex \footnotesize 2 etex, (2,0), z[t]);
+     labelCellBottom(btex \footnotesize 3 etex, (3,0), z[t]);
+     labelCellBottom(btex \footnotesize 4 etex, (4,0), z[t]);
+     labelCellLeft(btex \footnotesize 0 etex, (0,0), z[t]);
+     labelCellLeft(btex \footnotesize 1 etex, (0,1), z[t]);
+     labelCellLeft(btex \footnotesize 2 etex, (0,2), z[t]);
+     labelCellLeft(btex \footnotesize 3 etex, (0,3), z[t]);
+     labelCellLeft(btex \footnotesize 4 etex, (0,4), z[t]);
+   endfor
+   
+   %% Label the grid cells' values.
+   % Label b(I,J) grid values.
+   pair zShift;
+   zShift := z1 + unit*(1,1);
+   labelCell(btex \normalsize 9 etex, (0,0), zShift);
+   labelCell(btex \normalsize 11 etex, (1,0), zShift);
+   labelCell(btex \normalsize 13 etex, (2,0), zShift);
+   labelCell(btex \normalsize 17 etex, (0,1), zShift);
+   labelCell(btex \normalsize 19 etex, (1,1), zShift);
+   labelCell(btex \normalsize 21 etex, (2,1), zShift);
+   labelCell(btex \normalsize 25 etex, (0,2), zShift);
+   labelCell(btex \normalsize 27 etex, (1,2), zShift);
+   labelCell(btex \normalsize 29 etex, (2,2), zShift);
+   % Label b(I+1,J-1) grid values.
+   zShift := z2 + unit*(2,0);
+   labelCell(btex \normalsize 3 etex, (0,0), zShift);
+   labelCell(btex \normalsize 5 etex, (1,0), zShift);
+   labelCell(btex \normalsize 7 etex, (2,0), zShift);
+   labelCell(btex \normalsize 11 etex, (0,1), zShift);
+   labelCell(btex \normalsize 13 etex, (1,1), zShift);
+   labelCell(btex \normalsize 15 etex, (2,1), zShift);
+   labelCell(btex \normalsize 19 etex, (0,2), zShift);
+   labelCell(btex \normalsize 21 etex, (1,2), zShift);
+   labelCell(btex \normalsize 23 etex, (2,2), zShift);
+   % Label b(I,J)+b(I+1,J-1) grid values.
+   zShift := z0 + unit*(1,1);
+   labelCell(btex \normalsize 9 etex, (0,0), zShift);
+   labelCell(btex \normalsize 22 etex, (1,0), zShift);
+   labelCell(btex \normalsize 26 etex, (2,0), zShift);
+   labelCell(btex \normalsize 17 etex, (0,1), zShift);
+   labelCell(btex \normalsize 38 etex, (1,1), zShift);
+   labelCell(btex \normalsize 42 etex, (2,1), zShift);
+   labelCell(btex \normalsize 25 etex, (0,2), zShift);
+   labelCell(btex \normalsize 27 etex, (1,2), zShift);
+   labelCell(btex \normalsize 29 etex, (2,2), zShift);
+ 
+   %% Label the grids.
+   labelGrid(btex $A+B$ etex, nuCells, z0);
+   labelGrid(btex $A$ etex, nuCells, z1);
+   labelGrid(btex $B$ etex, nuCells, z2);
+ endfig;
+ 
+ 
+ bye
Index: figures/doof2d.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/doof2d.mp,v
retrieving revision 1.2
diff -c -p -r1.2 doof2d.mp
*** figures/doof2d.mp	2001/12/11 20:36:13	1.2
--- figures/doof2d.mp	2002/01/04 17:14:11
*************** verbatimtex
*** 12,46 ****
  \begin{document}
  etex
  
! % Draw a set of grid cells.
! vardef drawGrid(expr nuCells, unit, llCorner) =
!   for i = 0 upto nuCells-1:
!     for j = 0 upto nuCells-1:
!       draw unitsquare scaled unit shifted (llCorner + unit*(i,j));
!     endfor
!   endfor
! enddef;
! 
! % Label the specified grid, grid cell, or its edge.
! % Place a value at the center of a grid cell.
! vardef labelCell(expr lbl, xy, llCorner) =
!   label(lbl, llCorner + unit*(xy + 0.5*(1,1)));
! enddef;
! 
! % Label the bottom of a grid cell.
! vardef labelCellBottom(expr lbl, xy, llCorner) =
!   label.bot(lbl, llCorner + unit*(xy + 0.5*(1,0)));
! enddef;
! 
! % Label the left side of a grid cell.
! vardef labelCellLeft(expr lbl, xy, llCorner) =
!   label.lft(lbl, llCorner + unit*(xy + 0.5*(0,1)));
! enddef;
! 
! % Label the top of a grid.
! vardef labelGrid(expr lbl, nuCells, llCorner) =
!   label.top(lbl, llCorner + unit*(nuCells/2,nuCells));
! enddef;
  
  %% Global Declarations
  numeric unit; unit = 0.9cm;	% width or height of an individual grid cell
--- 12,18 ----
  \begin{document}
  etex
  
! input grid-macros;
  
  %% Global Declarations
  numeric unit; unit = 0.9cm;	% width or height of an individual grid cell
Index: figures/grid-macros.mp
===================================================================
RCS file: grid-macros.mp
diff -N grid-macros.mp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- grid-macros.mp	Fri Jan  4 10:14:11 2002
***************
*** 0 ****
--- 1,45 ----
+ %% Oldham, Jeffrey D.
+ %% 2001Dec21
+ %% Pooma
+ 
+ %% Macros for Drawing Grids
+ 
+ % Draw a set of grid cells.
+ vardef drawGrid(expr nuCells, unit, llCorner) =
+   for i = 0 upto nuCells-1:
+     for j = 0 upto nuCells-1:
+       draw unitsquare scaled unit shifted (llCorner + unit*(i,j));
+     endfor
+   endfor
+ enddef;
+ 
+ % Draw a set of grid cells with dashed lines.
+ vardef drawGridDashed(expr nuCells, unit, llCorner) =
+   for i = 0 upto nuCells-1:
+     for j = 0 upto nuCells-1:
+       draw unitsquare scaled unit shifted (llCorner + unit*(i,j)) dashed evenly;
+     endfor
+   endfor
+ enddef;
+ 
+ % Label the specified grid, grid cell, or its edge.
+ % Place a value at the center of a grid cell.
+ vardef labelCell(expr lbl, xy, llCorner) =
+   label(lbl, llCorner + unit*(xy + 0.5*(1,1)));
+ enddef;
+ 
+ % Label the bottom of a grid cell.
+ vardef labelCellBottom(expr lbl, xy, llCorner) =
+   label.bot(lbl, llCorner + unit*(xy + 0.5*(1,0)));
+ enddef;
+ 
+ % Label the left side of a grid cell.
+ vardef labelCellLeft(expr lbl, xy, llCorner) =
+   label.lft(lbl, llCorner + unit*(xy + 0.5*(0,1)));
+ enddef;
+ 
+ % Label the top of a grid.
+ vardef labelGrid(expr lbl, nuCells, llCorner) =
+   label.top(lbl, llCorner + unit*(nuCells/2,nuCells));
+ enddef;
+ 
Index: figures/introduction.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/introduction.mp,v
retrieving revision 1.1
diff -c -p -r1.1 introduction.mp
*** figures/introduction.mp	2001/12/17 17:27:42	1.1
--- figures/introduction.mp	2002/01/04 17:14:11
***************
*** 7,12 ****
--- 7,13 ----
  %% Assumes TEX=latex.
  
  input boxes;
+ input box-macros;
  
  verbatimtex
  \documentclass[10pt]{article}
*************** beginfig(101)
*** 21,125 ****
    numeric horizSpace; horizSpace = 8unit;
    numeric vertSpace; vertSpace = unit;
    numeric nuBoxes;		% number of boxes
- 
-   % Ensure a list of boxes all have the same width.
-   % input <- suffixes for the boxes;
-   % output-> all boxes have the same width (maximum picture width + defaultdx)
-   vardef samewidth(suffix $)(text t) =
-     save p_; pair p_;
-     p_ = maxWidthAndHeight($)(t);
-     numericSetWidth(xpart(p_)+2defaultdx)($)(t);
-   enddef;
-   
-   % Ensure a list of boxes all have the same height.
-   % input <- suffixes for the boxes;
-   % output-> all boxes have the same height (maximum picture height + defaultdy)
-   vardef sameheight(suffix $)(text t) =
-     save p_; pair p_;
-     p_ = maxWidthAndHeight($)(t);
-     numericSetWidth(ypart(p_)+2defaultdy)($)(t);
-   enddef;
-   
-   % Given a list of boxes, determine the maximum picture width and
-   % maximum picture height.
-   % input <- suffixes for the boxes
-   % output-> pair of maximum picture width and height
-   vardef maxWidthAndHeight(suffix f)(text t) =
-     save w_, h_; numeric w_, h_;
-     w_ = xpart((urcorner pic_.f - llcorner pic_.f));
-     h_ = ypart((urcorner pic_.f - llcorner pic_.f));
-     forsuffixes uu = t:
-       if xpart((urcorner pic_.uu - llcorner pic_.uu)) > w_ :
- 	w_ := xpart((urcorner pic_.uu - llcorner pic_.uu));
-       fi
-       if ypart((urcorner pic_.uu - llcorner pic_.uu)) > h_ :
- 	h_ := ypart((urcorner pic_.uu - llcorner pic_.uu));
-       fi
-     endfor
-     (w_, h_)
-   enddef;
- 
-   % Given a width, ensure a box has the given width.
-   % input <- box width
-   %          suffix for the one box
-   % output-> the box has the given width by setting its .dx
-   vardef numericSetWidthOne(expr width)(suffix f) =
-     f.dx = 0.5(width - xpart(urcorner pic_.f - llcorner pic_.f));
-   enddef;
-   
-   % Given a width, ensure all boxes have the given width.
-   % input <- box width
-   %          suffixes for the boxes
-   % output-> all boxes have the given width by setting their .dx
-   vardef numericSetWidth(expr width)(suffix f)(text t) =
-     f.dx = 0.5(width - xpart(urcorner pic_.f - llcorner pic_.f));
-     forsuffixes $ = t:
-       $.dx = 0.5(width - xpart(urcorner pic_.$ - llcorner pic_.$));
-     endfor
-   enddef;
- 
-   % Given a height, ensure all boxes have the given height.
-   % input <- box height
-   %          suffixes for the boxes
-   % output-> all boxes have the given height by setting their .dx
-   vardef numericSetHeight(expr height)(suffix f)(text t) =
-     f.dy = 0.5(height - ypart(urcorner pic_.f - llcorner pic_.f));
-     forsuffixes $ = t:
-       $.dy = 0.5(height - ypart(urcorner pic_.$ - llcorner pic_.$));
-     endfor
-   enddef;
-   
-   % Ensure a list of boxes and circles all to have the same width, height,
-   % and diameter.
-   % input <- suffixes for the boxes and circles
-   % output-> all boxes have .dx and .dy set so they have the same width,
-   %           height, and radius
-   % The boxes are squares and the circles are circular, not oval.
-   vardef sameWidthAndHeight(suffix f)(text t) =
-     save p_; pair p_;
-     p_ = maxWidthAndHeight(f)(t);
-     if (xpart(p_)+2defaultdx >= ypart(p_)+2defaultdy):
-       numericSetWidth(xpart(p_)+2defaultdx)(f)(t);
-       numericSetHeight(xpart(p_)+2defaultdx)(f)(t);
-     else:
-       numericSetWidth(ypart(p_)+2defaultdy)(f)(t);
-       numericSetHeight(ypart(p_)+2defaultdy)(f)(t);
-     fi
-   enddef;
- 
-   % Ensure a list of boxes and circles all to have the same width and
-   % the same height.  Unlike sameWidthAndHeight, the width and height
-   % can differ.
-   % input <- suffixes for the boxes and circles
-   % output-> all boxes have .dx and .dy set so they have the same width,
-   %           height, and radius
-   % The boxes are squares and the circles are circular, not oval.
-   vardef sameWidthSameHeight(suffix f)(text t) =
-     save p_; pair p_;
-     p_ = maxWidthAndHeight(f)(t);
-     numericSetWidth(xpart(p_)+2defaultdx)(f)(t);
-     numericSetHeight(ypart(p_)+2defaultdy)(f)(t);
-   enddef;
  
    % Create the boxes.
    boxit.b0(btex \textsl{science / math} etex);
--- 22,27 ----
Index: programs/Doof2d-Array-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Array-distributed-annotated.patch
diff -N Doof2d-Array-distributed-annotated.patch
*** /tmp/cvsKKb5AR	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,184 ****
- *** Doof2d-Array-distributed.cpp	Wed Dec  5 14:04:36 2001
- --- Doof2d-Array-distributed-annotated.cpp	Wed Dec  5 14:07:56 2001
- ***************
- *** 1,3 ****
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- --- 1,5 ----
- ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- ***************
- *** 14,18 ****
-     // (i,j).  The "C" template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template <class C>
-     inline
-     typename C::Element_t
- --- 16,20 ----
-     // (i,j).  The "C" template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 42,46 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 44,48 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  <co id="tutorial-array_distributed-doof2d-io"></co>
-     Inform output;
-   
- ***************
- *** 48,52 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
-       return EXIT_FAILURE;
-     }
- --- 50,54 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &lt;&lt; argv[0] &lt;&lt; ": number-of-processors number-of-averagings number-of-values" &lt;&lt; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 55,63 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 57,65 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 65,69 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 67,71 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 71,80 ****
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<2> interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- --- 73,82 ----
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- ***************
- *** 83,98 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.
- !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
- ! 				    GuardLayers<2>(1),  // internal
- ! 				    GuardLayers<2>(0)); // external
- !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
-   
-     // The template parameters indicate 2 dimensions and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
- !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > b(layout);
-   
-     // Set up the initial conditions.
- --- 85,100 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.  <co id="tutorial-array_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // The template parameters indicate 2 dimensions and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; b(layout);
-   
-     // Set up the initial conditions.
- ***************
- *** 104,112 ****
-   
-     // Create the stencil performing the computation.
- !   Stencil<DoofNinePt> stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 106,114 ----
-   
-     // Create the stencil performing the computation.
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_distributed-doof2d-first_write"></co>
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 117,121 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 119,123 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 125,126 ****
- --- 127,129 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: programs/Doof2d-Array-element-annotated.patch
===================================================================
RCS file: Doof2d-Array-element-annotated.patch
diff -N Doof2d-Array-element-annotated.patch
*** /tmp/cvslmAiwW	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,143 ****
- *** Doof2d-Array-element.cpp	Tue Dec  4 12:02:10 2001
- --- Doof2d-Array-element-annotated.cpp	Tue Dec  4 12:24:25 2001
- ***************
- *** 1,5 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
- ! #include "Pooma/Arrays.h"	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, element-wise implementation
- --- 1,6 ----
- ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include "Pooma/Arrays.h"	// has Pooma's Array  <co id="tutorial-array_elementwise-doof2d-header"></co>
-   
-   // Doof2d: Pooma Arrays, element-wise implementation
- ***************
- *** 7,17 ****
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the Pooma library for execution.
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 8,18 ----
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the Pooma library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; "Please enter the number of averagings: ";
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,37 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
- !   // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
-     for (int j = 1; j < n-1; j++)
-       for (int i = 1; i < n-1; i++)
- --- 20,38 ----
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; "Please enter the array size: ";
- !   std::cin &gt;&gt; n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).  <co id="tutorial-array_elementwise-doof2d-domain"></co>
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  <co id="tutorial-array_elementwise-doof2d-initialization"></co>
-     for (int j = 1; j < n-1; j++)
-       for (int i = 1; i < n-1; i++)
- ***************
- *** 43,51 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
- !         a(i,j) = weight *
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- --- 44,52 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
- !         a(i,j) = weight *  <co id="tutorial-array_elementwise-doof2d-first_write"></co>
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- ***************
- *** 53,58 ****
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- --- 54,59 ----
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- ***************
- *** 62,71 ****
-   
-     // Print out the final central value.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
- !   // The arrays are automatically deallocated.
-   
- !   // Tell the Pooma library execution has finished.
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- --- 63,74 ----
-   
-     // Print out the final central value.
- !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
- !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
-   
- !   // Tell the Pooma library execution has finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: programs/Doof2d-Array-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Array-parallel-annotated.patch
diff -N Doof2d-Array-parallel-annotated.patch
*** /tmp/cvsuReKr3	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,116 ****
- *** Doof2d-Array-parallel.cpp	Tue Dec  4 11:49:43 2001
- --- Doof2d-Array-parallel-annotated.cpp	Tue Dec  4 12:24:36 2001
- ***************
- *** 1,4 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- --- 1,5 ----
- ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; "Please enter the number of averagings: ";
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,43 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- --- 20,44 ----
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; "Please enter the array size: ";
- !   std::cin &gt;&gt; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.  <co id="tutorial-array_parallel-doof2d-innerdomain"></co>
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.  <co id="tutorial-array_parallel-doof2d-blockAndEvaluate"></co>
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- ***************
- *** 47,52 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 48,53 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_parallel-doof2d-first_write"></co>
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 63,67 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 64,68 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 71,72 ****
- --- 72,74 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: programs/Doof2d-Array-stencil-annotated.patch
===================================================================
RCS file: Doof2d-Array-stencil-annotated.patch
diff -N Doof2d-Array-stencil-annotated.patch
*** /tmp/cvsLwSPO9	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,152 ****
- *** Doof2d-Array-stencil.cpp	Tue Dec  4 11:49:39 2001
- --- Doof2d-Array-stencil-annotated.cpp	Tue Dec  4 12:26:46 2001
- ***************
- *** 1,9 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.
-   class DoofNinePt
-   {
- --- 1,10 ----
- ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
-   class DoofNinePt
-   {
- ***************
- *** 14,19 ****
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.
- !   template <class C>
-     inline
-     typename C::Element_t
- --- 15,20 ----
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.  <co id="tutorial-array_stencil-doof2d-stencil_operator"></co>
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 26,30 ****
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }
-     inline int upperExtent(int) const { return 1; }
-   
- --- 27,31 ----
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }  <co id="tutorial-array_stencil-doof2d-stencil_extent"></co>
-     inline int upperExtent(int) const { return 1; }
-   
- ***************
- *** 42,47 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 43,48 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; "Please enter the number of averagings: ";
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 49,68 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<2> interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
- --- 50,69 ----
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; "Please enter the array size: ";
- !   std::cin &gt;&gt; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- ***************
- *** 73,82 ****
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.
- !   Stencil<DoofNinePt> stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 74,83 ----
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil_creation"></co>
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_stencil-doof2d-first_write"></co>
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 87,91 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 88,92 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 95,96 ****
- --- 96,98 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: programs/Doof2d-C-element-annotated.patch
===================================================================
RCS file: Doof2d-C-element-annotated.patch
diff -N Doof2d-C-element-annotated.patch
*** /tmp/cvs2hDHVf	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,150 ****
- *** Doof2d-C-element.cpp	Tue Nov 27 08:36:38 2001
- --- Doof2d-C-element-annotated.cpp	Tue Nov 27 12:08:03 2001
- ***************
- *** 1,4 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- --- 1,5 ----
- ! <programlisting id="tutorial-hand_coded-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- ***************
- *** 6,30 ****
-   int main()
-   {
- !   // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of elements along one dimension of
- !   // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
- !   // Allocate the arrays.
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i < n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- --- 7,31 ----
-   int main()
-   {
- !   // Ask the user for the number of averagings.  <co id="tutorial-hand_coded-doof2d-nuaveragings"></co>
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; "Please enter the number of averagings: ";
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.  <co id="tutorial-hand_coded-doof2d-array_storage"></co>
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of elements along one dimension of
- !   // the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
-     long n;
- !   std::cout &lt;&lt; "Please enter the array size: ";
- !   std::cin &gt;&gt; n;
-   
- !   // Allocate the arrays.  <co id="tutorial-hand_coded-doof2d-allocation"></co>
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i &lt; n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- ***************
- *** 32,49 ****
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
- !   for (int j = 0; j < n; j++)
- !     for (int i = 0; i < n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- --- 33,50 ----
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  <co id="tutorial-hand_coded-doof2d-initialization"></co>
- !   for (int j = 0; j &lt; n; j++)
- !     for (int i = 0; i &lt; n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.  <co id="tutorial-hand_coded-doof2d-constants"></co>
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-hand_coded-doof2d-first_write"></co>
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- ***************
- *** 51,57 ****
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- --- 52,58 ----
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.  <co id="tutorial-hand_coded-doof2d-second_write"></co>
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- ***************
- *** 60,68 ****
-     }
-   
- !   // Print out the final central value.
- !   std::cout << (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) << std::endl;
-   
- !   // Deallocate the arrays.
- !   for (int i = 0; i < n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- --- 61,69 ----
-     }
-   
- !   // Print out the final central value.  <co id="tutorial-hand_coded-doof2d-answer"></co>
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) &lt;&lt; std::endl;
-   
- !   // Deallocate the arrays.  <co id="tutorial-hand_coded-doof2d-deallocation"></co>
- !   for (int i = 0; i &lt; n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- ***************
- *** 73,74 ****
- --- 74,76 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: programs/Doof2d-Field-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Field-distributed-annotated.patch
diff -N Doof2d-Field-distributed-annotated.patch
*** /tmp/cvsF2z45n	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,176 ****
- *** Doof2d-Field-distributed.cpp	Wed Dec  5 14:05:10 2001
- --- Doof2d-Field-distributed-annotated.cpp	Wed Dec  5 14:41:24 2001
- ***************
- *** 1,3 ****
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Fields.h"	// has Pooma's Field
-   
- --- 1,4 ----
- ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Fields.h"	// has Pooma's Field
-   
- ***************
- *** 12,16 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 13,17 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  <co id="tutorial-field_distributed-doof2d-io"></co>
-     Inform output;
-   
- ***************
- *** 18,22 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
-       return EXIT_FAILURE;
-     }
- --- 19,23 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &lt;&lt; argv[0] &lt;&lt; ": number-of-processors number-of-averagings number-of-values" &lt;&lt; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 25,33 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 26,34 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 35,39 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 36,40 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 41,50 ****
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- --- 42,51 ----
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- ***************
- *** 52,74 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.
- !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
- ! 				    GuardLayers<2>(1),  // internal
- ! 				    GuardLayers<2>(0)); // external
- !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
- !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
-   
-     // The template parameters indicate a mesh and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
- !     Remote<Brick> > > a(cell, layout, mesh);
- !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
- !     Remote<Brick> > > b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 53,75 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.  <co id="tutorial-field_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  <co id="tutorial-field_distributed-doof2d-mesh"></co>
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // The template parameters indicate a mesh and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 83,87 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- --- 84,88 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- ***************
- *** 99,103 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The fields are automatically deallocated.
- --- 100,104 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 107,108 ****
- --- 108,110 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: programs/Doof2d-Field-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Field-parallel-annotated.patch
diff -N Doof2d-Field-parallel-annotated.patch
*** /tmp/cvswOFpSv	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,120 ****
- *** Doof2d-Field-parallel.cpp	Tue Dec  4 10:01:28 2001
- --- Doof2d-Field-parallel-annotated.cpp	Tue Dec  4 11:04:26 2001
- ***************
- *** 1,5 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
- ! #include "Pooma/Fields.h"	// has Pooma's Field
-   
-   // Doof2d: Pooma Fields, data-parallel implementation
- --- 1,6 ----
- ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include "Pooma/Fields.h"	// has Pooma's Field  <co id="tutorial-field_parallel-doof2d-header"></co>
-   
-   // Doof2d: Pooma Fields, data-parallel implementation
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &lt;&lt; "Please enter the number of averagings: ";
- !   std::cin &gt;&gt; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,44 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the field size: ";
- !   std::cin >> n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   DomainLayout<2> layout(vertDomain);
- !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
- !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The template parameters indicate a mesh, a 'double' element
- !   // type, and ordinary 'Brick' storage.
- !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
- !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 20,45 ----
-     // the grid.
-     long n;
- !   std::cout &lt;&lt; "Please enter the field size: ";
- !   std::cin &gt;&gt; n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  <co id="tutorial-field_parallel-doof2d-mesh"></co>
- !   DomainLayout&lt;2&gt; layout(vertDomain);
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The template parameters indicate a mesh, a 'double' element
- !   // type, and ordinary 'Brick' storage.  <co id="tutorial-field_parallel-doof2d-field_creation"></co>
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 51,56 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 52,57 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-field_parallel-doof2d-first_write"></co>
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 67,71 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The fields are automatically deallocated.
- --- 68,72 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &lt;&lt; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &lt;&lt; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 75,76 ****
- --- 76,78 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: programs/makefile
===================================================================
RCS file: makefile
diff -N makefile
*** /tmp/cvsfaiLlD	Fri Jan  4 10:14:11 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,12 ****
- ### Oldham, Jeffrey D.
- ### 2001Nov27
- ### Pooma
- ###
- ### Produce Annotated Source Code
- 
- all: Doof2d-C-element-annotated.cpp Doof2d-Array-element-annotated.cpp \
-      Doof2d-Array-parallel-annotated.cpp Doof2d-Array-stencil-annotated.cpp \
-      Doof2d-Array-distributed-annotated.cpp
- 
- %-annotated.cpp: %-annotated.patch %.cpp
- 	patch -o $@ < $<
--- 0 ----

From oldham at codesourcery.com  Fri Jan  4 11:02:05 2002
From: oldham at codesourcery.com (Jeffrey Oldham)
Date: Fri, 4 Jan 2002 03:02:05 -0800
Subject: Manual Patch: Program Movements and Additions
Message-ID: <20020104030205.A13228@codesourcery.com>

This patch moves some existing program examples and adds some new short
program examples to the R2 manual.

2002-Jan-04  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* examples/Doof2d/Doof2d-Array-distributed-annotated.patch: Moved
	from '.'.
	* examples/Doof2d/Doof2d-Array-element-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Array-parallel-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Array-stencil-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-C-element-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Field-distributed-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Field-parallel-annotated.patch: Likewise.
	* examples/Doof2d/Makefile: Likewise.
	* examples/Sequential/Makefile: New file.
	* examples/Sequential/initialize-finalize-annotated.patch: New file.
	* examples/Templates/Makefile: New file.
	* examples/Templates/pairs-templated-annotated.patch: New file.
	* examples/Templates/pairs-untemplated-annotated.patch: New file.

Applied to mainline.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: examples/Doof2d/Doof2d-Array-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Array-distributed-annotated.patch
diff -N Doof2d-Array-distributed-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Array-distributed-annotated.patch	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,184 ----
+ *** Doof2d-Array-distributed.cpp	Wed Dec  5 14:04:36 2001
+ --- Doof2d-Array-distributed-annotated.cpp	Wed Dec  5 14:07:56 2001
+ ***************
+ *** 1,3 ****
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+   #include "Pooma/Arrays.h"	// has Pooma's Array
+   
+ --- 1,5 ----
+ ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+   #include "Pooma/Arrays.h"	// has Pooma's Array
+   
+ ***************
+ *** 14,18 ****
+     // (i,j).  The "C" template parameter permits use of this stencil
+     // operator with both Arrays and Fields.
+ !   template <class C>
+     inline
+     typename C::Element_t
+ --- 16,20 ----
+     // (i,j).  The "C" template parameter permits use of this stencil
+     // operator with both Arrays and Fields.
+ !   template &lt;class C&gt;
+     inline
+     typename C::Element_t
+ ***************
+ *** 42,46 ****
+     // canot use standard input and output.  Instead we use command-line
+     // arguments, which are replicated, for input, and we use an Inform
+ !   // stream for output.
+     Inform output;
+   
+ --- 44,48 ----
+     // canot use standard input and output.  Instead we use command-line
+     // arguments, which are replicated, for input, and we use an Inform
+ !   // stream for output.  <co id="tutorial-array_distributed-doof2d-io"></co>
+     Inform output;
+   
+ ***************
+ *** 48,52 ****
+     if (argc != 4) {
+       // Incorrect number of command-line arguments.
+ !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
+       return EXIT_FAILURE;
+     }
+ --- 50,54 ----
+     if (argc != 4) {
+       // Incorrect number of command-line arguments.
+ !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
+       return EXIT_FAILURE;
+     }
+ ***************
+ *** 55,63 ****
+     // Determine the number of processors.
+     long nuProcessors;
+ !   nuProcessors = strtol(argv[1], &tail, 0);
+   
+     // Determine the number of averagings.
+     long nuAveragings, nuIterations;
+ !   nuAveragings = strtol(argv[2], &tail, 0);
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ --- 57,65 ----
+     // Determine the number of processors.
+     long nuProcessors;
+ !   nuProcessors = strtol(argv[1], &amp;tail, 0);
+   
+     // Determine the number of averagings.
+     long nuAveragings, nuIterations;
+ !   nuAveragings = strtol(argv[2], &amp;tail, 0);
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ ***************
+ *** 65,69 ****
+     // the grid.
+     long n;
+ !   n = strtol(argv[3], &tail, 0);
+     // The dimension must be a multiple of the number of processors
+     // since we are using a UniformGridLayout.
+ --- 67,71 ----
+     // the grid.
+     long n;
+ !   n = strtol(argv[3], &amp;tail, 0);
+     // The dimension must be a multiple of the number of processors
+     // since we are using a UniformGridLayout.
+ ***************
+ *** 71,80 ****
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+     // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval<1> I(1,n-2);
+ !   Interval<2> interiorDomain(I,I);
+   
+     // Create the distributed arrays.
+ --- 73,82 ----
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+     // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;2&gt; interiorDomain(I,I);
+   
+     // Create the distributed arrays.
+ ***************
+ *** 83,98 ****
+     // dimension.  Guard layers optimize communication between patches.
+     // Internal guards surround each patch.  External guards surround
+ !   // the entire array domain.
+ !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
+ ! 				    GuardLayers<2>(1),  // internal
+ ! 				    GuardLayers<2>(0)); // external
+ !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
+   
+     // The template parameters indicate 2 dimensions and a 'double'
+     // element type.  MultiPatch indicates multiple computation patches,
+     // i.e., distributed computation.  The UniformTag indicates the
+ !   // patches should have the same size.  Each patch has Brick type.
+ !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
+ !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > b(layout);
+   
+     // Set up the initial conditions.
+ --- 85,100 ----
+     // dimension.  Guard layers optimize communication between patches.
+     // Internal guards surround each patch.  External guards surround
+ !   // the entire array domain.  <co id="tutorial-array_distributed-doof2d-layout"></co>
+ !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
+ ! 				    GuardLayers&lt;2&gt;(1),  // internal
+ ! 				    GuardLayers&lt;2&gt;(0)); // external
+ !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
+   
+     // The template parameters indicate 2 dimensions and a 'double'
+     // element type.  MultiPatch indicates multiple computation patches,
+     // i.e., distributed computation.  The UniformTag indicates the
+ !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
+ !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
+ !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; b(layout);
+   
+     // Set up the initial conditions.
+ ***************
+ *** 104,112 ****
+   
+     // Create the stencil performing the computation.
+ !   Stencil<DoofNinePt> stencil;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+ !     // Read from b.  Write to a.
+       a(interiorDomain) = stencil(b, interiorDomain);
+   
+ --- 106,114 ----
+   
+     // Create the stencil performing the computation.
+ !   Stencil&lt;DoofNinePt&gt; stencil;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+ !     // Read from b.  Write to a.  <co id="tutorial-array_distributed-doof2d-first_write"></co>
+       a(interiorDomain) = stencil(b, interiorDomain);
+   
+ ***************
+ *** 117,121 ****
+     // Print out the final central value.
+     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+     // The arrays are automatically deallocated.
+ --- 119,123 ----
+     // Print out the final central value.
+     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
+   
+     // The arrays are automatically deallocated.
+ ***************
+ *** 125,126 ****
+ --- 127,129 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: examples/Doof2d/Doof2d-Array-element-annotated.patch
===================================================================
RCS file: Doof2d-Array-element-annotated.patch
diff -N Doof2d-Array-element-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Array-element-annotated.patch	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,143 ----
+ *** Doof2d-Array-element.cpp	Tue Dec  4 12:02:10 2001
+ --- Doof2d-Array-element-annotated.cpp	Tue Dec  4 12:24:25 2001
+ ***************
+ *** 1,5 ****
+ ! #include <iostream>		// has std::cout, ...
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+ ! #include "Pooma/Arrays.h"	// has Pooma's Array
+   
+   // Doof2d: Pooma Arrays, element-wise implementation
+ --- 1,6 ----
+ ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+ ! #include "Pooma/Arrays.h"	// has Pooma's Array  <co id="tutorial-array_elementwise-doof2d-header"></co>
+   
+   // Doof2d: Pooma Arrays, element-wise implementation
+ ***************
+ *** 7,17 ****
+   int main(int argc, char *argv[])
+   {
+ !   // Prepare the Pooma library for execution.
+     Pooma::initialize(argc,argv);
+     
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout << "Please enter the number of averagings: ";
+ !   std::cin >> nuAveragings;
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ --- 8,18 ----
+   int main(int argc, char *argv[])
+   {
+ !   // Prepare the Pooma library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
+     Pooma::initialize(argc,argv);
+     
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout &openopen; "Please enter the number of averagings: ";
+ !   std::cin &closeclose; nuAveragings;
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ ***************
+ *** 19,37 ****
+     // the grid.
+     long n;
+ !   std::cout << "Please enter the array size: ";
+ !   std::cin >> n;
+   
+ !   // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+ !   // Create the arrays.
+     // The template parameters indicate 2 dimensions, a 'double' element
+     // type, and ordinary 'Brick' storage.
+ !   Array<2, double, Brick> a(vertDomain);
+ !   Array<2, double, Brick> b(vertDomain);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.
+     for (int j = 1; j < n-1; j++)
+       for (int i = 1; i < n-1; i++)
+ --- 20,38 ----
+     // the grid.
+     long n;
+ !   std::cout &openopen; "Please enter the array size: ";
+ !   std::cin &closeclose; n;
+   
+ !   // Specify the arrays' domains [0,n) x [0,n).  <co id="tutorial-array_elementwise-doof2d-domain"></co>
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+ !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
+     // The template parameters indicate 2 dimensions, a 'double' element
+     // type, and ordinary 'Brick' storage.
+ !   Array&lt;2, double, Brick&gt; a(vertDomain);
+ !   Array&lt;2, double, Brick&gt; b(vertDomain);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.  <co id="tutorial-array_elementwise-doof2d-initialization"></co>
+     for (int j = 1; j < n-1; j++)
+       for (int i = 1; i < n-1; i++)
+ ***************
+ *** 43,51 ****
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+       // Read from b.  Write to a.
+ !     for (int j = 1; j < n-1; j++)
+ !       for (int i = 1; i < n-1; i++)
+ !         a(i,j) = weight *
+             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
+              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
+ --- 44,52 ----
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+       // Read from b.  Write to a.
+ !     for (int j = 1; j &lt; n-1; j++)
+ !       for (int i = 1; i &lt; n-1; i++)
+ !         a(i,j) = weight *  <co id="tutorial-array_elementwise-doof2d-first_write"></co>
+             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
+              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
+ ***************
+ *** 53,58 ****
+   
+       // Read from a.  Write to b.
+ !     for (int j = 1; j < n-1; j++)
+ !       for (int i = 1; i < n-1; i++)
+           b(i,j) = weight *
+             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
+ --- 54,59 ----
+   
+       // Read from a.  Write to b.
+ !     for (int j = 1; j &lt; n-1; j++)
+ !       for (int i = 1; i &lt; n-1; i++)
+           b(i,j) = weight *
+             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
+ ***************
+ *** 62,71 ****
+   
+     // Print out the final central value.
+ !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+ !   // The arrays are automatically deallocated.
+   
+ !   // Tell the Pooma library execution has finished.
+     Pooma::finalize();
+     return EXIT_SUCCESS;
+   }
+ --- 63,74 ----
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
+   
+ !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
+   
+ !   // Tell the Pooma library execution has finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
+     Pooma::finalize();
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: examples/Doof2d/Doof2d-Array-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Array-parallel-annotated.patch
diff -N Doof2d-Array-parallel-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Array-parallel-annotated.patch	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,116 ----
+ *** Doof2d-Array-parallel.cpp	Tue Dec  4 11:49:43 2001
+ --- Doof2d-Array-parallel-annotated.cpp	Tue Dec  4 12:24:36 2001
+ ***************
+ *** 1,4 ****
+ ! #include <iostream>		// has std::cout, ...
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+   #include "Pooma/Arrays.h"	// has Pooma's Array
+   
+ --- 1,5 ----
+ ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+   #include "Pooma/Arrays.h"	// has Pooma's Array
+   
+ ***************
+ *** 12,17 ****
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout << "Please enter the number of averagings: ";
+ !   std::cin >> nuAveragings;
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ --- 13,18 ----
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout &openopen; "Please enter the number of averagings: ";
+ !   std::cin &closeclose; nuAveragings;
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ ***************
+ *** 19,43 ****
+     // the grid.
+     long n;
+ !   std::cout << "Please enter the array size: ";
+ !   std::cin >> n;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval<1> I(1,n-2);
+ !   Interval<1> J(1,n-2);
+   
+     // Create the arrays.
+     // The template parameters indicate 2 dimensions, a 'double' element
+     // type, and ordinary 'Brick' storage.
+ !   Array<2, double, Brick> a(vertDomain);
+ !   Array<2, double, Brick> b(vertDomain);
+   
+     // Set up the initial conditions.
+     // All grid values should be zero except for the central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+ --- 20,44 ----
+     // the grid.
+     long n;
+ !   std::cout &openopen; "Please enter the array size: ";
+ !   std::cin &closeclose; n;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) for computation.  <co id="tutorial-array_parallel-doof2d-innerdomain"></co>
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;1&gt; J(1,n-2);
+   
+     // Create the arrays.
+     // The template parameters indicate 2 dimensions, a 'double' element
+     // type, and ordinary 'Brick' storage.
+ !   Array&lt;2, double, Brick&gt; a(vertDomain);
+ !   Array&lt;2, double, Brick&gt; b(vertDomain);
+   
+     // Set up the initial conditions.
+     // All grid values should be zero except for the central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes before accessing a value.  <co id="tutorial-array_parallel-doof2d-blockAndEvaluate"></co>
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+ ***************
+ *** 47,52 ****
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+ !     // Read from b.  Write to a.
+       a(I,J) = weight *
+         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+ --- 48,53 ----
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+ !     // Read from b.  Write to a.  <co id="tutorial-array_parallel-doof2d-first_write"></co>
+       a(I,J) = weight *
+         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+ ***************
+ *** 63,67 ****
+     // Print out the final central value.
+     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+     // The arrays are automatically deallocated.
+ --- 64,68 ----
+     // Print out the final central value.
+     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
+   
+     // The arrays are automatically deallocated.
+ ***************
+ *** 71,72 ****
+ --- 72,74 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: examples/Doof2d/Doof2d-Array-stencil-annotated.patch
===================================================================
RCS file: Doof2d-Array-stencil-annotated.patch
diff -N Doof2d-Array-stencil-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Array-stencil-annotated.patch	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,152 ----
+ *** Doof2d-Array-stencil.cpp	Tue Dec  4 11:49:39 2001
+ --- Doof2d-Array-stencil-annotated.cpp	Tue Dec  4 12:26:46 2001
+ ***************
+ *** 1,9 ****
+ ! #include <iostream>		// has std::cout, ...
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+   #include "Pooma/Arrays.h"	// has Pooma's Array
+   
+   // Doof2d: Pooma Arrays, stencil implementation
+   
+ ! // Define the stencil class performing the computation.
+   class DoofNinePt
+   {
+ --- 1,10 ----
+ ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+   #include "Pooma/Arrays.h"	// has Pooma's Array
+   
+   // Doof2d: Pooma Arrays, stencil implementation
+   
+ ! // Define the stencil class performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
+   class DoofNinePt
+   {
+ ***************
+ *** 14,19 ****
+     // This stencil operator is applied to each interior domain position
+     // (i,j).  The "C" template parameter permits use of this stencil
+ !   // operator with both Arrays and Fields.
+ !   template <class C>
+     inline
+     typename C::Element_t
+ --- 15,20 ----
+     // This stencil operator is applied to each interior domain position
+     // (i,j).  The "C" template parameter permits use of this stencil
+ !   // operator with both Arrays and Fields.  <co id="tutorial-array_stencil-doof2d-stencil_operator"></co>
+ !   template &lt;class C&gt;
+     inline
+     typename C::Element_t
+ ***************
+ *** 26,30 ****
+     }
+   
+ !   inline int lowerExtent(int) const { return 1; }
+     inline int upperExtent(int) const { return 1; }
+   
+ --- 27,31 ----
+     }
+   
+ !   inline int lowerExtent(int) const { return 1; }  <co id="tutorial-array_stencil-doof2d-stencil_extent"></co>
+     inline int upperExtent(int) const { return 1; }
+   
+ ***************
+ *** 42,47 ****
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout << "Please enter the number of averagings: ";
+ !   std::cin >> nuAveragings;
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ --- 43,48 ----
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout &openopen; "Please enter the number of averagings: ";
+ !   std::cin &closeclose; nuAveragings;
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ ***************
+ *** 49,68 ****
+     // the grid.
+     long n;
+ !   std::cout << "Please enter the array size: ";
+ !   std::cin >> n;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+     // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval<1> I(1,n-2);
+ !   Interval<2> interiorDomain(I,I);
+   
+     // Create the arrays.
+     // The template parameters indicate 2 dimensions, a 'double' element
+     // type, and ordinary 'Brick' storage.
+ !   Array<2, double, Brick> a(vertDomain);
+ !   Array<2, double, Brick> b(vertDomain);
+   
+     // Set up the initial conditions.
+ --- 50,69 ----
+     // the grid.
+     long n;
+ !   std::cout &openopen; "Please enter the array size: ";
+ !   std::cin &closeclose; n;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+     // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;2&gt; interiorDomain(I,I);
+   
+     // Create the arrays.
+     // The template parameters indicate 2 dimensions, a 'double' element
+     // type, and ordinary 'Brick' storage.
+ !   Array&lt;2, double, Brick&gt; a(vertDomain);
+ !   Array&lt;2, double, Brick&gt; b(vertDomain);
+   
+     // Set up the initial conditions.
+ ***************
+ *** 73,82 ****
+     b(n/2,n/2) = 1000.0;
+   
+ !   // Create the stencil performing the computation.
+ !   Stencil<DoofNinePt> stencil;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+ !     // Read from b.  Write to a.
+       a(interiorDomain) = stencil(b, interiorDomain);
+   
+ --- 74,83 ----
+     b(n/2,n/2) = 1000.0;
+   
+ !   // Create the stencil performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil_creation"></co>
+ !   Stencil&lt;DoofNinePt&gt; stencil;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+ !     // Read from b.  Write to a.  <co id="tutorial-array_stencil-doof2d-first_write"></co>
+       a(interiorDomain) = stencil(b, interiorDomain);
+   
+ ***************
+ *** 87,91 ****
+     // Print out the final central value.
+     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+     // The arrays are automatically deallocated.
+ --- 88,92 ----
+     // Print out the final central value.
+     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
+   
+     // The arrays are automatically deallocated.
+ ***************
+ *** 95,96 ****
+ --- 96,98 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: examples/Doof2d/Doof2d-C-element-annotated.patch
===================================================================
RCS file: Doof2d-C-element-annotated.patch
diff -N Doof2d-C-element-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-C-element-annotated.patch	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,150 ----
+ *** Doof2d-C-element.cpp	Tue Nov 27 08:36:38 2001
+ --- Doof2d-C-element-annotated.cpp	Tue Nov 27 12:08:03 2001
+ ***************
+ *** 1,4 ****
+ ! #include <iostream>		// has std::cout, ...
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+   
+   // Doof2d: C-like, element-wise implementation
+ --- 1,5 ----
+ ! <programlisting id="tutorial-hand_coded-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+   
+   // Doof2d: C-like, element-wise implementation
+ ***************
+ *** 6,30 ****
+   int main()
+   {
+ !   // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout << "Please enter the number of averagings: ";
+ !   std::cin >> nuAveragings;
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ !   // Use two-dimensional grids of values.
+     double **a;
+     double **b;
+   
+     // Ask the user for the number n of elements along one dimension of
+ !   // the grid.
+     long n;
+ !   std::cout << "Please enter the array size: ";
+ !   std::cin >> n;
+   
+ !   // Allocate the arrays.
+     typedef double* doublePtr;
+     a = new doublePtr[n];
+     b = new doublePtr[n];
+ !   for (int i = 0; i < n; i++) {
+       a[i] = new double[n];
+       b[i] = new double[n];
+ --- 7,31 ----
+   int main()
+   {
+ !   // Ask the user for the number of averagings.  <co id="tutorial-hand_coded-doof2d-nuaveragings"></co>
+     long nuAveragings, nuIterations;
+ !   std::cout &openopen; "Please enter the number of averagings: ";
+ !   std::cin &closeclose; nuAveragings;
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ !   // Use two-dimensional grids of values.  <co id="tutorial-hand_coded-doof2d-array_storage"></co>
+     double **a;
+     double **b;
+   
+     // Ask the user for the number n of elements along one dimension of
+ !   // the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
+     long n;
+ !   std::cout &openopen; "Please enter the array size: ";
+ !   std::cin &closeclose; n;
+   
+ !   // Allocate the arrays.  <co id="tutorial-hand_coded-doof2d-allocation"></co>
+     typedef double* doublePtr;
+     a = new doublePtr[n];
+     b = new doublePtr[n];
+ !   for (int i = 0; i &lt; n; i++) {
+       a[i] = new double[n];
+       b[i] = new double[n];
+ ***************
+ *** 32,49 ****
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.
+ !   for (int j = 0; j < n; j++)
+ !     for (int i = 0; i < n; i++)
+         a[i][j] = b[i][j] = 0.0;
+     b[n/2][n/2] = 1000.0;
+   
+ !   // In the average, weight elements with this value.
+     const double weight = 1.0/9.0;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+ !     // Read from b.  Write to a.
+ !     for (int j = 1; j < n-1; j++)
+ !       for (int i = 1; i < n-1; i++)
+           a[i][j] = weight *
+             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
+ --- 33,50 ----
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.  <co id="tutorial-hand_coded-doof2d-initialization"></co>
+ !   for (int j = 0; j &lt; n; j++)
+ !     for (int i = 0; i &lt; n; i++)
+         a[i][j] = b[i][j] = 0.0;
+     b[n/2][n/2] = 1000.0;
+   
+ !   // In the average, weight elements with this value.  <co id="tutorial-hand_coded-doof2d-constants"></co>
+     const double weight = 1.0/9.0;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+ !     // Read from b.  Write to a.  <co id="tutorial-hand_coded-doof2d-first_write"></co>
+ !     for (int j = 1; j &lt; n-1; j++)
+ !       for (int i = 1; i &lt; n-1; i++)
+           a[i][j] = weight *
+             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
+ ***************
+ *** 51,57 ****
+              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
+   
+ !     // Read from a.  Write to b.
+ !     for (int j = 1; j < n-1; j++)
+ !       for (int i = 1; i < n-1; i++)
+           b[i][j] = weight *
+             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
+ --- 52,58 ----
+              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
+   
+ !     // Read from a.  Write to b.  <co id="tutorial-hand_coded-doof2d-second_write"></co>
+ !     for (int j = 1; j &lt; n-1; j++)
+ !       for (int i = 1; i &lt; n-1; i++)
+           b[i][j] = weight *
+             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
+ ***************
+ *** 60,68 ****
+     }
+   
+ !   // Print out the final central value.
+ !   std::cout << (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) << std::endl;
+   
+ !   // Deallocate the arrays.
+ !   for (int i = 0; i < n; i++) {
+       delete [] a[i];
+       delete [] b[i];
+ --- 61,69 ----
+     }
+   
+ !   // Print out the final central value.  <co id="tutorial-hand_coded-doof2d-answer"></co>
+ !   std::cout &openopen; (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) &openopen; std::endl;
+   
+ !   // Deallocate the arrays.  <co id="tutorial-hand_coded-doof2d-deallocation"></co>
+ !   for (int i = 0; i &lt; n; i++) {
+       delete [] a[i];
+       delete [] b[i];
+ ***************
+ *** 73,74 ****
+ --- 74,76 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: examples/Doof2d/Doof2d-Field-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Field-distributed-annotated.patch
diff -N Doof2d-Field-distributed-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Field-distributed-annotated.patch	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,176 ----
+ *** Doof2d-Field-distributed.cpp	Wed Dec  5 14:05:10 2001
+ --- Doof2d-Field-distributed-annotated.cpp	Wed Dec  5 14:41:24 2001
+ ***************
+ *** 1,3 ****
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+   #include "Pooma/Fields.h"	// has Pooma's Field
+   
+ --- 1,4 ----
+ ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+   #include "Pooma/Fields.h"	// has Pooma's Field
+   
+ ***************
+ *** 12,16 ****
+     // canot use standard input and output.  Instead we use command-line
+     // arguments, which are replicated, for input, and we use an Inform
+ !   // stream for output.
+     Inform output;
+   
+ --- 13,17 ----
+     // canot use standard input and output.  Instead we use command-line
+     // arguments, which are replicated, for input, and we use an Inform
+ !   // stream for output.  <co id="tutorial-field_distributed-doof2d-io"></co>
+     Inform output;
+   
+ ***************
+ *** 18,22 ****
+     if (argc != 4) {
+       // Incorrect number of command-line arguments.
+ !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
+       return EXIT_FAILURE;
+     }
+ --- 19,23 ----
+     if (argc != 4) {
+       // Incorrect number of command-line arguments.
+ !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
+       return EXIT_FAILURE;
+     }
+ ***************
+ *** 25,33 ****
+     // Determine the number of processors.
+     long nuProcessors;
+ !   nuProcessors = strtol(argv[1], &tail, 0);
+   
+     // Determine the number of averagings.
+     long nuAveragings, nuIterations;
+ !   nuAveragings = strtol(argv[2], &tail, 0);
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ --- 26,34 ----
+     // Determine the number of processors.
+     long nuProcessors;
+ !   nuProcessors = strtol(argv[1], &amp;tail, 0);
+   
+     // Determine the number of averagings.
+     long nuAveragings, nuIterations;
+ !   nuAveragings = strtol(argv[2], &amp;tail, 0);
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ ***************
+ *** 35,39 ****
+     // the grid.
+     long n;
+ !   n = strtol(argv[3], &tail, 0);
+     // The dimension must be a multiple of the number of processors
+     // since we are using a UniformGridLayout.
+ --- 36,40 ----
+     // the grid.
+     long n;
+ !   n = strtol(argv[3], &amp;tail, 0);
+     // The dimension must be a multiple of the number of processors
+     // since we are using a UniformGridLayout.
+ ***************
+ *** 41,50 ****
+   
+     // Specify the fields' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+     // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval<1> I(1,n-2);
+ !   Interval<1> J(1,n-2);
+   
+     // Partition the fields' domains uniformly, i.e., each patch has the
+ --- 42,51 ----
+   
+     // Specify the fields' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+     // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;1&gt; J(1,n-2);
+   
+     // Partition the fields' domains uniformly, i.e., each patch has the
+ ***************
+ *** 52,74 ****
+     // dimension.  Guard layers optimize communication between patches.
+     // Internal guards surround each patch.  External guards surround
+ !   // the entire field domain.
+ !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
+ ! 				    GuardLayers<2>(1),  // internal
+ ! 				    GuardLayers<2>(0)); // external
+ !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
+   
+     // Specify the fields' mesh, i.e., its spatial extent, and its
+ !   // centering type.
+ !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
+ !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
+   
+     // The template parameters indicate a mesh and a 'double'
+     // element type.  MultiPatch indicates multiple computation patches,
+     // i.e., distributed computation.  The UniformTag indicates the
+ !   // patches should have the same size.  Each patch has Brick type.
+ !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
+ !     Remote<Brick> > > a(cell, layout, mesh);
+ !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
+ !     Remote<Brick> > > b(cell, layout, mesh);
+   
+     // Set up the initial conditions.
+ --- 53,75 ----
+     // dimension.  Guard layers optimize communication between patches.
+     // Internal guards surround each patch.  External guards surround
+ !   // the entire field domain.  <co id="tutorial-field_distributed-doof2d-layout"></co>
+ !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
+ ! 				    GuardLayers&lt;2&gt;(1),  // internal
+ ! 				    GuardLayers&lt;2&gt;(0)); // external
+ !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
+   
+     // Specify the fields' mesh, i.e., its spatial extent, and its
+ !   // centering type.  <co id="tutorial-field_distributed-doof2d-mesh"></co>
+ !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
+ !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
+   
+     // The template parameters indicate a mesh and a 'double'
+     // element type.  MultiPatch indicates multiple computation patches,
+     // i.e., distributed computation.  The UniformTag indicates the
+ !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
+ !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
+ !     Remote&lt;Brick&gt; &gt; &gt; a(cell, layout, mesh);
+ !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
+ !     Remote&lt;Brick&gt; &gt; &gt; b(cell, layout, mesh);
+   
+     // Set up the initial conditions.
+ ***************
+ *** 83,87 ****
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+       // Read from b.  Write to a.
+       a(I,J) = weight *
+ --- 84,88 ----
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+       // Read from b.  Write to a.
+       a(I,J) = weight *
+ ***************
+ *** 99,103 ****
+     // Print out the final central value.
+     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+     // The fields are automatically deallocated.
+ --- 100,104 ----
+     // Print out the final central value.
+     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
+   
+     // The fields are automatically deallocated.
+ ***************
+ *** 107,108 ****
+ --- 108,110 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: examples/Doof2d/Doof2d-Field-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Field-parallel-annotated.patch
diff -N Doof2d-Field-parallel-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Field-parallel-annotated.patch	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,120 ----
+ *** Doof2d-Field-parallel.cpp	Tue Dec  4 10:01:28 2001
+ --- Doof2d-Field-parallel-annotated.cpp	Tue Dec  4 11:04:26 2001
+ ***************
+ *** 1,5 ****
+ ! #include <iostream>		// has std::cout, ...
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+ ! #include "Pooma/Fields.h"	// has Pooma's Field
+   
+   // Doof2d: Pooma Fields, data-parallel implementation
+ --- 1,6 ----
+ ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+ ! #include "Pooma/Fields.h"	// has Pooma's Field  <co id="tutorial-field_parallel-doof2d-header"></co>
+   
+   // Doof2d: Pooma Fields, data-parallel implementation
+ ***************
+ *** 12,17 ****
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout << "Please enter the number of averagings: ";
+ !   std::cin >> nuAveragings;
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ --- 13,18 ----
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout &openopen; "Please enter the number of averagings: ";
+ !   std::cin &closeclose; nuAveragings;
+     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ ***************
+ *** 19,44 ****
+     // the grid.
+     long n;
+ !   std::cout << "Please enter the field size: ";
+ !   std::cin >> n;
+   
+     // Specify the fields' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+     // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval<1> I(1,n-2);
+ !   Interval<1> J(1,n-2);
+   
+     // Specify the fields' mesh, i.e., its spatial extent, and its
+ !   // centering type.
+ !   DomainLayout<2> layout(vertDomain);
+ !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
+ !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
+   
+     // Create the fields.
+     // The template parameters indicate a mesh, a 'double' element
+ !   // type, and ordinary 'Brick' storage.
+ !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
+ !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
+   
+     // Set up the initial conditions.
+ --- 20,45 ----
+     // the grid.
+     long n;
+ !   std::cout &openopen; "Please enter the field size: ";
+ !   std::cin &closeclose; n;
+   
+     // Specify the fields' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+     // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;1&gt; J(1,n-2);
+   
+     // Specify the fields' mesh, i.e., its spatial extent, and its
+ !   // centering type.  <co id="tutorial-field_parallel-doof2d-mesh"></co>
+ !   DomainLayout&lt;2&gt; layout(vertDomain);
+ !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
+ !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
+   
+     // Create the fields.
+     // The template parameters indicate a mesh, a 'double' element
+ !   // type, and ordinary 'Brick' storage.  <co id="tutorial-field_parallel-doof2d-field_creation"></co>
+ !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
+ !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
+   
+     // Set up the initial conditions.
+ ***************
+ *** 51,56 ****
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+ !     // Read from b.  Write to a.
+       a(I,J) = weight *
+         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+ --- 52,57 ----
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+ !     // Read from b.  Write to a.  <co id="tutorial-field_parallel-doof2d-first_write"></co>
+       a(I,J) = weight *
+         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+ ***************
+ *** 67,71 ****
+     // Print out the final central value.
+     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+     // The fields are automatically deallocated.
+ --- 68,72 ----
+     // Print out the final central value.
+     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
+   
+     // The fields are automatically deallocated.
+ ***************
+ *** 75,76 ****
+ --- 76,78 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: examples/Doof2d/Makefile
===================================================================
RCS file: Makefile
diff -N Makefile
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Makefile	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,13 ----
+ ### Oldham, Jeffrey D.
+ ### 2001Nov27
+ ### Pooma
+ ###
+ ### Produce Annotated Source Code
+ 
+ all: Doof2d-C-element-annotated.cpp Doof2d-Array-element-annotated.cpp \
+      Doof2d-Array-parallel-annotated.cpp Doof2d-Array-stencil-annotated.cpp \
+      Doof2d-Array-distributed-annotated.cpp \
+      Doof2d-Field-parallel-annotated.cpp Doof2d-Field-distributed-annotated.cpp
+ 
+ %-annotated.cpp: %-annotated.patch %.cpp
+ 	patch -o $@ < $<
Index: examples/Sequential/Makefile
===================================================================
RCS file: Makefile
diff -N Makefile
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Makefile	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,10 ----
+ ### Oldham, Jeffrey D.
+ ### 2001Nov27
+ ### Pooma
+ ###
+ ### Produce Annotated Source Code
+ 
+ all: initialize-finalize-annotated.cpp
+ 
+ %-annotated.cpp: %-annotated.patch %.cpp
+ 	patch -o $@ < $<
Index: examples/Sequential/initialize-finalize-annotated.patch
===================================================================
RCS file: initialize-finalize-annotated.patch
diff -N initialize-finalize-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- initialize-finalize-annotated.patch	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,14 ----
+ *** initialize-finalize.cpp	Sat Dec 15 15:35:57 2001
+ --- initialize-finalize-annotated.cpp	Sun Dec 16 14:24:43 2001
+ ***************
+ *** 1,2 ****
+ --- 1,3 ----
+ + <programlisting id="initialize-finalize-program" linenumbering="numbered" format="linespecific">
+   #include "Pooma/Pooma.h"
+   
+ ***************
+ *** 10,11 ****
+ --- 11,13 ----
+     return 0;
+   }
+ + </programlisting>
Index: examples/Templates/Makefile
===================================================================
RCS file: Makefile
diff -N Makefile
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Makefile	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,10 ----
+ ### Oldham, Jeffrey D.
+ ### 2002Jan04
+ ### Pooma
+ ###
+ ### Produce Annotated Source Code
+ 
+ all: pairs-templated-annotated.cpp pairs-untemplated-annotated.cpp
+ 
+ %-annotated.cpp: %-annotated.patch %.cpp
+ 	patch -o $@ < $<
Index: examples/Templates/pairs-templated-annotated.patch
===================================================================
RCS file: pairs-templated-annotated.patch
diff -N pairs-templated-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- pairs-templated-annotated.patch	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,37 ----
+ *** pairs-templated.cpp	Wed Dec 26 14:01:38 2001
+ --- pairs-templated-annotated.cpp	Wed Dec 26 14:12:51 2001
+ ***************
+ *** 1,15 ****
+ ! // Declare a template class storing a pair of values with the same type.
+ ! template <typename T>
+   struct pair {
+ !   pair(const int& left, const int& right)
+       : left_(left), right_(right) {}
+   
+ !   T left_;
+     T right_;
+   };
+   
+ ! // Use a class storing a pair of integers.
+ ! pair<int> pair1;
+   
+   // Use a class storing a pair of doubles;
+ ! pair<double> pair2;
+ --- 1,17 ----
+ ! <programlisting id="template_programming-template_use-templated_pair_program" linenumbering="numbered" format="linespecific">
+ ! // Declare a template class storing a pair of values with the same type.  <co id="template_programming-template_use-templated_pair_program-template_declaration"></co>
+ ! template &lt;typename T&gt;
+   struct pair {
+ !   pair(const T&amp; left, const T&amp; right)  // <co id="template_programming-template_use-templated_pair_program-constructor"></co>
+       : left_(left), right_(right) {}
+   
+ !   T left_;  // <co id="template_programming-template_use-templated_pair_program-members"></co>
+     T right_;
+   };
+   
+ ! // Use a class storing a pair of integers. <co id="template_programming-template_use-templated_pair_program-use"></co>
+ ! pair&lt;int&gt; pair1;
+   
+   // Use a class storing a pair of doubles;
+ ! pair&lt;double&gt; pair2;
+ ! </programlisting>
Index: examples/Templates/pairs-untemplated-annotated.patch
===================================================================
RCS file: pairs-untemplated-annotated.patch
diff -N pairs-untemplated-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- pairs-untemplated-annotated.patch	Fri Jan  4 10:53:56 2002
***************
*** 0 ****
--- 1,35 ----
+ *** pairs-untemplated.cpp	Wed Dec 26 13:48:10 2001
+ --- pairs-untemplated-annotated.cpp	Wed Dec 26 14:02:58 2001
+ ***************
+ *** 1,5 ****
+   // Declare a class storing a pair of integers.
+   struct pairOfInts {
+ !   pairOfInts(const int& left, const int& right)
+       : left_(left), right_(right) {}
+   
+ --- 1,6 ----
+ + <programlisting id="template_programming-template_use-untemplated_pair_program" linenumbering="numbered" format="linespecific">
+   // Declare a class storing a pair of integers.
+   struct pairOfInts {
+ !   pairOfInts(const int&amp; left, const int&amp; right)
+       : left_(left), right_(right) {}
+   
+ ***************
+ *** 10,14 ****
+   // Declare a class storing a pair of doubles.
+   struct pairOfDoubles {
+ !   pairOfDoubles(const double& left, const double& right)
+       : left_(left), right_(right) {}
+   
+ --- 11,15 ----
+   // Declare a class storing a pair of doubles.
+   struct pairOfDoubles {
+ !   pairOfDoubles(const double&amp; left, const double&amp; right)
+       : left_(left), right_(right) {}
+   
+ ***************
+ *** 16,17 ****
+ --- 17,19 ----
+     double right_;
+   };
+ + </programlisting>

From oldham at codesourcery.com  Thu Jan 10 22:12:02 2002
From: oldham at codesourcery.com (Jeffrey Oldham)
Date: Thu, 10 Jan 2002 14:12:02 -0800
Subject: Index Domain Type
Message-ID: <200201102212.g0AMC2j17703@oz.codesourcery.com>


        Was the Index domain type removed?  Various comments refer to
it and there is a forward declaration, but I found no definition.

in Pooma's src/:

find . -name *.h -print | xargs -n 10 grep '[[:space:]]Index[^[:alpha:]]'
./Domain/Grid.h:// however, like Index does, so it cannot be used in any kind of tensor-like
./Domain/Interval.h:// however, like Index does, so it cannot be used in any kind of tensor-like
./Domain/Loc.h:// like Index does, so it cannot be used in any kind of tensor-like
./Domain/NewDomain.h:template<int Dim>               class Index;
./Domain/NewDomain.h://      of the slice = sum of dimensions of Interval, Range, Index objects
./Domain/Range.h:// however, like Index does, so it cannot be used in any kind of tensor-like
./Engine/DynamicEngine.h:  // Index of the first point.
./Engine/IndexFunctionEngine.h:// Index-function-engine objects provide a way to make a function of indices
./Pooma/Indices.h:  typedef typename ComponentView<Loc<1>, Iota_t>::Type_t Index_t;

Thanks for the information,
Jeffrey D. Oldham
oldham at codesourcery.com


From jcrotinger at proximation.com  Fri Jan 11 17:48:52 2002
From: jcrotinger at proximation.com (James Crotinger)
Date: Fri, 11 Jan 2002 10:48:52 -0700
Subject: [pooma-dev] Index Domain Type
Message-ID: <F871BB04B0EA224A821A5274C31DF315094248@proxim-sf001.santafe.proximation.com>

Index was never implemented. The notion of Index was a domain with position
information. In POOMA r1 you can do the following sort of thing:

  Index I, J;
  A[I][J] = B[J][I];

to assign the transpose of B to A. This does have some uses, but it adds a
lot of complexity, so we never put it in. 

  Jim

> -----Original Message-----
> From: Jeffrey Oldham [mailto:oldham at codesourcery.com]
> Sent: Thursday, January 10, 2002 3:12 PM
> To: pooma-dev at pooma.codesourcery.com
> Subject: [pooma-dev] Index Domain Type
> 
> 
> 
>         Was the Index domain type removed?  Various comments refer to
> it and there is a forward declaration, but I found no definition.
> 
> in Pooma's src/:
> 
> find . -name *.h -print | xargs -n 10 grep 
> '[[:space:]]Index[^[:alpha:]]'
> ./Domain/Grid.h:// however, like Index does, so it cannot be 
> used in any kind of tensor-like
> ./Domain/Interval.h:// however, like Index does, so it cannot 
> be used in any kind of tensor-like
> ./Domain/Loc.h:// like Index does, so it cannot be used in 
> any kind of tensor-like
> ./Domain/NewDomain.h:template<int Dim>               class Index;
> ./Domain/NewDomain.h://      of the slice = sum of dimensions 
> of Interval, Range, Index objects
> ./Domain/Range.h:// however, like Index does, so it cannot be 
> used in any kind of tensor-like
> ./Engine/DynamicEngine.h:  // Index of the first point.
> ./Engine/IndexFunctionEngine.h:// Index-function-engine 
> objects provide a way to make a function of indices
> ./Pooma/Indices.h:  typedef typename ComponentView<Loc<1>, 
> Iota_t>::Type_t Index_t;
> 
> Thanks for the information,
> Jeffrey D. Oldham
> oldham at codesourcery.com
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/pooma-dev/attachments/20020111/3725b5af/attachment.html>

From oldham at codesourcery.com  Fri Jan 11 20:01:13 2002
From: oldham at codesourcery.com (Jeffrey)
Date: Fri, 11 Jan 2002 12:01:13 -0800
Subject: Grid<N> and Monotonicity
Message-ID: <200201112001.g0BK1DX00941@vaio.codesourcery.com>


The comments in src/Domain/Grid.h describe a Grid<N> as "any ascending
or descending sequence."  When constructing a Grid<1> domain from an
IndirectionList<1> il, il's entries are not reordered to be ascending
or descending.  Will this cause any problems when using it?

This program demonstrates the lack of monotonicity:

    #include "Pooma/Pooma.h"
    #include "Pooma/Domains.h"
    #include <iostream>

    int main(int argc, char *argv[])
    {
      Pooma::initialize(argc,argv);

      IndirectionList<int> list(4);
      list(0) = 10;
      list(1) = 12;
      list(2) = 11;
      list(3) = 13;
      Grid<1> g(list);
      std::cout << g << std::endl;

      Pooma::finalize();
      return 0;
    }

Thanks for the information,
Jeffrey D. Oldham
oldham at codesourcery.com


From jcrotinger at proximation.com  Fri Jan 11 20:03:46 2002
From: jcrotinger at proximation.com (James Crotinger)
Date: Fri, 11 Jan 2002 13:03:46 -0700
Subject: [pooma-dev] Grid<N> and Monotonicity
Message-ID: <F871BB04B0EA224A821A5274C31DF31509424C@proxim-sf001.santafe.proximation.com>

I'm pretty sure that we want these to be monotonic. I don't know if we want
to reorder (would you order to ascending or descending?) or just assert.

  Jim


> -----Original Message-----
> From: Jeffrey [mailto:oldham at codesourcery.com]
> Sent: Friday, January 11, 2002 1:01 PM
> To: pooma-dev at pooma.codesourcery.com
> Subject: [pooma-dev] Grid<N> and Monotonicity
> 
> 
> 
> The comments in src/Domain/Grid.h describe a Grid<N> as "any ascending
> or descending sequence."  When constructing a Grid<1> domain from an
> IndirectionList<1> il, il's entries are not reordered to be ascending
> or descending.  Will this cause any problems when using it?
> 
> This program demonstrates the lack of monotonicity:
> 
>     #include "Pooma/Pooma.h"
>     #include "Pooma/Domains.h"
>     #include <iostream>
> 
>     int main(int argc, char *argv[])
>     {
>       Pooma::initialize(argc,argv);
> 
>       IndirectionList<int> list(4);
>       list(0) = 10;
>       list(1) = 12;
>       list(2) = 11;
>       list(3) = 13;
>       Grid<1> g(list);
>       std::cout << g << std::endl;
> 
>       Pooma::finalize();
>       return 0;
>     }
> 
> Thanks for the information,
> Jeffrey D. Oldham
> oldham at codesourcery.com
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/pooma-dev/attachments/20020111/cf9f47e6/attachment.html>

From oldham at codesourcery.com  Mon Jan 14 09:47:34 2002
From: oldham at codesourcery.com (Jeffrey Oldham)
Date: Mon, 14 Jan 2002 01:47:34 -0800
Subject: Patch: Remove Non-Existent 'Index' From Comments
Message-ID: <20020114014734.A10951@codesourcery.com>

2002-Jan-14  Jeffrey D. Oldham  <oldham at codesourcery.com>

	These changes remove mentions of the non-existent 'Index' type
	from comments.
	
	* Grid.h: Remove 'Index' from introductory comment.
	* Interval.h: Likewise.
	* Loc.h: Likewise.
	* NewDomain.h: Remove forward declaration for 'Index'.
	  Remove 'Index' from NewDomain'N' comment.
	* Range.h: Remove 'Index' from introductory comment.

Applied to      mainline
Not tested      since only comments were changed.
Approved by     Stephen Smith

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: Grid.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Grid.h,v
retrieving revision 1.12
diff -c -p -r1.12 Grid.h
*** Grid.h	2001/04/27 22:58:09	1.12
--- Grid.h	2002/01/11 22:46:43
***************
*** 76,84 ****
  // Grid<N> is a domain representing a set of N numeric sequences, one
  // for each dimension N.  The sequences are lists of ascending or descending
  // numbers, but without any fixed stride - the list for each dimension is
! // an IndirectionList<int>.  It does not have any concept of loop variables,
! // however, like Index does, so it cannot be used in any kind of tensor-like
! // expression.
  //
  // You can construct a Grid object using other domain objects.
  // The constructors accept up to 7 domain objects of various types.
--- 76,82 ----
  // Grid<N> is a domain representing a set of N numeric sequences, one
  // for each dimension N.  The sequences are lists of ascending or descending
  // numbers, but without any fixed stride - the list for each dimension is
! // an IndirectionList<int>.
  //
  // You can construct a Grid object using other domain objects.
  // The constructors accept up to 7 domain objects of various types.
Index: Interval.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Interval.h,v
retrieving revision 1.18
diff -c -p -r1.18 Interval.h
*** Interval.h	2001/04/27 22:58:13	1.18
--- Interval.h	2002/01/11 22:46:43
***************
*** 70,78 ****
  //
  // Interval<N> is a domain representing a set of N numeric sequences, one
  // for each dimension N.  The sequences have endpoints [a,b], and a
! // hard-coded stride of +1. It does not have any concept of loop variables,
! // however, like Index does, so it cannot be used in any kind of tensor-like
! // expression.
  //
  // You can construct an Interval object using other domain objects.
  // The constructors accept up to 7 domain objects of various types.
--- 70,76 ----
  //
  // Interval<N> is a domain representing a set of N numeric sequences, one
  // for each dimension N.  The sequences have endpoints [a,b], and a
! // hard-coded stride of +1.
  //
  // You can construct an Interval object using other domain objects.
  // The constructors accept up to 7 domain objects of various types.
Index: Loc.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Loc.h,v
retrieving revision 1.24
diff -c -p -r1.24 Loc.h
*** Loc.h	2001/04/13 02:12:59	1.24
--- Loc.h	2002/01/11 22:46:43
***************
*** 73,81 ****
  // Loc<N> is a domain representing a single N-dimensional point.  It has
  // a stride of one, endpoints which are the same, and a single element.
  // Otherwise, it acts very much like all other domain objects such as Range
! // or Interval.  It does not have any concept of loop variables, however,
! // like Index does, so it cannot be used in any kind of tensor-like
! // expression.
  //
  // You can construct a Loc object using other Loc objects or integers.
  // The constructor for Loc accepts up to 7 domain objects of various types.
--- 73,79 ----
  // Loc<N> is a domain representing a single N-dimensional point.  It has
  // a stride of one, endpoints which are the same, and a single element.
  // Otherwise, it acts very much like all other domain objects such as Range
! // or Interval.
  //
  // You can construct a Loc object using other Loc objects or integers.
  // The constructor for Loc accepts up to 7 domain objects of various types.
Index: NewDomain.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/NewDomain.h,v
retrieving revision 1.30
diff -c -p -r1.30 NewDomain.h
*** NewDomain.h	2001/04/13 02:12:59	1.30
--- NewDomain.h	2002/01/11 22:46:44
*************** template<int Dim>               class Lo
*** 70,76 ****
  template<int Dim>               class Interval;
  template<int Dim>               class Range;
  template<int Dim>               class Grid;
- template<int Dim>               class Index;
  template<int Dim>               class AllDomain;
  template<int Dim>               class LeftDomain;
  template<int Dim>               class RightDomain;
--- 70,75 ----
*************** struct CombineSliceDomain {
*** 337,343 ****
  //      a lower-dimensional subdomain of the complete domain.  Specifying
  //      a Loc or int for one or more of the dimensions in the operator() will
  //      result in that dimension being "sliced out", so that the total dim
! //      of the slice = sum of dimensions of Interval, Range, Index objects
  //      - sum dimensions of Loc and int objects.  If slice rules are used,
  //      and any Loc or int objects are being combined in, the resulting
  //      domain object will be a SliceDomain subclass (e.g., SliceInterval,
--- 336,342 ----
  //      a lower-dimensional subdomain of the complete domain.  Specifying
  //      a Loc or int for one or more of the dimensions in the operator() will
  //      result in that dimension being "sliced out", so that the total dim
! //      of the slice = sum of dimensions of Interval, Range objects
  //      - sum dimensions of Loc and int objects.  If slice rules are used,
  //      and any Loc or int objects are being combined in, the resulting
  //      domain object will be a SliceDomain subclass (e.g., SliceInterval,
Index: Range.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Range.h,v
retrieving revision 1.19
diff -c -p -r1.19 Range.h
*** Range.h	2001/04/27 22:58:17	1.19
--- Range.h	2002/01/11 22:46:44
*************** void fillRangeScalar(Range<Dim> &r, cons
*** 76,84 ****
  //
  // Range<N> is a domain representing a set of N numeric sequences, one
  // for each dimension N.  The sequences have endpoints [a,b], with a stride
! // s. It does not have any concept of loop variables,
! // however, like Index does, so it cannot be used in any kind of tensor-like
! // expression.
  //
  // You can construct a Range object using other domain objects.
  // The constructors accept up to 7 domain objects of various types.
--- 76,82 ----
  //
  // Range<N> is a domain representing a set of N numeric sequences, one
  // for each dimension N.  The sequences have endpoints [a,b], with a stride
! // s.
  //
  // You can construct a Range object using other domain objects.
  // The constructors accept up to 7 domain objects of various types.

From mark at codesourcery.com  Mon Jan 14 17:48:17 2002
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 14 Jan 2002 09:48:17 -0800
Subject: [pooma-dev] Grid<N> and Monotonicity
In-Reply-To: <F871BB04B0EA224A821A5274C31DF31509424C@proxim-sf001.santafe.proximation.com>
Message-ID: <16030000.1011030497@gandalf.codesourcery.com>



--On Friday, January 11, 2002 01:03:46 PM -0700 James Crotinger 
<jcrotinger at proximation.com> wrote:

>
> I'm pretty sure that we want these to be monotonic. I don't know if we
> want to reorder (would you order to ascending or descending?) or just
> assert.

I think we should just assert.  The programmer should sort before
setting this up.

My two cents,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From oldham at codesourcery.com  Tue Jan 15 17:53:19 2002
From: oldham at codesourcery.com (Jeffrey Oldham)
Date: Tue, 15 Jan 2002 09:53:19 -0800
Subject: Pooma Manual: Array and Domain Chapter
Message-ID: <20020115095319.A8680@codesourcery.com>

This patch finishes the first draft of the Array and Domain chapter of
the Pooma manual.

2002-Jan-15  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* arrays.xml: New file containing the Array and Domain chapter.
	* concepts.xml: Add glossary links to "index" entry.
	* manual.xml: Replace "bookCap" entity with "bookcap".  Add "dim",
	"domaintemplate", and "float" entities.  Move Array (and Domain)
	chapter to new file 'arrays.xml'.

Applied to	mainline
Approved by	me!

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: arrays.xml
===================================================================
RCS file: arrays.xml
diff -N arrays.xml
*** /dev/null	Fri Mar 23 21:37:44 2001
--- arrays.xml	Tue Jan 15 17:48:34 2002
***************
*** 0 ****
--- 1,1738 ----
+   <chapter id="arrays">
+    <title>&array; Containers</title>
+ 
+    <para>A container is a class holding objects.  &array;s are one of
+    the two most widely used &pooma; containers since they model the
+    mathematical concept of mapping indices from domains to values.
+    &pooma; &array;s extend built-in &cc; arrays by supporting a wider
+    variety of domains, automatically handling memory allocations, and
+    supporting first-class status.  For example, they may be used as
+    operands and in assignments.  In this chapter, we introduce the
+    concept of containers, the mathematical concept of arrays, and the
+    &pooma; concept for &array;s.  Before illustrating how to declare
+    &array;s, we introduce &domain;s, which specify the sets of
+    indices.  After describing how to declare the various types of
+    &domain;s, we describe how to declare and use &array;s.  This is
+    illustrated in a &doof2d; implementation using &array;s.  We end
+    with a description of their implementation.</para>
+ 
+ 
+    <section id="arrays-containers">
+     <title>Containers</title>
+ 
+     <para>A <glossterm
+     linkend="glossary-container"><firstterm>container class
+     expression</firstterm></glossterm> is a class with the main
+     purpose of holding objects.  These stored objects, called
+     <glossterm linkend="glossary-container_value"><firstterm>container
+     values</firstterm></glossterm> or more simply
+     <quote>values</quote> or elements<quote></quote>, may be accessed
+     and changed, usually using indices.  <quote>Container
+     class</quote> is usually abbreviated
+     <quote>container</quote>.</para>
+ 
+     <para>The six &pooma; containers can be categorized into two
+     groups.  Mathematical containers include &tensor;s, &matrix;s, and
+     &vector;s, modeling tensors, matrices, and vectors, respectively.
+     Storage containers include &array;s, &dynamicarray;s, and
+     &field;s.  In this chapter, we focus on simplest of these:
+     &array;s.  The other containers will be described in subsequent
+     chapters.</para>
+ 
+     <para>&c;&nbsp;has built-in arrays, and the &cc; Standard Library
+     provides <type>map</type>s, <type>vector</type>s,
+     <type>stack</type>s, and other containers, but the &pooma;
+     containers better model scientific computing concepts and provide
+     more functionality.  They automatically handle memory allocation
+     and deallocation and can be used in expressions and on the
+     left-hand side of assignments.  Since &pooma; containers separate
+     the container concepts of accessing and using values from storing
+     values, value storage can be optimized to specific needs.  For
+     example, if most of an &array;'s values are known to be the same
+     most of the time, a compressible engine can be used.  Whenever all
+     the array's values are the same, it stores only one value.  At
+     other times, it stores all the values.  Engines will be discussed
+     in <xref linkend="engines"></xref>.</para>
+    </section>
+ 
+ 
+    <section id="arrays-arrays">
+     <title>&array;s</title>
+ 
+     <para>Mathematically, an array maps indices from a domain to
+     values.  Usually, the domain consists of a one-dimensional
+     integral interval or it may be multidimensional.  &pooma;'s
+     &array; container class implements this idea.  Given an index,
+     i.e., a position in an &array;'s &domain;, it returns the associated
+     value, either by returning a stored value or by computing it.  The
+     use of indices, which are usually integral tuples but need not be
+     zero-based or even consist of all possible integral tuples in a
+     multidimensional range.  Using indices permits constant-time
+     access to values although computing a particular value may require
+     significant time.</para>
+ 
+     <para>&pooma; &array;s are <glossterm
+     linkend="glossary-first_class">first-class
+     types<firstterm></firstterm></glossterm> so they can be used more
+     widely than built-in &cc; arrays.  For example, &array;s can be
+     used as operands and in assignment statements.  The statement
+     <statement>a = a + b;</statement> adds corresponding elements of
+     &array;s <varname>a</varname> and <varname>b</varname>, assigning
+     the sums to the &array; <varname>a</varname>.  The statement
+     treats each array as one object, rather than requiring the use of
+     one or more loops to access individual values.  Data-parallel
+     statements are further discussed in <xref
+     linkend="data_parallel"></xref>.  &array;s also handle their own
+     memory allocation and deallocation.  For example, the &array;
+     declaration <statement>Array&lt;2, double, Brick&gt;
+     a(vertDomain)</statement> creates an
+     &array;&nbsp;<varname>a</varname>, allocating whatever memory it
+     needs.  When <varname>a</varname> goes out of scope, it and its
+     memory is automatically deallocated.  Automatic memory allocation
+     and deallocation also eases copying.  As we mentioned above, an
+     &array;'s &engine; stores or computes its values so it, not the
+     &array; itself, is responsible for memory allocation and
+     deallocation.  Fortunately, this distinction is usually hidden
+     from the &pooma; user.</para>
+ 
+     <para>Individual &array; values can be accessed using parentheses,
+     not square brackets, as for &cc; arrays.  For example,
+     <statement>a(3,4)</statement> yields the value at position (3,4)
+     of <varname>a</varname>'s two-dimensional domain.</para>
+    </section>
+ 
+ 
+    <section id="arrays-domains">
+     <title>&domain;s</title>
+ 
+     <para>A <glossterm
+     linkend="glossary-domain"><firstterm>domain</firstterm></glossterm>
+     specifies the set of points on which an &array; can define values.
+     These indices are the arguments placed within parentheses when
+     selecting particular values, as described previously.  A domain
+     supported both by &array;s and by built-in &cc; arrays is an
+     interval [0,n-1] of integers containing all integers {0, 1, 2,
+     &hellip;, n-1}.  For &cc;, every integer in the interval must be
+     included, and the minimum index must be zero.  &pooma; expands the
+     set of permissible domains to support intervals with nonzero
+     minimal indices and strides and by adding other choices.</para>
+ 
+     <para>In &pooma;, &domain;s implement domains.  There are four
+     different categories:
+      <variablelist>
+       <varlistentry>
+        <term>&loc;</term>
+        <listitem>
+ 	<para>&domain; with a single point.</para>
+        </listitem>
+       </varlistentry>
+       <varlistentry>
+        <term>&interval;</term>
+        <listitem>
+ 	<para>&domain; with an integral interval [a,b].</para>
+        </listitem>
+       </varlistentry>
+       <varlistentry>
+        <term>&range;</term>
+        <listitem>
+ 	<para>&domain; with an integral interval [a,b] and an integral
+ 	stride&nbsp;s indicating the gap between indices: {a, a+s,
+ 	a+2s, &hellip;, b}.</para>
+        </listitem>
+       </varlistentry>
+       <varlistentry>
+        <term>&grid;</term>
+        <listitem>
+ 	<para>&domain; with an ascending or descending sequence of
+ 	integral values.  The sequence elements must be individually
+ 	specified.</para>
+        </listitem>
+       </varlistentry>
+      </variablelist>
+     One-dimensional and multidimensional versions of each categories
+     are supported.  A multidimensional &domain; consists of the direct
+     product of one-dimensional &domain;s.  For example, the first
+     dimension of a two-dimensional interval [0,3]x[2,9] is the
+     interval&nbsp;[0,3], and its second dimension is the
+     interval&nbsp;[2,9].  Its indices are ordered pairs such as (0,2),
+     (0,3), (1,2), (1,9), and&nbsp;(3,7).</para>
+ 
+     <para>Many domains can be represented using domain triplets.  A
+     <glossterm linkend="glossary-domain_triplet"><firstterm>domain
+     triplet</firstterm></glossterm>
+     [<varname>begin</varname>:<varname>end</varname>:<varname>stride</varname>]
+     represents the mathematical set {begin, begin + stride, begin +
+     2stride, &hellip;, end}, where <varname>end</varname> is in the
+     set only if it equals <varname>begin</varname> plus some integral
+     multiple of <varname>stride</varname>.  If the
+     <varname>stride</varname> is negative, its beginning index
+     <varname>begin</varname> should at least be as large as
+     <varname>end</varname> if the interval is to be nonempty.  The
+     stride can be zero only if <varname>begin</varname> and
+     <varname>end</varname> are equal.  There are lots of ways to
+     represent an empty interval, e.g., [1:0:1] and [23,34,-1], and
+     &pooma; will accept them, but they are all equivalent.  The domain
+     triplet notation is easily extended to multiple dimensions by
+     separating different dimension's intervals with commas.  For
+     example, [2:4:2,6:4:-2] contains (2,6), (2,4), (4,6),
+     and&nbsp;(4,4).</para>
+ 
+     <para>All the &domain; categories listed above except &grid; can be
+     represented using domain triplet notation.  Since the triplet
+     [7:7:1] represents {7}, or more simply&nbsp;7, it can also
+     represent <statement>Loc<1>(7)</statement>.  Multidimensional
+     &loc;s are similarly represented.  For example,
+     [0:0:1,10:10:1,2:2:1] represents
+     <statement>Loc<3>(0,10,2)</statement>, but it is frequently
+     abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
+     [a:b:1], while a &range; has specific stride&nbsp;s:
+     [a:b:s].</para>
+ 
+     <para>&domain;s can be constructed by combining &domain;s of smaller
+     dimension.  For example, since a two-dimensional &interval; is the
+     direct product of two one-dimensional &interval;s, it can be
+     specified using two one-dimensional &interval;s.  For example,
+     <statement>Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
+     Interval&lt;1&gt;(4,5))</statement> creates a [2:3:1,4:5:1]
+     &domain;.  The resulting dimensionality equals the sum of the
+     components' dimensions.  For example, a four-dimension &loc; can
+     be specified using three- and one-dimension &loc;s or using four
+     one-dimension &loc;s.  If fewer dimensions than the created
+     object's dimensionality, the last dimensions are unspecified and
+     uninitialized.  &loc;s, &interval;s, &range;s, and &grid;s can all
+     be composed from smaller similar components.</para>
+ 
+     <para>A &domain; can be composed from smaller components with
+     different types.  A &loc; object can be constructed from other
+     &loc; objects and integers.  &interval;s, &range;s, and &grid;s
+     can be constructed using any of these types, &loc;s, and integers.
+     For example, <statement>Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2),
+     Interval&lt;1&gt;(3,5))</statement> uses a two-dimensional &loc;
+     and a one-dimensional &interval; to create a [1:1:1,2:2:1,3:5:1]
+     &domain;.  During creation of a &domain;, the type of each object
+     is changed to the &domain;'s type.  In the example,
+     <statement>Loc&lt;2&gt;(1,2)</statement> is first converted to an
+     &interval;.</para>
+ 
+     <para>&domain;s can participate in some arithmetic and comparison
+     operations.  For example, a &domain;'s triplet can be shifted two
+     units to the right by adding two.  Multiplying a &domain; by two
+     multiplies its triplet's beginnings, endings, and strides by two.
+     &pooma; users rarely need to compare &domain;s, but we describe
+     operating with the less-than operator on &interval;s.  &interval;
+     <varname>d1</varname> &lt; &interval; <varname>d2</varname> if the
+     length of <varname>d1's</varname> interval is less than
+     <varname>d2</varname>'s or, if equal, its beginning value is
+     smaller.  &domain; arithmetic is frequently used with data-parallel
+     statements and container views.  These will be discussed in <xref
+     linkend="data_parallel"></xref> and <xref
+     linkend="views"></xref>.</para>
+ 
+     <para>The current &pooma; implementation supports &domain;s with
+     dimensionality between one and seven, inclusive.  Since most
+     scientific computations use one, two, or three dimensions, this is
+     usually sufficient.  If more dimensions are needed, they can be
+     added to the source code.</para>
+    </section>
+ 
+ 
+    <section id="arrays-domains_declarations">
+     <title>Declaring &domain;s</title>
+ 
+     <para>Since &domain;s are mainly used to declare container
+     domains, we focus on declaring &domain;s.  Arithmetic operations
+     with &domain;s are described in <xref
+     linkend="views"></xref>.</para>
+ 
+     <para>All &domain; declarations require a dimension template
+     parameter&nbsp;<varname>&dim;</varname>.  This positive integer
+     specifies the number of dimensions, i.e., rank, of the &domain; and
+     determines the length of the tuples for points in the &domain;.  For
+     example, a three-dimensional &domain; contains ordered triples,
+     while a one-dimensional &domain; contains singletons, or just
+     integers.  Multidimensional &domain;s are just the direct products
+     of one-dimensional &domain;s so the techniques for declaring
+     one-dimensional &domain;s carry over to multi-dimensional
+     ones.</para>
+ 
+     <para>To declare a &domain;, one must include the
+     <filename class="headerfile">Pooma/Domains.h</filename> header
+     file.  However, most &pooma; programs declare &domain;s to use them
+     when constructing containers.  The container header files
+     automatically include <filename
+     class="headerfile">Pooma/Domains.h</filename> so no explicit
+     inclusion is usually necessary.</para>
+ 
+     <section id="arrays-domains_declarations-loc">
+      <title>&loc;s</title>
+ 
+      <para>A <type>Loc&lt;&dim;&gt;</type> is a &domain; with just a single
+      <varname>&dim;</varname>-dimensional point.  Although it is
+      infrequently used as a container's domain, it is used to refer to
+      a single point within another domain.  Its beginning and ending
+      points are the same, and its stride is one.  One-dimensional
+      &loc;s and integers are frequently interchanged.</para>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0" id="arrays-domains_declarations-loc-one_d_table">
+       <title>Declaring One-Dimensional &loc;s</title>
+      
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>constructor</entry>
+ 	 <entry>result</entry>
+ 	</row>
+        </thead>
+        <tfoot>
+ 	<row>
+ 	 <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
+ 	 <varname>&domaintemplate;3</varname> are template parameters.</entry>
+ 	 <entry></entry>
+ 	</row>
+        </tfoot>
+        <tbody>
+ 	<row>
+ 	 <entry><statement>Loc&lt;1&gt;()</statement></entry>
+ 	 <entry>points to zero.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
+ 	 <entry>creates an uninitialized &locone;, to be assigned a value later.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
+ 	 <entry>creates a &locone; with the integer converted from <varname>t1</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
+ 	 <entry>creates a &locone; with the integer converted from
+ 	 <varname>t1</varname>.  <varname>t2</varname> must equal
+ 	 <varname>t1</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
+ 	 <entry>creates a &locone; with the integer converted from
+ 	 <varname>t1</varname>.  <varname>t2</varname> must equal
+ 	 <varname>t1</varname>, and <varname>t3</varname> is
+ 	 ignored.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+ 
+      <para>Constructors for one-dimensional &loc;s appear in <xref
+      linkend="arrays-domains_declarations-loc-one_d_table"></xref>.
+      The empty constructor yields the zero point.  The constructor
+      taking a <type>Pooma::Init</type> object does not initialize the
+      resulting &loc; to any particular value.  Presumably, the value
+      will be assigned later.  For small &domain;s such as &loc;s, the
+      time savings from not initializing is small, but the
+      functionality is still available.  The constructor taking one
+      argument with type&nbsp;<type>&domaintemplate;1</type> converts this argument to
+      an integer to specify the point.  The template
+      type&nbsp;<type>&domaintemplate;1</type> may be any type that can be converted
+      to an integer, e.g., &bool;, &char;, &int;, or &double;.  The
+      constructors taking two and three arguments of templatized types
+      facilitate converting an &interval; and a &range; into a &loc;.
+      Since a &loc; represents a single point, the &interval;'s or
+      &range;'s first two arguments must be equal.  The stride is
+      ignored.  Again, the templatized types may be any type that can
+      be converted into an integer.</para>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0" id="arrays-domains_declarations-loc-multi_d_table">
+       <title>Declaring Multidimensional &loc;s</title>
+      
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>constructor</entry>
+ 	 <entry>result</entry>
+ 	</row>
+        </thead>
+        <tfoot>
+ 	<row>
+ 	 <entry><varname>&dim;</varname> indicates the &loc;'s dimension.
+ 	 <varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, &hellip; are
+ 	 template parameters.</entry>
+ 	</row>
+        </tfoot>
+        <tbody>
+ 	<row>
+ 	 <entry><statement>Loc&lt;&dim;&gt;()</statement></entry>
+ 	 <entry>points to zero.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
+ 	 <entry>creates an uninitialized &loc;, to be assigned a value later.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
+ 	 <entry>creates a &loc; using the given &domain; object.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
+ 	 <entry>creates a &loc; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
+ 	 <entry>creates a &loc; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
+ 	 <entry>creates a &loc; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5)</statement></entry>
+ 	 <entry>creates a &loc; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6)</statement></entry>
+ 	 <entry>creates a &loc; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
+ 	 <entry>creates a &loc; using the given &domain; objects.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+ 
+      <para>Constructors for multidimensional &loc;s appear in <xref
+      linkend="arrays-domains_declarations-loc-multi_d_table"></xref>.
+      <varname>&dim;</varname>&nbsp;indicates the &loc;'s dimension.  The
+      first two constructors are similar to &locone;'s first two
+      constructors, returning a representation of the zero point and
+      returning an uninitialized point.  The seven other constructors
+      create a &loc; using other &domain; objects.  These &domain; objects,
+      having types <type>&domaintemplate;1</type>, &hellip;, <type>&domaintemplate;7</type>, can have
+      any type that can be converted into an integer, to a &locone;, or
+      to a multidimensional &domain; object that itself can be converted
+      into a &loc;.  The total dimensionality of all the arguments'
+      types should be at most&nbsp;<varname>&dim;</varname>.  For example,
+      <statement>Loc<5>(Range<1>(2,2,2), Loc<2>(2,3),
+      Interval<1>(4,4))</statement> creates a five-dimensional &loc;
+      [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
+      &loc;, and a one-dimensional &interval;.  The final fifth
+      dimension has an unspecified value, in this case&nbsp;1.  The
+      one-dimensional &range; is converted into the single integer two;
+      its beginning and ending points must be the same.  The
+      two-dimensional &loc; contributes values for the next two
+      dimensions, while the &interval; contributes its beginning point,
+      which must be the same as its ending point.  Note that the
+      &locone; constructors taking two and three parameters ignore
+      their second and third arguments, but this is not true for the
+      multidimensional constructors.</para>
+     </section>
+ 
+ 
+     <section id="arrays-domains_declarations-intervals">
+      <title>&interval;s</title>
+ 
+      <para>A one-dimensional &interval; represents a set of integers
+      within a mathematical <glossterm
+      linkend="glossary-interval">interval</glossterm>.
+      Multidimensional &interval;s represent their multidimensional
+      generalization, i.e., the direct product of one-dimensional
+      intervals.  &interval;s are arguably the most commonly used
+      &pooma; &domain;.  A one-dimensional &interval; has integral
+      beginning and ending points and a unit stride.</para>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0" id="arrays-domains_declarations-interval-one_d_table">
+       <title>Declaring One-Dimensional &interval;s</title>
+      
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>constructor</entry>
+ 	 <entry>result</entry>
+ 	</row>
+        </thead>
+        <tfoot>
+ 	<row>
+ 	 <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
+ 	 <varname>&domaintemplate;3</varname> are template parameters.</entry>
+ 	 <entry></entry>
+ 	</row>
+        </tfoot>
+        <tbody>
+ 	<row>
+ 	 <entry><statement>Interval&lt;1&gt;()</statement></entry>
+ 	 <entry>creates an empty, uninitialized interval.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
+ 	 <entry>creates an uninitialized &intervalone;, to be assigned a value later.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
+ 	 <entry>creates a &intervalone;.  See the text for an explanation.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
+ 	 <entry>creates a &intervalone; with the integers converted from
+ 	 <varname>t1</varname> and <varname>t2</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
+ 	 <entry>creates a &intervalone; with the integers converted from
+ 	 <varname>t1</varname> and <varname>t2</varname>.
+ 	 <varname>t3</varname> must equal&nbsp;1.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+ 
+      <para>&intervalone; constructors are patterned on &locone;
+      constructors except that &intervalone;s can have differing
+      beginning and ending points.  See <xref
+      linkend="arrays-domains_declarations-interval-one_d_table"></xref>.
+      The default constructor creates an empty, uninitialized interval,
+      which should not be used before assigning it values.  If the
+      one-parameter constructor's argument is a &domain; object, it must
+      be a one-dimensional &domain; object which is copied into an
+      &interval; if possible; for example, it must have unit stride.
+      If the one-parameter constructor's argument is not a &domain;
+      object, it must be convertible to an
+      integer&nbsp;<varname>e</varname> and an interval [0:e-1:1]
+      starting at zero is constructed.  If two arguments are specified,
+      they are assumed to be convertible to integers
+      <varname>b</varname> and <varname>e</varname>, specifying the
+      interval [b:e:1].  The three-parameter constructor is similar,
+      with the third argument specifying a stride, which must be
+      one.</para>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0" id="arrays-domains_declarations-intervals-multi_d_table">
+       <title>Declaring Multidimensional &interval;s</title>
+      
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>constructor</entry>
+ 	 <entry>result</entry>
+ 	</row>
+        </thead>
+        <tfoot>
+ 	<row>
+ 	 <entry><varname>&dim;</varname> indicates the &interval;'s dimension.
+ 	 <varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, &hellip; are
+ 	 template parameters.</entry>
+ 	</row>
+        </tfoot>
+        <tbody>
+ 	<row>
+ 	 <entry><statement>Interval&lt;&dim;&gt;()</statement></entry>
+ 	 <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
+ 	 <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
+ 	 <entry>creates a &interval; using the given &domain; object.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
+ 	 <entry>creates a &interval; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
+ 	 <entry>creates a &interval; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
+ 	 <entry>creates a &interval; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5)</statement></entry>
+ 	 <entry>creates a &interval; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6)</statement></entry>
+ 	 <entry>creates a &interval; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
+ 	 <entry>creates a &interval; using the given &domain; objects.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+ 
+      <para>Constructors for multidimensional &interval;s closely
+      follow constructors for multidimensional &loc;s.  See <xref
+      linkend="arrays-domains_declarations-intervals-multi_d_table"></xref>.
+      <varname>&dim;</varname>&nbsp;indicates the &interval;'s
+      dimension.  The first two constructors both return empty,
+      uninitialized intervals.  The seven other constructors create an
+      &interval; using &domain; objects.  These &domain; objects,
+      having types <type>&domaintemplate;1</type>, &hellip;,
+      <type>&domaintemplate;7</type>, can have any type that can be
+      converted into an integer, into a single-dimensional &domain;
+      object that can be converted into a single-dimensional
+      &interval;, or to a multidimensional &domain; object that itself
+      can be converted into an &interval;.  The total dimensionality of
+      all the arguments' types should be at
+      most&nbsp;<varname>&dim;</varname>.  One-dimensional &domain;
+      objects that can be converted into one-dimensional &interval;s
+      include &locone;s, &intervalone;s, and &rangeone;s with unit
+      strides.  If the sum of the objects' dimensions is less
+      than&nbsp;<varname>&dim;</varname>, the intervals for the final
+      dimensions are unspecified.  See the last paragraph of <xref
+      linkend="arrays-domains_declarations-loc"></xref> for an
+      analogous example.  Note that the &intervalone; constructors
+      taking two and three parameters treat these arguments differently
+      than the multidimensional constructors do.</para>
+     </section>
+ 
+ 
+     <section id="arrays-domains_declarations-ranges">
+      <title>&range;s</title>
+ 
+      <para>A one-dimensional &range; generalizes an &interval; by
+      permitting a non-unit stride between integral members.  A
+      <glossterm
+      linkend="glossary-range"><firstterm>range</firstterm></glossterm>
+      is a set of integers in a mathematical interval [b,e] with a
+      stride&nbsp;s between them: {a, a+s, a+2s, &hellip;, b}.  Ranges
+      are generalized to <varname>&dim;</varname>&nbsp;dimensions using the
+      direct product of one-dimensional ranges.</para>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0" id="arrays-domains_declarations-range-one_d_table">
+       <title>Declaring One-Dimensional &range;s</title>
+      
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>constructor</entry>
+ 	 <entry>result</entry>
+ 	</row>
+        </thead>
+        <tfoot>
+ 	<row>
+ 	 <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
+ 	 <varname>&domaintemplate;3</varname> are template parameters.</entry>
+ 	 <entry></entry>
+ 	</row>
+        </tfoot>
+        <tbody>
+ 	<row>
+ 	 <entry><statement>Range&lt;1&gt;()</statement></entry>
+ 	 <entry>creates an empty, uninitialized range.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
+ 	 <entry>creates an uninitialized &rangeone;, to be assigned a value later.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
+ 	 <entry>creates a &rangeone;.  See the text for an explanation.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
+ 	 <entry>creates a &rangeone; with an interval specified by the
+ 	 integers converted from <varname>t1</varname> and
+ 	 <varname>t2</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
+ 	 <entry>creates a &rangeone; by converting the arguments to
+ 	 integers <varname>i1</varname>, <varname>i2</varname>, and
+ 	 <varname>i3</varname> and then making a range [i1:i2:i3].</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+ 
+      <para>&rangeone; constructors are the same as &intervalone;
+      constructors except they create ranges, not intervals.  See <xref
+      linkend="arrays-domains_declarations-range-one_d_table"></xref>.
+      The default constructor creates an empty, uninitialized range,
+      which should not be used before assigning it values.  If the
+      one-parameter constructor's argument is a &domain; object, it must
+      be a one-dimensional &domain; object which is copied into a &range;
+      if possible.  If the one-parameter constructor's argument is not
+      a &domain; object, it must be convertible to an
+      integer&nbsp;<varname>e</varname> and a range [0:e-1:1] starting
+      at zero is constructed.  If two arguments are specified, they are
+      assumed to be convertible to integers <varname>b</varname> and
+      <varname>e</varname>, specifying the range [b:e:1].  The
+      three-parameter constructor is similar, with the third argument
+      specifying a stride.</para>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0" id="arrays-domains_declarations-ranges-multi_d_table">
+       <title>Declaring Multidimensional &range;s</title>
+      
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>constructor</entry>
+ 	 <entry>result</entry>
+ 	</row>
+        </thead>
+        <tfoot>
+ 	<row>
+ 	 <entry><varname>&dim;</varname> indicates the &range;'s dimension.
+ 	 <varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, &hellip; are
+ 	 template parameters.</entry>
+ 	</row>
+        </tfoot>
+        <tbody>
+ 	<row>
+ 	 <entry><statement>Range&lt;&dim;&gt;()</statement></entry>
+ 	 <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
+ 	 <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
+ 	 <entry>creates a &range; using the given &domain; object.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
+ 	 <entry>creates a &range; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
+ 	 <entry>creates a &range; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
+ 	 <entry>creates a &range; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5)</statement></entry>
+ 	 <entry>creates a &range; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6)</statement></entry>
+ 	 <entry>creates a &range; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
+ 	 <entry>creates a &range; using the given &domain; objects.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+ 
+      <para>Constructors for multidimensional &range;s are the same as
+      multidimensional &interval; constructors except they create
+      ranges, not intervals.  See <xref
+      linkend="arrays-domains_declarations-ranges-multi_d_table"></xref>.
+      <varname>&dim;</varname>&nbsp;indicates the &range;'s dimension.  The
+      first two constructors return empty, uninitialized ranges.
+      The seven other constructors create an &range; using &domain;
+      objects.  These &domain; objects, having types <type>&domaintemplate;1</type>,
+      &hellip;, <type>&domaintemplate;7</type>, can have any type that can be
+      converted into an integer, into a single-dimensional &domain;
+      object that can be converted into a single-dimensional &range;,
+      or to a multidimensional &domain; object that itself can be
+      converted into an &range;.  The total dimensionality of all the
+      arguments' types should be at most&nbsp;<varname>&dim;</varname>.
+      One-dimensional &domain; objects that can be converted into
+      one-dimensional &range;s include &locone;s, &intervalone;s, and
+      &rangeone;s.  If the sum of the objects' dimensions is less
+      than&nbsp;<varname>&dim;</varname>, the ranges for the final
+      dimensions are unspecified.  See the last paragraph of <xref
+      linkend="arrays-domains_declarations-loc"></xref> for an
+      analogous example.  Note that the &rangeone; constructors taking
+      two and three parameters treat these arguments differently than
+      the multidimensional constructors do.</para>
+     </section>
+ 
+ 
+     <section id="arrays-domains_declarations-grids">
+      <title>&grid;s</title>
+ 
+      <para>&loc;s, &interval;s, and &range;s all have regularly spaced
+      integral values so they can be represented using <glossterm
+      linkend="glossary-domain_triplet">domain triplets</glossterm>.
+      One-dimensional &grid; integral domains contain ascending or
+      descending sequences of integers, with no fixed stride.  For
+      example, a &gridone; may represent {-13, 1, 4, 5, 34}.  &gridone;
+      is generalized to multidimensional &grid;s using the direct
+      product of &gridone; &domain;s.</para>
+ 
+      <para>&grid;s that can be represented using domain triplets can
+      be constructed using techniques similar to other &domain;s, but
+      irregularly spaced domains can be constructed using
+      &indirectionlistint;s.</para>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0" id="arrays-domains_declarations-grid-one_d_table">
+       <title>Declaring One-Dimensional &grid;s</title>
+      
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>constructor</entry>
+ 	 <entry>result</entry>
+ 	</row>
+        </thead>
+        <tfoot>
+ 	<row>
+ 	 <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
+ 	 <varname>&domaintemplate;3</varname> are template parameters.</entry>
+ 	 <entry></entry>
+ 	</row>
+        </tfoot>
+        <tbody>
+ 	<row>
+ 	 <entry><statement>Grid&lt;1&gt;()</statement></entry>
+ 	 <entry>creates an empty, uninitialized grid.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
+ 	 <entry>creates a &gridone;.  See the text for an explanation.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
+ 	 <entry>creates a &gridone; from the interval specified by the
+ 	 integers converted from <varname>t1</varname> and
+ 	 <varname>t2</varname>.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
+ 	 <entry>creates a &gridone; from the domain triplet specified
+ 	 by the integers converted from <varname>t1</varname>,
+ 	 <varname>t2</varname>, and <varname>t3</varname>.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+ 
+      <para>To construct a &gridone; that can also be represented by a
+      domain triplet, use a &gridone; constructor similar to those for
+      &intervalone; and &rangeone;.  See <xref
+      linkend="arrays-domains_declarations-grid-one_d_table"></xref>
+      and the text explanations following <xref
+      linkend="arrays-domains_declarations-range-one_d_table"></xref>
+      or <xref
+      linkend="arrays-domains_declarations-interval-one_d_table"></xref>.</para>
+ 
+      <para>&gridone;s with irregularly spaced points can be
+      constructed using &indirectionlistint;s.  For example,
+ <programlisting>
+ IndirectionList&lt;int&gt; list(4);
+ list(0) = 2;
+ list(1) = 5;
+ list(2) = 6;
+ list(3) = 9;
+ Grid&lt;1&gt; g(list);
+ </programlisting> constructs an empty &indirectionlistint;, fills it
+      with ascending values, and then creates a &gridone; containing
+      {2, 5, 6, 9}.  When creating a list, its size must be specified.
+      Subsequently, its values can be assigned.  &indirectionlist;s can
+      also be initialized using one-dimensional &array;s:
+ <programlisting>
+ Array&lt;1,int,Brick&gt; a1(Interval&lt;1&gt;(0,3));
+ a1(0) = 2; a1(1) = 5; a1(2) = 6; a1(3) = 9;
+ IndirectionList&lt;int&gt; il(a1);
+ Grid&lt;1&gt; g1(il);
+ </programlisting>  The &array; stores the integral points to include
+      in the &gridone; and is used to create the &indirectionlistint;,
+      which itself is used to create the &gridone;.  Since the points
+      are integers, the &array;'s type is &int;.  Either a &brick; or
+      &compressiblebrick; &engine; should be used.</para>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0" id="arrays-domains_declarations-grids-multi_d_table">
+       <title>Declaring Multidimensional &grid;s</title>
+      
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>constructor</entry>
+ 	 <entry>result</entry>
+ 	</row>
+        </thead>
+        <tfoot>
+ 	<row>
+ 	 <entry><varname>&dim;</varname> indicates the &grid;'s
+ 	 dimension.  <varname>&domaintemplate;1</varname>,
+ 	 <varname>&domaintemplate;2</varname>, &hellip; are template
+ 	 parameters.</entry>
+ 	</row>
+        </tfoot>
+        <tbody>
+ 	<row>
+ 	 <entry><statement>Grid&lt;&dim;&gt;()</statement></entry>
+ 	 <entry>creates an empty, uninitialized &grid;, to be assigned a value later.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
+ 	 <entry>creates a &grid; using the given &domain; object.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
+ 	 <entry>creates a &grid; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
+ 	 <entry>creates a &grid; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
+ 	 <entry>creates a &grid; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5)</statement></entry>
+ 	 <entry>creates a &grid; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6)</statement></entry>
+ 	 <entry>creates a &grid; using the given &domain; objects.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
+ 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
+ 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
+ 	 <entry>creates a &grid; using the given &domain; objects.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+ 
+      <para>Constructors for multidimensional &grid;s are the same as
+      multidimensional &interval; constructors except they create
+      &grid;s, not intervals.  See <xref
+      linkend="arrays-domains_declarations-grids-multi_d_table"></xref>.
+      <varname>&dim;</varname>&nbsp;indicates the &grid;'s dimension.  The
+      first constructor returns empty, uninitialized grids.  The seven
+      other constructors create an &grid; using &domain; objects.  These
+      &domain; objects, having types <type>&domaintemplate;1</type>, &hellip;,
+      <type>&domaintemplate;7</type>, can have any type that can be converted into an
+      integer, into a single-dimensional &domain; object that can be
+      converted into a single-dimensional &grid;, or to a
+      multidimensional &domain; object that itself can be converted into
+      an &grid;.  The total dimensionality of all the arguments' types
+      should be at most&nbsp;<varname>&dim;</varname>.  One-dimensional
+      &domain; objects that can be converted into one-dimensional &grid;s
+      include &locone;s, &intervalone;s, &rangeone;s, and &gridone;s.
+      If the sum of the objects' dimensions is less
+      than&nbsp;<varname>&dim;</varname>, the grids for the final
+      dimensions are unspecified.  See the last paragraph of <xref
+      linkend="arrays-domains_declarations-loc"></xref> for an
+      analogous example.  Note that the &gridone; constructors taking
+      two and three parameters treat these arguments differently than
+      the multidimensional constructors do.</para>
+     </section>
+    </section>
+ 
+ 
+    <section id="arrays-arrays_declarations">
+     <title>Declaring &array;s</title>
+ 
+     <para>A &pooma; &array; maps indices from its &domain; to values.
+     In this section, we describe first describe how to declare
+     &array;s.  In the next section, we explain how to access
+     individual values stored within an &array; and &array; copy
+     semantics.</para>
+ 
+     <para>&array; values need not just be stored values, as &c; arrays
+     have.  They can also be computed using its engine.  We defer
+     discussion of computing values to the next chapter discussing
+     engines (<xref linkend="engines"></xref>).  To avoid being verbose
+     in this chapter, when we discuss stored values, the values might
+     instead be computed.</para>
+ 
+     <para>Declaring an &array; requires four arguments: the domain's
+     dimensionality, the type of values stored or computed, a
+     specification how the values are stored, and a &domain;.  The
+     first three arguments are template parameters since few scientific
+     programs (and no &pooma; programs) need to change these values
+     while a program executes.  For example, an &array; cannot change
+     the type of the elements it stores.  Alternatively, an &array;'s
+     values can be copied into another &array; having the desired type.
+     Although scientific programs do not frequently change an array's
+     domain, they do frequently request a subset of the array's values,
+     i.e., a <glossterm linkend="glossary-view">view</glossterm>.  The
+     subset is specified via a &domain; so it is a run-time value.
+     Views are presented in <xref linkend="views"></xref>.</para>
+ 
+     <para>An &array;'s first template parameter specifies its
+     dimensionality.  This positive
+     integer&nbsp;<varname>&dim;</varname> specifies its rank.  This is
+     the same value as its domain's dimensionality.  Theoretically, an
+     &array; can have any positive integer, but the &pooma; code
+     currently supports <varname>&dim;</varname> at most seven.  For
+     almost all scientific codes, a dimension of three or four is
+     sufficient, but the code can be extended to support higher
+     dimensions.</para>
+ 
+     <para>An &array;'s second template parameter specifies the type of
+     its stored values.  Common value types include &int;, &double;,
+     &complex;, and &vector;, but any type is permissible.  For
+     example, an &array;'s values might be matrices or even other
+     &array;s.  The parameter's default value is usually &double;, but
+     it may be changed when the &poomatoolkit; is configured.</para>
+ 
+     <para>An &array;'s third parameter specifies how its data is
+     stored by an &engine; and its values accessed.  The argument is a
+     tag indicating a particular type of &engine;.  Permissible tags
+     include &brick;, &compressiblebrick;, and
+     <type>ConstantFunction</type>.  The &brick; tag indicates all
+     &array; values will be explicitly stored, just as built-in &c;
+     arrays do.  If the &array;s frequently stores exactly the same
+     value in every position, a &compressiblebrick; &engine;, which
+     reduces its space requirements to a constant whenever all its
+     values are the same, is appropriate.  A
+     <type>ConstantFunction</type> &engine; returns the same value for
+     all indices.</para>
+ 
+     <para>Even though every &array; container has an engine to store
+     its values and permit access to individual values, an &array; is
+     conceptually separated from engines.  An engine's role is
+     low-level, storing values and permitting access to individual
+     values.  As we indicated above, the storage can be optimized to
+     fit specific situations such as few nonzero values and computing
+     values using a function applied to another engine's values.  An
+     &array;'s role is high-level, supporting access to groups of
+     values.  They handle memory allocation and deallocation.  &array;s
+     can be used in data-parallel expressions, e.g., adding all the
+     values in one &array; to all the values in another.  (See <xref
+     linkend="data_parallel"></xref> for more information.)  Subsets of
+     &array; values, frequently used in data-parallel statements, can
+     be obtained.  (See <xref linkend="views"></xref> for more
+     information.)  Even though engines and &array;s are conceptually
+     separate, higher-level &array;s provide access to lower-level
+     &engine;s.  Users usually have an &array; create its &engine;,
+     rarely explicitly creating &engine;s themselves.  Also, &array;s
+     provide access to individual values.  In short, &pooma; users use
+     &array;s, only dealing with how they are implemented (engines)
+     upon declaration.  For more description of &engine;s, see <xref
+     linkend="engines"></xref>.</para>
+ 
+     <para>The engine parameter's default value is usually &brick;, but
+     it may be changed when the &poomatoolkit; is configured.</para>
+ 
+     <para>An &array;'s one constructor argument is its domain.  The
+     domain specifies its extent and simultaneously how many values it
+     can return.  All the provided &domain; objects are combined to
+     yield an <type>Interval&lt;&dim;&gt;</type>, where &dim; matches
+     the &array;'s first template parameter.  Since an &interval;
+     domain with its unit strides is used, there are no unaccessed
+     <quote>gaps</quote> within the domain, wasting storage space.  To
+     use other domains to access an &array;, first create it using an
+     &interval; domain and then take a view of it, as described in
+     <xref linkend="views"></xref>.  As we mentioned above, the current
+     &pooma; code supports up to seven dimensions so at most seven
+     &domain; objects can be provided.  If more dimensions are
+     required, the &pooma; code can be extended to the desired number
+     of dimensions.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0" id="arrays-arrays_declarations-table">
+      <title>Declaring &array;s</title>
+      
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>&array; declaration</entry>
+ 	<entry>result</entry>
+        </row>
+       </thead>
+       <tfoot>
+        <row>
+ 	<entry>Template parameters <varname>&dim;</varname>,
+ 	 <varname>T</varname>, and <varname>E</varname> indicates the
+ 	 &array;'s dimension, value type, and &engine; type,
+ 	 respectively.  <varname>DT1</varname>, &hellip;,
+ 	 <varname>DT7</varname> indicate domain types or
+ 	 integers.</entry>
+        </row>
+       </tfoot>
+       <tbody>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;()</statement></entry>
+ 	<entry>creates an empty, uninitialized &array; which must be
+ 	<methodname>initialize</methodname>()d before use.</entry>
+        </row>
+        <!-- Omit Indirection Array because src/Engine/IndirectionEngine.h indicates it is not yet finished. -->
+        <!-- Omit the two Array&lt;D1,T1,E1&gt; a constructors, which
+        should not be used by users. -->
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; object or integer.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6, const DT7&amp; t7)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; object or
+ 	integer and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6, const DT7&amp; t7,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates an &array; using the given &domain; objects and
+ 	integers and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <para>&array; constructors are listed in <xref
+     linkend="arrays-arrays_declarations-table"></xref>.  An &array;s'
+     three template parameters for dimensionality, value type, and
+     engine type are abbreviated <varname>D</varname>,
+     <varname>T</varname>, and <varname>E</varname>.  Template
+     parameters for domain types are named <varname>DT1</varname>,
+     &hellip;, <varname>DT7</varname>.  The first constructor, with no
+     domain arguments, creates an empty, uninitialized &array; for
+     which a domain must be specified before it is used.  Specify the
+     array's domain using its <methodname>initialize</methodname> function.
+     The next seven constructors combine their domain arguments to
+     compute the resulting &array;'s domain.  These are combined in the
+     same way that multidimensional &interval;s are constructed.  (See
+     <xref
+     linkend="arrays-domains_declarations-intervals-multi_d_table"></xref>
+     and the following text.)  The domain objects, having types
+     <type>&domaintemplate;1</type>, &hellip;,
+     <type>&domaintemplate;7</type>, can have any type that can be
+     converted into an integer, into a single-dimensional &domain;
+     object that can be converted into a single-dimensional &interval;,
+     or to a multidimensional &domain; object that itself can be
+     converted into an &interval;.  The total dimensionality of all the
+     arguments' types should
+     <emphasis>equal</emphasis>&nbsp;<varname>&dim;</varname>, unlike
+     &interval; construction which permits total dimensionality less
+     than or equal to&nbsp;<varname>&dim;</varname>.  One-dimensional
+     &domain; objects that can be converted into one-dimensional
+     &interval;s include &locone;s, &intervalone;s, and &rangeone;s
+     with unit strides.  To initialize all of an &array; values to a
+     specific value, use one of the final seven constructors, each
+     taking a particular value, wrapped as a <type>ModelElement</type>.
+     These constructors use the given domain objects the same way as
+     the preceding constructors but assign <varname>model</varname> to
+     every &array; value.  <varname>model</varname>'s type
+     <type>ModelElement&lt;T&gt;</type> rather than
+     <varname>T</varname> to differentiate it from an &int;, which can
+     also be used to specify a domain object.
+     <type>ModelElement</type> just stores an element of any type
+     <varname>T</varname>, which must match the &array;'s value
+     type.</para>
+ 
+     <para>We illustrate creating &array;s.  To create a
+     three-dimensional &array;&nbsp;<varname>a</varname> explicitly
+     storing &double; floating-point values, use
+ <programlisting>
+ Interval&lt;1&gt; D(6);
+ Interval&lt;3&gt; I3(D,D,D);
+ Array&lt;3,double,Brick&gt; a(I3);.
+ </programlisting>  The template parameters specify its dimensionality,
+     the type of its values, and a &brick; &engine; type, which
+     explicitly stores values.  Its domain, which must have three
+     dimensions, is specified by an <type>Interval&lt;3&gt;</type>
+     object which consists of a [0,5] intervals for all its three
+     dimensions.  Since &double; and &brick; are usually the default
+     template parameters, they can be omitted so these declarations are
+     equivalent:
+ <programlisting>
+ Array&lt;3,double&gt; a_duplicate1(I3);
+ Array&lt;3&gt; a_duplicate2(I3);.
+ </programlisting>  To create a similar &array; with a domain of
+ [0:1:1, 0:2:1, 0:0:1], use
+ <programlisting>
+ Array&lt;3&gt; b(2,3,1);.
+ </programlisting> Specifying an integer&nbsp;<varname>i</varname>
+     indicates a one-dimensional zero-based &interval; [0:i-1:1].  To
+     store &bool;s, specify &bool; as the second template argument:
+ <programlisting>
+ Array&lt;2,bool&gt; c(2,3);.
+ </programlisting>  To specify a default &array; value of &true;, use
+     <statement>ModelElement&lt;bool&gt;(true)</statement>:
+ <programlisting>
+ Array&lt;2,bool&gt; c(2,3, ModelElement&lt;bool&gt;(true));.
+ </programlisting>  To create a one-dimensional &array; containing
+     seven &double;s all equaling &pi;, use
+ <programlisting>
+ Array&lt;1,double,CompressibleBrick&gt; d(7, ModelElement&lt;double&gt;(4.0*atan(1.0)));.
+ </programlisting>  We use a &compressiblebrick; &engine;, rather than
+     a &brick; &engine;, so all seven values will be stored once rather
+     than seven times when they are all the same.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0" id="arrays-arrays_declarations-initialize_table">
+      <title>Initializing &array;s' Domains</title>
+      
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>An &array;'s <methodname>initialize</methodname> member
+ 	functions sets its domain and should be invoked only for an
+ 	array created without a domain.  It returns nothing.</entry>
+        </row>
+        <row>
+ 	<entry><methodname>initialize</methodname> declaration</entry>
+ 	<entry>result</entry>
+        </row>
+       </thead>
+       <tfoot>
+        <row>
+ 	<entry>Template parameters <varname>DT1</varname>, &hellip;,
+ 	<varname>DT7</varname> indicate domain types or
+ 	integers.</entry>
+        </row>
+       </tfoot>
+       <tbody>
+        <!-- Omit Indirection Array initialize because it does not exist! -->
+        <!-- Omit the two Array&lt;D1,T1,E1&gt; functions, which should not be used by users. -->
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain;
+ object or integer.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6, const DT7&amp; t7)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; object and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><statement>initialize(const DT1&amp; t1, const
+ 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
+ 	 t5, const DT6&amp; t6, const DT7&amp; t7,
+ 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
+ 	<entry>creates the &array;'s domain using the given &domain; objects and
+ 	then initializes all entries using <varname>model</varname>.</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <para>An uninitialized &array;, created using the parameter-less
+     constructor, must have a specified domain before it can be used.
+     For example, one must use the parameter-less &array; constructor
+     when creating an array of &array;s using
+     <keywordname>new</keywordname> (although it would probably be
+     better to create an &array; of &array;s since memory allocation
+     and deallocation would automatically be handled) so their domains
+     must be specified.  &array;'s <methodname>initialize</methodname>
+     functions accept the same set of domain object specifications and
+     model elements that the &array; constructors do, creating the
+     specified domain.  See <xref
+     linkend="arrays-arrays_declarations-initialize_table"></xref>.
+     For example, both <varname>a</varname> and <varname>b</varname>
+     are two-dimensional &array;s of &float;s with a [2:7:1,-2:4:1]
+     domains:
+ <programlisting>
+ // Create an Array and its domain.
+ Array<2,float,Brick> a(Interval<1>(2,7), Interval<1>(-2,4));
+ // Create an Array without a domain and then specify its domain.
+ Array<2,float,Brick> b();
+ b.initialize(Interval<1>(2,7), Interval<1>(-2,4));.
+ </programlisting>  Invoking <methodname>initialize</methodname> on an
+     &array; with an existing domain is unspecified.  All &array;
+     values may be lost and memory may be leaked.</para>
+    </section>
+ 
+ 
+    <section id="arrays-arrays_use">
+     <title>Using &array;s</title>
+ 
+     <para>In the previous section, we explained how to declare and
+     initialize &array;s.  In this section, we explain how to access
+     individual values stored within an &array; and how to copy
+     &array;s.  In <xref linkend="data_parallel"></xref>, we explain
+     how to use entire &array;s in data-parallel statements, including
+     how to print them.  In <xref linkend="views"></xref>, we extend
+     this capability to work on subsets.</para>
+ 
+     <para>In its simplest form, an &array; stores individual values,
+     permitting access to these values.  For a &cc; array, the desired
+     index is specified within square brackets following the array's
+     name.  For &pooma; &array;s, the desired index is specified
+     within parentheses following the &array;'s name.  The same
+     notation is used to read and write values.  For example, the
+     following code prints the initial value at index (2,-2) and
+     increments its value, printing the new value:
+ <programlisting>
+ Array&lt;2,int,Brick&gt; a(Interval&lt;1&gt;(0,3), Interval&lt;1&gt;(-2,4),
+      	               ModelElement&lt;int&gt;(4));
+ std::cout &openopen; a(2,-2) &openopen; std::endl;
+ ++a(2,-2);
+ std::cout &openopen; a(2,-2) &openopen; std::endl;
+ </programlisting>  <computeroutput>4</computeroutput> and then
+     <computeroutput>5</computeroutput> are printed.  An index
+     specification for an &array; usually has as many integers as
+     dimensions, all separated by commas, but the &array;'s engine may
+     permit other notation such as using strings or floating-point
+     numbers.</para>
+ 
+     <para>For read-only access to a value, use the
+     <methodname>read</methodname> member function, which takes the
+     same index notation as its nameless read-write counterpart:
+ <programlisting>
+ std::cout &openopen; a.read(2,-2) &openopen; std::endl;
+ </programlisting> Using <methodname>read</methodname> sometimes
+     permits the optimizer to produce faster executing code.</para>
+ 
+     <example id="arrays-arrays_use-copy_example">
+      <title>Copying &array;s</title>
+      &array-copy;
+     </example>
+ 
+     <para>Copying &array;s requires little execution time because they
+     have reference semantics.  That is, a copy of an &array; and the
+     &array; itself share the same underlying data.  Changing a value
+     in one changes it in the other.  <xref
+     linkend="arrays-arrays_use-copy_example"></xref> illustrates this
+     behavior.  Initially, all values in the array <varname>a</varname>
+     are&nbsp;4.  The <varname>b</varname> array is initialized using
+     <varname>a</varname> so it shares the same values as
+     <varname>a</varname>.  Thus, changing the former's value also
+     changes the latter's value.  Function arguments are also
+     initialized so changing their underlying values also changes the
+     calling function's values.  For example, the
+     <function>changeValue</function> function changes the value with
+     index&nbsp;(0,0) of both its function argument
+     and&nbsp;<varname>a</varname>.</para>
+ 
+     <para>The separation between a higher-level &array; and its
+     lower-level &engine; storage permits fast copying.  An &array;'s
+     only data member is its engine, which itself has reference
+     semantics that increments a reference-counted pointer to its data.
+     Thus, copying an &array; requires creating a new object with one
+     data member and incrementing a pointer's reference count.
+     Destruction is similarly inexpensive.</para>
+ 
+     <para>Array assignment does not have reference semantics.  Thus,
+     the assignment <statement>a = b</statement> ensures that all of
+     <varname>a</varname>'s values are the same as <varname>b</varname>
+     at the time of assignment only.  Subsequent changes to
+     <varname>a</varname>'s values do not change <varname>b</varname>'s
+     values or vice versa.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0" id="arrays-arrays_use-compile_time_table">
+      <title>&array; Internal Type Definitions and Compile-Time Constants</title>
+      
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>internal type or compile-time constant</entry>
+ 	<entry>meaning</entry>
+        </row>
+       </thead>
+       <tbody>
+        <row>
+ 	<entry><type>This_t</type></entry>
+ 	<entry>the &array;'s type <type>Array&lt;&dim;,T,E&gt;</type>.</entry>
+        </row>
+        <row>
+ 	<entry><type>Engine_t</type></entry>
+ 	<entry>the &array;'s &engine; type <type>Engine&lt;&dim;,T,E&gt;</type>.</entry>
+        </row>
+        <row>
+ 	<entry><type>EngineTag_t</type></entry>
+ 	<entry>the &array;'s &engine;'s tag&nbsp;<varname>E</varname>.</entry>
+        </row>
+        <row>
+ 	<entry><type>Element_t</type></entry>
+ 	<entry>the type&nbsp;<varname>T</varname> of values stored in the &array;.</entry>
+        </row>
+        <row>
+ 	<entry><type>ElementRef_t</type></entry>
+ 	<entry>the type of references to values stored in the &array;
+ 	(usually <type>T&</type>).</entry>
+        </row>
+        <row>
+ 	<entry><type>Domain_t</type></entry>
+ 	<entry>the type of the &array;'s domain.</entry>
+        </row>
+        <row>
+ 	<entry><type>Layout_t</type></entry>
+ 	<entry>the type of the &array;'s layout.</entry>
+        </row>
+        <row>
+ 	<entry><fieldsynopsis>
+ 	  <modifier>const</modifier>
+ 	  <type>int</type>
+ 	  <varname>dimensions</varname></fieldsynopsis></entry>
+ 	<entry>the number&nbsp;&dim; of dimensions of the &array;.</entry>
+        </row>
+        <row>
+ 	<entry><fieldsynopsis>
+ 	  <modifier>const</modifier>
+ 	  <type>int</type>
+ 	  <varname>rank</varname></fieldsynopsis></entry>
+ 	<entry>synonym for <varname>dimensions</varname>.</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <para>The &array; class has internal type definitions and
+     constants useful for both compile-time and run-time computations.
+     See <xref linkend="arrays-arrays_use-compile_time_table"></xref>.
+     These may be accessed using the &array;'s type and the scope
+     resolution operator (<operator>::</operator>).  The table begins
+     with a list of internal type definitions, e.g.,
+     <statement>Array&lt;&dim;,T,E&gt;::Domain_t</statement>.  Member
+     functions use some of these types.  A <glossterm
+     linkend="glossary-layout">layout</glossterm> maps a domain index
+     to a particular processor and memory used to compute the
+     associated value.<!-- FIXME: Add a reference to the corresponding
+     chapter. --> The two internal enumerations
+     <fieldsynopsis><varname>dimensions</varname></fieldsynopsis> and
+     <fieldsynopsis><varname>rank</varname></fieldsynopsis> both record
+     the &array;'s dimension.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0" id="arrays-arrays_use-accessor_table">
+      <title>&array; Accessors</title>
+      
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>&array; member function</entry>
+ 	<entry>result</entry>
+        </row>
+       </thead>
+       <tfoot>
+        <row>
+ 	<entry>Internal type definitions, e.g., <type>Domain_t</type>,
+ 	are listed without a class type prefix
+ 	<statement>Array&lt;&dim;,T,E&gt;::</statement>.</entry>
+        </row>
+       </tfoot>
+       <tbody>
+        <row>
+ 	<entry><statement>Domain_t domain()</statement></entry>
+ 	<entry>returns the &array;'s domain.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Domain_t physicalDomain()</statement></entry>
+ 	<entry>returns the &array;'s domain.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Domain_t totalDomain()</statement></entry>
+ 	<entry>returns the &array;'s domain.</entry>
+        </row>
+        <row>
+ 	<entry><statement>int first(int dim)</statement></entry>
+ 	<entry>returns the first (smallest) index value for the
+ 	specified dimension.</entry>
+        </row>
+        <row>
+ 	<entry><statement>int last(int dim)</statement></entry>
+ 	<entry>returns the last (largest) index value for the
+ 	specified dimension.</entry>
+        </row>
+        <row>
+ 	<entry><statement>int length(int dim)</statement></entry>
+ 	<entry>returns the number of indices (including endpoints) for
+ 	the specified dimension.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Loc&lt;Dim&gt; firsts()</statement></entry>
+ 	<entry>returns the first (smallest) index values for all the
+ 	dimensions.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Loc&lt;Dim&gt; lasts()</statement></entry>
+ 	<entry>returns the last (largest) index values for all the
+ 	specified dimensions.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Loc&lt;Dim&gt; lengths()</statement></entry>
+ 	<entry>returns the numbers of indices (including endpoints)
+ 	for all the specified dimensions.</entry>
+        </row>
+        <row>
+ 	<entry><statement>long size()</statement></entry>
+ 	<entry>returns the total number of indices in the domain.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Layout_t layout()</statement></entry>
+ 	<entry>returns the &array;'s domain.</entry>
+        </row>
+        <row>
+ 	<entry><statement>Engine_t engine()</statement></entry>
+ 	<entry>returns the &array;'s engine.</entry>
+        </row>
+        <row>
+ 	<entry><statement>const Engine_t engine()</statement></entry>
+ 	<entry>returns the &array;'s engine.</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <para>The &array; class has several member functions easing access
+     to its domain and engine.  The first ten functions listed in <xref
+     linkend="arrays-arrays_use-accessor_table"></xref> ease access to
+     &array; domains.  The first three functions are synonyms all
+     returning the &array;'s domain, which has type
+     <type>Array&lt;&dim;,T,E&gt;::Domain_t</type>, abbreviated
+     <type>Domain_t</type> in the table.  The next seven functions
+     query the domain.  <methodname>first</methodname>,
+     <methodname>last</methodname>, and <methodname>length</methodname>
+     return the smallest, largest, and number of indices for the
+     specified dimension.  The domain's dimensions are numbered 0, 1,
+     &hellip;,
+     <statement>Array&lt;&dim;,T,E&gt;::dimensions</statement>-1.  If
+     these values are needed for all dimensions, use
+     <methodname>firsts</methodname>, <methodname>lasts</methodname>,
+     and <methodname>lengths</methodname>.  The returned
+     <type>Loc&lt;&dim;&gt;</type>s have &dim; entries, one for each
+     dimension.  <methodname>size</methodname> returns the total number
+     of indices in the entire domain.  This is the product of all the
+     dimensions' <methodname>length</methodname>s.  The
+     <methodname>layout</methodname> member function returns the
+     &array;'s layout, which specifies the mapping of indices to
+     processors and memory.<!-- FIXME: Add a reference to the
+     corresponding chapter. --> The last two functions return the
+     &array;'s engine.</para>
+ 
+     <example id="arrays-arrays_use-members_example">
+      <title>Using &array; Member Functions</title>
+      &array-size;
+      <calloutlist>
+       <callout arearefs="arrays-arrays_use-members-example-compare_size">
+        <para>The <methodname>size</methodname> is invoked by
+        prepending the &array;'s name followed by a period.  This
+        assertion is unnecessary, but the
+        <function>computeArraySize</function> function further
+        illustrates using member functions.</para>
+       </callout>
+       <callout arearefs="arrays-arrays_use-members-example-template_parameters">
+        <para>These template parameters, used in the &array;
+        parameter's type, permit the function to work with any
+        &array;.</para>
+       </callout>
+       <callout arearefs="arrays-arrays_use-members-example-function_call">
+        <para>We invoke these three member functions using the
+        &array;'s name <varname>a</varname>, a period, and the
+        functions' names.  These functions return &loc;s.</para>
+       </callout>
+       <callout arearefs="arrays-arrays_use-members-example-loc_use">
+        <para><statement>lens[d]</statement> returns a
+        <type>Loc&lt;1&gt;</type> for
+        dimension&nbsp;<varname>d</varname>'s length.  Invoking
+        <type>Loc&lt;1&gt;</type> <methodname>first</methodname>method
+        yields its value.</para>
+       </callout>
+       <callout arearefs="arrays-arrays_use-members-example-check_length">
+        <para>This comparison is unnecessary but further illustrates
+        using member functions.</para>
+       </callout>
+      </calloutlist>
+     </example>
+ 
+     <para>We illustrate using &array; member functions in <xref
+     linkend="arrays-arrays_use-members_example"></xref>.  The program
+     computes the total number of &array;'s indices, comparing the
+     result with invoking its <methodname>size</methodname> method.
+     Since the &array;'s name is <varname>a</varname>,
+     <statement>a.size()</statement> returns its size.
+     <function>computeArraySize</function> also computes the &array;'s
+     size.  This templated function uses its three template parameters
+     to accept any &array;, regardless of its dimension, value type, or
+     &engine; tag.  It begins by obtaining the range of indices for all
+     dimensions and their lengths.  Only the latter is necessary for
+     the computation, but the former further illustrate using member
+     functions.  The domain's size is the product of the length of each
+     dimension.  Since the lengths are stored in the
+     <type>Loc&lt;&dim&gt;</type> <varname>lens</varname>,
+     <statement>lens[d]</statement> is a <type>Loc&lt;1&gt;</type>, for
+     which its <methodname>first</methodname> extracts the length.  The
+     <methodname>length</methodname> &array; member function is used in
+     the <function>PAssert</function>.</para>
+    </section>
+ 
+ 
+    <section id="arrays-doof2d">
+     <title>An &array; Implementation of &doof2d;</title>
+ 
+     <para>mostly copy pp.35-38 from tutorial chapter<!-- UNFINISHED --></para>
+    </section>
+ 
+ 
+    <section id="arrays-implementation">
+     <title>Implementing &array;s</title>
+ 
+     <para>What to write?<!-- UNFINISHED -->
+ 
+     Do I need to describe the public interface of Domains?  Do I need
+     to describe how a programmer would implement a new type of domain?
+     Probably not.</para>
+    </section>
+ 
+   </chapter>
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.5
diff -c -p -r1.5 concepts.xml
*** concepts.xml	2002/01/14 17:33:33	1.5
--- concepts.xml	2002/01/16 00:48:35
***************
*** 134,140 ****
       <row>
  	<entry><glossterm
  	linkend="glossary-array">&array;</glossterm></entry>
! 	<entry>container mapping indices to values and that may be
  	used in expressions</entry>
       </row>
       <row>
--- 134,140 ----
       <row>
  	<entry><glossterm
  	linkend="glossary-array">&array;</glossterm></entry>
! 	<entry>container mapping <glossterm linkend="glossary-index">indices</glossterm> to values and that may be
  	used in expressions</entry>
       </row>
       <row>
***************
*** 146,152 ****
       </row>
       <row>
  	<entry><glossterm linkend="glossary-field">&field;</glossterm></entry>
! 	<entry>container mapping indices to one or more values and
  	residing in multi-dimensional space</entry>
       </row>
       <row>
--- 146,152 ----
       </row>
       <row>
  	<entry><glossterm linkend="glossary-field">&field;</glossterm></entry>
! 	<entry>container mapping <glossterm linkend="glossary-index">indices</glossterm> to one or more values and
  	residing in multi-dimensional space</entry>
       </row>
       <row>
***************
*** 172,178 ****
  
    <para>A &pooma; <glossterm
    linkend="glossary-array">&array;</glossterm> generalizes a &c; array
!   and maps indices to values.  Given an index or position in an
    &array;'s domain, it returns the associated value, either by
    returning a stored value or by computing it.  The use of indices,
    which are usually ordered tuples, permits constant-time access
--- 172,178 ----
  
    <para>A &pooma; <glossterm
    linkend="glossary-array">&array;</glossterm> generalizes a &c; array
!   and maps <glossterm linkend="glossary-index">indices</glossterm> to values.  Given an index or position in an
    &array;'s domain, it returns the associated value, either by
    returning a stored value or by computing it.  The use of indices,
    which are usually ordered tuples, permits constant-time access
***************
*** 350,356 ****
  
     <para>A <glossterm
     linkend="glossary-layout"><firstterm>layout</firstterm></glossterm>
!    maps <link linkend="glossary-domain">domain</link> indices to the
     processors and computer memory used by a container's engines.  See
     <xref
     linkend="concepts-containers-declarations-computational_implementation"></xref>.
--- 350,356 ----
  
     <para>A <glossterm
     linkend="glossary-layout"><firstterm>layout</firstterm></glossterm>
!    maps <link linkend="glossary-domain">domain</link> <glossterm linkend="glossary-index">indices</glossterm> to the
     processors and computer memory used by a container's engines.  See
     <xref
     linkend="concepts-containers-declarations-computational_implementation"></xref>.
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.6
diff -c -p -r1.6 manual.xml
*** manual.xml	2002/01/14 17:33:34	1.6
--- manual.xml	2002/01/16 00:48:38
***************
*** 15,21 ****
  <!ENTITY book "book">
    <!-- Produce a notation for the book/manual/report/WWW page.  -->
    <!-- Modify this to the desired noun. -->
! <!ENTITY bookCap "Book">
    <!-- Produce a capitalized version of &book;  -->
    <!-- Modify this to the desired noun. -->
  <!ENTITY c "<application class='software'>C</application>">
--- 15,21 ----
  <!ENTITY book "book">
    <!-- Produce a notation for the book/manual/report/WWW page.  -->
    <!-- Modify this to the desired noun. -->
! <!ENTITY bookcap "Book">
    <!-- Produce a capitalized version of &book;  -->
    <!-- Modify this to the desired noun. -->
  <!ENTITY c "<application class='software'>C</application>">
***************
*** 32,37 ****
--- 32,39 ----
    <!-- Produce a notation for ">>>", which infrequently occurs with templates.  Without this, TeX produces a shift symbol. -->
  <!ENTITY dashdash "-&gap;-" >
    <!-- Produce a notation for a double dash.  Without this, TeX produces an en-hyphen. -->
+ <!ENTITY dim "D">
+   <!-- the number of dimensions of an array, domain, etc. -->
  <!ENTITY doof2d "<command>Doof2d</command>" >
    <!-- Produce a notation for the Doof2d program.  -->
  <!ENTITY fortran "<application class='software'>Fortran</application>">
***************
*** 89,94 ****
--- 91,98 ----
    <!-- The DistributedTag Layout type. -->
  <!ENTITY domain "<type>Domain</type>">
    <!-- The "Domain" type. -->
+ <!ENTITY domaintemplate "DT">
+   <!-- A domain template parameter. -->
  <!ENTITY double "<type>double</type>">
    <!-- The C "double" type. -->
  <!ENTITY dynamicarray "<type>DynamicArray</type>">
***************
*** 100,105 ****
--- 104,111 ----
    <!-- Modify its tag to the appropriate one. -->
  <!ENTITY field "<type>Field</type>">
    <!-- The "Field" type. -->
+ <!ENTITY float "<type>float</type>">
+   <!-- The C "float" type. -->
  <!ENTITY grid "<type>Grid</type>">
    <!-- The "Grid" domain type. -->
  <!ENTITY gridone "<type>Grid&lt;1&gt;</type>">
***************
*** 193,198 ****
--- 199,206 ----
    <!-- formatting: for sets, no spaces between brackets and entries but spaced between entries -->
  
  <!-- External Chapters -->
+ <!ENTITY arrays-chapter SYSTEM "arrays.xml">
+   <!-- Pooma Arrays chapter -->
  <!ENTITY bibliography-chapter SYSTEM "bibliography.xml">
    <!-- bibliography -->
  <!ENTITY concepts-chapter SYSTEM "concepts.xml">
***************
*** 228,233 ****
--- 236,245 ----
  <!-- Sequential Programs -->
  <!ENTITY initialize-finalize SYSTEM "./programs/examples/Sequential/initialize-finalize-annotated.cpp">
    <!-- Illustrate initialize() and finalize(). -->
+ <!ENTITY array-copy SYSTEM "./programs/examples/Sequential/array-copy-annotated.cpp">
+   <!-- Illustrate Array reference semantics. -->
+ <!ENTITY array-size SYSTEM "./programs/examples/Sequential/array-size-annotated.cpp">
+   <!-- Illustrate Array member functions. -->
  
  <!-- Template Programs -->
  <!ENTITY pairs-untemplated SYSTEM "./programs/examples/Templates/pairs-untemplated-annotated.cpp">
***************
*** 285,291 ****
  
  
    <section id="preface-reading_book:">
!    <title>How to Read This &bookCap;</title>
  
     <para>FINISH: Write this section in a style similar to Lamport's
     LaTeX section 1.2.  FINISH: Fix the book title and the section
--- 297,303 ----
  
  
    <section id="preface-reading_book:">
!    <title>How to Read This &bookcap;</title>
  
     <para>FINISH: Write this section in a style similar to Lamport's
     LaTeX section 1.2.  FINISH: Fix the book title and the section
***************
*** 338,1581 ****
    &tutorial-chapter;
  
    &concepts-chapter;
- 
- 
-   <chapter id="arrays">
-    <title>&array; Containers</title>
- 
-    <para>A container is a class holding objects.  &array;s are one of
-    the two most widely used &pooma; containers since they model the
-    mathematical concept of mapping indices from domains to values.
-    &pooma; &array;s extend built-in &cc; arrays by supporting a wider
-    variety of domains, automatically handling memory allocations, and
-    supporting first-class status.  For example, they may be used as
-    operands and in assignments.  In this chapter, we introduce the
-    concept of containers, the mathematical concept of arrays, and the
-    &pooma; concept for &array;s.  Before illustrating how to declare
-    &array;s, we introduce &domain;s, which specify the sets of
-    indices.  After describing how to declare the various types of
-    &domain;s, we describe how to declare and use &array;s.  This is
-    illustrated in a &doof2d; implementation using &array;s.  We end
-    with a description of their implementation.</para>
- 
- 
-    <section id="arrays-containers">
-     <title>Containers</title>
- 
-     <para>A <glossterm
-     linkend="glossary-container"><firstterm>container class
-     expression</firstterm></glossterm> is a class with the main
-     purpose of holding objects.  These stored objects, called
-     <glossterm linkend="glossary-container_value"><firstterm>container
-     values</firstterm></glossterm> or more simply
-     <quote>values</quote> or elements<quote></quote>, may be accessed
-     and changed, usually using indices.  <quote>Container
-     class</quote> is usually abbreviated
-     <quote>container</quote>.</para>
- 
-     <para>The six &pooma; containers can be categorized into two
-     groups.  Mathematical containers include &tensor;s, &matrix;s, and
-     &vector;s, modeling tensors, matrices, and vectors, respectively.
-     Storage containers include &array;s, &dynamicarray;s, and
-     &field;s.  In this chapter, we focus on simplest of these:
-     &array;s.  The other containers will be described in subsequent
-     chapters.</para>
- 
-     <para>&c;&nbsp;has built-in arrays, and the &cc; Standard Library
-     provides <type>map</type>s, <type>vector</type>s,
-     <type>stack</type>s, and other containers, but the &pooma;
-     containers better model scientific computing concepts and provide
-     more functionality.  They automatically handle memory allocation
-     and deallocation and can be used in expressions and on the
-     left-hand side of assignments.  Since &pooma; containers separate
-     the container concepts of accessing and using values from storing
-     values, value storage can be optimized to specific needs.  For
-     example, if most of an &array;'s values are known to be the same
-     most of the time, a compressible engine can be used.  Whenever all
-     the array's values are the same, it stores only one value.  At
-     other times, it stores all the values.  Engines will be discussed
-     in <xref linkend="engines"></xref>.</para>
-    </section>
- 
- 
-    <section id="arrays-arrays">
-     <title>&array;s</title>
- 
-     <para>Mathematically, an array maps indices from a domain to
-     values.  Usually, the domain consists of a one-dimensional
-     integral interval or it may be multidimensional.  &pooma;'s
-     &array; container class implements this idea.  Given an index,
-     i.e., a position in an &array;'s &domain;, it returns the associated
-     value, either by returning a stored value or by computing it.  The
-     use of indices, which are usually integral tuples but need not be
-     zero-based or even consist of all possible integral tuples in a
-     multidimensional range.  Using indices permits constant-time
-     access to values although computing a particular value may require
-     significant time.</para>
- 
-     <para>&pooma; &array;s are <glossterm
-     linkend="glossary-first_class">first-class
-     types<firstterm></firstterm></glossterm> so they can be used more
-     widely than built-in &cc; arrays.  For example, &array;s can be
-     used as operands and in assignment statements.  The statement
-     <statement>a = a + b;</statement> adds corresponding elements of
-     &array;s <varname>a</varname> and <varname>b</varname>, assigning
-     the sums to the &array; <varname>a</varname>.  The statement
-     treats each array as one object, rather than requiring the use of
-     one or more loops to access individual values.  Data-parallel
-     statements are further discussed in <xref
-     linkend="data_parallel"></xref>.  &array;s also handle their own
-     memory allocation and deallocation.  For example, the &array;
-     declaration <statement>Array&lt;2, double, Brick&gt;
-     a(vertDomain)</statement> creates an
-     &array;&nbsp;<varname>a</varname>, allocating whatever memory it
-     needs.  When <varname>a</varname> goes out of scope, it and its
-     memory is automatically deallocated.  Automatic memory allocation
-     and deallocation also eases copying.  As we mentioned above, an
-     &array;'s &engine; stores or computes its values so it, not the
-     &array; itself, is responsible for memory allocation and
-     deallocation.  Fortunately, this distinction is usually hidden
-     from the &pooma; user.</para>
- 
-     <para>Individual &array; values can be accessed using parentheses,
-     not square brackets, as for &cc; arrays.  For example,
-     <statement>a(3,4)</statement> yields the value at position (3,4)
-     of <varname>a</varname>'s two-dimensional domain.</para>
-    </section>
- 
- 
-    <section id="arrays-domains">
-     <title>&domain;s</title>
- 
-     <para>A <glossterm
-     linkend="glossary-domain"><firstterm>domain</firstterm></glossterm>
-     specifies the set of points on which an &array; can define values.
-     These indices are the arguments placed within parentheses when
-     selecting particular values, as described previously.  A domain
-     supported both by &array;s and by built-in &cc; arrays is an
-     interval [0,n-1] of integers containing all integers {0, 1, 2,
-     &hellip;, n-1}.  For &cc;, every integer in the interval must be
-     included, and the minimum index must be zero.  &pooma; expands the
-     set of permissible domains to support intervals with nonzero
-     minimal indices and strides and by adding other choices.</para>
- 
-     <para>In &pooma;, &domain;s implement domains.  There are four
-     different categories:
-      <variablelist>
-       <varlistentry>
-        <term>&loc;</term>
-        <listitem>
- 	<para>&domain; with a single point.</para>
-        </listitem>
-       </varlistentry>
-       <varlistentry>
-        <term>&interval;</term>
-        <listitem>
- 	<para>&domain; with an integral interval [a,b].</para>
-        </listitem>
-       </varlistentry>
-       <varlistentry>
-        <term>&range;</term>
-        <listitem>
- 	<para>&domain; with an integral interval [a,b] and an integral
- 	stride&nbsp;s indicating the gap between indices: {a, a+s,
- 	a+2s, &hellip;, b}.</para>
-        </listitem>
-       </varlistentry>
-       <varlistentry>
-        <term>&grid;</term>
-        <listitem>
- 	<para>&domain; with an ascending or descending sequence of
- 	integral values.  The sequence elements must be individually
- 	specified.</para>
-        </listitem>
-       </varlistentry>
-      </variablelist>
-     One-dimensional and multidimensional versions of each categories
-     are supported.  A multidimensional &domain; consists of the direct
-     product of one-dimensional &domain;s.  For example, the first
-     dimension of a two-dimensional interval [0,3]x[2,9] is the
-     interval&nbsp;[0,3], and its second dimension is the
-     interval&nbsp;[2,9].  Its indices are ordered pairs such as (0,2),
-     (0,3), (1,2), (1,9), and&nbsp;(3,7).</para>
- 
-     <para>Many domains can be represented using domain triplets.  A
-     <glossterm linkend="glossary-domain_triplet"><firstterm>domain
-     triplet</firstterm></glossterm>
-     [<varname>begin</varname>:<varname>end</varname>:<varname>stride</varname>]
-     represents the mathematical set {begin, begin + stride, begin +
-     2stride, &hellip;, end}, where <varname>end</varname> is in the
-     set only if it equals <varname>begin</varname> plus some integral
-     multiple of <varname>stride</varname>.  If the
-     <varname>stride</varname> is negative, its beginning index
-     <varname>begin</varname> should at least be as large as
-     <varname>end</varname> if the interval is to be nonempty.  The
-     stride can be zero only if <varname>begin</varname> and
-     <varname>end</varname> are equal.  There are lots of ways to
-     represent an empty interval, e.g., [1:0:1] and [23,34,-1], and
-     &pooma; will accept them, but they are all equivalent.  The domain
-     triplet notation is easily extended to multiple dimensions by
-     separating different dimension's intervals with commas.  For
-     example, [2:4:2,6:4:-2] contains (2,6), (2,4), (4,6),
-     and&nbsp;(4,4).</para>
- 
-     <para>All the &domain; categories listed above except &grid; can be
-     represented using domain triplet notation.  Since the triplet
-     [7:7:1] represents {7}, or more simply&nbsp;7, it can also
-     represent <statement>Loc<1>(7)</statement>.  Multidimensional
-     &loc;s are similarly represented.  For example,
-     [0:0:1,10:10:1,2:2:1] represents
-     <statement>Loc<3>(0,10,2)</statement>, but it is frequently
-     abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
-     [a:b:1], while a &range; has specific stride&nbsp;s:
-     [a:b:s].</para>
- 
-     <para>&domain;s can be constructed by combining &domain;s of smaller
-     dimension.  For example, since a two-dimensional &interval; is the
-     direct product of two one-dimensional &interval;s, it can be
-     specified using two one-dimensional &interval;s.  For example,
-     <statement>Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
-     Interval&lt;1&gt;(4,5))</statement> creates a [2:3:1,4:5:1]
-     &domain;.  The resulting dimensionality equals the sum of the
-     components' dimensions.  For example, a four-dimension &loc; can
-     be specified using three- and one-dimension &loc;s or using four
-     one-dimension &loc;s.  If fewer dimensions than the created
-     object's dimensionality, the last dimensions are unspecified and
-     uninitialized.  &loc;s, &interval;s, &range;s, and &grid;s can all
-     be composed from smaller similar components.</para>
- 
-     <para>A &domain; can be composed from smaller components with
-     different types.  A &loc; object can be constructed from other
-     &loc; objects and integers.  &interval;s, &range;s, and &grid;s
-     can be constructed using any of these types, &loc;s, and integers.
-     For example, <statement>Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2),
-     Interval&lt;1&gt;(3,5))</statement> uses a two-dimensional &loc;
-     and a one-dimensional &interval; to create a [1:1:1,2:2:1,3:5:1]
-     &domain;.  During creation of a &domain;, the type of each object
-     is changed to the &domain;'s type.  In the example,
-     <statement>Loc&lt;2&gt;(1,2)</statement> is first converted to an
-     &interval;.</para>
- 
-     <para>&domain;s can participate in some arithmetic and comparison
-     operations.  For example, a &domain;'s triplet can be shifted two
-     units to the right by adding two.  Multiplying a &domain; by two
-     multiplies its triplet's beginnings, endings, and strides by two.
-     &pooma; users rarely need to compare &domain;s, but we describe
-     operating with the less-than operator on &interval;s.  &interval;
-     <varname>d1</varname> &lt; &interval; <varname>d2</varname> if the
-     length of <varname>d1's</varname> interval is less than
-     <varname>d2</varname>'s or, if equal, its beginning value is
-     smaller.  &domain; arithmetic is frequently used with data-parallel
-     statements and container views.  These will be discussed in <xref
-     linkend="data_parallel"></xref> and <xref
-     linkend="views"></xref>.</para>
- 
-     <para>The current &pooma; implementation supports &domain;s with
-     dimensionality between one and seven, inclusive.  Since most
-     scientific computations use one, two, or three dimensions, this is
-     usually sufficient.  If more dimensions are needed, they can be
-     added to the source code.</para>
-    </section>
- 
  
!    <section id="arrays-domains_declarations">
!     <title>Declaring &domain;s</title>
  
-     <para>Since &domain;s are mainly used to declare container
-     domains, we focus on declaring &domain;s.  Arithmetic operations
-     with &domain;s are described in <xref
-     linkend="views"></xref>.</para>
- 
-     <para>All &domain; declarations require a dimension template
-     parameter&nbsp;<varname>&dim;</varname>.  This positive integer
-     specifies the number of dimensions, i.e., rank, of the &domain; and
-     determines the length of the tuples for points in the &domain;.  For
-     example, a three-dimensional &domain; contains ordered triples,
-     while a one-dimensional &domain; contains singletons, or just
-     integers.  Multidimensional &domain;s are just the direct products
-     of one-dimensional &domain;s so the techniques for declaring
-     one-dimensional &domain;s carry over to multi-dimensional
-     ones.</para>
- 
-     <para>To declare a &domain;, one must include the
-     <filename class="headerfile">Pooma/Domains.h</filename> header
-     file.  However, most &pooma; programs declare &domain;s to use them
-     when constructing containers.  The container header files
-     automatically include <filename
-     class="headerfile">Pooma/Domains.h</filename> so no explicit
-     inclusion is usually necessary.</para>
- 
-     <section id="arrays-domains_declarations-loc">
-      <title>&loc;s</title>
- 
-      <para>A <type>Loc&lt;&dim;&gt;</type> is a &domain; with just a single
-      <varname>&dim;</varname>-dimensional point.  Although it is
-      infrequently used as a container's domain, it is used to refer to
-      a single point within another domain.  Its beginning and ending
-      points are the same, and its stride is one.  One-dimensional
-      &loc;s and integers are frequently interchanged.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0" id="arrays-domains_declarations-loc-one_d_table">
-       <title>Declaring One-Dimensional &loc;s</title>
-      
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>constructor</entry>
- 	 <entry>result</entry>
- 	</row>
-        </thead>
-        <tfoot>
- 	<row>
- 	 <entry><varname>T1</varname>, <varname>T2</varname>, and
- 	 <varname>T3</varname> are template parameters.</entry>
- 	 <entry></entry>
- 	</row>
-        </tfoot>
-        <tbody>
- 	<row>
- 	 <entry><statement>Loc&lt;1&gt;()</statement></entry>
- 	 <entry>points to zero.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
- 	 <entry>creates an uninitialized &locone;, to be assigned a value later.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;1&gt;(const T1&amp; t1)</statement></entry>
- 	 <entry>creates a &locone; with the integer converted from <varname>t1</varname>.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;1&gt;(const T1&amp; t1, const T2&amp; t2)</statement></entry>
- 	 <entry>creates a &locone; with the integer converted from
- 	 <varname>t1</varname>.  <varname>t2</varname> must equal
- 	 <varname>t1</varname>.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;1&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)</statement></entry>
- 	 <entry>creates a &locone; with the integer converted from
- 	 <varname>t1</varname>.  <varname>t2</varname> must equal
- 	 <varname>t1</varname>, and <varname>t3</varname> is
- 	 ignored.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
-      <para>Constructors for one-dimensional &loc;s appear in <xref
-      linkend="arrays-domains_declarations-loc-one_d_table"></xref>.
-      The empty constructor yields the zero point.  The constructor
-      taking a <type>Pooma::Init</type> object does not initialize the
-      resulting &loc; to any particular value.  Presumably, the value
-      will be assigned later.  For small &domain;s such as &loc;s, the
-      time savings from not initializing is small, but the
-      functionality is still available.  The constructor taking one
-      argument with type&nbsp;<type>T1</type> converts this argument to
-      an integer to specify the point.  The template
-      type&nbsp;<type>T1</type> may be any type that can be converted
-      to an integer, e.g., &bool;, &char;, &int;, or &double;.  The
-      constructors taking two and three arguments of templatized types
-      facilitate converting an &interval; and a &range; into a &loc;.
-      Since a &loc; represents a single point, the &interval;'s or
-      &range;'s first two arguments must be equal.  The stride is
-      ignored.  Again, the templatized types may be any type that can
-      be converted into an integer.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0" id="arrays-domains_declarations-loc-multi_d_table">
-       <title>Declaring Multidimensional &loc;s</title>
-      
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>constructor</entry>
- 	 <entry>result</entry>
- 	</row>
-        </thead>
-        <tfoot>
- 	<row>
- 	 <entry><varname>&dim;</varname> indicates the &loc;'s dimension.
- 	 <varname>T1</varname>, <varname>T2</varname>, &hellip; are
- 	 template parameters.</entry>
- 	</row>
-        </tfoot>
-        <tbody>
- 	<row>
- 	 <entry><statement>Loc&lt;&dim;&gt;()</statement></entry>
- 	 <entry>points to zero.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
- 	 <entry>creates an uninitialized &loc;, to be assigned a value later.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;&dim;&gt;(const T1&amp; t1)</statement></entry>
- 	 <entry>creates a &loc; using the given &domain; object.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2)</statement></entry>
- 	 <entry>creates a &loc; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)</statement></entry>
- 	 <entry>creates a &loc; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4)</statement></entry>
- 	 <entry>creates a &loc; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5)</statement></entry>
- 	 <entry>creates a &loc; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6)</statement></entry>
- 	 <entry>creates a &loc; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Loc&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6, const T7&amp; t7)</statement></entry>
- 	 <entry>creates a &loc; using the given &domain; objects.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
-      <para>Constructors for multidimensional &loc;s appear in <xref
-      linkend="arrays-domains_declarations-loc-multi_d_table"></xref>.
-      <varname>&dim;</varname>&nbsp;indicates the &loc;'s dimension.  The
-      first two constructors are similar to &locone;'s first two
-      constructors, returning a representation of the zero point and
-      returning an uninitialized point.  The seven other constructors
-      create a &loc; using other &domain; objects.  These &domain; objects,
-      having types <type>T1</type>, &hellip;, <type>T7</type>, can have
-      any type that can be converted into an integer, to a &locone;, or
-      to a multidimensional &domain; object that itself can be converted
-      into a &loc;.  The total dimensionality of all the arguments'
-      types should be at most&nbsp;<varname>&dim;</varname>.  For example,
-      <statement>Loc<5>(Range<1>(2,2,2), Loc<2>(2,3),
-      Interval<1>(4,4))</statement> creates a five-dimensional &loc;
-      [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
-      &loc;, and a one-dimensional &interval;.  The final fifth
-      dimension has an unspecified value, in this case&nbsp;1.  The
-      one-dimensional &range; is converted into the single integer two;
-      its beginning and ending points must be the same.  The
-      two-dimensional &loc; contributes values for the next two
-      dimensions, while the &interval; contributes its beginning point,
-      which must be the same as its ending point.  Note that the
-      &locone; constructors taking two and three parameters ignore
-      their second and third arguments, but this is not true for the
-      multidimensional constructors.</para>
-     </section>
- 
- 
-     <section id="arrays-domains_declarations-intervals">
-      <title>&interval;s</title>
- 
-      <para>A one-dimensional &interval; represents a set of integers
-      within a mathematical <glossterm
-      linkend="glossary-interval">interval</glossterm>.
-      Multidimensional &interval;s represent their multidimensional
-      generalization, i.e., the direct product of one-dimensional
-      intervals.  &interval;s are arguably the most commonly used
-      &pooma; &domain;.  A one-dimensional &interval; has integral
-      beginning and ending points and a unit stride.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0" id="arrays-domains_declarations-interval-one_d_table">
-       <title>Declaring One-Dimensional &interval;s</title>
-      
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>constructor</entry>
- 	 <entry>result</entry>
- 	</row>
-        </thead>
-        <tfoot>
- 	<row>
- 	 <entry><varname>T1</varname>, <varname>T2</varname>, and
- 	 <varname>T3</varname> are template parameters.</entry>
- 	 <entry></entry>
- 	</row>
-        </tfoot>
-        <tbody>
- 	<row>
- 	 <entry><statement>Interval&lt;1&gt;()</statement></entry>
- 	 <entry>creates an empty, uninitialized interval.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
- 	 <entry>creates an uninitialized &intervalone;, to be assigned a value later.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;1&gt;(const T1&amp; t1)</statement></entry>
- 	 <entry>creates a &intervalone;.  See the text for an explanation.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;1&gt;(const T1&amp; t1, const T2&amp; t2)</statement></entry>
- 	 <entry>creates a &intervalone; with the integers converted from
- 	 <varname>t1</varname> and <varname>t2</varname>.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;1&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)</statement></entry>
- 	 <entry>creates a &intervalone; with the integers converted from
- 	 <varname>t1</varname> and <varname>t2</varname>.
- 	 <varname>t3</varname> must equal&nbsp;1.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
-      <para>&intervalone; constructors are patterned on &locone;
-      constructors except that &intervalone;s can have differing
-      beginning and ending points.  See <xref
-      linkend="arrays-domains_declarations-interval-one_d_table"></xref>.
-      The default constructor creates an empty, uninitialized interval,
-      which should not be used before assigning it values.  If the
-      one-parameter constructor's argument is a &domain; object, it must
-      be a one-dimensional &domain; object which is copied into an
-      &interval; if possible; for example, it must have unit stride.
-      If the one-parameter constructor's argument is not a &domain;
-      object, it must be convertible to an
-      integer&nbsp;<varname>e</varname> and an interval [0:e-1:1]
-      starting at zero is constructed.  If two arguments are specified,
-      they are assumed to be convertible to integers
-      <varname>b</varname> and <varname>e</varname>, specifying the
-      interval [b:e:1].  The three-parameter constructor is similar,
-      with the third argument specifying a stride, which must be
-      one.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0" id="arrays-domains_declarations-intervals-multi_d_table">
-       <title>Declaring Multidimensional &interval;s</title>
-      
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>constructor</entry>
- 	 <entry>result</entry>
- 	</row>
-        </thead>
-        <tfoot>
- 	<row>
- 	 <entry><varname>&dim;</varname> indicates the &interval;'s dimension.
- 	 <varname>T1</varname>, <varname>T2</varname>, &hellip; are
- 	 template parameters.</entry>
- 	</row>
-        </tfoot>
-        <tbody>
- 	<row>
- 	 <entry><statement>Interval&lt;&dim;&gt;()</statement></entry>
- 	 <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
- 	 <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;&dim;&gt;(const T1&amp; t1)</statement></entry>
- 	 <entry>creates a &interval; using the given &domain; object.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2)</statement></entry>
- 	 <entry>creates a &interval; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)</statement></entry>
- 	 <entry>creates a &interval; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4)</statement></entry>
- 	 <entry>creates a &interval; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5)</statement></entry>
- 	 <entry>creates a &interval; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6)</statement></entry>
- 	 <entry>creates a &interval; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Interval&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6, const T7&amp; t7)</statement></entry>
- 	 <entry>creates a &interval; using the given &domain; objects.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
-      <para>Constructors for multidimensional &interval;s closely
-      follow constructors for multidimensional &loc;s.  See <xref
-      linkend="arrays-domains_declarations-intervals-multi_d_table"></xref>.
-      <varname>&dim;</varname>&nbsp;indicates the &interval;'s dimension.
-      The first two constructors both return empty, uninitialized
-      intervals.  The seven other constructors create an &interval;
-      using &domain; objects.  These &domain; objects, having types
-      <type>T1</type>, &hellip;, <type>T7</type>, can have any type
-      that can be converted into an integer, into a single-dimensional
-      &domain; object that can be converted into a single-dimensional
-      &interval;, or to a multidimensional &domain; object that itself
-      can be converted into an &interval;.  The total dimensionality of
-      all the arguments' types should be at
-      most&nbsp;<varname>&dim;</varname>.  One-dimensional &domain; objects
-      that can be converted into one-dimensional &interval;s include
-      &locone;s, &intervalone;s, and &rangeone;s with unit strides.  If
-      the sum of the objects' dimensions is less
-      than&nbsp;<varname>&dim;</varname>, the intervals for the final
-      dimensions are unspecified.  See the last paragraph of <xref
-      linkend="arrays-domains_declarations-loc"></xref> for an
-      analogous example.  Note that the &intervalone; constructors
-      taking two and three parameters treat these arguments differently
-      than the multidimensional constructors do.</para>
-     </section>
- 
- 
-     <section id="arrays-domains_declarations-ranges">
-      <title>&range;s</title>
- 
-      <para>A one-dimensional &range; generalizes an &interval; by
-      permitting a non-unit stride between integral members.  A
-      <glossterm
-      linkend="glossary-range"><firstterm>range</firstterm></glossterm>
-      is a set of integers in a mathematical interval [b,e] with a
-      stride&nbsp;s between them: {a, a+s, a+2s, &hellip;, b}.  Ranges
-      are generalized to <varname>&dim;</varname>&nbsp;dimensions using the
-      direct product of one-dimensional ranges.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0" id="arrays-domains_declarations-range-one_d_table">
-       <title>Declaring One-Dimensional &range;s</title>
-      
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>constructor</entry>
- 	 <entry>result</entry>
- 	</row>
-        </thead>
-        <tfoot>
- 	<row>
- 	 <entry><varname>T1</varname>, <varname>T2</varname>, and
- 	 <varname>T3</varname> are template parameters.</entry>
- 	 <entry></entry>
- 	</row>
-        </tfoot>
-        <tbody>
- 	<row>
- 	 <entry><statement>Range&lt;1&gt;()</statement></entry>
- 	 <entry>creates an empty, uninitialized range.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
- 	 <entry>creates an uninitialized &rangeone;, to be assigned a value later.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;1&gt;(const T1&amp; t1)</statement></entry>
- 	 <entry>creates a &rangeone;.  See the text for an explanation.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;1&gt;(const T1&amp; t1, const T2&amp; t2)</statement></entry>
- 	 <entry>creates a &rangeone; with an interval specified by the
- 	 integers converted from <varname>t1</varname> and
- 	 <varname>t2</varname>.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;1&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)</statement></entry>
- 	 <entry>creates a &rangeone; by converting the arguments to
- 	 integers <varname>i1</varname>, <varname>i2</varname>, and
- 	 <varname>i3</varname> and then making a range [i1:i2:i3].</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
-      <para>&rangeone; constructors are the same as &intervalone;
-      constructors except they create ranges, not intervals.  See <xref
-      linkend="arrays-domains_declarations-range-one_d_table"></xref>.
-      The default constructor creates an empty, uninitialized range,
-      which should not be used before assigning it values.  If the
-      one-parameter constructor's argument is a &domain; object, it must
-      be a one-dimensional &domain; object which is copied into a &range;
-      if possible.  If the one-parameter constructor's argument is not
-      a &domain; object, it must be convertible to an
-      integer&nbsp;<varname>e</varname> and a range [0:e-1:1] starting
-      at zero is constructed.  If two arguments are specified, they are
-      assumed to be convertible to integers <varname>b</varname> and
-      <varname>e</varname>, specifying the range [b:e:1].  The
-      three-parameter constructor is similar, with the third argument
-      specifying a stride.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0" id="arrays-domains_declarations-ranges-multi_d_table">
-       <title>Declaring Multidimensional &range;s</title>
-      
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>constructor</entry>
- 	 <entry>result</entry>
- 	</row>
-        </thead>
-        <tfoot>
- 	<row>
- 	 <entry><varname>&dim;</varname> indicates the &range;'s dimension.
- 	 <varname>T1</varname>, <varname>T2</varname>, &hellip; are
- 	 template parameters.</entry>
- 	</row>
-        </tfoot>
-        <tbody>
- 	<row>
- 	 <entry><statement>Range&lt;&dim;&gt;()</statement></entry>
- 	 <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
- 	 <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;&dim;&gt;(const T1&amp; t1)</statement></entry>
- 	 <entry>creates a &range; using the given &domain; object.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2)</statement></entry>
- 	 <entry>creates a &range; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)</statement></entry>
- 	 <entry>creates a &range; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4)</statement></entry>
- 	 <entry>creates a &range; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5)</statement></entry>
- 	 <entry>creates a &range; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6)</statement></entry>
- 	 <entry>creates a &range; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Range&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6, const T7&amp; t7)</statement></entry>
- 	 <entry>creates a &range; using the given &domain; objects.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
-      <para>Constructors for multidimensional &range;s are the same as
-      multidimensional &interval; constructors except they create
-      ranges, not intervals.  See <xref
-      linkend="arrays-domains_declarations-ranges-multi_d_table"></xref>.
-      <varname>&dim;</varname>&nbsp;indicates the &range;'s dimension.  The
-      first two constructors return empty, uninitialized ranges.
-      The seven other constructors create an &range; using &domain;
-      objects.  These &domain; objects, having types <type>T1</type>,
-      &hellip;, <type>T7</type>, can have any type that can be
-      converted into an integer, into a single-dimensional &domain;
-      object that can be converted into a single-dimensional &range;,
-      or to a multidimensional &domain; object that itself can be
-      converted into an &range;.  The total dimensionality of all the
-      arguments' types should be at most&nbsp;<varname>&dim;</varname>.
-      One-dimensional &domain; objects that can be converted into
-      one-dimensional &range;s include &locone;s, &intervalone;s, and
-      &rangeone;s.  If the sum of the objects' dimensions is less
-      than&nbsp;<varname>&dim;</varname>, the ranges for the final
-      dimensions are unspecified.  See the last paragraph of <xref
-      linkend="arrays-domains_declarations-loc"></xref> for an
-      analogous example.  Note that the &rangeone; constructors taking
-      two and three parameters treat these arguments differently than
-      the multidimensional constructors do.</para>
-     </section>
- 
- 
-     <section id="arrays-domains_declarations-grids">
-      <title>&grid;s</title>
- 
-      <para>&loc;s, &interval;s, and &range;s all have regularly spaced
-      integral values so they can be represented using <glossterm
-      linkend="glossary-domain_triplet">domain triplets</glossterm>.
-      One-dimensional &grid; integral domains contain ascending or
-      descending sequences of integers, with no fixed stride.  For
-      example, a &gridone; may represent {-13, 1, 4, 5, 34}.  &gridone;
-      is generalized to multidimensional &grid;s using the direct
-      product of &gridone; &domain;s.</para>
- 
-      <para>&grid;s that can be represented using domain triplets can
-      be constructed using techniques similar to other &domain;s, but
-      irregularly spaced domains can be constructed using
-      &indirectionlistint;s.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0" id="arrays-domains_declarations-grid-one_d_table">
-       <title>Declaring One-Dimensional &grid;s</title>
-      
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>constructor</entry>
- 	 <entry>result</entry>
- 	</row>
-        </thead>
-        <tfoot>
- 	<row>
- 	 <entry><varname>T1</varname>, <varname>T2</varname>, and
- 	 <varname>T3</varname> are template parameters.</entry>
- 	 <entry></entry>
- 	</row>
-        </tfoot>
-        <tbody>
- 	<row>
- 	 <entry><statement>Grid&lt;1&gt;()</statement></entry>
- 	 <entry>creates an empty, uninitialized grid.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;1&gt;(const T1&amp; t1)</statement></entry>
- 	 <entry>creates a &gridone;.  See the text for an explanation.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;1&gt;(const T1&amp; t1, const T2&amp; t2)</statement></entry>
- 	 <entry>creates a &gridone; from the interval specified by the
- 	 integers converted from <varname>t1</varname> and
- 	 <varname>t2</varname>.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;1&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)</statement></entry>
- 	 <entry>creates a &gridone; from the domain triplet specified
- 	 by the integers converted from <varname>t1</varname>,
- 	 <varname>t2</varname>, and <varname>t3</varname>.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
-      <para>To construct a &gridone; that can also be represented by a
-      domain triplet, use a &gridone; constructor similar to those for
-      &intervalone; and &rangeone;.  See <xref
-      linkend="arrays-domains_declarations-grid-one_d_table"></xref>
-      and the text explanations following <xref
-      linkend="arrays-domains_declarations-range-one_d_table"></xref>
-      or <xref
-      linkend="arrays-domains_declarations-interval-one_d_table"></xref>.</para>
- 
-      <para>&gridone;s with irregularly spaced points can be
-      constructed using &indirectionlistint;s.  For example,
- <programlisting>
- IndirectionList&lt;int&gt; list(4);
- list(0) = 2;
- list(1) = 5;
- list(2) = 6;
- list(3) = 9;
- Grid&lt;1&gt; g(list);
- </programlisting> constructs an empty &indirectionlistint;, fills it
-      with ascending values, and then creates a &gridone; containing
-      {2, 5, 6, 9}.  When creating a list, its size must be specified.
-      Subsequently, its values can be assigned.  &indirectionlist;s can
-      also be initialized using one-dimensional &array;s:
- <programlisting>
- Array&lt;1,int,Brick&gt; a1(Interval&lt;1&gt;(0,3));
- a1(0) = 2; a1(1) = 5; a1(2) = 6; a1(3) = 9;
- IndirectionList&lt;int&gt; il(a1);
- Grid&lt;1&gt; g1(il);
- </programlisting>  The &array; stores the integral points to include
-      in the &gridone; and is used to create the &indirectionlistint;,
-      which itself is used to create the &gridone;.  Since the points
-      are integers, the &array;'s type is &int;.  Either a &brick; or
-      &compressiblebrick; &engine; should be used.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0" id="arrays-domains_declarations-grids-multi_d_table">
-       <title>Declaring Multidimensional &grid;s</title>
-      
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>constructor</entry>
- 	 <entry>result</entry>
- 	</row>
-        </thead>
-        <tfoot>
- 	<row>
- 	 <entry><varname>&dim;</varname> indicates the &grid;'s dimension.
- 	 <varname>T1</varname>, <varname>T2</varname>, &hellip; are
- 	 template parameters.</entry>
- 	</row>
-        </tfoot>
-        <tbody>
- 	<row>
- 	 <entry><statement>Grid&lt;&dim;&gt;()</statement></entry>
- 	 <entry>creates an empty, uninitialized &grid;, to be assigned a value later.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;&dim;&gt;(const T1&amp; t1)</statement></entry>
- 	 <entry>creates a &grid; using the given &domain; object.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2)</statement></entry>
- 	 <entry>creates a &grid; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;&dim;&gt;(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3)</statement></entry>
- 	 <entry>creates a &grid; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4)</statement></entry>
- 	 <entry>creates a &grid; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5)</statement></entry>
- 	 <entry>creates a &grid; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6)</statement></entry>
- 	 <entry>creates a &grid; using the given &domain; objects.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;&dim;&gt;(const T1&amp; t1, const
- 	 T2&amp; t2, const T3&amp; t3, const T4&amp; t4, const T5&amp;
- 	 t5, const T6&amp; t6, const T7&amp; t7)</statement></entry>
- 	 <entry>creates a &grid; using the given &domain; objects.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
-      <para>Constructors for multidimensional &grid;s are the same as
-      multidimensional &interval; constructors except they create
-      &grid;s, not intervals.  See <xref
-      linkend="arrays-domains_declarations-grids-multi_d_table"></xref>.
-      <varname>&dim;</varname>&nbsp;indicates the &grid;'s dimension.  The
-      first constructor returns empty, uninitialized grids.  The seven
-      other constructors create an &grid; using &domain; objects.  These
-      &domain; objects, having types <type>T1</type>, &hellip;,
-      <type>T7</type>, can have any type that can be converted into an
-      integer, into a single-dimensional &domain; object that can be
-      converted into a single-dimensional &grid;, or to a
-      multidimensional &domain; object that itself can be converted into
-      an &grid;.  The total dimensionality of all the arguments' types
-      should be at most&nbsp;<varname>&dim;</varname>.  One-dimensional
-      &domain; objects that can be converted into one-dimensional &grid;s
-      include &locone;s, &intervalone;s, &rangeone;s, and &gridone;s.
-      If the sum of the objects' dimensions is less
-      than&nbsp;<varname>&dim;</varname>, the grids for the final
-      dimensions are unspecified.  See the last paragraph of <xref
-      linkend="arrays-domains_declarations-loc"></xref> for an
-      analogous example.  Note that the &gridone; constructors taking
-      two and three parameters treat these arguments differently than
-      the multidimensional constructors do.</para>
-     </section>
-    </section>
- 
- 
-    <section id="arrays-arrays_use">
-     <title>Declaring and Using &array;s</title>
- 
-     <para>A &pooma; &array; maps indices from its &domain; to values.
-     In this section, we describe first describe how to declare
-     &array;s.  Then, we explain how to access individual values stored
-     or computed by an &array; and their copy semantics.</para>
- 
-     <para>&array; values need not just be stored values, as &c; arrays
-     have.  They can also be computed using its engine.  We defer
-     discussion of computing values to the next chapter discussing
-     engines (<xref linkend="engines"></xref>).  To avoid being verbose
-     in this chapter, when we discuss stored values, the values might
-     instead be computed.</para>
- 
-     <para>Declaring an &array; requires four arguments: the domain's
-     dimensionality, the type of values stored or computed, a
-     specification how the values are stored, and a &domain;.  The
-     first three arguments are template parameters since few scientific
-     programs (and no &pooma; programs) need to change these values
-     while a program executes.  For example, an &array; cannot change
-     the type of the elements it stores.  Alternatively, an &array;'s
-     values can be copied into another &array; having the desired type.
-     Although scientific programs do not frequently change an array's
-     domain, they do frequently request a subset of the array's values,
-     i.e., a <glossterm linkend="glossary-view">view</glossterm>.  The
-     subset is specified via a &domain; so it is a run-time value.
-     Views are presented in <xref linkend="views"></xref>.</para>
- 
-     <para>An &array;'s first template parameter specifies its
-     dimensionality.  This positive
-     integer&nbsp;<varname>&dim;</varname> specifies its rank.  This is
-     the same value as its domain's dimensionality.  Theoretically, an
-     &array; can have any positive integer, but the &pooma; code
-     currently supports <varname>&dim;</varname> at most seven.  For
-     almost all scientific codes, a dimension of three or four is
-     sufficient, but the code can be extended to support higher
-     dimensions.</para>
- 
-     <para>An &array;'s second template parameter specifies the type of
-     its stored values.  Common value types include &int;, &double;,
-     &complex;, and &vector;, but any type is permissible.  For
-     example, an &array;'s values might be matrices or even other
-     &array;s.</para>
- 
-     <para>An &array;'s third parameter specifies how its data is
-     stored by an &engine; and its values accessed.  The argument is a
-     tag indicating a particular type of &engine;.  Permissible tags
-     include &brick;, &compressiblebrick;, and
-     <type>ConstantFunction</type>.  The &brick; tag indicates all
-     &array; values will be explicitly stored, just as built-in &c;
-     arrays do.  If the &array;s frequently stores exactly the same
-     value in every position, a &compressiblebrick; &engine;, which
-     reduces its space requirements to a constant whenever all its
-     values are the same, is appropriate.  A
-     <type>ConstantFunction</type> &engine; returns the same value for
-     all indices.</para>
- 
-     <para>Even though every &array; container has an engine to store
-     its values and permit access to individual values, an &array; is
-     conceptually separated from engines.  An engine's role is
-     low-level, storing values and permitting access to individual
-     values.  As we indicated above, the storage can be optimized to
-     fit specific situations such as few nonzero values and computing
-     values using a function applied to another engine's values.  An
-     &array;'s role is high-level, supporting access to groups of
-     values.  They handle memory allocation and deallocation.  &array;s
-     can be used in data-parallel expressions, e.g., adding all the
-     values in one &array; to all the values in another.  (See <xref
-     linkend="data_parallel"></xref> for more information.)  Subsets of
-     &array; values, frequently used in data-parallel statements, can
-     be obtained.  (See <xref linkend="views"></xref> for more
-     information.)  Even though engines and &array;s are conceptually
-     separate, higher-level &array;s provide access to lower-level
-     &engine;s.  Users usually have an &array; create its &engine;,
-     rarely explicitly creating &engine;s themselves.  Also, &array;s
-     provide access to individual values.  In short, &pooma; users use
-     &array;s, only dealing with how they are implemented (engines)
-     upon declaration.  For more description of &engine;s, see <xref
-     linkend="engines"></xref>.</para>
- 
-     <para>An &array;'s one constructor argument is its domain.  The
-     domain specifies its extent and simultaneously how many values it
-     can return.  All the provided &domain; objects are combined to
-     yield an <type>Interval&lt;&dim;&gt;</type>, where &dim; matches
-     the &array;'s first template parameter.  Since an &interval;
-     domain with its unit strides is used, there are no unaccessed
-     <quote>gaps</quote> within the domain, wasting storage space.  To
-     use other domains to access an &array;, first create it using an
-     &interval; domain and then take a view of it, as described in
-     <xref linkend="views"></xref>.  As we mentioned above, the current
-     &pooma; code supports up to seven dimensions so at most seven
-     &domain; objects can be provided.  If more dimensions are
-     required, the &pooma; code can be extended to the desired number
-     of dimensions.</para>
- 
-     <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	   orient="port" pgwide="0" id="arrays-arrays_use-table">
-      <title>Declaring &array;s</title>
-      
-      <tgroup cols="2" align="left">
-       <thead>
-        <row>
- 	<entry>&array; declaration</entry>
- 	<entry>result</entry>
-        </row>
-       </thead>
-       <tfoot>
-        <row>
- 	<entry>Template parameters <varname>&dim;</varname>,
- 	 <varname>T</varname>, and <varname>E</varname> indicates the
- 	 &array;'s dimension, value type, and &engine; type,
- 	 respectively, as do <varname>D1</varname>,
- 	 <varname>T1</varname>, and <varname>E1</varname>.
- 	 <varname>DT1</varname>, &hellip;, <varname>DT7</varname>
- 	 indicate domain types.</entry>
-        </row>
-       </tfoot>
-       <tbody>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;()</statement></entry>
- 	<entry>creates an empty, uninitialized &array;, which must be
- 	<function>initialize</function>()d before use.</entry>
-        </row>
-        <!-- Omit Indirection Array because src/Engine/IndirectionEngine.h indicates it is not yet finished. -->
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const Array&lt;D1,T1,E1&gt;&amp; a)</statement></entry>
- 	<entry>creates an &array; by copying another one.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const
- 	Array&lt;D1,T1,E1&gt;&amp; a, const Dom&amp; d)</statement></entry>
- 	<entry>creates an &array; by copying another one but using the
- 	specified domain.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1)</statement></entry>
- 	<entry>creates an &array; using the given &domain; object.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5, const DT6&amp; t6)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5, const DT6&amp; t6, const DT7&amp; t7)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1,
- 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
- 	<entry>creates an &array; using the given &domain; object and
- 	then initializes all entries using <varname>model</varname>.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2,
- 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects and
- 	then initializes all entries using <varname>model</varname>.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
- 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects and
- 	then initializes all entries using <varname>model</varname>.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
- 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects and
- 	then initializes all entries using <varname>model</varname>.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5,
- 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects and
- 	then initializes all entries using <varname>model</varname>.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5, const DT6&amp; t6,
- 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects and
- 	then initializes all entries using <varname>model</varname>.</entry>
-        </row>
-        <row>
- 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
- 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
- 	 t5, const DT6&amp; t6, const DT7&amp; t7,
- 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
- 	<entry>creates a &array; using the given &domain; objects and
- 	then initializes all entries using <varname>model</varname>.</entry>
-        </row>
-       </tbody>
-      </tgroup>
-     </table>
- 
-     <para>&array; constructors are listed in <xref
-     linkend="arrays-arrays_use-table"></xref>.  An &array;s' three
-     template parameters for dimensionality, value type, and engine
-     type are abbreviated <varname>D</varname>, <varname>T</varname>,
-     and <varname>E</varname>.  <varname>D1</varname>,
-     <varname>T1</varname>, and <varname>E1</varname> are analogous.
-     Template parameters for &domain; types 
- 
- HERE</para>
- 
-     <para>list ?all? possible declarations
-       perhaps this involves copying all possible domain declarations
- 
-     table of <function>initialize</function>() versions
- 
-     use: (element-wise only for now)
-     how to assign and access particular elements
-     use a single set of parentheses, not multiple brackets
- 
-     semantics of copies and references
-       based on engines
- 
- HERE</para>
-    </section>
- 
- 
-    <section id="arrays-doof2d">
-     <title>An &array; Implementation of &doof2d;</title>
- 
-     <para>mostly copy pp.35-38 from tutorial chapter
- HERE</para>
-    </section>
- 
- 
-    <section id="arrays-implementation">
-     <title>Implementing &array;s</title>
- 
-     <para>What to write?
- 
-     Do I need to describe the public interface of Domains?  Do I need
-     to describe how a programmer would implement a new type of domain?
-     Probably not.
- 
- HERE</para>
-    </section>
- 
- <!-- HERE -->
- 
-   </chapter>
- 
- 
    <chapter id="engines">
     <title>Engines</title>
  
!    <para>
! HERE</para>
    </chapter>
  
    &data-parallel-chapter;
  
  
--- 350,365 ----
    &tutorial-chapter;
  
    &concepts-chapter;
  
!   &arrays-chapter;
  
    <chapter id="engines">
     <title>Engines</title>
  
!    <para>UNFINISHED</para>
    </chapter>
  
+ 
    &data-parallel-chapter;
  
  
*************** HERE</para>
*** 1584,1590 ****
  
     <para>Be sure to list the various arithmetic operations on domains
     that can be used.  This was deferred from the &array; and domain
!    chapter.</para>
  
  <!-- FIXME: Finish this chapter. -->
    </chapter>
--- 368,374 ----
  
     <para>Be sure to list the various arithmetic operations on domains
     that can be used.  This was deferred from the &array; and domain
!    chapter.  Explain &array;'s <function>comp</function> function.</para>
  
  <!-- FIXME: Finish this chapter. -->
    </chapter>
*************** HERE</para>
*** 1592,1605 ****
    <chapter id="sequential">
     <title>Writing Sequential Programs</title>
  
!    <para>FIXME: Explain the chapter's purpose.
! HERE</para>
  
!    <para>FIXME: Explain the format of each section.
! HERE</para>
  
!    <para>FIXME: Explain the order of the sections.
! HERE</para>
  
     <para>Proposed order.  Basically follow the order in the proposed
     reference section.
--- 376,386 ----
    <chapter id="sequential">
     <title>Writing Sequential Programs</title>
  
!    <para>FIXME: Explain the chapter's purpose.</para>
  
!    <para>FIXME: Explain the format of each section.</para>
  
!    <para>FIXME: Explain the order of the sections.</para>
  
     <para>Proposed order.  Basically follow the order in the proposed
     reference section.
*************** HERE</para>
*** 1772,1778 ****
      <title>Beginning and Ending &pooma; Programs</title>
  
      <para>Every &pooma; program must begin with a call to
!     <function>initialize</function> and end with a call to
      <function>finalize</function>.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.</para>
  
--- 553,559 ----
      <title>Beginning and Ending &pooma; Programs</title>
  
      <para>Every &pooma; program must begin with a call to
!     <methodname>initialize</methodname> and end with a call to
      <function>finalize</function>.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.</para>
  
*************** HERE</para>
*** 1822,1828 ****
      <bridgehead id="sequential-begin_end-description" renderas="sect2">Description</bridgehead>
  
       <para>Before its use, the &poomatoolkit; must be initialized by a
!      call to <function>initialize</function>.  This usually occurs in
       the <function>main</function> function.  The first form removes
       and processes any &pooma;-specific arguments from the
       command-line arguments <varname>argv</varname> and
--- 603,609 ----
      <bridgehead id="sequential-begin_end-description" renderas="sect2">Description</bridgehead>
  
       <para>Before its use, the &poomatoolkit; must be initialized by a
!      call to <methodname>initialize</methodname>.  This usually occurs in
       the <function>main</function> function.  The first form removes
       and processes any &pooma;-specific arguments from the
       command-line arguments <varname>argv</varname> and
*************** HERE</para>
*** 1844,1850 ****
       architecture-specific initialization.  The function always
       returns &true;.</para>
  
!      <para><function>initialize</function>'s alternative form
       assumes the &pooma;-specific and architecture-specific
       command-line arguments have already been removed from
       <varname>argv</varname> and <varname>argc</varname> and stored in
--- 625,631 ----
       architecture-specific initialization.  The function always
       returns &true;.</para>
  
!      <para><methodname>initialize</methodname>'s alternative form
       assumes the &pooma;-specific and architecture-specific
       command-line arguments have already been removed from
       <varname>argv</varname> and <varname>argc</varname> and stored in
*************** HERE</para>
*** 1872,1878 ****
      <bridgehead id="sequential-begin_end-example" renderas="sect2">Example Program</bridgehead>
  
       <para>Since every &pooma; program must call
!      <function>initialize</function> and
       <function>finalize</function>, the simplest &pooma; program also
       must call them.  This program also illustrates their usual
       use.</para>
--- 653,659 ----
      <bridgehead id="sequential-begin_end-example" renderas="sect2">Example Program</bridgehead>
  
       <para>Since every &pooma; program must call
!      <methodname>initialize</methodname> and
       <function>finalize</function>, the simplest &pooma; program also
       must call them.  This program also illustrates their usual
       use.</para>
*************** HERE</para>
*** 1908,1914 ****
         </row>
         <row>
  	<entry>&inform; <varname>pwarn</varname></entry>
! 	<entry>HERE output stream used to print informative messages to the
  	user while the program executes.  The stream accepts a
  	superset of standard output operations.</entry>
         </row>
--- 689,695 ----
         </row>
         <row>
  	<entry>&inform; <varname>pwarn</varname></entry>
! 	<entry>FIXME: output stream used to print informative messages to the
  	user while the program executes.  The stream accepts a
  	superset of standard output operations.</entry>
         </row>
*************** HERE</para>
*** 1918,1925 ****
  
     </section>
  
- <!-- HERE -->
- 
     <section id="sequential-options">
      <title>&pooma; Command-line Options</title>
  
--- 699,704 ----
*************** UNFINISHED</para>
*** 1944,1961 ****
  	executes.</para>
         </listitem>
        </varlistentry>
! <!-- HERE -->
       </variablelist>
  
       <para>FIXME: Be sure to list default values.</para>
! <!-- HERE: need to describe the pinfo, pwarn, and perr streams somewhere.  To do so requires describing informs.-->
! <!-- HERE: Which streams are buffered and which are not? -->
  
- <!-- HERE -->
- 
      </section>
- 
- <!-- HERE -->
  
     </section><!-- end sequential-options -->
  
--- 723,736 ----
  	executes.</para>
         </listitem>
        </varlistentry>
! <!-- UNFINISHED -->
       </variablelist>
  
       <para>FIXME: Be sure to list default values.</para>
! <!-- FIXME: need to describe the pinfo, pwarn, and perr streams somewhere.  To do so requires describing informs.-->
! <!-- FIXME: Which streams are buffered and which are not? -->
  
      </section>
  
     </section><!-- end sequential-options -->


From oldham at codesourcery.com  Tue Jan 22 15:55:42 2002
From: oldham at codesourcery.com (Jeffrey Oldham)
Date: Tue, 22 Jan 2002 07:55:42 -0800
Subject: Manual Patch: DynamicArrays and Part of Engines
Message-ID: <20020122075542.A32076@codesourcery.com>

This patch mainly adds a description of DynamicArrays, an unfinished
section on simple Domain accessors, and an unfinished chapter on
Engines.  (Mark, I was working on the Engines chapter, but the Dynamic
Engine led me back to the Arrays chapter.  Sorry.)

2002-Jan-22  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* arrays.xml: Add (unfinished) Domain use section, making Domain
	declarations section a subsection of 'Domains' section.  Add
	DynamicArray section.
	* concepts.xml: s/multi-dimensional/multidimensional/g
	* glossary.xml (function object): New definition.
	s/multi-dimensional/multidimensional/g
	* manual.xml: Add unfinished Engines chapter, explaining the
	concepts, a table of Engines, and descriptions of Brick and
	CompressibleBrick.
	s/<methodname>initialize</methodname>/<function>initialize</function>/
	as appropriate.
	* tutorial.xml: s/multi-dimensional/multidimensional/g

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.1
diff -c -p -r1.1 arrays.xml
*** arrays.xml	2002/01/16 00:50:27	1.1
--- arrays.xml	2002/01/22 15:37:14
***************
*** 233,968 ****
      scientific computations use one, two, or three dimensions, this is
      usually sufficient.  If more dimensions are needed, they can be
      added to the source code.</para>
-    </section>
- 
  
-    <section id="arrays-domains_declarations">
-     <title>Declaring &domain;s</title>
  
!     <para>Since &domain;s are mainly used to declare container
!     domains, we focus on declaring &domain;s.  Arithmetic operations
!     with &domain;s are described in <xref
!     linkend="views"></xref>.</para>
! 
!     <para>All &domain; declarations require a dimension template
!     parameter&nbsp;<varname>&dim;</varname>.  This positive integer
!     specifies the number of dimensions, i.e., rank, of the &domain; and
!     determines the length of the tuples for points in the &domain;.  For
!     example, a three-dimensional &domain; contains ordered triples,
!     while a one-dimensional &domain; contains singletons, or just
!     integers.  Multidimensional &domain;s are just the direct products
!     of one-dimensional &domain;s so the techniques for declaring
!     one-dimensional &domain;s carry over to multi-dimensional
!     ones.</para>
! 
!     <para>To declare a &domain;, one must include the
!     <filename class="headerfile">Pooma/Domains.h</filename> header
!     file.  However, most &pooma; programs declare &domain;s to use them
!     when constructing containers.  The container header files
!     automatically include <filename
!     class="headerfile">Pooma/Domains.h</filename> so no explicit
!     inclusion is usually necessary.</para>
! 
!     <section id="arrays-domains_declarations-loc">
!      <title>&loc;s</title>
! 
!      <para>A <type>Loc&lt;&dim;&gt;</type> is a &domain; with just a single
!      <varname>&dim;</varname>-dimensional point.  Although it is
!      infrequently used as a container's domain, it is used to refer to
!      a single point within another domain.  Its beginning and ending
!      points are the same, and its stride is one.  One-dimensional
!      &loc;s and integers are frequently interchanged.</para>
  
!      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	    orient="port" pgwide="0" id="arrays-domains_declarations-loc-one_d_table">
!       <title>Declaring One-Dimensional &loc;s</title>
!      
!       <tgroup cols="2" align="left">
!        <thead>
! 	<row>
! 	 <entry>constructor</entry>
! 	 <entry>result</entry>
! 	</row>
!        </thead>
!        <tfoot>
! 	<row>
! 	 <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
! 	 <varname>&domaintemplate;3</varname> are template parameters.</entry>
! 	 <entry></entry>
! 	</row>
!        </tfoot>
!        <tbody>
! 	<row>
! 	 <entry><statement>Loc&lt;1&gt;()</statement></entry>
! 	 <entry>points to zero.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	 <entry>creates an uninitialized &locone;, to be assigned a value later.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	 <entry>creates a &locone; with the integer converted from <varname>t1</varname>.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	 <entry>creates a &locone; with the integer converted from
! 	 <varname>t1</varname>.  <varname>t2</varname> must equal
! 	 <varname>t1</varname>.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	 <entry>creates a &locone; with the integer converted from
! 	 <varname>t1</varname>.  <varname>t2</varname> must equal
! 	 <varname>t1</varname>, and <varname>t3</varname> is
! 	 ignored.</entry>
! 	</row>
!        </tbody>
!       </tgroup>
!      </table>
! 
!      <para>Constructors for one-dimensional &loc;s appear in <xref
!      linkend="arrays-domains_declarations-loc-one_d_table"></xref>.
!      The empty constructor yields the zero point.  The constructor
!      taking a <type>Pooma::Init</type> object does not initialize the
!      resulting &loc; to any particular value.  Presumably, the value
!      will be assigned later.  For small &domain;s such as &loc;s, the
!      time savings from not initializing is small, but the
!      functionality is still available.  The constructor taking one
!      argument with type&nbsp;<type>&domaintemplate;1</type> converts this argument to
!      an integer to specify the point.  The template
!      type&nbsp;<type>&domaintemplate;1</type> may be any type that can be converted
!      to an integer, e.g., &bool;, &char;, &int;, or &double;.  The
!      constructors taking two and three arguments of templatized types
!      facilitate converting an &interval; and a &range; into a &loc;.
!      Since a &loc; represents a single point, the &interval;'s or
!      &range;'s first two arguments must be equal.  The stride is
!      ignored.  Again, the templatized types may be any type that can
!      be converted into an integer.</para>
! 
!      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	    orient="port" pgwide="0" id="arrays-domains_declarations-loc-multi_d_table">
!       <title>Declaring Multidimensional &loc;s</title>
!      
!       <tgroup cols="2" align="left">
!        <thead>
! 	<row>
! 	 <entry>constructor</entry>
! 	 <entry>result</entry>
! 	</row>
!        </thead>
!        <tfoot>
! 	<row>
! 	 <entry><varname>&dim;</varname> indicates the &loc;'s dimension.
! 	 <varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, &hellip; are
! 	 template parameters.</entry>
! 	</row>
!        </tfoot>
!        <tbody>
! 	<row>
! 	 <entry><statement>Loc&lt;&dim;&gt;()</statement></entry>
! 	 <entry>points to zero.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	 <entry>creates an uninitialized &loc;, to be assigned a value later.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	 <entry>creates a &loc; using the given &domain; object.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	 <entry>creates a &loc; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	 <entry>creates a &loc; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
! 	 <entry>creates a &loc; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5)</statement></entry>
! 	 <entry>creates a &loc; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6)</statement></entry>
! 	 <entry>creates a &loc; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
! 	 <entry>creates a &loc; using the given &domain; objects.</entry>
! 	</row>
!        </tbody>
!       </tgroup>
!      </table>
! 
!      <para>Constructors for multidimensional &loc;s appear in <xref
!      linkend="arrays-domains_declarations-loc-multi_d_table"></xref>.
!      <varname>&dim;</varname>&nbsp;indicates the &loc;'s dimension.  The
!      first two constructors are similar to &locone;'s first two
!      constructors, returning a representation of the zero point and
!      returning an uninitialized point.  The seven other constructors
!      create a &loc; using other &domain; objects.  These &domain; objects,
!      having types <type>&domaintemplate;1</type>, &hellip;, <type>&domaintemplate;7</type>, can have
!      any type that can be converted into an integer, to a &locone;, or
!      to a multidimensional &domain; object that itself can be converted
!      into a &loc;.  The total dimensionality of all the arguments'
!      types should be at most&nbsp;<varname>&dim;</varname>.  For example,
!      <statement>Loc<5>(Range<1>(2,2,2), Loc<2>(2,3),
!      Interval<1>(4,4))</statement> creates a five-dimensional &loc;
!      [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
!      &loc;, and a one-dimensional &interval;.  The final fifth
!      dimension has an unspecified value, in this case&nbsp;1.  The
!      one-dimensional &range; is converted into the single integer two;
!      its beginning and ending points must be the same.  The
!      two-dimensional &loc; contributes values for the next two
!      dimensions, while the &interval; contributes its beginning point,
!      which must be the same as its ending point.  Note that the
!      &locone; constructors taking two and three parameters ignore
!      their second and third arguments, but this is not true for the
!      multidimensional constructors.</para>
      </section>
  
- 
-     <section id="arrays-domains_declarations-intervals">
-      <title>&interval;s</title>
- 
-      <para>A one-dimensional &interval; represents a set of integers
-      within a mathematical <glossterm
-      linkend="glossary-interval">interval</glossterm>.
-      Multidimensional &interval;s represent their multidimensional
-      generalization, i.e., the direct product of one-dimensional
-      intervals.  &interval;s are arguably the most commonly used
-      &pooma; &domain;.  A one-dimensional &interval; has integral
-      beginning and ending points and a unit stride.</para>
  
!      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	    orient="port" pgwide="0" id="arrays-domains_declarations-interval-one_d_table">
!       <title>Declaring One-Dimensional &interval;s</title>
!      
!       <tgroup cols="2" align="left">
!        <thead>
! 	<row>
! 	 <entry>constructor</entry>
! 	 <entry>result</entry>
! 	</row>
!        </thead>
!        <tfoot>
! 	<row>
! 	 <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
! 	 <varname>&domaintemplate;3</varname> are template parameters.</entry>
! 	 <entry></entry>
! 	</row>
!        </tfoot>
!        <tbody>
! 	<row>
! 	 <entry><statement>Interval&lt;1&gt;()</statement></entry>
! 	 <entry>creates an empty, uninitialized interval.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	 <entry>creates an uninitialized &intervalone;, to be assigned a value later.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	 <entry>creates a &intervalone;.  See the text for an explanation.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	 <entry>creates a &intervalone; with the integers converted from
! 	 <varname>t1</varname> and <varname>t2</varname>.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	 <entry>creates a &intervalone; with the integers converted from
! 	 <varname>t1</varname> and <varname>t2</varname>.
! 	 <varname>t3</varname> must equal&nbsp;1.</entry>
! 	</row>
!        </tbody>
!       </tgroup>
!      </table>
! 
!      <para>&intervalone; constructors are patterned on &locone;
!      constructors except that &intervalone;s can have differing
!      beginning and ending points.  See <xref
!      linkend="arrays-domains_declarations-interval-one_d_table"></xref>.
!      The default constructor creates an empty, uninitialized interval,
!      which should not be used before assigning it values.  If the
!      one-parameter constructor's argument is a &domain; object, it must
!      be a one-dimensional &domain; object which is copied into an
!      &interval; if possible; for example, it must have unit stride.
!      If the one-parameter constructor's argument is not a &domain;
!      object, it must be convertible to an
!      integer&nbsp;<varname>e</varname> and an interval [0:e-1:1]
!      starting at zero is constructed.  If two arguments are specified,
!      they are assumed to be convertible to integers
!      <varname>b</varname> and <varname>e</varname>, specifying the
!      interval [b:e:1].  The three-parameter constructor is similar,
!      with the third argument specifying a stride, which must be
!      one.</para>
! 
!      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	    orient="port" pgwide="0" id="arrays-domains_declarations-intervals-multi_d_table">
!       <title>Declaring Multidimensional &interval;s</title>
!      
!       <tgroup cols="2" align="left">
!        <thead>
! 	<row>
! 	 <entry>constructor</entry>
! 	 <entry>result</entry>
! 	</row>
!        </thead>
!        <tfoot>
! 	<row>
! 	 <entry><varname>&dim;</varname> indicates the &interval;'s dimension.
! 	 <varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, &hellip; are
! 	 template parameters.</entry>
! 	</row>
!        </tfoot>
!        <tbody>
! 	<row>
! 	 <entry><statement>Interval&lt;&dim;&gt;()</statement></entry>
! 	 <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	 <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	 <entry>creates a &interval; using the given &domain; object.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	 <entry>creates a &interval; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	 <entry>creates a &interval; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
! 	 <entry>creates a &interval; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5)</statement></entry>
! 	 <entry>creates a &interval; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6)</statement></entry>
! 	 <entry>creates a &interval; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
! 	 <entry>creates a &interval; using the given &domain; objects.</entry>
! 	</row>
!        </tbody>
!       </tgroup>
!      </table>
! 
!      <para>Constructors for multidimensional &interval;s closely
!      follow constructors for multidimensional &loc;s.  See <xref
!      linkend="arrays-domains_declarations-intervals-multi_d_table"></xref>.
!      <varname>&dim;</varname>&nbsp;indicates the &interval;'s
!      dimension.  The first two constructors both return empty,
!      uninitialized intervals.  The seven other constructors create an
!      &interval; using &domain; objects.  These &domain; objects,
!      having types <type>&domaintemplate;1</type>, &hellip;,
!      <type>&domaintemplate;7</type>, can have any type that can be
!      converted into an integer, into a single-dimensional &domain;
!      object that can be converted into a single-dimensional
!      &interval;, or to a multidimensional &domain; object that itself
!      can be converted into an &interval;.  The total dimensionality of
!      all the arguments' types should be at
!      most&nbsp;<varname>&dim;</varname>.  One-dimensional &domain;
!      objects that can be converted into one-dimensional &interval;s
!      include &locone;s, &intervalone;s, and &rangeone;s with unit
!      strides.  If the sum of the objects' dimensions is less
!      than&nbsp;<varname>&dim;</varname>, the intervals for the final
!      dimensions are unspecified.  See the last paragraph of <xref
!      linkend="arrays-domains_declarations-loc"></xref> for an
!      analogous example.  Note that the &intervalone; constructors
!      taking two and three parameters treat these arguments differently
!      than the multidimensional constructors do.</para>
!     </section>
! 
! 
!     <section id="arrays-domains_declarations-ranges">
!      <title>&range;s</title>
! 
!      <para>A one-dimensional &range; generalizes an &interval; by
!      permitting a non-unit stride between integral members.  A
!      <glossterm
!      linkend="glossary-range"><firstterm>range</firstterm></glossterm>
!      is a set of integers in a mathematical interval [b,e] with a
!      stride&nbsp;s between them: {a, a+s, a+2s, &hellip;, b}.  Ranges
!      are generalized to <varname>&dim;</varname>&nbsp;dimensions using the
!      direct product of one-dimensional ranges.</para>
! 
!      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	    orient="port" pgwide="0" id="arrays-domains_declarations-range-one_d_table">
!       <title>Declaring One-Dimensional &range;s</title>
!      
!       <tgroup cols="2" align="left">
!        <thead>
! 	<row>
! 	 <entry>constructor</entry>
! 	 <entry>result</entry>
! 	</row>
!        </thead>
!        <tfoot>
! 	<row>
! 	 <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
! 	 <varname>&domaintemplate;3</varname> are template parameters.</entry>
! 	 <entry></entry>
! 	</row>
!        </tfoot>
!        <tbody>
! 	<row>
! 	 <entry><statement>Range&lt;1&gt;()</statement></entry>
! 	 <entry>creates an empty, uninitialized range.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Range&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	 <entry>creates an uninitialized &rangeone;, to be assigned a value later.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	 <entry>creates a &rangeone;.  See the text for an explanation.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	 <entry>creates a &rangeone; with an interval specified by the
! 	 integers converted from <varname>t1</varname> and
! 	 <varname>t2</varname>.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	 <entry>creates a &rangeone; by converting the arguments to
! 	 integers <varname>i1</varname>, <varname>i2</varname>, and
! 	 <varname>i3</varname> and then making a range [i1:i2:i3].</entry>
! 	</row>
!        </tbody>
!       </tgroup>
!      </table>
  
!      <para>&rangeone; constructors are the same as &intervalone;
!      constructors except they create ranges, not intervals.  See <xref
!      linkend="arrays-domains_declarations-range-one_d_table"></xref>.
!      The default constructor creates an empty, uninitialized range,
!      which should not be used before assigning it values.  If the
!      one-parameter constructor's argument is a &domain; object, it must
!      be a one-dimensional &domain; object which is copied into a &range;
!      if possible.  If the one-parameter constructor's argument is not
!      a &domain; object, it must be convertible to an
!      integer&nbsp;<varname>e</varname> and a range [0:e-1:1] starting
!      at zero is constructed.  If two arguments are specified, they are
!      assumed to be convertible to integers <varname>b</varname> and
!      <varname>e</varname>, specifying the range [b:e:1].  The
!      three-parameter constructor is similar, with the third argument
!      specifying a stride.</para>
  
       <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	    orient="port" pgwide="0" id="arrays-domains_declarations-ranges-multi_d_table">
!       <title>Declaring Multidimensional &range;s</title>
       
        <tgroup cols="2" align="left">
         <thead>
  	<row>
! 	 <entry>constructor</entry>
  	 <entry>result</entry>
  	</row>
         </thead>
         <tfoot>
  	<row>
! 	 <entry><varname>&dim;</varname> indicates the &range;'s dimension.
! 	 <varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, &hellip; are
! 	 template parameters.</entry>
  	</row>
         </tfoot>
         <tbody>
! 	<row>
! 	 <entry><statement>Range&lt;&dim;&gt;()</statement></entry>
! 	 <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
  	</row>
  	<row>
! 	 <entry><statement>Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	 <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
  	</row>
  	<row>
! 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	 <entry>creates a &range; using the given &domain; object.</entry>
  	</row>
  	<row>
! 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	 <entry>creates a &range; using the given &domain; objects.</entry>
  	</row>
! 	<row>
! 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	 <entry>creates a &range; using the given &domain; objects.</entry>
  	</row>
  	<row>
! 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
! 	 <entry>creates a &range; using the given &domain; objects.</entry>
  	</row>
  	<row>
! 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5)</statement></entry>
! 	 <entry>creates a &range; using the given &domain; objects.</entry>
  	</row>
  	<row>
! 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6)</statement></entry>
! 	 <entry>creates a &range; using the given &domain; objects.</entry>
  	</row>
  	<row>
! 	 <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
! 	 <entry>creates a &range; using the given &domain; objects.</entry>
  	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
-      <para>Constructors for multidimensional &range;s are the same as
-      multidimensional &interval; constructors except they create
-      ranges, not intervals.  See <xref
-      linkend="arrays-domains_declarations-ranges-multi_d_table"></xref>.
-      <varname>&dim;</varname>&nbsp;indicates the &range;'s dimension.  The
-      first two constructors return empty, uninitialized ranges.
-      The seven other constructors create an &range; using &domain;
-      objects.  These &domain; objects, having types <type>&domaintemplate;1</type>,
-      &hellip;, <type>&domaintemplate;7</type>, can have any type that can be
-      converted into an integer, into a single-dimensional &domain;
-      object that can be converted into a single-dimensional &range;,
-      or to a multidimensional &domain; object that itself can be
-      converted into an &range;.  The total dimensionality of all the
-      arguments' types should be at most&nbsp;<varname>&dim;</varname>.
-      One-dimensional &domain; objects that can be converted into
-      one-dimensional &range;s include &locone;s, &intervalone;s, and
-      &rangeone;s.  If the sum of the objects' dimensions is less
-      than&nbsp;<varname>&dim;</varname>, the ranges for the final
-      dimensions are unspecified.  See the last paragraph of <xref
-      linkend="arrays-domains_declarations-loc"></xref> for an
-      analogous example.  Note that the &rangeone; constructors taking
-      two and three parameters treat these arguments differently than
-      the multidimensional constructors do.</para>
-     </section>
- 
- 
-     <section id="arrays-domains_declarations-grids">
-      <title>&grid;s</title>
- 
-      <para>&loc;s, &interval;s, and &range;s all have regularly spaced
-      integral values so they can be represented using <glossterm
-      linkend="glossary-domain_triplet">domain triplets</glossterm>.
-      One-dimensional &grid; integral domains contain ascending or
-      descending sequences of integers, with no fixed stride.  For
-      example, a &gridone; may represent {-13, 1, 4, 5, 34}.  &gridone;
-      is generalized to multidimensional &grid;s using the direct
-      product of &gridone; &domain;s.</para>
- 
-      <para>&grid;s that can be represented using domain triplets can
-      be constructed using techniques similar to other &domain;s, but
-      irregularly spaced domains can be constructed using
-      &indirectionlistint;s.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0" id="arrays-domains_declarations-grid-one_d_table">
-       <title>Declaring One-Dimensional &grid;s</title>
-      
-       <tgroup cols="2" align="left">
-        <thead>
  	<row>
! 	 <entry>constructor</entry>
! 	 <entry>result</entry>
  	</row>
-        </thead>
-        <tfoot>
  	<row>
! 	 <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
! 	 <varname>&domaintemplate;3</varname> are template parameters.</entry>
! 	 <entry></entry>
  	</row>
-        </tfoot>
-        <tbody>
- 	<row>
- 	 <entry><statement>Grid&lt;1&gt;()</statement></entry>
- 	 <entry>creates an empty, uninitialized grid.</entry>
- 	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
- 	 <entry>creates a &gridone;.  See the text for an explanation.</entry>
- 	</row>
  	<row>
! 	 <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	 <entry>creates a &gridone; from the interval specified by the
! 	 integers converted from <varname>t1</varname> and
! 	 <varname>t2</varname>.</entry>
  	</row>
- 	<row>
- 	 <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
- 	 <entry>creates a &gridone; from the domain triplet specified
- 	 by the integers converted from <varname>t1</varname>,
- 	 <varname>t2</varname>, and <varname>t3</varname>.</entry>
- 	</row>
         </tbody>
        </tgroup>
       </table>
  
!      <para>To construct a &gridone; that can also be represented by a
!      domain triplet, use a &gridone; constructor similar to those for
!      &intervalone; and &rangeone;.  See <xref
!      linkend="arrays-domains_declarations-grid-one_d_table"></xref>
!      and the text explanations following <xref
!      linkend="arrays-domains_declarations-range-one_d_table"></xref>
!      or <xref
!      linkend="arrays-domains_declarations-interval-one_d_table"></xref>.</para>
  
!      <para>&gridone;s with irregularly spaced points can be
!      constructed using &indirectionlistint;s.  For example,
! <programlisting>
! IndirectionList&lt;int&gt; list(4);
! list(0) = 2;
! list(1) = 5;
! list(2) = 6;
! list(3) = 9;
! Grid&lt;1&gt; g(list);
! </programlisting> constructs an empty &indirectionlistint;, fills it
!      with ascending values, and then creates a &gridone; containing
!      {2, 5, 6, 9}.  When creating a list, its size must be specified.
!      Subsequently, its values can be assigned.  &indirectionlist;s can
!      also be initialized using one-dimensional &array;s:
! <programlisting>
! Array&lt;1,int,Brick&gt; a1(Interval&lt;1&gt;(0,3));
! a1(0) = 2; a1(1) = 5; a1(2) = 6; a1(3) = 9;
! IndirectionList&lt;int&gt; il(a1);
! Grid&lt;1&gt; g1(il);
! </programlisting>  The &array; stores the integral points to include
!      in the &gridone; and is used to create the &indirectionlistint;,
!      which itself is used to create the &gridone;.  Since the points
!      are integers, the &array;'s type is &int;.  Either a &brick; or
!      &compressiblebrick; &engine; should be used.</para>
! 
!      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	    orient="port" pgwide="0" id="arrays-domains_declarations-grids-multi_d_table">
!       <title>Declaring Multidimensional &grid;s</title>
!      
!       <tgroup cols="2" align="left">
!        <thead>
! 	<row>
! 	 <entry>constructor</entry>
! 	 <entry>result</entry>
! 	</row>
!        </thead>
!        <tfoot>
! 	<row>
! 	 <entry><varname>&dim;</varname> indicates the &grid;'s
! 	 dimension.  <varname>&domaintemplate;1</varname>,
! 	 <varname>&domaintemplate;2</varname>, &hellip; are template
! 	 parameters.</entry>
! 	</row>
!        </tfoot>
!        <tbody>
! 	<row>
! 	 <entry><statement>Grid&lt;&dim;&gt;()</statement></entry>
! 	 <entry>creates an empty, uninitialized &grid;, to be assigned a value later.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	 <entry>creates a &grid; using the given &domain; object.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	 <entry>creates a &grid; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	 <entry>creates a &grid; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
! 	 <entry>creates a &grid; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5)</statement></entry>
! 	 <entry>creates a &grid; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6)</statement></entry>
! 	 <entry>creates a &grid; using the given &domain; objects.</entry>
! 	</row>
! 	<row>
! 	 <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	 &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	 t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
! 	 <entry>creates a &grid; using the given &domain; objects.</entry>
! 	</row>
!        </tbody>
!       </tgroup>
!      </table>
! 
!      <para>Constructors for multidimensional &grid;s are the same as
!      multidimensional &interval; constructors except they create
!      &grid;s, not intervals.  See <xref
!      linkend="arrays-domains_declarations-grids-multi_d_table"></xref>.
!      <varname>&dim;</varname>&nbsp;indicates the &grid;'s dimension.  The
!      first constructor returns empty, uninitialized grids.  The seven
!      other constructors create an &grid; using &domain; objects.  These
!      &domain; objects, having types <type>&domaintemplate;1</type>, &hellip;,
!      <type>&domaintemplate;7</type>, can have any type that can be converted into an
!      integer, into a single-dimensional &domain; object that can be
!      converted into a single-dimensional &grid;, or to a
!      multidimensional &domain; object that itself can be converted into
!      an &grid;.  The total dimensionality of all the arguments' types
!      should be at most&nbsp;<varname>&dim;</varname>.  One-dimensional
!      &domain; objects that can be converted into one-dimensional &grid;s
!      include &locone;s, &intervalone;s, &rangeone;s, and &gridone;s.
!      If the sum of the objects' dimensions is less
!      than&nbsp;<varname>&dim;</varname>, the grids for the final
!      dimensions are unspecified.  See the last paragraph of <xref
!      linkend="arrays-domains_declarations-loc"></xref> for an
!      analogous example.  Note that the &gridone; constructors taking
!      two and three parameters treat these arguments differently than
!      the multidimensional constructors do.</para>
!     </section>
     </section>
  
  
     <section id="arrays-arrays_declarations">
      <title>Declaring &array;s</title>
  
      <para>A &pooma; &array; maps indices from its &domain; to values.
!     In this section, we describe first describe how to declare
!     &array;s.  In the next section, we explain how to access
!     individual values stored within an &array; and &array; copy
!     semantics.</para>
  
      <para>&array; values need not just be stored values, as &c; arrays
      have.  They can also be computed using its engine.  We defer
--- 233,1063 ----
      scientific computations use one, two, or three dimensions, this is
      usually sufficient.  If more dimensions are needed, they can be
      added to the source code.</para>
  
  
!     <section id="arrays-domains-declarations">
!      <title>Declaring &domain;s</title>
  
!      <para>Since &domain;s are mainly used to declare container
!      domains, we focus on declaring &domain;s.  We describe a few
!      &domain; operations but most, including arithmetic operations with
!      &domain;s, are described in <xref linkend="views"></xref>.</para>
! 
!      <para>All &domain; declarations require a dimension template
!      parameter&nbsp;<varname>&dim;</varname>.  This positive integer
!      specifies the number of dimensions, i.e., rank, of the &domain; and
!      determines the length of the tuples for points in the &domain;.  For
!      example, a three-dimensional &domain; contains ordered triples,
!      while a one-dimensional &domain; contains singletons, or just
!      integers.  Multidimensional &domain;s are just the direct products
!      of one-dimensional &domain;s so the techniques for declaring
!      one-dimensional &domain;s carry over to multidimensional
!      ones.</para>
! 
!      <para>To declare a &domain;, one must include the
!      <filename class="headerfile">Pooma/Domains.h</filename> header
!      file.  However, most &pooma; programs declare &domain;s to use them
!      when constructing containers.  The container header files
!      automatically include <filename
!      class="headerfile">Pooma/Domains.h</filename> so no explicit
!      inclusion is usually necessary.</para>
! 
! 
!      <section id="arrays-domains-declarations-loc">
!       <title>&loc;s</title>
! 
!       <para>A <type>Loc&lt;&dim;&gt;</type> is a &domain; with just a single
!       <varname>&dim;</varname>-dimensional point.  Although it is
!       infrequently used as a container's domain, it is used to refer to
!       a single point within another domain.  Its beginning and ending
!       points are the same, and its stride is one.  One-dimensional
!       &loc;s and integers are frequently interchanged.</para>
! 
!       <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	     orient="port" pgwide="0" id="arrays-domains-declarations-loc-one_d_table">
!        <title>Declaring One-Dimensional &loc;s</title>
! 
!        <tgroup cols="2" align="left">
! 	<thead>
! 	 <row>
! 	  <entry>constructor</entry>
! 	  <entry>result</entry>
! 	 </row>
! 	</thead>
! 	<tfoot>
! 	 <row>
! 	  <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
! 	  <varname>&domaintemplate;3</varname> are template parameters.</entry>
! 	  <entry></entry>
! 	 </row>
! 	</tfoot>
! 	<tbody>
! 	 <row>
! 	  <entry><statement>Loc&lt;1&gt;()</statement></entry>
! 	  <entry>points to zero.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	  <entry>creates an uninitialized &locone;, to be assigned a value later.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates a &locone; with the integer converted from <varname>t1</varname>.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates a &locone; with the integer converted from
! 	  <varname>t1</varname>.  <varname>t2</varname> must equal
! 	  <varname>t1</varname>.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates a &locone; with the integer converted from
! 	  <varname>t1</varname>.  <varname>t2</varname> must equal
! 	  <varname>t1</varname>, and <varname>t3</varname> is
! 	  ignored.</entry>
! 	 </row>
! 	</tbody>
!        </tgroup>
!       </table>
! 
!       <para>Constructors for one-dimensional &loc;s appear in <xref
!       linkend="arrays-domains-declarations-loc-one_d_table"></xref>.
!       The empty constructor yields the zero point.  The constructor
!       taking a <type>Pooma::Init</type> object does not initialize the
!       resulting &loc; to any particular value.  Presumably, the value
!       will be assigned later.  For small &domain;s such as &loc;s, the
!       time savings from not initializing is small, but the
!       functionality is still available.  The constructor taking one
!       argument with type&nbsp;<type>&domaintemplate;1</type> converts this argument to
!       an integer to specify the point.  The template
!       type&nbsp;<type>&domaintemplate;1</type> may be any type that can be converted
!       to an integer, e.g., &bool;, &char;, &int;, or &double;.  The
!       constructors taking two and three arguments of templatized types
!       facilitate converting an &interval; and a &range; into a &loc;.
!       Since a &loc; represents a single point, the &interval;'s or
!       &range;'s first two arguments must be equal.  The stride is
!       ignored.  Again, the templatized types may be any type that can
!       be converted into an integer.</para>
! 
!       <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	     orient="port" pgwide="0" id="arrays-domains-declarations-loc-multi_d_table">
!        <title>Declaring Multidimensional &loc;s</title>
! 
!        <tgroup cols="2" align="left">
! 	<thead>
! 	 <row>
! 	  <entry>constructor</entry>
! 	  <entry>result</entry>
! 	 </row>
! 	</thead>
! 	<tfoot>
! 	 <row>
! 	  <entry><varname>&dim;</varname> indicates the &loc;'s dimension.
! 	  <varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, &hellip; are
! 	  template parameters.</entry>
! 	 </row>
! 	</tfoot>
! 	<tbody>
! 	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;()</statement></entry>
! 	  <entry>points to zero.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	  <entry>creates an uninitialized &loc;, to be assigned a value later.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates a &loc; using the given &domain; object.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates a &loc; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates a &loc; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
! 	  <entry>creates a &loc; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</statement></entry>
! 	  <entry>creates a &loc; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</statement></entry>
! 	  <entry>creates a &loc; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
! 	  <entry>creates a &loc; using the given &domain; objects.</entry>
! 	 </row>
! 	</tbody>
!        </tgroup>
!       </table>
! 
!       <para>Constructors for multidimensional &loc;s appear in <xref
!       linkend="arrays-domains-declarations-loc-multi_d_table"></xref>.
!       <varname>&dim;</varname>&nbsp;indicates the &loc;'s dimension.  The
!       first two constructors are similar to &locone;'s first two
!       constructors, returning a representation of the zero point and
!       returning an uninitialized point.  The seven other constructors
!       create a &loc; using other &domain; objects.  These &domain; objects,
!       having types <type>&domaintemplate;1</type>, &hellip;, <type>&domaintemplate;7</type>, can have
!       any type that can be converted into an integer, to a &locone;, or
!       to a multidimensional &domain; object that itself can be converted
!       into a &loc;.  The total dimensionality of all the arguments'
!       types should be at most&nbsp;<varname>&dim;</varname>.  For example,
!       <statement>Loc<5>(Range<1>(2,2,2), Loc<2>(2,3),
!       Interval<1>(4,4))</statement> creates a five-dimensional &loc;
!       [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
!       &loc;, and a one-dimensional &interval;.  The final fifth
!       dimension has an unspecified value, in this case&nbsp;1.  The
!       one-dimensional &range; is converted into the single integer two;
!       its beginning and ending points must be the same.  The
!       two-dimensional &loc; contributes values for the next two
!       dimensions, while the &interval; contributes its beginning point,
!       which must be the same as its ending point.  Note that the
!       &locone; constructors taking two and three parameters ignore
!       their second and third arguments, but this is not true for the
!       multidimensional constructors.</para>
!      </section>
! 
! 
!      <section id="arrays-domains-declarations-intervals">
!       <title>&interval;s</title>
! 
!       <para>A one-dimensional &interval; represents a set of integers
!       within a mathematical <glossterm
!       linkend="glossary-interval">interval</glossterm>.
!       Multidimensional &interval;s represent their multidimensional
!       generalization, i.e., the direct product of one-dimensional
!       intervals.  &interval;s are arguably the most commonly used
!       &pooma; &domain;.  A one-dimensional &interval; has integral
!       beginning and ending points and a unit stride.</para>
! 
!       <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	     orient="port" pgwide="0" id="arrays-domains-declarations-interval-one_d_table">
!        <title>Declaring One-Dimensional &interval;s</title>
! 
!        <tgroup cols="2" align="left">
! 	<thead>
! 	 <row>
! 	  <entry>constructor</entry>
! 	  <entry>result</entry>
! 	 </row>
! 	</thead>
! 	<tfoot>
! 	 <row>
! 	  <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
! 	  <varname>&domaintemplate;3</varname> are template parameters.</entry>
! 	  <entry></entry>
! 	 </row>
! 	</tfoot>
! 	<tbody>
! 	 <row>
! 	  <entry><statement>Interval&lt;1&gt;()</statement></entry>
! 	  <entry>creates an empty, uninitialized interval.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	  <entry>creates an uninitialized &intervalone;, to be assigned a value later.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates a &intervalone;.  See the text for an explanation.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates a &intervalone; with the integers converted from
! 	  <varname>t1</varname> and <varname>t2</varname>.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates a &intervalone; with the integers converted from
! 	  <varname>t1</varname> and <varname>t2</varname>.
! 	  <varname>t3</varname> must equal&nbsp;1.</entry>
! 	 </row>
! 	</tbody>
!        </tgroup>
!       </table>
! 
!       <para>&intervalone; constructors are patterned on &locone;
!       constructors except that &intervalone;s can have differing
!       beginning and ending points.  See <xref
!       linkend="arrays-domains-declarations-interval-one_d_table"></xref>.
!       The default constructor creates an empty, uninitialized interval,
!       which should not be used before assigning it values.  If the
!       one-parameter constructor's argument is a &domain; object, it must
!       be a one-dimensional &domain; object which is copied into an
!       &interval; if possible; for example, it must have unit stride.
!       If the one-parameter constructor's argument is not a &domain;
!       object, it must be convertible to an
!       integer&nbsp;<varname>e</varname> and an interval [0:e-1:1]
!       starting at zero is constructed.  If two arguments are specified,
!       they are assumed to be convertible to integers
!       <varname>b</varname> and <varname>e</varname>, specifying the
!       interval [b:e:1].  The three-parameter constructor is similar,
!       with the third argument specifying a stride, which must be
!       one.</para>
! 
!       <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	     orient="port" pgwide="0" id="arrays-domains-declarations-intervals-multi_d_table">
!        <title>Declaring Multidimensional &interval;s</title>
! 
!        <tgroup cols="2" align="left">
! 	<thead>
! 	 <row>
! 	  <entry>constructor</entry>
! 	  <entry>result</entry>
! 	 </row>
! 	</thead>
! 	<tfoot>
! 	 <row>
! 	  <entry><varname>&dim;</varname> indicates the &interval;'s dimension.
! 	  <varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, &hellip; are
! 	  template parameters.</entry>
! 	 </row>
! 	</tfoot>
! 	<tbody>
! 	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;()</statement></entry>
! 	  <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	  <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; object.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
! 	 </row>
! 	</tbody>
!        </tgroup>
!       </table>
! 
!       <para>Constructors for multidimensional &interval;s closely
!       follow constructors for multidimensional &loc;s.  See <xref
!       linkend="arrays-domains-declarations-intervals-multi_d_table"></xref>.
!       <varname>&dim;</varname>&nbsp;indicates the &interval;'s
!       dimension.  The first two constructors both return empty,
!       uninitialized intervals.  The seven other constructors create an
!       &interval; using &domain; objects.  These &domain; objects,
!       having types <type>&domaintemplate;1</type>, &hellip;,
!       <type>&domaintemplate;7</type>, can have any type that can be
!       converted into an integer, into a single-dimensional &domain;
!       object that can be converted into a single-dimensional
!       &interval;, or to a multidimensional &domain; object that itself
!       can be converted into an &interval;.  The total dimensionality of
!       all the arguments' types should be at
!       most&nbsp;<varname>&dim;</varname>.  One-dimensional &domain;
!       objects that can be converted into one-dimensional &interval;s
!       include &locone;s, &intervalone;s, and &rangeone;s with unit
!       strides.  If the sum of the objects' dimensions is less
!       than&nbsp;<varname>&dim;</varname>, the intervals for the final
!       dimensions are unspecified.  See the last paragraph of <xref
!       linkend="arrays-domains-declarations-loc"></xref> for an
!       analogous example.  Note that the &intervalone; constructors
!       taking two and three parameters treat these arguments differently
!       than the multidimensional constructors do.</para>
!      </section>
! 
! 
!      <section id="arrays-domains-declarations-ranges">
!       <title>&range;s</title>
! 
!       <para>A one-dimensional &range; generalizes an &interval; by
!       permitting a non-unit stride between integral members.  A
!       <glossterm
!       linkend="glossary-range"><firstterm>range</firstterm></glossterm>
!       is a set of integers in a mathematical interval [b,e] with a
!       stride&nbsp;s between them: {a, a+s, a+2s, &hellip;, b}.  Ranges
!       are generalized to <varname>&dim;</varname>&nbsp;dimensions using the
!       direct product of one-dimensional ranges.</para>
! 
!       <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	     orient="port" pgwide="0" id="arrays-domains-declarations-range-one_d_table">
!        <title>Declaring One-Dimensional &range;s</title>
! 
!        <tgroup cols="2" align="left">
! 	<thead>
! 	 <row>
! 	  <entry>constructor</entry>
! 	  <entry>result</entry>
! 	 </row>
! 	</thead>
! 	<tfoot>
! 	 <row>
! 	  <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
! 	  <varname>&domaintemplate;3</varname> are template parameters.</entry>
! 	  <entry></entry>
! 	 </row>
! 	</tfoot>
! 	<tbody>
! 	 <row>
! 	  <entry><statement>Range&lt;1&gt;()</statement></entry>
! 	  <entry>creates an empty, uninitialized range.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	  <entry>creates an uninitialized &rangeone;, to be assigned a value later.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates a &rangeone;.  See the text for an explanation.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates a &rangeone; with an interval specified by the
! 	  integers converted from <varname>t1</varname> and
! 	  <varname>t2</varname>.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates a &rangeone; by converting the arguments to
! 	  integers <varname>i1</varname>, <varname>i2</varname>, and
! 	  <varname>i3</varname> and then making a range [i1:i2:i3].</entry>
! 	 </row>
! 	</tbody>
!        </tgroup>
!       </table>
! 
!       <para>&rangeone; constructors are the same as &intervalone;
!       constructors except they create ranges, not intervals.  See <xref
!       linkend="arrays-domains-declarations-range-one_d_table"></xref>.
!       The default constructor creates an empty, uninitialized range,
!       which should not be used before assigning it values.  If the
!       one-parameter constructor's argument is a &domain; object, it must
!       be a one-dimensional &domain; object which is copied into a &range;
!       if possible.  If the one-parameter constructor's argument is not
!       a &domain; object, it must be convertible to an
!       integer&nbsp;<varname>e</varname> and a range [0:e-1:1] starting
!       at zero is constructed.  If two arguments are specified, they are
!       assumed to be convertible to integers <varname>b</varname> and
!       <varname>e</varname>, specifying the range [b:e:1].  The
!       three-parameter constructor is similar, with the third argument
!       specifying a stride.</para>
! 
!       <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	     orient="port" pgwide="0" id="arrays-domains-declarations-ranges-multi_d_table">
!        <title>Declaring Multidimensional &range;s</title>
! 
!        <tgroup cols="2" align="left">
! 	<thead>
! 	 <row>
! 	  <entry>constructor</entry>
! 	  <entry>result</entry>
! 	 </row>
! 	</thead>
! 	<tfoot>
! 	 <row>
! 	  <entry><varname>&dim;</varname> indicates the &range;'s dimension.
! 	  <varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, &hellip; are
! 	  template parameters.</entry>
! 	 </row>
! 	</tfoot>
! 	<tbody>
! 	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;()</statement></entry>
! 	  <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
! 	  <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates a &range; using the given &domain; object.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates a &range; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates a &range; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
! 	  <entry>creates a &range; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</statement></entry>
! 	  <entry>creates a &range; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</statement></entry>
! 	  <entry>creates a &range; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
! 	  <entry>creates a &range; using the given &domain; objects.</entry>
! 	 </row>
! 	</tbody>
!        </tgroup>
!       </table>
! 
!       <para>Constructors for multidimensional &range;s are the same as
!       multidimensional &interval; constructors except they create
!       ranges, not intervals.  See <xref
!       linkend="arrays-domains-declarations-ranges-multi_d_table"></xref>.
!       <varname>&dim;</varname>&nbsp;indicates the &range;'s dimension.  The
!       first two constructors return empty, uninitialized ranges.
!       The seven other constructors create an &range; using &domain;
!       objects.  These &domain; objects, having types <type>&domaintemplate;1</type>,
!       &hellip;, <type>&domaintemplate;7</type>, can have any type that can be
!       converted into an integer, into a single-dimensional &domain;
!       object that can be converted into a single-dimensional &range;,
!       or to a multidimensional &domain; object that itself can be
!       converted into an &range;.  The total dimensionality of all the
!       arguments' types should be at most&nbsp;<varname>&dim;</varname>.
!       One-dimensional &domain; objects that can be converted into
!       one-dimensional &range;s include &locone;s, &intervalone;s, and
!       &rangeone;s.  If the sum of the objects' dimensions is less
!       than&nbsp;<varname>&dim;</varname>, the ranges for the final
!       dimensions are unspecified.  See the last paragraph of <xref
!       linkend="arrays-domains-declarations-loc"></xref> for an
!       analogous example.  Note that the &rangeone; constructors taking
!       two and three parameters treat these arguments differently than
!       the multidimensional constructors do.</para>
!      </section>
! 
! 
!      <section id="arrays-domains-declarations-grids">
!       <title>&grid;s</title>
! 
!       <para>&loc;s, &interval;s, and &range;s all have regularly spaced
!       integral values so they can be represented using <glossterm
!       linkend="glossary-domain_triplet">domain triplets</glossterm>.
!       One-dimensional &grid; integral domains contain ascending or
!       descending sequences of integers, with no fixed stride.  For
!       example, a &gridone; may represent {-13, 1, 4, 5, 34}.  &gridone;
!       is generalized to multidimensional &grid;s using the direct
!       product of &gridone; &domain;s.</para>
! 
!       <para>&grid;s that can be represented using domain triplets can
!       be constructed using techniques similar to other &domain;s, but
!       irregularly spaced domains can be constructed using
!       &indirectionlistint;s.</para>
! 
!       <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	     orient="port" pgwide="0" id="arrays-domains-declarations-grid-one_d_table">
!        <title>Declaring One-Dimensional &grid;s</title>
! 
!        <tgroup cols="2" align="left">
! 	<thead>
! 	 <row>
! 	  <entry>constructor</entry>
! 	  <entry>result</entry>
! 	 </row>
! 	</thead>
! 	<tfoot>
! 	 <row>
! 	  <entry><varname>&domaintemplate;1</varname>, <varname>&domaintemplate;2</varname>, and
! 	  <varname>&domaintemplate;3</varname> are template parameters.</entry>
! 	  <entry></entry>
! 	 </row>
! 	</tfoot>
! 	<tbody>
! 	 <row>
! 	  <entry><statement>Grid&lt;1&gt;()</statement></entry>
! 	  <entry>creates an empty, uninitialized grid.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates a &gridone;.  See the text for an explanation.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates a &gridone; from the interval specified by the
! 	  integers converted from <varname>t1</varname> and
! 	  <varname>t2</varname>.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates a &gridone; from the domain triplet specified
! 	  by the integers converted from <varname>t1</varname>,
! 	  <varname>t2</varname>, and <varname>t3</varname>.</entry>
! 	 </row>
! 	</tbody>
!        </tgroup>
!       </table>
! 
!       <para>To construct a &gridone; that can also be represented by a
!       domain triplet, use a &gridone; constructor similar to those for
!       &intervalone; and &rangeone;.  See <xref
!       linkend="arrays-domains-declarations-grid-one_d_table"></xref>
!       and the text explanations following <xref
!       linkend="arrays-domains-declarations-range-one_d_table"></xref>
!       or <xref
!       linkend="arrays-domains-declarations-interval-one_d_table"></xref>.</para>
! 
!       <para>&gridone;s with irregularly spaced points can be
!       constructed using &indirectionlistint;s.  For example,
!  <programlisting>
!  IndirectionList&lt;int&gt; list(4);
!  list(0) = 2;
!  list(1) = 5;
!  list(2) = 6;
!  list(3) = 9;
!  Grid&lt;1&gt; g(list);
!  </programlisting> constructs an empty &indirectionlistint;, fills it
!       with ascending values, and then creates a &gridone; containing
!       {2, 5, 6, 9}.  When creating a list, its size must be specified.
!       Subsequently, its values can be assigned.  &indirectionlist;s can
!       also be initialized using one-dimensional &array;s:
!  <programlisting>
!  Array&lt;1,int,Brick&gt; a1(Interval&lt;1&gt;(0,3));
!  a1(0) = 2; a1(1) = 5; a1(2) = 6; a1(3) = 9;
!  IndirectionList&lt;int&gt; il(a1);
!  Grid&lt;1&gt; g1(il);
!  </programlisting>  The &array; stores the integral points to include
!       in the &gridone; and is used to create the &indirectionlistint;,
!       which itself is used to create the &gridone;.  Since the points
!       are integers, the &array;'s type is &int;.  Either a &brick; or
!       &compressiblebrick; &engine; should be used.</para>
! 
!       <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	     orient="port" pgwide="0" id="arrays-domains-declarations-grids-multi_d_table">
!        <title>Declaring Multidimensional &grid;s</title>
! 
!        <tgroup cols="2" align="left">
! 	<thead>
! 	 <row>
! 	  <entry>constructor</entry>
! 	  <entry>result</entry>
! 	 </row>
! 	</thead>
! 	<tfoot>
! 	 <row>
! 	  <entry><varname>&dim;</varname> indicates the &grid;'s
! 	  dimension.  <varname>&domaintemplate;1</varname>,
! 	  <varname>&domaintemplate;2</varname>, &hellip; are template
! 	  parameters.</entry>
! 	 </row>
! 	</tfoot>
! 	<tbody>
! 	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;()</statement></entry>
! 	  <entry>creates an empty, uninitialized &grid;, to be assigned a value later.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates a &grid; using the given &domain; object.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates a &grid; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates a &grid; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
! 	  <entry>creates a &grid; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</statement></entry>
! 	  <entry>creates a &grid; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</statement></entry>
! 	  <entry>creates a &grid; using the given &domain; objects.</entry>
! 	 </row>
! 	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
! 	  <entry>creates a &grid; using the given &domain; objects.</entry>
! 	 </row>
! 	</tbody>
!        </tgroup>
!       </table>
! 
!       <para>Constructors for multidimensional &grid;s are the same as
!       multidimensional &interval; constructors except they create
!       &grid;s, not intervals.  See <xref
!       linkend="arrays-domains-declarations-grids-multi_d_table"></xref>.
!       <varname>&dim;</varname>&nbsp;indicates the &grid;'s dimension.  The
!       first constructor returns empty, uninitialized grids.  The seven
!       other constructors create an &grid; using &domain; objects.  These
!       &domain; objects, having types <type>&domaintemplate;1</type>, &hellip;,
!       <type>&domaintemplate;7</type>, can have any type that can be converted into an
!       integer, into a single-dimensional &domain; object that can be
!       converted into a single-dimensional &grid;, or to a
!       multidimensional &domain; object that itself can be converted into
!       an &grid;.  The total dimensionality of all the arguments' types
!       should be at most&nbsp;<varname>&dim;</varname>.  One-dimensional
!       &domain; objects that can be converted into one-dimensional &grid;s
!       include &locone;s, &intervalone;s, &rangeone;s, and &gridone;s.
!       If the sum of the objects' dimensions is less
!       than&nbsp;<varname>&dim;</varname>, the grids for the final
!       dimensions are unspecified.  See the last paragraph of <xref
!       linkend="arrays-domains-declarations-loc"></xref> for an
!       analogous example.  Note that the &gridone; constructors taking
!       two and three parameters treat these arguments differently than
!       the multidimensional constructors do.</para>
!      </section>
      </section>
  
  
!     <section id="arrays-domains-use">
!      <title>Using &domain;s</title>
  
!      <para>Since an &array; can be queried for its domain, we briefly
!      describe some &domain; operations.  A fuller description,
!      including arithmetic operations, occur in <xref
!      linkend="views"></xref>.</para>
  
       <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	   orient="port" pgwide="0" id="arrays-domains-use-table">
!       <title>Some &domain; Accessors</title>
       
        <tgroup cols="2" align="left">
         <thead>
  	<row>
! 	 <entry>&domain; member function</entry>
  	 <entry>result</entry>
  	</row>
         </thead>
         <tfoot>
  	<row>
! 	 <entry>Other &domain; accessors are described in <xref
! 	 linkend="views"></xref>.</entry>
  	</row>
         </tfoot>
         <tbody>
! 	<row rowsep="1">
! 	 <entry>Multidimensional &domain; Accessors</entry>
  	</row>
  	<row>
! 	 <entry><statement>long size()</statement></entry>
! 	 <entry>returns the total number of indices.</entry>
  	</row>
  	<row>
! 	 <entry><statement>bool empty()</statement></entry>
! 	 <entry>returns &true; if and only if the &domain; has no indices.</entry>
  	</row>
  	<row>
! 	 <entry><statement>D&lt;1&gt; operator[](int dimension)</statement></entry>
! 	 <entry>returns the one-dimensional &domain; for the specified
! 	 dimension.  The return type is a one-dimensional version of
! 	 the &domain;.</entry>
  	</row>
! 	<row rowsep="1">
! 	 <entry>One-dimensional &domain; Accessors</entry>
  	</row>
  	<row>
! 	 <entry><statement>long length()</statement></entry>
! 	 <entry>returns the number of indices.</entry>
  	</row>
  	<row>
! 	 <entry><statement>int first()</statement></entry>
! 	 <entry>returns the beginning of the domain.</entry>
  	</row>
  	<row>
! 	 <entry><statement>int last()</statement></entry>
! 	 <entry>returns the ending of the domain.</entry>
  	</row>
  	<row>
! 	 <entry><statement>int min()</statement></entry>
! 	 <entry>returns the minimum index in the domain.</entry>
  	</row>
  	<row>
! 	 <entry><statement>int max()</statement></entry>
! 	 <entry>returns the maximum index in the domain.</entry>
  	</row>
  	<row>
! 	 <entry><statement>D&lt;1&gt;::iterator begin()</statement></entry>
! 	 <entry>returns a bidirectional iterator pointing to the
! 	 beginning domain index.</entry>
  	</row>
  	<row>
! 	 <entry><statement>D&lt;1&gt;::iterator end()</statement></entry>
! 	 <entry>returns a bidirectional iterator pointing to the ending
! 	 domain index.</entry>
  	</row>
         </tbody>
        </tgroup>
       </table>
  
!      <para>&domain; member functions are listed in <xref
!      linkend="arrays-domains-use-table"></xref>.  Functions applicable
!      to one-dimensional and multidimensional &domain;s are listed
!      before functions that only applicable to one-dimensional
!      &domain;s.  The <methodname>size</methodname> member function
!      yields the total number of indices in a given &domain;.  If and
!      only if this number is zero, <methodname>empty</methodname> will
!      yield &true;.  A multidimensional
!      <type>domain&lt;&dim;&gt;</type> is the direct product of &dim;
!      one-dimensional &domain;s.
  
! HERE</para>
     </section>
+    </section>
  
  
     <section id="arrays-arrays_declarations">
      <title>Declaring &array;s</title>
  
      <para>A &pooma; &array; maps indices from its &domain; to values.
!     In this section, we first describe how to declare &array;s.  In
!     the next section, we explain how to access individual values
!     stored within an &array; and &array; copy semantics.</para>
  
      <para>&array; values need not just be stored values, as &c; arrays
      have.  They can also be computed using its engine.  We defer
*************** Grid&lt;1&gt; g1(il);
*** 1195,1201 ****
      compute the resulting &array;'s domain.  These are combined in the
      same way that multidimensional &interval;s are constructed.  (See
      <xref
!     linkend="arrays-domains_declarations-intervals-multi_d_table"></xref>
      and the following text.)  The domain objects, having types
      <type>&domaintemplate;1</type>, &hellip;,
      <type>&domaintemplate;7</type>, can have any type that can be
--- 1290,1296 ----
      compute the resulting &array;'s domain.  These are combined in the
      same way that multidimensional &interval;s are constructed.  (See
      <xref
!     linkend="arrays-domains-declarations-intervals-multi_d_table"></xref>
      and the following text.)  The domain objects, having types
      <type>&domaintemplate;1</type>, &hellip;,
      <type>&domaintemplate;7</type>, can have any type that can be
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1715,1720 ****
--- 1810,2129 ----
      which its <methodname>first</methodname> extracts the length.  The
      <methodname>length</methodname> &array; member function is used in
      the <function>PAssert</function>.</para>
+    </section>
+ 
+ 
+    <section id="arrays-dynamic_arrays">
+     <title>&dynamicarray;s: Dynamically Changing Domain Sizes</title>
+ 
+     <para>&array;s have fixed domains so the set of valid indices
+     remains fixed after declaration.  The &dynamicarray; class
+     supports one-dimensional domains that can be resized even while
+     the array is used.</para>
+ 
+     <para>&dynamicarray;'s interface extends the one-dimensional
+     interface of an &array; by adding member functions to change the
+     domain's size.  It is declared in <filename
+     class="libraryfile">Pooma/DynamicArrays.h</filename>.  A
+     &dynamicarray; has two, not three, template parameters, omitting
+     the array's dimensionality.  The first
+     parameter&nbsp;<type>T</type> specifies the type of stored values.
+     Its default value is usually &double;, but it may be changed when
+     the &poomatoolkit; is configured.  The second parameter specifies
+     an &engine; via a tag.  The engine must support a domain with
+     dynamic resizing.  For example, the &dynamic; &engine; is
+     analogous to a one-dimensional &brick; &engine; supporting a
+     dynamically-resizable domain.  It is also usually the default
+     value for this tag.  For example, <statement>DynamicArray&lt;&gt;
+     d0(1);</statement>, <statement>DynamicArray&lt;double&gt;
+     d1(1);</statement>, and <statement>DynamicArray&lt;double,
+     Dynamic&gt; d2(1);</statement> all declare the same
+     &dynamicarray;s explicitly storing one &double; value.  A
+     &dynamicarray; automatically allocates its initial memory and
+     deallocates its final memory, just as an &array; does.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0" id="arrays-dynamic_arrays-change_size">
+      <title>Changing a &dynamicarray;'s Domain</title>
+      
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>&dynamicarray; member function</entry>
+ 	<entry>description</entry>
+        </row>
+       </thead>
+       <tfoot>
+        <row>
+ 	<entry>This table omits member functions designed for
+ 	distributed computation.</entry>
+        </row>
+       </tfoot>
+       <tbody>
+        <row>
+ 	<entry><statement>void create(int num)</statement></entry>
+ 	<entry>extend the current domain by the requested number of
+         elements.</entry>
+        </row>
+        <row>
+ 	<entry><statement>void destroy(const Dom&amp; killList)</statement></entry>
+ 	<entry>remove the elements specified by the indices in the
+ 	given &domain; argument.  <quote>Backfill</quote> moves
+ 	elements from the end of the domain to replace the deleted
+ 	elements.</entry>
+        </row>
+        <row>
+ 	<entry><statement>void destroy(Iter killBegin, Iter killEnd)</statement></entry>
+ 	<entry>remove the elements specified by the indices in the
+ 	container range [begin,end) specified by the random-access
+ 	iterators.  <quote>Backfill</quote> moves elements from the
+ 	end of the domain to replace the deleted elements.</entry>
+        </row>
+        <row>
+ 	<entry><statement>void destroy(const Dom&amp; killList, const
+ 	DeleteMethod&amp; method)</statement></entry>
+ 
+ 	<entry>remove the elements specified by the indices in the
+ 	given &domain; argument.  Deleted elements can be replaced by
+ 	<type>BackFill</type>'ing, i.e., moving data from the domain's
+ 	end to fill removed elements, or by <type>ShiftUp</type>'ing,
+ 	i.e., compacting all data but maintaining relative ordering.</entry>
+        </row>
+        <row>
+ 	<entry><statement>void destroy(Iter killBegin, Iter killEnd,
+ 	const DeleteMethod&amp; method)</statement></entry>
+         <entry>remove the elements specified by the indices in the
+ 	container range [begin,end) specified by the random-access
+ 	iterators.  Deleted elements can be replaced by
+ 	<type>BackFill</type>'ing, i.e., moving data from the domain's
+ 	end to fill removed elements, or by <type>ShiftUp</type>'ing,
+ 	i.e., compacting all data but maintaining relative ordering.</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <para>The <methodname>create</methodname> and
+     <methodname>destroy</methodname> member functions permit changing
+     a &dynamicarray;'s domain.  <xref
+     linkend="arrays-dynamic_arrays-change_size"></xref> lists these member
+     functions but omits functions exclusively used in distributed
+     computation.  When making the domain larger, new indices are added
+     to the end of the one-dimensional domain and the corresponding
+     values are initialized with the default value
+     for&nbsp;<type>T</type>.  Existing values are copied.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0" id="arrays-dynamic_arrays-table">
+      <title>Changing a &dynamicarray;'s Domain</title>
+      
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>&dynamicarray; member function</entry>
+ 	<entry>description</entry>
+        </row>
+       </thead>
+       <tfoot>
+        <row>
+ 	<entry>This table omits member functions designed for
+ 	distributed computation.</entry>
+        </row>
+       </tfoot>
+       <tbody>
+        <row>
+ 	<entry><statement>void create(int num)</statement></entry>
+ 	<entry>extend the current domain by the requested number of
+         elements.</entry>
+        </row>
+        <row>
+ 	<entry><statement>void destroy(const Dom&amp; killList)</statement></entry>
+ 	<entry>remove the elements specified by the indices in the
+ 	given &domain; argument.  <quote>Backfill</quote> moves
+ 	elements from the end of the domain to replace the deleted
+ 	elements.</entry>
+        </row>
+        <row>
+ 	<entry><statement>void destroy(Iter killBegin, Iter killEnd)</statement></entry>
+ 	<entry>remove the elements specified by the indices in the
+ 	container range [begin,end) specified by the random-access
+ 	iterators.  <quote>Backfill</quote> moves elements from the
+ 	end of the domain to replace the deleted elements.</entry>
+        </row>
+        <row>
+ 	<entry><statement>void destroy(const Dom&amp; killList, const
+ 	DeleteMethod&amp; method)</statement></entry>
+ 
+ 	<entry>remove the elements specified by the indices in the
+ 	given &domain; argument.  Deleted elements can be replaced by
+ 	<type>BackFill</type>'ing, i.e., moving data from the domain's
+ 	end to fill removed elements, or by <type>ShiftUp</type>'ing,
+ 	i.e., compacting all data but maintaining relative ordering.</entry>
+        </row>
+        <row>
+ 	<entry><statement>void destroy(Iter killBegin, Iter killEnd,
+ 	const DeleteMethod&amp; method)</statement></entry>
+         <entry>remove the elements specified by the indices in the
+ 	container range [begin,end) specified by the random-access
+ 	iterators.  Deleted elements can be replaced by
+ 	<type>BackFill</type>'ing, i.e., moving data from the domain's
+ 	end to fill removed elements, or by <type>ShiftUp</type>'ing,
+ 	i.e., compacting all data but maintaining relative ordering.</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <para>The <methodname>destroy</methodname> deletes specified
+     indices.  The indices may be specified using either a &domain;
+     object (<type>Interval&lt;1&gt;</type>,
+     <type>Range&lt;1&gt;</type>, or <type>IndirectionList</type>) or
+     in a container specified using random-access iterators.  For
+     example, every other element from a ten-element
+     array&nbsp;<varname>d</varname> might be removed using
+     <statement>Range&lt;1&gt;(0,9,2)</statement>.  Alternatively,
+ <programlisting>
+ int killList[] = {0, 2, 4, 6, 8};
+ d.destroy(killList, killList+5);
+ </programlisting> performs the same deletions.  As indices are
+     removed, other indices are moved into their positions.  Using the
+     <type>BackFill</type> method moves the last index and its
+     associated value into deleted index's position.  Thus, the total
+     number of indices is decreased by one, but the indices can be
+     reordered.  Using the <type>ShiftUp</type> method ensures the
+     indices' orders are maintained by <quote>shifting</quote> all
+     elements left (or up) so all <quote>gaps</quote> between indices
+     disappear.  For example, consider removing the first index from a
+     domain.
+     <informaltable frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0" id="arrays-dynamic_arrays-destroy_example">
+      <tgroup cols="2" align="left">
+       <tbody>
+        <row>
+ 	<entry>original indices:</entry>
+ 	<entry>0 1 2 3</entry>
+        </row>
+        <row>
+ 	<entry><methodname>destroy</methodname> using <type>BackFill</type></entry>
+ 	<entry>3 1 2</entry>
+        </row>
+        <row>
+ 	<entry><methodname>destroy</methodname> using <type>ShiftUp</type></entry>
+ 	<entry>1 2 3</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </informaltable>
+     The <type>BackFill</type> moves the rightmost index&nbsp;3 into
+     the removed index&nbsp;0's position.  The <type>ShiftUp</type>
+     moves all the indices one position to the left.  This illustrates
+     that <type>BackFill</type> moves exactly as many indices as are
+     deleted, while <type>ShiftUp</type> can shift all indices in a
+     domain.  Thus, <type>BackFill</type> is the default method.  When
+     multiple indices are deleted, they are deleted from the largest to
+     the smallest.  When using the <type>BackFill</type> method, some
+     indices may be moved repeatedly.  For example, consider removing
+     indices 0 and 2 from original indices of 0 1 2 3.  Removing 2
+     yields 0 1 3.  Removing 0 yields 3 1.  Using an object with the
+     desired type to indicate which fill method is desired, i.e.,
+     <statement>BackFill()</statement> or
+     <statement>ShiftUp()</statement>.</para>
+ 
+     <example id="arrays-dynamic_arrays-example">
+      <title>Example Using &dynamicarray;s</title>
+ 
+      &dynamicarray-example;
+      <calloutlist>
+       <callout arearefs="arrays-dynamic_arrays-example-header">
+        <para>This header file declares &dynamicarray;s.</para>
+       </callout>
+       <callout arearefs="arrays-dynamic_arrays-example-identical_declarations">
+        <para>These three declarations yield equivalent
+        &dynamicarray;s, storing one &double; value.</para>
+       </callout>
+       <callout arearefs="arrays-dynamic_arrays-example-extension">
+        <para>This <methodname>create</methodname> member function adds
+        five indices to the end of the domain.</para>
+       </callout>
+       <callout arearefs="arrays-dynamic_arrays-example-access">
+        <para>&dynamicarray; values are accessed the same way as
+        &array; values.</para>
+       </callout>
+       <callout arearefs="arrays-dynamic_arrays-example-destroy_range">
+        <para>The &range; object specifies that every other index
+        should be removed.  The <statement>BackFill()</statement>
+        object is unnecessary since it is the default replacement
+        method.</para>
+       </callout>
+       <callout arearefs="arrays-dynamic_arrays-example-destroy_iterators">
+        <para>This <methodname>destroy</methodname> call is equivalent
+        to the previous one but uses iterators.</para>
+       </callout>
+      </calloutlist>
+     </example>
+ 
+     <para>We illustrate &dynamicarray; resizing in <xref
+     linkend="arrays-dynamic_arrays-example"></xref>.  &dynamicarray;s
+     are declared in <filename
+     class="headerfile">Pooma/DynamicArrays.h</filename>, not <filename
+     class="headerfile">Pooma/Arrays.h</filename>.  Their declarations
+     require two, not three, template arguments because the array must
+     be one-dimensional.  The three arrays, each having one &double;
+     value, are equivalent.  (The &poomatoolkit; can be configured to
+     support different default values.)  Invoking
+     <varname>d0</varname>'s <methodname>create</methodname> with an
+     argument of five increases its domain size from one to six.  The
+     additional indices are added to the end of the domain so the value
+     at index&nbsp;0 is not changed.  To illustrate which indices are
+     removed and which indices are reordered, the program first sets
+     all values equal to their indices.  This illustrates that
+     &dynamicarray; values are accessed the same way as &array; values.
+     For example, <statement>d0(i)</statement> accesses the
+     <varname>i</varname>th value.  The
+     <methodname>destroy</methodname> removes every other index from
+     the array.  The one-dimensional &range; specifies these indices by
+     specifying the domain's entire interval and a stride of&nbsp;2.
+     The <statement>BackFill</statement> function call creates a
+     <type>BackFill</type> object indicating the <type>BackFill</type>
+     method should be used.  We illustrate the steps of this method:
+     <informaltable frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0" id="arrays-dynamic_arrays-program_example">
+      <tgroup cols="2" align="left">
+       <tbody>
+        <row>
+ 	<entry>original indices:</entry>
+ 	<entry>0 1 2 3 4 5</entry>
+        </row>
+        <row>
+ 	<entry>delete index 4</entry>
+ 	<entry>0 1 2 3 5</entry>
+        </row>
+        <row>
+ 	<entry>delete index 2</entry>
+ 	<entry>0 1 5 3</entry>
+        </row>
+        <row>
+ 	<entry>delete index 0</entry>
+ 	<entry>3 1 5</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </informaltable>
+     Since multiple indices are specified, the rightmost one is removed
+     first, i.e., index&nbsp;4.  The rightmost index&nbsp;5 is moved
+     into 4's position.  When removing index&nbsp;2, the index
+     originally at 5 is moved again into 2's position.  Finally,
+     index&nbsp;0 is replaced by index&nbsp;3.  The rest of the program
+     repeats the computation, using the random-access iterator version
+     of <methodname>destroy</methodname>.  Since this &dynamicarray;'s
+     indices are specified using &int;s, the
+     <varname>killList</varname> explicitly lists the indices to
+     remove.  The <methodname>destroy</methodname> call uses pointers
+     to the beginning and end of the <varname>killList</varname> array
+     to specify which of its indices to use.  Since no replacement
+     method is specified, the default <type>BackFill</type> method is
+     used.  All the &dynamicarray;s' unallocated memory is
+     deallocated.</para>
     </section>
  
  
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.6
diff -c -p -r1.6 concepts.xml
*** concepts.xml	2002/01/16 00:50:27	1.6
--- concepts.xml	2002/01/22 15:37:14
***************
*** 147,158 ****
       <row>
  	<entry><glossterm linkend="glossary-field">&field;</glossterm></entry>
  	<entry>container mapping <glossterm linkend="glossary-index">indices</glossterm> to one or more values and
! 	residing in multi-dimensional space</entry>
       </row>
       <row>
  	<entry><glossterm
  	linkend="glossary-tensor">&tensor;</glossterm></entry>
! 	<entry>multi-dimensional mathematical tensor</entry>
       </row>
       <row>
  	<entry><glossterm
--- 147,158 ----
       <row>
  	<entry><glossterm linkend="glossary-field">&field;</glossterm></entry>
  	<entry>container mapping <glossterm linkend="glossary-index">indices</glossterm> to one or more values and
! 	residing in multidimensional space</entry>
       </row>
       <row>
  	<entry><glossterm
  	linkend="glossary-tensor">&tensor;</glossterm></entry>
! 	<entry>multidimensional mathematical tensor</entry>
       </row>
       <row>
  	<entry><glossterm
***************
*** 162,168 ****
       <row>
  	<entry><glossterm
  	linkend="glossary-vector">&vector;</glossterm></entry>
! 	<entry>multi-dimensional mathematical vector</entry>
       </row>
      </tbody>
     </tgroup>
--- 162,168 ----
       <row>
  	<entry><glossterm
  	linkend="glossary-vector">&vector;</glossterm></entry>
! 	<entry>multidimensional mathematical vector</entry>
       </row>
      </tbody>
     </tgroup>
***************
*** 210,216 ****
  <!-- FIXME: Want firstterm around tensor. -->
  
    <para>A <glossterm linkend="glossary-tensor">&tensor;</glossterm>
!   implements a multi-dimensional mathematical tensor.  Since it is a
    first-class type, it can be used in expressions such as
    adding two &tensor;s.</para>
  
--- 210,216 ----
  <!-- FIXME: Want firstterm around tensor. -->
  
    <para>A <glossterm linkend="glossary-tensor">&tensor;</glossterm>
!   implements a multidimensional mathematical tensor.  Since it is a
    first-class type, it can be used in expressions such as
    adding two &tensor;s.</para>
  
***************
*** 224,230 ****
  <!-- FIXME: Want firstterm around vector. -->
  
    <para>A <glossterm linkend="glossary-vector">&vector;</glossterm>
!   implements a multi-dimensional mathematical vector, which is an
    ordered tuple of components.  Since it is a first-class type, it
    can be used in expressions such as adding two &vector;s and
    multiplying a &matrix; and a &vector;.</para>
--- 224,230 ----
  <!-- FIXME: Want firstterm around vector. -->
  
    <para>A <glossterm linkend="glossary-vector">&vector;</glossterm>
!   implements a multidimensional mathematical vector, which is an
    ordered tuple of components.  Since it is a first-class type, it
    can be used in expressions such as adding two &vector;s and
    multiplying a &matrix; and a &vector;.</para>
***************
*** 263,269 ****
  	<entry>use a &vector;, &matrix;, or &tensor;.</entry>
       </row>
       <row>
! 	<entry>If indices and values reside in multi-dimensional space
  	&space;,</entry>
  	<entry>use a &field;.</entry>
       </row>
--- 263,269 ----
  	<entry>use a &vector;, &matrix;, or &tensor;.</entry>
       </row>
       <row>
! 	<entry>If indices and values reside in multidimensional space
  	&space;,</entry>
  	<entry>use a &field;.</entry>
       </row>
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.6
diff -c -p -r1.6 glossary.xml
*** glossary.xml	2002/01/14 17:33:34	1.6
--- glossary.xml	2002/01/22 15:37:16
***************
*** 369,374 ****
--- 369,384 ----
     </glossdef>
    </glossentry>
  
+   <glossentry id="glossary-function_object">
+    <glossterm>function object</glossterm>
+    <glossdef>
+     <para>object that can behave as a function.  The object can store
+     values that the function uses.  If its function is called
+     <methodname>operator()</methodname>, the object can be invoked as
+     a function.</para>
+    </glossdef>
+   </glossentry>
+ 
    <glossentry id="glossary-function_template">
     <glossterm>function template</glossterm>
     <glossdef>
***************
*** 547,553 ****
    <glossentry id="glossary-point">
     <glossterm>point</glossterm>
     <glossdef>
!     <para>a location in multi-dimensional space&nbsp;&space;.
      In contrast, indices specify positions in container domains.</para>
      <glossseealso otherterm="glossary-field">&field;</glossseealso>
      <glossseealso otherterm="glossary-mesh">mesh</glossseealso>
--- 557,563 ----
    <glossentry id="glossary-point">
     <glossterm>point</glossterm>
     <glossdef>
!     <para>a location in multidimensional space&nbsp;&space;.
      In contrast, indices specify positions in container domains.</para>
      <glossseealso otherterm="glossary-field">&field;</glossseealso>
      <glossseealso otherterm="glossary-mesh">mesh</glossseealso>
***************
*** 694,700 ****
    <glossentry id="glossary-tensor">
     <glossterm>&tensor;</glossterm>
     <glossdef>
!     <para>a &pooma; container implementing multi-dimensional
      mathematical tensors as first-class objects.</para>
      <glossseealso otherterm="glossary-matrix">&matrix;</glossseealso>
      <glossseealso otherterm="glossary-vector">&vector;</glossseealso>
--- 704,710 ----
    <glossentry id="glossary-tensor">
     <glossterm>&tensor;</glossterm>
     <glossdef>
!     <para>a &pooma; container implementing multidimensional
      mathematical tensors as first-class objects.</para>
      <glossseealso otherterm="glossary-matrix">&matrix;</glossseealso>
      <glossseealso otherterm="glossary-vector">&vector;</glossseealso>
***************
*** 750,756 ****
    <glossentry id="glossary-vector">
     <glossterm>&vector;</glossterm>
     <glossdef>
!     <para>a &pooma; container implementing multi-dimensional
      mathematical vectors, i.e., an ordered tuple of components, as
      first-class objects.</para>
      <glossseealso otherterm="glossary-tensor">&tensor;</glossseealso>
--- 760,766 ----
    <glossentry id="glossary-vector">
     <glossterm>&vector;</glossterm>
     <glossdef>
!     <para>a &pooma; container implementing multidimensional
      mathematical vectors, i.e., an ordered tuple of components, as
      first-class objects.</para>
      <glossseealso otherterm="glossary-tensor">&tensor;</glossseealso>
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.7
diff -c -p -r1.7 manual.xml
*** manual.xml	2002/01/16 00:50:27	1.7
--- manual.xml	2002/01/22 15:37:19
***************
*** 95,100 ****
--- 95,102 ----
    <!-- A domain template parameter. -->
  <!ENTITY double "<type>double</type>">
    <!-- The C "double" type. -->
+ <!ENTITY dynamic "<type>Dynamic</type>">
+   <!-- The "Dynamic" Engine type. -->
  <!ENTITY dynamicarray "<type>DynamicArray</type>">
    <!-- The "DynamicArray" type. -->
  <!ENTITY engine "<type>Engine</type>">
***************
*** 156,167 ****
  
  <!ENTITY container "C">
    <!-- an abbreviation for a canonical container -->
- <!ENTITY dim "D">
-   <!-- the number of dimensions of an array, domain, etc. -->
  <!ENTITY n "n">
    <!-- the size of one dimension of an array -->
  <!ENTITY space "&real;<superscript>d</superscript>">
!   <!-- a notation for multi-dimensional space -->
  
  <!-- System and Operating System Entity Declarations -->
  <!ENTITY gcc "<application>g++</application>">
--- 158,167 ----
  
  <!ENTITY container "C">
    <!-- an abbreviation for a canonical container -->
  <!ENTITY n "n">
    <!-- the size of one dimension of an array -->
  <!ENTITY space "&real;<superscript>d</superscript>">
!   <!-- a notation for multidimensional space -->
  
  <!-- System and Operating System Entity Declarations -->
  <!ENTITY gcc "<application>g++</application>">
***************
*** 234,245 ****
    <!-- Field data-parallel distributed Doof2d implementation -->
  
  <!-- Sequential Programs -->
- <!ENTITY initialize-finalize SYSTEM "./programs/examples/Sequential/initialize-finalize-annotated.cpp">
-   <!-- Illustrate initialize() and finalize(). -->
  <!ENTITY array-copy SYSTEM "./programs/examples/Sequential/array-copy-annotated.cpp">
    <!-- Illustrate Array reference semantics. -->
  <!ENTITY array-size SYSTEM "./programs/examples/Sequential/array-size-annotated.cpp">
    <!-- Illustrate Array member functions. -->
  
  <!-- Template Programs -->
  <!ENTITY pairs-untemplated SYSTEM "./programs/examples/Templates/pairs-untemplated-annotated.cpp">
--- 234,247 ----
    <!-- Field data-parallel distributed Doof2d implementation -->
  
  <!-- Sequential Programs -->
  <!ENTITY array-copy SYSTEM "./programs/examples/Sequential/array-copy-annotated.cpp">
    <!-- Illustrate Array reference semantics. -->
  <!ENTITY array-size SYSTEM "./programs/examples/Sequential/array-size-annotated.cpp">
    <!-- Illustrate Array member functions. -->
+ <!ENTITY dynamicarray-example SYSTEM "./programs/examples/Sequential/dynamicarray-annotated.cpp">
+   <!-- Illustrate using DynamicArray class. -->
+ <!ENTITY initialize-finalize SYSTEM "./programs/examples/Sequential/initialize-finalize-annotated.cpp">
+   <!-- Illustrate initialize() and finalize(). -->
  
  <!-- Template Programs -->
  <!ENTITY pairs-untemplated SYSTEM "./programs/examples/Templates/pairs-untemplated-annotated.cpp">
***************
*** 353,362 ****
  
    &arrays-chapter;
  
    <chapter id="engines">
     <title>Engines</title>
  
!    <para>UNFINISHED</para>
    </chapter>
  
  
--- 355,692 ----
  
    &arrays-chapter;
  
+ 
    <chapter id="engines">
     <title>Engines</title>
  
!    <para>Each container has one or more &engine;s to store or compute
!    its values.  As we mentioned in <xref
!    linkend="arrays-arrays_declarations"></xref>, a container's role is
!    high-level, supporting access to groups of values, and an engine's
!    role is low-level, storing or computing values and supporting
!    access to individual values.  This separation permits optimizing
!    space and computation requirements.</para>
! 
!    <para>We begin this chapter by introducing the concept of an engine
!    and how it is used.  Then, we describe the various &engine;s that
!    &pooma; provides, separating them into engines that store values
!    and engines that compute values.  Finally, we describe how the
!    &engine;s are implemented, using tags to differentiate engines and
!    reference-counted pointers to their underlying data.</para>
! 
! 
!    <section id="engines-concept">
!     <title>The Concept</title>
! 
!     <para>An engine performs the low-level value storage, computation,
!     and element-wise access for a container.  The &pooma; &engine;
!     class and its specializations implement the concept.  An engine
!     has a domain and accessor functions returning individual elements.
!     Given an index within the domain, an engine's
!     <methodname>operator()</methodname> function returns the
!     associated value, which can be used or changed.  Its
!     <methodname>read</methodname> returns the same value for only use,
!     not modification.  The acceptable indices are determined by each
!     &engine;.  Most accept indices specified using &int; and
!     <type>Loc&lt;&dim;&gt;</type> parameters, but an &engine; might
!     accept string or floating-point parameters.  An &engine;'s layout
!     specifies maps its domain indices to the processors and memory
!     used to store and compute the associated values.</para>
! 
!     <para>Since an engine's main role is to return the individual
!     values associated with specific domain indices, any implementation
!     performing this task is an engine.  &pooma; &engine;s fall into
!     three categories:
!     <itemizedlist>
!      <listitem>
!       <para>&engine;s that store values.</para>
!      </listitem>
!      <listitem>
!       <para>&engine;s that compute their values using other &engine;s'
!       values.</para>
!      </listitem>
!      <listitem>
!       <para>&engine;s that support distributed computation.</para>
!      </listitem>
!     </itemizedlist>
!     For example, the &brick; &engine; explicitly stores all its
!     values, while the &compressiblebrick; engine adds the feature of
!     reducing its storage requirements if all these values are
!     identical.  A <type>UserFunction</type> &engine; yields values by
!     applying a <glossterm linkend="glossary-function_object">function
!     object</glossterm> to each value returned by another &engine;.  A
!     <type>CompFwd</type> &engine; projects components from another
!     &engine;.  For example, <type>CompFwd</type> will use the second
!     components of each vector in an &array; to form its own &array;.
!     Since each container has one or more &engine;s, we can also
!     describe the latter category as containers that compute their
!     values using other containers' values.  A <type>MultiPatch</type>
!     &engine; distributes its domain among various processors and
!     memory spaces, each responsible for computing values associated
!     with a portion, or patch, of the domain.</para>
! 
!     <para>Just as multiple containers can use the same engine,
!     multiple &engine;s can use the same underlying data.  As we
!     mentioned in <xref linkend="arrays-arrays_use"></xref>, &engine;s
!     have reference semantics.  So a copy of an &engine; has a
!     reference-counted pointer to an &engine;'s data (if any exists).
!     Thus, copying an &engine; or a container requires little execution
!     time.  If an &engine; has the same data as another &engine; but it
!     needs its own data to modify, the
!     <methodname>makeOwnCopy</methodname> creates such a copy.</para>
! 
!     <para>&engine;s are rarely explicitly declared.  Instead a
!     container is declared using an &engine; tag, and the container,
!     creates the specified &engine; to deal with its values.  For
!     example, a &brick; &engine; is explicitly declared as
!     <type>Engine&lt;&dim;,T,Brick&gt;</type>, but they are more
!     frequently created by containers, e.g.,
!     <type>Array&lt;&dim;,T,Brick&gt;</type>.  The first two template
!     parameters specify the domain's dimensionality and the value type,
!     as described in <xref
!     linkend="arrays-arrays_declarations"></xref>.  Unlike container
!     declarations, the third template parameter, the &engine; tag,
!     specifies which &engine; specialization to use.  For example, the
!     &brick; engine tag indicates a brick &engine; should be used.
!     Some &engine;s, such as <type>CompFwd</type>, are rarely declared
!     even using &engine; tags.  Instead the &array;'s
!     <methodname>comp</methodname> and
!     <methodname>readComp</methodname> methods return views of
!     containers using <type>CompFwd</type> &engine;s.</para>
!    </section>
! 
! 
!    <section id="engines-types">
!     <title>Types of &engine;s</title>
! 
!     <para>In this section, we describe the different types of
!     &engine;s and illustrate their creation, when appropriate.  First,
!     we describe &engine;s that explicitly store values and then
!     &engine;s that compute values.</para>
! 
!      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	    orient="port" pgwide="0" id="engines-types-table">
!       <title>Types of &engine;s</title>
!      
!       <tgroup cols="2" align="left">
!        <thead>
! 	<row>
! 	 <entry>&engine; tag</entry>
! 	 <entry>description</entry>
! 	</row>
!        </thead>
!        <tbody>
! 	<row rowsep="1">
! 	 <entry>&engine;s That Store</entry>
! 	</row>
! 	<row>
! 	 <entry>&brick;</entry>
! 	 <entry>explicitly stores all values; similar to &c; arrays.</entry>
! 	</row>
! 	<row>
! 	 <entry>&compressiblebrick;</entry>
! 	 <entry>stores all values, reducing storage requirements when
! 	 all values are the same.</entry>
! 	</row>
! 	<row>
! 	 <entry>&dynamic;</entry>
! 	 <entry>is a one-dimensional &brick; with dynamically
!          resizable domain.  HERE ever explicitly declare these?</entry>
! 	</row>
! 	<row rowsep="1">
! 	 <entry>&engine;s That Compute</entry>
! 	</row>
! 	<row>
! 	 <entry><type>CompFwd</type></entry>
! 	 <entry>extracts specified components of an engine's vectors,
! 	 tensors, arrays, etc.; usually created using
! 	 <methodname>comp</methodname> container function.</entry>
! 	</row>
! 	<row>
! 	 <entry><type>ConstantFunction</type></entry>
! 	 <entry>makes a scalar value behave like a container.</entry>
! 	</row>
! 	<row>
! 	 <entry><type>IndexFunction&lt;FunctionObject&gt;</type></entry>
! 	 <entry>makes the <type>FunctionObject</type> function of
! 	 indices behave like a container.</entry>
! 	</row>
! 	<row>
! 	 <entry><type>ExpressionTag&lt;Expr&gt;</type></entry>
! 	 <entry>evaluates an expression tree; usually created by
! 	 data-parallel expressions.</entry>
! 	</row>
! 	<row>
! 	 <entry><type>Stencil&lt;Function,
! 	 Expression&gt;</type></entry>
!          <entry>applies a stencil computation (<type>Function</type>)
! 	 to its input (<type>Expression</type>), usually a container;
! 	 usually created by applying a <type>Stencil</type> object to
! 	 a container.  A stencil computation can use multiple
! 	 neighboring input values.</entry>
! 	</row>
! 	<row>
! 	 <entry><type>UserFunctionEngine&lt;Function,
! 	 Expression&gt;</type></entry>
! 	 <entry>applies the given function (or <glossterm
! 	 linkend="glossary-function_object">function
! 	 object</glossterm>) to its input (<type>Expression</type>),
! 	 usually a container; usually created by applying a
! 	 <type>UserFunction</type> object to a container.  The
! 	 function implements a one-to-one mapping from its input to
! 	 values.</entry>
! 	</row>
! 	<row rowsep="1">
! 	 <entry>&engine;s for Distributed Computation</entry>
! 	</row>
! 	<row>
! 	 <entry><type>MultiPatch&lt;LayoutTag,EngineTag&gt;</type></entry>
! 	 <entry>runs a separate <type>EngineTag</type> &engine; on
! 	 each context (patch) specified by the given layout.  This is
! 	 the usual &engine; for distributed computation.</entry>
! 	</row>
! 	<row>
! 	 <entry><type>Remote&lt;EngineTag&gt;</type></entry>
! 	 <entry>runs the &engine; specified by <type>EngineTag</type>
! 	 on a specified context.</entry>
! 	</row>
! 	<row>
! 	 <entry><type>Remote&lt;Dynamic&gt;</type></entry>
! 	<entry>runs a <type>Dynamic</type> one-dimensional, resizable
! 	&engine; on a specified context.  This is a specialization of
! 	<type>Remote</type>.</entry>
! 	</row>
!        </tbody>
!       </tgroup>
!      </table>
! 
!     <para>&brick; &engine;s explicitly store values just like &c;
!     arrays.  &compressiblebrick; &engine;s optimize their storage
!     requirements when all values are the same.  Most &array;s use one
!     of these two &engine;s.  &brick;s are the default &engine;s for
!     &array; and &field; containers because each of their values are
!     explicitly stored.  Explicitly storing all an engine's value can
!     require a large amount of space, particularly if all these values
!     are the same.  If all a compressible brick &engine;'s values are
!     the same, the engine stores that one value rather than many, many
!     copies of the same value.  These engines can both save time as
!     well as space.  Initializing a compressible engine requires
!     setting only one value, not every value.  Using less storage space
!     may permit more useful values to be stored in cache, improving
!     cache performance.  Reading a value in a compressed &engine; using
!     <methodname>read</methodname> is as fast as reading a value in a
!     &brick; &engine;, but writing a value always requires an
!     additional <keywordname>if</keywordname> conditional.  Thus, if an
!     &engine; occasionally has multiple different values during its
!     life time, a &compressiblebrick; &engine; may be faster than a
!     &brick; &engine;.  If an &engine; is created and its values are
!     mostly read, not written, a &compressiblebrick; &engine; may also
!     be faster.  Otherwise, a &brick; &engine; may be preferable.
!     Timing the same program using the two different &engine; types
!     will reveal which is faster for a particular situation.</para>
! 
!     <para>In distributed computing, many &engine;s may have few
!     nonzero values so &compressiblebrick; &engine;s may be preferable.
!     For distributed computing, a container's domain is partitioned
!     into regions each computed by a separate processor and &engine;.
!     If the computation is concentrated in sections of the domain, many
!     &engine;s may have few, if any, nonzero values.  Thus,
!     &compressiblebrick; &engine;s may be preferable for distributed
!     computing.</para>
! 
!     <para>Both &brick; and &compressiblebrick; &engine;s have
!     <methodname>read</methodname> and
!     <methodname>operator()</methodname> members with &int; and &loc;
!     parameters.  The parameters should match the &array;'s
!     dimensionality.  For example, if &array; <varname>a</varname> has
!     dimensionality&nbsp;3, <function>a.read(int, int, int)</function>
!     and <function>a(int, int, int)</function> should be used.  The
!     former returns a value that cannot be modified, while the latter
!     can be changed.  Using the <methodname>read</methodname> can lead
!     to faster code.  Alternatively, an index can be specified using a
!     &loc;.  For example,
!     <statement>a.read(Loc&lt;3&gt;(1,-2,5))</statement> and
!     <statement>a(Loc&lt;3&gt;(1,-2,5))</statement> are equivalent to
!     <statement>a.read(1,-2,5))</statement> and
!     <statement>a(1,-2,5)</statement>.</para>
! 
!     <para>The &dynamic; &engine; supports changing domain sizes while
!     a program is executing.  It is basically a one-dimensional
!     &brick;, explicitly storing values, but permitting the number and
!     order of stored values to change.  Thus, it supports the same
!     interface as &brick; except that all member functions are
!     restricted to their one-dimensional versions.  For example,
!     <methodname>read</methodname> and
!     <methodname>operator()</methodname> take <type>Loc&lt;1&gt;</type>
!     or one &int; parameter.  In addition, the one-dimensional domain
!     can be dynamically resized using <methodname>create</methodname>
!     and <methodname>destroy</methodname>; see .  
! 
! HERE Dynamic. How does one change the domain size?  What is the model?</para>
! 
! <!-- HERE: Array cannot forward domain size changes to underlying Dynamic Engine. -->
! 
!     <para>Types of &engine;s:
!    Brick - explicitly store values
!    CompressibleBrick - explicitly store values but store only one if all the same
!    ConstantFunction - convert scalar into an array
!    DynamicEngine - contiguous, local, resizable, 1D block
!    ExpressionEngine - evaluate PETE expression
!    CompFwd - array formed by extracted components from array
!      ForwardEngine
!      tut-02.html: use .comp() or .readComp()
!    IndexFunctionEngine - convert function of indices into an array
!    IndirectionEngine - incomplete
!    MultiPatch - ?How do I describe this?
!    RemoteDynamic - run a Dynamic engine on a specified context
!    Remote - permit computations on specified context
!      should discuss with MultiPatch
!    Stencil - apply a stencil to an array, returning a new Array with the results
!    UserFunction - Array = apply function to an Array
! </para>
! 
!    <para>How do I organize these engines into understandable
! 	     categories?
! 
!    storage
!     Brick
!     CompressibleBrick
!     Dynamic - resizable 1D block
!       RemoteDynamic
!     MultiPatch - ?WHAT?
!       Remote
! 
!    computation
!     CompFwd: project(array)->array
!       .comp() and .readComp()
!       view, not a copy
!     ConstantFunction: scalar(array)->array
!       explicitly use
!     IndexFunctionEngine: function(indices)->array
!       explicitly use
!     ExpressionEngine: expression(array)->array
!       created by data-parallel expression
!     Stencil: stencil(array)->array
!       implicitly used
!       explicitly use Stencil<...> type
!     UserFunction: function(array)->array
!       explicitly use
! </para>
! 
!     <para>
!       Element_t read(Loc&lt;&dim;&gt;)
!       ElementRef_t operator()(Loc&lt;&dim;&gt;)
!       Element_t read(int+)
!       ElementRef_t operator()(int+)
!     </para>
! 
!     <para>Explain the concept of an engine.  How does an engine
!     interact with a container or an &array;?  Explain the different
!     types of engines likely to be used by &pooma; programmers and how
!     to declare containers using them.  Should I list the other engines
!     that are automatically created?</para>
! 
!    </section>
    </chapter>
  
  
***************
*** 553,559 ****
      <title>Beginning and Ending &pooma; Programs</title>
  
      <para>Every &pooma; program must begin with a call to
!     <methodname>initialize</methodname> and end with a call to
      <function>finalize</function>.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.</para>
  
--- 883,889 ----
      <title>Beginning and Ending &pooma; Programs</title>
  
      <para>Every &pooma; program must begin with a call to
!     <function>initialize</function> and end with a call to
      <function>finalize</function>.  These functions respectively
      prepare and shut down &pooma;'s run-time structures.</para>
  
***************
*** 603,609 ****
      <bridgehead id="sequential-begin_end-description" renderas="sect2">Description</bridgehead>
  
       <para>Before its use, the &poomatoolkit; must be initialized by a
!      call to <methodname>initialize</methodname>.  This usually occurs in
       the <function>main</function> function.  The first form removes
       and processes any &pooma;-specific arguments from the
       command-line arguments <varname>argv</varname> and
--- 933,939 ----
      <bridgehead id="sequential-begin_end-description" renderas="sect2">Description</bridgehead>
  
       <para>Before its use, the &poomatoolkit; must be initialized by a
!      call to <function>initialize</function>.  This usually occurs in
       the <function>main</function> function.  The first form removes
       and processes any &pooma;-specific arguments from the
       command-line arguments <varname>argv</varname> and
***************
*** 625,631 ****
       architecture-specific initialization.  The function always
       returns &true;.</para>
  
!      <para><methodname>initialize</methodname>'s alternative form
       assumes the &pooma;-specific and architecture-specific
       command-line arguments have already been removed from
       <varname>argv</varname> and <varname>argc</varname> and stored in
--- 955,961 ----
       architecture-specific initialization.  The function always
       returns &true;.</para>
  
!      <para><function>initialize</function>'s alternative form
       assumes the &pooma;-specific and architecture-specific
       command-line arguments have already been removed from
       <varname>argv</varname> and <varname>argc</varname> and stored in
***************
*** 653,659 ****
      <bridgehead id="sequential-begin_end-example" renderas="sect2">Example Program</bridgehead>
  
       <para>Since every &pooma; program must call
!      <methodname>initialize</methodname> and
       <function>finalize</function>, the simplest &pooma; program also
       must call them.  This program also illustrates their usual
       use.</para>
--- 983,989 ----
      <bridgehead id="sequential-begin_end-example" renderas="sect2">Example Program</bridgehead>
  
       <para>Since every &pooma; program must call
!      <function>initialize</function> and
       <function>finalize</function>, the simplest &pooma; program also
       must call them.  This program also illustrates their usual
       use.</para>
*************** UNFINISHED</para>
*** 862,868 ****
        specifying N indices, which collectively specify a single point
        in the input domain: A(i1, i2, ..., iN).</para>
  
!      <para>The &pooma; multi-dimensional Array concept is similar to
        the &fortran; 90 array facility, but extends it in several
        ways. Both &pooma; and &fortran; arrays can have up to seven
        dimensions, and can serve as containers for arbitrary
--- 1192,1198 ----
        specifying N indices, which collectively specify a single point
        in the input domain: A(i1, i2, ..., iN).</para>
  
!      <para>The &pooma; multidimensional Array concept is similar to
        the &fortran; 90 array facility, but extends it in several
        ways. Both &pooma; and &fortran; arrays can have up to seven
        dimensions, and can serve as containers for arbitrary
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.5
diff -c -p -r1.5 tutorial.xml
*** tutorial.xml	2002/01/14 17:33:34	1.5
--- tutorial.xml	2002/01/22 15:37:20
***************
*** 856,862 ****
    multiple values.  Like &array;s, &field;s can be accessed via
    data-parallel expressions and stencils and may be distributed
    across processors.  Unlike &array; cells, &field; cells exist in a
!   multi-dimensional volume so, e.g., distances between cells and
    normals to cells can be computed.</para>
  
    <para>In this section, we implement the &doof2d; two-dimensional
--- 856,862 ----
    multiple values.  Like &array;s, &field;s can be accessed via
    data-parallel expressions and stencils and may be distributed
    across processors.  Unlike &array; cells, &field; cells exist in a
!   multidimensional volume so, e.g., distances between cells and
    normals to cells can be computed.</para>
  
    <para>In this section, we implement the &doof2d; two-dimensional

From oldham at codesourcery.com  Thu Jan 24 05:18:51 2002
From: oldham at codesourcery.com (Jeffrey Oldham)
Date: Wed, 23 Jan 2002 21:18:51 -0800
Subject: Manual: Wordsmithing Changes to First Four Chapters
Message-ID: <20020123211851.A4304@codesourcery.com>

2002-Jan-23  Jeffrey D. Oldham  <oldham at codesourcery.com>

        These changes move the manual toward delivery.  Unfinished
        sections remain in the DocBook source code but are not printed.
        The first two chapters were indexed.  Wordsmithing throughout the
        document (hopefully) improved the exposition.

        * arrays.xml: Wordsmithing.  Finish describing the Domain use
        section.
        * concepts.xml: Wordsmithing.
        * data-parallel.xml: Rewrite "naive".
        * glossary.xml: Add some indexing.
        (stride): Fix definition.
        (template): New definition.
        * introduction.xml: Index.  Wordsmith.
        * manual.xml: Add 'unfinished', 'temporary', and 'naive', and
        'naivecap' entities.  Change names of entities that used capital
        letters.  Write short description of container views.  Comment out
        unfinished sections.
        * template.xml: Index.  s/<</&openopen;/g.  Wordsmith.
        * tutorial.xml: Wordsmith.

Applied to	mainline.
Approved by	Bill Clinton.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.2
diff -c -p -r1.2 arrays.xml
*** arrays.xml	2002/01/22 15:48:49	1.2
--- arrays.xml	2002/01/24 04:56:31
***************
*** 1,3 ****
--- 1,4 ----
+ <!-- FIXME: Index this file. -->
    <chapter id="arrays">
     <title>&array; Containers</title>
  
***************
*** 961,967 ****
       <para>Since an &array; can be queried for its domain, we briefly
       describe some &domain; operations.  A fuller description,
       including arithmetic operations, occur in <xref
!      linkend="views"></xref>.</para>
  
       <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-domains-use-table">
--- 962,973 ----
       <para>Since an &array; can be queried for its domain, we briefly
       describe some &domain; operations.  A fuller description,
       including arithmetic operations, occur in <xref
!      linkend="views"></xref>.  As we mentioned in <xref
!      linkend="arrays-domains-declarations"></xref>, the <filename
!      class="headerfile">Pooma/Domains.h</filename> header file
!      declares &domain;s, but most container header files automatically
!      include <filename class="headerfile">Pooma/Domains.h</filename>
!      so no explicit inclusion of is usually necessary.</para>
  
       <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-domains-use-table">
***************
*** 976,983 ****
         </thead>
         <tfoot>
  	<row>
! 	 <entry>Other &domain; accessors are described in <xref
! 	 linkend="views"></xref>.</entry>
  	</row>
         </tfoot>
         <tbody>
--- 982,990 ----
         </thead>
         <tfoot>
  	<row>
! 	 <entry><type>D</type> abbreviates the particular &domain;
! 	 type, e.g., &interval; or &grid;.  Other &domain; accessors
! 	 are described in <xref linkend="views"></xref>.</entry>
  	</row>
         </tfoot>
         <tbody>
***************
*** 1037,1053 ****
  
       <para>&domain; member functions are listed in <xref
       linkend="arrays-domains-use-table"></xref>.  Functions applicable
!      to one-dimensional and multidimensional &domain;s are listed
       before functions that only applicable to one-dimensional
       &domain;s.  The <methodname>size</methodname> member function
       yields the total number of indices in a given &domain;.  If and
       only if this number is zero, <methodname>empty</methodname> will
       yield &true;.  A multidimensional
       <type>domain&lt;&dim;&gt;</type> is the direct product of &dim;
!      one-dimensional &domain;s.
! 
! HERE</para>
!    </section>
     </section>
  
  
--- 1044,1087 ----
  
       <para>&domain; member functions are listed in <xref
       linkend="arrays-domains-use-table"></xref>.  Functions applicable
!      to both one-dimensional and multidimensional &domain;s are listed
       before functions that only applicable to one-dimensional
       &domain;s.  The <methodname>size</methodname> member function
       yields the total number of indices in a given &domain;.  If and
       only if this number is zero, <methodname>empty</methodname> will
       yield &true;.  A multidimensional
       <type>domain&lt;&dim;&gt;</type> is the direct product of &dim;
!      one-dimensional &domain;s.  The <methodname>operator[](int
!      dimension)</methodname> operator extracts the one-dimensional
!      &domain; corresponding to its parameter.  For example, the three
!      <type>Range&lt;1&gt;</type> (one-dimensional) &domain;s can be
!      extracted from a <type>Range&lt;3&gt;</type>
!      object&nbsp;<varname>r</varname> using
!      <statement>r[0]</statement>, <statement>r[1]</statement>, and
!      <statement>r[2]</statement>.</para>
! 
!      <para>&domain; accessors applicable only to one-dimensional
!      &domain;s are listed in the second half of <xref
!      linkend="arrays-domains-use-table"></xref>.  The
!      <methodname>length</methodname> member function, analogous to the
!      multidimensional <methodname>size</methodname> function, returns
!      the number of indices in the &domain;.  The
!      <methodname>first</methodname> and <methodname>last</methodname>
!      member functions return the domain's beginning and ending
!      indices.  The <methodname>begin</methodname> and
!      <methodname>end</methodname> member functions return input
!      iterators pointing to these respective locations.  They have type
!      <type>D&lt;1&gt;::iterator</type>, where <type>D</type>
!      abbreviates the &domain;'s type, e.g., &interval; or &grid;.
!      <!-- FIXME: Do I need to explain input iterators and their use?
!      --> The <methodname>min</methodname> and
!      <methodname>max</methodname> member functions return the minimum
!      and maximum indices in the &domain; object, respectively.  For
!      &locone; and &intervalone;, these are the same as
!      <methodname>first</methodname> and <methodname>last</methodname>,
!      but &rangeone; and &gridone; can have their largest index at the
!      beginning of their &domain;s.</para>
!     </section>
     </section>
  
  
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1814,1820 ****
  
  
     <section id="arrays-dynamic_arrays">
!     <title>&dynamicarray;s: Dynamically Changing Domain Sizes</title>
  
      <para>&array;s have fixed domains so the set of valid indices
      remains fixed after declaration.  The &dynamicarray; class
--- 1848,1854 ----
  
  
     <section id="arrays-dynamic_arrays">
!     <title>&dynamicarray;s</title>
  
      <para>&array;s have fixed domains so the set of valid indices
      remains fixed after declaration.  The &dynamicarray; class
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.7
diff -c -p -r1.7 concepts.xml
*** concepts.xml	2002/01/22 15:48:49	1.7
--- concepts.xml	2002/01/24 04:56:32
***************
*** 1,3 ****
--- 1,4 ----
+ <!-- FIXME: Index this file. -->
  <chapter id="concepts">
   <title>Overview of &pooma; Concepts</title>
  
***************
*** 13,22 ****
   separate categories:
   <variablelist>
    <varlistentry>
!     <term>container</term>
      <listitem>
!      <para>data structure holding one or more values and usually addressed
!      by indices</para>
      </listitem>
     </varlistentry>
     <varlistentry>
--- 14,23 ----
   separate categories:
   <variablelist>
    <varlistentry>
!     <term>containers</term>
      <listitem>
!      <para>data structures holding one or more values and usually accessed
!      using indices</para>
      </listitem>
     </varlistentry>
     <varlistentry>
***************
*** 34,41 ****
      </listitem>
     </varlistentry>
    </variablelist>
!   See <xref linkend="concepts-table"></xref>.  Many &pooma; programs
!   select one possibility from each column.  For example, <xref
    linkend="tutorial-array_stencil-doof2d"></xref> used &array;
    containers and stencils for sequential computation, while <xref
    linkend="tutorial-field_distributed-doof2d"></xref> used &field;
--- 35,43 ----
      </listitem>
     </varlistentry>
    </variablelist>
!   <xref linkend="concepts-table"></xref> categorizes the &pooma;
!   concepts.  Many &pooma; programs select one possibility from each
!   category.  For example, <xref
    linkend="tutorial-array_stencil-doof2d"></xref> used &array;
    containers and stencils for sequential computation, while <xref
    linkend="tutorial-field_distributed-doof2d"></xref> used &field;
***************
*** 103,115 ****
    <para>Most &pooma; programs use <firstterm>containers</firstterm> to
    store groups of values.  &pooma; containers are objects that store
    other objects such as numbers or vectors.  They control allocation
!   and deallocation of and access to these stored objects.  They are a
!   generalization of &c; arrays, but &pooma; containers are first-class
!   objects so they can be used directly in expressions.  They are
!   similar to &cc; containers such as <type>vector</type>,
!   <type>list</type>, and <type>stack</type>.  See <xref
!   linkend="concepts-containers-table"></xref> for a summary of the
!   containers.</para>
  
    <para>This section describes many concepts, but one need not
    understand them all to begin programming with the &poomatoolkit;.
--- 105,117 ----
    <para>Most &pooma; programs use <firstterm>containers</firstterm> to
    store groups of values.  &pooma; containers are objects that store
    other objects such as numbers or vectors.  They control allocation
!   and deallocation of these stored objects and access to them.  They
!   are a generalization of &c; arrays, but &pooma; containers are
!   first-class objects so they can be used directly in expressions.
!   They are also similar to &cc; containers such as
!   <type>vector</type>, <type>list</type>, and <type>stack</type>.  See
!   <xref linkend="concepts-containers-table"></xref> for a summary of
!   the containers.</para>
  
    <para>This section describes many concepts, but one need not
    understand them all to begin programming with the &poomatoolkit;.
***************
*** 126,131 ****
--- 128,137 ----
    multiple processors.  The programs in the previous chapter
    illustrate many of these concepts.</para>
  
+   <para><xref linkend="concepts-containers-table"></xref> briefly
+   describes the six &pooma; containers.  They are more fully described
+   in the paragraphs below.</para>
+ 
    <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="concepts-containers-table">
     <title>&pooma; Container Summary</title>
***************
*** 201,210 ****
    to &array;s, each cell may contain multiple values and multiple
    materials.  A &field;'s <glossterm
    linkend="glossary-mesh">mesh</glossterm> stores its spatial
!   characteristics and can map yield, e.g., the cell at a particular
!   point, the distance between two cells, or a cell's normals.  A
!   &field; should be used whenever geometric or spatial computations
!   are needed, multiple values per index are desired, or a computation
    involves more than one material.</para>
  
  <!-- FIXME: Want firstterm around tensor. -->
--- 207,216 ----
    to &array;s, each cell may contain multiple values and multiple
    materials.  A &field;'s <glossterm
    linkend="glossary-mesh">mesh</glossterm> stores its spatial
!   characteristics and can yield, e.g., the cell at a particular point,
!   the distance between two cells, or a cell's normals.  A &field;
!   should be used whenever geometric or spatial computations are
!   needed, multiple values per index are desired, or a computation
    involves more than one material.</para>
  
  <!-- FIXME: Want firstterm around tensor. -->
***************
*** 230,254 ****
    multiplying a &matrix; and a &vector;.</para>
  
    <para>The data of an &array;, &dynamicarray;, or &field; can be
!   viewed using more than one container by taking a view.  A <glossterm
    linkend="glossary-view"><firstterm>view</firstterm></glossterm> of
    an existing container&nbsp;&container; is a container whose domain
!   is a subset of&nbsp;&container;.  The subset can equal the original
!   domain.  A view acts like a reference in that changing any of the
!   view's values also changes the original container's and vice versa.
!   While users sometimes explicitly create views, they are perhaps more
!   frequently created as temporaries in expressions.  For example, if
!   <varname>A</varname> is an &array; and <varname>I</varname> is a
!   domain, <statement>A(I) - A(I-1)</statement> uses two views to form
!   the difference between adjacent values.</para>
  
  
    <section id="concepts-containers-choosing">
     <title>Choosing a Container</title>
  
     <para>The two most commonly used &pooma; containers are &array;s
!    and &field;s, while &vector;, &matrix;, or &tensor; frequently
!    represent mathematical objects.  <xref
     linkend="concepts-containers-choice_table"></xref> contains a
     decision tree describing how to choose an appropriate
     container.</para>
--- 236,262 ----
    multiplying a &matrix; and a &vector;.</para>
  
    <para>The data of an &array;, &dynamicarray;, or &field; can be
!   accessed using more than one container by taking a view.  A
!   <glossterm
    linkend="glossary-view"><firstterm>view</firstterm></glossterm> of
    an existing container&nbsp;&container; is a container whose domain
!   is a subset of&nbsp;&container;'s domain.  The subset can equal the
!   original domain.  A view acts like a reference in that changing any
!   of the view's values also changes the original container's and vice
!   versa.  While users sometimes explicitly create views, they are
!   perhaps more frequently created as temporaries in expressions.  For
!   example, if <varname>A</varname> is an &array; and
!   <varname>I</varname> is a domain, <statement>A(I) -
!   A(I-1)</statement> uses two views to form the difference between
!   adjacent values.</para>
  
  
    <section id="concepts-containers-choosing">
     <title>Choosing a Container</title>
  
     <para>The two most commonly used &pooma; containers are &array;s
!    and &field;s, while &vector;, &matrix;, and &tensor; represent
!    mathematical objects.  <xref
     linkend="concepts-containers-choice_table"></xref> contains a
     decision tree describing how to choose an appropriate
     container.</para>
***************
*** 299,304 ****
--- 307,324 ----
     in declaring them.  Concepts specific to distributed computation
     are described in the next section.</para>
  
+    <para><xref
+    linkend="concepts-sequential_containers-declarations-dependences"></xref>
+    illustrates the containers and the concepts involved in their
+    declarations.  The containers are listed in the top row.  Lines
+    connect these containers to the components necessary for their
+    declarations.  For example, an &array; declaration requires an
+    engine and a layout.  These, in turn, can depend on other &pooma;
+    concepts.  Declarations necessary only for distributed, or
+    multiprocessor, computation are also indicated.  Given a desired
+    container, one can use this figure to determine the concepts needed
+    to declare a particular container.</para>
+ 
     <figure float="1" id="concepts-sequential_containers-declarations-dependences">
      <title>Concepts For Declaring Containers</title>
      <mediaobject>
***************
*** 311,328 ****
      </mediaobject>
     </figure>
  
-    <para><xref
-    linkend="concepts-sequential_containers-declarations-dependences"></xref>
-    illustrates the containers and the concepts involved in their
-    declarations.  The containers are listed in the top row.  Lines
-    connect these containers to the components necessary for their
-    declarations.  For example, an &array; declaration requires an
-    &engine; and a layout.  These, in turn, can depend on other &pooma;
-    concepts.  Declarations necessary only for distributed, or
-    multiprocessor, computation are surrounded by dashed lines.  These
-    dependences to indicate the concepts needed for a particular
-    container.</para>
- 
     <para>An <glossterm
     linkend="glossary-engine"><firstterm>engine</firstterm></glossterm>
     stores and, if necessary, computes a container's values.  A
--- 331,336 ----
***************
*** 332,338 ****
     for all indices can use a constant engine, which need only store
     one value for the entire domain.  A &compressiblebrick; &engine;
     reduces its space requirements to a constant whenever all its
!    values are the same.  The separation also permits taking <link
     linkend="glossary-view">view</link>s of containers without copying
     storage.</para>
  
--- 340,347 ----
     for all indices can use a constant engine, which need only store
     one value for the entire domain.  A &compressiblebrick; &engine;
     reduces its space requirements to a constant whenever all its
!    values are the same.  The separation between a container and its
!    engine also permits taking <link
     linkend="glossary-view">view</link>s of containers without copying
     storage.</para>
  
***************
*** 350,360 ****
  
     <para>A <glossterm
     linkend="glossary-layout"><firstterm>layout</firstterm></glossterm>
!    maps <link linkend="glossary-domain">domain</link> <glossterm linkend="glossary-index">indices</glossterm> to the
!    processors and computer memory used by a container's engines.  See
!    <xref
     linkend="concepts-containers-declarations-computational_implementation"></xref>.
!    A program computes a container's values using a processor and
     memory.  The layout specifies the processors and memory to use for
     each particular index.  A container's layout for a uniprocessor
     implementation consists of its domain, the processor, and its
--- 359,369 ----
  
     <para>A <glossterm
     linkend="glossary-layout"><firstterm>layout</firstterm></glossterm>
!    maps <link linkend="glossary-domain">domain</link> <glossterm
!    linkend="glossary-index">indices</glossterm> to the processors and
!    computer memory used by a container's engines.  See <xref
     linkend="concepts-containers-declarations-computational_implementation"></xref>.
!    A program computes a container's values using these processors and
     memory.  The layout specifies the processors and memory to use for
     each particular index.  A container's layout for a uniprocessor
     implementation consists of its domain, the processor, and its
***************
*** 378,388 ****
     interval [0,n).  A domain need not contain all integral points
     between its endpoints.  A <glossterm
     linkend="glossary-stride"><firstterm>stride</firstterm></glossterm>
!    is a subset of an interval consisting of regularly-spaced points.
!    A <glossterm
     linkend="glossary-range"><firstterm>range</firstterm></glossterm>
     is a subset of an interval of regularly-spaced points specified by
!    strides.</para>
  
     <para>A &field;'s <glossterm
     linkend="glossary-mesh"><firstterm>mesh</firstterm></glossterm>
--- 387,396 ----
     interval [0,n).  A domain need not contain all integral points
     between its endpoints.  A <glossterm
     linkend="glossary-stride"><firstterm>stride</firstterm></glossterm>
!    indicates a regular spacing between points.  A <glossterm
     linkend="glossary-range"><firstterm>range</firstterm></glossterm>
     is a subset of an interval of regularly-spaced points specified by
!    a stride.</para>
  
     <para>A &field;'s <glossterm
     linkend="glossary-mesh"><firstterm>mesh</firstterm></glossterm>
***************
*** 399,422 ****
     linkend="glossary-point">point</link> in &space; corresponding to
     the cell in the lower, left corner of its <link
     linkend="glossary-domain">domain</link>.  Combining this, the
!    domain, and the cell size fully specifies the mesh's map from
!    indices to &space;.</para>
  
     <para>A mesh's <glossterm
     linkend="glossary-cell_size"><firstterm>cell
!    size</firstterm></glossterm> specifies the spatial dimensions of
!    a &field; <link linkend="glossary-cell">cell</link>, e.g., its
!    width, height, and depth, in&nbsp;&space;.  Combining this, the
!    domain, and the corner position fully specifies the mesh's map
!    from indices to &space;.</para>
    </section>
  
  
    <section id="concepts-containers-distributed_declarations">
     <title>Declaring Distributed Containers</title>
  
!    <para>In the previous section, we introduced the concepts important
!    when declaring containers for use on uniprocessor computers.  When
     using multiprocessor computers, we augment these concepts with
     those for distributed computation.  Reading this section is
     important only for running a program on multiple processors.  Many
--- 407,430 ----
     linkend="glossary-point">point</link> in &space; corresponding to
     the cell in the lower, left corner of its <link
     linkend="glossary-domain">domain</link>.  Combining this, the
!    domain, and the cell size can specify the mesh's map from indices
!    to &space;.</para>
  
     <para>A mesh's <glossterm
     linkend="glossary-cell_size"><firstterm>cell
!    size</firstterm></glossterm> specifies the spatial dimensions of a
!    &field; <link linkend="glossary-cell">cell</link>, e.g., its width,
!    height, and depth, in&nbsp;&space;.  Combining this, the domain,
!    and the corner position can specify the mesh's map from indices to
!    &space;.</para>
    </section>
  
  
    <section id="concepts-containers-distributed_declarations">
     <title>Declaring Distributed Containers</title>
  
!    <para>In the previous section, we introduced the important concepts
!    for declaring containers for use on uniprocessor computers.  When
     using multiprocessor computers, we augment these concepts with
     those for distributed computation.  Reading this section is
     important only for running a program on multiple processors.  Many
***************
*** 457,463 ****
     linkend="glossary-external_guard_layer"><firstterm>external guard
     layer</firstterm></glossterm> specifies values surrounding the
     entire domain.  Its presence eases computation along the domain's
!    edges by permitting the same computations as for more internal
     computations.  An <glossterm
     linkend="glossary-internal_guard_layer"><firstterm>internal guard
     layer</firstterm></glossterm> duplicates values from adjacent
--- 465,471 ----
     linkend="glossary-external_guard_layer"><firstterm>external guard
     layer</firstterm></glossterm> specifies values surrounding the
     entire domain.  Its presence eases computation along the domain's
!    edges by permitting the same computations as for more-internal
     computations.  An <glossterm
     linkend="glossary-internal_guard_layer"><firstterm>internal guard
     layer</firstterm></glossterm> duplicates values from adjacent
***************
*** 488,503 ****
  
    <para>&pooma; computations can be expressed using a variety of
    modes.  Many &pooma; computations involve &array; or &field;
!   containers, but how their values are accessed and the associated
!   algorithms using them varies.  For example, element-wise computation
    involves explicitly accessing a container's values.  A data-parallel
!   computation uses expressions to represent larger subsets of a
!   container's values.  Stencil-based computations express a
!   computation as repeatedly applying a local computation to each
!   element of an array.  A relation among containers establishes a
!   dependency among them so the values of one container are updated
!   whenever any other's values change.  A program may use any or all of
!   these styles, which are described below.</para>
  
    <para><glossterm
    linkend="glossary-element_wise"><firstterm>Element-wise</firstterm></glossterm>
--- 496,511 ----
  
    <para>&pooma; computations can be expressed using a variety of
    modes.  Many &pooma; computations involve &array; or &field;
!   containers, but how their values are accessed and how the associated
!   algorithms use them varies.  For example, element-wise computation
    involves explicitly accessing a container's values.  A data-parallel
!   computation operates on larger subsets of a container's values.
!   Stencil-based computations express a computation as repeatedly
!   applying a local computation to each element of an array.  A
!   relation among containers establishes a dependency among them so the
!   values of one container are updated whenever any other's values
!   change.  A program may use any or all of these styles, which are
!   described below.</para>
  
    <para><glossterm
    linkend="glossary-element_wise"><firstterm>Element-wise</firstterm></glossterm>
***************
*** 515,524 ****
    linkend="tutorial-array_parallel-doof2d"></xref>,
    <statement>a(I,J)</statement> represents the subset of &array;
    <varname>a</varname>'s values having coordinates in the domain
!   specified by the one-dimensional &interval;s <varname>I</varname>
!   and <varname>J</varname>.  Using data-parallel expressions
!   frequently eliminates the need for writing explicit loops in
!   code.</para>
  
    <para>A <glossterm
    linkend="glossary-stencil"><firstterm>stencil</firstterm></glossterm>
--- 523,532 ----
    linkend="tutorial-array_parallel-doof2d"></xref>,
    <statement>a(I,J)</statement> represents the subset of &array;
    <varname>a</varname>'s values having coordinates in the domain
!   specified by the direct product of one-dimensional &interval;s
!   <varname>I</varname> and&nbsp;<varname>J</varname>.  Using
!   data-parallel expressions frequently eliminates the need for writing
!   explicit loops.</para>
  
    <para>A <glossterm
    linkend="glossary-stencil"><firstterm>stencil</firstterm></glossterm>
***************
*** 550,557 ****
   <section id="concepts-computation_environment">
    <title>Computation Environment</title>
  
!   <para>A &pooma; program can execute on a wide variety of computers.
!    The default <glossterm
     linkend="glossary-sequential"><firstterm>sequential computing
     environment</firstterm></glossterm> consists of one processor and
     its associated memory, as found on a personal computer.  In
--- 558,565 ----
   <section id="concepts-computation_environment">
    <title>Computation Environment</title>
  
!   <para>The same &pooma; program can execute on a wide variety of
!    computers.  The default <glossterm
     linkend="glossary-sequential"><firstterm>sequential computing
     environment</firstterm></glossterm> consists of one processor and
     its associated memory, as found on a personal computer.  In
***************
*** 574,580 ****
        library.</para>
       </listitem>
       <listitem>
!       <para>The &pooma; executable must be run using the library.</para>
      </listitem>
     </orderedlist>
     All of these were illustrated in <xref
--- 582,589 ----
        library.</para>
       </listitem>
       <listitem>
!       <para>The &pooma; executable must be run using the
!       communications library.</para>
      </listitem>
     </orderedlist>
     All of these were illustrated in <xref
***************
*** 611,619 ****
     contexts, all of which is hidden from both the programmer and the
     user.  &pooma; works with the Message Passing Interface (&mpi;)
     Communications Library 
! <!-- FIXME: xref linkend="mpi99" -->
!    (<ulink url="http://www-unix.mcs.anl.gov/mpi/"></ulink>) and the &mm;
!    Shared Memory Library.  See <xref
!    linkend="installation-distributed_computing"></xref> for details.</para>
    </section>
  </chapter>
--- 620,628 ----
     contexts, all of which is hidden from both the programmer and the
     user.  &pooma; works with the Message Passing Interface (&mpi;)
     Communications Library 
! <!-- FIXME: xref linkend="mpi99" (<ulink url="http://www-unix.mcs.anl.gov/mpi/"></ulink>) -->
!    and the &mm; Shared Memory Library.  See <xref
!    linkend="installation-distributed_computing"></xref> for
!    details.</para>
    </section>
  </chapter>
Index: data-parallel.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/data-parallel.xml,v
retrieving revision 1.1
diff -c -p -r1.1 data-parallel.xml
*** data-parallel.xml	2002/01/14 17:33:33	1.1
--- data-parallel.xml	2002/01/24 04:56:34
***************
*** 14,20 ****
  
     <para>After introducing data-parallel expressions and statements,
     we present the corresponding &pooma; syntax.  Then we present its
!    implementation, which uses expression-template technology.  A naive
     data-parallel implementation might generate temporary variables,
     cluttering a program's inner loops and slowing its execution.
     Instead, &pooma; uses &pete, the Portable Expression Template
--- 14,20 ----
  
     <para>After introducing data-parallel expressions and statements,
     we present the corresponding &pooma; syntax.  Then we present its
!    implementation, which uses expression-template technology.  A &naive;
     data-parallel implementation might generate temporary variables,
     cluttering a program's inner loops and slowing its execution.
     Instead, &pooma; uses &pete, the Portable Expression Template
***************
*** 51,57 ****
      height&nbsp;h and to an entire field of particles with
      masses&nbsp;m and heights&nbsp;h.  Our algorithm works with
      data-parallel syntax, and we would like to write the corresponding
!     computer program using data-parallel syntax as well..</para>
     </section>
  
  
--- 51,57 ----
      height&nbsp;h and to an entire field of particles with
      masses&nbsp;m and heights&nbsp;h.  Our algorithm works with
      data-parallel syntax, and we would like to write the corresponding
!     computer program using data-parallel syntax as well.</para>
     </section>
  
  
*************** std::cout << A-B << std::endl;
*** 881,887 ****
  
      <para>Data-parallel statements involving containers occur
      frequently in the inner loops of scientific programs so their
!     efficient execution is important.  A naive implementation for
      these statements may create and destroy containers holding
      intermediate values, slowing execution considerably.
      In&nbsp;1995, Todd <!-- FIXME: Add citations to vandevoorde-95 and
--- 881,887 ----
  
      <para>Data-parallel statements involving containers occur
      frequently in the inner loops of scientific programs so their
!     efficient execution is important.  A &naive; implementation for
      these statements may create and destroy containers holding
      intermediate values, slowing execution considerably.
      In&nbsp;1995, Todd <!-- FIXME: Add citations to vandevoorde-95 and
*************** std::cout << A-B << std::endl;
*** 894,900 ****
      framework, is also available separately from &pooma; at
      <ulink url="http://www.acl.lanl.gov/pete/"></ulink>.</para>
  
!     <para>In this section, we first describe how a naive
      implementation may slow execution.  Then, we describe &pete;'s
      faster implementation.  A data-parallel statement is converted
      into a parse tree, rather than immediately evaluating it.  The
--- 894,900 ----
      framework, is also available separately from &pooma; at
      <ulink url="http://www.acl.lanl.gov/pete/"></ulink>.</para>
  
!     <para>In this section, we first describe how a &naive;
      implementation may slow execution.  Then, we describe &pete;'s
      faster implementation.  A data-parallel statement is converted
      into a parse tree, rather than immediately evaluating it.  The
*************** std::cout << A-B << std::endl;
*** 909,918 ****
      types are traversed and code is produced without the need for any
      intermediate values.  We present the implementation in <xref
  								 linkend="data_parallel-implementation-pete"></xref>, but first we
!     explain the difficulties caused by the naive implementation.</para>
  
      <section id="data_parallel-implementation-naive">
!      <title>Naive Implementation</title>
  
       <para>A conventional implementation to evaluate data-parallel
       expressions might overload arithmetic operator functions.
--- 909,918 ----
      types are traversed and code is produced without the need for any
      intermediate values.  We present the implementation in <xref
  								 linkend="data_parallel-implementation-pete"></xref>, but first we
!     explain the difficulties caused by the &naive; implementation.</para>
  
      <section id="data_parallel-implementation-naive">
!      <title>&naivecap; Implementation</title>
  
       <para>A conventional implementation to evaluate data-parallel
       expressions might overload arithmetic operator functions.
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.7
diff -c -p -r1.7 glossary.xml
*** glossary.xml	2002/01/22 15:48:49	1.7
--- glossary.xml	2002/01/24 04:56:35
***************
*** 99,105 ****
    <glossentry id="glossary-compile_time">
     <glossterm>compile time</glossterm>
     <glossdef>
!     <para>time in the process from writing a program to executing it
      when the program is compiled by a compiler.  This is also called
      <firstterm>compilation time</firstterm>.</para>
      <glossseealso otherterm="glossary-programming_time">programming time</glossseealso>
--- 99,113 ----
    <glossentry id="glossary-compile_time">
     <glossterm>compile time</glossterm>
     <glossdef>
!     <para>
!     <indexterm zone="glossary-compile_time">
!      <primary>compile time</primary>
!     </indexterm>
!     <indexterm>
!      <primary>compilation time</primary>
!      <see>compile time.</see>
!     </indexterm>
!     in the process from writing a program to executing it, the time
      when the program is compiled by a compiler.  This is also called
      <firstterm>compilation time</firstterm>.</para>
      <glossseealso otherterm="glossary-programming_time">programming time</glossseealso>
***************
*** 306,316 ****
     </glossdef>
    </glossentry>
  
- <!-- HERE -->
    <glossentry id="glossary-enumeration">
     <glossterm>enumeration</glossterm>
     <glossdef>
!     <para>distinct &cc; integral type with named constants.  These are
      frequently used in template programming because they can be used
      as template arguments.</para>
     </glossdef>
--- 314,327 ----
     </glossdef>
    </glossentry>
  
    <glossentry id="glossary-enumeration">
     <glossterm>enumeration</glossterm>
     <glossdef>
!     <para>
!     <indexterm zone="glossary-enumeration">
!      <primary>enumeration</primary>
!     </indexterm>
!     &cc; integral type with named constants.  These are
      frequently used in template programming because they can be used
      as template arguments.</para>
     </glossdef>
***************
*** 324,330 ****
    <glossentry id="glossary-external_guard_layer">
     <glossterm>external guard layer</glossterm>
     <glossdef>
!     <para><link linkend="glossary-guard_layer">guard layer</link>
      surrounding a container's domain used to ease computation along
      the domain's edges by permitting the same computations as for
      more internal computations.  It is an optimization, not required
--- 335,350 ----
    <glossentry id="glossary-external_guard_layer">
     <glossterm>external guard layer</glossterm>
     <glossdef>
!     <para>
!      <indexterm zone="glossary-external_guard_layer">
!       <primary>guard layer</primary>
!       <secondary>external</secondary>
!      </indexterm>
!      <indexterm>
!       <primary>external guard layer</primary>
!       <see>guard layer, external.</see> 
!      </indexterm>
!     <link linkend="glossary-guard_layer">guard layer</link>
      surrounding a container's domain used to ease computation along
      the domain's edges by permitting the same computations as for
      more internal computations.  It is an optimization, not required
***************
*** 382,394 ****
    <glossentry id="glossary-function_template">
     <glossterm>function template</glossterm>
     <glossdef>
!     <para>a definition of an unbounded set of related functions, all
!     having the same name but whose parameter types can depend on
!     template parameters.  They are particularly useful when
!     overloading <glossterm
!     linkend="glossary-operator_function">operator
!     functions</glossterm> to accept parameters that themselves depend
!     on templates.</para>
     </glossdef>
    </glossentry>
   </glossdiv>
--- 402,434 ----
    <glossentry id="glossary-function_template">
     <glossterm>function template</glossterm>
     <glossdef>
!     <para>
!     <indexterm zone="glossary-function_template">
!      <primary>function</primary>
!      <secondary>template</secondary>
!     </indexterm>
!     a definition of an unbounded set of related functions, all having
!     the same name but whose types can depend on template parameters.
!     They are particularly useful when overloading
!     <indexterm>
!      <primary>overloaded function</primary>
!      <see>function, overloaded.</see>
!     </indexterm>
!     <indexterm>
!      <primary>function</primary>
!      <secondary>overloaded</secondary>
!     </indexterm>
!     <glossterm linkend="glossary-operator_function">operator
!     functions</glossterm>
!     <indexterm>
!      <primary>operator function</primary>
!      <see>function, operator.</see>
!     </indexterm>
!     <indexterm>
!      <primary>function</primary>
!      <secondary>operator</secondary>
!     </indexterm>
!     to accept parameters that themselves depend on templates.</para>
     </glossdef>
    </glossentry>
   </glossdiv>
***************
*** 399,417 ****
    <glossentry id="glossary-guard_layer">
     <glossterm>guard layer</glossterm>
     <glossdef>
!     <para>domain surrounding each patch of a container's domain.  It
      contains read-only values.  <link
      linkend="glossary-external_guard_layer">External guard
      layer</link>s ease programming, while <link
      linkend="glossary-internal_guard_layer">internal guard
      layer</link>s permit each patch's computation to be occur without
      copying values from adjacent patches.  They are optimizations, not
!     required for program correctness.</para> <glossseealso
!     otherterm="glossary-external_guard_layer">external guard
!     layer</glossseealso> <glossseealso
!     otherterm="glossary-internal_guard_layer">internal guard
!     layer</glossseealso> <glossseealso
!     otherterm="glossary-partition">partition</glossseealso>
      <glossseealso otherterm="glossary-patch">patch</glossseealso>
      <glossseealso otherterm="glossary-domain">domain</glossseealso>
     </glossdef>
--- 439,460 ----
    <glossentry id="glossary-guard_layer">
     <glossterm>guard layer</glossterm>
     <glossdef>
!     <para>
!      <indexterm zone="glossary-guard_layer">
!       <primary>guard layer</primary>
!      </indexterm>
!     domain surrounding each patch of a container's domain.  It
      contains read-only values.  <link
      linkend="glossary-external_guard_layer">External guard
      layer</link>s ease programming, while <link
      linkend="glossary-internal_guard_layer">internal guard
      layer</link>s permit each patch's computation to be occur without
      copying values from adjacent patches.  They are optimizations, not
!     required for program correctness.</para>
!     <glossseealso otherterm="glossary-external_guard_layer">external guard layer</glossseealso>
!     <glossseealso otherterm="glossary-internal_guard_layer">internal
! guard layer</glossseealso>
!     <glossseealso otherterm="glossary-partition">partition</glossseealso>
      <glossseealso otherterm="glossary-patch">patch</glossseealso>
      <glossseealso otherterm="glossary-domain">domain</glossseealso>
     </glossdef>
***************
*** 448,454 ****
    <glossentry id="glossary-internal_guard_layer">
     <glossterm>internal guard layer</glossterm>
     <glossdef>
!     <para><link linkend="glossary-guard_layer">guard layer</link>
      containing copies of adjacent patches' values.  These copies can
      permit an individual patch's computation to occur without asking
      adjacent patches for values.  This can speed computation but are
--- 491,506 ----
    <glossentry id="glossary-internal_guard_layer">
     <glossterm>internal guard layer</glossterm>
     <glossdef>
!     <para>
!      <indexterm zone="glossary-internal_guard_layer">
!       <primary>guard layer</primary>
!       <secondary>internal</secondary>
!      </indexterm>
!      <indexterm>
!       <primary>internal guard layer</primary>
!       <see>guard layer, internal.</see> 
!      </indexterm>
!     <link linkend="glossary-guard_layer">guard layer</link>
      containing copies of adjacent patches' values.  These copies can
      permit an individual patch's computation to occur without asking
      adjacent patches for values.  This can speed computation but are
***************
*** 498,503 ****
--- 550,560 ----
   <glossdiv id="glossary-m">
    <title>M</title>
  
+   <glossentry id="glossary-real_matrix">
+    <glossterm>matrix</glossterm>
+    <glosssee otherterm="glossary-matrix"></glosssee>
+   </glossentry>
+ 
    <glossentry id="glossary-mesh">
     <glossterm>mesh</glossterm>
     <glossdef>
***************
*** 516,524 ****
    <glossentry id="glossary-operator_function">
     <glossterm>operator function</glossterm>
     <glossdef>
!     <para>function defining an operator's code.  For example,
!     <function>operator+</function> defines the result of using the
!     <operator>+</operator>.</para>
     </glossdef>
    </glossentry>
   </glossdiv>
--- 573,586 ----
    <glossentry id="glossary-operator_function">
     <glossterm>operator function</glossterm>
     <glossdef>
!     <para>
!      <indexterm zone="glossary-operator_function">
!       <primary>function</primary>
!       <secondary>operator</secondary>
!      </indexterm>
!     function defining a function invoked using a &cc; operator.  For
!     example, the <function>operator+</function> function defines the
!     result of using the <operator>+</operator>.</para>
     </glossdef>
    </glossentry>
   </glossdiv>
***************
*** 545,551 ****
    <glossentry id="glossary-patch">
     <glossterm>patch</glossterm>
     <glossdef>
!     <para>subset of a container's domain with values computed by a
      particular context.  A partition splits a domain into patches.  It
      may be surrounded by external and internal guard layers.</para>
      <glossseealso otherterm="glossary-partition">partition</glossseealso>
--- 607,617 ----
    <glossentry id="glossary-patch">
     <glossterm>patch</glossterm>
     <glossdef>
!     <para>
!      <indexterm zone="glossary-patch">
!       <primary>patch</primary>
!      </indexterm>
!     subset of a container's domain with values computed by a
      particular context.  A partition splits a domain into patches.  It
      may be surrounded by external and internal guard layers.</para>
      <glossseealso otherterm="glossary-partition">partition</glossseealso>
***************
*** 568,574 ****
    <glossentry id="glossary-programming_time">
     <glossterm>programming time</glossterm>
     <glossdef>
!     <para>time in the process from writing a program to executing it
      when the program is being written by a programmer.</para>
      <glossseealso otherterm="glossary-compile_time">compile time</glossseealso>
      <glossseealso otherterm="glossary-run_time">run time</glossseealso>
--- 634,644 ----
    <glossentry id="glossary-programming_time">
     <glossterm>programming time</glossterm>
     <glossdef>
!     <para>
!     <indexterm zone="glossary-programming_time">
!      <primary>programming time</primary>
!     </indexterm>
!     in the process from writing a program to executing it, the time
      when the program is being written by a programmer.</para>
      <glossseealso otherterm="glossary-compile_time">compile time</glossseealso>
      <glossseealso otherterm="glossary-run_time">run time</glossseealso>
***************
*** 613,619 ****
    <glossentry id="glossary-run_time">
     <glossterm>run time</glossterm>
     <glossdef>
!     <para>time in the process from writing a program to executing it
      when the program is executed.  This is also called
      <firstterm>execution time</firstterm>.</para>
      <glossseealso otherterm="glossary-compile_time">compile time</glossseealso>
--- 683,697 ----
    <glossentry id="glossary-run_time">
     <glossterm>run time</glossterm>
     <glossdef>
!     <para>
!     <indexterm zone="glossary-run_time">
!      <primary>run time</primary>
!     </indexterm>
!     <indexterm>
!      <primary>execution time</primary>
!      <see>run time.</see>
!     </indexterm>
!     in the process from writing a program to executing it, the time
      when the program is executed.  This is also called
      <firstterm>execution time</firstterm>.</para>
      <glossseealso otherterm="glossary-compile_time">compile time</glossseealso>
***************
*** 654,665 ****
    <glossentry id="glossary-stride">
     <glossterm>stride</glossterm>
     <glossdef>
!     <para>a subset of regularly-spaced points in an integral
!     interval.  For example, the set of points a, a+2, a+4, &hellip;,
!     b-2, b is specified by [a,b] with stride&nbsp;2.  It is a
!     domain.</para>
      <glossseealso otherterm="glossary-range">range</glossseealso>
!     <glossseealso otherterm="glossary-interval">interval</glossseealso>
      <glossseealso otherterm="glossary-domain">domain</glossseealso>
     </glossdef>
    </glossentry>
--- 732,743 ----
    <glossentry id="glossary-stride">
     <glossterm>stride</glossterm>
     <glossdef>
!     <para>spacing between regularly-spaced points in a domain.  For
!     example, the set of points a, a+2, a+4, &hellip;, b-2, b is
!     specified by [a,b] with stride&nbsp;2.  It is a domain.</para>
      <glossseealso otherterm="glossary-range">range</glossseealso>
!     <glossseealso
!     otherterm="glossary-interval">interval</glossseealso>
      <glossseealso otherterm="glossary-domain">domain</glossseealso>
     </glossdef>
    </glossentry>
***************
*** 681,690 ****
   <glossdiv id="glossary-t">
    <title>T</title>
  
    <glossentry id="glossary-template_instantiation">
     <glossterm>template instantiation</glossterm>
     <glossdef>
!     <para>applying a template class to template parameters to create a
      type.  For example, <statement>foo&lt;double,3&gt;</statement>
      instantiates <statement>template &lt;typename T, int n&gt; class
      foo</statement> with the type &double; and the constant
--- 759,788 ----
   <glossdiv id="glossary-t">
    <title>T</title>
  
+   <glossentry id="glossary-template">
+    <glossterm>template</glossterm>
+    <glossdef>
+     <para>
+     <indexterm zone="glossary-template">
+      <primary>template</primary>
+     </indexterm>
+     class or function definition having template parameters.
+     These parameters' values are used at compile time, not run time,
+     so they may include types and other compile-time values.
+     <!-- FIXME: Strengthen this definition. --></para>
+     <glossseealso otherterm="glossary-template_instantiation">template instantiation</glossseealso>
+     <glossseealso otherterm="glossary-template_specialization">template specialization</glossseealso>
+    </glossdef>
+   </glossentry>
+ 
    <glossentry id="glossary-template_instantiation">
     <glossterm>template instantiation</glossterm>
     <glossdef>
!     <para>
!     <indexterm zone="glossary-template_instantiation">
!      <primary>template instantiation</primary>
!     </indexterm>
!     applying a template class to template parameter arguments to create a
      type.  For example, <statement>foo&lt;double,3&gt;</statement>
      instantiates <statement>template &lt;typename T, int n&gt; class
      foo</statement> with the type &double; and the constant
***************
*** 696,702 ****
    <glossentry id="glossary-template_specialization">
     <glossterm>template specialization</glossterm>
     <glossdef>
!     <para>class or function definition for a particular (special)
      subset of template arguments.</para>
     </glossdef>
    </glossentry>
--- 794,804 ----
    <glossentry id="glossary-template_specialization">
     <glossterm>template specialization</glossterm>
     <glossdef>
!     <para>
!     <indexterm zone="glossary-template_specialization">
!      <primary>template specialization</primary>
!     </indexterm>
!     class or function definition for a particular (special)
      subset of template arguments.</para>
     </glossdef>
    </glossentry>
***************
*** 724,730 ****
    <glossentry id="glossary-trait">
     <glossterm>trait</glossterm>
     <glossdef>
!     <para>a characteristic of a type.</para>
      <glossseealso otherterm="glossary-traits_class">traits class</glossseealso>
     </glossdef>
    </glossentry>
--- 826,836 ----
    <glossentry id="glossary-trait">
     <glossterm>trait</glossterm>
     <glossdef>
!     <para>
!     <indexterm zone="glossary-trait">
!      <primary>trait</primary>
!     </indexterm>
!     a characteristic of a type.</para>
      <glossseealso otherterm="glossary-traits_class">traits class</glossseealso>
     </glossdef>
    </glossentry>
***************
*** 732,739 ****
    <glossentry id="glossary-traits_class">
     <glossterm>traits class</glossterm>
     <glossdef>
!     <para>a class containing one or more traits all describing a
!     particular type's chacteristics.</para>
      <glossseealso otherterm="glossary-trait">trait</glossseealso>
     </glossdef>
    </glossentry>
--- 838,849 ----
    <glossentry id="glossary-traits_class">
     <glossterm>traits class</glossterm>
     <glossdef>
!     <para>
!     <indexterm zone="glossary-traits_class">
!      <primary>traits class</primary>
!     </indexterm>
!     a class containing one or more traits all describing a particular
!     type's chacteristics.</para>
      <glossseealso otherterm="glossary-trait">trait</glossseealso>
     </glossdef>
    </glossentry>
***************
*** 771,783 ****
    <glossentry id="glossary-view">
     <glossterm>view of a container</glossterm>
     <glossdef>
!     <para>a container derived from another.  The former's domain is a
      subset of the latter's, but, where the domains intersect,
      accessing a value through the view is the same as accessing it
      through the original container.  In Fortran&nbsp;90, these are
      called array sections.  Only &array;s, &dynamicarray;s, and
!     &field;s support views.</para> <glossseealso
!     otherterm="glossary-container">container</glossseealso>
     </glossdef>
    </glossentry>
   </glossdiv>
--- 881,893 ----
    <glossentry id="glossary-view">
     <glossterm>view of a container</glossterm>
     <glossdef>
!     <para>a container derived from another.  The view's domain is a
      subset of the latter's, but, where the domains intersect,
      accessing a value through the view is the same as accessing it
      through the original container.  In Fortran&nbsp;90, these are
      called array sections.  Only &array;s, &dynamicarray;s, and
!     &field;s support views.</para>
!     <glossseealso otherterm="glossary-container">container</glossseealso>
     </glossdef>
    </glossentry>
   </glossdiv>
Index: introduction.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/introduction.xml,v
retrieving revision 1.3
diff -c -p -r1.3 introduction.xml
*** introduction.xml	2002/01/14 17:33:34	1.3
--- introduction.xml	2002/01/24 04:56:35
***************
*** 20,32 ****
     </listitem>
     <listitem>
      <para>automatic creation of all interprocessor communication for
!     parallel and distributed programs</para>
     </listitem>
     <listitem>
-     <para>several container storage classes to reduce a program's
-     storage requirements, and</para>
-    </listitem>
-    <listitem>
      <para>automatic out-of-order execution and loop rearrangement
      for fast program execution.</para>
     </listitem>
--- 20,28 ----
     </listitem>
     <listitem>
      <para>automatic creation of all interprocessor communication for
!     parallel and distributed programs, and</para>
     </listitem>
     <listitem>
      <para>automatic out-of-order execution and loop rearrangement
      for fast program execution.</para>
     </listitem>
***************
*** 44,50 ****
   <section id="introduction-goals">
    <title>&pooma; Goals</title>
  
!   <para>The goals for the &poomatoolkit; have remained unchanged
    since its conception in 1994:
    <orderedlist>
     <listitem>
--- 40,50 ----
   <section id="introduction-goals">
    <title>&pooma; Goals</title>
  
!   <para><indexterm zone="introduction-goals">
!          <primary>&pooma;</primary>
!          <secondary>goals</secondary>
!         </indexterm>
!   The goals for the &poomatoolkit; have remained unchanged
    since its conception in 1994:
    <orderedlist>
     <listitem>
***************
*** 74,89 ****
  
    <bridgehead id="introduction-goals-portability" renderas="sect2">Code Portability for Sequential and Distributed Programs</bridgehead>
  
!   <para>The same &pooma; programs run on sequential, distributed, and
    parallel computers.  No change in source code is required.  Two or
!   three lines specifying how each container's domain should be
    distributed among available processors.  Using these directives and
    run-time information about the computer's configuration, the
    &toolkit; automatically distributes pieces of the container domains,
    called <link
    linkend="glossary-patch"><firstterm>patches</firstterm></link>,
    among the available processors.  If a computation needs values from
!   another patch, &pooma; automatically passes the value to the patch
    where it is needed.  The same program, and even the same executable,
    works regardless of the number of the available processors and the
    size of the containers' domains.  A programmer interested in only
--- 74,92 ----
  
    <bridgehead id="introduction-goals-portability" renderas="sect2">Code Portability for Sequential and Distributed Programs</bridgehead>
  
!   <para><indexterm zone="introduction-goals-portability">
!          <primary>code portability</primary>
!         </indexterm>
!   The same &pooma; programs run on sequential, distributed, and
    parallel computers.  No change in source code is required.  Two or
!   three lines specify how each container's domain should be
    distributed among available processors.  Using these directives and
    run-time information about the computer's configuration, the
    &toolkit; automatically distributes pieces of the container domains,
    called <link
    linkend="glossary-patch"><firstterm>patches</firstterm></link>,
    among the available processors.  If a computation needs values from
!   another patch, &pooma; automatically passes the values to the patch
    where it is needed.  The same program, and even the same executable,
    works regardless of the number of the available processors and the
    size of the containers' domains.  A programmer interested in only
***************
*** 92,116 ****
  
    <bridgehead id="introduction-goals-rapid_development" renderas="sect2">Rapid Application Development</bridgehead>
  
!   <para>The &poomatoolkit; is designed to enable rapid development of
    scientific and distributed applications.  For example, its vector,
    matrix, and tensor classes model the corresponding mathematical
    concepts.  Its &array; and &field; classes model the discrete spaces
!   and mathematical arrays frequently found in computational science and
!   math.  See <xref linkend="introduction-science_algorithms"></xref>.
!   The left column indicates theoretical science and math concepts, the
!   middle column computational science and math concepts, and the right
!   column computer science implementations.  For example, theoretical
!   physics frequently uses continuous fields in three-dimension space,
!   while algorithms for a corresponding computational physics problem
!   usually uses discrete fields.  &pooma; containers, classes, and
!   functions ease engineering computer programs for these algorithms.
!   For example, the &pooma; &field; container models discrete fields;
!   both map locations in discrete space to values and permit
!   computations of spatial distances and values.  The &pooma; &array;
!   container models the mathematical concept of an array, used in
!   numerical analysis.</para>
  
    <figure float="1" id="introduction-science_algorithms">
     <title>How &pooma; Fits Into the Scientific Process</title>
     <mediaobject>
--- 95,125 ----
  
    <bridgehead id="introduction-goals-rapid_development" renderas="sect2">Rapid Application Development</bridgehead>
  
!   <para><indexterm zone="introduction-goals-rapid_development">
!          <primary>rapid development</primary>
!         </indexterm>
!   The &poomatoolkit; is designed to enable rapid development of
    scientific and distributed applications.  For example, its vector,
    matrix, and tensor classes model the corresponding mathematical
    concepts.  Its &array; and &field; classes model the discrete spaces
!   and mathematical arrays frequently found in computational science
!   and math.  See <xref
!   linkend="introduction-science_algorithms"></xref>.  The left column
!   indicates theoretical science and math concepts, the middle column
!   computational science and math concepts, and the right column
!   computer science implementations.  For example, theoretical physics
!   frequently uses continuous fields in three-dimension space, while
!   algorithms for a corresponding computational physics problem usually
!   uses discrete fields.  &pooma; containers, classes, and functions
!   ease engineering computer programs for these algorithms.  For
!   example, the &pooma; &field; container models discrete fields: both
!   map locations in discrete space to values and permit computations of
!   spatial distances and values.  The &pooma; &array; container models
!   the mathematical concept of an array, frequently used in numerical
!   analysis.</para>
  
+   <!-- FIXME: How can we include this figure in the HTML version? -->
+ 
    <figure float="1" id="introduction-science_algorithms">
     <title>How &pooma; Fits Into the Scientific Process</title>
     <mediaobject>
***************
*** 121,129 ****
       <phrase>&pooma; helps translate algorithms into programs.</phrase>
      </textobject>
      <caption>
!      <para>In the translation from theoretical science and math to
!      computational science and math to computer programs, &pooma; eases
!      the implementation of algorithms as computer programs.</para>
      </caption>
     </mediaobject>
    </figure>
--- 130,138 ----
       <phrase>&pooma; helps translate algorithms into programs.</phrase>
      </textobject>
      <caption>
!      <para>In the translation from theoretical science to
!      computational science to computer programs, &pooma; eases the
!      implementation of algorithms as computer programs.</para>
      </caption>
     </mediaobject>
    </figure>
***************
*** 131,191 ****
    <para>&pooma; containers support a variety of computation modes,
    easing translation of algorithms into code.  For example, many
    algorithms for solving partial differential equations use
!   stencil-based computations.  &pooma; supports stencil-based
!   computations on &array;s and &field;s.  It also supports
!   data-parallel computation similar to &fortran&nbsp;90 syntax.  For
!   computations where one &field;'s values is a function of several
!   other &field;'s values, the programmer can specify a relation.
!   Relations are lazily evaluated: whenever the dependent &field;'s
!   values are needed and it is dependent on a &field; whose values have
!   changed, its values are computed.  Lazy evaluation also assists
!   correctness by eliminating the frequently forgotten need for a
!   programmer to ensure a &field;'s values are up-to-date before being
!   used.</para>
  
    <bridgehead id="introduction-goals-efficient" renderas="sect2">Efficient Code</bridgehead>
  
    <para>&pooma; incorporates a variety of techniques to ensure it
!   produces code that executes as quickly as special-case,
!   hand-written code.
!  <!-- FIXME: Do I present execution numbers here? -->
!   These techniques include extensive use of templates, out-of-order
!   evaluation, use of guard layers, and production of fast inner loops.</para>
! 
!   <para>&pooma;'s uses of &cc; templates permits the expressiveness
!   from using pointers and function arguments but ensures as much as
!   work as possible occurs at compile time, not run time.  This speeds
!   programs' execution.  Since more code is produced at compile time,
!   more code is available to the compiler's optimizer, further speeding
!   execution.  The &pooma; &array; container benefits from the use of
!   template parameters.  Their use permits the use of specialized data
!   storage classes called <link
    linkend="glossary-engine"><firstterm>engines</firstterm></link>.  An
!   &array;'s &engine; template parameter specifies how data is stored and
!   indexed.  Some &array;s expect almost all values to be used, while
!   others might be mostly vacant.  In the latter case, using a
    specialized engine storing the few nonzero values greatly reduces
!   space requirements.  Using engines also permits fast creation of
!   container views, known as <firstterm>array sections</firstterm> in
!   Fortran&nbsp;90.  A view's engine is the same as the original
!   container's engine, but the view object maps its restricted domain to
!   the original domain.  Space requirements and execution time to use
!   views are minimal.  Using templates also permits containers to
!   support polymorphic indexing, e.g., indexing both by integers and by
!   three-dimensional coordinates.  A container defers indexing
!   operations to its engine's templatized index operator.  Since it uses
!   templates, the &engine; can define indexing functions with different
!   function arguments, without the need to add corresponding container
!   functions.  Some of these benefits of using templates can be
!   expressed without them, but doing so increases execution time.  For
!   example, a container could have a pointer to an engine object, but
!   this requires a pointer dereference for each operation.  Implementing
!   polymorphic indexing without templates would require adding virtual
!   functions corresponding to each of the indexing functions.</para>
  
   <!-- FIXME: Are the claims concerning out-of-order evaluation I make true? -->
  
!   <para>To ensure multiprocessor &pooma; programs execute quickly, it
    is important that interprocessor communication overlaps with
    intraprocessor computations as much as possible and that
    communication is minimized.  Asynchronous communication, out-of-order
--- 140,235 ----
    <para>&pooma; containers support a variety of computation modes,
    easing translation of algorithms into code.  For example, many
    algorithms for solving partial differential equations use
!   stencil-based computations so &pooma; supports stencil-based
!   computations on &array;s and &field;s.  &pooma; also supports
!   data-parallel computation similar to &fortran&nbsp;90 syntax.
!   <indexterm class="startofrange"
!   id="introduction-goals-rapid_development-index-relations">
!    <primary>relation</primary>
!   </indexterm>
!   To ease implementing computations where one &field;'s values are a
!   function of several other &field;'s values, the programmer can
!   specify a <glossterm
!   linkend="glossary-relation">relation</glossterm>.  Relations are
!   lazily evaluated: whenever the dependent &field;'s values are needed
!   and they are dependent on a &field; whose values have changed, the
!   values are computed.  Relations also assists correctness by
!   eliminating the frequently forgotten need for a programmer to ensure
!   a &field;'s values are up-to-date before being used.<indexterm
!   class="endofrange"
!   startref="introduction-goals-rapid_development-index-relations"></indexterm></para>
  
    <bridgehead id="introduction-goals-efficient" renderas="sect2">Efficient Code</bridgehead>
  
    <para>&pooma; incorporates a variety of techniques to ensure it
!   produces code that executes as quickly as special-case, hand-written
!   code.  These techniques include extensive use of templates,
!   out-of-order evaluation, use of guard layers, and production of fast
!   inner loops.</para>
! 
!   <para><indexterm class="startofrange"
!   id="introduction-goals-efficient-index-templates_use">
!    <primary>templates</primary>
!    <secondary>use</secondary>
!   </indexterm>
!   &pooma;'s uses of &cc; templates ensures as much as work as possible
!   occurs at compile time, not run time.  This speeds programs'
!   execution.  Since more code is produced at compile time, more code
!   is available to the compiler's optimizer, further speeding
!   execution.
!   <indexterm class="startofrange"
!   id="introduction-goals-efficient-index-templates-engines">
!    <primary>engines</primary>
!   </indexterm>
!   The &pooma; &array; container benefits from the use of template
!   parameters.  Their use permits the use of specialized data storage
!   classes called <link
    linkend="glossary-engine"><firstterm>engines</firstterm></link>.  An
!   &array;'s &engine; template parameter specifies how data is stored
!   and indexed.  Some &array;s expect almost all values to be used,
!   while others might be mostly empty.  In the latter case, using a
    specialized engine storing the few nonzero values greatly reduces
!   storage requirements.  Using engines also permits fast creation of
!   container views, known as <indexterm><primary>array
!   sections</primary></indexterm><firstterm>array sections</firstterm>
!   in &fortran;&nbsp;90.  A view's engine is the same as the original
!   container's engine, but the view object's restricted domain is a
!   subset of the original domain.  Space requirements and execution
!   time to use views are minimal.  <indexterm class="endofrange"
!   startref="introduction-goals-efficient-index-templates-engines"></indexterm>
!   </para>
  
+   <para id="introduction-goals-efficient-polymorphic_indexing">
+   <indexterm zone="introduction-goals-efficient-polymorphic_indexing">
+    <primary>polymorphic indexing</primary>
+   </indexterm>
+   Using templates also permits containers to support polymorphic
+   indexing, e.g., indexing both by integers and by three-dimensional
+   coordinates.  A container uses templatized indexing functions that
+   defer indexing operations to its engine's index operators.  Since
+   the container uses templates, the &engine; can define indexing
+   functions with different function arguments, without the need to add
+   corresponding container functions.  Some of these benefits of using
+   templates can be expressed without them, but doing so increases
+   execution time.  For example, a container could have a pointer to an
+   engine object, but this requires a pointer dereference for each
+   operation.  Implementing polymorphic indexing without templates
+   would require adding virtual functions corresponding to each of the
+   indexing functions.
+   <indexterm class="endofrange"
+   startref="introduction-goals-efficient-index-templates_use"></indexterm>
+   </para>
+ 
   <!-- FIXME: Are the claims concerning out-of-order evaluation I make true? -->
  
!   <para id="introduction-goals-efficient-asynchronous_communication">
!   <indexterm zone="introduction-goals-efficient-asynchronous_communication">
!    <primary>asynchronous communication</primary>
!   </indexterm>
!   <indexterm zone="introduction-goals-efficient-asynchronous_communication">
!    <primary>&cheetah;</primary>
!   </indexterm>
!   To ensure multiprocessor &pooma; programs execute quickly, it
    is important that interprocessor communication overlaps with
    intraprocessor computations as much as possible and that
    communication is minimized.  Asynchronous communication, out-of-order
***************
*** 199,241 ****
    sender to put and get data without synchronizing with the recipient
    processor, and it also permits invoking functions at remote sites to
    ensure desired data is up-to-date.  Thus, out-of-order evaluation
    must be supported.  Out-of-order evaluation also has another benefit:
    Only computations directly or indirectly related to values that are
!   printed need occur.</para>
  
!   <para>Surrounding a patch with <link
    linkend="glossary-guard_layer"><firstterm>guard
    layers</firstterm></link> can help reduce interprocessor
    communication.  For distributed computation, each container's domain
    is split into pieces distributed among the available processors.
    Frequently, computing a container value is local, involving just the
!   value itself and a few neighbors, but computing a value near the edge
!   of a processor's domain may require knowing a few values from a
    neighboring domain.  Guard layers permit these values to be copied
    locally so they need not be repeatedly communicated.</para>
  
!   <para>&pooma; uses &pete; technology to ensure inner loops involving
    &pooma;'s object-oriented containers run as quickly as hand-coded
!   <!-- FIXME: Add a citation to Dr. Dobb's Journal article pete-99. -->
!   loops.  &pete; (the Portable Expression Template Engine) uses
!   expression-template technology to convert data-parallel statements
!   in the inner loops of programs into efficient loops
!   without any intermediate computations.  For example, consider
!   evaluating the statement
!   <programlisting>
!   A += -B + 2 * C;</programlisting>
!   where <varname>A</varname> and <varname>C</varname> are
    <type>vector&lt;double&gt;</type>s and <varname>B</varname> is a
!   <type>vector&lt;int&gt;</type>.  Naive evaluation might introduce
    intermediaries for <statement>-B</statement>,
    <statement>2*C</statement>, and their sum.  The presence of these
!   intermediaries in inner loops can measurably slow evaluation.  To
    produce a loop without intermediaries, &pete; stores each expression
!   as a parse tree.  The resulting parse trees can be combined into a
!   larger parse tree.  Using its templates, the parse tree is converted,
!   at compile time, to a loop evaluating each component of the result.
!   Thus, no intermediate values are computed or stored.  For example,
!   the code corresponding to the statement above is
    <programlisting>
    vector&lt;double&gt;::iterator iterA = A.begin();
    vector&lt;int&gt;::const_iterator iterB = B.begin();
--- 243,308 ----
    sender to put and get data without synchronizing with the recipient
    processor, and it also permits invoking functions at remote sites to
    ensure desired data is up-to-date.  Thus, out-of-order evaluation
+   <indexterm>
+    <primary>out-of-order evaluation</primary>
+   </indexterm>
+   <indexterm>
+    <primary>evaluation</primary>
+    <secondary>out-of-order</secondary>
+    <see>out-of-order evaluation.</see>
+   </indexterm>
+ <!-- FIXME: Add glossary entry for out-of-order evaluation. -->
    must be supported.  Out-of-order evaluation also has another benefit:
    Only computations directly or indirectly related to values that are
!   printed need occur.
!   </para>
  
!   <para id="introduction-goals-efficient-guard_layers">
!   <indexterm zone="introduction-goals-efficient-guard_layers">
!    <primary>guard layer</primary>
!   </indexterm>
!   Surrounding a patch with <link
    linkend="glossary-guard_layer"><firstterm>guard
    layers</firstterm></link> can help reduce interprocessor
    communication.  For distributed computation, each container's domain
    is split into pieces distributed among the available processors.
    Frequently, computing a container value is local, involving just the
!   value itself and a few neighbors, but computing a value near the
!   edge of a processor's domain may require knowing a few values from a
    neighboring domain.  Guard layers permit these values to be copied
    locally so they need not be repeatedly communicated.</para>
  
!   <para id="introduction-goals-efficient-pete">
!   <indexterm zone="introduction-goals-efficient-pete">
!    <primary>&pete;</primary>
!   </indexterm>
!   <indexterm>
!    <primary><application class="software">Portable Expression Template Engine</application></primary>
!    <see>&pete;.</see>
!   </indexterm>
!   <indexterm zone="introduction-goals-efficient-pete">
!    <primary>inner-loop evaluation</primary>
!   </indexterm>
!   &pooma; uses &pete; technology to ensure inner loops involving
    &pooma;'s object-oriented containers run as quickly as hand-coded
!   <!-- FIXME: Add a citation to Dr. Dobb's Journal article
!   pete-99. --> loops.  &pete; (the <application>Portable Expression Template
!   Engine</application>) uses expression-template technology to convert data-parallel
!   statements into efficient loops without any intermediate
!   computations.  For example, consider evaluating the statement
! <programlisting>
! A += -B + 2 * C;
! </programlisting> where <varname>A</varname> and <varname>C</varname> are
    <type>vector&lt;double&gt;</type>s and <varname>B</varname> is a
!   <type>vector&lt;int&gt;</type>.  &naivecap; evaluation might introduce
    intermediaries for <statement>-B</statement>,
    <statement>2*C</statement>, and their sum.  The presence of these
!   intermediaries in inner loops can measurably slow performance.  To
    produce a loop without intermediaries, &pete; stores each expression
!   as a parse tree.  Using its templates, the parse tree is
!   converted, at compile time, to a loop directly evaluating each component of
!   the result without computing intermediate values.
!   For example, the code corresponding to the statement above is
    <programlisting>
    vector&lt;double&gt;::iterator iterA = A.begin();
    vector&lt;int&gt;::const_iterator iterB = B.begin();
***************
*** 244,267 ****
      *iterA += -*iterB + 2 * *iterC;
      ++iterA; ++iterB; ++iterC;
    }</programlisting>
!   Furthermore, since the code is available at compile, not run, time,
    it can be further optimized, e.g., moving any loop-invariant code out
    of the loop.</para>
  
    <bridgehead id="introduction-goals-scientific" renderas="sect2">Used for Diverse Set of Scientific Problems</bridgehead>
  
    <para>&pooma; has been used to solve a wide variety of scientific
    problems.  Most recently, physicists at Los Alamos National
!   Laboratory implemented an entire library of hydrodynamics codes as
    part of the U.S. government's science-based Stockpile Stewardship
!   Program to simulate nuclear weapons.  Other applications include a
    matrix solver, an accelerator code simulating the dynamics of
    high-intensity charged particle beams in linear accelerators, and a
!   Monte Carlo neutron transport code.</para>
  
    <bridgehead id="introduction-goals-easy_implementation" renderas="sect2">Easy Implementation</bridgehead>
  
!   <para>&pooma;'s tools greatly reduce the time to implement
    applications.  As we noted above, &pooma;'s containers and expression
    syntax model the computational models and algorithms most frequently
    found in scientific programs.  These high-level tools are known to be
--- 311,357 ----
      *iterA += -*iterB + 2 * *iterC;
      ++iterA; ++iterB; ++iterC;
    }</programlisting>
!   Furthermore, since the code is available at compile time, not run time,
    it can be further optimized, e.g., moving any loop-invariant code out
    of the loop.</para>
  
+ 
    <bridgehead id="introduction-goals-scientific" renderas="sect2">Used for Diverse Set of Scientific Problems</bridgehead>
  
    <para>&pooma; has been used to solve a wide variety of scientific
    problems.  Most recently, physicists at Los Alamos National
!   Laboratory
!   <indexterm>
!    <primary>Los Alamos National Laboratory</primary>
!   </indexterm>
!   implemented an entire library of hydrodynamics codes
!   <indexterm>
!    <primary>hydrodynamics</primary>
!   </indexterm>
!   as
    part of the U.S. government's science-based Stockpile Stewardship
!   Program
!   <indexterm>
!    <primary>Stockpile Stewardship Program</primary>
!   </indexterm>
!   to simulate nuclear weapons.  Other applications include a
    matrix solver, an accelerator code simulating the dynamics of
    high-intensity charged particle beams in linear accelerators, and a
!   Monte Carlo
!   <indexterm>
!    <primary>Monte Carlo simulation</primary>
!   </indexterm>
!   neutron transport code.</para>
  
+ 
    <bridgehead id="introduction-goals-easy_implementation" renderas="sect2">Easy Implementation</bridgehead>
  
!   <para id="introduction-goals-easy_implementation-ease">
!   <indexterm zone="introduction-goals-easy_implementation-ease">
!    <primary>&pooma;</primary>
!    <secondary>ease of writing programs</secondary>
!   </indexterm>
!   &pooma;'s tools greatly reduce the time to implement
    applications.  As we noted above, &pooma;'s containers and expression
    syntax model the computational models and algorithms most frequently
    found in scientific programs.  These high-level tools are known to be
***************
*** 271,280 ****
    computers.  With no additional work, the same program runs on
    computers with hundreds of processors; the code is exactly the same,
    and the &toolkit; automatically handles distribution of the data, all
!   data communication, and all synchronization.  The net results is a
    significant reduction in programming time.  For example, a team of
    two physicists and two support people at Los Alamos National
!   Laboratory implemented a suite of hydrodynamics kernels in six
    months.  Their work replaced a previous suite of less-powerful
    kernels which had taken sixteen people several years to implement and
    debug.  Despite not have previously implemented any of the kernels,
--- 361,378 ----
    computers.  With no additional work, the same program runs on
    computers with hundreds of processors; the code is exactly the same,
    and the &toolkit; automatically handles distribution of the data, all
!   data communication, and all synchronization.  The net result is a
    significant reduction in programming time.  For example, a team of
    two physicists and two support people at Los Alamos National
!   Laboratory
!   <indexterm>
!    <primary>Los Alamos National Laboratory</primary>
!   </indexterm>
!   implemented a suite of hydrodynamics kernels
!   <indexterm>
!    <primary>hydrodynamics</primary>
!   </indexterm>
!   in six
    months.  Their work replaced a previous suite of less-powerful
    kernels which had taken sixteen people several years to implement and
    debug.  Despite not have previously implemented any of the kernels,
***************
*** 283,352 ****
   </section><!-- introduction-goals -->
  
  
   <section id="introduction-performance">
    <title>&pooma; Produces Fast Programs</title>
  
    <para>almost as fast as &c;.  wide variety of configurations: one
    processor, many processors, give performance data for at least two
!   different programs
! HERE</para>
  
!   <para>describe &doof2d; here
  
    &doof2d; is a two-dimensional diffusion simulation program.
    Initially, all values in the square two-dimensional grid are zero
!   except for the central value.  
! 
! HERE</para>
  
   </section>
  
- <!-- HERE -->
  
   <section id="introduction-open_source">
    <title>&pooma; is Free, Open-Source Software</title>
  
    <para>The &poomatoolkit; is open-source software.  Anyone may
    download, read, redistribute, and modify the &pooma; source code.
!   If an application requires a specialized container, any programmer
!   may add it.  Any programmer can extend it to solve problems in
!   previously unsupported domains.  Companies using the &toolkit; can
!   read the source code to ensure it has no hidden back doors or
!   security holes.  It may be downloaded for free and used for
!   perpetuity.  There are no annual licenses and no on-going costs.  By
!   keeping their own copies, companies are guaranteed the software will
!   never disappear.  In summary, the &poomatoolkit; is free, low-risk
!   software.</para>
   </section>
  
  
   <section id="introduction-pooma_history">
    <title>History of &pooma;</title>
  
    <para>The &poomatoolkit; was developed at Los Alamos National
!   Laboratory to assist nuclear fusion and fission research.
    In&nbsp;1994, the &toolkit; grew out of the <application
    class='software'>Object-Oriented Particle Simulation</application>
!   class library developed for particle-in-cell simulations.  The goals
    of the Framework, as it was called at the time, were driven by the
!   Numerical Tokamak's <quote>Parallel Platform Paradox</quote>:
    <blockquote>
     <para>The average time required to implement a moderate-sized
     application on a parallel computer architecture is equivalent to
     the half-life of the latest parallel supercomputer.</para>
    </blockquote>
    The framework's goal of being able to quickly write efficient
    scientific code that could be run on a wide variety of platforms
    remains unchanged today.  Development, mainly at the
!   Advanced Computing Laboratory at Los Alamos, proceeded rapidly.
!   A matrix solver application was written using the framework.
  <!-- FIXME: Add citation to pooma-sc95. -->
!   Support for hydrodynamics, Monte Carlo simulations, and molecular
!   dynamics modeling soon followed.</para>
! 
!   <para>By&nbsp;1998, &pooma; was part of the U.S. Department of
!   Energy's Accelerated Strategic Computing Initiative
!   (<acronym>ASCI</acronym>).  The Comprehensive Test Ban Treaty forbid
    nuclear weapons testing so they were instead simulated using
    computers.  <acronym>ASCI</acronym>'s goal was to radically advance
    the state of the art in high-performance computing and numerical
--- 381,516 ----
   </section><!-- introduction-goals -->
  
  
+ <![%unfinished;[
   <section id="introduction-performance">
    <title>&pooma; Produces Fast Programs</title>
  
    <para>almost as fast as &c;.  wide variety of configurations: one
    processor, many processors, give performance data for at least two
!   different programs UNFINISHED</para>
  
!   <para>describe &doof2d; at this location
  
    &doof2d; is a two-dimensional diffusion simulation program.
    Initially, all values in the square two-dimensional grid are zero
!   except for the central value.  UNFINISHED</para>
  
   </section>
+ ]]>  <!-- end unfinished -->
  
  
   <section id="introduction-open_source">
    <title>&pooma; is Free, Open-Source Software</title>
  
+   <indexterm zone="introduction-open_source">
+    <primary>open-source software</primary>
+   </indexterm>
+   <indexterm zone="introduction-open_source">
+    <primary>&pooma;</primary>
+    <secondary>open-source</secondary>
+   </indexterm>
+ 
    <para>The &poomatoolkit; is open-source software.  Anyone may
    download, read, redistribute, and modify the &pooma; source code.
!   If an application requires a specialized container not already
!   available, any programmer may add it.  Any programmer can extend it
!   to solve problems in previously unsupported domains.  Companies
!   using the &toolkit; can read the source code to ensure it has no
!   security holes.  It may be downloaded for free
!   and used for perpetuity.  There are no annual licenses and no
!   on-going costs.  By keeping their own copies, companies are
!   guaranteed the software will never disappear.  In summary, the
!   &poomatoolkit; is free, low-risk software.</para>
   </section>
  
  
   <section id="introduction-pooma_history">
    <title>History of &pooma;</title>
  
+   <indexterm zone="introduction-pooma_history">
+    <primary>&pooma;</primary>
+    <secondary>history</secondary>
+   </indexterm>
+   <indexterm zone="introduction-pooma_history">
+    <primary>Los Alamos National Laboratory</primary>
+   </indexterm>
+ 
    <para>The &poomatoolkit; was developed at Los Alamos National
!   Laboratory to assist nuclear fusion
!   <indexterm>
!    <primary>fusion</primary>
!   </indexterm>
!   and fission
!   <indexterm>
!    <primary>fission</primary>
!   </indexterm>
!   research.
    In&nbsp;1994, the &toolkit; grew out of the <application
    class='software'>Object-Oriented Particle Simulation</application>
!   <indexterm>
!    <primary>Object-Oriented Particle Simulation Library</primary>
!   </indexterm>
!   Class Library developed for particle-in-cell simulations.  The goals
    of the Framework, as it was called at the time, were driven by the
!   Numerical Tokamak's 
!   <indexterm>
!    <primary>Tokamak</primary>
!   </indexterm>
!   <quote>Parallel Platform Paradox</quote>:
    <blockquote>
     <para>The average time required to implement a moderate-sized
     application on a parallel computer architecture is equivalent to
     the half-life of the latest parallel supercomputer.</para>
    </blockquote>
+   <indexterm>
+    <primary>Parallel Platform Paradox</primary>
+   </indexterm>
    The framework's goal of being able to quickly write efficient
    scientific code that could be run on a wide variety of platforms
    remains unchanged today.  Development, mainly at the
!   Advanced Computing Laboratory
!   <indexterm>
!    <primary>Los Alamos National Laboratory</primary>
!    <secondary>Advanced Computing Laboratory</secondary>
!   </indexterm>
!   at Los Alamos, proceeded rapidly.  A matrix solver application was
!   written using the framework.
  <!-- FIXME: Add citation to pooma-sc95. -->
!   Support for hydrodynamics,
!   <indexterm>
!    <primary>hydrodynamics</primary>
!   </indexterm>
!   Monte Carlo simulations,
!   <indexterm>
!    <primary>Monte Carlo simulation</primary>
!   </indexterm>
!   and molecular dynamics
!   <indexterm>
!    <primary>molecular dynamics modeling</primary>
!   </indexterm>
!   modeling soon followed.</para>
! 
!   <para id="introduction-pooma_history-asci">
!   By&nbsp;1998, &pooma; was part of the U.S. Department of
!   Energy's
!   <indexterm>
!    <primary>Department of Energy</primary>
!   </indexterm>
!   Accelerated Strategic Computing Initiative
!   (<acronym>ASCI</acronym>).
!   <indexterm zone="introduction-pooma_history-asci">
!    <primary>Department of Energy</primary>
!    <secondary>Accelerated Strategic Computing Initiative</secondary>
!   </indexterm>
!   <indexterm>
!    <primary>Accelerated Strategic Computing Initiative</primary>
!    <see>Department of Energy, Accelerated Strategic Computing Initiative.</see>
!   </indexterm>
!   The Comprehensive Test Ban Treaty
!   <indexterm>
!    <primary>Comprehensive Test Ban Treaty</primary>
!   </indexterm>
!   forbid
    nuclear weapons testing so they were instead simulated using
    computers.  <acronym>ASCI</acronym>'s goal was to radically advance
    the state of the art in high-performance computing and numerical
*************** HERE</para>
*** 361,388 ****
    <para>&pooma;&nbsp;2 involved a new conceptual framework and a
    complete rewriting of the source code to improve performance.  The
  <!-- FIXME: Add a citation to iscope98.pdf. -->
!   &array; class was introduced with its use of &engine;s, separating
!   container use from container storage.  An asynchronous scheduler
!   permitted out-of-order execution to improve cache coherency.
    Incorporating the <application class="software">Portable
    Expression Template Engine</application> (<acronym>PETE</acronym>)
!   permitted faster loop execution.  Soon, container views and
!   <type>ConstantFunction</type> and <type>IndexFunction</type>
!   &engine;s were added.  Release&nbsp;2.1.0 included &field;s with
!   their spatial extent and &dynamicarray;s with the ability to
!   dynamically change its domain size.  Support for particles and
    their interaction with &field;s were added.  The &pooma; messaging
    implementation was revised in release&nbsp;2.3.0.  Use of the
!   &cheetah; Library separated &pooma; from the actual messaging
    library used, and support for applications running on clusters of
    computers was added.  <ulink
!   url="http://www.codesourcery.com">CodeSourcery, LLC</ulink>, and
!   <ulink url="www.proximation.com">Proximation, LLC</ulink>, took
    over &pooma; development from Los Alamos National Laboratory.
    During the past two years, the &field;
!   abstraction and implementation was improved to increase its
    flexibility, add support for multiple values and materials in the
!   same cell, and permit lazy evaluation.  Simultaneously, the
    execution speed of the inner loops was greatly increased.</para>
   </section>
  
--- 525,609 ----
    <para>&pooma;&nbsp;2 involved a new conceptual framework and a
    complete rewriting of the source code to improve performance.  The
  <!-- FIXME: Add a citation to iscope98.pdf. -->
!   &array; class
!   <indexterm>
!    <primary>&array;</primary>
!   </indexterm>
!   was introduced with its use of &engine;s,
!   <indexterm>
!    <primary>&engine;</primary>
!   </indexterm>
!   separating
!   container use from container storage.  A new asynchronous scheduler
!   permitted out-of-order execution
!   <indexterm>
!    <primary>out-of-order evaluation</primary>
!   </indexterm>
!   to improve cache coherency.
    Incorporating the <application class="software">Portable
    Expression Template Engine</application> (<acronym>PETE</acronym>)
!   <indexterm>
!    <primary>&pete;</primary>
!   </indexterm>
!   permitted faster loop execution.  Soon, container views
!   <indexterm>
!    <primary>container</primary>
!    <secondary>view</secondary>
!   </indexterm>
!   and
!   <type>ConstantFunction</type>
!   <indexterm>
!    <primary>&engine;</primary>
!    <secondary><type>ConstantFunction</type></secondary>
!   </indexterm>
!   and <type>IndexFunction</type>
!   <indexterm>
!    <primary>&engine;</primary>
!    <secondary><type>IndexFunction</type></secondary>
!   </indexterm>
!   &engine;s were added.  Release&nbsp;2.1.0 included &field;s
!   <indexterm>
!    <primary>&field;</primary>
!   </indexterm>
!   with
!   their spatial extent and &dynamicarray;s
!   <indexterm>
!    <primary>&dynamicarray;</primary>
!   </indexterm>
!   with the ability to
!   dynamically change domain size.  Support for particles and
    their interaction with &field;s were added.  The &pooma; messaging
    implementation was revised in release&nbsp;2.3.0.  Use of the
!   &cheetah; Library
!   <indexterm>
!    <primary>&cheetah;</primary>
!   </indexterm>
!   separated &pooma; from the actual messaging
    library used, and support for applications running on clusters of
    computers was added.  <ulink
!   url="http://www.codesourcery.com/">CodeSourcery, LLC</ulink>,
!   <indexterm>
!    <primary>CodeSourcery, LLC</primary>
!   </indexterm>
!   and
!   <ulink url="http://www.proximation.com/">Proximation, LLC</ulink>,
!   <indexterm>
!    <primary>Proximation, LLC</primary>
!   </indexterm>
!   took
    over &pooma; development from Los Alamos National Laboratory.
    During the past two years, the &field;
!   abstraction
!   <indexterm>
!    <primary>&field;</primary>
!   </indexterm>
!   and implementation was improved to increase its
    flexibility, add support for multiple values and materials in the
!   same cell, and permit lazy evaluation.
!   <indexterm>
!    <primary>lazy evaluation</primary>
!   </indexterm>
!   Simultaneously, the
    execution speed of the inner loops was greatly increased.</para>
   </section>
  
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.8
diff -c -p -r1.8 manual.xml
*** manual.xml	2002/01/22 15:48:49	1.8
--- manual.xml	2002/01/24 04:56:38
***************
*** 1,4 ****
--- 1,6 ----
  <?xml version="1.0"?>
+ <!-- FIXME: Index this file. -->
+ <!-- FIXME: What font does DocBook/JadeTeX use?  Can we use it for the figures? -->
  
  <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "file://usr/lib/sgml/docbookx.dtd" [
  
***************
*** 7,12 ****
--- 9,20 ----
    <!-- UPDATE: Check before publishing to see if any needs changing. -->
    <!-- ADD: Write more material. -->
  
+ <!-- Conditional Inclusion Entity Declarations -->
+ <!ENTITY % unfinished "IGNORE">
+   <!-- Unfinished sections should not be included in published versions. -->
+ <!ENTITY % temporary "INCLUDE">
+   <!-- Temporary sections to be included in published versions until the final version is written. -->
+ 
  <!-- Index Entity Declarations -->
  <!ENTITY genindex.sgm SYSTEM "genindex.sgm">
  
***************
*** 158,163 ****
--- 166,173 ----
  
  <!ENTITY container "C">
    <!-- an abbreviation for a canonical container -->
+ <!ENTITY containerdomain "D">
+   <!-- an abbreviation for a canonical container domain -->
  <!ENTITY n "n">
    <!-- the size of one dimension of an array -->
  <!ENTITY space "&real;<superscript>d</superscript>">
***************
*** 173,194 ****
  
  <!-- &pooma; URLs and Files -->
  
! <!ENTITY poomaDownloadPage '<ulink url="http://pooma.codesourcery.com/pooma/download">http://pooma.codesourcery.com/pooma/download</ulink>'>
    <!-- The WWW page supporting downloading the &pooma; source code. -->
    <!-- UPDATE this URL. -->
! <!ENTITY poomaHomePage '<ulink url="http://www.pooma.com/">http://www.pooma.com/</ulink>'>
    <!-- The canonical Pooma home page. -->
    <!-- UPDATE this filename. -->
! <!ENTITY poomaSource "pooma-2.3.0">
    <!-- The Pooma source code directory. -->
! <!ENTITY poomaSourceFile "&poomaSource;.tgz">
    <!-- The Pooma source code archive. -->
! <!ENTITY poomaExampleDirectory "examples/Manual">
    <!-- The directory holding this manual's example codes. -->
  
  <!-- Spelling and Formatting Decisions -->
  <!ENTITY author "author">
    <!-- A word describing an author xor authors. -->
    <!-- spelling: dependence, not dependency -->
    <!-- spelling: element-wise, not elementwise -->
    <!-- phrase: function object, not functor -->
--- 183,210 ----
  
  <!-- &pooma; URLs and Files -->
  
! <!ENTITY poomadownloadpage '<ulink url="http://pooma.codesourcery.com/pooma/download">http://pooma.codesourcery.com/pooma/download</ulink>'>
    <!-- The WWW page supporting downloading the &pooma; source code. -->
    <!-- UPDATE this URL. -->
! <!ENTITY poomahomepage '<ulink url="http://www.pooma.com/">http://www.pooma.com/</ulink>'>
    <!-- The canonical Pooma home page. -->
    <!-- UPDATE this filename. -->
! <!ENTITY poomasource "pooma-2.3.0">
    <!-- The Pooma source code directory. -->
!   <!-- UPDATE this filename. -->
! <!ENTITY poomasourcefile "&poomasource;.tgz">
    <!-- The Pooma source code archive. -->
! <!ENTITY poomaexampledirectory "examples/Manual">
    <!-- The directory holding this manual's example codes. -->
  
  <!-- Spelling and Formatting Decisions -->
  <!ENTITY author "author">
    <!-- A word describing an author xor authors. -->
+ <!ENTITY naive "na&iuml;ve">
+   <!-- The word "na\"{\i}ve." -->
+ <!ENTITY naivecap "Na&iuml;ve">
+   <!-- The word "Na\"{\i}ve," i.e., the capitalized &naive;. -->
+   <!-- The Pooma source code directory. -->
    <!-- spelling: dependence, not dependency -->
    <!-- spelling: element-wise, not elementwise -->
    <!-- phrase: function object, not functor -->
***************
*** 260,277 ****
      <orgname>CodeSourcery, LLC</orgname>
     </affiliation>
    </author>
!   <copyright><year>2001</year><holder>CodeSourcery, LLC (<ulink url="http://www.codesourcery.com"></ulink>)</holder></copyright>
!   <contractsponsor>Los Alamos National Laboratory<ulink url="http://www.lanl.gov"></ulink></contractsponsor>
    <legalnotice>
     <!-- FIXME: What is the correct legal notice? -->
     <para>All rights reserved.  This document may not be redistributed in any form without the express permission of the author.</para>
    </legalnotice>
    <revhistory>
     <revision>
!     <revnumber>0.01</revnumber>
!     <date>2002 Jan 14</date>
      <authorinitials>jdo</authorinitials>
!     <revremark>first draft</revremark>
     </revision>
    </revhistory>
   </bookinfo>
--- 276,293 ----
      <orgname>CodeSourcery, LLC</orgname>
     </affiliation>
    </author>
!   <copyright><year>2002</year><holder>CodeSourcery, LLC (<ulink url="http://www.codesourcery.com/"></ulink>)</holder></copyright>
!   <contractsponsor>Los Alamos National Laboratory<ulink url="http://www.lanl.gov/"></ulink></contractsponsor>
    <legalnotice>
     <!-- FIXME: What is the correct legal notice? -->
     <para>All rights reserved.  This document may not be redistributed in any form without the express permission of the author.</para>
    </legalnotice>
    <revhistory>
     <revision>
!     <revnumber>1.00</revnumber>
!     <date>2002 Jan 23</date>
      <authorinitials>jdo</authorinitials>
!     <revremark>First publication.</revremark>
     </revision>
    </revhistory>
   </bookinfo>
***************
*** 279,284 ****
--- 295,301 ----
   <!-- FINISH: May we have a short table of contents followed by a -->
   <!-- complete table of contents? -->
  
+ <![%unfinished;[
   <preface id="preface">
    <title>Preface</title>
  
***************
*** 338,349 ****
--- 355,369 ----
    </section>
  
   </preface>
+ ]]>  <!-- end unfinished -->
  
  
+ <![%unfinished;[
   <part id="programming">
    <title>Programming with &pooma;</title>
  
  <!-- FIXME: Add a partintro to the part above? -->
+ ]]>  <!-- end unfinished -->
  
    &introductory-chapter; 
  
***************
*** 420,429 ****
      components of each vector in an &array; to form its own &array;.
      Since each container has one or more &engine;s, we can also
      describe the latter category as containers that compute their
!     values using other containers' values.  A <type>MultiPatch</type>
!     &engine; distributes its domain among various processors and
!     memory spaces, each responsible for computing values associated
!     with a portion, or patch, of the domain.</para>
  
      <para>Just as multiple containers can use the same engine,
      multiple &engine;s can use the same underlying data.  As we
--- 440,449 ----
      components of each vector in an &array; to form its own &array;.
      Since each container has one or more &engine;s, we can also
      describe the latter category as containers that compute their
!     values using other containers' values.  A &multipatch; &engine;
!     distributes its domain among various processors and memory spaces,
!     each responsible for computing values associated with a portion,
!     or patch, of the domain.</para>
  
      <para>Just as multiple containers can use the same engine,
      multiple &engine;s can use the same underlying data.  As we
***************
*** 491,497 ****
  	<row>
  	 <entry>&dynamic;</entry>
  	 <entry>is a one-dimensional &brick; with dynamically
!          resizable domain.  HERE ever explicitly declare these?</entry>
  	</row>
  	<row rowsep="1">
  	 <entry>&engine;s That Compute</entry>
--- 511,518 ----
  	<row>
  	 <entry>&dynamic;</entry>
  	 <entry>is a one-dimensional &brick; with dynamically
!          resizable domain.  This should be used with &dynamicarray;,
! 	 not &array;.</entry>
  	</row>
  	<row rowsep="1">
  	 <entry>&engine;s That Compute</entry>
***************
*** 620,626 ****
      <methodname>operator()</methodname> take <type>Loc&lt;1&gt;</type>
      or one &int; parameter.  In addition, the one-dimensional domain
      can be dynamically resized using <methodname>create</methodname>
!     and <methodname>destroy</methodname>; see .  
  
  HERE Dynamic. How does one change the domain size?  What is the model?</para>
  
--- 641,647 ----
      <methodname>operator()</methodname> take <type>Loc&lt;1&gt;</type>
      or one &int; parameter.  In addition, the one-dimensional domain
      can be dynamically resized using <methodname>create</methodname>
!     and <methodname>destroy</methodname>; see .
  
  HERE Dynamic. How does one change the domain size?  What is the model?</para>
  
*************** HERE Dynamic. How does one change the do
*** 696,708 ****
--- 717,780 ----
    <chapter id="views">
     <title>Container Views</title>
  
+    <indexterm zone="views">
+     <primary>container</primary>
+     <secondary>view</secondary>
+    </indexterm>
+    <indexterm>
+     <primary>view of a container</primary>
+     <see>container, view.</see>
+    </indexterm>
+ 
+ <![%temporary;[
+ 
+    <para>A <glossterm linkend="glossary-view"><firstterm>view of a
+    container&nbsp;&container;</firstterm></glossterm> is a container
+    accessing a subset of &container;'s domain&nbsp;&containerdomain;
+    and values.  The subset can include all of&nbsp;&containerdomain;.
+    A <quote>view</quote> is so named because it is a different way to
+    access, or view, another container's values.  Both the container
+    and its view share the same underlying engine so changing values in
+    one also changes them in the other.</para>
+ 
+    <para>A view is created by following a container's name by
+    parentheses containing a domain&nbsp;&containerdomain;.  For
+    example, consider this code extracted from <xref
+    linkend="tutorial-array_parallel-doof2d"></xref> in <xref
+    linkend="tutorial-array_data_parallel"></xref>.
+ <programlisting>
+ Interval<1> N(0, n-1);
+ Interval<2> vertDomain(N, N);
+ Interval<1> I(1,n-2);
+ Interval<1> J(1,n-2);
+ Array<2, double, Brick> a(vertDomain);
+ Array<2, double, Brick> b(vertDomain);
+ a(I,J) = (1.0/9.0) *
+   (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+    b(I  ,J+1) + b(I  ,J  ) + b(I  ,J-1) +
+    b(I-1,J+1) + b(I-1,J  ) + b(I-1,J-1));
+ </programlisting>  The last statement creates ten views.  For example,
+ 
+    <statement>a(I,J)</statement> creates a view of
+    <varname>a</varname> using the smaller domain specified by
+    <varname>I</varname> and <varname>J</varname>.  This omits the
+    outermost rows of columns of&nbsp;<varname>a</varname>.  The views
+    of <varname>b</varname> illustrate the use of views in
+    data-parallel statements.  <statement>b(I-1,J-1)</statement> has a
+    subset shifted up one row and left one column compared with
+    <statement>b(I,J)</statement>.</para>
+ ]]>  <!-- end temporary -->
+ <![%unfinished;[
     <para>Be sure to list the various arithmetic operations on domains
     that can be used.  This was deferred from the &array; and domain
     chapter.  Explain &array;'s <function>comp</function> function.</para>
  
  <!-- FIXME: Finish this chapter. -->
+ ]]>  <!-- end unfinished -->
    </chapter>
  
+ 
+ <![%unfinished;[
    <chapter id="sequential">
     <title>Writing Sequential Programs</title>
  
*************** UNFINISHED</para>
*** 1086,1095 ****
      dependence computations, so the &author; recommends calling
      <function>Pooma::blockAndEvaluate</function> before each access to
      a particular value in an &array; or &field;.  Omitting a necessary
!     call may lead to a race condition.  See <xref
      linkend="debugging_profiling-missing_blockandevaluate"></xref> for
      instructions how to diagnose and eliminate these race
!     conditions.</para>
  
      <para>Where talk about various &pooma; streams?</para>
  
--- 1158,1171 ----
      dependence computations, so the &author; recommends calling
      <function>Pooma::blockAndEvaluate</function> before each access to
      a particular value in an &array; or &field;.  Omitting a necessary
!     call may lead to a race condition.
! <![%unfinished;[
!     See <xref
      linkend="debugging_profiling-missing_blockandevaluate"></xref> for
      instructions how to diagnose and eliminate these race
!     conditions.
! ]]>  <!-- end unfinished -->
! </para>
  
      <para>Where talk about various &pooma; streams?</para>
  
*************** UNFINISHED</para>
*** 1193,1199 ****
        in the input domain: A(i1, i2, ..., iN).</para>
  
       <para>The &pooma; multidimensional Array concept is similar to
!       the &fortran; 90 array facility, but extends it in several
        ways. Both &pooma; and &fortran; arrays can have up to seven
        dimensions, and can serve as containers for arbitrary
        types. Both support the notion of views of a portion of the
--- 1269,1275 ----
        in the input domain: A(i1, i2, ..., iN).</para>
  
       <para>The &pooma; multidimensional Array concept is similar to
!       the &fortran;&nbsp;90 array facility, but extends it in several
        ways. Both &pooma; and &fortran; arrays can have up to seven
        dimensions, and can serve as containers for arbitrary
        types. Both support the notion of views of a portion of the
*************** UNFINISHED</para>
*** 1492,1498 ****
      &pooma;&nbsp;II's expression trees and expression engines.</para>
  
      <variablelist>
!      <varlistentry><term><type>MultiPatch</type> Engine</term>
        <listitem><para>From <filename
        class="libraryfile">README</filename>: To actually use multiple
        contexts effectively, you need to use the MultiPatch engine with
--- 1568,1574 ----
      &pooma;&nbsp;II's expression trees and expression engines.</para>
  
      <variablelist>
!      <varlistentry><term>&multipatch; Engine</term>
        <listitem><para>From <filename
        class="libraryfile">README</filename>: To actually use multiple
        contexts effectively, you need to use the MultiPatch engine with
*************** UNFINISHED</para>
*** 1508,1515 ****
--- 1584,1593 ----
  
     </section>
    </chapter>
+ ]]>  <!-- end unfinished -->
  
  
+ <![%unfinished;[
    <chapter id="parallel">
     <title>Writing Distributed Programs</title>
  
*************** UNFINISHED</para>
*** 1562,1569 ****
--- 1640,1649 ----
     </section>
  
    </chapter>
+ ]]>  <!-- end unfinished -->
  
  
+ <![%unfinished;[
    <chapter id="debugging_profiling">
     <title>Debugging and Profiling &pooma; Programs</title>
  
*************** UNFINISHED</para>
*** 1607,1615 ****
--- 1687,1700 ----
        region's size should reveal where calls are missing.</para>
      </section>
    </chapter>
+ ]]>  <!-- end unfinished -->
+ 
  
+ <![%unfinished;[
   </part>
+ ]]>  <!-- end unfinished -->
  
+ <![%unfinished;[
   <part id="reference">
    <title>&pooma; Reference Manual</title>
  
*************** UNFINISHED</para>
*** 3489,3496 ****
--- 3574,3583 ----
     </itemizedlist>
    </chapter>
   </part>
+ ]]>  <!-- end unfinished -->
  
  
+ <![%unfinished;[
   <appendix id="future_development">
    <title>Future Development</title>
  
*************** UNFINISHED</para>
*** 3610,3615 ****
--- 3697,3703 ----
    </section>
  
   </appendix>
+ ]]>  <!-- end unfinished -->
  
  
   <appendix id="installation">
*************** UNFINISHED</para>
*** 3644,3650 ****
       <orderedlist spacing="compact">
  	<listitem>
  	 <para>Download the library from the &pooma; Download page
!          available off the &pooma; home page (&poomaHomePage;).</para>
  	</listitem>
  	<listitem>
  	 <para>Extract the source code using <command>tar xzvf
--- 3732,3738 ----
       <orderedlist spacing="compact">
  	<listitem>
  	 <para>Download the library from the &pooma; Download page
!          available off the &pooma; home page (&poomahomepage;).</para>
  	</listitem>
  	<listitem>
  	 <para>Extract the source code using <command>tar xzvf
*************** UNFINISHED</para>
*** 3715,3721 ****
       <orderedlist spacing="compact">
        <listitem>
         <para>Download the library from the &pooma; Download page
!        available off the &pooma; home page (&poomaHomePage;).</para>
        </listitem>
        <listitem>
         <para>Extract the source code using <command>tar xzvf
--- 3803,3809 ----
       <orderedlist spacing="compact">
        <listitem>
         <para>Download the library from the &pooma; Download page
!        available off the &pooma; home page (&poomahomepage;).</para>
        </listitem>
        <listitem>
         <para>Extract the source code using <command>tar xzvf
*************** UNFINISHED</para>
*** 3863,3868 ****
--- 3951,3957 ----
   </appendix>
  
  
+ <![%unfinished;[
   <appendix id="compilation_errors">
    <title>Dealing with Compilation Errors</title>
  
*************** UNFINISHED</para>
*** 4039,4044 ****
--- 4128,4134 ----
    </section>
  
   </appendix>
+ ]]>  <!-- end unfinished -->
  
  
   &bibliography-chapter;
Index: template.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/template.xml,v
retrieving revision 1.1
diff -c -p -r1.1 template.xml
*** template.xml	2002/01/14 17:33:34	1.1
--- template.xml	2002/01/24 04:56:39
***************
*** 1,7 ****
    <chapter id="template_programming">
     <title>Programming with Templates</title>
  
!    <para>&pooma; extensively uses &cc; templates to support type
     polymorphism without incurring any run-time cost.  In this chapter,
     we briefly introduce using templates in &cc; programs by relating
     them to <quote>ordinary</quote> &cc; constructs such as values,
--- 1,16 ----
    <chapter id="template_programming">
     <title>Programming with Templates</title>
  
!    <indexterm zone="template_programming">
!     <primary>templates</primary>
!    </indexterm>
!    <indexterm>
!     <primary>template programming</primary>
!     <see>templates</see>
!    </indexterm>
! 
!    <para>&pooma; extensively uses &cc; <glossterm
!    linkend="glossary-template">template</glossterm>s to support type
     polymorphism without incurring any run-time cost.  In this chapter,
     we briefly introduce using templates in &cc; programs by relating
     them to <quote>ordinary</quote> &cc; constructs such as values,
***************
*** 9,69 ****
     templates will occur repeatedly:
     <itemizedlist>
       <listitem>
!       <para>Template programming occurs at compile time, not run time.
!       That is, template operations occur within the compiler, not when
!       a program runs.</para>
       </listitem>
       <listitem>
!       <para>Templates permit declaring families of classes using a
!       single declaration.  For example, the &array; template
!       declaration permits using arrays with many different value
        types, e.g., arrays of integers, arrays of floating point
        numbers, and arrays of arrays.</para>
      </listitem>
     </itemizedlist>
!    For those interested in the implementation of &pooma;, we close
!    with a discussion of some template programming concepts used in the
!    implementation but not likely to be used by &pooma; users.</para>
  
  
     <section id="template_programming-compile_time">
!     <title>Templates Occur at Compile-Time</title>
  
      <para>&pooma; uses &cc; templates to support type polymorphism
      without incurring any run-time cost as a program executes.  All
      template operations are performed at compile time by the
      compiler.</para>
  
!     <para>Prior to the introduction of templates, almost all a
      program's interesting computation occurred when it was executed.
      When writing the program, the programmer, at <glossterm
      linkend="glossary-programming_time"><firstterm>programming
!     time</firstterm></glossterm>, would specify which statements and
!     expressions would occur and which types to use.  At <glossterm
      linkend="glossary-compile_time"><firstterm>compile
      time</firstterm></glossterm>, the compiler would convert the
      program's source code into an executable program.  Even though the
      compiler uses the types to produce the executable, no interesting
      computation would occur.  At <glossterm
      linkend="glossary-run_time"><firstterm>run
!     time</firstterm></glossterm>, the resulting executable program
      would actually perform the operations.</para>
  
      <para>The introduction of templates permits interesting
      computation to occur while the compiler produces the executable.
!     Most interesting is template instantiation, which produces a type
      at compile time.  For example, the &array; <quote>type</quote>
      definition requires template parameters <varname>Dim</varname>,
      <varname>T</varname>, and <varname>EngineTag</varname>, specifying
!     its dimension, the type of its elements, and its &engine; type.  To
      use this, a programmer specifies values for the template
      parameters:
      <statement><type>Array&lt;2,double,Brick&gt;</type></statement>
!     specifies a dimension of 2, an element type of &double;, and the
!     &brick; &engine; type.  At compile time, the compiler creates a type
!     definition by substituting the values for the template parameters
!     in the template definition.  The substitution is analogous to the
!     run-time application of a function to specific values.</para>
  
      <para>All computation not involving run-time input or output can
      occur at program time, compile time, or run time, whichever is
--- 18,107 ----
     templates will occur repeatedly:
     <itemizedlist>
       <listitem>
!       <para>Template programming constructs execute at compile time,
!       not run time.  That is, template operations occur within the
!       compiler, not when a program runs.</para>
       </listitem>
       <listitem>
!       <para id="template_programming-introduction-main_uses-type_polymorphism">Templates permit declaring families of classes using a
!       single declaration.  For example, the &array;
!       <indexterm>
!        <primary>&array;</primary>
!       </indexterm>
!       <indexterm zone="template_programming-introduction-main_uses-type_polymorphism">
!        <primary>type polymorphism</primary>
!       </indexterm>
!       template
!       declaration permits using &array;s with many different value
        types, e.g., arrays of integers, arrays of floating point
        numbers, and arrays of arrays.</para>
      </listitem>
     </itemizedlist>
!    For those interested in the implementation of &pooma;, we close the
!    section with a discussion of some template programming concepts
!    used in the implementation but not likely to be used by &pooma;
!    users.</para>
  
  
     <section id="template_programming-compile_time">
!     <title>Templates Execute at Compile-Time</title>
! 
!     <indexterm zone="template_programming-compile_time">
!      <primary>compile time</primary>
!     </indexterm>
!     <indexterm zone="template_programming-compile_time">
!      <primary>compiler</primary>
!     </indexterm>
  
      <para>&pooma; uses &cc; templates to support type polymorphism
      without incurring any run-time cost as a program executes.  All
      template operations are performed at compile time by the
      compiler.</para>
  
!     <para>Prior to the introduction of templates, almost all of a
      program's interesting computation occurred when it was executed.
      When writing the program, the programmer, at <glossterm
      linkend="glossary-programming_time"><firstterm>programming
!     time</firstterm></glossterm>,
!     <indexterm>
!      <primary>programming time</primary>
!     </indexterm>
!     would specify which statements and expressions will occur and
!     which types to use.  At <glossterm
      linkend="glossary-compile_time"><firstterm>compile
      time</firstterm></glossterm>, the compiler would convert the
      program's source code into an executable program.  Even though the
      compiler uses the types to produce the executable, no interesting
      computation would occur.  At <glossterm
      linkend="glossary-run_time"><firstterm>run
!     time</firstterm></glossterm>,
!     <indexterm>
!      <primary>run time</primary>
!     </indexterm>
!     the resulting executable program
      would actually perform the operations.</para>
  
      <para>The introduction of templates permits interesting
      computation to occur while the compiler produces the executable.
!     Most interesting is template instantiation,
!     <indexterm>
!      <primary>template</primary>
!      <secondary>instantiation</secondary>
!     </indexterm>
!     which produces a type
      at compile time.  For example, the &array; <quote>type</quote>
      definition requires template parameters <varname>Dim</varname>,
      <varname>T</varname>, and <varname>EngineTag</varname>, specifying
!     its dimension, the type of its values, and its &engine; type.  To
      use this, a programmer specifies values for the template
      parameters:
      <statement><type>Array&lt;2,double,Brick&gt;</type></statement>
!     specifies a dimension of 2, a value type of &double;, and the
!     &brick; &engine; type.  At compile time, the compiler creates a
!     type definition by substituting the values for the template
!     parameters in the templatized type definition.  The substitution
!     is analogous to the run-time application of a function to specific
!     values.</para>
  
      <para>All computation not involving run-time input or output can
      occur at program time, compile time, or run time, whichever is
***************
*** 71,83 ****
      computations by hand rather than writing code to compute it.  &cc;
      templates are Turing-complete so they can compute anything
      computable.  Unfortunately, syntax for compile-time computation is
!     more difficult than for run-time computation, and also current
      compilers are not as efficient as code executed by hardware.
!     Run-time &cc; constructs are Turing-complete so using templates is
      unnecessary.  Thus, we can shift computation to the time which
      best trades off the ease of expressing syntax with the speed of
      computation by programmer, compiler, or computer chip.  For
!     example, &pooma; uses expression template technology to speed
      run-time execution of data-parallel statements.  The &pooma;
      developers decided to shift some of the computation from run-time
      to compile-time using template computations.  The resulting
--- 109,129 ----
      computations by hand rather than writing code to compute it.  &cc;
      templates are Turing-complete so they can compute anything
      computable.  Unfortunately, syntax for compile-time computation is
!     more difficult than for run-time computation.  Also current
      compilers are not as efficient as code executed by hardware.
!     Run-time &cc; constructs are Turing-complete
!     <indexterm>
!      <primary>Turing complete</primary>
!     </indexterm>
!     so using templates is
      unnecessary.  Thus, we can shift computation to the time which
      best trades off the ease of expressing syntax with the speed of
      computation by programmer, compiler, or computer chip.  For
!     example, &pooma; uses expression template technology
!     <indexterm>
!      <primary>expression templates</primary>
!     </indexterm>
!     to speed
      run-time execution of data-parallel statements.  The &pooma;
      developers decided to shift some of the computation from run-time
      to compile-time using template computations.  The resulting
***************
*** 100,111 ****
         parameters, both of which are used in this book.</para>
        </listitem>
        <listitem>
!        <para>template instantiation, i.e., specifying a particular
!        type by specifying values for template parameters.</para>
        </listitem>
        <listitem>
!        <para>nested type names, which are types specified within a
!        class definition.</para>
        </listitem>
       </itemizedlist>
      We discuss each of these below.</para>
--- 146,170 ----
         parameters, both of which are used in this book.</para>
        </listitem>
        <listitem>
!        <para>template instantiation,
!        <indexterm>
! 	<primary>template</primary>
! 	<secondary>instantiation</secondary>
!        </indexterm>
!        i.e., specifying a particular type by specifying values for
!        template parameters.</para>
        </listitem>
        <listitem>
!        <para>nested type names,
!        <indexterm>
! 	<primary>nested type</primary>
! 	<see>type, nested.</see>
!        </indexterm>
!        <indexterm>
! 	<primary>type</primary>
! 	<secondary>nested</secondary>
!        </indexterm>
!        which are types specified within a class definition.</para>
        </listitem>
       </itemizedlist>
      We discuss each of these below.</para>
***************
*** 174,179 ****
--- 233,242 ----
      brackets&nbsp;(<statement>&lt;&gt;</statement>).  For example,
      <type>pair&lt;int&gt;</type> <glossterm
      linkend="glossary-template_instantiation"><firstterm>instantiates</firstterm></glossterm>
+     <indexterm>
+      <primary>template</primary>
+      <secondary>instantiation</secondary>
+     </indexterm>
      the <classname>pair</classname> template class definition with
      <varname>T</varname> equal to &int;.  That is, the compiler
      creates a definition for <type>pair&lt;int&gt;</type> by copying
***************
*** 184,193 ****
      The result is a definition exactly the same as
      <classname>pairOfInts</classname>.</para>
  
!      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	    orient="port" pgwide="0"
! 	    id="template_programming-template_use-correspondence_table">
!       <title>Correspondences Between Run-Time and Compile-Time
       Programming Constructs</title>
        
        <tgroup cols="3" align="left">
--- 247,286 ----
      The result is a definition exactly the same as
      <classname>pairOfInts</classname>.</para>
  
!     <para>As we mentioned above, template instantiation
!     <indexterm>
!      <primary>template</primary>
!      <secondary>instantiation</secondary>
!     </indexterm>
!     is analogous to function application.
!     <indexterm>
!      <primary>function</primary>
!      <secondary>application</secondary>
!     </indexterm>
!     A template class is analogous to a
!     function.  The analogy between compile-time and run-time
!     programming constructs can be extended.  <xref
!     linkend="template_programming-template_use-correspondence_table"></xref>
!     lists these correspondences.  For example, at run time, values
!     consist of things such as integers, floating point numbers,
!     pointers, functions, and objects.  Programs compute by operating
!     on these values.  The compile-time values
!     <indexterm>
!      <primary>compile time</primary>
!      <secondary>value</secondary>
!     </indexterm>
!     include types, and
!     compile-time operations use these types.  For both run-time and
!     compile-time programming, &cc; defines default sets of values that
!     all conforming compilers must support.  For example,
!     <statement>3</statement> and <statement>6.022e+23</statement> are
!     run-time values that any &cc; compiler must accept.  It must also
!     accept the &int;, &bool;, and <type>int*</type> types.</para>
! 
!     <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	   orient="port" pgwide="0"
! 	   id="template_programming-template_use-correspondence_table">
!      <title>Correspondences Between Run-Time and Compile-Time
       Programming Constructs</title>
        
        <tgroup cols="3" align="left">
***************
*** 198,204 ****
  	 <entry>compile time</entry>
  	</row>
         </thead>
!        <tbody>
  	<row>
  	 <entry>values</entry>
  	 <entry>integers, strings, objects, functions, &hellip;</entry>
--- 291,297 ----
  	 <entry>compile time</entry>
  	</row>
         </thead>
!        <tbody valign="top">
  	<row>
  	 <entry>values</entry>
  	 <entry>integers, strings, objects, functions, &hellip;</entry>
***************
*** 222,236 ****
  	</row>
  	<row>
  	 <entry>packaging repeated operations</entry>
! 	 <entry>A function generalizes a particular operation applied to
! 	different values.  The function parameters are placeholders
! 	for particular values.</entry>
! 	 <entry>A template class generalizes a particular class
! 	definition using different types.  The template parameters are
! 	placeholders for particular values.</entry>
  	</row>
  	<row>
! 	 <entry>application</entry>
  	 <entry>Use a function by appending function arguments
  	surrounded by parentheses.</entry>
  	 <entry>Use a template class by appending template arguments
--- 315,342 ----
  	</row>
  	<row>
  	 <entry>packaging repeated operations</entry>
! 	 <entry>A function
!          <indexterm>
!           <primary>function</primary>
!          </indexterm>
!          generalizes a particular operation applied to different
!          values.  The function parameters are placeholders for
!          particular values.</entry>
!          <entry>A template class generalizes a particular class
!          definition using different types.  The template parameters
!          are placeholders for particular values.</entry>
  	</row>
  	<row>
! 	 <entry>application
!          <indexterm>
!           <primary>function</primary>
!           <secondary>application</secondary>
!          </indexterm>
!          <indexterm>
!           <primary>application</primary>
!           <see>function, application.</see>
!          </indexterm>
!          </entry>
  	 <entry>Use a function by appending function arguments
  	surrounded by parentheses.</entry>
  	 <entry>Use a template class by appending template arguments
***************
*** 239,262 ****
         </tbody>
        </tgroup>
       </table>
- 
-     <para>As we mentioned above, template instantiation is analogous
-     to function application.  A template class is analogous to a
-     function.  The analogy between compile-time and run-time
-     programming constructs can be extended.  <xref
-     linkend="template_programming-template_use-correspondence_table"></xref>
-     lists these correspondences.  For example, at run time, values
-     consist of things such as integers, floating point numbers,
-     pointers, functions, and objects.  Programs compute by operating
-     on these values.  The compile-time values include types, and
-     compile-time operations use these types.  For both run-time and
-     compile-time programming, &cc; defines default sets of values that
-     all conforming compilers must support.  For example,
-     <statement>3</statement> and <statement>6.022e+23</statement> are
-     run-time values that any &cc; compiler must accept.  It must also
-     accept the &int;, &bool;, and <type>int*</type> types.</para>
  
!     <para>The set of supported run-time and compile-time values can be
      extended.  Run-time values can be extended by creating new
      objects.  Although not part of the default set of values, these
      objects are treated and operated on as values.  To extend the set
--- 345,359 ----
         </tbody>
        </tgroup>
       </table>
  
!     <para id="template_programming-template_use-extensions">
!     <indexterm zone="template_programming-template_use-extensions">
!      <primary>object</primary>
!     </indexterm>
!     <indexterm zone="template_programming-template_use-extensions">
!      <primary>class definition</primary>
!     </indexterm>
!     The set of supported run-time and compile-time values can be
      extended.  Run-time values can be extended by creating new
      objects.  Although not part of the default set of values, these
      objects are treated and operated on as values.  To extend the set
***************
*** 268,282 ****
      built-in types, these types can be used in the same way that any
      other types can be used, e.g., declaring variables.</para>
  
!     <para>Functions generalize similar run-time operations, while
      template class generalize similar class definitions.  A function
      definition generalizes a repeated run-time operation.  For
      example, consider repeatedly printing the largest of two numbers:
  <programlisting>
! std::cout << (3 &gt; 4 ? 3 : 4) << std::endl;
! std::cout << (4 &gt; -13 ? 4 : -13) << std::endl;
! std::cout << (23 &gt; 4 ? 23 : 4) << std::endl;
! std::cout << (0 &gt; 3 ? 0 : 3) << std::endl;
  </programlisting>  Each statement is exactly the same except for the
  repeated two values.  Thus, we can generalize these statements writing
  a function:
--- 365,383 ----
      built-in types, these types can be used in the same way that any
      other types can be used, e.g., declaring variables.</para>
  
!     <para id="template_programming-template_use-functions">
!     <indexterm zone="template_programming-template_use-functions">
!      <primary>function</primary>
!     </indexterm>
!     Functions generalize similar run-time operations, while
      template class generalize similar class definitions.  A function
      definition generalizes a repeated run-time operation.  For
      example, consider repeatedly printing the largest of two numbers:
  <programlisting>
! std::cout &openopen; (3 &gt; 4 ? 3 : 4) &openopen; std::endl;
! std::cout &openopen; (4 &gt; -13 ? 4 : -13) &openopen; std::endl;
! std::cout &openopen; (23 &gt; 4 ? 23 : 4) &openopen; std::endl;
! std::cout &openopen; (0 &gt; 3 ? 0 : 3) &openopen; std::endl;
  </programlisting>  Each statement is exactly the same except for the
  repeated two values.  Thus, we can generalize these statements writing
  a function:
*************** void maxOut(int a, int b)
*** 285,294 ****
  { std::cout &openopen; (a > b ? a : b) &openopen; std::endl; }
  </programlisting>  The function's body consists of the statement with
  variables substituted for the two particular values.  Each parameter
! is a placeholder that, when used, holds one particular value among the
! set of possible integral values.  The function must be named to permit
! its use, and declarations for its two parameters follow.  Using the
! function simplifies the code:
  <programlisting>
  maxOut(3, 4);
  maxOut(4, -13);
--- 386,395 ----
  { std::cout &openopen; (a > b ? a : b) &openopen; std::endl; }
  </programlisting>  The function's body consists of the statement with
  variables substituted for the two particular values.  Each parameter
! variable is a placeholder that, when used, holds one particular value
! among the set of possible integral values.  The function must be named
! to permit its use, and declarations for its two parameters follow.
! Using the function simplifies the code:
  <programlisting>
  maxOut(3, 4);
  maxOut(4, -13);
*************** maxOut(0, 3);
*** 298,306 ****
      parentheses surrounding specific values for its parameters, but
      the function's return type is omitted.</para>
  
!     <para>A template class definition generalizes repeated class
      definitions.  If two class definitions differ only in a few types,
!     template parameters can be substituted.  Each parameter is a
      placeholder that, when used, holds one particular value, i.e.,
      type, among the set of possible values.  The class definition is
      named to permit its use, and declarations for its parameters
--- 399,417 ----
      parentheses surrounding specific values for its parameters, but
      the function's return type is omitted.</para>
  
!     <para id="template_programming-template_use-template_class">
!     <indexterm zone="template_programming-template_use-template_class">
!      <primary>template</primary>
!      <secondary>definition</secondary>
!     </indexterm>
!     A template class definition generalizes repeated class
      definitions.  If two class definitions differ only in a few types,
!     template parameters
!     <indexterm>
!      <primary>template</primary>
!      <secondary>parameter</secondary>
!     </indexterm>
!     can be substituted.  Each parameter is a
      placeholder that, when used, holds one particular value, i.e.,
      type, among the set of possible values.  The class definition is
      named to permit its use, and declarations for its parameters
*************** maxOut(0, 3);
*** 313,323 ****
      Note the notation for the template class parameters.
      <statement>template &lt;typename T&gt;</statement>
      <emphasis>precedes</emphasis> the class definition.  The keyword
!     <keywordname>typename</keywordname> indicates the template
      parameter is a type.  <varname>T</varname>&nbsp;is the template
      parameter's name.  (We could have used any other identifier such
      as <varname>pairElementType</varname> or <varname>foo</varname>.)
!     Note that using <keywordname>class</keywordname> is equivalent to
      using <keywordname>typename</keywordname> so <statement>template
      &lt;class T&gt;</statement> is equivalent to <statement>template
      &lt;typename T&gt;</statement>.  While declaring a template class
--- 424,442 ----
      Note the notation for the template class parameters.
      <statement>template &lt;typename T&gt;</statement>
      <emphasis>precedes</emphasis> the class definition.  The keyword
!     <keywordname>typename</keywordname>
!     <indexterm>
!      <primary><keywordname>typename</keywordname></primary>
!     </indexterm>
!     indicates the template
      parameter is a type.  <varname>T</varname>&nbsp;is the template
      parameter's name.  (We could have used any other identifier such
      as <varname>pairElementType</varname> or <varname>foo</varname>.)
!     Note that using <keywordname>class</keywordname>
!     <indexterm>
!      <primary><keywordname>class</keywordname></primary>
!     </indexterm>
!     is equivalent to
      using <keywordname>typename</keywordname> so <statement>template
      &lt;class T&gt;</statement> is equivalent to <statement>template
      &lt;typename T&gt;</statement>.  While declaring a template class
*************** maxOut(0, 3);
*** 327,336 ****
      for its parameters.  As we showed above,
      <statement>pair&lt;int&gt;</statement> <glossterm
      linkend="glossary-template_instantiation">instantiates</glossterm>
      the template class <classname>pair</classname> with &int; for its
      type parameter&nbsp;<varname>T</varname>.</para>
  
!     <para>In template programming, nested type names store
      compile-time data that can be used within template classes.  Since
      compile-time class definitions are analogous to run-time objects
      and the latter stores named values, nested type names are values,
--- 446,468 ----
      for its parameters.  As we showed above,
      <statement>pair&lt;int&gt;</statement> <glossterm
      linkend="glossary-template_instantiation">instantiates</glossterm>
+     <indexterm>
+      <primary>template</primary>
+      <secondary>instantiation</secondary>
+     </indexterm>
      the template class <classname>pair</classname> with &int; for its
      type parameter&nbsp;<varname>T</varname>.</para>
  
!     <para id="template_programming-template_use-nested_types">
!     <indexterm zone="template_programming-template_use-nested_types">
!      <primary>type</primary>
!      <secondary>nested</secondary>
!     </indexterm>
!     <indexterm>
!      <primary>nested type</primary>
!      <see>type, nested.</see>
!     </indexterm>
!     In template programming, nested type names store
      compile-time data that can be used within template classes.  Since
      compile-time class definitions are analogous to run-time objects
      and the latter stores named values, nested type names are values,
*************** maxOut(0, 3);
*** 338,349 ****
      template class &array; has an nested type name for the type of its
      domain:
  <programlisting>
! 		 typedef typename Engine_t::Domain_t Domain_t;
! </programlisting> This <keywordname>typedef</keywordname>, i.e., type
      definition, defines the type <type>Domain_t</type> as equivalent
      to <type>Engine_t::Domain_t</type>.  The
!     <operator>::</operator>&nbsp;operator selects the
!     <type>Domain_t</type> nested type from inside the
      <type>Engine_t</type> type.  This illustrates how to access
      &array;'s <type>Domain_t</type> when not within &array;'s scope:
      <type>Array&lt;Dim, T, EngineTag&gt;::Domain_t</type>.  The
--- 470,493 ----
      template class &array; has an nested type name for the type of its
      domain:
  <programlisting>
! typedef typename Engine_t::Domain_t Domain_t;
! </programlisting> This <keywordname>typedef</keywordname>,
!     <indexterm>
!      <primary><keywordname>typedef</keywordname></primary>
!      <see>type, definition.</see>
!     </indexterm>
!     <indexterm>
!      <primary>type</primary>
!      <secondary>definition</secondary>
!     </indexterm>
!     i.e., type
      definition, defines the type <type>Domain_t</type> as equivalent
      to <type>Engine_t::Domain_t</type>.  The
!     <operator>::</operator>&nbsp;operator
!     <indexterm>
!      <primary><operator>::</operator>&nbsp;operator</primary>
!     </indexterm>
!     selects the <type>Domain_t</type> nested type from inside the
      <type>Engine_t</type> type.  This illustrates how to access
      &array;'s <type>Domain_t</type> when not within &array;'s scope:
      <type>Array&lt;Dim, T, EngineTag&gt;::Domain_t</type>.  The
*************** maxOut(0, 3);
*** 363,371 ****
      &poomatoolkit;.  In this section, we present template programming
      techniques used to implement &pooma;.  We extend the
      correspondence between compile-time template programming
!     constructs and run-time constructs.  Reading this section is not
!     necessary unless you wish to understand how &pooma; is
!     implemented.</para>
  
      <para>In the previous section, we used a correspondence between
      run-time and compile-time programming constructs to introduce
--- 507,515 ----
      &poomatoolkit;.  In this section, we present template programming
      techniques used to implement &pooma;.  We extend the
      correspondence between compile-time template programming
!     constructs and run-time constructs started in the previous
!     section.  Reading this section is not necessary unless you wish to
!     understand how &pooma; is implemented.</para>
  
      <para>In the previous section, we used a correspondence between
      run-time and compile-time programming constructs to introduce
*************** maxOut(0, 3);
*** 390,396 ****
  	<entry>compile time</entry>
         </row>
        </thead>
!       <tbody>
         <row>
  	<entry>values</entry>
  	<entry>integers, strings, objects, functions, &hellip;</entry>
--- 534,540 ----
  	<entry>compile time</entry>
         </row>
        </thead>
!       <tbody valign="top">
         <row>
  	<entry>values</entry>
  	<entry>integers, strings, objects, functions, &hellip;</entry>
*************** maxOut(0, 3);
*** 414,430 ****
  	<entry>values stored in a collection</entry>
  	<entry>An object stores values.</entry>
  	<entry>A <glossterm linkend="glossary-traits_class">traits
! 	class</glossterm> contains values describing a type.</entry>
         </row>
         <row>
  	<entry>extracting values from collections</entry>
  	<entry>An object's named values are extracted using the
! 	<operator>.</operator>&nbsp;operator</entry>
  	<entry>A class's nested types and classes are extracted using
! 	the <operator>::</operator>&nbsp;operator.</entry>
         </row>
         <row>
! 	<entry>control flow to choose among operations</entry>
  	<entry><keywordname>if</keywordname>, <keywordname>while</keywordname>, <keywordname>goto</keywordname>, &hellip;</entry>
  	<entry>template class specializations with pattern matching</entry>
         </row>
--- 558,595 ----
  	<entry>values stored in a collection</entry>
  	<entry>An object stores values.</entry>
  	<entry>A <glossterm linkend="glossary-traits_class">traits
! 	class</glossterm>
!         <indexterm>
!          <primary>traits class</primary>
!         </indexterm>
!         <indexterm>
!          <primary>class</primary>
!          <secondary>traits</secondary>
!          <see>traits class</see>
!         </indexterm>
!         contains values describing a type.</entry>
         </row>
         <row>
  	<entry>extracting values from collections</entry>
  	<entry>An object's named values are extracted using the
! 	<operator>.</operator>&nbsp;operator.
!         <indexterm>
!          <primary><operator>.</operator>&nbsp;operator</primary>
!         </indexterm>
!         </entry>
  	<entry>A class's nested types and classes are extracted using
! 	the <operator>::</operator>&nbsp;operator.
!         <indexterm>
!          <primary><operator>::</operator>&nbsp;operator</primary>
!         </indexterm>
!         </entry>
         </row>
         <row>
! 	<entry>control flow
!         <indexterm>
!          <primary>control flow</primary>
!         </indexterm>
!         to choose among operations</entry>
  	<entry><keywordname>if</keywordname>, <keywordname>while</keywordname>, <keywordname>goto</keywordname>, &hellip;</entry>
  	<entry>template class specializations with pattern matching</entry>
         </row>
*************** maxOut(0, 3);
*** 432,444 ****
       </tgroup>
      </table>
  
!     <para>The only compile-time value described in the previous
!     section was types, but any compile-time constant can also be used.
      Integral literals, <keywordname>const</keywordname> variables, and
      other constructs can be used, but the main use is enumerations.
      An <glossterm
      linkend="glossary-enumeration"><firstterm>enumeration</firstterm></glossterm>
!     enumeration is a distinct integral type with named constants.  For
      example, the &array; declaration declares two separate
      enumerations:
  <programlisting>
--- 597,619 ----
       </tgroup>
      </table>
  
!     <para>
!     <indexterm class="startofrange"
! 	       id="template_programming-pooma_implementation-index-enumeration">
!      <primary>enumeration</primary>
!     </indexterm>
!     <indexterm class="startofrange"
! 	       id="template_programming-pooma_implementation-index-compile_time_values">
!      <primary>compile time</primary>
!      <secondary>value</secondary>
!     </indexterm>
!     The only compile-time values described in the previous
!     section were types, but any compile-time constant can also be used.
      Integral literals, <keywordname>const</keywordname> variables, and
      other constructs can be used, but the main use is enumerations.
      An <glossterm
      linkend="glossary-enumeration"><firstterm>enumeration</firstterm></glossterm>
!     is a distinct integral type with named constants.  For
      example, the &array; declaration declares two separate
      enumerations:
  <programlisting>
*************** enum { dimensionPlusRank = dimensions + 
*** 480,502 ****
       </listitem>
      </itemizedlist>
      The use of non-integral constant values such as floating-point
!     numbers at compile time is restricted.</para>
! 
!     <para>Other compile-time values include pointers and references to
!     objects and functions and executable code.  For example, a pointer
!     to a function sometimes is passed to a template function to
!     perform a specific task.  Even though executable code cannot be
!     directly represented in a program, it is a compile-time value
!     which the compiler uses.  A simple example is a class that is
!     created by template instantiation, e.g.,
!     <type>pair&lt;int&gt;</type>.  Conceptually, the &int; template
      argument is substituted throughout the <type>pair</type> template
      class to produce a class definition.  Although neither the
      programmer nor the user sees this class definition, it is
      represented inside the compiler, which can use and manipulate the
      code.</para>
! 
!     <para>Through template programming, the compiler's optimizer can
      transform complicated code into much simpler code.  In <xref
      linkend="data_parallel-implementation"></xref>, we describe the
      complicated template code used to implement efficiently
--- 655,723 ----
       </listitem>
      </itemizedlist>
      The use of non-integral constant values such as floating-point
!     numbers at compile time is restricted.
!     <indexterm class="endofrange"
! 	       startref="template_programming-pooma_implementation-index-enumeration">
!     </indexterm>
!     </para>
! 
!     <para>Other compile-time values include pointers
!     <indexterm>
!      <primary>pointer</primary>
!     </indexterm>
!     to objects and
!     functions, references
!     <indexterm>
!      <primary>reference</primary>
!     </indexterm>
!     to objects and functions, and executable
!     code.  For example, a pointer to a function
!     <indexterm>
!      <primary>pointer</primary>
!      <secondary>function</secondary>
!     </indexterm>
!     <indexterm>
!      <primary>function pointer</primary>
!      <see>pointer, function.</see>
!     </indexterm>
!     sometimes is passed to
!     a template function to perform a specific task.  Even though
!     executable code
!     <indexterm>
!      <primary>executable code</primary>
!     </indexterm>
!     cannot be directly represented in a program, it is
!     a compile-time value which the compiler uses.  A simple example is
!     a class that is created by template instantiation,
!     <indexterm>
!      <primary>template</primary>
!      <secondary>instantiation</secondary>
!     </indexterm>
!     e.g., <type>pair&lt;int&gt;</type>.  Conceptually, the &int; template
      argument is substituted throughout the <type>pair</type> template
      class to produce a class definition.  Although neither the
      programmer nor the user sees this class definition, it is
      represented inside the compiler, which can use and manipulate the
      code.</para>
!     <indexterm class="endofrange"
! 	       startref="template_programming-pooma_implementation-index-compile_time_values">
!     </indexterm>
! 
!     <para id="template_programming-pooma_implementation-optimization">
!     Through template programming, the compiler's optimizer
!     <indexterm>
!      <primary>optimizer</primary>
!      <see>compiler, optimizer.</see>
!     </indexterm>
!     <indexterm>
!      <primary>optimization</primary>
!      <see>compiler, optimizer.</see>
!     </indexterm>
!     <indexterm zone="template_programming-pooma_implementation-optimization">
!      <primary>compiler</primary>
!      <secondary>optimizer</secondary>
!     </indexterm>
!     can
      transform complicated code into much simpler code.  In <xref
      linkend="data_parallel-implementation"></xref>, we describe the
      complicated template code used to implement efficiently
*************** struct usuallySimpleClass&lt;false&gt; {
*** 537,544 ****
      compilers that translate &cc; code into &c; code may permit
      inspecting the resulting code.  For example, using the
      <option>&dashdash;keep_gen_c</option> command-line option with the
!     KAI &cc; compiler<!-- FIXME: Reference or link? --> creates a file
!     containing the result of intermediate code.  Unfortunately,
      reading and understanding the code is frequently difficult.
      Perhaps future &cc; compilers will support easy inspection of
      optimized code.</para>
--- 758,775 ----
      compilers that translate &cc; code into &c; code may permit
      inspecting the resulting code.  For example, using the
      <option>&dashdash;keep_gen_c</option> command-line option with the
!     <application class="software">KAI &cc; compiler</application>
!     <!-- FIXME: Reference or link? -->
!     <indexterm>
!      <primary>compiler</primary>
!      <secondary>KAI</secondary>
!     </indexterm>
!     <indexterm>
!      <primary><application class="software">KAI &cc; compiler</application></primary>
!      <see>compiler, KAI.</see>
!     </indexterm>
!     creates a file
!     containing the intermediate code.  Unfortunately,
      reading and understanding the code is frequently difficult.
      Perhaps future &cc; compilers will support easy inspection of
      optimized code.</para>
*************** struct usuallySimpleClass&lt;false&gt; {
*** 550,556 ****
      <operator>&gt;</operator> and <operator>==</operator>.  At run
      time, the category of strings can be compared using
      <operator>==</operator> and characters can be extracted using
!     subscripts and the <operator>[]</operator> operator.  Compile-time
      operations are more limited.  Types may be declared and used.  The
      <keywordname>sizeof</keywordname> operator yields the number of
      bytes to represent an object of the specified type.  Enumerations,
--- 781,787 ----
      <operator>&gt;</operator> and <operator>==</operator>.  At run
      time, the category of strings can be compared using
      <operator>==</operator> and characters can be extracted using
!     subscripts with the <operator>[]</operator> operator.  Compile-time
      operations are more limited.  Types may be declared and used.  The
      <keywordname>sizeof</keywordname> operator yields the number of
      bytes to represent an object of the specified type.  Enumerations,
*************** struct usuallySimpleClass&lt;false&gt; {
*** 562,582 ****
      used as template arguments.  At compile time, pointers and
      references to objects and functions can be used as template
      arguments, while the category of executable code supports no
!     operations.  (The compiler's optimizer may simplify it,
!     though.)</para>
! 
!     <para>At run time, an object can store multiple values, each
      having its own name.  For example, a <type>pair&lt;int&gt;</type>
      object&nbsp;<varname>p</varname> stores two &int;s named
      <methodname>left_</methodname> and
      <methodname>right_</methodname>.  The <operator>.</operator>
!     operator extracts a named member from an object:
      <statement>p.left_</statement>.  At compile time, a class can
      store multiple values, each having its own name.  These are
      sometimes called <glossterm
      linkend="glossary-traits_class"><firstterm>traits
      classes</firstterm></glossterm>.  For example, implementing
!     data-parallel operations requiring storing the a tree of types.
      The <type>ExpressionTraits&lt;BinaryNode&lt;Op, Left,
      Right&closeclose;</type> traits class stores the types of a binary
      node representing the operation of <varname>Op</varname> on left
--- 793,829 ----
      used as template arguments.  At compile time, pointers and
      references to objects and functions can be used as template
      arguments, while the category of executable code supports no
!     operations.  (The compiler's optimizer
!     <indexterm>
!      <primary>compiler</primary>
!      <secondary>optimizer</secondary>
!     </indexterm>
!     may simplify it, though.)</para>
! 
!     <para id="template_programming-pooma_implementation-traits_class">
!     <indexterm zone="template_programming-pooma_implementation-traits_class">
!      <primary>traits class</primary>
!     </indexterm>
!     At run time, an object
!     <indexterm>
!      <primary>object</primary>
!     </indexterm>
!     can store multiple values, each
      having its own name.  For example, a <type>pair&lt;int&gt;</type>
      object&nbsp;<varname>p</varname> stores two &int;s named
      <methodname>left_</methodname> and
      <methodname>right_</methodname>.  The <operator>.</operator>
!     operator
!     <indexterm>
!      <primary><operator>.</operator>&nbsp;operator</primary>
!     </indexterm>
!     extracts a named member from an object:
      <statement>p.left_</statement>.  At compile time, a class can
      store multiple values, each having its own name.  These are
      sometimes called <glossterm
      linkend="glossary-traits_class"><firstterm>traits
      classes</firstterm></glossterm>.  For example, implementing
!     data-parallel operations requiring storing a tree of types.
      The <type>ExpressionTraits&lt;BinaryNode&lt;Op, Left,
      Right&closeclose;</type> traits class stores the types of a binary
      node representing the operation of <varname>Op</varname> on left
*************** struct ExpressionTraits&lt;BinaryNode&lt
*** 590,629 ****
    typedef typename CombineExpressionTraits&lt;Left_t, Right_t&gt;::Type_t Type_t;
  };
  </programlisting> consists of a class definition and internal type
! 
!     definitions.  This traits class contains three values, all types,
!     named <type>Left_t</type>, <type>Right_t</type>, and
      <type>Type_t</type>, representing the type of the left child, the
!     right child, and the entire node, respectively.  No enumerations
!     or constant values occur.  See <xref
      linkend="data_parallel-implementation"></xref> for more details
!     regarding the implementation of data-parallel operators.  Many
!     traits classes, such as this one, use internal type definitions to
!     store values.</para>
! 
!     <para>The example also illustrates using the
!     <operator>::</operator> operator to extract a member of a traits
!     class.  The type <type>ExpressionTraits&lt;Left&gt;</type>
!     contains an internal type definition of <type>Type_t</type>.
!     Using the <operator>::</operator> operator extracts it:
      <statement>ExpressionTraits&lt;Left&gt;::Type_t</statement>.
      Enumerations and other values can also be extracted.  For example,
      <statement>Array&lt;2, int, Brick&gt;::dimensions</statement>
      yields the dimension of the array's domain.</para>
  
!     <para>Control flow determines which code is used.  At run time,
      control-flow statements such as <keywordname>if</keywordname>,
      <keywordname>while</keywordname>, and
      <keywordname>goto</keywordname> determine which statements to
      execute.  Template programming uses two mechanisms: template class
      specializations and pattern matching.  These are similar to
!     control flow for functional programming languages.  A <glossterm
      linkend="glossary-traits_class"><firstterm>template class
      specialization</firstterm></glossterm> is a class definition
      specific to one or more template arguments.  For example, the
!     implementation for data-parallel operations uses the templated
!     <type>CreateLeaf</type>.  The default definition works for any
!     template argument&nbsp;<varname>T</varname>:
  <programlisting>
  template&lt;class T&gt;
  struct CreateLeaf
--- 837,891 ----
    typedef typename CombineExpressionTraits&lt;Left_t, Right_t&gt;::Type_t Type_t;
  };
  </programlisting> consists of a class definition and internal type
!     definitions.  This traits class contains three values, all types
!     and named <type>Left_t</type>, <type>Right_t</type>, and
      <type>Type_t</type>, representing the type of the left child, the
!     right child, and the entire node, respectively.  Many traits
!     classes, such as this one, use internal type definitions to store
!     values.  No enumerations or constant values occur in this traits
!     class, but other such classes include them.  See <xref
      linkend="data_parallel-implementation"></xref> for more details
!     regarding the implementation of data-parallel operators.</para>
! 
!     <para id="template_programming-pooma_implementation-double_colon_operator">
!     <indexterm zone="template_programming-pooma_implementation-double_colon_operator">
!      <primary><operator>::</operator>&nbsp;operator</primary>
!     </indexterm>
!     The example also illustrates using the <operator>::</operator>
!     operator to extract a member of a traits class.  The type
!     <type>ExpressionTraits&lt;Left&gt;</type> contains an internal
!     type definition of <type>Type_t</type>.  Using the
!     <operator>::</operator> operator extracts it:
      <statement>ExpressionTraits&lt;Left&gt;::Type_t</statement>.
      Enumerations and other values can also be extracted.  For example,
      <statement>Array&lt;2, int, Brick&gt;::dimensions</statement>
      yields the dimension of the array's domain.</para>
  
!     <para id="template_programming-pooma_implementation-template_specialization">
!     <indexterm zone="template_programming-pooma_implementation-template_specialization">
!      <primary>template</primary>
!      <secondary>specialization</secondary>
!     </indexterm>
!     <indexterm class="startofrange" id="template_programming-pooma_implementation-index-control_flow">
!      <primary>control flow</primary>
!     </indexterm>
!     Control flow determines which code is used.  At run time,
      control-flow statements such as <keywordname>if</keywordname>,
      <keywordname>while</keywordname>, and
      <keywordname>goto</keywordname> determine which statements to
      execute.  Template programming uses two mechanisms: template class
      specializations and pattern matching.  These are similar to
!     control flow in functional programming languages.  A <glossterm
      linkend="glossary-traits_class"><firstterm>template class
      specialization</firstterm></glossterm> is a class definition
      specific to one or more template arguments.  For example, the
!     implementation for data-parallel operations
!     <indexterm>
!      <primary>data-parallel operation</primary>
!     </indexterm>
!     uses the templated <type>CreateLeaf</type>.  The default
!     definition works for any template
!     argument&nbsp;<varname>T</varname>:
  <programlisting>
  template&lt;class T&gt;
  struct CreateLeaf
*************** struct CreateLeaf&lt;Expression&lt;T&clo
*** 644,650 ****
      <type>CreateLeaf</type>'s template argument is an
      <type>Expression</type> type.</para>
  
!     <para>Pattern matching of template arguments to template
      parameters determines which template code is used.  The code
      associated with the match that is most specific is the one that is
      used.  For example, <type>CreateLeaf&lt;int&gt;</type> uses the
--- 906,921 ----
      <type>CreateLeaf</type>'s template argument is an
      <type>Expression</type> type.</para>
  
!     <para id="template_programming-pooma_implementation-pattern_matching">
!     <indexterm zone="template_programming-pooma_implementation-pattern_matching">
!      <primary>template</primary>
!      <secondary>pattern matching</secondary>
!     </indexterm>
!     <indexterm>
!      <primary>pattern matching</primary>
!      <see>template, pattern matching.</see>
!     </indexterm>
!     Pattern matching of template arguments to template
      parameters determines which template code is used.  The code
      associated with the match that is most specific is the one that is
      used.  For example, <type>CreateLeaf&lt;int&gt;</type> uses the
*************** struct CreateLeaf&lt;Expression&lt;T&clo
*** 663,672 ****
  
      <para>Control flow using template specializations and pattern
      matching is similar to <keywordname>switch</keywordname>
!     statements.  A <keywordname>switch</keywordname> statement has a
      condition and one or more pairs of case labels and associated
      code.  The code associated with the the case label whose value
!     matched the condition is executed.  If no case label matches the
      condition, the default code, if present, is used.  In template
      programming, instantiating a template, e.g.,
      <type>CreateLeaf&lt;Expression&lt;int&closeclose;</type> serves as
--- 934,947 ----
  
      <para>Control flow using template specializations and pattern
      matching is similar to <keywordname>switch</keywordname>
!     statements.
!     <indexterm>
!      <primary><keywordname>switch</keywordname></primary>
!     </indexterm>
!     A <keywordname>switch</keywordname> statement has a
      condition and one or more pairs of case labels and associated
      code.  The code associated with the the case label whose value
!     matches the condition is executed.  If no case label matches the
      condition, the default code, if present, is used.  In template
      programming, instantiating a template, e.g.,
      <type>CreateLeaf&lt;Expression&lt;int&closeclose;</type> serves as
*************** struct CreateLeaf&lt;Expression&lt;T&clo
*** 681,689 ****
      default label since it matches any arguments.  If no set of
      template parameters match (which is impossible for our example) or
      if more than one set are best matches, the code is
!     incorrect.</para>
! 
!     <para>Functions as well as classes may be templated.  All the
      concepts needed to understand function templates have already been
      introduced so we illustrate using an example.  The templated
      function <function>f</function> takes one parameter of any type:
--- 956,975 ----
      default label since it matches any arguments.  If no set of
      template parameters match (which is impossible for our example) or
      if more than one set are best matches, the code is
!     incorrect.
!     <indexterm class="endofrange" startref="template_programming-pooma_implementation-index-control_flow">
!     </indexterm></para>
! 
!     <para>
!     <indexterm class="startofrange" id="template_programming-pooma_implementation-function_template">
!      <primary>template</primary>
!      <secondary>function</secondary>
!     </indexterm>
!     <indexterm>
!      <primary>function template</primary>
!      <see>function, template.</see>
!     </indexterm>
!     Functions as well as classes may be templated.  All the
      concepts needed to understand function templates have already been
      introduced so we illustrate using an example.  The templated
      function <function>f</function> takes one parameter of any type:
*************** void f(const T&amp; t) { &hellip; }
*** 697,704 ****
      functions equivalent to <function>f(const int&amp)</function>,
      <function>f(const bool&amp)</function>, <function>f(const
      int*&amp)</function>, &hellip;.  Using a templated class
!     definition with a static member function, we can define an
!     equivalent function:
  <programlisting>
  template &lt;typename T&gt;
  class F {
--- 983,1008 ----
      functions equivalent to <function>f(const int&amp)</function>,
      <function>f(const bool&amp)</function>, <function>f(const
      int*&amp)</function>, &hellip;.  Using a templated class
!     definition with a static member function,
!     <indexterm>
!      <primary>function</primary>
!      <secondary>static member</secondary>
!     </indexterm>
!     <indexterm>
!      <primary>static member function</primary>
!      <see>function, static member</see>
!     </indexterm>
!     we can define an equivalent function:
!     <indexterm>
!      <primary>function</primary>
!      <secondary>static member</secondary>
!      <tertiary>equivalence with function template</tertiary>
!     </indexterm>
!     <indexterm>
!      <primary>template</primary>
!      <secondary>function</secondary>
!      <tertiary>equivalence with static member function</tertiary>
!     </indexterm>
  <programlisting>
  template &lt;typename T&gt;
  class F {
*************** class F {
*** 706,735 ****
  };
  </programlisting>  Both the templated class and the templated function
      take the same template arguments, but the class uses a static
!     member function so the notation to invoke it is slightly more
!     verbose: <statement>F&lt;T&gt;::f(t)</statement>.  The advantage
!     of a function template is that it can be overloaded, particularly
!     operator functions.  For example, the <operator>+</operator>
!     operator is overloaded to add two &array;s, which require template
!     parameters to specify:
  <programlisting>
  template &lt;int D1,class T1,class E1,int D2,class T2,class E2&gt;
  // complicated return type omitted
  operator+(const Array&lt;D1,T1,E1&gt; & l,const Array&lt;D2,T2,E2&gt; & r);
  </programlisting>  Without using function templates, it would not be
- 
      possible to write expressions such as <statement>a1 +
      a2</statement>.  Member functions can also be templated.  This
      permits, for example, overloading of assignment operators defined
!     within templated classes.</para>
! 
!     <para>Function objects are frequently useful in run-time code.
      They consist of a function plus some additional storage and are
      usually implemented as structures with data members and a function
!     call operator.  Analogous classes can be used at compile time.
!     Using the transformation introduced in the previous paragraph, we
      see that any function can be transformed into a class containing a
!     static member function.  Internal type definitions, enumerations,
      and static constant values can be added to the class.  The static
      member function can use these values during its computation.  The
      <type>CreateLeaf</type> structure, introduced above, illustrates this.
--- 1010,1077 ----
  };
  </programlisting>  Both the templated class and the templated function
      take the same template arguments, but the class uses a static
!     member function.  Thus, the notation to invoke it is slightly more
!     verbose: <statement>F&lt;T&gt;::f(t)</statement>.</para>
! 
!     <para id="template_programming-pooma_implementation-function_template-overloaded">
!     <indexterm zone="template_programming-pooma_implementation-function_template-overloaded">
!      <primary>function</primary>
!      <secondary>overloaded</secondary>
!     </indexterm>
!     <indexterm zone="template_programming-pooma_implementation-function_template-overloaded">
!      <primary>function</primary>
!      <secondary>operator</secondary>
!     </indexterm>
!     The advantage of a function template is that it can be overloaded,
!     particularly operator functions.  For example, the
!     <operator>+</operator> operator is overloaded to add two &array;s,
!     which require template parameters to specify:
  <programlisting>
  template &lt;int D1,class T1,class E1,int D2,class T2,class E2&gt;
  // complicated return type omitted
  operator+(const Array&lt;D1,T1,E1&gt; & l,const Array&lt;D2,T2,E2&gt; & r);
  </programlisting>  Without using function templates, it would not be
      possible to write expressions such as <statement>a1 +
      a2</statement>.  Member functions can also be templated.  This
      permits, for example, overloading of assignment operators defined
!     within templated classes.
!     <indexterm class="endofrange" startref="template_programming-pooma_implementation-function_template">
!     </indexterm>
!     </para>
! 
!     <para>Function objects
!     <indexterm>
!      <primary>function</primary>
!      <secondary>object</secondary>
!     </indexterm>
!     are frequently useful in run-time code.
      They consist of a function plus some additional storage and are
      usually implemented as structures with data members and a function
!     call operator.
!     <indexterm>
!      <primary>function</primary>
!      <secondary>call operator</secondary>
!     </indexterm>
!     Analogous classes can be used at compile time.
!     Using the transformation
!     <indexterm>
!      <primary>function</primary>
!      <secondary>static member</secondary>
!      <tertiary>equivalence with function template</tertiary>
!     </indexterm>
!     <indexterm>
!      <primary>template</primary>
!      <secondary>function</secondary>
!      <tertiary>equivalence with static member function</tertiary>
!     </indexterm>
!     introduced in the previous paragraph, we
      see that any function can be transformed into a class containing a
!     static member function.
!     <indexterm>
!      <primary>function</primary>
!      <secondary>static member</secondary>
!     </indexterm>
!     Internal type definitions, enumerations,
      and static constant values can be added to the class.  The static
      member function can use these values during its computation.  The
      <type>CreateLeaf</type> structure, introduced above, illustrates this.
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.6
diff -c -p -r1.6 tutorial.xml
*** tutorial.xml	2002/01/22 15:48:49	1.6
--- tutorial.xml	2002/01/24 04:56:40
***************
*** 1,17 ****
  <chapter id="tutorial">
   <title>A Tutorial Introduction</title>
  
-  <para>UPDATE: In the following paragraph, fix the cross-reference
-  to the actual section.</para>
- 
   <para>&pooma; provides different containers and processor
   configurations and supports different implementation styles, as
!  described in <xref linkend="introduction"></xref>.  In this
!  chapter, we present several different implementations of the
!  &doof2d; two-dimensional diffusion simulation program:
    <itemizedlist spacing="compact">
     <listitem>
!     <para>a C-style implementation omitting any use of &pooma;
      computing each array element individually,</para>
     </listitem>
     <listitem>
--- 1,15 ----
+ <!-- FIXME: Index this file. -->
  <chapter id="tutorial">
   <title>A Tutorial Introduction</title>
  
   <para>&pooma; provides different containers and processor
   configurations and supports different implementation styles, as
!  described in <xref linkend="introduction-goals"></xref>.  In this
!  chapter, we present several different implementations of the &doof2d;
!  two-dimensional diffusion simulation program:
    <itemizedlist spacing="compact">
     <listitem>
!     <para>a C-style implementation omitting any use of &pooma; and
      computing each array element individually,</para>
     </listitem>
     <listitem>
***************
*** 40,52 ****
     </listitem>
    </itemizedlist>
   </para>
!  <para>These illustrate the &array;, &field;, &engine;, layout,
!  mesh, and domain data types.  They also illustrate various
!  immediate computation styles (element-wise accesses, data-parallel
!  expressions, and stencil computation) and various processor
!  configurations (one sequential processor and multiple
!  processors).</para>
  
   <figure float="1" id="tutorial-doof2d_averagings">
    <title>&doof2d; Averagings</title>
    <mediaobject>
--- 38,68 ----
     </listitem>
    </itemizedlist>
   </para>
!  <para>These illustrate the &array;, &field;, &engine;, layout, mesh,
!  and &domain; data types.  They also illustrate various immediate
!  computation styles (element-wise accesses, data-parallel expressions,
!  and stencil computation) and various processor configurations (one
!  processor and multiple processors).</para>
! 
!  <para>The &doof2d; diffusion program starts with a two-dimensional
!  grid of values.  To model an initial density, all grid values are
!  zero except for one nonzero value in the center.  Each averaging,
!  each grid element, except the outermost ones, updates its value by
!  averaging its value and its eight neighbors.  To avoid overwriting
!  grid values before all their uses occur, we use two arrays, reading
!  the first and writing the second and then reversing their roles
!  within each iteration.</para>
! 
!  <para>We illustrate the averagings in <xref
!  linkend="tutorial-doof2d_averagings"></xref>.  Initially, only the
!  center element has nonzero value.  To form the first averaging, each
!  element's new value equals the average of its and its neighbors'
!  previous values.  Thus, the initial nonzero value spreads to a
!  three-by-three grid.  The averaging continues, spreading to a
!  five-by-five grid of nonzero values.  Values in the outermost grid cells
!  are always zero.</para>
  
+ <!-- FIXME: Fix the layout, somehow. -->
   <figure float="1" id="tutorial-doof2d_averagings">
    <title>&doof2d; Averagings</title>
    <mediaobject>
***************
*** 75,177 ****
    </mediaobject>
   </figure>
  
!  <para>The &doof2d; diffusion program starts with a two-dimensional
!  grid of values.  To model an initial density, all grid values are
!  zero except for one nonzero value in the center.  Each averaging,
!  each grid element, except the outermost ones, updates its value by
!  averaging its value and its eight neighbors.  To avoid overwriting
!  grid values before all their uses occur, we use two arrays, reading
!  the first and writing the second and then reversing their roles
!  within each iteration.</para>
! 
!  <para>Figure <xref linkend="tutorial-doof2d_averagings"></xref>
!  illustrates the averagings.  Initially, only the center element has
!  nonzero value.  To form the first averaging, each element's new
!  value equals the average of its and its neighbors' previous values.
!  Thus, the initial nonzero value spreads to a three-by-three grid.
!  The averaging continues, spreading to a five-by-five grid of
!  nonzero values.  Values in outermost grid cells are always
!  zero.</para>
! 
!  <para>Before presenting various implementations of %doof2d;, we
   explain how to install the &poomatoolkit;.</para>
  
   <para>REMOVE: &doof2d; algorithm and code is illustrated in
   Section&nbsp;4.1 of
   <filename>pooma-publications/pooma.ps</filename>.  It includes a
   figure illustrating parallel communication of data.</para>
  
   <section id="tutorial-installation">
    <title>Installing &pooma;</title>
  
    <para>ADD: How does one install &pooma; using Windows or Mac?</para>
  
    <para>UPDATE: Make a more recent &pooma; source code file
!   available on &poomaDownloadPage;.  For example,
    <quote>LINUXgcc.conf</quote> is not available.</para>
  
    <para>In this section, we describe how to obtain, build, and
    install the &poomatoolkit;.  We focus on installing under the
!   Unix operating system.  Instructions for installing on computers
    running Microsoft Windows or MacOS, as well as more extensive
    instructions for Unix, appear in <xref
!   linkend="installation"></xref>.</para>
  
    <para>Obtain the &pooma; source code <filename
!   path="http://www.codesourcery.com/pooma/downloads_folder/">&poomaSourceFile;</filename>
!   from the &pooma; download page (&poomaDownloadPage;) available off
!   the &pooma; home page (&poomaHomePage;).  The <quote>tgz</quote>
    indicates this is a compressed tar archive file.  To extract the
!   source files, use <command>tar xzvf &poomaSourceFile;</command>.
    Move into the source code directory <filename
!   class="directory">&poomaSource;</filename> directory; e.g.,
!   <command>cd &poomaSource;</command>.</para>
  
!   <para>Configuring the source code prepares the necessary paths for
!   compilation.  First, determine a configuration file in
!   corresponding to your operating system and compiler in the
!   <filename class="directory">config/arch/</filename> directory.
!   For example, <filename
    class="libraryfile">LINUXgcc.conf</filename> supports compiling
!   under a &linux; operating system with &gcc; and <filename
    class="libraryfile">SGI64KCC.conf</filename> supports compiling
!   under a 64-bit <application>SGI</application> Unix operating
!   system with &kcc;.  Then, configure the source code:
!   <command>./configure &dashdash;arch LINUXgcc &dashdash;opt &dashdash;suite
    LINUXgcc-opt</command>.  The architecture argument to the
!   <command>&dashdash;arch</command> option is the name of the corresponding
!   configuration file, omitting its <filename
    class="libraryfile">.conf</filename> suffix.  The
    <command>&dashdash;opt</command> indicates the &poomatoolkit; will
!   contain optimized source code, which makes the code run more
!   quickly but may impede debugging.  Alternatively, the
!   <command>&dashdash;debug</command> option supports debugging.  The
!   <glossterm linkend="glossary-suite_name">suite name</glossterm>
    can be any arbitrary string.  We chose
!   <command>LINUXgcc-opt</command> to remind us of the architecture
!   and optimization choice.  <filename
    class="libraryfile">configure</filename> creates subdirectories
!   named by the suite name <quote>LINUXgcc-opt</quote> for use when
!   compiling the source files.  Comments at the beginning of
!   <filename
    class="libraryfile">lib/<replaceable>suiteName</replaceable>/PoomaConfiguration.h</filename>
    record the configuration arguments.</para>
  
!   <para>To compile the source code, set the
!   <envar>POOMASUITE</envar> environment variable to the suite name
!   and then type <command>make</command>.  To set the environment
!   variable for the <application>bash</application> shell use
!   <command>export
    POOMASUITE=<replaceable>suiteName</replaceable></command>,
!   substituting the suite name's
!   <replaceable>suiteName</replaceable>.  For the
!   <application>csh</application> shell, use <command>setenv
    POOMASUITE LINUXgcc-opt</command>.  Issuing the
    <command>make</command> command compiles the &pooma; source code
    files to create the &pooma; library.  The &pooma; makefiles assume
!   the <trademark>GNU</trademark> &make; so substitute the proper
!   command if necessary.  The &pooma; library can be found in, e.g.,
!   <filename
    class="libraryfile">lib/LINUXgcc-opt/libpooma-gcc.a</filename>.</para>
   </section>
  
--- 91,183 ----
    </mediaobject>
   </figure>
  
!  <para>Before presenting the various implementations of &doof2d;, we
   explain how to install the &poomatoolkit;.</para>
  
+ <![%unfinished;[
   <para>REMOVE: &doof2d; algorithm and code is illustrated in
   Section&nbsp;4.1 of
   <filename>pooma-publications/pooma.ps</filename>.  It includes a
   figure illustrating parallel communication of data.</para>
+ ]]>  <!-- end unfinished -->
  
+ 
   <section id="tutorial-installation">
    <title>Installing &pooma;</title>
  
+ <![%unfinished;[
    <para>ADD: How does one install &pooma; using Windows or Mac?</para>
  
    <para>UPDATE: Make a more recent &pooma; source code file
!   available on &poomadownloadpage;.  For example,
    <quote>LINUXgcc.conf</quote> is not available.</para>
+ ]]>  <!-- end unfinished -->
  
    <para>In this section, we describe how to obtain, build, and
    install the &poomatoolkit;.  We focus on installing under the
!   Unix operating system.
! <![%unfinished;[
!   Instructions for installing on computers
    running Microsoft Windows or MacOS, as well as more extensive
    instructions for Unix, appear in <xref
!   linkend="installation"></xref>.
! ]]>  <!-- end unfinished -->
!   </para>
  
    <para>Obtain the &pooma; source code <filename
!   path="http://www.codesourcery.com/pooma/downloads_folder/">&poomasourcefile;</filename>
!   from the &pooma; download page (&poomadownloadpage;) available off
!   the &pooma; home page (&poomahomepage;).  The <quote>tgz</quote>
    indicates this is a compressed tar archive file.  To extract the
!   source files, use <command>tar xzvf &poomasourcefile;</command>.
    Move into the source code directory <filename
!   class="directory">&poomasource;</filename> directory; e.g.,
!   <command>cd &poomasource;</command>.</para>
  
!   <para>Configuring the source code determines file names needed for
!   compilation.  First, determine a configuration file in the <filename
!   class="directory">config/arch/</filename> directory corresponding to
!   your operating system and compiler.  For example, <filename
    class="libraryfile">LINUXgcc.conf</filename> supports compiling
!   under a &linux; operating system with &gcc;, while <filename
    class="libraryfile">SGI64KCC.conf</filename> supports compiling
!   under a 64-bit <application>SGI</application> Unix operating system
! <!-- FIXME: Center the following command. -->
!   with &kcc;.  Next, configure the source code: <command>./configure
!   &dashdash;arch LINUXgcc &dashdash;opt &dashdash;suite
    LINUXgcc-opt</command>.  The architecture argument to the
!   <command>&dashdash;arch</command> option is the name of the
!   corresponding configuration file, omitting its <filename
    class="libraryfile">.conf</filename> suffix.  The
    <command>&dashdash;opt</command> indicates the &poomatoolkit; will
!   contain optimized source code, which makes the code run more quickly
!   but may impede debugging.  Alternatively, use the
!   <command>&dashdash;debug</command> option which supports debugging.
!   The <glossterm linkend="glossary-suite_name">suite name</glossterm>
    can be any arbitrary string.  We chose
!   <command>LINUXgcc-opt</command> to remind us of the architecture and
!   optimization choice.  <filename
    class="libraryfile">configure</filename> creates subdirectories
!   named <quote>LINUXgcc-opt</quote> for use when compiling the source
!   files.  Comments at the beginning of <filename
    class="libraryfile">lib/<replaceable>suiteName</replaceable>/PoomaConfiguration.h</filename>
    record the configuration arguments.</para>
  
!   <para>To compile the source code, set the <envar>POOMASUITE</envar>
!   environment variable to the suite name and then type
!   <command>make</command>.  To set the environment variable for the
! <!-- FIXME: Center the following command. -->
!   <application>bash</application> shell use <command>export
    POOMASUITE=<replaceable>suiteName</replaceable></command>,
!   substituting the suite name's <replaceable>suiteName</replaceable>.
! <!-- FIXME: Center the following command. -->
!   For the <application>csh</application> shell, use <command>setenv
    POOMASUITE LINUXgcc-opt</command>.  Issuing the
    <command>make</command> command compiles the &pooma; source code
    files to create the &pooma; library.  The &pooma; makefiles assume
!   the <trademark>GNU</trademark> &make; is available so substitute the
!   proper command to run <trademark>GNU</trademark> &make; if
!   necessary.  The &pooma; library can be found in, e.g., <filename
    class="libraryfile">lib/LINUXgcc-opt/libpooma-gcc.a</filename>.</para>
   </section>
  
***************
*** 181,209 ****
    <para>Before implementing &doof2d; using the &poomatoolkit;, we
    present a hand-coded implementation of &doof2d;.  See <xref
    linkend="tutorial-hand_coded-doof2d"></xref>.  After querying the
!   user for the number of averagings, the arrays' memory is
!   allocated.  Since the arrays' size is not known at compile time,
!   the arrays are accesses via pointers to allocated dynamic memory.
!   This memory is deallocated at the program's end to avoid memory
!   leaks.  The arrays are initialized with initial conditions.  For
!   the <varname>b</varname> array, all values except the central ones
!   have nonzero values.  Only the outermost values of the
    <varname>a</varname> array need be initialized to zero, but we
!   instead initialize them all using the loop used by
!   <varname>b</varname>.</para>
  
!   <para>The simulation's kernel consists of triply nested loops.
!   The outermost loop controls the number of iterations.  The inner
    nested loops iterate through the arrays' elements, excepting the
!   outermost elements; note the loop indices range from 1 to n-2
!   while the array indices range from 0 to n-1.  Each
!   <varname>a</varname> value is assigned the average of its
!   corresponding value in <varname>b</varname> and the latter's
!   neighbors.  Values in the two-dimensional grids are accessed using
!   two sets of brackets, e.g., <statement>a[i][j]</statement>.  After
!   assigning values to <varname>a</varname>, a second averaging reads
!   values in <varname>a</varname>, writing values in
!   <varname>b</varname>.</para>
  
    <para>After the kernel finishes, the final central value is
    printed.  If the desired number of averagings is even, the value
--- 187,214 ----
    <para>Before implementing &doof2d; using the &poomatoolkit;, we
    present a hand-coded implementation of &doof2d;.  See <xref
    linkend="tutorial-hand_coded-doof2d"></xref>.  After querying the
!   user for the number of averagings, the arrays' memory is allocated.
!   Since the arrays' size is not known at compile time, the arrays are
!   accessed via pointers to allocated dynamic memory.  This memory is
!   deallocated at the program's end to avoid memory leaks.  The arrays
!   are initialized with initial conditions.  For the
!   <varname>b</varname> array, all values except the central ones have
!   nonzero values.  Only the outermost values of the
    <varname>a</varname> array need be initialized to zero, but we
!   instead initialize them all using the same loop
!   initializing&nbsp;<varname>b</varname>.</para>
  
!   <para>The simulation's kernel consists of triply nested loops.  The
!   outermost loop controls the number of iterations.  The two inner
    nested loops iterate through the arrays' elements, excepting the
!   outermost elements; note the loop indices range from 1 to n-2 while
!   the array indices range from 0 to n-1.  Each <varname>a</varname>
!   value is assigned the average of its corresponding value in
!   <varname>b</varname> and the latter's neighbors.  Values in the
!   two-dimensional grids are accessed using two sets of brackets, e.g.,
!   <statement>a[i][j]</statement>.  After assigning values to
!   <varname>a</varname>, a second averaging reads values in
!   <varname>a</varname>, writing values in <varname>b</varname>.</para>
  
    <para>After the kernel finishes, the final central value is
    printed.  If the desired number of averagings is even, the value
***************
*** 241,248 ****
       <varname>a</varname> array.</para>
      </callout>
      <callout arearefs="tutorial-hand_coded-doof2d-constants">
!      <para>These constants indicate the number of iterations, and
!      the average weighting.</para>
      </callout>
      <callout arearefs="tutorial-hand_coded-doof2d-first_write">
       <para>Each <varname>a</varname> value, except an outermost one,
--- 246,252 ----
       <varname>a</varname> array.</para>
      </callout>
      <callout arearefs="tutorial-hand_coded-doof2d-constants">
!      <para>This constants indicates the average's weighting.</para>
      </callout>
      <callout arearefs="tutorial-hand_coded-doof2d-first_write">
       <para>Each <varname>a</varname> value, except an outermost one,
***************
*** 268,289 ****
  
    <para>To compile the executable, change directories to the &pooma;
    <filename
!   class="directory">&poomaExampleDirectory;/Doof2d</filename>
    directory.  Ensure the <envar>POOMASUITE</envar> environment
    variable specifies the desired suite name
    <replaceable>suiteName</replaceable>, as we did when compiling
!   &pooma; in the previous section <xref
!   linkend="tutorial-installation"></xref>.  Issuing the
!   <command>make Doof2d-C-element</command> command creates the
    executable
    <command><replaceable>suiteName</replaceable>/Doof2d-C-element</command>.</para>
  
!   <para>When running the executable, specify the desired a
!   nonnegative number of averagings and the nonnegative number of
!   grid cells along any dimension.  The resulting grid has the same
!   number of cells along each dimension.  After the executable
!   finishes, the resulting value of the central element is
!   printed.</para>
   </section>
  
  
--- 272,291 ----
  
    <para>To compile the executable, change directories to the &pooma;
    <filename
!   class="directory">&poomaexampledirectory;/Doof2d</filename>
    directory.  Ensure the <envar>POOMASUITE</envar> environment
    variable specifies the desired suite name
    <replaceable>suiteName</replaceable>, as we did when compiling
!   &pooma; in <xref linkend="tutorial-installation"></xref>.  Issuing
!   the <command>make Doof2d-C-element</command> command creates the
    executable
    <command><replaceable>suiteName</replaceable>/Doof2d-C-element</command>.</para>
  
!   <para>When running the executable, specify the desired nonnegative
!   number of averagings and the nonnegative number of grid cells along
!   any dimension.  The resulting grid has the same number of cells
!   along each dimension.  After the executable finishes, the resulting
!   value of the central element is printed.</para>
   </section>
  
  
***************
*** 314,323 ****
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-domain">
       <para>Before creating an &array;, its domain must be specified.
!      The <varname>N</varname> interval represents the
!      one-dimensional integral set {0, 1, 2, &hellip;, n-1}.  An
!      <type>Interval&lt;2&gt;</type> object represents the entire
!      two-dimensional index domain.</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-array_creation">
       <para>An &array;'s template parameters indicate its dimension,
--- 316,325 ----
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-domain">
       <para>Before creating an &array;, its domain must be specified.
!      The <varname>N</varname> &interval; represents the
!      one-dimensional integral set {0, 1, 2, &hellip;, n-1}.  The
!      <type>Interval&lt;2&gt;</type> <varname>vertDomain</varname>
!      object represents the entire two-dimensional index domain.</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-array_creation">
       <para>An &array;'s template parameters indicate its dimension,
***************
*** 330,349 ****
       domain.</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-initialization">
!      <para>The first statement initializes all &array; values to the
!      same scalar value.  This is possible because each &array;
!      <quote>knows</quote> its domain.  The second statement
!      illustrates &array; element access.  Indices, separated by
       commas, are surrounded by parentheses rather than surrounded by
       square brackets (<statement>[]</statement>).</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-first_write">
       <para>&array; element access uses parentheses, rather than
!      square brackets</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-deallocation">
!      <para>Since &array;s are first-class objects, they
!      automatically deallocate any memory they require, eliminating
       memory leaks.</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-pooma_finish">
--- 332,349 ----
       domain.</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-initialization">
!      <para>The first loop initializes all &array; values to the
!      same scalar value.  The second statement
!      illustrates assigning one &array; value.  Indices, separated by
       commas, are surrounded by parentheses rather than surrounded by
       square brackets (<statement>[]</statement>).</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-first_write">
       <para>&array; element access uses parentheses, rather than
!      square brackets.</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-deallocation">
!      <para>The &array;s deallocate any memory they require, eliminating
       memory leaks.</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-pooma_finish">
***************
*** 364,370 ****
    <para>The creation of the <varname>a</varname> and
    <varname>b</varname> &array;s requires an object specifying their
    index domains.  Since these are two-dimensional arrays, their
!   index domains are also two dimensional.  The two-dimensional
    <type>Interval&lt;2&gt;</type> object is the Cartesian product of
    two one-dimensional <type>Interval&lt;1&gt;</type> objects, each
    specifying the integral set {0, 1, 2, &hellip;, n-1}.</para>
--- 364,370 ----
    <para>The creation of the <varname>a</varname> and
    <varname>b</varname> &array;s requires an object specifying their
    index domains.  Since these are two-dimensional arrays, their
!   index domains are also two-dimensional.  The two-dimensional
    <type>Interval&lt;2&gt;</type> object is the Cartesian product of
    two one-dimensional <type>Interval&lt;1&gt;</type> objects, each
    specifying the integral set {0, 1, 2, &hellip;, n-1}.</para>
***************
*** 373,387 ****
    type of its values, and how the values are stored.  Both
    <varname>a</varname> and <varname>b</varname> are two-dimension
    arrays storing &double;s so their <varname>dimension</varname>
!   is&nbsp;2 and its element type is &double;.  An &engine; stores an
!   &array;'s values.  For example, a &brick; &engine; explicitly
!   stores all values.  A &compressiblebrick; &engine; also explicitly
!   stores values if more than value is present, but, if all values
!   are the same, storage for just that value is required.  Since an
!   engine can store its values any way it desires, it might instead
!   compute its values using a function or compute the values stored
!   in separate engines.  In practice, most explicitly specified
!   &engine;s are either &brick; or &compressiblebrick;.</para>
  
    <para>&array;s support both element-wise access and scalar
    assignment.  Element-wise access uses parentheses, not square
--- 373,387 ----
    type of its values, and how the values are stored.  Both
    <varname>a</varname> and <varname>b</varname> are two-dimension
    arrays storing &double;s so their <varname>dimension</varname>
!   is&nbsp;2 and their value type is &double;.  An &engine; stores an
!   &array;'s values.  For example, a &brick; &engine; explicitly stores
!   all values.  A &compressiblebrick; &engine; also explicitly stores
!   values if more than one value is present, but, if all values are the
!   same, storage for just that value is required.  Since an engine can
!   store its values any way it desires, it might instead compute its
!   values using a function or compute using values stored in separate
!   engines.  In practice, most explicitly specified &engine;s are
!   either &brick; or &compressiblebrick;.</para>
  
    <para>&array;s support both element-wise access and scalar
    assignment.  Element-wise access uses parentheses, not square
***************
*** 389,405 ****
    specifies the central element.  The scalar assignment <statement>b
    = 0.0</statement> assigns the same 0.0 value to all array
    elements.  This is possible because the array knows the extent of
!   its domain.</para>
  
    <para>Any program using the &poomatoolkit; must initialize the
    &toolkit;'s data structures using
!   <statement>Pooma::initialize(argc,argv)</statement>.  This
!   extracts &pooma;-specific command-line options from the
!   command-line arguments in <varname>argv</varname> and initializes
!   the inter-processor communication and other data structures.  When
!   finished, <statement>Pooma::finalize()</statement> ensures all
!   computation has finished and the communication and other data
!   structures are destructed.</para>
   </section>
  
  
--- 389,406 ----
    specifies the central element.  The scalar assignment <statement>b
    = 0.0</statement> assigns the same 0.0 value to all array
    elements.  This is possible because the array knows the extent of
!   its domain.  We illustrate these data-parallel statements in the
!   next section.</para>
  
    <para>Any program using the &poomatoolkit; must initialize the
    &toolkit;'s data structures using
!   <statement>Pooma::initialize(argc,argv)</statement>.  This extracts
!   &pooma;-specific command-line options from the program's
!   command-line arguments and initializes the interprocessor
!   communication and other data structures.  When finished,
!   <statement>Pooma::finalize()</statement> ensures all computation and
!   communication has finished and the data structures are
!   destructed.</para>
   </section>
  
  
***************
*** 408,437 ****
  
    <para>&pooma; supports data-parallel &array; accesses.  Many
    algorithms are more easily expressed using data-parallel
!   expressions.  Also, the &poomatoolkit; might be able to reorder
!   the data-parallel computations to be more efficient or distribute
!   them among various processors.  In this section, we concentrate
!   the differences between the data-parallel implementation of
!   &doof2d; listed in <xref
!   linkend="tutorial-array_parallel-doof2d"></xref> and the
!   element-wise implementation listed in the previous section <xref
!   linkend="tutorial-array_elementwise"></xref>.</para>
  
    <example id="tutorial-array_parallel-doof2d">
     <title>Data-Parallel &array; Implementation of &doof2d;</title>
     &doof2d-array-parallel;
     <calloutlist>
      <callout arearefs="tutorial-array_parallel-doof2d-blockAndEvaluate">
       <para>&pooma; may reorder computation of statements.  Calling
       <function>Pooma::blockAndEvaluate</function> ensures all
       computation finishes before accessing a particular array
       element.</para>
      </callout>
-     <callout arearefs="tutorial-array_parallel-doof2d-innerdomain">
-      <para>These variables specify one-dimensional domains {1, 2,
-      &hellip;, n-2}.  Their Cartesian product specifies the domain
-      of the array values that are modified.</para>
-     </callout>
      <callout arearefs="tutorial-array_parallel-doof2d-first_write">
       <para>Data-parallel expressions replace nested loops and array
       element accesses.  For example, <statement>a(I,J)</statement>
--- 409,437 ----
  
    <para>&pooma; supports data-parallel &array; accesses.  Many
    algorithms are more easily expressed using data-parallel
!   expressions.  Also, the &poomatoolkit; can sometimes reorder the
!   data-parallel computations to be more efficient or distribute them
!   among various processors.  In this section, we concentrate on the
!   differences between the data-parallel implementation of &doof2d;
!   listed in <xref linkend="tutorial-array_parallel-doof2d"></xref> and
!   the element-wise implementation listed in the previous
!   section.</para>
  
    <example id="tutorial-array_parallel-doof2d">
     <title>Data-Parallel &array; Implementation of &doof2d;</title>
     &doof2d-array-parallel;
     <calloutlist>
+     <callout arearefs="tutorial-array_parallel-doof2d-innerdomain">
+      <para>These variables specify one-dimensional domains {1, 2,
+      &hellip;, n-2}.  Their Cartesian product specifies the domain
+      of the array values that are modified.</para>
+     </callout>
      <callout arearefs="tutorial-array_parallel-doof2d-blockAndEvaluate">
       <para>&pooma; may reorder computation of statements.  Calling
       <function>Pooma::blockAndEvaluate</function> ensures all
       computation finishes before accessing a particular array
       element.</para>
      </callout>
      <callout arearefs="tutorial-array_parallel-doof2d-first_write">
       <para>Data-parallel expressions replace nested loops and array
       element accesses.  For example, <statement>a(I,J)</statement>
***************
*** 443,462 ****
     </calloutlist>
    </example>
  
!   <para>Data-parallel expressions apply domain objects to containers
!   to indicate a set of parallel expressions.  For example, in the
!   program listed above, <statement>a(I,J)</statement> specifies all
!   of <varname>a</varname> array excepting the outermost elements.
!   The array's <varname>vertDomain</varname> domain consists of the
!   Cartesian product of {0, 1, 2, &hellip;, n-1} and itself, while
    <varname>I</varname> and <varname>J</varname> each specify {1, 2,
    &hellip;, n-2}.  Thus, <statement>a(I,J)</statement> is the subset
!   with a domain of the Cartesian product of {1, 2, &hellip;, n-2}
!   and itself.  It is called a <firstterm>view</firstterm> of an
!   array.  It is itself an array, with a domain and supporting
!   element access, but its storage is the same as
!   <varname>a</varname>'s.  Changing a value in
!   <statement>a(I,J)</statement> also changes the same value in
    <varname>a</varname>.  Changing a value in the latter also changes
    the former if the value is not one of <varname>a</varname>'s
    outermost elements.  The expression
--- 443,461 ----
     </calloutlist>
    </example>
  
!   <para>Data-parallel expressions use containers and domain objects to
!   indicate a set of parallel expressions.  For example, in the program
!   listed above, <statement>a(I,J)</statement> specifies the subset of
!   <varname>a</varname> array omitting the outermost elements.  The
!   array's <varname>vertDomain</varname> domain consists of the
!   Cartesian product of {0, 1, 2, &hellip;, n-1} with itself, while
    <varname>I</varname> and <varname>J</varname> each specify {1, 2,
    &hellip;, n-2}.  Thus, <statement>a(I,J)</statement> is the subset
!   with a domain of the Cartesian product of {1, 2, &hellip;, n-2} with
!   itself.  It is called a <firstterm>view</firstterm> of an array.  It
!   is itself an &array;, with a domain and supporting element access, but
!   its storage is the same as <varname>a</varname>'s.  Changing a value
!   in <statement>a(I,J)</statement> also changes the same value in
    <varname>a</varname>.  Changing a value in the latter also changes
    the former if the value is not one of <varname>a</varname>'s
    outermost elements.  The expression
***************
*** 465,474 ****
    product of {2, 3, &hellip;, n-1}, i.e., the same domain as
    <statement>a(I,J)</statement> but shifted up one unit and to the
    right one unit.  Only an &interval;'s value, not its name, is
!   important.  Thus, all uses of <varname>J</varname> in this program
    could be replaced by <varname>I</varname> without changing the
    semantics.</para>
  
    <figure float="1" id="tutorial-array_parallel-doof2d-adding_arrays">
     <title>Adding &array;s</title>
     <mediaobject>
--- 464,483 ----
    product of {2, 3, &hellip;, n-1}, i.e., the same domain as
    <statement>a(I,J)</statement> but shifted up one unit and to the
    right one unit.  Only an &interval;'s value, not its name, is
!   important so all uses of <varname>J</varname> in this program
    could be replaced by <varname>I</varname> without changing the
    semantics.</para>
  
+   <para>The statement assigning to <statement>a(I,J)</statement>
+   illustrates that &array;s may participate in expressions.  Each
+   addend is a view of an array, which is itself an array.  The views'
+   indices are zero-based so their sum can be formed by adding
+   identically indexed elements of each array.  For example, the lower,
+   left element of the result equals the sum of the lower, left
+   elements of the addend arrays.  <xref
+   linkend="tutorial-array_parallel-doof2d-adding_arrays"></xref>
+   illustrates adding two arrays.</para>
+ 
    <figure float="1" id="tutorial-array_parallel-doof2d-adding_arrays">
     <title>Adding &array;s</title>
     <mediaobject>
***************
*** 476,528 ****
       <imagedata fileref="figures/doof2d.210" format="EPS" align="center"></imagedata>
      </imageobject>
      <textobject>
!      <phrase>Adding two arrays with different domains is supported.</phrase>
      </textobject>
      <caption>
!      <para>When adding arrays, values in corresponding positions are
!      added even if they have different indices, indicated by the
!      small numbers adjacent to the arrays.</para>
      </caption>
     </mediaobject>
    </figure>
  
-   <para>The statement assigning to <statement>a(I,J)</statement>
-   illustrates that &array;s may participate in expressions.  Each
-   addend is a view of an array, which is itself an array.  Each view
-   has the same domain size so their sum can be formed by
-   corresponding elements of each array.  For example, the lower,
-   left element of the result equals the sum of the lower, left
-   elements of the addend arrays.  For the computation, indices are
-   ignored; only the relative positions within each domain are used.
-   <xref
-   linkend="tutorial-array_parallel-doof2d-adding_arrays"></xref>
-   illustrates adding two arrays with different domain indices.  The
-   indices are indicated by the small numbers to the left and the
-   bottom of the arrays.  Even though 9 and 3 have different indices
-   (1,1) and (2,0), they are added to each other because they have
-   the same relative positions within the addends.</para>
- 
    <para>Just before accessing individual &array; values, the code
    contains calls to <function>Pooma::blockAndEvaluate</function>.
    &pooma; may reorder computation or distribute them among various
    processors.  Before reading an individual &array; value, calling
!   the function ensures all computations affecting its value have
!   finished, i.e., it has the correct value.  Calling this function
!   is necessary only when accessing individual array elements because
!   &pooma; cannot determine when to call the function itself. For
!   example, before printing an array, &pooma; will call
!   <function>blockAndEvaluate</function> itself.</para>
   </section>
  
  
   <section id="tutorial-array_stencil">
    <title>Stencil &array; Implementation</title>
  
!   <para>Many computations are local, computing an &array;'s value by
!   using close-by &array; values.  Encapsulating this computation in
!   a stencil can yield faster code because the compiler can determine
!   all accesses come from the same array.  Each stencil consists of a
!   function object and an indication of the stencil's extent.</para>
  
    <example id="tutorial-array_stencil-doof2d">
     <title>Stencil &array; Implementation of &doof2d;</title>
--- 485,523 ----
       <imagedata fileref="figures/doof2d.210" format="EPS" align="center"></imagedata>
      </imageobject>
      <textobject>
!      <phrase>Adding two arrays is supported.</phrase>
      </textobject>
      <caption>
!      <para>When adding arrays, values with the same indices, indicated
!      by the small numbers adjacent to the arrays, are added.</para>
      </caption>
     </mediaobject>
    </figure>
  
    <para>Just before accessing individual &array; values, the code
    contains calls to <function>Pooma::blockAndEvaluate</function>.
    &pooma; may reorder computation or distribute them among various
    processors.  Before reading an individual &array; value, calling
!   this function ensures all computations affecting its value have
!   finished, i.e., it has the correct value.  Calling this function is
!   necessary only when accessing individual array elements.  For
!   example, before the data-parallel operation of printing an array,
!   &pooma; will call <function>blockAndEvaluate</function>
!   itself.</para>
   </section>
  
  
   <section id="tutorial-array_stencil">
    <title>Stencil &array; Implementation</title>
  
!   <para>Many scientific computations are localized, computing an
!   array's value by using neighboring values.  Encapsulating this local
!   computation in a <glossterm
!   linkend="glossary-stencil"><firstterm>stencil</firstterm></glossterm>
!   can yield faster code because the compiler can determine that all
!   array accesses use the same array.  Each stencil consists of a
!   function object and an indication of which neighbors participate in
!   the function's computation.</para>
  
    <example id="tutorial-array_stencil-doof2d">
     <title>Stencil &array; Implementation of &doof2d;</title>
***************
*** 546,552 ****
      <callout arearefs="tutorial-array_stencil-doof2d-stencil_extent">
       <para>These two functions indicate the stencil's size.  For
       each dimension, the stencil extends one cell to the left of (or
!      below) its center and also one call to the right (or above) its
       center.</para>
      </callout>
      <callout
--- 541,547 ----
      <callout arearefs="tutorial-array_stencil-doof2d-stencil_extent">
       <para>These two functions indicate the stencil's size.  For
       each dimension, the stencil extends one cell to the left of (or
!      below) its center and also one cell to the right (or above) its
       center.</para>
      </callout>
      <callout
***************
*** 564,584 ****
     </calloutlist>
    </example>
  
!   <para>Before we describe how to create a stencil, we describe how
!   to apply a stencil to an array, yielding values.  To compute the
!   value associated with index position (1,3), the stencil's center
!   is placed at (1,3).  The stencil's
!   <function>upperExtent</function> and
!   <function>lowerExtent</function> functions indicate which &array;
!   values the stencil's function will use.  See <xref
    linkend="tutorial-array_stencil-doof2d-apply_stencil"></xref>.
!   Applying the stencil's function call
!   <function>operator()</function> yields the computed value.  To
!   compute multiple &array; values, apply a stencil to the array and
!   a domain object: <statement>stencil(b,
!   interiorDomain)</statement>.  This applies the stencil to each
!   position in the domain.  The user must ensure that applying the
!   stencil does not access nonexistent &array; values.</para>
  
    <figure float="1" id="tutorial-array_stencil-doof2d-apply_stencil">
     <title>Applying a Stencil to an &array;</title>
--- 559,578 ----
     </calloutlist>
    </example>
  
!   <para>Before we describe how to create a stencil, we describe how to
!   apply a stencil to an array, yielding computed values.  To compute
!   the value associated with index position (1,3), the stencil's center
!   is placed at (1,3).  The stencil's <function>upperExtent</function>
!   and <function>lowerExtent</function> functions indicate which
!   &array; values the stencil's function will use.  See <xref
    linkend="tutorial-array_stencil-doof2d-apply_stencil"></xref>.
!   Applying the stencil's function call <function>operator()</function>
!   yields the computed value.  To compute multiple &array; values,
!   apply a stencil to the array and a domain object:
!   <statement>stencil(b, interiorDomain)</statement>.  This applies the
!   stencil to each position in the domain.  The user must ensure that
!   applying the stencil does not access nonexistent &array;
!   values.</para>
  
    <figure float="1" id="tutorial-array_stencil-doof2d-apply_stencil">
     <title>Applying a Stencil to an &array;</title>
***************
*** 592,598 ****
      <caption>
       <para>To compute the value associated with index position (1,3)
       of an array, place the stencil's center, indicated with dashed
!      lines, at the position.  The computation involves the array
       values covered by the array and delineated by
       <function>upperExtent</function> and
       <function>lowerExtent</function>.</para>
--- 586,592 ----
      <caption>
       <para>To compute the value associated with index position (1,3)
       of an array, place the stencil's center, indicated with dashed
!      lines, at the position&nbsp;(1,3).  The computation involves the array
       values covered by the array and delineated by
       <function>upperExtent</function> and
       <function>lowerExtent</function>.</para>
***************
*** 607,625 ****
    must define a function call <function>operator()</function> with a
    container parameter and index parameters.  The number of index
    parameters, indicating the stencil's center, must equal the
!   container's dimension.  For example, <type>DoofNinePt</type>
!   defines <methodname>operator()(const C& c, int i, int
!   j)</methodname>.  We templated the container type
!   <varname>C</varname> although this is not strictly necessary.  The
!   two index parameters <varname>i</varname> and <varname>j</varname>
!   ensure the stencil works with two-dimensional containers.  The
!   <methodname>lowerExtent</methodname> indicates how far to the left
!   (or below) the stencil extends beyond its center.  Its parameter
!   indicates a particular dimension.  Index parameters
    <varname>i</varname> and <varname>j</varname> are in dimension 0
    and&nbsp;1.  <methodname>upperExtent</methodname> serves an
    analogous purpose.  The &poomatoolkit; uses these functions when
!   distribution computation among various processors, but it does not
    use these functions to ensure nonexistent &array; values are not
    accessed.  Caveat stencil user!</para>
   </section>
--- 601,619 ----
    must define a function call <function>operator()</function> with a
    container parameter and index parameters.  The number of index
    parameters, indicating the stencil's center, must equal the
!   container's dimension.  For example, <type>DoofNinePt</type> defines
!   <methodname>operator()(const C& c, int i, int j)</methodname>.  We
!   templated the container type <varname>C</varname> although this is
!   not strictly necessary.  The two index parameters
!   <varname>i</varname> and <varname>j</varname> ensure the stencil
!   works with two-dimensional containers.  The
!   <methodname>lowerExtent</methodname> function indicates how far to
!   the left (or below) the stencil extends beyond its center.  Its
!   parameter indicates a particular dimension.  Index parameters
    <varname>i</varname> and <varname>j</varname> are in dimension 0
    and&nbsp;1.  <methodname>upperExtent</methodname> serves an
    analogous purpose.  The &poomatoolkit; uses these functions when
!   distributing computation among various processors, but it does not
    use these functions to ensure nonexistent &array; values are not
    accessed.  Caveat stencil user!</para>
   </section>
***************
*** 634,640 ****
    only specify how each container's domain should be split into
    <quote>patches</quote>.  The &poomatoolkit; automatically
    distributes the data among the available processors and handles
!   any required communication among processors.</para>
  
    <example id="tutorial-array_distributed-doof2d">
     <title>Distributed Stencil &array; Implementation of &doof2d;</title>
--- 628,637 ----
    only specify how each container's domain should be split into
    <quote>patches</quote>.  The &poomatoolkit; automatically
    distributes the data among the available processors and handles
!   any required communication among processors.  <xref
!   linkend="tutorial-array_distributed-doof2d"></xref> illustrates how
!   to write a distributed version of the stencil program (<xref
!   linkend="tutorial-array_stencil-doof2d"></xref>).</para>
  
    <example id="tutorial-array_distributed-doof2d">
     <title>Distributed Stencil &array; Implementation of &doof2d;</title>
***************
*** 644,655 ****
       <para>Multiple copies of a distributed program may
       simultaneously run, perhaps each having its own input and
       output.  Thus, we use command-line arguments to pass input to
!      the program.  Using an &inform; object ensures only one program
       produces output.</para>
      </callout>
      <callout arearefs="tutorial-array_distributed-doof2d-layout">
       <para>The <type>UniformGridPartition</type> declaration
!      specifies how an array's domain will be partition, of split,
       into patches.  Guard layers are an optimization that can reduce
       data communication between patches.  The
       <type>UniformGridLayout</type> declaration applies the
--- 641,652 ----
       <para>Multiple copies of a distributed program may
       simultaneously run, perhaps each having its own input and
       output.  Thus, we use command-line arguments to pass input to
!      the program.  Using an &inform; object ensures only one copy
       produces output.</para>
      </callout>
      <callout arearefs="tutorial-array_distributed-doof2d-layout">
       <para>The <type>UniformGridPartition</type> declaration
!      specifies how an array's domain will be partitioned, or split,
       into patches.  Guard layers are an optimization that can reduce
       data communication between patches.  The
       <type>UniformGridLayout</type> declaration applies the
***************
*** 657,664 ****
       patches among various processors.</para>
      </callout>
      <callout arearefs="tutorial-array_distributed-doof2d-remote">
!      <para>The <type>MultiPatch</type> &engine; distributes requests
!      for &array; values to the associated patch.  Since a patch may
       associated with a different processor, its
       <quote>remote</quote> &engine; has type
       <type>Remote&lt;Brick&gt;</type>.  &pooma; automatically
--- 654,661 ----
       patches among various processors.</para>
      </callout>
      <callout arearefs="tutorial-array_distributed-doof2d-remote">
!      <para>The &multipatch; &engine; distributes requests
!      for &array; values to the associated patches.  Since a patch may
       associated with a different processor, its
       <quote>remote</quote> &engine; has type
       <type>Remote&lt;Brick&gt;</type>.  &pooma; automatically
***************
*** 675,690 ****
  
    <para>Supporting distributed computation requires only minor code
    changes.  These changes specify how each container's domain is
!   distributed among the available processors and how input and
!   output occurs.  The rest of the program, including all the
!   computations, remains the same.  When running, the &pooma;
!   executable interacts with the run-time library to determine which
!   processors are available, distributes the containers' domains, and
!   automatically handles all necessary interprocessor communication.
!   The same executable runs on one or many processors.  Thus, the
!   programmer can write one program, debugging it on a uniprocessor
!   computer and running it on a supercomputer.</para>
  
    <figure float="1" id="tutorial-array_distributed-doof2d-distributed_model">
     <title>The &pooma; Distributed Computation Model</title>
     <mediaobject>
--- 672,713 ----
  
    <para>Supporting distributed computation requires only minor code
    changes.  These changes specify how each container's domain is
!   distributed among the available processors and how input and output
!   occurs.  The rest of the program, including all the computations,
!   remains the same.  When running, the &pooma; executable interacts
!   with the run-time library to determine which processors are
!   available, distributes the containers' domains, and automatically
!   handles all necessary interprocessor communication.  The same
!   executable runs on one or many processors.  Thus, the programmer can
!   write one program, debugging it on a uniprocessor computer and run
!   it on a supercomputer.</para>
! 
!   <para>&pooma;'s distributed computing model separates container
!   domain concepts from computer configuration concepts.  See <xref
!   linkend="tutorial-array_distributed-doof2d-distributed_model"></xref>.
!   The statements in the program indicate how each container's domain
!   will be partitioned.  This process is represented in the upper left
!   corner of the figure.  A user-specified
!   <firstterm>partition</firstterm> specifies how to split the domain
!   into pieces.  For example, the illustrated partition splits the
!   domain into three equal-sized pieces along the x-dimension and two
!   equal-sized pieces along the y-dimension.  Applying the partition to
!   the domain creates <firstterm>patches</firstterm>.  The partition
!   also specifies external and internal guard layers.  A
!   <firstterm>guard layer</firstterm> is a domain surrounding a patch.
!   A patch's computation only reads but does not write these guarded
!   values.  An <firstterm>external guard layer</firstterm> conceptually
!   surrounds the entire container domain with boundary values whose
!   presence permits all domain computations to be performed the same
!   way even for computed values along the domain's edge.  An
!   <firstterm>internal guard layer</firstterm> duplicates values from
!   adjacent patches so communication need not occur during a patch's
!   computation.  The use of guard layers is an optimization; using
!   external guard layers eases programming and using internal guard
!   layers reduces communication among processors.  Their use is not
!   required.</para>
  
+ <!-- FIXME: Fix the "Computer Configuration" text layout so it does not overlap the box. -->
    <figure float="1" id="tutorial-array_distributed-doof2d-distributed_model">
     <title>The &pooma; Distributed Computation Model</title>
     <mediaobject>
***************
*** 695,732 ****
       <phrase>the &pooma; distributed computation model</phrase>
      </textobject>
      <caption>
!      <para>The &pooma; distributed computation model combines
!      partitioning containers' domains and the computer configuration
!      to create a layout.</para>
      </caption>
     </mediaobject>
    </figure>
  
-   <para>&pooma;'s distributed computing model separates container
-   domain concepts from computer configuration concepts.  See <xref
-   linkend="tutorial-array_distributed-doof2d-distributed_model"></xref>.
-   The program indicates how each container's domain will be
-   partitioned.  This process is represented in the upper left corner
-   of the figure.  A user-specified <firstterm>partition</firstterm>
-   specifies how to split the domain into pieces.  For example, the
-   illustrated partition splits the domain into three equal-sized
-   pieces along the x-dimension and two equal-sized pieces along the
-   y-dimension.  Thus, the domain is split into
-   <firstterm>patches</firstterm>.  The partition also specifies
-   external and internal guard layers.  A <firstterm>guard
-   layer</firstterm> is a domain surrounding a patch.  A patch's
-   computation only reads but does not write these guarded values.
-   An <firstterm>external guard layer</firstterm> conceptually
-   surrounds the entire container domain with boundary values whose
-   presence permits all domain computations to be performed the same
-   way even for values along the domain's edge.  An
-   <firstterm>internal guard layer</firstterm> duplicates values from
-   adjacent patches so communication need not occur during a patch's
-   computation.  The use of guard layers is an optimization; using
-   external guard layers eases programming and using internal guard
-   layers reduces communication among processors.  Their use is not
-   required.</para>
- 
    <para>The computer configuration of shared memory and processors
    is determined by the run-time system.  See the upper right portion
    of <xref
--- 718,730 ----
       <phrase>the &pooma; distributed computation model</phrase>
      </textobject>
      <caption>
!      <para>The &pooma; distributed computation model creates a layout
!      by combining a partitioning of the containers' domains and the
!      computer configuration.</para>
      </caption>
     </mediaobject>
    </figure>
  
    <para>The computer configuration of shared memory and processors
    is determined by the run-time system.  See the upper right portion
    of <xref
***************
*** 738,765 ****
    supercomputer consisting of desktop computers networked together
    might have as many contexts as computers.  The run-time system,
    e.g., the Message Passing Interface (&mpi;) Communications Library
!   (FIXME: xref linkend="mpi99", <ulink
!   url="http://www-unix.mcs.anl.gov/mpi/"></ulink>) or the &mm;
    Shared Memory Library (<ulink
    url="http://www.engelschall.com/sw/mm/"></ulink>), communicates
    the available contexts to the executable.  &pooma; must be
!   configured for the particular run-time system.  See <xref
    linkend="installation-distributed_computing"></xref>.</para>
  
    <para>A <firstterm>layout</firstterm> combines patches with contexts
    so the program can be executed.  If &distributedtag; is specified,
    the patches are distributed among the available contexts.  If
!   &replicatedtag; is specified, each set of patches is replicated
!   among each context.  Regardless, the containers' domains are now
    distributed among the contexts so the program can run.  When a patch
    needs data from another patch, the &poomatoolkit; sends messages to
!   the desired patch uses a message-passing library.  All such
!   communication is automatically performed by the &toolkit; with no need
!   for programmer or user input.</para>
! 
!   <para>FIXME: The two previous paragraphs demonstrate confusion
!   between <quote>run-time system</quote> and <quote>message-passing
!   library</quote>.</para>
  
    <para>Incorporating &pooma;'s distributed computation model into a
    program requires writing very few lines of code.  <xref
--- 736,759 ----
    supercomputer consisting of desktop computers networked together
    might have as many contexts as computers.  The run-time system,
    e.g., the Message Passing Interface (&mpi;) Communications Library
!   <!-- FIXME: xref linkend="mpi99", <ulink
!   url="http://www-unix.mcs.anl.gov/mpi/"></ulink> --> or the &mm;
    Shared Memory Library (<ulink
    url="http://www.engelschall.com/sw/mm/"></ulink>), communicates
    the available contexts to the executable.  &pooma; must be
!   configured for the particular run-time system in use.  See <xref
    linkend="installation-distributed_computing"></xref>.</para>
  
    <para>A <firstterm>layout</firstterm> combines patches with contexts
    so the program can be executed.  If &distributedtag; is specified,
    the patches are distributed among the available contexts.  If
!   &replicatedtag; is specified, each set of patches is replicated on
!   each context.  Regardless, the containers' domains are now
    distributed among the contexts so the program can run.  When a patch
    needs data from another patch, the &poomatoolkit; sends messages to
!   the desired patch uses the message-passing library.  All such
!   communication is automatically performed by the &toolkit; with no
!   need for programmer or user input.</para>
  
    <para>Incorporating &pooma;'s distributed computation model into a
    program requires writing very few lines of code.  <xref
***************
*** 772,783 ****
    copy of adjacent patches' outermost values.  This may speed
    computation because a patch need not synchronize its computation
    with other patches' processors.  Since each value's computation
!   requires knowing its surrounding neighbors, the internal guard
    layer is one layer deep.  The second <type>GuardLayers</type>
    argument specifies no external guard layer.  External guard layers
!   simplify computing values along the edges of domains.  Since the
!   program already uses only the interior domain for computation, we
!   do not use this feature.</para>
  
    <para>The <varname>layout</varname> declaration creates a
    <type>UniformGridLayout</type> layout.  As <xref
--- 766,777 ----
    copy of adjacent patches' outermost values.  This may speed
    computation because a patch need not synchronize its computation
    with other patches' processors.  Since each value's computation
!   requires knowing its surrounding neighbors, this internal guard
    layer is one layer deep.  The second <type>GuardLayers</type>
    argument specifies no external guard layer.  External guard layers
!   simplify computing values along the edges of domains.  Since our
!   program already uses only the interior domain for computation, we do
!   not use this feature.</para>
  
    <para>The <varname>layout</varname> declaration creates a
    <type>UniformGridLayout</type> layout.  As <xref
***************
*** 787,843 ****
    comprise <varname>layout</varname>'s three parameters; the
    contexts are implicitly supplied by the run-time system.</para>
  
!   <para>To create a distributed &array;, it should be created using
!   a &layout; object and have a &multipatch; &engine;.  Prior
!   implementations designed for uniprocessors constructed the
!   container using a &domain; object.  A distributed implementation
!   uses a &layout; object, which conceptually specifies a &domain;
!   object and its distribution throughout the computer.  A
!   &multipatch; &engine; supports computations using multiple patches.
!   The <type>UniformTag</type> indicates the patches all have the
!   same size.  Since patches may reside on different contexts, the
!   second template parameter is <type>Remote</type>.  Its
!   <type>Brick</type> template parameter specifies the &engine; for a
!   particular patch on a particular context.  Most distributed
!   programs use <type>MultiPatch&lt;UniformTag, Remote&lt;Brick&gt;
!   &gt;</type> or <type>MultiPatch&lt;UniformTag,
!   Remote&lt;CompressibleBrick&gt; &gt;</type> &engine;s.</para>
  
    <para>The computations for a distributed implementation are exactly
    the same as for a sequential implementation.  The &poomatoolkit; and
!   a message-passing library automatically perform all
    computation.</para>
  
    <para>Input and output for distributed programs is different than
!   for sequential programs.  Although the same instructions run on
!   each context, each context may have its own input and output
!   streams.  To avoid dealing with multiple input streams, we pass
!   the input via command-line arguments, which are replicated for
!   each context.  Using &inform; streams avoids having multiple
!   output streams print.  Any context can print to an &inform; stream
!   but only text sent to context&nbsp;0 is sent.  At the beginning of
!   the program, we create an &inform; object.  Throughout the rest of
!   the program, we use it instead of <varname>std::cout</varname> and
    <varname>std::cerr</varname>.</para>
  
    <para>The command to run the program is dependent on the run-time
    system.  To use &mpi; with the Irix&nbsp;6.5 operating system, one
    can use the <command>mpirun</command> command.  For example,
!   <statement>mpirun -np 4 Doof2d-Array-distributed -mpi 2 10
!   1000</statement> invokes the &mpi; run-time system with four
!   processors.  The <statement>-mpi</statement> option tells the
!   &pooma; executable <command>Doof2d-Array-distributed</command> to
!   use the &mpi; Library.  The remaining arguments specify the number
!   of processors, the number of averagings, and the array size.  The
!   first and last values are used for each dimension.  For example,
!   if three processors are specified, then the x-dimension will have
!   three processors and the y-dimension will have three processors,
!   totalling nine processors.  The command
!   <statement>Doof2d-Array-distributed -shmem -np 4 2 10
!   1000</statement> uses the &mm; Shared Memory Library
!   (<statement>-shmem</statement>) and four processors.  As for
!   &mpi;, the remaining command-line arguments are specified on a
!   per-dimension basis for the two-dimensional program.</para>
   </section>
  
  
--- 781,837 ----
    comprise <varname>layout</varname>'s three parameters; the
    contexts are implicitly supplied by the run-time system.</para>
  
!   <para>To create a distributed &array;, it should be created using a
!   &layout; object and have a &multipatch; &engine; rather than using a
!   &domain; object and a &brick; &engine; as we did for the
!   uniprocessor implementations.  A distributed implementation uses a
!   &layout; object, which conceptually specifies a &domain; object and
!   its distribution throughout the computer.  A &multipatch; &engine;
!   supports computations using multiple patches.  The
!   <type>UniformTag</type> indicates the patches all have the same
!   size.  Since patches may reside on different contexts, the second
!   template parameter is <type>Remote</type>.  Its <type>Brick</type>
!   template parameter specifies the &engine; for a particular patch on
!   a particular context.  Most distributed programs use
!   <type>MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt;</type> or
!   <type>MultiPatch&lt;UniformTag, Remote&lt;CompressibleBrick&gt;
!   &gt;</type> &engine;s.</para>
  
    <para>The computations for a distributed implementation are exactly
    the same as for a sequential implementation.  The &poomatoolkit; and
!   a message-passing library automatically perform all the
    computation.</para>
  
    <para>Input and output for distributed programs is different than
!   for sequential programs.  Although the same instructions run on each
!   context, each context may have its own input and output streams.  To
!   avoid dealing with multiple input streams, we pass the input via
!   command-line arguments, which are replicated for each context.
!   Using &inform; streams avoids having multiple output streams print.
!   Any context can print to an &inform; stream but only text sent to
!   context&nbsp;0 is displayed.  At the beginning of the program, we
!   create an &inform; object named <varname>output</varname>.
!   Throughout the rest of the program, we use it instead of
!   <varname>std::cout</varname> and
    <varname>std::cerr</varname>.</para>
  
    <para>The command to run the program is dependent on the run-time
    system.  To use &mpi; with the Irix&nbsp;6.5 operating system, one
    can use the <command>mpirun</command> command.  For example,
!   <command>mpirun -np 4 Doof2d-Array-distributed -mpi 2 10
!   1000</command> invokes the &mpi; run-time system with four
!   processors.  The <option>-mpi</option> option tells the &pooma;
!   executable <command>Doof2d-Array-distributed</command> to use the
!   &mpi; Library.  The remaining arguments specify the number of
!   processors, the number of averagings, and the array size.  The first
!   and last values are the same for each dimension.  For example, if three
!   processors are specified, then the x-dimension will have three
!   processors and the y-dimension will have three processors, totaling
!   nine processors.  The command <command>Doof2d-Array-distributed
!   -shmem -np 4 2 10 1000</command> uses the &mm; Shared Memory Library
!   (<option>-shmem</option>) and four processors.  As for &mpi;, the
!   remaining command-line arguments are specified on a per-dimension
!   basis for the two-dimensional program.</para>
   </section>
  
  
***************
*** 845,851 ****
    <title>Data-Parallel &field; Implementation</title>
  
    <para>&pooma; &array;s support many scientific computations, but
!   many scientific computations require values distributed throughout
    space, and &array;s have no spatial extent.  &pooma; &field;s,
    supporting a superset of &array; functionality, model values
    distributed throughout space.</para>
--- 839,845 ----
    <title>Data-Parallel &field; Implementation</title>
  
    <para>&pooma; &array;s support many scientific computations, but
!   other scientific computations require values distributed throughout
    space, and &array;s have no spatial extent.  &pooma; &field;s,
    supporting a superset of &array; functionality, model values
    distributed throughout space.</para>
***************
*** 861,869 ****
  
    <para>In this section, we implement the &doof2d; two-dimensional
    diffusion simulation program using &field;s.  This simulation does
!   not require any &field;-specific features, but we chose to present
    this program rather than one using &field;-specific features to
!   permit comparisons with the &array; versions, especially <xref
    linkend="tutorial-array_parallel-doof2d"></xref>.</para>
  
    <example id="tutorial-field_parallel-doof2d">
--- 855,863 ----
  
    <para>In this section, we implement the &doof2d; two-dimensional
    diffusion simulation program using &field;s.  This simulation does
!   not require any &field;-specific features, but we present
    this program rather than one using &field;-specific features to
!   facilitate comparison with the &array; versions, especially <xref
    linkend="tutorial-array_parallel-doof2d"></xref>.</para>
  
    <example id="tutorial-field_parallel-doof2d">
***************
*** 876,886 ****
       included.</para>
      </callout>
      <callout arearefs="tutorial-field_parallel-doof2d-mesh">
!      <para>These statements specify the spacing and number of
!      &field; values.  First, a layout is explicitly.  Then, a mesh,
!      which specifies the spacing between cells, is created.  The
!      &field;'s centering specifies one cell-centered value per
!      cell.</para>
      </callout>
      <callout arearefs="tutorial-field_parallel-doof2d-field_creation">
       <para>&field;'s first template parameter specifies the type of
--- 870,879 ----
       included.</para>
      </callout>
      <callout arearefs="tutorial-field_parallel-doof2d-mesh">
!      <para>These statements specify the spacing and number of &field;
!      values.  First, a layout is specified.  Then, a mesh, which
!      specifies the spacing between cells, is created.  The &field;'s
!      centering specifies one cell-centered value per cell.</para>
      </callout>
      <callout arearefs="tutorial-field_parallel-doof2d-field_creation">
       <para>&field;'s first template parameter specifies the type of
***************
*** 907,931 ****
    Since the above program is designed for uniprocessor computation,
    specifying the domain specifies the layout.  A &field;'s
    <firstterm>mesh</firstterm> specifies its spatial extent.  For
!   example, one can ask the mesh for the distance between two cells
!   or for the normals to a particular cell.  Cells in a
    <type>UniformRectilinearMesh</type> all have the same size and are
!   parallelepipeds.  To create the mesh, one specifies the layout,
!   the location of the spatial point corresponding to the lower, left
    domain location, and the size of a particular cell.  Since this
!   program does not use mesh computations, our choices do not much
!   matter.  We specify the domain's lower, left corner is at spatial
!   location (0.0, 0.0) and each cell's width and height is&nbsp;1.
!   Thus, the middle of the cell at domain position (3,4) is (3.5,
!   4.5).</para>
  
    <para>A &field; cell can contain one or more values although each
!   cell must have the same arrangement.  For this simulation, we
!   desire one value per cell so we place that position at the cell's
    center, i.e., a cell centering.  The
    <function>canonicalCentering</function> function returns such a
!   centering.  We defer discussion of the latter two arguments to
!   <xref linkend="sequential"></xref>.</para>
  
    <para>A &field; declaration is analogous to an &array; declaration
    but must also specify a centering and a mesh.  In <xref
--- 900,924 ----
    Since the above program is designed for uniprocessor computation,
    specifying the domain specifies the layout.  A &field;'s
    <firstterm>mesh</firstterm> specifies its spatial extent.  For
!   example, one can ask the mesh for the distance between two cells or
!   for the normals to a particular cell.  Cells in a
    <type>UniformRectilinearMesh</type> all have the same size and are
!   parallelepipeds.  To create the mesh, one specifies the layout, the
!   location of the spatial point corresponding to the lower, left
    domain location, and the size of a particular cell.  Since this
!   program does not use mesh computations, our choices do not matter.
!   We specify the domain's lower, left corner as spatial location (0.0,
!   0.0) and each cell's width and height as&nbsp;1.  Thus, the middle
!   of the cell at domain position (3,4) is (3.5, 4.5).</para>
  
    <para>A &field; cell can contain one or more values although each
!   cell must have the same arrangement of values.  For this simulation,
!   we desire one value per cell so we place that position at the cell's
    center, i.e., a cell centering.  The
    <function>canonicalCentering</function> function returns such a
!   centering.  <![%unfinished;[ We defer discussion of the latter two arguments
!   to <xref linkend="sequential"></xref> ]]> <!-- FIXME
!   unfinished --> .</para>
  
    <para>A &field; declaration is analogous to an &array; declaration
    but must also specify a centering and a mesh.  In <xref
***************
*** 938,954 ****
    the &engine; type.  Since a &field; has a centering and a mesh in
    addition to a layout, those arguments are also necessary.</para>
  
!   <para>&field; operations are a superset of &array; operations so
!   the &doof2d; computations are the same as for <xref
!   linkend="tutorial-array_parallel-doof2d"></xref>.  &field;
!   accesses require parentheses, not square brackets, and accesses to
!   particular values should be preceded by calls to
    <function>Pooma::blockAndEvaluate</function>.</para>
  
    <para>To summarize, &field;s support multiple values per cell and
    have spatial extent.  Thus, their declarations must specify a
    centering and a mesh.  Otherwise, a &field; program is similar to
!   one with &array;s.</para>
   </section>
  
  
--- 931,947 ----
    the &engine; type.  Since a &field; has a centering and a mesh in
    addition to a layout, those arguments are also necessary.</para>
  
!   <para>&field; operations are a superset of &array; operations so the
!   &doof2d; computations are the same as in <xref
!   linkend="tutorial-array_parallel-doof2d"></xref>.  &field; accesses
!   require parentheses, not square brackets, and accesses to individual
!   values should be preceded by calls to
    <function>Pooma::blockAndEvaluate</function>.</para>
  
    <para>To summarize, &field;s support multiple values per cell and
    have spatial extent.  Thus, their declarations must specify a
    centering and a mesh.  Otherwise, a &field; program is similar to
!   one using &array;s.</para>
   </section>
  
  
***************
*** 956,970 ****
    <title>Distributed &field; Implementation</title>
  
    <para>A &pooma; program using &field;s can execute on one or more
!   processors.  In <xref
!   linkend="tutorial-array_distributed"></xref>, we demonstrated how
!   to modify a uniprocessor stencil &array; implementation to run on
!   multiple processors.  In this section, we demonstrate that the
!   uniprocessor data-parallel &field; implementation of the previous
!   section can be converted.  Only the container declarations change;
!   the computations do not.  Since the changes are exactly analogous
!   to those in <xref linkend="tutorial-array_distributed"></xref>,
!   our exposition here will be shorter.</para>
  
    <example id="tutorial-field_distributed-doof2d">
     <title>Distributed Data-Parallel &field; Implementation of &doof2d;</title>
--- 949,963 ----
    <title>Distributed &field; Implementation</title>
  
    <para>A &pooma; program using &field;s can execute on one or more
!   processors.  In <xref linkend="tutorial-array_distributed"></xref>,
!   we demonstrated how to modify a uniprocessor stencil &array;
!   implementation to run on multiple processors.  In this section, we
!   demonstrate that the uniprocessor data-parallel &field;
!   implementation of the previous section can be similarly converted.
!   Only the container declarations change; the computations do not.
!   Since the changes are exactly analogous to those in <xref
!   linkend="tutorial-array_distributed"></xref>, our exposition here
!   will be shorter.</para>
  
    <example id="tutorial-field_distributed-doof2d">
     <title>Distributed Data-Parallel &field; Implementation of &doof2d;</title>
***************
*** 974,985 ****
       <para>Multiple copies of a distributed program may
       simultaneously run, perhaps each having its own input and
       output.  Thus, we use command-line arguments to pass input to
!      the program.  Using an &inform; stream ensures only one program
       produces output.</para>
      </callout>
      <callout arearefs="tutorial-field_distributed-doof2d-layout">
       <para>The <type>UniformGridPartition</type> declaration
!      specifies how an array's domain will be partition, of split,
       into patches.  Guard layers are an optimization that can reduce
       data communication between patches.  The
       <type>UniformGridLayout</type> declaration applies the
--- 967,978 ----
       <para>Multiple copies of a distributed program may
       simultaneously run, perhaps each having its own input and
       output.  Thus, we use command-line arguments to pass input to
!      the program.  Using an &inform; stream ensures only one copy
       produces output.</para>
      </callout>
      <callout arearefs="tutorial-field_distributed-doof2d-layout">
       <para>The <type>UniformGridPartition</type> declaration
!      specifies how an array's domain will be partitioned, or split,
       into patches.  Guard layers are an optimization that can reduce
       data communication between patches.  The
       <type>UniformGridLayout</type> declaration applies the
***************
*** 991,998 ****
       uniprocessor and multiprocessor implementations.</para>
      </callout>
      <callout arearefs="tutorial-field_distributed-doof2d-remote">
!      <para>The <type>MultiPatch</type> &engine; distributes requests
!      for &array; values to the associated patch.  Since a patch may
       associated with a different processor, its
       <quote>remote</quote> engine has type
       <type>Remote&lt;Brick&gt;</type>.  &pooma; automatically
--- 984,991 ----
       uniprocessor and multiprocessor implementations.</para>
      </callout>
      <callout arearefs="tutorial-field_distributed-doof2d-remote">
!      <para>The &multipatch; &engine; distributes requests
!      for &field; values to the associated patch.  Since a patch may
       associated with a different processor, its
       <quote>remote</quote> engine has type
       <type>Remote&lt;Brick&gt;</type>.  &pooma; automatically
***************
*** 1038,1051 ****
      </listitem>
      <listitem>
       <para>The command to invoke a distributed program is
!      system-dependent.  For example, the <statement>mpirun -np 4
!      Doof2d-Field-distributed -mpi 2 10 1000</statement> command
       might use &mpi; communication.
!      <statement>Doof2d-Field-distributed -shmem -np 4 2 10
!      1000</statement> might use the &mm; Shared Memory Library.</para>
      </listitem>
    </itemizedlist>
    </para>
   </section>
! <!-- FIXME: Do I need a chapter conclusion? -->
  </chapter>
--- 1031,1044 ----
      </listitem>
      <listitem>
       <para>The command to invoke a distributed program is
!      system-dependent.  For example, the <command>mpirun -np 4
!      Doof2d-Field-distributed -mpi 2 10 1000</command> command
       might use &mpi; communication.
!      <command>Doof2d-Field-distributed -shmem -np 4 2 10
!      1000</command> might use the &mm; Shared Memory Library.</para>
      </listitem>
    </itemizedlist>
    </para>
   </section>
! <!-- FIXME: Add a chapter conclusion. -->
  </chapter>

From jcrotinger at proximation.com  Thu Jan 24 20:58:05 2002
From: jcrotinger at proximation.com (James Crotinger)
Date: Thu, 24 Jan 2002 13:58:05 -0700
Subject: [pooma-dev] Manual: Wordsmithing Changes to First Four Chapte
	rs
Message-ID: <F871BB04B0EA224A821A5274C31DF315094267@proxim-sf001.santafe.proximation.com>


> Applied to	mainline.
> Approved by	Bill Clinton.
> 

Define "Approved". 8-)

BTW, are there instructions or tools included to print the manual? I haven't
looked at it lately, but I'd like to look it over at least briefly now that
it is approaching delivery. 

  Jim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/pooma-dev/attachments/20020124/8e2bc807/attachment.html>

From oldham at codesourcery.com  Fri Jan 25 02:33:33 2002
From: oldham at codesourcery.com (Jeffrey Oldham)
Date: Thu, 24 Jan 2002 18:33:33 -0800
Subject: Manual: Second Half Revised
Message-ID: <20020124183333.B7684@codesourcery.com>

2002-Jan-24  Jeffrey D. Oldham  <oldham at codesourcery.com>

	These changes continue moving the manual toward delivery.
	Unfinished sections remain in the DocBook source code but are not
	printed.  Wordsmithing concentrated on the Arrays, Engines,
	data-parallel, container views, and glossary chapters.  The
	incomplete index and unformatted bibliography sections are not
	printed.

	* Makefile (manual.dvi): Update dependences.
	(%.dvi): Improve rule.
	(clean): Add generated index.
	* arrays.xml: Wordsmithing, some format fixes, and some glossary
	links added.
	* bibliography.xml: Prevent printing of incomplete bibliography.
	* concepts.xml: Ensure table cells are aligned at the top of the
	rows.
	* data-parallel.xml: Wordsmithing, some format fixes, and some glossary
	links added.
	* glossary.xml: Wordsmithing and new 'see also' links added.
	(reference semantics): New entry.
	* manual.xml: Wordsmith partially-completed Engine chapter.
	Ensure table cells are aligned at the top of the rows.  Add
	introductory statement to POOMA installation appendix.  Turn off
	index.

Applied to the	mainline.
Approved by	you.

Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: Makefile
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/Makefile,v
retrieving revision 1.1
diff -c -p -r1.1 Makefile
*** Makefile	2002/01/14 17:33:33	1.1
--- Makefile	2002/01/25 02:15:02
*************** CXXFLAGS= -g -Wall -pedantic -W -Wstrict
*** 25,32 ****
  
  all: manual.ps
  
! manual.dvi: manual.xml introduction.xml tutorial.xml concepts.xml \
!             data-parallel.xml glossary.xml bibliography.xml
  
  %.all:	%.ps %.pdf %.html
  	chmod 644 $*.ps $*.pdf
--- 25,33 ----
  
  all: manual.ps
  
! manual.dvi: manual.xml introduction.xml template.xml tutorial.xml \
!             concepts.xml arrays.xml data-parallel.xml glossary.xml \
!             bibliography.xml
  
  %.all:	%.ps %.pdf %.html
  	chmod 644 $*.ps $*.pdf
*************** manual.dvi: manual.xml introduction.xml 
*** 50,58 ****
  
  # This rule assumes index creation.
  %.dvi:	%.xml genindex.sgm
! 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $<
! 	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index
! 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) $(XML) $< && jadetex $*.tex && jadetex $*.tex && jadetex $*.tex
  
  genindex.sgm:
  	perl collateindex.pl $(INDEXOPTIONS) -N -o $@
--- 51,59 ----
  
  # This rule assumes index creation.
  %.dvi:	%.xml genindex.sgm
! 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $< && \
! 	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index && \
! 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) -V tex-backend $(XML) $< && jadetex $*.tex && jadetex $*.tex && jadetex $*.tex
  
  genindex.sgm:
  	perl collateindex.pl $(INDEXOPTIONS) -N -o $@
*************** mproof-%.ps:	%.mp
*** 70,73 ****
  	detex $< > $@
  
  clean:
! 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.mpx mpxerr.tex HTML.index manual.tex
--- 71,74 ----
  	detex $< > $@
  
  clean:
! 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.mpx mpxerr.tex HTML.index manual.tex genindex.sgm
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.3
diff -c -p -r1.3 arrays.xml
*** arrays.xml	2002/01/24 05:11:21	1.3
--- arrays.xml	2002/01/25 02:15:03
***************
*** 2,44 ****
    <chapter id="arrays">
     <title>&array; Containers</title>
  
!    <para>A container is a class holding objects.  &array;s are one of
!    the two most widely used &pooma; containers since they model the
!    mathematical concept of mapping indices from domains to values.
     &pooma; &array;s extend built-in &cc; arrays by supporting a wider
!    variety of domains, automatically handling memory allocations, and
!    supporting first-class status.  For example, they may be used as
     operands and in assignments.  In this chapter, we introduce the
     concept of containers, the mathematical concept of arrays, and the
!    &pooma; concept for &array;s.  Before illustrating how to declare
!    &array;s, we introduce &domain;s, which specify the sets of
     indices.  After describing how to declare the various types of
!    &domain;s, we describe how to declare and use &array;s.  This is
!    illustrated in a &doof2d; implementation using &array;s.  We end
!    with a description of their implementation.</para>
  
  
     <section id="arrays-containers">
      <title>Containers</title>
  
      <para>A <glossterm
!     linkend="glossary-container"><firstterm>container class
!     expression</firstterm></glossterm> is a class with the main
!     purpose of holding objects.  These stored objects, called
!     <glossterm linkend="glossary-container_value"><firstterm>container
      values</firstterm></glossterm> or more simply
!     <quote>values</quote> or elements<quote></quote>, may be accessed
      and changed, usually using indices.  <quote>Container
!     class</quote> is usually abbreviated
      <quote>container</quote>.</para>
  
      <para>The six &pooma; containers can be categorized into two
      groups.  Mathematical containers include &tensor;s, &matrix;s, and
!     &vector;s, modeling tensors, matrices, and vectors, respectively.
      Storage containers include &array;s, &dynamicarray;s, and
      &field;s.  In this chapter, we focus on simplest of these:
!     &array;s.  The other containers will be described in subsequent
!     chapters.</para>
  
      <para>&c;&nbsp;has built-in arrays, and the &cc; Standard Library
      provides <type>map</type>s, <type>vector</type>s,
--- 2,46 ----
    <chapter id="arrays">
     <title>&array; Containers</title>
  
!    <para>A container is an object holding objects.  &array;s are one
!    of the two most widely used &pooma; containers since they model the
!    mathematical concept of mapping from domain indices to values.
     &pooma; &array;s extend built-in &cc; arrays by supporting a wider
!    variety of domains, automatically handling memory allocation, and
!    having first-class status.  For example, they may be used as
     operands and in assignments.  In this chapter, we introduce the
     concept of containers, the mathematical concept of arrays, and the
!    &pooma; implementation of &array;s.  Before illustrating how to
!    declare &array;s, we introduce &domain;s, which specify the sets of
     indices.  After describing how to declare the various types of
!    &domain;s, we describe how to declare and use &array;s.
! <![%unfinished;[
!    We end
!    with a description of their implementation.
! ]]>  <!-- end unfinished -->
!    </para>
  
  
     <section id="arrays-containers">
      <title>Containers</title>
  
      <para>A <glossterm
!     linkend="glossary-container"><firstterm>container
!     class</firstterm></glossterm> is a class whose main purpose is to
!     hold objects.  These stored objects, called <glossterm
!     linkend="glossary-container_value"><firstterm>container
      values</firstterm></glossterm> or more simply
!     <quote>values</quote> or <quote>elements</quote>, may be accessed
      and changed, usually using indices.  <quote>Container
!     class</quote> is usually abbreviated as
      <quote>container</quote>.</para>
  
      <para>The six &pooma; containers can be categorized into two
      groups.  Mathematical containers include &tensor;s, &matrix;s, and
!     &vector;s, which model tensors, matrices, and vectors, respectively.
      Storage containers include &array;s, &dynamicarray;s, and
      &field;s.  In this chapter, we focus on simplest of these:
!     &array;s.  &dynamicarray;s are also described.</para>
  
      <para>&c;&nbsp;has built-in arrays, and the &cc; Standard Library
      provides <type>map</type>s, <type>vector</type>s,
***************
*** 47,100 ****
      more functionality.  They automatically handle memory allocation
      and deallocation and can be used in expressions and on the
      left-hand side of assignments.  Since &pooma; containers separate
!     the container concepts of accessing and using values from storing
!     values, value storage can be optimized to specific needs.  For
!     example, if most of an &array;'s values are known to be the same
!     most of the time, a compressible engine can be used.  Whenever all
!     the array's values are the same, it stores only one value.  At
!     other times, it stores all the values.  Engines will be discussed
!     in <xref linkend="engines"></xref>.</para>
     </section>
  
  
     <section id="arrays-arrays">
      <title>&array;s</title>
  
!     <para>Mathematically, an array maps indices from a domain to
!     values.  Usually, the domain consists of a one-dimensional
!     integral interval or it may be multidimensional.  &pooma;'s
      &array; container class implements this idea.  Given an index,
!     i.e., a position in an &array;'s &domain;, it returns the associated
!     value, either by returning a stored value or by computing it.  The
!     use of indices, which are usually integral tuples but need not be
!     zero-based or even consist of all possible integral tuples in a
!     multidimensional range.  Using indices permits constant-time
      access to values although computing a particular value may require
      significant time.</para>
  
      <para>&pooma; &array;s are <glossterm
      linkend="glossary-first_class">first-class
!     types<firstterm></firstterm></glossterm> so they can be used more
!     widely than built-in &cc; arrays.  For example, &array;s can be
!     used as operands and in assignment statements.  The statement
!     <statement>a = a + b;</statement> adds corresponding elements of
      &array;s <varname>a</varname> and <varname>b</varname>, assigning
      the sums to the &array; <varname>a</varname>.  The statement
!     treats each array as one object, rather than requiring the use of
      one or more loops to access individual values.  Data-parallel
!     statements are further discussed in <xref
      linkend="data_parallel"></xref>.  &array;s also handle their own
      memory allocation and deallocation.  For example, the &array;
      declaration <statement>Array&lt;2, double, Brick&gt;
      a(vertDomain)</statement> creates an
      &array;&nbsp;<varname>a</varname>, allocating whatever memory it
      needs.  When <varname>a</varname> goes out of scope, it and its
!     memory is automatically deallocated.  Automatic memory allocation
!     and deallocation also eases copying.  As we mentioned above, an
!     &array;'s &engine; stores or computes its values so it, not the
!     &array; itself, is responsible for memory allocation and
!     deallocation.  Fortunately, this distinction is usually hidden
!     from the &pooma; user.</para>
  
      <para>Individual &array; values can be accessed using parentheses,
      not square brackets, as for &cc; arrays.  For example,
--- 49,98 ----
      more functionality.  They automatically handle memory allocation
      and deallocation and can be used in expressions and on the
      left-hand side of assignments.  Since &pooma; containers separate
!     the concepts of accessing and using values from the concept of
!     storing values, value storage can be optimized to specific needs.
!     For example, if most of an &array;'s values are known to be
!     identical most of the time, a compressible engine can be used.
!     Whenever all the array's values are identical, it stores only one
!     value.  At other times, it stores all the values.  Engines will be
!     discussed in <xref linkend="engines"></xref>.</para>
     </section>
  
  
     <section id="arrays-arrays">
      <title>&array;s</title>
  
!     <para>Mathematically, an array maps domain indices to values.
!     Usually, the domain consists of a one-dimensional integral
!     interval or it may be a multidimensional domain.  &pooma;'s
      &array; container class implements this idea.  Given an index,
!     i.e., a position in an &array;'s &domain;, it returns the
!     associated value, either by returning a stored value or by
!     computing it.  The indices are usually integral tuples but need
!     not be zero-based or even consist of all possible integral tuples
!     in a multidimensional range.  Using indices permits constant-time
      access to values although computing a particular value may require
      significant time.</para>
  
      <para>&pooma; &array;s are <glossterm
      linkend="glossary-first_class">first-class
!     objects<firstterm></firstterm></glossterm> so they can be used
!     more easily than built-in &cc; arrays.  For example, &array;s can
!     be used as operands and in assignment statements.  The statement
!     <statement>a = a + b;</statement> adds corresponding values of
      &array;s <varname>a</varname> and <varname>b</varname>, assigning
      the sums to the &array; <varname>a</varname>.  The statement
!     treats each array as an object, rather than requiring the use of
      one or more loops to access individual values.  Data-parallel
!     statements such as this are further discussed in <xref
      linkend="data_parallel"></xref>.  &array;s also handle their own
      memory allocation and deallocation.  For example, the &array;
      declaration <statement>Array&lt;2, double, Brick&gt;
      a(vertDomain)</statement> creates an
      &array;&nbsp;<varname>a</varname>, allocating whatever memory it
      needs.  When <varname>a</varname> goes out of scope, it and its
!     memory are automatically deallocated.  Automatic memory allocation
!     and deallocation also eases copying.</para>
  
      <para>Individual &array; values can be accessed using parentheses,
      not square brackets, as for &cc; arrays.  For example,
***************
*** 108,125 ****
  
      <para>A <glossterm
      linkend="glossary-domain"><firstterm>domain</firstterm></glossterm>
!     specifies the set of points on which an &array; can define values.
!     These indices are the arguments placed within parentheses when
!     selecting particular values, as described previously.  A domain
!     supported both by &array;s and by built-in &cc; arrays is an
      interval [0,n-1] of integers containing all integers {0, 1, 2,
      &hellip;, n-1}.  For &cc;, every integer in the interval must be
      included, and the minimum index must be zero.  &pooma; expands the
      set of permissible domains to support intervals with nonzero
!     minimal indices and strides and by adding other choices.</para>
  
!     <para>In &pooma;, &domain;s implement domains.  There are four
!     different categories:
       <variablelist>
        <varlistentry>
         <term>&loc;</term>
--- 106,123 ----
  
      <para>A <glossterm
      linkend="glossary-domain"><firstterm>domain</firstterm></glossterm>
!     specifies the set of points on which an array can define values.
!     These indices are the arguments placed within parentheses to
!     select particular values, as described previously.  A domain
!     supported both by &array;s and by built-in &cc; arrays is the
      interval [0,n-1] of integers containing all integers {0, 1, 2,
      &hellip;, n-1}.  For &cc;, every integer in the interval must be
      included, and the minimum index must be zero.  &pooma; expands the
      set of permissible domains to support intervals with nonzero
!     minimal indices, nonzero strides, and other options.</para>
  
!     <para>In &pooma;, &domain; classes implement domains.  There are
!     four different categories:
       <variablelist>
        <varlistentry>
         <term>&loc;</term>
***************
*** 150,156 ****
         </listitem>
        </varlistentry>
       </variablelist>
!     One-dimensional and multidimensional versions of each categories
      are supported.  A multidimensional &domain; consists of the direct
      product of one-dimensional &domain;s.  For example, the first
      dimension of a two-dimensional interval [0,3]x[2,9] is the
--- 148,154 ----
         </listitem>
        </varlistentry>
       </variablelist>
!     One-dimensional and multidimensional versions of the categories
      are supported.  A multidimensional &domain; consists of the direct
      product of one-dimensional &domain;s.  For example, the first
      dimension of a two-dimensional interval [0,3]x[2,9] is the
***************
*** 178,198 ****
      example, [2:4:2,6:4:-2] contains (2,6), (2,4), (4,6),
      and&nbsp;(4,4).</para>
  
!     <para>All the &domain; categories listed above except &grid; can be
!     represented using domain triplet notation.  Since the triplet
      [7:7:1] represents {7}, or more simply&nbsp;7, it can also
!     represent <statement>Loc<1>(7)</statement>.  Multidimensional
!     &loc;s are similarly represented.  For example,
      [0:0:1,10:10:1,2:2:1] represents
      <statement>Loc<3>(0,10,2)</statement>, but it is frequently
      abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
!     [a:b:1], while a &range; has specific stride&nbsp;s:
      [a:b:s].</para>
  
!     <para>&domain;s can be constructed by combining &domain;s of smaller
!     dimension.  For example, since a two-dimensional &interval; is the
!     direct product of two one-dimensional &interval;s, it can be
!     specified using two one-dimensional &interval;s.  For example,
      <statement>Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
      Interval&lt;1&gt;(4,5))</statement> creates a [2:3:1,4:5:1]
      &domain;.  The resulting dimensionality equals the sum of the
--- 176,197 ----
      example, [2:4:2,6:4:-2] contains (2,6), (2,4), (4,6),
      and&nbsp;(4,4).</para>
  
!     <para>All the &domain; categories listed above except &grid; can
!     be represented using domain triplet notation.  Since the triplet
      [7:7:1] represents {7}, or more simply&nbsp;7, it can also
!     represent the one-dimensional <statement>Loc<1>(7)</statement>.
!     Multidimensional &loc;s are similarly represented.  For example,
      [0:0:1,10:10:1,2:2:1] represents
      <statement>Loc<3>(0,10,2)</statement>, but it is frequently
      abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
!     [a:b:1], while a &range; has specific stride&nbsp;s, e.g.,
      [a:b:s].</para>
  
!     <para>&domain;s can be constructed by combining &domain;s with
!     smaller dimension.  For example, since a two-dimensional
!     &interval; is the direct product of two one-dimensional
!     &interval;s, it can be specified using two one-dimensional
!     &interval;s.  For example,
      <statement>Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
      Interval&lt;1&gt;(4,5))</statement> creates a [2:3:1,4:5:1]
      &domain;.  The resulting dimensionality equals the sum of the
***************
*** 220,248 ****
      units to the right by adding two.  Multiplying a &domain; by two
      multiplies its triplet's beginnings, endings, and strides by two.
      &pooma; users rarely need to compare &domain;s, but we describe
!     operating with the less-than operator on &interval;s.  &interval;
      <varname>d1</varname> &lt; &interval; <varname>d2</varname> if the
      length of <varname>d1's</varname> interval is less than
      <varname>d2</varname>'s or, if equal, its beginning value is
!     smaller.  &domain; arithmetic is frequently used with data-parallel
!     statements and container views.  These will be discussed in <xref
!     linkend="data_parallel"></xref> and <xref
      linkend="views"></xref>.</para>
  
      <para>The current &pooma; implementation supports &domain;s with
      dimensionality between one and seven, inclusive.  Since most
      scientific computations use one, two, or three dimensions, this is
!     usually sufficient.  If more dimensions are needed, they can be
!     added to the source code.</para>
  
  
      <section id="arrays-domains-declarations">
       <title>Declaring &domain;s</title>
  
       <para>Since &domain;s are mainly used to declare container
!      domains, we focus on declaring &domain;s.  We describe a few
!      &domain; operations but most, including arithmetic operations with
!      &domain;s, are described in <xref linkend="views"></xref>.</para>
  
       <para>All &domain; declarations require a dimension template
       parameter&nbsp;<varname>&dim;</varname>.  This positive integer
--- 219,248 ----
      units to the right by adding two.  Multiplying a &domain; by two
      multiplies its triplet's beginnings, endings, and strides by two.
      &pooma; users rarely need to compare &domain;s, but we describe
!     operating with the less-than operator on &interval;s: &interval;
      <varname>d1</varname> &lt; &interval; <varname>d2</varname> if the
      length of <varname>d1's</varname> interval is less than
      <varname>d2</varname>'s or, if equal, its beginning value is
!     smaller.  &domain; arithmetic is frequently used with
!     data-parallel statements and container views.  These will be
!     discussed in <xref linkend="data_parallel"></xref> and <xref
      linkend="views"></xref>.</para>
  
      <para>The current &pooma; implementation supports &domain;s with
      dimensionality between one and seven, inclusive.  Since most
      scientific computations use one, two, or three dimensions, this is
!     usually sufficient.  If more dimensions than seven are needed,
!     they can be added to the source code.</para>
  
  
      <section id="arrays-domains-declarations">
       <title>Declaring &domain;s</title>
  
       <para>Since &domain;s are mainly used to declare container
!      domains, we focus on declaring &domain;s.  We subsequently
!      describe a few &domain; operations but most, including arithmetic
!      operations with &domain;s, are described in <xref
!      linkend="views"></xref>.</para>
  
       <para>All &domain; declarations require a dimension template
       parameter&nbsp;<varname>&dim;</varname>.  This positive integer
***************
*** 255,267 ****
       one-dimensional &domain;s carry over to multidimensional
       ones.</para>
  
!      <para>To declare a &domain;, one must include the
!      <filename class="headerfile">Pooma/Domains.h</filename> header
!      file.  However, most &pooma; programs declare &domain;s to use them
!      when constructing containers.  The container header files
!      automatically include <filename
!      class="headerfile">Pooma/Domains.h</filename> so no explicit
!      inclusion is usually necessary.</para>
  
  
       <section id="arrays-domains-declarations-loc">
--- 255,266 ----
       one-dimensional &domain;s carry over to multidimensional
       ones.</para>
  
!      <para>To declare a &domain;, one must include the <filename
!      class="headerfile">Pooma/Domains.h</filename> header file.
!      However, most &pooma; programs use &domain;s when constructing
!      containers.  The storage container header files automatically
!      include <filename class="headerfile">Pooma/Domains.h</filename>
!      so no explicit inclusion is usually necessary.</para>
  
  
       <section id="arrays-domains-declarations-loc">
***************
*** 292,301 ****
  	  <entry></entry>
  	 </row>
  	</tfoot>
! 	<tbody>
  	 <row>
  	  <entry><statement>Loc&lt;1&gt;()</statement></entry>
! 	  <entry>points to zero.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Loc&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
--- 291,300 ----
  	  <entry></entry>
  	 </row>
  	</tfoot>
! 	<tbody valign="top">
  	 <row>
  	  <entry><statement>Loc&lt;1&gt;()</statement></entry>
! 	  <entry>indicates zero.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Loc&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
***************
*** 330,345 ****
        will be assigned later.  For small &domain;s such as &loc;s, the
        time savings from not initializing is small, but the
        functionality is still available.  The constructor taking one
!       argument with type&nbsp;<type>&domaintemplate;1</type> converts this argument to
!       an integer to specify the point.  The template
!       type&nbsp;<type>&domaintemplate;1</type> may be any type that can be converted
!       to an integer, e.g., &bool;, &char;, &int;, or &double;.  The
!       constructors taking two and three arguments of templatized types
!       facilitate converting an &interval; and a &range; into a &loc;.
!       Since a &loc; represents a single point, the &interval;'s or
!       &range;'s first two arguments must be equal.  The stride is
!       ignored.  Again, the templatized types may be any type that can
!       be converted into an integer.</para>
  
        <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	     orient="port" pgwide="0" id="arrays-domains-declarations-loc-multi_d_table">
--- 329,344 ----
        will be assigned later.  For small &domain;s such as &loc;s, the
        time savings from not initializing is small, but the
        functionality is still available.  The constructor taking one
!       argument with type&nbsp;<type>&domaintemplate;1</type> converts
!       this argument to an integer to specify the point.  The template
!       type&nbsp;<type>&domaintemplate;1</type> may be any type that
!       can be converted to an integer, e.g., &bool;, &char;, &int;, or
!       &double;.  The constructors taking two and three arguments of
!       templatized types facilitate converting an &intervalone; and a
!       &rangeone; into a &locone;.  Since a &loc; represents a single
!       point, the &interval;'s or &range;'s first two arguments must be
!       equal.  The stride is ignored.  Again, the templatized types may
!       be any type that can be converted into an integer.</para>
  
        <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	     orient="port" pgwide="0" id="arrays-domains-declarations-loc-multi_d_table">
***************
*** 359,368 ****
  	  template parameters.</entry>
  	 </row>
  	</tfoot>
! 	<tbody>
  	 <row>
  	  <entry><statement>Loc&lt;&dim;&gt;()</statement></entry>
! 	  <entry>points to zero.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
--- 358,367 ----
  	  template parameters.</entry>
  	 </row>
  	</tfoot>
! 	<tbody valign="top">
  	 <row>
  	  <entry><statement>Loc&lt;&dim;&gt;()</statement></entry>
! 	  <entry>indicates zero.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
***************
*** 465,471 ****
  	  <entry></entry>
  	 </row>
  	</tfoot>
! 	<tbody>
  	 <row>
  	  <entry><statement>Interval&lt;1&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized interval.</entry>
--- 464,470 ----
  	  <entry></entry>
  	 </row>
  	</tfoot>
! 	<tbody valign="top">
  	 <row>
  	  <entry><statement>Interval&lt;1&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized interval.</entry>
***************
*** 476,491 ****
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates a &intervalone;.  See the text for an explanation.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates a &intervalone; with the integers converted from
  	  <varname>t1</varname> and <varname>t2</varname>.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates a &intervalone; with the integers converted from
  	  <varname>t1</varname> and <varname>t2</varname>.
  	  <varname>t3</varname> must equal&nbsp;1.</entry>
  	 </row>
--- 475,490 ----
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates an &intervalone;.  See the text for an explanation.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates an &intervalone; with the integers converted from
  	  <varname>t1</varname> and <varname>t2</varname>.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates an &intervalone; with the integers converted from
  	  <varname>t1</varname> and <varname>t2</varname>.
  	  <varname>t3</varname> must equal&nbsp;1.</entry>
  	 </row>
***************
*** 497,512 ****
        constructors except that &intervalone;s can have differing
        beginning and ending points.  See <xref
        linkend="arrays-domains-declarations-interval-one_d_table"></xref>.
!       The default constructor creates an empty, uninitialized interval,
!       which should not be used before assigning it values.  If the
!       one-parameter constructor's argument is a &domain; object, it must
!       be a one-dimensional &domain; object which is copied into an
!       &interval; if possible; for example, it must have unit stride.
!       If the one-parameter constructor's argument is not a &domain;
!       object, it must be convertible to an
        integer&nbsp;<varname>e</varname> and an interval [0:e-1:1]
!       starting at zero is constructed.  If two arguments are specified,
!       they are assumed to be convertible to integers
        <varname>b</varname> and <varname>e</varname>, specifying the
        interval [b:e:1].  The three-parameter constructor is similar,
        with the third argument specifying a stride, which must be
--- 496,512 ----
        constructors except that &intervalone;s can have differing
        beginning and ending points.  See <xref
        linkend="arrays-domains-declarations-interval-one_d_table"></xref>.
!       The default constructor creates an empty, uninitialized
!       interval, which should not be used before assigning it values.
!       If the one-parameter constructor's argument is a &domain;
!       object, it must be a one-dimensional &domain; object which is
!       converted into an &interval; if possible; for example, it must have
!       unit stride.  If the one-parameter constructor's argument is not
!       a &domain; object, it must be convertible to an
        integer&nbsp;<varname>e</varname> and an interval [0:e-1:1]
!       starting at zero is constructed.  Note e-1, not e, is used so
!       the &intervalone; has e indices.  If two arguments are
!       specified, they are assumed to be convertible to integers
        <varname>b</varname> and <varname>e</varname>, specifying the
        interval [b:e:1].  The three-parameter constructor is similar,
        with the third argument specifying a stride, which must be
***************
*** 530,536 ****
  	  template parameters.</entry>
  	 </row>
  	</tfoot>
! 	<tbody>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
--- 530,536 ----
  	  template parameters.</entry>
  	 </row>
  	</tfoot>
! 	<tbody valign="top">
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
***************
*** 541,578 ****
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; object.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5, const &domaintemplate;6&amp; t6)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
! 	  <entry>creates a &interval; using the given &domain; objects.</entry>
  	 </row>
  	</tbody>
         </tgroup>
--- 541,578 ----
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
! 	  <entry>creates an &interval; using the given &domain; object.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
! 	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
! 	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
! 	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5)</statement></entry>
! 	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5, const &domaintemplate;6&amp; t6)</statement></entry>
! 	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
  	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
  	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
! 	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	</tbody>
         </tgroup>
***************
*** 635,641 ****
  	  <entry></entry>
  	 </row>
  	</tfoot>
! 	<tbody>
  	 <row>
  	  <entry><statement>Range&lt;1&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized range.</entry>
--- 635,641 ----
  	  <entry></entry>
  	 </row>
  	</tfoot>
! 	<tbody valign="top">
  	 <row>
  	  <entry><statement>Range&lt;1&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized range.</entry>
***************
*** 665,684 ****
        </table>
  
        <para>&rangeone; constructors are the same as &intervalone;
!       constructors except they create ranges, not intervals.  See <xref
        linkend="arrays-domains-declarations-range-one_d_table"></xref>.
        The default constructor creates an empty, uninitialized range,
        which should not be used before assigning it values.  If the
!       one-parameter constructor's argument is a &domain; object, it must
!       be a one-dimensional &domain; object which is copied into a &range;
!       if possible.  If the one-parameter constructor's argument is not
!       a &domain; object, it must be convertible to an
        integer&nbsp;<varname>e</varname> and a range [0:e-1:1] starting
!       at zero is constructed.  If two arguments are specified, they are
!       assumed to be convertible to integers <varname>b</varname> and
!       <varname>e</varname>, specifying the range [b:e:1].  The
!       three-parameter constructor is similar, with the third argument
!       specifying a stride.</para>
  
        <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	     orient="port" pgwide="0" id="arrays-domains-declarations-ranges-multi_d_table">
--- 665,686 ----
        </table>
  
        <para>&rangeone; constructors are the same as &intervalone;
!       constructors except they create ranges, not intervals.  See
!       <xref
        linkend="arrays-domains-declarations-range-one_d_table"></xref>.
        The default constructor creates an empty, uninitialized range,
        which should not be used before assigning it values.  If the
!       one-parameter constructor's argument is a &domain; object, it
!       must be a one-dimensional &domain; object which is converted
!       into a &range; if possible.  If the one-parameter constructor's
!       argument is not a &domain; object, it must be convertible to an
        integer&nbsp;<varname>e</varname> and a range [0:e-1:1] starting
!       at zero is constructed.  Note e-1, not e, is used so the
!       &intervalone; has e indices.  If two arguments are specified,
!       they are assumed to be convertible to integers
!       <varname>b</varname> and <varname>e</varname>, specifying the
!       range [b:e:1].  The three-parameter constructor is similar, with
!       the third argument specifying a stride.</para>
  
        <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	     orient="port" pgwide="0" id="arrays-domains-declarations-ranges-multi_d_table">
***************
*** 698,704 ****
  	  template parameters.</entry>
  	 </row>
  	</tfoot>
! 	<tbody>
  	 <row>
  	  <entry><statement>Range&lt;&dim;&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
--- 700,706 ----
  	  template parameters.</entry>
  	 </row>
  	</tfoot>
! 	<tbody valign="top">
  	 <row>
  	  <entry><statement>Range&lt;&dim;&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
***************
*** 807,813 ****
  	  <entry></entry>
  	 </row>
  	</tfoot>
! 	<tbody>
  	 <row>
  	  <entry><statement>Grid&lt;1&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized grid.</entry>
--- 809,815 ----
  	  <entry></entry>
  	 </row>
  	</tfoot>
! 	<tbody valign="top">
  	 <row>
  	  <entry><statement>Grid&lt;1&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized grid.</entry>
***************
*** 843,856 ****
  
        <para>&gridone;s with irregularly spaced points can be
        constructed using &indirectionlistint;s.  For example,
!  <programlisting>
!  IndirectionList&lt;int&gt; list(4);
!  list(0) = 2;
!  list(1) = 5;
!  list(2) = 6;
!  list(3) = 9;
!  Grid&lt;1&gt; g(list);
!  </programlisting> constructs an empty &indirectionlistint;, fills it
        with ascending values, and then creates a &gridone; containing
        {2, 5, 6, 9}.  When creating a list, its size must be specified.
        Subsequently, its values can be assigned.  &indirectionlist;s can
--- 845,858 ----
  
        <para>&gridone;s with irregularly spaced points can be
        constructed using &indirectionlistint;s.  For example,
! <programlisting>
! IndirectionList&lt;int&gt; list(4);
! list(0) = 2;
! list(1) = 5;
! list(2) = 6;
! list(3) = 9;
! Grid&lt;1&gt; g(list);
! </programlisting> constructs an empty &indirectionlistint;, fills it
        with ascending values, and then creates a &gridone; containing
        {2, 5, 6, 9}.  When creating a list, its size must be specified.
        Subsequently, its values can be assigned.  &indirectionlist;s can
***************
*** 885,891 ****
  	  parameters.</entry>
  	 </row>
  	</tfoot>
! 	<tbody>
  	 <row>
  	  <entry><statement>Grid&lt;&dim;&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized &grid;, to be assigned a value later.</entry>
--- 887,893 ----
  	  parameters.</entry>
  	 </row>
  	</tfoot>
! 	<tbody valign="top">
  	 <row>
  	  <entry><statement>Grid&lt;&dim;&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized &grid;, to be assigned a value later.</entry>
***************
*** 961,973 ****
  
       <para>Since an &array; can be queried for its domain, we briefly
       describe some &domain; operations.  A fuller description,
!      including arithmetic operations, occur in <xref
       linkend="views"></xref>.  As we mentioned in <xref
       linkend="arrays-domains-declarations"></xref>, the <filename
       class="headerfile">Pooma/Domains.h</filename> header file
!      declares &domain;s, but most container header files automatically
!      include <filename class="headerfile">Pooma/Domains.h</filename>
!      so no explicit inclusion of is usually necessary.</para>
  
       <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-domains-use-table">
--- 963,976 ----
  
       <para>Since an &array; can be queried for its domain, we briefly
       describe some &domain; operations.  A fuller description,
!      including arithmetic operations, occurs in <xref
       linkend="views"></xref>.  As we mentioned in <xref
       linkend="arrays-domains-declarations"></xref>, the <filename
       class="headerfile">Pooma/Domains.h</filename> header file
!      declares &domain;s, but most storage container header files
!      automatically include <filename
!      class="headerfile">Pooma/Domains.h</filename> so no explicit
!      inclusion is usually necessary.</para>
  
       <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-domains-use-table">
***************
*** 982,993 ****
         </thead>
         <tfoot>
  	<row>
! 	 <entry><type>D</type> abbreviates the particular &domain;
! 	 type, e.g., &interval; or &grid;.  Other &domain; accessors
! 	 are described in <xref linkend="views"></xref>.</entry>
  	</row>
         </tfoot>
!        <tbody>
  	<row rowsep="1">
  	 <entry>Multidimensional &domain; Accessors</entry>
  	</row>
--- 985,996 ----
         </thead>
         <tfoot>
  	<row>
! 	 <entry><type>D</type> abbreviates a particular &domain; type,
! 	 e.g., &interval; or &grid;.  Other &domain; accessors are
! 	 described in <xref linkend="views"></xref>.</entry>
  	</row>
         </tfoot>
!        <tbody valign="top">
  	<row rowsep="1">
  	 <entry>Multidimensional &domain; Accessors</entry>
  	</row>
***************
*** 1030,1041 ****
  	</row>
  	<row>
  	 <entry><statement>D&lt;1&gt;::iterator begin()</statement></entry>
! 	 <entry>returns a bidirectional iterator pointing to the
  	 beginning domain index.</entry>
  	</row>
  	<row>
  	 <entry><statement>D&lt;1&gt;::iterator end()</statement></entry>
! 	 <entry>returns a bidirectional iterator pointing to the ending
  	 domain index.</entry>
  	</row>
         </tbody>
--- 1033,1044 ----
  	</row>
  	<row>
  	 <entry><statement>D&lt;1&gt;::iterator begin()</statement></entry>
! 	 <entry>returns a forward iterator pointing to the
  	 beginning domain index.</entry>
  	</row>
  	<row>
  	 <entry><statement>D&lt;1&gt;::iterator end()</statement></entry>
! 	 <entry>returns a forward iterator pointing to the ending
  	 domain index.</entry>
  	</row>
         </tbody>
***************
*** 1054,1060 ****
       one-dimensional &domain;s.  The <methodname>operator[](int
       dimension)</methodname> operator extracts the one-dimensional
       &domain; corresponding to its parameter.  For example, the three
!      <type>Range&lt;1&gt;</type> (one-dimensional) &domain;s can be
       extracted from a <type>Range&lt;3&gt;</type>
       object&nbsp;<varname>r</varname> using
       <statement>r[0]</statement>, <statement>r[1]</statement>, and
--- 1057,1063 ----
       one-dimensional &domain;s.  The <methodname>operator[](int
       dimension)</methodname> operator extracts the one-dimensional
       &domain; corresponding to its parameter.  For example, the three
!      one-dimensional <type>Range&lt;1&gt;</type> &domain;s can be
       extracted from a <type>Range&lt;3&gt;</type>
       object&nbsp;<varname>r</varname> using
       <statement>r[0]</statement>, <statement>r[1]</statement>, and
***************
*** 1069,1075 ****
       <methodname>first</methodname> and <methodname>last</methodname>
       member functions return the domain's beginning and ending
       indices.  The <methodname>begin</methodname> and
!      <methodname>end</methodname> member functions return input
       iterators pointing to these respective locations.  They have type
       <type>D&lt;1&gt;::iterator</type>, where <type>D</type>
       abbreviates the &domain;'s type, e.g., &interval; or &grid;.
--- 1072,1078 ----
       <methodname>first</methodname> and <methodname>last</methodname>
       member functions return the domain's beginning and ending
       indices.  The <methodname>begin</methodname> and
!      <methodname>end</methodname> member functions return forward
       iterators pointing to these respective locations.  They have type
       <type>D&lt;1&gt;::iterator</type>, where <type>D</type>
       abbreviates the &domain;'s type, e.g., &interval; or &grid;.
***************
*** 1077,1086 ****
       --> The <methodname>min</methodname> and
       <methodname>max</methodname> member functions return the minimum
       and maximum indices in the &domain; object, respectively.  For
!      &locone; and &intervalone;, these are the same as
       <methodname>first</methodname> and <methodname>last</methodname>,
!      but &rangeone; and &gridone; can have their largest index at the
!      beginning of their &domain;s.</para>
      </section>
     </section>
  
--- 1080,1089 ----
       --> The <methodname>min</methodname> and
       <methodname>max</methodname> member functions return the minimum
       and maximum indices in the &domain; object, respectively.  For
!      &locone; and &intervalone;, these yield the same values as
       <methodname>first</methodname> and <methodname>last</methodname>,
!      but &rangeone; and &gridone; can have their numerically largest
!      index at the beginning of their &domain;s.</para>
      </section>
     </section>
  
***************
*** 1088,1100 ****
     <section id="arrays-arrays_declarations">
      <title>Declaring &array;s</title>
  
!     <para>A &pooma; &array; maps indices from its &domain; to values.
!     In this section, we first describe how to declare &array;s.  In
!     the next section, we explain how to access individual values
!     stored within an &array; and &array; copy semantics.</para>
  
      <para>&array; values need not just be stored values, as &c; arrays
!     have.  They can also be computed using its engine.  We defer
      discussion of computing values to the next chapter discussing
      engines (<xref linkend="engines"></xref>).  To avoid being verbose
      in this chapter, when we discuss stored values, the values might
--- 1091,1105 ----
     <section id="arrays-arrays_declarations">
      <title>Declaring &array;s</title>
  
!     <para>A &pooma; &array; maps &domain; indices to values.  In this
!     section, we describe how to declare &array;s.  In the next
!     section, we explain how to access individual values stored within
!     an &array; and how to copy &array;s.</para>
  
+ <!-- FIXME: This paragraph is poorly worded. -->
+ 
      <para>&array; values need not just be stored values, as &c; arrays
!     have.  They can also be computed by its engine.  We defer
      discussion of computing values to the next chapter discussing
      engines (<xref linkend="engines"></xref>).  To avoid being verbose
      in this chapter, when we discuss stored values, the values might
***************
*** 1102,1177 ****
  
      <para>Declaring an &array; requires four arguments: the domain's
      dimensionality, the type of values stored or computed, a
!     specification how the values are stored, and a &domain;.  The
!     first three arguments are template parameters since few scientific
!     programs (and no &pooma; programs) need to change these values
!     while a program executes.  For example, an &array; cannot change
!     the type of the elements it stores.  Alternatively, an &array;'s
!     values can be copied into another &array; having the desired type.
!     Although scientific programs do not frequently change an array's
!     domain, they do frequently request a subset of the array's values,
!     i.e., a <glossterm linkend="glossary-view">view</glossterm>.  The
!     subset is specified via a &domain; so it is a run-time value.
!     Views are presented in <xref linkend="views"></xref>.</para>
  
      <para>An &array;'s first template parameter specifies its
      dimensionality.  This positive
!     integer&nbsp;<varname>&dim;</varname> specifies its rank.  This is
      the same value as its domain's dimensionality.  Theoretically, an
      &array; can have any positive integer, but the &pooma; code
!     currently supports <varname>&dim;</varname> at most seven.  For
!     almost all scientific codes, a dimension of three or four is
!     sufficient, but the code can be extended to support higher
      dimensions.</para>
  
      <para>An &array;'s second template parameter specifies the type of
!     its stored values.  Common value types include &int;, &double;,
!     &complex;, and &vector;, but any type is permissible.  For
!     example, an &array;'s values might be matrices or even other
      &array;s.  The parameter's default value is usually &double;, but
      it may be changed when the &poomatoolkit; is configured.</para>
  
      <para>An &array;'s third parameter specifies how its data is
!     stored by an &engine; and its values accessed.  The argument is a
!     tag indicating a particular type of &engine;.  Permissible tags
!     include &brick;, &compressiblebrick;, and
      <type>ConstantFunction</type>.  The &brick; tag indicates all
      &array; values will be explicitly stored, just as built-in &c;
!     arrays do.  If the &array;s frequently stores exactly the same
!     value in every position, a &compressiblebrick; &engine;, which
!     reduces its space requirements to a constant whenever all its
!     values are the same, is appropriate.  A
!     <type>ConstantFunction</type> &engine; returns the same value for
!     all indices.</para>
  
      <para>Even though every &array; container has an engine to store
!     its values and permit access to individual values, an &array; is
!     conceptually separated from engines.  An engine's role is
!     low-level, storing values and permitting access to individual
!     values.  As we indicated above, the storage can be optimized to
!     fit specific situations such as few nonzero values and computing
!     values using a function applied to another engine's values.  An
!     &array;'s role is high-level, supporting access to groups of
!     values.  They handle memory allocation and deallocation.  &array;s
!     can be used in data-parallel expressions, e.g., adding all the
!     values in one &array; to all the values in another.  (See <xref
!     linkend="data_parallel"></xref> for more information.)  Subsets of
!     &array; values, frequently used in data-parallel statements, can
!     be obtained.  (See <xref linkend="views"></xref> for more
!     information.)  Even though engines and &array;s are conceptually
!     separate, higher-level &array;s provide access to lower-level
!     &engine;s.  Users usually have an &array; create its &engine;,
!     rarely explicitly creating &engine;s themselves.  Also, &array;s
!     provide access to individual values.  In short, &pooma; users use
!     &array;s, only dealing with how they are implemented (engines)
!     upon declaration.  For more description of &engine;s, see <xref
      linkend="engines"></xref>.</para>
- 
-     <para>The engine parameter's default value is usually &brick;, but
-     it may be changed when the &poomatoolkit; is configured.</para>
  
!     <para>An &array;'s one constructor argument is its domain.  The
!     domain specifies its extent and simultaneously how many values it
      can return.  All the provided &domain; objects are combined to
      yield an <type>Interval&lt;&dim;&gt;</type>, where &dim; matches
      the &array;'s first template parameter.  Since an &interval;
--- 1107,1186 ----
  
      <para>Declaring an &array; requires four arguments: the domain's
      dimensionality, the type of values stored or computed, a
!     specification how the values are stored or computed, and a
!     &domain;.  The first three arguments are template parameters since
!     few scientific programs need to (and no &pooma; programs can)
!     change these values while a program executes.  For example, an
!     &array; cannot change the type of the values it stores, but an
!     &array;'s values can be copied into another &array; having the
!     desired type.  Although scientific programs do not frequently
!     change an array's domain, they do frequently request a subset of
!     the array's values, i.e., a <glossterm
!     linkend="glossary-view">view</glossterm>.  The subset is specified
!     via a &domain; so it is a run-time value.  Views are presented in
!     <xref linkend="views"></xref>.</para>
  
      <para>An &array;'s first template parameter specifies its
      dimensionality.  This positive
!     integer&nbsp;<varname>&dim;</varname> specifies its rank and has
      the same value as its domain's dimensionality.  Theoretically, an
      &array; can have any positive integer, but the &pooma; code
!     currently supports a dimensionality of at most seven.  For almost
!     all scientific codes, a dimension of three or four is sufficient,
!     but the &pooma; code can be extended to support higher
      dimensions.</para>
  
      <para>An &array;'s second template parameter specifies the type of
!     its stored or computed values.  Common value types include &int;,
!     &double;, &complex;, and &vector;, but any type is permissible.
!     For example, an &array;'s values might be matrices or even other
      &array;s.  The parameter's default value is usually &double;, but
      it may be changed when the &poomatoolkit; is configured.</para>
  
      <para>An &array;'s third parameter specifies how its data is
!     stored or computed by an &engine; and its values accessed.  The
!     argument is a tag indicating a particular type of &engine;.
!     Permissible tags include &brick;, &compressiblebrick;, and
      <type>ConstantFunction</type>.  The &brick; tag indicates all
      &array; values will be explicitly stored, just as built-in &c;
!     arrays do.  If an &array; frequently stores exactly the same value
!     in every position, a &compressiblebrick; &engine;, which reduces
!     its space requirements to a constant whenever all its values are
!     the same, is appropriate.  A <type>ConstantFunction</type>
!     &engine; returns the same value for all indices.  Some &engine;s
!     compute values, e.g., applying a function to every value in
!     another &engine;.  These &engine;s are discussed in <xref
!     linkend="engines"></xref>.  To avoid being verbose in the rest of
!     this chapter, we abbreviate <quote>store or compute values</quote>
!     as <quote>store values</quote>.  The engine parameter's default
!     value is usually &brick;, but it may be changed when the
!     &poomatoolkit; is configured.</para>
  
      <para>Even though every &array; container has an engine to store
!     its values and permit access to individual values, the concept of
!     an &array; is conceptually separate from the concept of an engine.
!     An engine's role is low-level, storing values and permitting
!     access to individual values.  As we indicated above, the storage
!     can be optimized to fit specific situations such as few nonzero
!     values and computing values using a function applied to another
!     engine's values.  An &array;'s role is high-level, supporting
!     access to groups of values.  &array;s can be used in data-parallel
!     expressions, e.g., adding all the values in one &array; to all the
!     values in another.  (See <xref linkend="data_parallel"></xref> for
!     more information.)  Subsets of &array; values, frequently used in
!     data-parallel statements, can be obtained.  (See <xref
!     linkend="views"></xref> for more information.)  Even though
!     engines and &array;s are conceptually separate, higher-level
!     &array;s provide access to lower-level &engine;s.  Users usually
!     have an &array; create its &engine;(s), rarely explicitly creating
!     &engine;s themselves.  Also, &array;s support access to individual
!     values.  In short, &pooma; users use &array;s, only dealing with
!     how they are implemented (engines) when declaring them.  For a
!     description of &engine;s, see <xref
      linkend="engines"></xref>.</para>
  
!     <para>An &array;'s one run-time argument is its domain.  The
!     domain specifies its extent and consequently how many values it
      can return.  All the provided &domain; objects are combined to
      yield an <type>Interval&lt;&dim;&gt;</type>, where &dim; matches
      the &array;'s first template parameter.  Since an &interval;
***************
*** 1185,1190 ****
--- 1194,1240 ----
      required, the &pooma; code can be extended to the desired number
      of dimensions.</para>
  
+     <para>&array; constructors are listed in <xref
+     linkend="arrays-arrays_declarations-table"></xref>.  An &array;'s
+     three template parameters for dimensionality, value type, and
+     engine type are abbreviated <varname>D</varname>,
+     <varname>T</varname>, and <varname>E</varname>.  Template
+     parameters for domain types are named <varname>DT1</varname>,
+     &hellip;, <varname>DT7</varname>.  The first constructor, with no
+     domain arguments, creates an empty, uninitialized &array; for
+     which a domain must be specified before it is used.  Specify the
+     array's domain using its <methodname>initialize</methodname>
+     function.  The next seven constructors combine their domain
+     arguments to compute the resulting &array;'s domain.  These are
+     combined in the same way that multidimensional &interval;s are
+     constructed.  (See <xref
+     linkend="arrays-domains-declarations-intervals-multi_d_table"></xref>
+     and the following text.)  The domain objects, having types
+     <type>&domaintemplate;1</type>, &hellip;,
+     <type>&domaintemplate;7</type>, can have any type that can be
+     converted into an integer, into a single-dimensional &domain;
+     object that can be converted into a single-dimensional &interval;,
+     or to a multidimensional &domain; object that itself can be
+     converted into an &interval;.  The total dimensionality of all the
+     arguments' types should
+     <emphasis>equal</emphasis>&nbsp;<varname>&dim;</varname>, unlike
+     &interval; construction which permits total dimensionality less
+     than or equal to&nbsp;<varname>&dim;</varname>.  One-dimensional
+     &domain; objects that can be converted into one-dimensional
+     &interval;s include &locone;s, &intervalone;s, and &rangeone;s
+     with unit strides.  To initialize all of an &array;'s values to a
+     specific value, use one of the final seven constructors, each
+     taking a particular value, wrapped as a <type>ModelElement</type>.
+     These constructors use the given domain objects the same way as
+     the preceding constructors but assign <varname>model</varname> to
+     every &array; value.  <varname>model</varname>'s type is
+     <type>ModelElement&lt;T&gt;</type>, rather than
+     <varname>T</varname>, to differentiate it from an &int;, which can
+     also be used to specify a domain object.
+     <type>ModelElement</type> just stores an element of any type
+     <varname>T</varname>, which must match the &array;'s value
+     type&nbsp;<varname>T</varname>.</para>
+ 
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-arrays_declarations-table">
       <title>Declaring &array;s</title>
***************
*** 1206,1212 ****
  	 integers.</entry>
         </row>
        </tfoot>
!       <tbody>
         <row>
  	<entry><statement>Array&lt;&dim;,T,E&gt;()</statement></entry>
  	<entry>creates an empty, uninitialized &array; which must be
--- 1256,1262 ----
  	 integers.</entry>
         </row>
        </tfoot>
!       <tbody valign="top">
         <row>
  	<entry><statement>Array&lt;&dim;,T,E&gt;()</statement></entry>
  	<entry>creates an empty, uninitialized &array; which must be
***************
*** 1310,1368 ****
       </tgroup>
      </table>
  
-     <para>&array; constructors are listed in <xref
-     linkend="arrays-arrays_declarations-table"></xref>.  An &array;s'
-     three template parameters for dimensionality, value type, and
-     engine type are abbreviated <varname>D</varname>,
-     <varname>T</varname>, and <varname>E</varname>.  Template
-     parameters for domain types are named <varname>DT1</varname>,
-     &hellip;, <varname>DT7</varname>.  The first constructor, with no
-     domain arguments, creates an empty, uninitialized &array; for
-     which a domain must be specified before it is used.  Specify the
-     array's domain using its <methodname>initialize</methodname> function.
-     The next seven constructors combine their domain arguments to
-     compute the resulting &array;'s domain.  These are combined in the
-     same way that multidimensional &interval;s are constructed.  (See
-     <xref
-     linkend="arrays-domains-declarations-intervals-multi_d_table"></xref>
-     and the following text.)  The domain objects, having types
-     <type>&domaintemplate;1</type>, &hellip;,
-     <type>&domaintemplate;7</type>, can have any type that can be
-     converted into an integer, into a single-dimensional &domain;
-     object that can be converted into a single-dimensional &interval;,
-     or to a multidimensional &domain; object that itself can be
-     converted into an &interval;.  The total dimensionality of all the
-     arguments' types should
-     <emphasis>equal</emphasis>&nbsp;<varname>&dim;</varname>, unlike
-     &interval; construction which permits total dimensionality less
-     than or equal to&nbsp;<varname>&dim;</varname>.  One-dimensional
-     &domain; objects that can be converted into one-dimensional
-     &interval;s include &locone;s, &intervalone;s, and &rangeone;s
-     with unit strides.  To initialize all of an &array; values to a
-     specific value, use one of the final seven constructors, each
-     taking a particular value, wrapped as a <type>ModelElement</type>.
-     These constructors use the given domain objects the same way as
-     the preceding constructors but assign <varname>model</varname> to
-     every &array; value.  <varname>model</varname>'s type
-     <type>ModelElement&lt;T&gt;</type> rather than
-     <varname>T</varname> to differentiate it from an &int;, which can
-     also be used to specify a domain object.
-     <type>ModelElement</type> just stores an element of any type
-     <varname>T</varname>, which must match the &array;'s value
-     type.</para>
- 
      <para>We illustrate creating &array;s.  To create a
      three-dimensional &array;&nbsp;<varname>a</varname> explicitly
      storing &double; floating-point values, use
  <programlisting>
  Interval&lt;1&gt; D(6);
  Interval&lt;3&gt; I3(D,D,D);
! Array&lt;3,double,Brick&gt; a(I3);.
  </programlisting>  The template parameters specify its dimensionality,
      the type of its values, and a &brick; &engine; type, which
      explicitly stores values.  Its domain, which must have three
      dimensions, is specified by an <type>Interval&lt;3&gt;</type>
!     object which consists of a [0,5] intervals for all its three
      dimensions.  Since &double; and &brick; are usually the default
      template parameters, they can be omitted so these declarations are
      equivalent:
--- 1360,1377 ----
       </tgroup>
      </table>
  
      <para>We illustrate creating &array;s.  To create a
      three-dimensional &array;&nbsp;<varname>a</varname> explicitly
      storing &double; floating-point values, use
  <programlisting>
  Interval&lt;1&gt; D(6);
  Interval&lt;3&gt; I3(D,D,D);
! Array&lt;3,double,Brick&gt; a(I3);
  </programlisting>  The template parameters specify its dimensionality,
      the type of its values, and a &brick; &engine; type, which
      explicitly stores values.  Its domain, which must have three
      dimensions, is specified by an <type>Interval&lt;3&gt;</type>
!     object which consists of [0,5] intervals for all its three
      dimensions.  Since &double; and &brick; are usually the default
      template parameters, they can be omitted so these declarations are
      equivalent:
*************** Array&lt;3&gt; a_duplicate2(I3);.
*** 1372,1383 ****
  </programlisting>  To create a similar &array; with a domain of
  [0:1:1, 0:2:1, 0:0:1], use
  <programlisting>
! Array&lt;3&gt; b(2,3,1);.
! </programlisting> Specifying an integer&nbsp;<varname>i</varname>
      indicates a one-dimensional zero-based &interval; [0:i-1:1].  To
!     store &bool;s, specify &bool; as the second template argument:
  <programlisting>
! Array&lt;2,bool&gt; c(2,3);.
  </programlisting>  To specify a default &array; value of &true;, use
      <statement>ModelElement&lt;bool&gt;(true)</statement>:
  <programlisting>
--- 1381,1392 ----
  </programlisting>  To create a similar &array; with a domain of
  [0:1:1, 0:2:1, 0:0:1], use
  <programlisting>
! Array&lt;3&gt; b(2,3,1);
! </programlisting> since specifying an integer&nbsp;<varname>i</varname>
      indicates a one-dimensional zero-based &interval; [0:i-1:1].  To
!     store booleans, specify &bool; as the second template argument:
  <programlisting>
! Array&lt;2,bool&gt; c(2,3);
  </programlisting>  To specify a default &array; value of &true;, use
      <statement>ModelElement&lt;bool&gt;(true)</statement>:
  <programlisting>
*************** Array&lt;2,bool&gt; c(2,3, ModelElement&
*** 1385,1395 ****
  </programlisting>  To create a one-dimensional &array; containing
      seven &double;s all equaling &pi;, use
  <programlisting>
! Array&lt;1,double,CompressibleBrick&gt; d(7, ModelElement&lt;double&gt;(4.0*atan(1.0)));.
  </programlisting>  We use a &compressiblebrick; &engine;, rather than
!     a &brick; &engine;, so all seven values will be stored once rather
!     than seven times when they are all the same.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-arrays_declarations-initialize_table">
       <title>Initializing &array;s' Domains</title>
--- 1394,1432 ----
  </programlisting>  To create a one-dimensional &array; containing
      seven &double;s all equaling &pi;, use
  <programlisting>
! const double pi = 4.0*atan(1.0);
! Array&lt;1,double,CompressibleBrick&gt; d(7, ModelElement&lt;double&gt;(pi));.
  </programlisting>  We use a &compressiblebrick; &engine;, rather than
!     a &brick; &engine;, so all seven values will be stored in one
!     location rather than in seven separate locations when they are all the
!     same.</para>
  
+     <para>An uninitialized &array;, created using its parameter-less
+     constructor, must have a specified domain before it can be used.
+     For example, one must use the parameter-less &array; constructor
+     when creating an array of &array;s using
+     <keywordname>new</keywordname> so their domains must be specified.
+     (It would probably be better to create an &array; of &array;s
+     since memory allocation and deallocation would automatically be
+     handled.)  &array;'s <methodname>initialize</methodname> functions
+     accept the same set of domain object specifications and model
+     elements that the &array; constructors do, creating the specified
+     domain.  See <xref
+     linkend="arrays-arrays_declarations-initialize_table"></xref>.
+     For example, both <varname>a</varname> and <varname>b</varname>
+     are two-dimensional &array;s of &float;s with a [2:7:1,-2:4:1]
+     domains:
+ <programlisting>
+ // Create an Array and its domain.
+ Array<2,float,Brick> a(Interval<1>(2,7), Interval<1>(-2,4));
+ 
+ // Create an Array without a domain and then specify its domain.
+ Array<2,float,Brick> b();
+ b.initialize(Interval<1>(2,7), Interval<1>(-2,4));.
+ </programlisting>  Invoking <methodname>initialize</methodname> on an
+     &array; with an existing domain yields unspecified behavior.  All
+     &array; values may be lost and memory may be leaked.</para>
+ 
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-arrays_declarations-initialize_table">
       <title>Initializing &array;s' Domains</title>
*************** Array&lt;1,double,CompressibleBrick&gt; 
*** 1413,1419 ****
  	integers.</entry>
         </row>
        </tfoot>
!       <tbody>
         <!-- Omit Indirection Array initialize because it does not exist! -->
         <!-- Omit the two Array&lt;D1,T1,E1&gt; functions, which should not be used by users. -->
         <row>
--- 1450,1456 ----
  	integers.</entry>
         </row>
        </tfoot>
!       <tbody valign="top">
         <!-- Omit Indirection Array initialize because it does not exist! -->
         <!-- Omit the two Array&lt;D1,T1,E1&gt; functions, which should not be used by users. -->
         <row>
*************** object or integer.</entry>
*** 1455,1480 ****
         <row>
  	<entry><statement>initialize(const DT1&amp; t1,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; object and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
  	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
  	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
  	<entry><statement>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
--- 1492,1520 ----
         <row>
  	<entry><statement>initialize(const DT1&amp; t1,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain;
! 	object or integer and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
  	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain;
! 	objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
  	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain;
! 	objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
  	<entry><statement>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
*************** object or integer.</entry>
*** 1482,1488 ****
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
--- 1522,1528 ----
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
*************** object or integer.</entry>
*** 1490,1496 ****
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
--- 1530,1536 ----
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
*************** object or integer.</entry>
*** 1498,1534 ****
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; objects and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
        </tbody>
       </tgroup>
      </table>
- 
-     <para>An uninitialized &array;, created using the parameter-less
-     constructor, must have a specified domain before it can be used.
-     For example, one must use the parameter-less &array; constructor
-     when creating an array of &array;s using
-     <keywordname>new</keywordname> (although it would probably be
-     better to create an &array; of &array;s since memory allocation
-     and deallocation would automatically be handled) so their domains
-     must be specified.  &array;'s <methodname>initialize</methodname>
-     functions accept the same set of domain object specifications and
-     model elements that the &array; constructors do, creating the
-     specified domain.  See <xref
-     linkend="arrays-arrays_declarations-initialize_table"></xref>.
-     For example, both <varname>a</varname> and <varname>b</varname>
-     are two-dimensional &array;s of &float;s with a [2:7:1,-2:4:1]
-     domains:
- <programlisting>
- // Create an Array and its domain.
- Array<2,float,Brick> a(Interval<1>(2,7), Interval<1>(-2,4));
- // Create an Array without a domain and then specify its domain.
- Array<2,float,Brick> b();
- b.initialize(Interval<1>(2,7), Interval<1>(-2,4));.
- </programlisting>  Invoking <methodname>initialize</methodname> on an
-     &array; with an existing domain is unspecified.  All &array;
-     values may be lost and memory may be leaked.</para>
     </section>
  
  
--- 1538,1549 ----
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
  	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
! 	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </section>
  
  
*************** std::cout &openopen; a(2,-2) &openopen; 
*** 1571,1586 ****
  std::cout &openopen; a.read(2,-2) &openopen; std::endl;
  </programlisting> Using <methodname>read</methodname> sometimes
      permits the optimizer to produce faster executing code.</para>
- 
-     <example id="arrays-arrays_use-copy_example">
-      <title>Copying &array;s</title>
-      &array-copy;
-     </example>
  
!     <para>Copying &array;s requires little execution time because they
!     have reference semantics.  That is, a copy of an &array; and the
!     &array; itself share the same underlying data.  Changing a value
!     in one changes it in the other.  <xref
      linkend="arrays-arrays_use-copy_example"></xref> illustrates this
      behavior.  Initially, all values in the array <varname>a</varname>
      are&nbsp;4.  The <varname>b</varname> array is initialized using
--- 1586,1598 ----
  std::cout &openopen; a.read(2,-2) &openopen; std::endl;
  </programlisting> Using <methodname>read</methodname> sometimes
      permits the optimizer to produce faster executing code.</para>
  
!     <para>Copying &array;s requires little execution time because
!     &array;s have <glossterm
!     linkend="glossary-reference_semantics"><firstterm>reference
!     semantics</firstterm></glossterm>.  That is, a copy of an &array;
!     and the &array; itself share the same underlying data.  Changing a
!     value in one changes it in the other.  <xref
      linkend="arrays-arrays_use-copy_example"></xref> illustrates this
      behavior.  Initially, all values in the array <varname>a</varname>
      are&nbsp;4.  The <varname>b</varname> array is initialized using
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1589,1598 ****
      changes the latter's value.  Function arguments are also
      initialized so changing their underlying values also changes the
      calling function's values.  For example, the
!     <function>changeValue</function> function changes the value with
!     index&nbsp;(0,0) of both its function argument
      and&nbsp;<varname>a</varname>.</para>
  
      <para>The separation between a higher-level &array; and its
      lower-level &engine; storage permits fast copying.  An &array;'s
      only data member is its engine, which itself has reference
--- 1601,1615 ----
      changes the latter's value.  Function arguments are also
      initialized so changing their underlying values also changes the
      calling function's values.  For example, the
!     <function>changeValue</function> function changes the value at
!     index&nbsp;(0,0) for both its function argument
      and&nbsp;<varname>a</varname>.</para>
  
+     <example id="arrays-arrays_use-copy_example">
+      <title>Copying &array;s</title>
+      &array-copy;
+     </example>
+ 
      <para>The separation between a higher-level &array; and its
      lower-level &engine; storage permits fast copying.  An &array;'s
      only data member is its engine, which itself has reference
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1608,1613 ****
--- 1625,1645 ----
      <varname>a</varname>'s values do not change <varname>b</varname>'s
      values or vice versa.</para>
  
+     <para>The &array; class has internal type definitions and
+     constants useful for both compile-time and run-time computations.
+     See <xref linkend="arrays-arrays_use-compile_time_table"></xref>.
+     These may be accessed using the &array;'s type and the scope
+     resolution operator (<operator>::</operator>).  The table begins
+     with a list of internal type definitions, e.g.,
+     <statement>Array&lt;&dim;,T,E&gt;::This_t</statement>.  A
+     <glossterm linkend="glossary-layout">layout</glossterm> maps a
+     domain index to a particular processor and memory used to compute
+     the associated value.<!-- FIXME: Add a reference to the
+     corresponding chapter. --> The two internal enumerations
+     <fieldsynopsis><varname>dimensions</varname></fieldsynopsis> and
+     <fieldsynopsis><varname>rank</varname></fieldsynopsis> both record
+     the &array;'s dimension.</para>
+ 
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-arrays_use-compile_time_table">
       <title>&array; Internal Type Definitions and Compile-Time Constants</title>
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1619,1625 ****
  	<entry>meaning</entry>
         </row>
        </thead>
!       <tbody>
         <row>
  	<entry><type>This_t</type></entry>
  	<entry>the &array;'s type <type>Array&lt;&dim;,T,E&gt;</type>.</entry>
--- 1651,1657 ----
  	<entry>meaning</entry>
         </row>
        </thead>
!       <tbody valign="top">
         <row>
  	<entry><type>This_t</type></entry>
  	<entry>the &array;'s type <type>Array&lt;&dim;,T,E&gt;</type>.</entry>
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1650,1687 ****
  	<entry>the type of the &array;'s layout.</entry>
         </row>
         <row>
! 	<entry><fieldsynopsis>
! 	  <modifier>const</modifier>
! 	  <type>int</type>
! 	  <varname>dimensions</varname></fieldsynopsis></entry>
  	<entry>the number&nbsp;&dim; of dimensions of the &array;.</entry>
         </row>
         <row>
! 	<entry><fieldsynopsis>
! 	  <modifier>const</modifier>
! 	  <type>int</type>
! 	  <varname>rank</varname></fieldsynopsis></entry>
  	<entry>synonym for <varname>dimensions</varname>.</entry>
         </row>
        </tbody>
       </tgroup>
      </table>
  
!     <para>The &array; class has internal type definitions and
!     constants useful for both compile-time and run-time computations.
!     See <xref linkend="arrays-arrays_use-compile_time_table"></xref>.
!     These may be accessed using the &array;'s type and the scope
!     resolution operator (<operator>::</operator>).  The table begins
!     with a list of internal type definitions, e.g.,
!     <statement>Array&lt;&dim;,T,E&gt;::Domain_t</statement>.  Member
!     functions use some of these types.  A <glossterm
!     linkend="glossary-layout">layout</glossterm> maps a domain index
!     to a particular processor and memory used to compute the
!     associated value.<!-- FIXME: Add a reference to the corresponding
!     chapter. --> The two internal enumerations
!     <fieldsynopsis><varname>dimensions</varname></fieldsynopsis> and
!     <fieldsynopsis><varname>rank</varname></fieldsynopsis> both record
!     the &array;'s dimension.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-arrays_use-accessor_table">
--- 1682,1723 ----
  	<entry>the type of the &array;'s layout.</entry>
         </row>
         <row>
! 	<entry><statement>const int dimensions</statement></entry>
  	<entry>the number&nbsp;&dim; of dimensions of the &array;.</entry>
         </row>
         <row>
! 	<entry><statement>const int rank</statement></entry>
  	<entry>synonym for <varname>dimensions</varname>.</entry>
         </row>
        </tbody>
       </tgroup>
      </table>
  
!     <para>The &array; class has several member functions easing access
!     to its domain and engine.  The first ten functions listed in <xref
!     linkend="arrays-arrays_use-accessor_table"></xref> ease access to
!     &array; domains.  The first three functions are synonyms all
!     returning the &array;'s domain, which has type
!     <type>Array&lt;&dim;,T,E&gt;::Domain_t</type> (abbreviated
!     <type>Domain_t</type> in the table).  The next seven functions
!     query the domain.  <methodname>first</methodname>,
!     <methodname>last</methodname>, and <methodname>length</methodname>
!     return the first index, last index, and number of indices for the
!     specified dimension.  The domain's dimensions are numbered 0, 1,
!     &hellip;,
!     <statement>Array&lt;&dim;,T,E&gt;::dimensions</statement>-1.  If
!     these values are needed for all dimensions, use
!     <methodname>firsts</methodname>, <methodname>lasts</methodname>,
!     and <methodname>lengths</methodname>.  The returned
!     <type>Loc&lt;&dim;&gt;</type>s have &dim; entries, one for each
!     dimension.  <methodname>size</methodname> returns the total number
!     of indices in the entire domain.  This is the product of all the
!     dimensions' <methodname>length</methodname>s.  The
!     <methodname>layout</methodname> member function returns the
!     &array;'s layout, which specifies the mapping of indices to
!     processors and memory.<!-- FIXME: Add a reference to the
!     corresponding chapter. --> The last two functions return the
!     &array;'s engine.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-arrays_use-accessor_table">
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1697,1707 ****
        <tfoot>
         <row>
  	<entry>Internal type definitions, e.g., <type>Domain_t</type>,
! 	are listed without a class type prefix
  	<statement>Array&lt;&dim;,T,E&gt;::</statement>.</entry>
         </row>
        </tfoot>
!       <tbody>
         <row>
  	<entry><statement>Domain_t domain()</statement></entry>
  	<entry>returns the &array;'s domain.</entry>
--- 1733,1743 ----
        <tfoot>
         <row>
  	<entry>Internal type definitions, e.g., <type>Domain_t</type>,
! 	are listed here without the class type prefix
  	<statement>Array&lt;&dim;,T,E&gt;::</statement>.</entry>
         </row>
        </tfoot>
!       <tbody valign="top">
         <row>
  	<entry><statement>Domain_t domain()</statement></entry>
  	<entry>returns the &array;'s domain.</entry>
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1716,1728 ****
         </row>
         <row>
  	<entry><statement>int first(int dim)</statement></entry>
! 	<entry>returns the first (smallest) index value for the
! 	specified dimension.</entry>
         </row>
         <row>
  	<entry><statement>int last(int dim)</statement></entry>
! 	<entry>returns the last (largest) index value for the
! 	specified dimension.</entry>
         </row>
         <row>
  	<entry><statement>int length(int dim)</statement></entry>
--- 1752,1764 ----
         </row>
         <row>
  	<entry><statement>int first(int dim)</statement></entry>
! 	<entry>returns the first index value for the specified
! 	dimension.</entry>
         </row>
         <row>
  	<entry><statement>int last(int dim)</statement></entry>
! 	<entry>returns the last index value for the specified
! 	dimension.</entry>
         </row>
         <row>
  	<entry><statement>int length(int dim)</statement></entry>
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1731,1743 ****
         </row>
         <row>
  	<entry><statement>Loc&lt;Dim&gt; firsts()</statement></entry>
! 	<entry>returns the first (smallest) index values for all the
  	dimensions.</entry>
         </row>
         <row>
  	<entry><statement>Loc&lt;Dim&gt; lasts()</statement></entry>
! 	<entry>returns the last (largest) index values for all the
! 	specified dimensions.</entry>
         </row>
         <row>
  	<entry><statement>Loc&lt;Dim&gt; lengths()</statement></entry>
--- 1767,1779 ----
         </row>
         <row>
  	<entry><statement>Loc&lt;Dim&gt; firsts()</statement></entry>
! 	<entry>returns the first index values for all the
  	dimensions.</entry>
         </row>
         <row>
  	<entry><statement>Loc&lt;Dim&gt; lasts()</statement></entry>
! 	<entry>returns the last index values for all the specified
! 	dimensions.</entry>
         </row>
         <row>
  	<entry><statement>Loc&lt;Dim&gt; lengths()</statement></entry>
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1750,1756 ****
         </row>
         <row>
  	<entry><statement>Layout_t layout()</statement></entry>
! 	<entry>returns the &array;'s domain.</entry>
         </row>
         <row>
  	<entry><statement>Engine_t engine()</statement></entry>
--- 1786,1792 ----
         </row>
         <row>
  	<entry><statement>Layout_t layout()</statement></entry>
! 	<entry>returns the &array;'s layout.</entry>
         </row>
         <row>
  	<entry><statement>Engine_t engine()</statement></entry>
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1764,1806 ****
       </tgroup>
      </table>
  
!     <para>The &array; class has several member functions easing access
!     to its domain and engine.  The first ten functions listed in <xref
!     linkend="arrays-arrays_use-accessor_table"></xref> ease access to
!     &array; domains.  The first three functions are synonyms all
!     returning the &array;'s domain, which has type
!     <type>Array&lt;&dim;,T,E&gt;::Domain_t</type>, abbreviated
!     <type>Domain_t</type> in the table.  The next seven functions
!     query the domain.  <methodname>first</methodname>,
!     <methodname>last</methodname>, and <methodname>length</methodname>
!     return the smallest, largest, and number of indices for the
!     specified dimension.  The domain's dimensions are numbered 0, 1,
!     &hellip;,
!     <statement>Array&lt;&dim;,T,E&gt;::dimensions</statement>-1.  If
!     these values are needed for all dimensions, use
!     <methodname>firsts</methodname>, <methodname>lasts</methodname>,
!     and <methodname>lengths</methodname>.  The returned
!     <type>Loc&lt;&dim;&gt;</type>s have &dim; entries, one for each
!     dimension.  <methodname>size</methodname> returns the total number
!     of indices in the entire domain.  This is the product of all the
!     dimensions' <methodname>length</methodname>s.  The
!     <methodname>layout</methodname> member function returns the
!     &array;'s layout, which specifies the mapping of indices to
!     processors and memory.<!-- FIXME: Add a reference to the
!     corresponding chapter. --> The last two functions return the
!     &array;'s engine.</para>
  
      <example id="arrays-arrays_use-members_example">
       <title>Using &array; Member Functions</title>
       &array-size;
       <calloutlist>
-       <callout arearefs="arrays-arrays_use-members-example-compare_size">
-        <para>The <methodname>size</methodname> is invoked by
-        prepending the &array;'s name followed by a period.  This
-        assertion is unnecessary, but the
-        <function>computeArraySize</function> function further
-        illustrates using member functions.</para>
-       </callout>
        <callout arearefs="arrays-arrays_use-members-example-template_parameters">
         <para>These template parameters, used in the &array;
         parameter's type, permit the function to work with any
--- 1800,1830 ----
       </tgroup>
      </table>
  
!     <para>We illustrate using &array; member functions in <xref
!     linkend="arrays-arrays_use-members_example"></xref>.  The program
!     computes the total number of &array;'s indices, comparing the
!     result with invoking its <methodname>size</methodname> method.
!     Since the &array;'s name is <varname>a</varname>,
!     <statement>a.size()</statement> returns its size.  The
!     <function>computeArraySize</function> function also computes the
!     &array;'s size.  This templated function uses its three template
!     parameters to accept any &array;, regardless of its dimension,
!     value type, or &engine; tag.  It begins by obtaining the range of
!     indices for all dimensions and their lengths.  Only the latter is
!     necessary for the computation, but using the former further
!     illustrates using member functions.  The domain's size is the
!     product of the length of each dimension.  Since the lengths are
!     stored in the <type>Loc&lt;&dim&gt;</type>
!     <varname>lens</varname>, <statement>lens[d]</statement> is a
!     <type>Loc&lt;1&gt;</type>, for which its
!     <methodname>first</methodname> member function extracts the
!     length.  The <methodname>length</methodname> &array; member
!     function is used in the <function>PAssert</function>.</para>
  
      <example id="arrays-arrays_use-members_example">
       <title>Using &array; Member Functions</title>
       &array-size;
       <calloutlist>
        <callout arearefs="arrays-arrays_use-members-example-template_parameters">
         <para>These template parameters, used in the &array;
         parameter's type, permit the function to work with any
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1815,1849 ****
         <para><statement>lens[d]</statement> returns a
         <type>Loc&lt;1&gt;</type> for
         dimension&nbsp;<varname>d</varname>'s length.  Invoking
!        <type>Loc&lt;1&gt;</type> <methodname>first</methodname>method
         yields its value.</para>
        </callout>
        <callout arearefs="arrays-arrays_use-members-example-check_length">
         <para>This comparison is unnecessary but further illustrates
         using member functions.</para>
        </callout>
       </calloutlist>
      </example>
- 
-     <para>We illustrate using &array; member functions in <xref
-     linkend="arrays-arrays_use-members_example"></xref>.  The program
-     computes the total number of &array;'s indices, comparing the
-     result with invoking its <methodname>size</methodname> method.
-     Since the &array;'s name is <varname>a</varname>,
-     <statement>a.size()</statement> returns its size.
-     <function>computeArraySize</function> also computes the &array;'s
-     size.  This templated function uses its three template parameters
-     to accept any &array;, regardless of its dimension, value type, or
-     &engine; tag.  It begins by obtaining the range of indices for all
-     dimensions and their lengths.  Only the latter is necessary for
-     the computation, but the former further illustrate using member
-     functions.  The domain's size is the product of the length of each
-     dimension.  Since the lengths are stored in the
-     <type>Loc&lt;&dim&gt;</type> <varname>lens</varname>,
-     <statement>lens[d]</statement> is a <type>Loc&lt;1&gt;</type>, for
-     which its <methodname>first</methodname> extracts the length.  The
-     <methodname>length</methodname> &array; member function is used in
-     the <function>PAssert</function>.</para>
     </section>
  
  
--- 1839,1860 ----
         <para><statement>lens[d]</statement> returns a
         <type>Loc&lt;1&gt;</type> for
         dimension&nbsp;<varname>d</varname>'s length.  Invoking
!        <type>Loc&lt;1&gt;</type> <methodname>first</methodname> method
         yields its value.</para>
        </callout>
        <callout arearefs="arrays-arrays_use-members-example-check_length">
         <para>This comparison is unnecessary but further illustrates
         using member functions.</para>
        </callout>
+       <callout arearefs="arrays-arrays_use-members-example-compare_size">
+        <para>The <methodname>size</methodname> is invoked by
+        prepending the &array;'s name followed by a period.  This
+        assertion is unnecessary, but the
+        <function>computeArraySize</function> function further
+        illustrates using member functions.</para>
+       </callout>
       </calloutlist>
      </example>
     </section>
  
  
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1851,1942 ****
      <title>&dynamicarray;s</title>
  
      <para>&array;s have fixed domains so the set of valid indices
!     remains fixed after declaration.  The &dynamicarray; class
!     supports one-dimensional domains that can be resized even while
!     the array is used.</para>
  
      <para>&dynamicarray;'s interface extends the one-dimensional
      interface of an &array; by adding member functions to change the
      domain's size.  It is declared in <filename
      class="libraryfile">Pooma/DynamicArrays.h</filename>.  A
      &dynamicarray; has two, not three, template parameters, omitting
!     the array's dimensionality.  The first
      parameter&nbsp;<type>T</type> specifies the type of stored values.
!     Its default value is usually &double;, but it may be changed when
!     the &poomatoolkit; is configured.  The second parameter specifies
!     an &engine; via a tag.  The engine must support a domain with
!     dynamic resizing.  For example, the &dynamic; &engine; is
!     analogous to a one-dimensional &brick; &engine; supporting a
!     dynamically-resizable domain.  It is also usually the default
!     value for this tag.  For example, <statement>DynamicArray&lt;&gt;
!     d0(1);</statement>, <statement>DynamicArray&lt;double&gt;
!     d1(1);</statement>, and <statement>DynamicArray&lt;double,
!     Dynamic&gt; d2(1);</statement> all declare the same
!     &dynamicarray;s explicitly storing one &double; value.  A
!     &dynamicarray; automatically allocates its initial memory and
!     deallocates its final memory, just as an &array; does.</para>
  
-     <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	   orient="port" pgwide="0" id="arrays-dynamic_arrays-change_size">
-      <title>Changing a &dynamicarray;'s Domain</title>
-      
-      <tgroup cols="2" align="left">
-       <thead>
-        <row>
- 	<entry>&dynamicarray; member function</entry>
- 	<entry>description</entry>
-        </row>
-       </thead>
-       <tfoot>
-        <row>
- 	<entry>This table omits member functions designed for
- 	distributed computation.</entry>
-        </row>
-       </tfoot>
-       <tbody>
-        <row>
- 	<entry><statement>void create(int num)</statement></entry>
- 	<entry>extend the current domain by the requested number of
-         elements.</entry>
-        </row>
-        <row>
- 	<entry><statement>void destroy(const Dom&amp; killList)</statement></entry>
- 	<entry>remove the elements specified by the indices in the
- 	given &domain; argument.  <quote>Backfill</quote> moves
- 	elements from the end of the domain to replace the deleted
- 	elements.</entry>
-        </row>
-        <row>
- 	<entry><statement>void destroy(Iter killBegin, Iter killEnd)</statement></entry>
- 	<entry>remove the elements specified by the indices in the
- 	container range [begin,end) specified by the random-access
- 	iterators.  <quote>Backfill</quote> moves elements from the
- 	end of the domain to replace the deleted elements.</entry>
-        </row>
-        <row>
- 	<entry><statement>void destroy(const Dom&amp; killList, const
- 	DeleteMethod&amp; method)</statement></entry>
- 
- 	<entry>remove the elements specified by the indices in the
- 	given &domain; argument.  Deleted elements can be replaced by
- 	<type>BackFill</type>'ing, i.e., moving data from the domain's
- 	end to fill removed elements, or by <type>ShiftUp</type>'ing,
- 	i.e., compacting all data but maintaining relative ordering.</entry>
-        </row>
-        <row>
- 	<entry><statement>void destroy(Iter killBegin, Iter killEnd,
- 	const DeleteMethod&amp; method)</statement></entry>
-         <entry>remove the elements specified by the indices in the
- 	container range [begin,end) specified by the random-access
- 	iterators.  Deleted elements can be replaced by
- 	<type>BackFill</type>'ing, i.e., moving data from the domain's
- 	end to fill removed elements, or by <type>ShiftUp</type>'ing,
- 	i.e., compacting all data but maintaining relative ordering.</entry>
-        </row>
-       </tbody>
-      </tgroup>
-     </table>
- 
      <para>The <methodname>create</methodname> and
      <methodname>destroy</methodname> member functions permit changing
      a &dynamicarray;'s domain.  <xref
--- 1862,1895 ----
      <title>&dynamicarray;s</title>
  
      <para>&array;s have fixed domains so the set of valid indices
!     remains fixed after creation.  The <glossterm
!     linkend="glossary-dynamicarray">&dynamicarray;
!     class</glossterm><!-- FIXME: Add firstterm here. --> supports
!     one-dimensional domains that can be resized even while the array
!     is used.</para>
  
      <para>&dynamicarray;'s interface extends the one-dimensional
      interface of an &array; by adding member functions to change the
      domain's size.  It is declared in <filename
      class="libraryfile">Pooma/DynamicArrays.h</filename>.  A
      &dynamicarray; has two, not three, template parameters, omitting
!     the array's dimensionality which must be one.  The first
      parameter&nbsp;<type>T</type> specifies the type of stored values.
!     Its default value is usually &double;, but this may be changed
!     when the &poomatoolkit; is configured.  The second parameter
!     specifies an &engine; via an &engine; tag.  The engine must
!     support a domain with dynamic resizing.  For example, the
!     &dynamic; &engine; is analogous to a one-dimensional &brick;
!     &engine; supporting a dynamically-resizable domain.  It is also
!     usually the default value for this tag.  For example,
!     <statement>DynamicArray&lt;&gt; d0(1);</statement>,
!     <statement>DynamicArray&lt;double&gt; d1(1);</statement>, and
!     <statement>DynamicArray&lt;double, Dynamic&gt; d2(1);</statement>
!     all declare the same &dynamicarray;s explicitly storing one
!     &double; value.  A &dynamicarray; automatically allocates its
!     initial memory and deallocates its final memory, just as an
!     &array; does.</para>
  
      <para>The <methodname>create</methodname> and
      <methodname>destroy</methodname> member functions permit changing
      a &dynamicarray;'s domain.  <xref
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1948,1954 ****
      for&nbsp;<type>T</type>.  Existing values are copied.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	   orient="port" pgwide="0" id="arrays-dynamic_arrays-table">
       <title>Changing a &dynamicarray;'s Domain</title>
       
       <tgroup cols="2" align="left">
--- 1901,1907 ----
      for&nbsp;<type>T</type>.  Existing values are copied.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	   orient="port" pgwide="0" id="arrays-dynamic_arrays-change_size">
       <title>Changing a &dynamicarray;'s Domain</title>
       
       <tgroup cols="2" align="left">
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1964,1970 ****
  	distributed computation.</entry>
         </row>
        </tfoot>
!       <tbody>
         <row>
  	<entry><statement>void create(int num)</statement></entry>
  	<entry>extend the current domain by the requested number of
--- 1917,1923 ----
  	distributed computation.</entry>
         </row>
        </tfoot>
!       <tbody valign="top">
         <row>
  	<entry><statement>void create(int num)</statement></entry>
  	<entry>extend the current domain by the requested number of
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1972,2019 ****
         </row>
         <row>
  	<entry><statement>void destroy(const Dom&amp; killList)</statement></entry>
! 	<entry>remove the elements specified by the indices in the
! 	given &domain; argument.  <quote>Backfill</quote> moves
! 	elements from the end of the domain to replace the deleted
! 	elements.</entry>
         </row>
         <row>
  	<entry><statement>void destroy(Iter killBegin, Iter killEnd)</statement></entry>
! 	<entry>remove the elements specified by the indices in the
  	container range [begin,end) specified by the random-access
! 	iterators.  <quote>Backfill</quote> moves elements from the
! 	end of the domain to replace the deleted elements.</entry>
         </row>
         <row>
  	<entry><statement>void destroy(const Dom&amp; killList, const
  	DeleteMethod&amp; method)</statement></entry>
  
! 	<entry>remove the elements specified by the indices in the
! 	given &domain; argument.  Deleted elements can be replaced by
  	<type>BackFill</type>'ing, i.e., moving data from the domain's
! 	end to fill removed elements, or by <type>ShiftUp</type>'ing,
! 	i.e., compacting all data but maintaining relative ordering.</entry>
         </row>
         <row>
  	<entry><statement>void destroy(Iter killBegin, Iter killEnd,
  	const DeleteMethod&amp; method)</statement></entry>
!         <entry>remove the elements specified by the indices in the
  	container range [begin,end) specified by the random-access
! 	iterators.  Deleted elements can be replaced by
  	<type>BackFill</type>'ing, i.e., moving data from the domain's
! 	end to fill removed elements, or by <type>ShiftUp</type>'ing,
! 	i.e., compacting all data but maintaining relative ordering.</entry>
         </row>
        </tbody>
       </tgroup>
      </table>
  
!     <para>The <methodname>destroy</methodname> deletes specified
!     indices.  The indices may be specified using either a &domain;
!     object (<type>Interval&lt;1&gt;</type>,
      <type>Range&lt;1&gt;</type>, or <type>IndirectionList</type>) or
!     in a container specified using random-access iterators.  For
!     example, every other element from a ten-element
      array&nbsp;<varname>d</varname> might be removed using
      <statement>Range&lt;1&gt;(0,9,2)</statement>.  Alternatively,
  <programlisting>
--- 1925,1975 ----
         </row>
         <row>
  	<entry><statement>void destroy(const Dom&amp; killList)</statement></entry>
! 	<entry>remove the values specified by the indices in the given
! 	&domain; argument.  The <quote>Backfill</quote> method moves
! 	values from the end of the domain to replace the deleted
! 	values.</entry>
         </row>
         <row>
  	<entry><statement>void destroy(Iter killBegin, Iter killEnd)</statement></entry>
! 	<entry>remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
! 	iterators.  The <quote>Backfill</quote> method moves values
! 	from the end of the domain to replace the deleted
! 	values.</entry>
         </row>
         <row>
  	<entry><statement>void destroy(const Dom&amp; killList, const
  	DeleteMethod&amp; method)</statement></entry>
  
! 	<entry>remove the values specified by the indices in the
! 	given &domain; argument.  Deleted values can be replaced by
  	<type>BackFill</type>'ing, i.e., moving data from the domain's
! 	end to fill removed values, or by <type>ShiftUp</type>'ing,
! 	i.e., compacting all data but maintaining the relative
! 	ordering.</entry>
         </row>
         <row>
  	<entry><statement>void destroy(Iter killBegin, Iter killEnd,
  	const DeleteMethod&amp; method)</statement></entry>
!         <entry>remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
! 	iterators.  Deleted values can be replaced by
  	<type>BackFill</type>'ing, i.e., moving data from the domain's
! 	end to fill removed values, or by <type>ShiftUp</type>'ing,
! 	i.e., compacting all data but maintaining the relative
! 	ordering.</entry>
         </row>
        </tbody>
       </tgroup>
      </table>
  
!     <para>The <methodname>destroy</methodname> member function deletes
!     the specified indices.  The indices may be specified using either
!     a &domain; object (<type>Interval&lt;1&gt;</type>,
      <type>Range&lt;1&gt;</type>, or <type>IndirectionList</type>) or
!     by random-access iterators pointing into a container.  For
!     example, every other value from a ten-value
      array&nbsp;<varname>d</varname> might be removed using
      <statement>Range&lt;1&gt;(0,9,2)</statement>.  Alternatively,
  <programlisting>
*************** d.destroy(killList, killList+5);
*** 2023,2048 ****
      removed, other indices are moved into their positions.  Using the
      <type>BackFill</type> method moves the last index and its
      associated value into deleted index's position.  Thus, the total
!     number of indices is decreased by one, but the indices can be
      reordered.  Using the <type>ShiftUp</type> method ensures the
!     indices' orders are maintained by <quote>shifting</quote> all
!     elements left (or up) so all <quote>gaps</quote> between indices
      disappear.  For example, consider removing the first index from a
      domain.
      <informaltable frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-dynamic_arrays-destroy_example">
       <tgroup cols="2" align="left">
!       <tbody>
         <row>
  	<entry>original indices:</entry>
  	<entry>0 1 2 3</entry>
         </row>
         <row>
! 	<entry><methodname>destroy</methodname> using <type>BackFill</type></entry>
  	<entry>3 1 2</entry>
         </row>
         <row>
! 	<entry><methodname>destroy</methodname> using <type>ShiftUp</type></entry>
  	<entry>1 2 3</entry>
         </row>
        </tbody>
--- 1979,2004 ----
      removed, other indices are moved into their positions.  Using the
      <type>BackFill</type> method moves the last index and its
      associated value into deleted index's position.  Thus, the total
!     number of indices is decreased by one, but the indices are
      reordered.  Using the <type>ShiftUp</type> method ensures the
!     order of the indices is preserved by <quote>shifting</quote> all
!     values left (or up) so all <quote>gaps</quote> between indices
      disappear.  For example, consider removing the first index from a
      domain.
      <informaltable frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-dynamic_arrays-destroy_example">
       <tgroup cols="2" align="left">
!       <tbody valign="top">
         <row>
  	<entry>original indices:</entry>
  	<entry>0 1 2 3</entry>
         </row>
         <row>
! 	<entry><methodname>destroy</methodname> using <type>BackFill</type>:</entry>
  	<entry>3 1 2</entry>
         </row>
         <row>
! 	<entry><methodname>destroy</methodname> using <type>ShiftUp</type>:</entry>
  	<entry>1 2 3</entry>
         </row>
        </tbody>
*************** d.destroy(killList, killList+5);
*** 2054,2101 ****
      that <type>BackFill</type> moves exactly as many indices as are
      deleted, while <type>ShiftUp</type> can shift all indices in a
      domain.  Thus, <type>BackFill</type> is the default method.  When
!     multiple indices are deleted, they are deleted from the largest to
!     the smallest.  When using the <type>BackFill</type> method, some
!     indices may be moved repeatedly.  For example, consider removing
!     indices 0 and 2 from original indices of 0 1 2 3.  Removing 2
!     yields 0 1 3.  Removing 0 yields 3 1.  Using an object with the
!     desired type to indicate which fill method is desired, i.e.,
!     <statement>BackFill()</statement> or
      <statement>ShiftUp()</statement>.</para>
  
-     <example id="arrays-dynamic_arrays-example">
-      <title>Example Using &dynamicarray;s</title>
- 
-      &dynamicarray-example;
-      <calloutlist>
-       <callout arearefs="arrays-dynamic_arrays-example-header">
-        <para>This header file declares &dynamicarray;s.</para>
-       </callout>
-       <callout arearefs="arrays-dynamic_arrays-example-identical_declarations">
-        <para>These three declarations yield equivalent
-        &dynamicarray;s, storing one &double; value.</para>
-       </callout>
-       <callout arearefs="arrays-dynamic_arrays-example-extension">
-        <para>This <methodname>create</methodname> member function adds
-        five indices to the end of the domain.</para>
-       </callout>
-       <callout arearefs="arrays-dynamic_arrays-example-access">
-        <para>&dynamicarray; values are accessed the same way as
-        &array; values.</para>
-       </callout>
-       <callout arearefs="arrays-dynamic_arrays-example-destroy_range">
-        <para>The &range; object specifies that every other index
-        should be removed.  The <statement>BackFill()</statement>
-        object is unnecessary since it is the default replacement
-        method.</para>
-       </callout>
-       <callout arearefs="arrays-dynamic_arrays-example-destroy_iterators">
-        <para>This <methodname>destroy</methodname> call is equivalent
-        to the previous one but uses iterators.</para>
-       </callout>
-      </calloutlist>
-     </example>
- 
      <para>We illustrate &dynamicarray; resizing in <xref
      linkend="arrays-dynamic_arrays-example"></xref>.  &dynamicarray;s
      are declared in <filename
--- 2010,2025 ----
      that <type>BackFill</type> moves exactly as many indices as are
      deleted, while <type>ShiftUp</type> can shift all indices in a
      domain.  Thus, <type>BackFill</type> is the default method.  When
!     multiple indices are deleted, they are deleted from the last
!     (largest) to the first (smallest).  When using the
!     <type>BackFill</type> method, some indices may be moved
!     repeatedly.  For example, consider removing indices 0 and 2 from
!     original indices of 0 1 2 3.  Removing 2 yields 0 1 3 because 3 is
!     moved into 2's position.  Removing 0 yields 3 1 because 3 is again
!     moved.  Use an object with the desired type to indicate which fill
!     method is desired, i.e., <statement>BackFill()</statement> or
      <statement>ShiftUp()</statement>.</para>
  
      <para>We illustrate &dynamicarray; resizing in <xref
      linkend="arrays-dynamic_arrays-example"></xref>.  &dynamicarray;s
      are declared in <filename
*************** d.destroy(killList, killList+5);
*** 2104,2110 ****
      require two, not three, template arguments because the array must
      be one-dimensional.  The three arrays, each having one &double;
      value, are equivalent.  (The &poomatoolkit; can be configured to
!     support different default values.)  Invoking
      <varname>d0</varname>'s <methodname>create</methodname> with an
      argument of five increases its domain size from one to six.  The
      additional indices are added to the end of the domain so the value
--- 2028,2034 ----
      require two, not three, template arguments because the array must
      be one-dimensional.  The three arrays, each having one &double;
      value, are equivalent.  (The &poomatoolkit; can be configured to
!     support different default template values.)  Invoking
      <varname>d0</varname>'s <methodname>create</methodname> with an
      argument of five increases its domain size from one to six.  The
      additional indices are added to the end of the domain so the value
*************** d.destroy(killList, killList+5);
*** 2113,2143 ****
      all values equal to their indices.  This illustrates that
      &dynamicarray; values are accessed the same way as &array; values.
      For example, <statement>d0(i)</statement> accesses the
!     <varname>i</varname>th value.  The
!     <methodname>destroy</methodname> removes every other index from
!     the array.  The one-dimensional &range; specifies these indices by
!     specifying the domain's entire interval and a stride of&nbsp;2.
      The <statement>BackFill</statement> function call creates a
      <type>BackFill</type> object indicating the <type>BackFill</type>
      method should be used.  We illustrate the steps of this method:
      <informaltable frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-dynamic_arrays-program_example">
       <tgroup cols="2" align="left">
!       <tbody>
         <row>
  	<entry>original indices:</entry>
  	<entry>0 1 2 3 4 5</entry>
         </row>
         <row>
! 	<entry>delete index 4</entry>
  	<entry>0 1 2 3 5</entry>
         </row>
         <row>
! 	<entry>delete index 2</entry>
  	<entry>0 1 5 3</entry>
         </row>
         <row>
! 	<entry>delete index 0</entry>
  	<entry>3 1 5</entry>
         </row>
        </tbody>
--- 2037,2067 ----
      all values equal to their indices.  This illustrates that
      &dynamicarray; values are accessed the same way as &array; values.
      For example, <statement>d0(i)</statement> accesses the
!     <varname>i</varname><superscript>th</superscript> value.  The
!     <methodname>destroy</methodname> member function removes every
!     other index from the array because the one-dimensional &range;
!     specifies the domain's entire interval with a stride of&nbsp;2.
      The <statement>BackFill</statement> function call creates a
      <type>BackFill</type> object indicating the <type>BackFill</type>
      method should be used.  We illustrate the steps of this method:
      <informaltable frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="arrays-dynamic_arrays-program_example">
       <tgroup cols="2" align="left">
!       <tbody valign="top">
         <row>
  	<entry>original indices:</entry>
  	<entry>0 1 2 3 4 5</entry>
         </row>
         <row>
! 	<entry>delete index 4:</entry>
  	<entry>0 1 2 3 5</entry>
         </row>
         <row>
! 	<entry>delete index 2:</entry>
  	<entry>0 1 5 3</entry>
         </row>
         <row>
! 	<entry>delete index 0:</entry>
  	<entry>3 1 5</entry>
         </row>
        </tbody>
*************** d.destroy(killList, killList+5);
*** 2146,2152 ****
      Since multiple indices are specified, the rightmost one is removed
      first, i.e., index&nbsp;4.  The rightmost index&nbsp;5 is moved
      into 4's position.  When removing index&nbsp;2, the index
!     originally at 5 is moved again into 2's position.  Finally,
      index&nbsp;0 is replaced by index&nbsp;3.  The rest of the program
      repeats the computation, using the random-access iterator version
      of <methodname>destroy</methodname>.  Since this &dynamicarray;'s
--- 2070,2076 ----
      Since multiple indices are specified, the rightmost one is removed
      first, i.e., index&nbsp;4.  The rightmost index&nbsp;5 is moved
      into 4's position.  When removing index&nbsp;2, the index
!     originally at 5 is again moved into 2's position.  Finally,
      index&nbsp;0 is replaced by index&nbsp;3.  The rest of the program
      repeats the computation, using the random-access iterator version
      of <methodname>destroy</methodname>.  Since this &dynamicarray;'s
*************** d.destroy(killList, killList+5);
*** 2158,2166 ****
--- 2082,2125 ----
      method is specified, the default <type>BackFill</type> method is
      used.  All the &dynamicarray;s' unallocated memory is
      deallocated.</para>
+ 
+     <example id="arrays-dynamic_arrays-example">
+      <title>Example Using &dynamicarray;s</title>
+ 
+      &dynamicarray-example;
+      <calloutlist>
+       <callout arearefs="arrays-dynamic_arrays-example-header">
+        <para>This header file declares &dynamicarray;s.</para>
+       </callout>
+       <callout arearefs="arrays-dynamic_arrays-example-identical_declarations">
+        <para>These three declarations yield equivalent
+        &dynamicarray;s, storing one &double; value.</para>
+       </callout>
+       <callout arearefs="arrays-dynamic_arrays-example-extension">
+        <para>This <methodname>create</methodname> member function call
+        adds five indices to the end of the domain.</para>
+       </callout>
+       <callout arearefs="arrays-dynamic_arrays-example-access">
+        <para>&dynamicarray; values are accessed the same way as
+        &array; values.</para>
+       </callout>
+       <callout arearefs="arrays-dynamic_arrays-example-destroy_range">
+        <para>The &range; object specifies that every other index
+        should be removed.  The <statement>BackFill()</statement>
+        object is unnecessary since it is the default replacement
+        method.</para>
+       </callout>
+       <callout arearefs="arrays-dynamic_arrays-example-destroy_iterators">
+        <para>This <methodname>destroy</methodname> call is equivalent
+        to the previous one but uses iterators.</para>
+       </callout>
+      </calloutlist>
+     </example>
+ 
     </section>
  
  
+ <![%unfinished;[
     <section id="arrays-doof2d">
      <title>An &array; Implementation of &doof2d;</title>
  
*************** d.destroy(killList, killList+5);
*** 2177,2181 ****
--- 2136,2141 ----
      to describe how a programmer would implement a new type of domain?
      Probably not.</para>
     </section>
+ ]]>  <!-- end unfinished -->
  
    </chapter>
Index: bibliography.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/bibliography.xml,v
retrieving revision 1.1
diff -c -p -r1.1 bibliography.xml
*** bibliography.xml	2002/01/04 17:42:43	1.1
--- bibliography.xml	2002/01/25 02:15:03
***************
*** 1,5 ****
--- 1,7 ----
  <!-- Bibliography -->
  
+ <![%unfinished;[
+ 
  <bibliography id="bibliography">
   <title>Bibliography</title>
  
*************** Array.  1995.  unpublished.  Available a
*** 275,277 ****
--- 277,281 ----
  
  
  </bibliography>
+ 
+ ]]>  <!-- end unfinished -->
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.8
diff -c -p -r1.8 concepts.xml
*** concepts.xml	2002/01/24 05:11:21	1.8
--- concepts.xml	2002/01/25 02:15:04
***************
*** 57,63 ****
  	<entry>Computation Environment</entry>
       </row>
      </thead>
!     <tbody>
       <row>
  	<entry>&array;</entry>
  	<entry>element-wise</entry>
--- 57,63 ----
  	<entry>Computation Environment</entry>
       </row>
      </thead>
!     <tbody valign="top">
       <row>
  	<entry>&array;</entry>
  	<entry>element-wise</entry>
***************
*** 136,142 ****
  	   orient="port" pgwide="0" id="concepts-containers-table">
     <title>&pooma; Container Summary</title>
     <tgroup cols="2" align="left">
!     <tbody>
       <row>
  	<entry><glossterm
  	linkend="glossary-array">&array;</glossterm></entry>
--- 136,142 ----
  	   orient="port" pgwide="0" id="concepts-containers-table">
     <title>&pooma; Container Summary</title>
     <tgroup cols="2" align="left">
!     <tbody valign="top">
       <row>
  	<entry><glossterm
  	linkend="glossary-array">&array;</glossterm></entry>
***************
*** 265,271 ****
  	   orient="port" pgwide="0" id="concepts-containers-choice_table">
     <title>Choosing a &pooma; Container</title>
     <tgroup cols="2" align="left">
!     <tbody>
       <row>
  	<entry>If modeling mathematical entries,</entry>
  	<entry>use a &vector;, &matrix;, or &tensor;.</entry>
--- 265,271 ----
  	   orient="port" pgwide="0" id="concepts-containers-choice_table">
     <title>Choosing a &pooma; Container</title>
     <tgroup cols="2" align="left">
!     <tbody valign="top">
       <row>
  	<entry>If modeling mathematical entries,</entry>
  	<entry>use a &vector;, &matrix;, or &tensor;.</entry>
Index: data-parallel.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/data-parallel.xml,v
retrieving revision 1.2
diff -c -p -r1.2 data-parallel.xml
*** data-parallel.xml	2002/01/24 05:11:21	1.2
--- data-parallel.xml	2002/01/25 02:15:05
***************
*** 1,16 ****
    <chapter id="data_parallel">
     <title>Data-Parallel Expressions</title>
  
!    <para>In the previous sections, we accessed container values one at
     a time.  Accessing more than one value in a container required a
     writing an explicit loop.  Scientists and engineers commonly
     operate on sets of values, treated as an aggregate.  For example, a
     vector is a one-dimension collection of data and two vectors can be
     added together.  A matrix is a two-dimensional collection of data,
!    and a scalar and a matrix are multiplied.  A <glossterm
     linkend="glossary-data_parallel"><firstterm>data-parallel
     expression</firstterm></glossterm> simultaneously uses multiple
!    container values.  &pooma; supports data-parallel syntax.</para>
  
     <para>After introducing data-parallel expressions and statements,
     we present the corresponding &pooma; syntax.  Then we present its
--- 1,17 ----
    <chapter id="data_parallel">
     <title>Data-Parallel Expressions</title>
  
!    <para>In the previous chapters, we accessed container values one at
     a time.  Accessing more than one value in a container required a
     writing an explicit loop.  Scientists and engineers commonly
     operate on sets of values, treated as an aggregate.  For example, a
     vector is a one-dimension collection of data and two vectors can be
     added together.  A matrix is a two-dimensional collection of data,
!    and a scalar and a matrix can be multiplied.  A <glossterm
     linkend="glossary-data_parallel"><firstterm>data-parallel
     expression</firstterm></glossterm> simultaneously uses multiple
!    container values.  &pooma; supports data-parallel
!    expressions.</para>
  
     <para>After introducing data-parallel expressions and statements,
     we present the corresponding &pooma; syntax.  Then we present its
***************
*** 61,73 ****
      <para>&pooma; containers can be used in data-parallel expressions
      and statements.  The basic guidelines are simple:
      <itemizedlist>
! 		   <listitem>
! 		   <para>The &cc; built-in and mathematical operators operate on
         an entire container by operating element-wise on its values.</para>
!    </listitem>
      <listitem>
       <para>Binary operators operate only on containers with the same
!       domain types by combining values with the same indices.  If the
        result is a container, it has a domain equal to the left operand's
        domain.</para>
      </listitem>
--- 62,74 ----
      <para>&pooma; containers can be used in data-parallel expressions
      and statements.  The basic guidelines are simple:
      <itemizedlist>
!      <listitem>
!       <para>The &cc; built-in and mathematical operators operate on
         an entire container by operating element-wise on its values.</para>
!      </listitem>
      <listitem>
       <para>Binary operators operate only on containers with the same
!       domain types and by combining values with the same indices.  If the
        result is a container, it has a domain equal to the left operand's
        domain.</para>
      </listitem>
***************
*** 79,86 ****
     </itemizedlist>
     </para>
  
!     <para>The operators operate element-wise on containers' values.
!     For example, if <varname>A</varname> is a one-dimensional array,
      <statement>-<varname>A</varname></statement> is a one-dimensional
      array with the same size such that the value at the
      i<superscript>th</superscript> position equals -A(i).  If
--- 80,88 ----
     </itemizedlist>
     </para>
  
!     <para>The data-parallel operators operate element-wise on
!     containers' values.  For example, if <varname>A</varname> is a
!     one-dimensional array,
      <statement>-<varname>A</varname></statement> is a one-dimensional
      array with the same size such that the value at the
      i<superscript>th</superscript> position equals -A(i).  If
***************
*** 91,114 ****
      corresponding values in <varname>A</varname> and
      <varname>B</varname>.</para>
  
-     <figure float="1" id="data_parallel-use-addition_example">
-      <title>Adding &array;s with Different Domains</title>
-        <mediaobject>
- 	<imageobject>
- 	 <imagedata fileref="figures/data-parallel.212" format="EPS" align="center"></imagedata>
- 	</imageobject>
- 	<textobject>
- 	 <phrase>Adding two arrays with different domains adds values
-        with the same indices.</phrase>
- 	</textobject>
- 	<caption>
- 	 <para>Adding &array;s with different domains is supported.
-        Solid lines indicate the domains' extent.  Values with the same
-        indices are added.</para>
-       </caption>
-      </mediaobject>
-     </figure>
- 
      <para>Binary operators operate on containers with the same domain
      types.  The domain's indices need not be the same, but the result
      will have a domain equal to the left operand.  For example, the
--- 93,98 ----
*************** Interval<1> H(0,2), I(1,3), J(2,4);
*** 131,155 ****
  Array<2, double, Brick> A(I,I), B(J,H);
  // ... fill A and B with values ...
  ... = A + B;
! </programlisting>Both <varname>A</varname> and
!     <varname>B</varname> have domains of two-dimensional intervals so
!     they may be added, but their domains' extent differ, as indicated
!     by the solid lines in the figure.  The sum has domain equal to the
!     left operand's domain.  Values with the same indices are added.  For
!     example, <statement>A(2,2)</statement> and
!     <statement>B(2,2)</statement> are added.  <varname>B</varname>'s
!     domain does not include index (1,1) so, when adding
!     <statement>A(1,1)</statement> and <statement>B(1,1)</statement>,
!     the default value for <varname>B</varname>'s value type is used.
!     Usually this is&nbsp;0.  Thus, <statement>A(1,1) +
!     B(1,1)</statement> equals <statement>9 + 0</statement>.</para>
! 
!     <para>Operations with &array;s and scalar values are supported.
!     Conceptually, a scalar value can be thought of as an &array; with
!     any desired domain and having the same value everywhere.  For
!     example, consider
  <programlisting>
! 		 Array<1, double, Brick> D(Interval<1>(7,10));
  D += 2*D + 7;
  </programlisting><statement>2*D</statement> obeys the guidelines
      because the scalar <statement>2</statement> can be thought of as
--- 115,159 ----
  Array<2, double, Brick> A(I,I), B(J,H);
  // ... fill A and B with values ...
  ... = A + B;
! </programlisting></para>
! 
!     <figure float="1" id="data_parallel-use-addition_example">
!      <title>Adding &array;s with Different Domains</title>
!        <mediaobject>
! 	<imageobject>
! 	 <imagedata fileref="figures/data-parallel.212" format="EPS" align="center"></imagedata>
! 	</imageobject>
! 	<textobject>
! 	 <phrase>Adding two arrays with different domains adds values
!        with the same indices.</phrase>
! 	</textobject>
! 	<caption>
! 	 <para>Adding &array;s with different domains is supported.
!        Solid lines indicate the domains' extent.  Values with the same
!        indices are added.</para>
!       </caption>
!      </mediaobject>
!     </figure>
! 
!     <para>Both <varname>A</varname> and <varname>B</varname> have
!     domains of two-dimensional intervals so they may be added, but
!     their domains' extent differ, as indicated by the solid lines in
!     the figure.  The sum has domain equal to the left operand's
!     domain.  Values with the same indices are added.  For example,
!     <statement>A(2,2)</statement> and <statement>B(2,2)</statement>
!     are added.  <varname>B</varname>'s domain does not include index
!     (1,1) so, when adding <statement>A(1,1)</statement> and
!     <statement>B(1,1)</statement>, the default value for
!     <varname>B</varname>'s value type is used.  Usually this
!     is&nbsp;0.  Thus, <statement>A(1,1) + B(1,1)</statement> equals
!     <statement>9 + 0</statement>.</para>
! 
!     <para>Operations with both &array;s and scalar values are
!     supported.  Conceptually, a scalar value can be thought of as an
!     &array; with any desired domain and having the same value
!     everywhere.  For example, consider
  <programlisting>
! Array<1, double, Brick> D(Interval<1>(7,10));
  D += 2*D + 7;
  </programlisting><statement>2*D</statement> obeys the guidelines
      because the scalar <statement>2</statement> can be thought of as
*************** D += 2*D + 7;
*** 163,180 ****
      not first convert scalar values to arrays but instead uses them
      directly in expressions.</para>
  
!     <para>Assignment to containers is also supported.  The domain
      types of the assignment's left-hand side and its right-hand side
      must be the same.  Their indices need not be the same, but they
      must correspond.  That is, the domains must be <glossterm
!     linkend="glossary-conformable_domains"><firstterm>conformable
!     domains</firstterm></glossterm>, or have the <quote>same
!     shape</quote>, i.e., have the same number of indices for each
!     dimension.  For example, the one-dimensional interval [0,3] is
!     conformable to the one-dimensional interval [1,4] because they
!     both have the same number of indices in each dimension.  The
!     domains of <varname>A</varname> and <varname>B</varname>, as
!     declared
  <programlisting>
  Interval<1> H(0,2), I(1,3), J(2,4), K(0,4);
  Array<2, double, Brick> A(I,I), B(H,J), C(I,K);
--- 167,183 ----
      not first convert scalar values to arrays but instead uses them
      directly in expressions.</para>
  
!     <para>Assignments to containers are also supported.  The domain
      types of the assignment's left-hand side and its right-hand side
      must be the same.  Their indices need not be the same, but they
      must correspond.  That is, the domains must be <glossterm
!     linkend="glossary-conformable_domains"><firstterm>conformable</firstterm></glossterm>,
!     or have the <quote>same shape</quote>, i.e., have the same number
!     of indices for each dimension.  For example, the one-dimensional
!     interval [0,3] is conformable to the one-dimensional interval
!     [1,4] because they both have the same number of indices in each
!     dimension.  The domains of <varname>A</varname> and
!     <varname>B</varname>, as declared
  <programlisting>
  Interval<1> H(0,2), I(1,3), J(2,4), K(0,4);
  Array<2, double, Brick> A(I,I), B(H,J), C(I,K);
*************** Array<2, double, Brick> A(I,I), B(H,J), 
*** 182,188 ****
      number of indices.  <varname>A</varname> and <varname>C</varname>
      are not conformable because, while their first dimensions are
      conformable, their second dimensions are not conformable.  It has
!     three indices while the other has four.  We define <glossterm
      linkend="glossary-conformable_containers"><firstterm>conformable
      containers</firstterm></glossterm> to be containers with
      conformable domains.</para>
--- 185,191 ----
      number of indices.  <varname>A</varname> and <varname>C</varname>
      are not conformable because, while their first dimensions are
      conformable, their second dimensions are not conformable.  It has
!     three indices while the other has five.  We define <glossterm
      linkend="glossary-conformable_containers"><firstterm>conformable
      containers</firstterm></glossterm> to be containers with
      conformable domains.</para>
*************** Array<1, double, Brick> A(Interval<1>(0,
*** 222,228 ****
  Array<1, double, Brick> B(Interval<1>(1,3));
  A = 1.0;
  B = 2.0;
! std::cout << A-B << std::endl;
  </programlisting> yields
      <computeroutput>
      (000:002:001) = 1 -1 -1</computeroutput>.  The initial
--- 225,231 ----
  Array<1, double, Brick> B(Interval<1>(1,3));
  A = 1.0;
  B = 2.0;
! std::cout &openopen; A-B &openopen; std::endl;
  </programlisting> yields
      <computeroutput>
      (000:002:001) = 1 -1 -1</computeroutput>.  The initial
*************** std::cout << A-B << std::endl;
*** 233,261 ****
      <para>The following four tables list the data-parallel operators
      that operate on &array;s.  <xref
      linkend="data_parallel-use-operators_table"></xref> lists standard
!     &cc; operators that can be applied to &array;s and constant values
!     if appropriate.  Each unary operator takes an &array; parameter
!     and returns an &array;.  The types of the two &array;s need not be
!     the same.  For example, <operator>!</operator> can take an
!     <type>Array&lt;bool&gt;</type>, <type>Array&lt;int&gt;</type>,
!     <type>Array&lt;long&gt;</type>, or any other value type to which
!     <operator>!</operator> can be applied.  The result is an
!     <type>Array&lt;bool&gt;</type>.  Each binary operator also returns
!     an &array;.  When specifying two &array;s or an &array; and a
!     constant value, a full set of operators is supported.  When
!     specifying an &array; and a &tensor;, &matrix;, or &vector;, a
!     more limited set of operators is supported.  For example,
!     <operator>==</operator> can take two &array;s, an &array; and a
!     constant value, or a constant value and an &array;.  If given two
!     &array;s, corresponding values are used.  If a parameter is a
!     constant value, its same value is the used with each &array;
!     value.  The <operator>+</operator> supports the same set of
!     parameters but also supports adding an &array; and a &tensor;, an
!     &array; and a &matrix;, an &array; and a &vector;, a &tensor; and
!     an &array;, a &matrix; and an &array;, and a &vector; and an
!     &array;.  For these cases, the &array; must have a value type that
!     can be added to the other argument.  For example, a &vector; can
!     be added to an &array; of &vector;s.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
       orient="port" pgwide="0" id="data_parallel-use-operators_table">
--- 236,264 ----
      <para>The following four tables list the data-parallel operators
      that operate on &array;s.  <xref
      linkend="data_parallel-use-operators_table"></xref> lists standard
!     &cc; operators that can be applied to &array;s and also scalar
!     values if appropriate.  Each unary operator takes an &array;
!     parameter and returns an &array;.  The types of the two &array;s
!     need not be the same.  For example, <operator>!</operator> can
!     take an <type>Array&lt;bool&gt;</type>,
!     <type>Array&lt;int&gt;</type>, <type>Array&lt;long&gt;</type>, or
!     any other value type to which <operator>!</operator> can be
!     applied.  The result is an <type>Array&lt;bool&gt;</type>.  Each
!     binary operator also returns an &array;.  When specifying two
!     &array;s or an &array; and a scalar value, a full set of operators
!     is supported.  When specifying an &array; and a &tensor;,
!     &matrix;, or &vector;, a more limited set of operators is
!     supported.  For example, <operator>==</operator> can take two
!     &array;s, an &array; and a scalar value, or a scalar value and an
!     &array;.  If given two &array;s, corresponding values are used.
!     If an argument is a scalar value, its same value is the used with
!     each &array; value.  The <operator>+</operator> supports the same
!     set of parameters but also supports adding an &array; and a
!     &tensor;, an &array; and a &matrix;, an &array; and a &vector;, a
!     &tensor; and an &array;, a &matrix; and an &array;, and a &vector;
!     and an &array;.  For these cases, the &array; must have a value
!     type that can be added to the other argument.  For example, a
!     &vector; can be added to an &array; of &vector;s.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
       orient="port" pgwide="0" id="data_parallel-use-operators_table">
*************** std::cout << A-B << std::endl;
*** 268,287 ****
          <entry>supported operators</entry>
         </row>
        </thead>
!       <tbody>
         <row>
          <entry>unary operators </entry>
          <entry><operator>+</operator>, <operator>-</operator>, <operator>~</operator>, <operator>!</operator></entry>
         </row>
         <row>
!         <entry>binary operators with at least one array and at most
!         one value</entry>
          <entry><operator>+</operator>, <operator>-</operator>, <operator>*</operator>, <operator>/</operator>, <operator>%</operator>, <operator>&amp;</operator>, <operator>|</operator>, <operator>^</operator>, <operator>&lt;</operator>, <operator>&lt;=</operator>, <operator>&gt;=</operator>, <operator>&gt;</operator>, <operator>==</operator>, <operator>!=</operator>, <operator>&amp;&amp;</operator>, <operator>||</operator>, <operator>&openopen;</operator>, <operator>&closeclose;</operator></entry>
         </row>
         <row>
!         <entry>binary operators with at least one array and at most
          one &tensor;, &matrix;, or &vector;</entry>
!         <entry><operator>+</operator>, <operator>-</operator>, <operator>*</operator>, <operator>/</operator>, <operator>%</operator>, <operator>&amp;</operator>, <operator>|</operator>, <operator>^</operator>, <operator>==</operator>, <operator>!=</operator></entry>
         </row>
        </tbody>
       </tgroup>
--- 271,294 ----
          <entry>supported operators</entry>
         </row>
        </thead>
!       <tbody valign="top">
         <row>
          <entry>unary operators </entry>
          <entry><operator>+</operator>, <operator>-</operator>, <operator>~</operator>, <operator>!</operator></entry>
         </row>
         <row>
!         <entry>binary operators with at least one &array; and at most
!         one scalar value</entry>
          <entry><operator>+</operator>, <operator>-</operator>, <operator>*</operator>, <operator>/</operator>, <operator>%</operator>, <operator>&amp;</operator>, <operator>|</operator>, <operator>^</operator>, <operator>&lt;</operator>, <operator>&lt;=</operator>, <operator>&gt;=</operator>, <operator>&gt;</operator>, <operator>==</operator>, <operator>!=</operator>, <operator>&amp;&amp;</operator>, <operator>||</operator>, <operator>&openopen;</operator>, <operator>&closeclose;</operator></entry>
         </row>
         <row>
!         <entry>binary operators with at least one &array; and at most
          one &tensor;, &matrix;, or &vector;</entry>
!         <entry><operator>+</operator>, <operator>-</operator>,
!         <operator>*</operator>, <operator>/</operator>,
!         <operator>%</operator>, <operator>&amp;</operator>,
!         <operator>|</operator>, <operator>^</operator>,
!         <operator>==</operator>, <operator>!=</operator></entry>
         </row>
        </tbody>
       </tgroup>
*************** std::cout << A-B << std::endl;
*** 291,302 ****
      expressions appear in <xref
      linkend="data_parallel-use-math_functions_table"></xref>.  For
      example, applying <function>cos</function> to an &array; of values
!     with type&nbsp;<type>T</type> yields an array of the same type.
!     The functions are split into five sections:
!      <itemizedlist>
! 		  <listitem>
! 		   <para>trigonometric and hyperbolic functions,</para>
! 		  </listitem>
  		  <listitem>
  		   <para>functions computing absolute values, rounding functions,
         and modulus functions,</para>
--- 298,309 ----
      expressions appear in <xref
      linkend="data_parallel-use-math_functions_table"></xref>.  For
      example, applying <function>cos</function> to an &array; of values
!     with type&nbsp;<type>T</type> yields an &array; with the same
!     type.  The functions are split into five sections:
!     <itemizedlist>
!      <listitem>
!       <para>trigonometric and hyperbolic functions,</para>
!      </listitem>
  		  <listitem>
  		   <para>functions computing absolute values, rounding functions,
         and modulus functions,</para>
*************** std::cout << A-B << std::endl;
*** 312,326 ****
  		  </listitem>
  		 </itemizedlist>
      Several data-parallel functions require inclusion of header files
!     declaring the underlying element-wise function.  These header
      files are listed at the beginning of each section.  For the
      data-parallel operator to be applicable, it must operate on the
      &array;'s type.  For example, <function>cos</function> can be
! 							   applied on &array;s of &int;, &double;, and even &bool;, but
      applying on &array;s of pointers is not supported because
!     <function>cos</function> cannot be called with a pointer argument.</para>
  
!     <para>A few functions deserve explanation.  The
      <function>PETE_identity</function> function applies the identity
      operation to the array.  That is, the returned array has values
      equaling the argument's values.  <function>pow2</function>,
--- 319,334 ----
  		  </listitem>
  		 </itemizedlist>
      Several data-parallel functions require inclusion of header files
!     declaring their underlying element-wise function.  These header
      files are listed at the beginning of each section.  For the
      data-parallel operator to be applicable, it must operate on the
      &array;'s type.  For example, <function>cos</function> can be
!     applied on &array;s of &int;, &double;, and even &bool;, but
      applying on &array;s of pointers is not supported because
!     <function>cos</function> cannot be called with a pointer
!     argument.</para>
  
!     <para>Two functions deserve special explanation.  The
      <function>PETE_identity</function> function applies the identity
      operation to the array.  That is, the returned array has values
      equaling the argument's values.  <function>pow2</function>,
*************** std::cout << A-B << std::endl;
*** 347,380 ****
  	choices for the template type parameters.</entry>
         </row>
        </tfoot>
!       <tbody>
         <row rowsep="1">
  	<entry>Trigonometric and Hyperbolic Functions</entry>
  	<entry><statement>#include &lt;math.h&gt;</statement></entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; cos (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the cosines of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; sin (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the sines of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; tan (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the tangents of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; acos (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>Returns the arc cosines of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; asin (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>Returns the arc sines of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; atan (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>Returns the arc tangents of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
--- 355,388 ----
  	choices for the template type parameters.</entry>
         </row>
        </tfoot>
!       <tbody valign="top">
         <row rowsep="1">
  	<entry>Trigonometric and Hyperbolic Functions</entry>
  	<entry><statement>#include &lt;math.h&gt;</statement></entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; cos (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the cosines of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; sin (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the sines of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; tan (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the tangents of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; acos (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>Returns the arc cosines of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; asin (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>Returns the arc sines of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; atan (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>Returns the arc tangents of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
*************** std::cout << A-B << std::endl;
*** 398,412 ****
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; cosh (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the hyperbolic cosines of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; sinh (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the hyperbolic sines of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; tanh (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the hyperbolic tangents of the array's values.</entry>
         </row>
         <row rowsep="1">
  	<entry>Absolute Value, Rounding, and Modulus Functions</entry>
--- 406,420 ----
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; cosh (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the hyperbolic cosines of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; sinh (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the hyperbolic sines of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; tanh (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the hyperbolic tangents of the &array;'s values.</entry>
         </row>
         <row rowsep="1">
  	<entry>Absolute Value, Rounding, and Modulus Functions</entry>
*************** std::cout << A-B << std::endl;
*** 415,435 ****
         <row>
  	<entry><statement>Array&lt;T&gt; fabs (const Array&lt;T1&gt;&amp; A)</statement></entry>
  	<entry>Returns the absolute values of the floating point
! 	numbers in the array.</entry>
!        </row>
!        <row>
! 	<entry><statement>Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>For each of the array's values, return the integer
! 	larger than or equal to it (as a floating point number).</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>For each of the array's values, return the integer
  	larger than or equal to it (as a floating point number).</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; floor (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>For each of the array's values, return the integer
  	smaller than or equal to it (as a floating point number).</entry>
         </row>
         <row>
--- 423,438 ----
         <row>
  	<entry><statement>Array&lt;T&gt; fabs (const Array&lt;T1&gt;&amp; A)</statement></entry>
  	<entry>Returns the absolute values of the floating point
! 	numbers in the &array;.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>For each of the &array;'s values, return the integer
  	larger than or equal to it (as a floating point number).</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; floor (const Array&lt;T1&gt;&amp; A)</statement></entry>
! 	<entry>For each of the &array;'s values, return the integer
  	smaller than or equal to it (as a floating point number).</entry>
         </row>
         <row>
*************** std::cout << A-B << std::endl;
*** 438,444 ****
  	<varname>A</varname>'s values with the corresponding value
  	in&nbsp;<varname>B</varname>.  The results have the same signs
  	as <varname>A</varname> and absolute values less than the
! 	absolute values of values in&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
--- 441,447 ----
  	<varname>A</varname>'s values with the corresponding value
  	in&nbsp;<varname>B</varname>.  The results have the same signs
  	as <varname>A</varname> and absolute values less than the
! 	absolute values of&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
*************** std::cout << A-B << std::endl;
*** 453,459 ****
  	<varname>l</varname> with the values
  	in&nbsp;<varname>B</varname>.  The results have the same signs
  	as <varname>l</varname> and absolute values less than the
! 	absolute values of values in&nbsp;<varname>B</varname>.</entry>
         </row>
         <row rowsep="1">
  	<entry>Powers, Exponentiation, and Logarithmic Functions</entry>
--- 456,462 ----
  	<varname>l</varname> with the values
  	in&nbsp;<varname>B</varname>.  The results have the same signs
  	as <varname>l</varname> and absolute values less than the
! 	absolute values of&nbsp;<varname>B</varname>.</entry>
         </row>
         <row rowsep="1">
  	<entry>Powers, Exponentiation, and Logarithmic Functions</entry>
*************** std::cout << A-B << std::endl;
*** 461,471 ****
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; PETE_identity (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the array.  That is, it applies the identity operation.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; sqrt (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the square roots of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
--- 464,474 ----
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; PETE_identity (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the &array;.  That is, it applies the identity operation.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; sqrt (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the square roots of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
*************** std::cout << A-B << std::endl;
*** 501,507 ****
         <row>
  	<entry><statement>Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, int r)</statement></entry>
  	<entry>Multiplies <varname>A</varname>'s values by two raised
! 	to the <varname>r</varname>'th power.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; ldexp (const T1&amp; l, const Array&lt;int&gt;&amp; B)</statement></entry>
--- 504,511 ----
         <row>
  	<entry><statement>Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, int r)</statement></entry>
  	<entry>Multiplies <varname>A</varname>'s values by two raised
! 	to the <varname>r</varname><subscript>th</subscript>
! 	power.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; ldexp (const T1&amp; l, const Array&lt;int&gt;&amp; B)</statement></entry>
*************** std::cout << A-B << std::endl;
*** 510,524 ****
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; exp (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the exponentiations of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; log (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the natural logarithms of the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; log10 (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the base-10 logarithms of the array's values.</entry>
         </row>
         <row rowsep="1">
  	<entry>Functions Involving Complex Numbers</entry>
--- 514,528 ----
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; exp (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the exponentiations of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; log (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the natural logarithms of the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; log10 (const Array&lt;T&gt;&amp; A)</statement></entry>
! 	<entry>Returns the base-10 logarithms of the &array;'s values.</entry>
         </row>
         <row rowsep="1">
  	<entry>Functions Involving Complex Numbers</entry>
*************** std::cout << A-B << std::endl;
*** 561,578 ****
  	<entry><statement>Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns the complex numbers created from polar
  	 coordinates (magnitudes and phase angles) in corresponding
! 	 arrays.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;complex&lt;T&closeclose; polar (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns the complex numbers created from polar
  	 coordinates with magnitude&nbsp;<varname>l</varname> and
! 	 phase angles in the array.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns the complex numbers created from polar
! 	 coordinates with magnitudes in the array and phase
  	 angle&nbsp;<varname>r</varname>.</entry>
         </row>
         <row rowsep="1">
--- 565,582 ----
  	<entry><statement>Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns the complex numbers created from polar
  	 coordinates (magnitudes and phase angles) in corresponding
! 	 &array;s.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;complex&lt;T&closeclose; polar (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns the complex numbers created from polar
  	 coordinates with magnitude&nbsp;<varname>l</varname> and
! 	 phase angles in the &array;.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns the complex numbers created from polar
! 	 coordinates with magnitudes in the &array; and phase
  	 angle&nbsp;<varname>r</varname>.</entry>
         </row>
         <row rowsep="1">
*************** std::cout << A-B << std::endl;
*** 599,612 ****
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
! 	<entry>Returns the dot products of values in the two arrays.
  	 Value type <type>T</type> equals the type of the
  	 <function>dot</function> operating on <type>T1</type>
  	 and <type>T2</type>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
! 	<entry>Returns the dot products of values in the array
  	 with&nbsp;<varname>r</varname>.
  	 Value type <type>T</type> equals the type of the
  	 <function>dot</function> operating on <type>T1</type>
--- 603,616 ----
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
! 	<entry>Returns the dot products of values in the two &array;s.
  	 Value type <type>T</type> equals the type of the
  	 <function>dot</function> operating on <type>T1</type>
  	 and <type>T2</type>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
! 	<entry>Returns the dot products of values in the &array;
  	 with&nbsp;<varname>r</varname>.
  	 Value type <type>T</type> equals the type of the
  	 <function>dot</function> operating on <type>T1</type>
*************** std::cout << A-B << std::endl;
*** 615,635 ****
         <row>
  	<entry><statement>Array&lt;T&gt; dot (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns the dot products of <varname>l</varname> with
! 	 values in the array.  Value type <type>T</type> equals the type of the
  	 <function>dot</function> operating on <type>T1</type>
  	 and <type>T2</type>.</entry>
         </row>
         <row>
- 	<entry><statement>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; B)</statement></entry>
- 	<entry>Returns the dot products of values in the array
- 	 Value type <type>T</type> equals the type of the
- 	 <function>dot</function> operating on <type>T1</type>
- 	 and <type>T2</type>.</entry>
-        </row>
-        <row>
  	<entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns tensors created by computing the outer product
! 	 of corresponding vectors in the two arrays.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors
  	 must have the same length.</entry>
--- 619,632 ----
         <row>
  	<entry><statement>Array&lt;T&gt; dot (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns the dot products of <varname>l</varname> with
! 	 values in the &array;.  Value type <type>T</type> equals the type of the
  	 <function>dot</function> operating on <type>T1</type>
  	 and <type>T2</type>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns tensors created by computing the outer product
! 	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors
  	 must have the same length.</entry>
*************** std::cout << A-B << std::endl;
*** 637,643 ****
         <row>
  	<entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns tensors created by computing the outer product
! 	 of <varname>l</varname> with the vectors in the array.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors
  	 must have the same length.</entry>
--- 634,640 ----
         <row>
  	<entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns tensors created by computing the outer product
! 	 of <varname>l</varname> with the vectors in the &array;.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors
  	 must have the same length.</entry>
*************** std::cout << A-B << std::endl;
*** 645,651 ****
         <row>
  	<entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns tensors created by computing the outer product
! 	 of vectors in the array with&nbsp;<varname>r</varname>.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors
  	 must have the same length.</entry>
--- 642,648 ----
         <row>
  	<entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns tensors created by computing the outer product
! 	 of vectors in the &array; with&nbsp;<varname>r</varname>.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors
  	 must have the same length.</entry>
*************** std::cout << A-B << std::endl;
*** 654,660 ****
  	<entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const Array&lt;T1&gt;&amp; A, const
  	 Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns matrices created by computing the outer product
! 	 of corresponding vectors in the two arrays.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors must have
  	 the same length.</entry>
--- 651,657 ----
  	<entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const Array&lt;T1&gt;&amp; A, const
  	 Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns matrices created by computing the outer product
! 	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors must have
  	 the same length.</entry>
*************** std::cout << A-B << std::endl;
*** 663,669 ****
  	<entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const T1&amp; l, const
  	 Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns matrices created by computing the outer
! 	 product of <varname>l</varname> with the vectors in the array.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors must
  	 have the same length.</entry>
--- 660,666 ----
  	<entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const T1&amp; l, const
  	 Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns matrices created by computing the outer
! 	 product of <varname>l</varname> with the vectors in the &array;.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors must
  	 have the same length.</entry>
*************** std::cout << A-B << std::endl;
*** 672,678 ****
  	<entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const
  	 Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns matrices created by computing the outer
! 	 product of the vectors in the array
  	 with&nbsp;<varname>r</varname>.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors must
--- 669,675 ----
  	<entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const
  	 Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns matrices created by computing the outer
! 	 product of the vectors in the &array;
  	 with&nbsp;<varname>r</varname>.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
  	 <type>T1</type> and <type>T2</type>.  The vectors must
*************** std::cout << A-B << std::endl;
*** 701,828 ****
  	<entry>effect</entry>
         </row>
        </thead>
!       <tbody>
         <row>
  	<entry><statement>Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
! 	<entry>Returns the maximum of corresponding array values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; max (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
! 	<entry>Returns the maximums of <varname>l</varname> with the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
! 	<entry>Returns the maximums of the array's values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
! 	<entry>Returns the minimum of corresponding array values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; min (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
! 	<entry>Returns the minimums of <varname>l</varname> with the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
! 	<entry>Returns the minimums of the array's values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;&lt; to compare corresponding array values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LT (const T1&amp; r, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;&lt; to compare <varname>l</varname> with the array's
  	 values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;&lt; to compare the array's
  	 values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&le; to compare array values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&le; to compare <varname>l</varname> with the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;&le; to compare the array's values
  	 with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&ge; to compare array values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&ge; to compare <varname>l</varname> with the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;&ge; to compare the array's values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;&gt; to compare array values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GT (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;&gt; to compare <varname>l</varname> with the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;&gt; to compare the array's values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from determining whether
! 	 corresponding array values in <varname>A</varname> and
  	 <varname>B</varname> are equal.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; EQ (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from determining whether
! 	 <varname>l</varname> equals the array's values..</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
! 	<entry>Returns booleans from determining whether the array's values equal&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from determining whether
! 	 corresponding array values in <varname>A</varname> and
  	 <varname>B</varname> are not equal.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; NE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from determining whether
! 	 <varname>l</varname> does not equal the array's values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from determining whether the 
! 	 array's values are not equal to&nbsp;<varname>r</varname>.</entry>
         </row>
         <!-- FIXME: Add dotdot from src/Array/PoomaArrayOperators.h if it is defined. -->
        </tbody>
--- 698,825 ----
  	<entry>effect</entry>
         </row>
        </thead>
!       <tbody valign="top">
         <row>
  	<entry><statement>Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
! 	<entry>Returns the maximum of corresponding &array; values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; max (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
! 	<entry>Returns the maximums of <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
! 	<entry>Returns the maximums of the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
! 	<entry>Returns the minimum of corresponding &array; values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; min (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
! 	<entry>Returns the minimums of <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
! 	<entry>Returns the minimums of the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;<operator>&lt;</operator> to compare corresponding &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LT (const T1&amp; r, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;<operator>&lt;</operator> to compare <varname>l</varname> with the &array;'s
  	 values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;<operator>&lt;</operator> to compare the &array;'s
  	 values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;<operator>&lt;=</operator> to compare &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;<operator>&lt;=</operator> to compare <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;<operator>&lt;=</operator> to compare the &array;'s values
  	 with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;<operator>&gt;=</operator> to compare &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;<operator>&gt;=</operator> to compare <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;<operator>&gt;=</operator> to compare the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;<operator>&gt;</operator> to compare &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GT (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;<operator>&gt;</operator> to compare <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;<operator>&gt;</operator> to compare the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from determining whether
! 	 corresponding &array; values in <varname>A</varname> and
  	 <varname>B</varname> are equal.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; EQ (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from determining whether
! 	 <varname>l</varname> equals the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
! 	<entry>Returns booleans from determining whether the &array;'s values equal&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from determining whether
! 	 corresponding &array; values in <varname>A</varname> and
  	 <varname>B</varname> are not equal.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; NE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from determining whether
! 	 <varname>l</varname> does not equal the &array;'s values.</entry>
         </row>
         <row>
  	<entry><statement>Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from determining whether the 
! 	 &array;'s values are not equal to&nbsp;<varname>r</varname>.</entry>
         </row>
         <!-- FIXME: Add dotdot from src/Array/PoomaArrayOperators.h if it is defined. -->
        </tbody>
*************** std::cout << A-B << std::endl;
*** 832,838 ****
      <para>The table of miscellaneous functions (<xref
  						      linkend="data_parallel-use-misc_functions_table"></xref>) contains
      two functions.  <function>peteCast</function> casts all values in
!     an array to the type specified by the first parameter.  The
      <function>where</function> function generalizes the trinary
      <operator>?:</operator> operator.  Using its first &array;
      argument as boolean values, it returns an &array; of just two
--- 829,835 ----
      <para>The table of miscellaneous functions (<xref
  						      linkend="data_parallel-use-misc_functions_table"></xref>) contains
      two functions.  <function>peteCast</function> casts all values in
!     an &array; to the type specified by its first parameter.  The
      <function>where</function> function generalizes the trinary
      <operator>?:</operator> operator.  Using its first &array;
      argument as boolean values, it returns an &array; of just two
*************** std::cout << A-B << std::endl;
*** 849,863 ****
  	   <entry>effect</entry>
  	  </row>
  	 </thead>
! 	 <tbody>
  	  <row>
  	   <entry><statement>Array&lt;T&gt; peteCast (const T1&amp;, const Array&lt;T&gt;&amp; A)</statement></entry>
! 	   <entry>Returns the casting of the array's values to type <type>T1</type>.</entry>
  	  </row>
  	  <row>
  	   <entry><statement>Array&lt;T&gt; where (const Array&lt;T1&gt;&amp; A, const T2&amp; t, const T3&amp; f)</statement></entry>
  	   <entry>Generalizes the <operator>?:</operator> operator,
! 	returning an array of <varname>t</varname> and
  	<varname>f</varname> values depending on whether
  	<varname>A</varname>'s values are true or false,
  	respectively.</entry>
--- 846,860 ----
  	   <entry>effect</entry>
  	  </row>
  	 </thead>
! 	 <tbody valign="top">
  	  <row>
  	   <entry><statement>Array&lt;T&gt; peteCast (const T1&amp;, const Array&lt;T&gt;&amp; A)</statement></entry>
! 	   <entry>Returns the casting of the &array;'s values to type <type>T1</type>.</entry>
  	  </row>
  	  <row>
  	   <entry><statement>Array&lt;T&gt; where (const Array&lt;T1&gt;&amp; A, const T2&amp; t, const T3&amp; f)</statement></entry>
  	   <entry>Generalizes the <operator>?:</operator> operator,
! 	returning an &array; of <varname>t</varname> and
  	<varname>f</varname> values depending on whether
  	<varname>A</varname>'s values are true or false,
  	respectively.</entry>
*************** std::cout << A-B << std::endl;
*** 871,878 ****
      values.  Frequently, operating on a subset is useful.  In &pooma;,
      a subset of a container's values is called a view.  Combining
      views and data-parallel expressions will enable us to more
!     succinctly and more easily write the diffusion program.  Views are
!     discussed in the next chapter.</para>
     </section>
  
  
--- 868,875 ----
      values.  Frequently, operating on a subset is useful.  In &pooma;,
      a subset of a container's values is called a view.  Combining
      views and data-parallel expressions will enable us to more
!     succinctly and more easily write the &doof2d; diffusion program.
!     Views are discussed in the next chapter.</para>
     </section>
  
  
*************** std::cout << A-B << std::endl;
*** 885,915 ****
      these statements may create and destroy containers holding
      intermediate values, slowing execution considerably.
      In&nbsp;1995, Todd <!-- FIXME: Add citations to vandevoorde-95 and
!     veldhuizen-95. --> Veldhuizen and David Vandevoorde developed an
!     expression-template technique to transform arithmetic expressions
!     involving array-like containers into efficient loops without using
!     temporaries.  Despite its perceived complexity, &pooma;
!     incorporated the technology.  The framework called &pete, the
!     <application>Portable Expression Template Engine</application>
!     framework, is also available separately from &pooma; at
!     <ulink url="http://www.acl.lanl.gov/pete/"></ulink>.</para>
  
!     <para>In this section, we first describe how a &naive;
      implementation may slow execution.  Then, we describe &pete;'s
!     faster implementation.  A data-parallel statement is converted
      into a parse tree, rather than immediately evaluating it.  The
      parse tree has two representations.  Its run-time representation
      holds run-time values.  Its compile-time representation records
      the types of the tree's values.  After a parse tree for the entire
      statement is constructed, it is evaluated.  Since it is a
      data-parallel statement, this evaluation involves at least one
!     loop.  At run time, each loop iteration, the value of one
      container value is computed and assigned.  At compile time, when
      the code for the loop iteration is produced, the parse tree's
      types are traversed and code is produced without the need for any
      intermediate values.  We present the implementation in <xref
! 								 linkend="data_parallel-implementation-pete"></xref>, but first we
!     explain the difficulties caused by the &naive; implementation.</para>
  
      <section id="data_parallel-implementation-naive">
       <title>&naivecap; Implementation</title>
--- 882,913 ----
      these statements may create and destroy containers holding
      intermediate values, slowing execution considerably.
      In&nbsp;1995, Todd <!-- FIXME: Add citations to vandevoorde-95 and
!     veldhuizen-95. --> Veldhuizen and David Vandevoorde each developed
!     an expression-template technique to transform arithmetic
!     expressions involving array-like containers into efficient loops
!     without using temporaries.  Despite its perceived complexity,
!     &pooma; incorporated the technology.  The framework called &pete,
!     the <application>Portable Expression Template Engine</application>
!     framework, is also available separately from &pooma; at <ulink
!     url="http://www.acl.lanl.gov/pete/"></ulink>.</para>
  
!     <para>In this chapter, we first describe how a &naive;
      implementation may slow execution.  Then, we describe &pete;'s
!     faster implementation.  &pete; converts a data-parallel statement
      into a parse tree, rather than immediately evaluating it.  The
      parse tree has two representations.  Its run-time representation
      holds run-time values.  Its compile-time representation records
      the types of the tree's values.  After a parse tree for the entire
      statement is constructed, it is evaluated.  Since it is a
      data-parallel statement, this evaluation involves at least one
!     loop.  At run time, for each loop iteration, the value of one
      container value is computed and assigned.  At compile time, when
      the code for the loop iteration is produced, the parse tree's
      types are traversed and code is produced without the need for any
      intermediate values.  We present the implementation in <xref
!     linkend="data_parallel-implementation-pete"></xref>, but first we
!     explain the difficulties caused by the &naive;
!     implementation.</para>
  
      <section id="data_parallel-implementation-naive">
       <title>&naivecap; Implementation</title>
*************** Array<1, double, Brick> A(I), B(I);
*** 923,933 ****
  A = 1.0;
  B = 2.0;
  A += -A + 2*B;
! std::cout << A << std::endl;
  </programlisting> Our goal is to transform the data-parallel
       statement <statement>A += -A + 2*B</statement> into a single
!      loop, preferably without intermediary containers.  To simplify
!      notation, let <type>Ar</type> abbreviate the type
       <type>Array&lt;1, double, Brick&gt;</type>.</para>
       
       <para>Using overloaded arithmetic operators would require using
--- 921,931 ----
  A = 1.0;
  B = 2.0;
  A += -A + 2*B;
! std::cout &openopen; A &openopen; std::endl;
  </programlisting> Our goal is to transform the data-parallel
       statement <statement>A += -A + 2*B</statement> into a single
!      loop, preferably without using intermediary containers.  To
!      simplify notation, let <type>Ar</type> abbreviate the type
       <type>Array&lt;1, double, Brick&gt;</type>.</para>
       
       <para>Using overloaded arithmetic operators would require using
*************** std::cout << A << std::endl;
*** 952,967 ****
       Template Engine</application> framework, to evaluate
       data-parallel statements using efficient loops without
       intermediate values.  &pete; uses expression-template technology.
!      Instead of aggressively evaluating a data-parallel statement's
!      subexpressions, it defers evaluation, instead building a parse
!      tree of the required computations.  The parse tree's type records
!      the types of each of its subtrees.  Then, the parse tree is
!      evaluated using an evaluator determined by the left-hand side's
!      type.  This container type determines how to loop through its
!      domain.  Each loop iteration, the corresponding value of the
!      right-hand side is evaluated.  No intermediate loops or temporary
!      values are needed.</para>
  
       <figure float="1" id="data_parallel-implementation-pete-tree_figure">
        <title>Annotated Parse Tree for <statement>-A + 2*B</statement></title>
         <mediaobject>
--- 950,983 ----
       Template Engine</application> framework, to evaluate
       data-parallel statements using efficient loops without
       intermediate values.  &pete; uses expression-template technology.
!      Instead of evaluating a data-parallel statement's subexpressions
!      at solely at run time, it evaluates the code at both run time and
!      at compile time.  At compile time, it builds a parse tree of the
!      required computations.  The parse tree's type records the types
!      of each of its subtrees.  Then, the parse tree is evaluated at
!      compile time using an evaluator determined by the left-hand
!      side's type.  This container type determines how to loop through
!      its domain.  Each loop iteration of the resulting run time code,
!      the corresponding value of the right-hand side is evaluated.  No
!      intermediate loops or temporary values are needed.</para>
  
+      <para>Before explaining the implementation, let us illustrate
+      using our example statement <statement>A += -A + 2*B</statement>.
+      Evaluating the right-hand side creates a parse tree similar to
+      the one in <xref
+      linkend="data_parallel-implementation-pete-tree_figure"></xref>.
+      For example, the overloaded unary minus operator yields a tree
+      node representing <statement>-A</statement>, having a unary-minus
+      function object, and having type
+      <type>Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;</type>.
+      The binary nodes continue the construction process yielding a
+      parse tree object for the entire right-hand side and having type
+      <type>Expression&lt;BinaryNode&lt;OpAdd, UnaryNode&lt;OpMinus,
+      Ar&gt;,
+      BinaryNode&lt;OpMultiply&lt;Scalar&lt;int&gt;,Ar&closecloseclose;</type>.
+      Evaluating the left-hand side yields an object
+      representing&nbsp;<varname>A</varname>.</para>
+ 
       <figure float="1" id="data_parallel-implementation-pete-tree_figure">
        <title>Annotated Parse Tree for <statement>-A + 2*B</statement></title>
         <mediaobject>
*************** std::cout << A << std::endl;
*** 979,1025 ****
         </mediaobject>
        </figure>
  
-      <para>Before explaining the implementation, let us illustrate
-      using our example statement <statement>A += -A + 2*B</statement>.
-      Evaluating the right-hand side creates a parse tree similar to
-      the one in <xref
- 		      linkend="data_parallel-implementation-pete-tree_figure"></xref>.
-      For example, the overloaded unary minus operator yields a tree
-      node representing <statement>-A</statement>, having a unary-minus
-      function object, and having type
-      <type>Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;</type>.
-      The binary nodes continue the construction process yielding a
-      parse tree object for the entire right-hand side and having type
-      <type>Expression&lt;BinaryNode&lt;OpAdd, UnaryNode&lt;OpMinus,
-      Ar&gt;,
-      BinaryNode&lt;OpMultiply&lt;Scalar&lt;int&gt;,Ar&closecloseclose;</type>.
-      Evaluating the left-hand side yields an object
-      representing&nbsp;<varname>A</varname>.</para>
- 
       <para>Finally, the assignment operator <statement>+=</statement>
       calls the <function>evaluate</function> function corresponding to
       the left-hand side's type.  At compile time, it produces the code
       for the computation.  Since this templated function is
       specialized on the type of the left-hand side, it generates a
!      loop through the left-hand side's container.  In the loop body,
!      the <function>forEach</function> function produces code for the
!      right-hand side expression at a specific position using a
!      post-order parse-tree traversal.  At a leaf, this evaluation
!      queries the leaf's container for a specified value or extracts a
!      scalar value.  At an interior node, its children's results are
!      combined using its function operator.  One loop performs the
!      entire assignment.  It is important to note that the type of the
!      entire right-hand side is known at compile time.  Thus, all of
!      these <function>evaluate</function>,
       <function>forEach</function>, and function operator function
       calls can be inlined at compile time to yield simple code without
       any temporary containers and hopefully as fast as hand-written
       loops!</para>
  
!      <para>To implement this scheme, we need &pooma; code to both
!      create the parse tree and to evaluate it.  We describe parse tree
!      creation first.  Parse trees consist of leaves,
!      <type>UnaryNode</type>s, <type>BinaryNode</type>s, and
       <type>TrinaryNode</type>s.  Since <type>TrinaryNode</type>s are
       similar to <type>BinaryNode</type>s, we omit describing them.  A
       <type>BinaryNode</type>'s three template parameters correspond to
--- 995,1024 ----
         </mediaobject>
        </figure>
  
       <para>Finally, the assignment operator <statement>+=</statement>
       calls the <function>evaluate</function> function corresponding to
       the left-hand side's type.  At compile time, it produces the code
       for the computation.  Since this templated function is
       specialized on the type of the left-hand side, it generates a
!      loop iterating through the left-hand side's container.  To
!      produce the loop body, the <function>forEach</function> function
!      produces code for the right-hand side expression at a specific
!      position using a post-order parse-tree traversal.  At a leaf,
!      this evaluation queries the leaf's container for a specified
!      value or extracts a scalar value.  At an interior node, its
!      children's results are combined using its function operator.  One
!      loop performs the entire assignment.  It is important to note
!      that the type of the entire right-hand side is known at compile
!      time.  Thus, all of these <function>evaluate</function>,
       <function>forEach</function>, and function operator function
       calls can be inlined at compile time to yield simple code without
       any temporary containers and hopefully as fast as hand-written
       loops!</para>
  
!      <para>To implement this scheme, we need &pooma; (really &pete;)
!      code to both create the parse tree and to evaluate it.  We
!      describe parse tree creation first.  Parse trees consist of
!      leaves, <type>UnaryNode</type>s, <type>BinaryNode</type>s, and
       <type>TrinaryNode</type>s.  Since <type>TrinaryNode</type>s are
       similar to <type>BinaryNode</type>s, we omit describing them.  A
       <type>BinaryNode</type>'s three template parameters correspond to
*************** std::cout << A << std::endl;
*** 1050,1056 ****
  
       <para><type>BinaryNode</type> does not need to store any
      representation of the node's operation.  Instead the
!     <type>Op</type> type is an empty structure declaring a function
      object.  For example, <type>OpAdd</type>'s function object is
      declared as
  <programlisting>
--- 1049,1055 ----
  
       <para><type>BinaryNode</type> does not need to store any
      representation of the node's operation.  Instead the
!     <type>Op</type> type is an empty structure defining a function
      object.  For example, <type>OpAdd</type>'s function object is
      declared as
  <programlisting>
*************** struct CreateLeaf&lt;Array&lt;Dim, T, En
*** 1116,1127 ****
  
       <para>Now that we have defined the node classes, the &cc;
      arithmetic operators must be overloaded to return the appropriate
!     parse tree.  For example, unary minus operator
!     <function>operator-</function> overloaded to accept an &array;
!     argument should create a <type>UnaryNode</type> having an &array;
      as its child, which will be a leaf:
  <programlisting>
! 		 template&lt;int D1,class T1,class E1&gt;
  inline typename MakeReturn&lt;UnaryNode&lt;OpUnaryMinus,
    typename CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::Leaf_t&gt; &gt;::Expression_t
  operator-(const Array&lt;D1,T1,E1&gt; &amp; l)
--- 1115,1126 ----
  
       <para>Now that we have defined the node classes, the &cc;
      arithmetic operators must be overloaded to return the appropriate
!     parse tree.  For example, the unary minus operator
!     <function>operator-</function> is overloaded to accept an &array;
!     argument.  It should create a <type>UnaryNode</type> having an &array;
      as its child, which will be a leaf:
  <programlisting>
! template&lt;int D1,class T1,class E1&gt;
  inline typename MakeReturn&lt;UnaryNode&lt;OpUnaryMinus,
    typename CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::Leaf_t&gt; &gt;::Expression_t
  operator-(const Array&lt;D1,T1,E1&gt; &amp; l)
*************** operator-(const Array&lt;D1,T1,E1&gt; &a
*** 1144,1183 ****
      type from <type>Expression</type>'s internal
      <type>Expression_t</type> type.</para>
  
!      <para>Specialized all the operators for &array;s using such
!     complicated is likely to be error-prone so &pete; provides a way
!     to automate it.  Using its <command>MakeOperators</command>
! 								command with this input:
  <programlisting>
! 		 classes
  -----
    ARG   = "int D[n],class T[n],class E[n]"
    CLASS = "Array&lt;D[n],T[n],E[n]&gt;"
  </programlisting> automatically generates code for all the needed operators.
      The <quote>[n]</quote> strings are used to number arguments for binary
      and ternary operators.</para>
  
!      <para>Assignment operators must also be specialized for &array;.
      Inside the &array; class definition, each such operator just
!     invokes the <function>assign</function> function with a corresponding
! 					    function object.  For example, <function>operator+=</function>
! 													   invokes <statement>assign(*this, rhs, OpAddAssign())</statement>.
!     <varname>rhs</varname> is the parse tree object for the right-hand
!     side.  Calling this function invokes
!     <function>evaluate</function>, which begins the evaluation.</para>
  
!      <para>Before we explain the evaluation, let us summarize the
      effect of the code so far described.  If we are considering run
!     time, parse trees for the left-hand and right-hand sides have been
!     constructed.  If we are considering compile time, the types of
!     these parse trees are known.  At compile time, the
!     <function>evaluate</function> function described below will
!     generate a loop through the left-hand side container's domain.
!     The loop's body will have code computing a container's value.  At
!     run time, this code will read values from containers, but the
!     run-time parse tree object itself will not traversed!</para>
  
!      <para>We now explore the evaluation, concentrating on compile
      time, not run time.  <function>evaluate</function> is an
      overloaded function specialized on the type of the left-hand side.
      In our example, the left-hand side is a one-dimensional &array;,
--- 1143,1185 ----
      type from <type>Expression</type>'s internal
      <type>Expression_t</type> type.</para>
  
!     <para>Specializing all the operators for &array;s using such
!     complicated functions is likely to be error-prone so &pete;
!     provides a way to automate their creation.  Using its
!     <command>MakeOperators</command> command with this input:
  <programlisting>
! classes
  -----
    ARG   = "int D[n],class T[n],class E[n]"
    CLASS = "Array&lt;D[n],T[n],E[n]&gt;"
  </programlisting> automatically generates code for all the needed operators.
      The <quote>[n]</quote> strings are used to number arguments for binary
      and ternary operators.</para>
+ 
  
!     <para>Assignment operators must also be specialized for &array;.
      Inside the &array; class definition, each such operator just
!     invokes the <function>assign</function> function with a
!     corresponding function object.  For example,
!     <function>operator+=</function> invokes <statement>assign(*this,
!     rhs, OpAddAssign())</statement>.  <varname>rhs</varname> is the
!     parse tree object for the right-hand side.  Calling this function
!     invokes <function>evaluate</function>, which begins the
!     evaluation.</para>
  
!     <para>Before we explain the evaluation, let us summarize the
      effect of the code so far described.  If we are considering run
!     time evaluation, parse trees for the left-hand and right-hand
!     sides have been constructed.  If we are considering compile time
!     evaluation, the types of these parse trees are known.  At compile
!     time, the <function>evaluate</function> function described below
!     will generate a loop iterating through the left-hand side
!     container's domain.  The loop's body will have code computing a
!     container's value.  At run time, this code will read values from
!     containers, but the run-time parse tree object itself will not
!     traversed!</para>
  
!     <para>We now explore the evaluation, concentrating on compile
      time, not run time.  <function>evaluate</function> is an
      overloaded function specialized on the type of the left-hand side.
      In our example, the left-hand side is a one-dimensional &array;,
*************** forEach(const Expression&amp; e, const L
*** 1205,1211 ****
      nodes, it combines the results using the <type>CombineTag</type>
      operator&nbsp;<varname>c</varname>.  It inlines into a call to
  <programlisting>
!     ForEach&lt;Expression, LeafTag, CombineTag&gt;::apply(e, f, c).
  </programlisting>  The <function>apply</function> function continues
      the traversal through the tree.  For our example,
      <type>LeafTag</type> equals <type>EvalLeaf&lt;1&gt;</type>, and
--- 1207,1213 ----
      nodes, it combines the results using the <type>CombineTag</type>
      operator&nbsp;<varname>c</varname>.  It inlines into a call to
  <programlisting>
! ForEach&lt;Expression, LeafTag, CombineTag&gt;::apply(e, f, c).
  </programlisting>  The <function>apply</function> function continues
      the traversal through the tree.  For our example,
      <type>LeafTag</type> equals <type>EvalLeaf&lt;1&gt;</type>, and
*************** for (int i = A.domain[0].first(); i < en
*** 1282,1292 ****
      code.</para>
  
      <para>&pete;'s expression template technology may be complicated,
!     using parse trees and their types, but the code they produce is
!     not.  Using the technology is also easy.  All data-parallel
!     statements are automatically converted.  In the next chapter, we
!     explore views of containers, permitting use of container subsets
!     and making data-parallel expressions even more useful.</para>
      </section>
  
     </section>
--- 1284,1294 ----
      code.</para>
  
      <para>&pete;'s expression template technology may be complicated,
!     using parse trees and their types, but the produced code is not.
!     Using the technology is also easy.  All data-parallel statements
!     are automatically converted.  In the next chapter, we explore
!     views of containers, permitting use of container subsets and
!     making data-parallel expressions even more useful.</para>
      </section>
  
     </section>
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.8
diff -c -p -r1.8 glossary.xml
*** glossary.xml	2002/01/24 05:11:21	1.8
--- glossary.xml	2002/01/25 02:15:05
***************
*** 11,19 ****
--- 11,21 ----
    should finish a sentence.  The rest of the definition should
    consist of complete sentences.  -->
  
+ <![%unfinished;[
   <para>ADD: Make sure all entries are indexed and perhaps point back
   to their first use.  WARNING: This is constructed by hand so it is
   likely to be full of inconsistencies and errors.</para>
+ ]]>  <!-- end unfinished -->
  
   <glossdiv id="glossary-a">
    <title>A</title>
***************
*** 29,42 ****
    <glossentry id="glossary-array">
     <glossterm>&array;</glossterm>
     <glossdef>
!     <para>a &pooma; container generalizing &c; arrays and mapping
!     indices to values.  Constant-time access to values is supported,
!     ignoring the time to compute the values if applicable.  &array;s
!     are <link linkend="glossary-first_class">first-class
!     object</link>s.  <link
      linkend="glossary-dynamicarray">&dynamicarray;</link>s and <link
      linkend="glossary-field">&field;</link>s generalize
      &array;.</para>
      <glossseealso otherterm="glossary-dynamicarray">&dynamicarray;</glossseealso>
      <glossseealso otherterm="glossary-field">&field;</glossseealso>
     </glossdef>
--- 31,46 ----
    <glossentry id="glossary-array">
     <glossterm>&array;</glossterm>
     <glossdef>
!     <para>a &pooma; <link
!     linkend="glossary-container">container</link> generalizing &c;
!     arrays and mapping indices to values.  Constant-time access to
!     values is supported, ignoring the time to compute the values if
!     applicable.  &array;s are <link
!     linkend="glossary-first_class">first-class object</link>s.  <link
      linkend="glossary-dynamicarray">&dynamicarray;</link>s and <link
      linkend="glossary-field">&field;</link>s generalize
      &array;.</para>
+     <glossseealso otherterm="glossary-container">container</glossseealso>
      <glossseealso otherterm="glossary-dynamicarray">&dynamicarray;</glossseealso>
      <glossseealso otherterm="glossary-field">&field;</glossseealso>
     </glossdef>
***************
*** 63,82 ****
     <glossdef>
      <para>a <link linkend="glossary-domain">domain</link> element of
      a <link linkend="glossary-field">&field;</link>.  Both <link
! 								  linkend="glossary-array">&array;</link> and &field; domain
      elements are denoted by indices, but a cell exists in space.  For
      example, it might be a rectangle or rectangular
      parallelepiped.</para>
      <glossseealso otherterm="glossary-field">&field;</glossseealso>
     </glossdef>
    </glossentry>
  
    <glossentry id="glossary-cell_size">
     <glossterm>cell size</glossterm>
     <glossdef>
!     <para>specifies a &field; cell's dimensions e.g., its
      width, height, and depth, in&nbsp;&space;.  This is frequently
      used to specify a mesh.</para>
      <glossseealso otherterm="glossary-mesh">mesh</glossseealso>
      <glossseealso otherterm="glossary-corner_position">corner position</glossseealso>
     </glossdef>
--- 67,90 ----
     <glossdef>
      <para>a <link linkend="glossary-domain">domain</link> element of
      a <link linkend="glossary-field">&field;</link>.  Both <link
!     linkend="glossary-array">&array;</link> and &field; domain
      elements are denoted by indices, but a cell exists in space.  For
      example, it might be a rectangle or rectangular
      parallelepiped.</para>
+     <glossseealso otherterm="glossary-cell_size">cell size</glossseealso>
      <glossseealso otherterm="glossary-field">&field;</glossseealso>
+     <glossseealso otherterm="glossary-mesh">mesh</glossseealso>
     </glossdef>
    </glossentry>
  
    <glossentry id="glossary-cell_size">
     <glossterm>cell size</glossterm>
     <glossdef>
!     <para>specifies a <link linkend="glossary-field">&field;</link>
!     <link linkend="glossary-cell">cell</link>'s dimensions e.g., its
      width, height, and depth, in&nbsp;&space;.  This is frequently
      used to specify a mesh.</para>
+     <glossseealso otherterm="glossary-cell">cell</glossseealso>
      <glossseealso otherterm="glossary-mesh">mesh</glossseealso>
      <glossseealso otherterm="glossary-corner_position">corner position</glossseealso>
     </glossdef>
***************
*** 85,99 ****
    <glossentry id="glossary-communication_library">
     <glossterm>communication library</glossterm>
     <glossdef>
!     <para>software library passing information among contexts, usually
!     using messages.</para>
!     <glossseealso otherterm="glossary-distributed">distributed computing environment</glossseealso>
     </glossdef>
    </glossentry>
  
    <glossentry id="glossary-compilation_time">
     <glossterm>compilation time</glossterm>
!    <glosssee otherterm="glossary-compilation_time"></glosssee>
    </glossentry>
  
    <glossentry id="glossary-compile_time">
--- 93,109 ----
    <glossentry id="glossary-communication_library">
     <glossterm>communication library</glossterm>
     <glossdef>
!     <para>software library passing information among <glossterm
!     linkend="glossary-context">contexts</glossterm>, usually using
!     messages.</para> <glossseealso
!     otherterm="glossary-distributed">distributed computing
!     environment</glossseealso>
     </glossdef>
    </glossentry>
  
    <glossentry id="glossary-compilation_time">
     <glossterm>compilation time</glossterm>
!    <glosssee otherterm="glossary-compile_time"></glosssee>
    </glossentry>
  
    <glossentry id="glossary-compile_time">
***************
*** 141,147 ****
      <para>domains with the <quote>same shape</quote> so that
      corresponding dimensions have the same number of elements.
      Scalars, deemed conformable with any domain, get
!     <quote>expanded</quote> to the domain's shape.  Binary operators
      can operate on containers with conformable domains.</para>
      <glossseealso otherterm="glossary-conformable_containers">conformable containers</glossseealso>
      <glossseealso otherterm="glossary-data_parallel">data parallel</glossseealso>
--- 151,157 ----
      <para>domains with the <quote>same shape</quote> so that
      corresponding dimensions have the same number of elements.
      Scalars, deemed conformable with any domain, get
!     <quote>expanded</quote> to the domain's shape.  Assignment
      can operate on containers with conformable domains.</para>
      <glossseealso otherterm="glossary-conformable_containers">conformable containers</glossseealso>
      <glossseealso otherterm="glossary-data_parallel">data parallel</glossseealso>
***************
*** 178,184 ****
     <glossterm>context</glossterm>
     <glossdef>
      <para>a collection of shared memory and processors that can execute
!      a program of a portion of a program.  It can have one or more
       processors, but all these processors must access the same shared
       memory.  Usually the computer and its operating system, not the
       programmer, determine the available contexts.</para>
--- 188,194 ----
     <glossterm>context</glossterm>
     <glossdef>
      <para>a collection of shared memory and processors that can execute
!      a program or a portion of a program.  It can have one or more
       processors, but all these processors must access the same shared
       memory.  Usually the computer and its operating system, not the
       programmer, determine the available contexts.</para>
***************
*** 193,198 ****
--- 203,209 ----
      <para>indicates how a container's patches are mapped to
      processors and shared memory.  Two common choices are
      distribution among the various processors and replication.</para>
+     <glossseealso otherterm="glossary-context">context</glossseealso>
      <glossseealso otherterm="glossary-patch">patch</glossseealso>
     </glossdef>
    </glossentry>
***************
*** 214,221 ****
    <glossentry id="glossary-data_parallel">
     <glossterm>data parallel</glossterm>
     <glossdef>
!     <para>describes an expression representing a subset of a
!     container's values.  For example,
      <statement>sin(&container;)</statement> is an expression
      indicating that the <function>sin</function> is applied to each
      value in container&nbsp;&container;.</para>
--- 225,232 ----
    <glossentry id="glossary-data_parallel">
     <glossterm>data parallel</glossterm>
     <glossdef>
!     <para>describes an expression involving a (non-singleton) subset
!     of a container's values.  For example,
      <statement>sin(&container;)</statement> is an expression
      indicating that the <function>sin</function> is applied to each
      value in container&nbsp;&container;.</para>
***************
*** 258,264 ****
      2stride, &hellip;, end}.  <varname>end</varname> is in the set
      only if it equals <varname>begin</varname> plus some integral
      multiple of <varname>stride</varname>.  This notation can
!     abbreviate most domains.  It is extended to multiple dimensions by
      separating the dimensions' sets with commas:
      [<varname>begin0</varname>:<varname>end0</varname>:<varname>stride0</varname>,<varname>begin1</varname>:<varname>end1</varname>:<varname>stride1</varname>].</para>
      <glossseealso otherterm="glossary-domain">domain</glossseealso>
--- 269,275 ----
      2stride, &hellip;, end}.  <varname>end</varname> is in the set
      only if it equals <varname>begin</varname> plus some integral
      multiple of <varname>stride</varname>.  This notation can
!     abbreviate many domains.  It is extended to multiple dimensions by
      separating the dimensions' sets with commas:
      [<varname>begin0</varname>:<varname>end0</varname>:<varname>stride0</varname>,<varname>begin1</varname>:<varname>end1</varname>:<varname>stride1</varname>].</para>
      <glossseealso otherterm="glossary-domain">domain</glossseealso>
***************
*** 268,279 ****
    <glossentry id="glossary-dynamicarray">
     <glossterm>&dynamicarray;</glossterm>
     <glossdef>
!     <para>a &pooma; container generalizing one-dimensional <link
!     linkend="glossary-array">&array;</link>s by supporting domain
!     resizing at run-time.  It maps indices to values in constant-time
!     access, ignoring the time to compute the values if applicable.
!     &dynamicarray;s are <link
      linkend="glossary-first_class">first-class object</link>s.</para>
      <glossseealso otherterm="glossary-array">&array;</glossseealso>
      <glossseealso otherterm="glossary-field">&field;</glossseealso>
     </glossdef>
--- 279,292 ----
    <glossentry id="glossary-dynamicarray">
     <glossterm>&dynamicarray;</glossterm>
     <glossdef>
!     <para>a &pooma; <link
!     linkend="glossary-container">container</link> generalizing
!     one-dimensional <link linkend="glossary-array">&array;</link>s by
!     supporting domain resizing at run-time.  It maps indices to values
!     in constant time, ignoring the time to compute the values if
!     applicable.  &dynamicarray;s are <link
      linkend="glossary-first_class">first-class object</link>s.</para>
+     <glossseealso otherterm="glossary-container">container</glossseealso>
      <glossseealso otherterm="glossary-array">&array;</glossseealso>
      <glossseealso otherterm="glossary-field">&field;</glossseealso>
     </glossdef>
***************
*** 292,298 ****
     <glossterm>element wise</glossterm>
     <glossdef>
      <para>describes accesses to individual values within a container.
!     For example, <statement>&container(i,j)</statement> represents one
      particular value in the container&nbsp;&container;.</para>
      <glossseealso otherterm="glossary-data_parallel">data parallel</glossseealso>
      <glossseealso otherterm="glossary-relation">relation</glossseealso>
--- 305,311 ----
     <glossterm>element wise</glossterm>
     <glossdef>
      <para>describes accesses to individual values within a container.
!     For example, <statement>&container(-4,3)</statement> represents one
      particular value in the container&nbsp;&container;.</para>
      <glossseealso otherterm="glossary-data_parallel">data parallel</glossseealso>
      <glossseealso otherterm="glossary-relation">relation</glossseealso>
***************
*** 303,314 ****
    <glossentry id="glossary-engine">
     <glossterm>engine</glossterm>
     <glossdef>
!     <para>stores and, if necessary, computes a <link
      linkend="glossary-container">container</link>'s values.  These can
      be specialized, e.g., to minimize storage when a domain has few
      distinct values.  Separating a container and its storage also
      permits <link linkend="glossary-view">views</link> of a
      container.</para>
      <glossseealso otherterm="glossary-container">&engine;</glossseealso>
      <glossseealso otherterm="glossary-view">view of a container</glossseealso>
     </glossdef>
--- 316,328 ----
    <glossentry id="glossary-engine">
     <glossterm>engine</glossterm>
     <glossdef>
!     <para>stores or computes a <link
      linkend="glossary-container">container</link>'s values.  These can
      be specialized, e.g., to minimize storage when a domain has few
      distinct values.  Separating a container and its storage also
      permits <link linkend="glossary-view">views</link> of a
      container.</para>
+     <glossseealso otherterm="glossary-brick">&brick; &engine;</glossseealso>
      <glossseealso otherterm="glossary-container">&engine;</glossseealso>
      <glossseealso otherterm="glossary-view">view of a container</glossseealso>
     </glossdef>
***************
*** 362,375 ****
    <glossentry id="glossary-field">
     <glossterm>&field;</glossterm>
     <glossdef>
!     <para>a &pooma; container representing an &array; with spatial
!     extent.  It also supports multiple values and multiple materials
!     indexed by the same value.  It maps indices to values in constant
!     time, ignoring the time to compute the values if applicable.  It
!     also supports geometric computations such as the distance between
!     two <link linkend="glossary-cell">cell</link>s and normals to a
!     cell.  &field;s are <link
!     linkend="glossary-first_class">first-class object</link>s.</para>
      <glossseealso otherterm="glossary-array">&array;</glossseealso>
      <glossseealso otherterm="glossary-dynamicarray">&dynamicarray;</glossseealso>
     </glossdef>
--- 376,394 ----
    <glossentry id="glossary-field">
     <glossterm>&field;</glossterm>
     <glossdef>
!     <para>a &pooma; <link
!     linkend="glossary-container">container</link> representing an
!     &array; with spatial extent.  It also supports multiple values and
!     multiple materials having the same index.  It maps indices to
!     values in constant time, ignoring the time to compute the values
!     if applicable.  It also supports geometric computations such as
!     the distance between two <link
!     linkend="glossary-cell">cell</link>s and normals to a cell.
!     &field;s are <link linkend="glossary-first_class">first-class
!     object</link>s.</para>
!     <glossseealso otherterm="glossary-container">container</glossseealso>
!     <glossseealso otherterm="glossary-cell">cell</glossseealso>
!     <glossseealso otherterm="glossary-mesh">mesh</glossseealso>
      <glossseealso otherterm="glossary-array">&array;</glossseealso>
      <glossseealso otherterm="glossary-dynamicarray">&dynamicarray;</glossseealso>
     </glossdef>
***************
*** 379,385 ****
     <glossterm>first-class type</glossterm>
     <glossdef>
      <para>a type of object with all the capabilities of the built-in
!     type with the most capabilities.  For example, <type>char</type>
      and <type>int</type> are first-class types in &cc; because they
      may be declared anywhere, stored in automatic variables, accessed
      anywhere, copied, and passed by both value and reference.
--- 398,404 ----
     <glossterm>first-class type</glossterm>
     <glossdef>
      <para>a type of object with all the capabilities of the built-in
!     type having the most capabilities.  For example, <type>char</type>
      and <type>int</type> are first-class types in &cc; because they
      may be declared anywhere, stored in automatic variables, accessed
      anywhere, copied, and passed by both value and reference.
*************** guard layer</glossseealso>
*** 477,483 ****
  
    <glossentry id="glossary-instantiation">
     <glossterm>instantiation</glossterm>
!    <glosssee>template instantiation</glosssee>
    </glossentry>
  
    <glossentry id="glossary-indices">
--- 496,502 ----
  
    <glossentry id="glossary-instantiation">
     <glossterm>instantiation</glossterm>
!    <glosssee otherterm="glossary-template_instantiation">template instantiation</glosssee>
    </glossentry>
  
    <glossentry id="glossary-indices">
*************** guard layer</glossseealso>
*** 559,567 ****
     <glossterm>mesh</glossterm>
     <glossdef>
      <para>a &field;'s map from indices to geometric values such as
!     cell size, edge length, and cell normals.  In other words, it
      specifies a &field;'s <quote>spatial extent</quote>.</para>
      <glossseealso otherterm="glossary-field">&field;</glossseealso>
      <glossseealso otherterm="glossary-layout">layout</glossseealso>
     </glossdef>
    </glossentry>
--- 578,589 ----
     <glossterm>mesh</glossterm>
     <glossdef>
      <para>a &field;'s map from indices to geometric values such as
!     <link linkend="glossary-cell_size">cell size</link>, edge length, and cell normals.  In other words, it
      specifies a &field;'s <quote>spatial extent</quote>.</para>
      <glossseealso otherterm="glossary-field">&field;</glossseealso>
+     <glossseealso otherterm="glossary-cell">cell</glossseealso>
+     <glossseealso otherterm="glossary-cell_size">cell size</glossseealso>
+     <glossseealso otherterm="glossary-corner_position">corner position</glossseealso>
      <glossseealso otherterm="glossary-layout">layout</glossseealso>
     </glossdef>
    </glossentry>
*************** guard layer</glossseealso>
*** 657,663 ****
      linkend="glossary-range">domain triplets</link> [b:e:s], can also
      be represented mathematically as an integral interval [b,e] with
      stride&nbsp;s, i.e., {a, a+s, a+2s, &hellip;, b}.  It is
!     generalized to &n;-dimensional range as the direct product of
      one-dimensional ranges.</para>
      <glossseealso otherterm="glossary-stride">stride</glossseealso>
      <glossseealso otherterm="glossary-interval">interval</glossseealso>
--- 679,685 ----
      linkend="glossary-range">domain triplets</link> [b:e:s], can also
      be represented mathematically as an integral interval [b,e] with
      stride&nbsp;s, i.e., {a, a+s, a+2s, &hellip;, b}.  It is
!     generalized to an &n;-dimensional range as the direct product of
      one-dimensional ranges.</para>
      <glossseealso otherterm="glossary-stride">stride</glossseealso>
      <glossseealso otherterm="glossary-interval">interval</glossseealso>
*************** guard layer</glossseealso>
*** 665,670 ****
--- 687,702 ----
     </glossdef>
    </glossentry>
  
+   <glossentry id="glossary-reference_semantics">
+    <glossterm>reference semantics</glossterm>
+    <glossdef>
+     <para>a copy of an object&nbsp;<varname>o</varname> refers to the
+     object&nbsp;<varname>o</varname> such that changing either one
+     also changes the other.  This is the opposite of value
+     semantics.</para>
+    </glossdef>
+   </glossentry>
+ 
    <glossentry id="glossary-relation">
     <glossterm>relation</glossterm>
     <glossdef>
*************** guard layer</glossseealso>
*** 717,728 ****
    <glossentry id="glossary-stencil">
     <glossterm>stencil</glossterm>
     <glossdef>
!     <para>set of values neighboring a container value and a function
      using those values to compute it.  For example, the stencil in a
!     two-dimensional Conway game of life consists of a value's eight
!     neighbors and a function that sets the value to
!     <quote>live</quote> if it is already live or it has exactly three
!     live neighbors.</para>
      <glossseealso otherterm="glossary-data_parallel">data parallel</glossseealso>
      <glossseealso otherterm="glossary-element_wise">element wise</glossseealso>
      <glossseealso otherterm="glossary-relation">relation</glossseealso>
--- 749,760 ----
    <glossentry id="glossary-stencil">
     <glossterm>stencil</glossterm>
     <glossdef>
!     <para>set of values neighboring a container index and a function
      using those values to compute it.  For example, the stencil in a
!     two-dimensional Conway game of life consists of an index's eight
!     neighbors and a function that sets its value to
!     <quote>live</quote> if it is already live and it has two neighbors
!     or it has exactly three live neighbors.</para>
      <glossseealso otherterm="glossary-data_parallel">data parallel</glossseealso>
      <glossseealso otherterm="glossary-element_wise">element wise</glossseealso>
      <glossseealso otherterm="glossary-relation">relation</glossseealso>
*************** guard layer</glossseealso>
*** 768,775 ****
      </indexterm>
      class or function definition having template parameters.
      These parameters' values are used at compile time, not run time,
!     so they may include types and other compile-time values.
!     <!-- FIXME: Strengthen this definition. --></para>
      <glossseealso otherterm="glossary-template_instantiation">template instantiation</glossseealso>
      <glossseealso otherterm="glossary-template_specialization">template specialization</glossseealso>
     </glossdef>
--- 800,806 ----
      </indexterm>
      class or function definition having template parameters.
      These parameters' values are used at compile time, not run time,
!     so they may include types and other compile-time values.</para>
      <glossseealso otherterm="glossary-template_instantiation">template instantiation</glossseealso>
      <glossseealso otherterm="glossary-template_specialization">template specialization</glossseealso>
     </glossdef>
*************** guard layer</glossseealso>
*** 788,793 ****
--- 819,825 ----
      foo</statement> with the type &double; and the constant
      integer&nbsp;3.  Template instantiation is analogous to applying a
      function to function arguments.</para>
+     <glossseealso otherterm="glossary-template">template</glossseealso>
     </glossdef>
    </glossentry>
  
*************** guard layer</glossseealso>
*** 800,805 ****
--- 832,838 ----
      </indexterm>
      class or function definition for a particular (special)
      subset of template arguments.</para>
+     <glossseealso otherterm="glossary-template">template</glossseealso>
     </glossdef>
    </glossentry>
  
*************** guard layer</glossseealso>
*** 843,849 ****
       <primary>traits class</primary>
      </indexterm>
      a class containing one or more traits all describing a particular
!     type's chacteristics.</para>
      <glossseealso otherterm="glossary-trait">trait</glossseealso>
     </glossdef>
    </glossentry>
--- 876,882 ----
       <primary>traits class</primary>
      </indexterm>
      a class containing one or more traits all describing a particular
!     type's characteristics.</para>
      <glossseealso otherterm="glossary-trait">trait</glossseealso>
     </glossdef>
    </glossentry>
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.9
diff -c -p -r1.9 manual.xml
*** manual.xml	2002/01/24 05:11:21	1.9
--- manual.xml	2002/01/25 02:15:08
***************
*** 150,155 ****
--- 150,157 ----
    <!-- The "Range" domain type. -->
  <!ENTITY rangeone "<type>Range&lt;1&gt;</type>">
    <!-- The "Range<1>" one-dimensional domain type. -->
+ <!ENTITY remote "<type>Remote</type>">
+   <!-- The "Remote" engine type. -->
  <!ENTITY replicatedtag "<type>ReplicatedTag</type>">
    <!-- The ReplicatedTag Layout type. -->
  <!ENTITY stencil "<type>Stencil</type>">
***************
*** 390,417 ****
     <para>We begin this chapter by introducing the concept of an engine
     and how it is used.  Then, we describe the various &engine;s that
     &pooma; provides, separating them into engines that store values
!    and engines that compute values.  Finally, we describe how the
     &engine;s are implemented, using tags to differentiate engines and
!    reference-counted pointers to their underlying data.</para>
  
  
     <section id="engines-concept">
      <title>The Concept</title>
  
      <para>An engine performs the low-level value storage, computation,
!     and element-wise access for a container.  The &pooma; &engine;
!     class and its specializations implement the concept.  An engine
!     has a domain and accessor functions returning individual elements.
!     Given an index within the domain, an engine's
      <methodname>operator()</methodname> function returns the
      associated value, which can be used or changed.  Its
!     <methodname>read</methodname> returns the same value for only use,
!     not modification.  The acceptable indices are determined by each
!     &engine;.  Most accept indices specified using &int; and
!     <type>Loc&lt;&dim;&gt;</type> parameters, but an &engine; might
!     accept string or floating-point parameters.  An &engine;'s layout
!     specifies maps its domain indices to the processors and memory
!     used to store and compute the associated values.</para>
  
      <para>Since an engine's main role is to return the individual
      values associated with specific domain indices, any implementation
--- 392,424 ----
     <para>We begin this chapter by introducing the concept of an engine
     and how it is used.  Then, we describe the various &engine;s that
     &pooma; provides, separating them into engines that store values
!    and engines that compute values.
! <![%unfinished;[
!    Finally, we describe how the
     &engine;s are implemented, using tags to differentiate engines and
!    reference-counted pointers to their underlying data.
! ]]>  <!-- end unfinished -->
!    </para>
  
  
     <section id="engines-concept">
      <title>The Concept</title>
  
      <para>An engine performs the low-level value storage, computation,
!     and element-wise access for a container.  An engine has a domain
!     and accessor functions returning individual elements.  The &pooma;
!     &engine; class and its specializations implement the engine
!     concept.  Given an index within the domain, an &engine;'s
      <methodname>operator()</methodname> function returns the
      associated value, which can be used or changed.  Its
!     <methodname>read</methodname> member function returns the same
!     value but permitting only use, not modification.  The acceptable
!     indices are determined by each &engine;.  Most accept indices
!     specified using &int; and <type>Loc&lt;&dim;&gt;</type>
!     parameters, but an &engine; might accept string or floating-point
!     parameters.  An &engine;'s layout specifies maps its domain
!     indices to the processors and memory used to store and compute the
!     associated values.</para>
  
      <para>Since an engine's main role is to return the individual
      values associated with specific domain indices, any implementation
***************
*** 437,477 ****
      object</glossterm> to each value returned by another &engine;.  A
      <type>CompFwd</type> &engine; projects components from another
      &engine;.  For example, <type>CompFwd</type> will use the second
!     components of each vector in an &array; to form its own &array;.
!     Since each container has one or more &engine;s, we can also
      describe the latter category as containers that compute their
      values using other containers' values.  A &multipatch; &engine;
      distributes its domain among various processors and memory spaces,
      each responsible for computing values associated with a portion,
!     or patch, of the domain.</para>
  
      <para>Just as multiple containers can use the same engine,
      multiple &engine;s can use the same underlying data.  As we
      mentioned in <xref linkend="arrays-arrays_use"></xref>, &engine;s
!     have reference semantics.  So a copy of an &engine; has a
!     reference-counted pointer to an &engine;'s data (if any exists).
      Thus, copying an &engine; or a container requires little execution
      time.  If an &engine; has the same data as another &engine; but it
      needs its own data to modify, the
!     <methodname>makeOwnCopy</methodname> creates such a copy.</para>
  
      <para>&engine;s are rarely explicitly declared.  Instead a
!     container is declared using an &engine; tag, and the container,
      creates the specified &engine; to deal with its values.  For
      example, a &brick; &engine; is explicitly declared as
      <type>Engine&lt;&dim;,T,Brick&gt;</type>, but they are more
      frequently created by containers, e.g.,
!     <type>Array&lt;&dim;,T,Brick&gt;</type>.  The first two template
!     parameters specify the domain's dimensionality and the value type,
!     as described in <xref
      linkend="arrays-arrays_declarations"></xref>.  Unlike container
      declarations, the third template parameter, the &engine; tag,
      specifies which &engine; specialization to use.  For example, the
!     &brick; engine tag indicates a brick &engine; should be used.
      Some &engine;s, such as <type>CompFwd</type>, are rarely declared
      even using &engine; tags.  Instead the &array;'s
      <methodname>comp</methodname> and
!     <methodname>readComp</methodname> methods return views of
      containers using <type>CompFwd</type> &engine;s.</para>
     </section>
  
--- 444,487 ----
      object</glossterm> to each value returned by another &engine;.  A
      <type>CompFwd</type> &engine; projects components from another
      &engine;.  For example, <type>CompFwd</type> will use the second
!     components of each &vector; in an &array; to form its own &array;.
!     Since each container has at least one &engine;, we can also
      describe the latter category as containers that compute their
      values using other containers' values.  A &multipatch; &engine;
      distributes its domain among various processors and memory spaces,
      each responsible for computing values associated with a portion,
!     or patch, of the domain.  The &remote; &engine; also supports
!     distributed computation.</para>
  
      <para>Just as multiple containers can use the same engine,
      multiple &engine;s can use the same underlying data.  As we
      mentioned in <xref linkend="arrays-arrays_use"></xref>, &engine;s
!     have <glossterm linkend="glossary-reference_semantics">reference
!     semantics</glossterm>.  A copy of an &engine; has a
!     reference-counted pointer to the &engine;'s data (if any exists).
      Thus, copying an &engine; or a container requires little execution
      time.  If an &engine; has the same data as another &engine; but it
      needs its own data to modify, the
!     <methodname>makeOwnCopy</methodname> member function creates such
!     a copy.</para>
  
      <para>&engine;s are rarely explicitly declared.  Instead a
!     container is declared using an &engine; tag, and the container
      creates the specified &engine; to deal with its values.  For
      example, a &brick; &engine; is explicitly declared as
      <type>Engine&lt;&dim;,T,Brick&gt;</type>, but they are more
      frequently created by containers, e.g.,
!     <type>Array&lt;&dim;,T,Brick&gt;</type>.  An &engine;'s first two
!     template parameters specify the domain's dimensionality and the
!     value type, as described in <xref
      linkend="arrays-arrays_declarations"></xref>.  Unlike container
      declarations, the third template parameter, the &engine; tag,
      specifies which &engine; specialization to use.  For example, the
!     &brick; &engine; tag indicates a &brick; &engine; should be used.
      Some &engine;s, such as <type>CompFwd</type>, are rarely declared
      even using &engine; tags.  Instead the &array;'s
      <methodname>comp</methodname> and
!     <methodname>readComp</methodname> member functions return views of
      containers using <type>CompFwd</type> &engine;s.</para>
     </section>
  
***************
*** 482,501 ****
      <para>In this section, we describe the different types of
      &engine;s and illustrate their creation, when appropriate.  First,
      we describe &engine;s that explicitly store values and then
!     &engine;s that compute values.</para>
  
!      <table frame="none" colsep="0" rowsep="0" tocentry="1"
! 	    orient="port" pgwide="0" id="engines-types-table">
!       <title>Types of &engine;s</title>
       
!       <tgroup cols="2" align="left">
         <thead>
  	<row>
  	 <entry>&engine; tag</entry>
  	 <entry>description</entry>
  	</row>
         </thead>
!        <tbody>
  	<row rowsep="1">
  	 <entry>&engine;s That Store</entry>
  	</row>
--- 492,512 ----
      <para>In this section, we describe the different types of
      &engine;s and illustrate their creation, when appropriate.  First,
      we describe &engine;s that explicitly store values and then
!     &engine;s that compute values.  See <xref
!     linkend="engines-types-table"></xref>.</para>
  
!     <table frame="none" colsep="0" rowsep="0" tocentry="1"
!            orient="port" pgwide="0" id="engines-types-table">
!      <title>Types of &engine;s</title>
       
!      <tgroup cols="2" align="left">
         <thead>
  	<row>
  	 <entry>&engine; tag</entry>
  	 <entry>description</entry>
  	</row>
         </thead>
!        <tbody valign="top">
  	<row rowsep="1">
  	 <entry>&engine;s That Store</entry>
  	</row>
***************
*** 506,512 ****
  	<row>
  	 <entry>&compressiblebrick;</entry>
  	 <entry>stores all values, reducing storage requirements when
! 	 all values are the same.</entry>
  	</row>
  	<row>
  	 <entry>&dynamic;</entry>
--- 517,523 ----
  	<row>
  	 <entry>&compressiblebrick;</entry>
  	 <entry>stores all values, reducing storage requirements when
! 	 all values are identical.</entry>
  	</row>
  	<row>
  	 <entry>&dynamic;</entry>
***************
*** 520,526 ****
  	<row>
  	 <entry><type>CompFwd</type></entry>
  	 <entry>extracts specified components of an engine's vectors,
! 	 tensors, arrays, etc.; usually created using
  	 <methodname>comp</methodname> container function.</entry>
  	</row>
  	<row>
--- 531,537 ----
  	<row>
  	 <entry><type>CompFwd</type></entry>
  	 <entry>extracts specified components of an engine's vectors,
! 	 tensors, arrays, etc.; usually created using the
  	 <methodname>comp</methodname> container function.</entry>
  	</row>
  	<row>
***************
*** 529,535 ****
  	</row>
  	<row>
  	 <entry><type>IndexFunction&lt;FunctionObject&gt;</type></entry>
! 	 <entry>makes the <type>FunctionObject</type> function of
  	 indices behave like a container.</entry>
  	</row>
  	<row>
--- 540,546 ----
  	</row>
  	<row>
  	 <entry><type>IndexFunction&lt;FunctionObject&gt;</type></entry>
! 	 <entry>makes the <type>FunctionObject</type>'s function of
  	 indices behave like a container.</entry>
  	</row>
  	<row>
***************
*** 538,558 ****
  	 data-parallel expressions.</entry>
  	</row>
  	<row>
! 	 <entry><type>Stencil&lt;Function,
! 	 Expression&gt;</type></entry>
           <entry>applies a stencil computation (<type>Function</type>)
! 	 to its input (<type>Expression</type>), usually a container;
! 	 usually created by applying a <type>Stencil</type> object to
! 	 a container.  A stencil computation can use multiple
! 	 neighboring input values.</entry>
  	</row>
  	<row>
  	 <entry><type>UserFunctionEngine&lt;Function,
  	 Expression&gt;</type></entry>
  	 <entry>applies the given function (or <glossterm
  	 linkend="glossary-function_object">function
! 	 object</glossterm>) to its input (<type>Expression</type>),
! 	 usually a container; usually created by applying a
  	 <type>UserFunction</type> object to a container.  The
  	 function implements a one-to-one mapping from its input to
  	 values.</entry>
--- 549,568 ----
  	 data-parallel expressions.</entry>
  	</row>
  	<row>
! 	 <entry><type>Stencil&lt;Function, Expression&gt;</type></entry>
           <entry>applies a stencil computation (<type>Function</type>)
! 	 to its input (<type>Expression</type>) which is usually a
! 	 container; usually created by applying a <type>Stencil</type>
! 	 object to a container.  A stencil computation can use
! 	 multiple neighboring input values.</entry>
  	</row>
  	<row>
  	 <entry><type>UserFunctionEngine&lt;Function,
  	 Expression&gt;</type></entry>
  	 <entry>applies the given function (or <glossterm
  	 linkend="glossary-function_object">function
! 	 object</glossterm>) to its input (<type>Expression</type>)
! 	 which is usually a container; usually created by applying a
  	 <type>UserFunction</type> object to a container.  The
  	 function implements a one-to-one mapping from its input to
  	 values.</entry>
***************
*** 581,631 ****
        </tgroup>
       </table>
  
!     <para>&brick; &engine;s explicitly store values just like &c;
      arrays.  &compressiblebrick; &engine;s optimize their storage
!     requirements when all values are the same.  Most &array;s use one
      of these two &engine;s.  &brick;s are the default &engine;s for
!     &array; and &field; containers because each of their values are
!     explicitly stored.  Explicitly storing all an engine's value can
!     require a large amount of space, particularly if all these values
!     are the same.  If all a compressible brick &engine;'s values are
!     the same, the engine stores that one value rather than many, many
!     copies of the same value.  These engines can both save time as
!     well as space.  Initializing a compressible engine requires
!     setting only one value, not every value.  Using less storage space
!     may permit more useful values to be stored in cache, improving
!     cache performance.  Reading a value in a compressed &engine; using
!     <methodname>read</methodname> is as fast as reading a value in a
!     &brick; &engine;, but writing a value always requires an
!     additional <keywordname>if</keywordname> conditional.  Thus, if an
!     &engine; occasionally has multiple different values during its
!     life time, a &compressiblebrick; &engine; may be faster than a
!     &brick; &engine;.  If an &engine; is created and its values are
!     mostly read, not written, a &compressiblebrick; &engine; may also
!     be faster.  Otherwise, a &brick; &engine; may be preferable.
!     Timing the same program using the two different &engine; types
!     will reveal which is faster for a particular situation.</para>
! 
!     <para>In distributed computing, many &engine;s may have few
!     nonzero values so &compressiblebrick; &engine;s may be preferable.
!     For distributed computing, a container's domain is partitioned
!     into regions each computed by a separate processor and &engine;.
!     If the computation is concentrated in sections of the domain, many
!     &engine;s may have few, if any, nonzero values.  Thus,
!     &compressiblebrick; &engine;s may be preferable for distributed
!     computing.</para>
  
      <para>Both &brick; and &compressiblebrick; &engine;s have
      <methodname>read</methodname> and
!     <methodname>operator()</methodname> members with &int; and &loc;
!     parameters.  The parameters should match the &array;'s
      dimensionality.  For example, if &array; <varname>a</varname> has
      dimensionality&nbsp;3, <function>a.read(int, int, int)</function>
      and <function>a(int, int, int)</function> should be used.  The
      former returns a value that cannot be modified, while the latter
!     can be changed.  Using the <methodname>read</methodname> can lead
!     to faster code.  Alternatively, an index can be specified using a
!     &loc;.  For example,
      <statement>a.read(Loc&lt;3&gt;(1,-2,5))</statement> and
      <statement>a(Loc&lt;3&gt;(1,-2,5))</statement> are equivalent to
      <statement>a.read(1,-2,5))</statement> and
--- 591,642 ----
        </tgroup>
       </table>
  
! <!-- FIXME: Place in firstterm. -->
!     <para><glossterm linkend="glossary-brick">&brick;
!     &engine;s</glossterm> explicitly store values just like &c;
      arrays.  &compressiblebrick; &engine;s optimize their storage
!     requirements when all values are identical.  Many &array;s use one
      of these two &engine;s.  &brick;s are the default &engine;s for
!     &array; and &field; containers because they explicitly store each
!     value.  This explicit storage can require a large amount of space,
!     particularly if all these values are the same.  If all a
!     compressible brick &engine;'s values are identical, the &engine;
!     stores that one value rather than many, many copies of the same
!     value.  These engines can both save time as well as space.
!     Initializing a compressible engine requires setting only one
!     value, not every value.  Using less storage space may also permit
!     more useful values to be stored in cache, improving cache
!     performance.  Reading a value in a compressed &engine; using the
!     <methodname>read</methodname> member function is as fast as
!     reading a value in a &brick; &engine;, but writing a value always
!     requires executing an additional <keywordname>if</keywordname>
!     conditional.  Thus, if an &engine; infrequently has multiple
!     different values during its life time, a &compressiblebrick;
!     &engine; may be faster than a &brick; &engine;.  If an &engine; is
!     created and its values are mostly read, not written, a
!     &compressiblebrick; &engine; may also be faster.  Otherwise, a
!     &brick; &engine; may be preferable.  Timing the same program using
!     the two different &engine; types will reveal which is faster for a
!     particular situation.  In distributed computing, many &engine;s
!     may have few nonzero values so &compressiblebrick; &engine;s may
!     be preferable.  For distributed computing, a container's domain is
!     partitioned into regions each computed by a separate processor and
!     &engine;.  If the computation is concentrated in sections of the
!     domain, many &engine;s may have few, if any, nonzero values.
!     Thus, &compressiblebrick; &engine;s may be preferable for
!     distributed computing.</para>
  
      <para>Both &brick; and &compressiblebrick; &engine;s have
      <methodname>read</methodname> and
!     <methodname>operator()</methodname> member functions taking &int;
!     and &loc; parameters.  The parameters should match the &array;'s
      dimensionality.  For example, if &array; <varname>a</varname> has
      dimensionality&nbsp;3, <function>a.read(int, int, int)</function>
      and <function>a(int, int, int)</function> should be used.  The
      former returns a value that cannot be modified, while the latter
!     can be changed.  Using the <methodname>read</methodname> member
!     function can lead to faster code.  Alternatively, an index can be
!     specified using a &loc;.  For example,
      <statement>a.read(Loc&lt;3&gt;(1,-2,5))</statement> and
      <statement>a(Loc&lt;3&gt;(1,-2,5))</statement> are equivalent to
      <statement>a.read(1,-2,5))</statement> and
***************
*** 641,650 ****
      <methodname>operator()</methodname> take <type>Loc&lt;1&gt;</type>
      or one &int; parameter.  In addition, the one-dimensional domain
      can be dynamically resized using <methodname>create</methodname>
!     and <methodname>destroy</methodname>; see .
  
! HERE Dynamic. How does one change the domain size?  What is the model?</para>
  
  <!-- HERE: Array cannot forward domain size changes to underlying Dynamic Engine. -->
  
      <para>Types of &engine;s:
--- 652,666 ----
      <methodname>operator()</methodname> take <type>Loc&lt;1&gt;</type>
      or one &int; parameter.  In addition, the one-dimensional domain
      can be dynamically resized using <methodname>create</methodname>
!     and <methodname>destroy</methodname>.
! <![%unfinished;[
! ; see .
  
! HERE Dynamic. How does one change the domain size?  What is the model?
! ]]>  <!-- end unfinished -->
! </para>
  
+ <![%unfinished;[
  <!-- HERE: Array cannot forward domain size changes to underlying Dynamic Engine. -->
  
      <para>Types of &engine;s:
*************** HERE Dynamic. How does one change the do
*** 706,711 ****
--- 722,728 ----
      types of engines likely to be used by &pooma; programmers and how
      to declare containers using them.  Should I list the other engines
      that are automatically created?</para>
+ ]]>  <!-- end unfinished -->
  
     </section>
    </chapter>
*************** HERE Dynamic. How does one change the do
*** 729,745 ****
  <![%temporary;[
  
     <para>A <glossterm linkend="glossary-view"><firstterm>view of a
!    container&nbsp;&container;</firstterm></glossterm> is a container
!    accessing a subset of &container;'s domain&nbsp;&containerdomain;
!    and values.  The subset can include all of&nbsp;&containerdomain;.
!    A <quote>view</quote> is so named because it is a different way to
!    access, or view, another container's values.  Both the container
!    and its view share the same underlying engine so changing values in
!    one also changes them in the other.</para>
  
     <para>A view is created by following a container's name by
!    parentheses containing a domain&nbsp;&containerdomain;.  For
!    example, consider this code extracted from <xref
     linkend="tutorial-array_parallel-doof2d"></xref> in <xref
     linkend="tutorial-array_data_parallel"></xref>.
  <programlisting>
--- 746,762 ----
  <![%temporary;[
  
     <para>A <glossterm linkend="glossary-view"><firstterm>view of a
!    container</firstterm></glossterm> is a container accessing a subset
!    of &container;'s domain and values.  The subset can include all of
!    the container's domain.  A <quote>view</quote> is so named because
!    it is a different way to access, or view, another container's
!    values.  Both the container and its view share the same underlying
!    engine so changing values in one also changes them in the
!    other.</para>
  
     <para>A view is created by following a container's name by
!    parentheses containing a domain.  For example, consider this code
!    extracted from <xref
     linkend="tutorial-array_parallel-doof2d"></xref> in <xref
     linkend="tutorial-array_data_parallel"></xref>.
  <programlisting>
*************** a(I,J) = (1.0/9.0) *
*** 922,928 ****
  	 <para>create, copy, and destroy operations (mostly table)</para>
  	</listitem>
  	<listitem>
! 	 <para>nonmodifying operations (mostly table)</para>
  	</listitem>
  	<listitem>
  	 <para>assignments (mostly table)</para>
--- 939,945 ----
  	 <para>create, copy, and destroy operations (mostly table)</para>
  	</listitem>
  	<listitem>
! 	 <para>non-modifying operations (mostly table)</para>
  	</listitem>
  	<listitem>
  	 <para>assignments (mostly table)</para>
*************** a(I,J) = (1.0/9.0) *
*** 1082,1088 ****
  	<entry>description</entry>
         </row>
        </thead>
!       <tbody>
         <row>
  	<entry>&inform; <varname>pinfo</varname></entry>
  	<entry>output stream used to print informative messages to the
--- 1099,1105 ----
  	<entry>description</entry>
         </row>
        </thead>
!       <tbody valign="top">
         <row>
  	<entry>&inform; <varname>pinfo</varname></entry>
  	<entry>output stream used to print informative messages to the
*************** UNFINISHED</para>
*** 1939,1945 ****
  	<entry>Interpretation</entry>
         </row>
        </thead>
!       <tbody>
         <row>
  	<entry><varname>Dim</varname></entry>
  	<entry><para>dimension</para></entry>
--- 1956,1962 ----
  	<entry>Interpretation</entry>
         </row>
        </thead>
!       <tbody valign="top">
         <row>
  	<entry><varname>Dim</varname></entry>
  	<entry><para>dimension</para></entry>
*************** UNFINISHED</para>
*** 1971,1977 ****
  	<entry>Interpretation</entry>
         </row>
        </thead>
!       <tbody>
         <row>
  	<entry><fieldsynopsis><varname>This_t</varname></fieldsynopsis></entry>
  	<entry><para>the &array; object's type</para></entry>
--- 1988,1994 ----
  	<entry>Interpretation</entry>
         </row>
        </thead>
!       <tbody valign="top">
         <row>
  	<entry><fieldsynopsis><varname>This_t</varname></fieldsynopsis></entry>
  	<entry><para>the &array; object's type</para></entry>
*************** UNFINISHED</para>
*** 2032,2038 ****
  	 <entry>Effect</entry>
  	</row>
         </thead>
!        <tbody>
  	<row>
  	 <entry>
            <constructorsynopsis>
--- 2049,2055 ----
  	 <entry>Effect</entry>
  	</row>
         </thead>
!        <tbody valign="top">
  	<row>
  	 <entry>
            <constructorsynopsis>
*************** UNFINISHED</para>
*** 2104,2110 ****
  	 <entry>Effect</entry>
  	</row>
         </thead>
!        <tbody>
  	<row>
  	 <entry>
            <methodsynopsis>
--- 2121,2127 ----
  	 <entry>Effect</entry>
  	</row>
         </thead>
!        <tbody valign="top">
  	<row>
  	 <entry>
            <methodsynopsis>
*************** UNFINISHED</para>
*** 2187,2193 ****
  	 <entry>Effect</entry>
  	</row>
         </thead>
!        <tbody>
  	<row>
  	 <entry>
            <methodsynopsis>
--- 2204,2210 ----
  	 <entry>Effect</entry>
  	</row>
         </thead>
!        <tbody valign="top">
  	<row>
  	 <entry>
            <methodsynopsis>
*************** UNFINISHED</para>
*** 2223,2229 ****
  	 <entry>Effect</entry>
  	</row>
         </thead>
!        <tbody>
  	<row>
  	 <entry>
            <methodsynopsis>
--- 2240,2246 ----
  	 <entry>Effect</entry>
  	</row>
         </thead>
!        <tbody valign="top">
  	<row>
  	 <entry>
            <methodsynopsis>
*************** UNFINISHED</para>
*** 2269,2275 ****
  	 <entry>Effect</entry>
  	</row>
         </thead>
!        <tbody>
  	<row>
  	 <entry>
            <methodsynopsis>
--- 2286,2292 ----
  	 <entry>Effect</entry>
  	</row>
         </thead>
!        <tbody valign="top">
  	<row>
  	 <entry>
            <methodsynopsis>
*************** UNFINISHED</para>
*** 2307,2313 ****
  	 <entry>Meaning</entry>
  	</row>
         </thead>
!        <tbody>
  	<row>
  	 <entry>
            <fieldsynopsis>
--- 2324,2330 ----
  	 <entry>Meaning</entry>
  	</row>
         </thead>
!        <tbody valign="top">
  	<row>
  	 <entry>
            <fieldsynopsis>
*************** UNFINISHED</para>
*** 2433,2439 ****
  	<entry>Value</entry>
         </row>
        </thead>
!       <tbody>
         <row>
  	<entry>
            <funcsynopsis>
--- 2450,2456 ----
  	<entry>Value</entry>
         </row>
        </thead>
!       <tbody valign="top">
         <row>
  	<entry>
            <funcsynopsis>
*************** UNFINISHED</para>
*** 2914,2920 ****
  	<entry>Description</entry>
         </row>
        </thead>
!       <tbody>
         <row>
  	<entry><type>NoMesh&lt;Dim&gt;</type></entry>
  	<entry><para>no physical spacing, causing a &field; to mimic
--- 2931,2937 ----
  	<entry>Description</entry>
         </row>
        </thead>
!       <tbody valign="top">
         <row>
  	<entry><type>NoMesh&lt;Dim&gt;</type></entry>
  	<entry><para>no physical spacing, causing a &field; to mimic
*************** UNFINISHED</para>
*** 2992,2998 ****
         <entry>Description</entry>
        </row>
       </thead>
!      <tbody>
        <row>
         <entry><para>Brick</para></entry>
         <entry><para><literal>Brick</literal></para></entry>
--- 3009,3015 ----
         <entry>Description</entry>
        </row>
       </thead>
!      <tbody valign="top">
        <row>
         <entry><para>Brick</para></entry>
         <entry><para><literal>Brick</literal></para></entry>
*************** UNFINISHED</para>
*** 3585,3591 ****
     <title>Particles</title>
  
     <para><filename
! 		   class="libraryfile">docs/ParticlesDoc.txt</filename> has
     out-of-date information.</para>
  
     <para>See Section&nbsp;3.2.3 of
--- 3602,3608 ----
     <title>Particles</title>
  
     <para><filename
!    class="libraryfile">docs/ParticlesDoc.txt</filename> has
     out-of-date information.</para>
  
     <para>See Section&nbsp;3.2.3 of
*************** UNFINISHED</para>
*** 3703,3711 ****
--- 3720,3736 ----
   <appendix id="installation">
    <title>Obtaining and Installing &pooma;</title>
  
+ <![%temporary;[
+   <para>In <xref linkend="tutorial-installation"></xref>, we described
+   how to install &pooma;.  In the following section, we describe how
+   to install &pooma; to support distributed computation.</para>
+ ]]>  <!-- end temporary -->
+ 
+ <![%unfinished;[
    <para>ADD: Write this section, including extensive instructions
    for Unix, MS Windows, and MacOS.  List the configuration options.
    Be sure to describe configuring for parallel execution.</para>
+ ]]>  <!-- end unfinished -->
  
    <section id="installation-distributed_computing">
     <title>Supporting Distributed Computation</title>
*************** UNFINISHED</para>
*** 3724,3743 ****
      <para>&cheetah;, and thus &pooma;, can use Ralf Engelschall's &mm;
      Shared Memory Library to pass messages between processors.  For
      example, the &author; uses this library on a two-processor
!     computer running &linux;.  The library, available at
!     http://www.engelschall.com/sw/mm/, is available for free and has
!     been successfully tested on a variety of Unix platforms.</para>
  
      <para>We describe how to download and install the &mm; library.
       <orderedlist spacing="compact">
! 	<listitem>
! 	 <para>Download the library from the &pooma; Download page
!          available off the &pooma; home page (&poomahomepage;).</para>
! 	</listitem>
  	<listitem>
  	 <para>Extract the source code using <command>tar xzvf
!          mm-1.1.3.tar.gz</command>.  Move into the resulting source
!          code directory <filename
           class="directory">mm-1.1.3</filename>.</para>
  	</listitem>
  	<listitem>
--- 3749,3770 ----
      <para>&cheetah;, and thus &pooma;, can use Ralf Engelschall's &mm;
      Shared Memory Library to pass messages between processors.  For
      example, the &author; uses this library on a two-processor
!     computer running &linux;.  The library, available at <ulink
!     url="http://www.engelschall.com/sw/mm/">http://www.engelschall.com/sw/mm/</ulink>,
!     is available for free and has been successfully tested on a
!     variety of Unix platforms.</para>
  
      <para>We describe how to download and install the &mm; library.
       <orderedlist spacing="compact">
!       <listitem>
!        <para>Download the library from the &pooma; Download page
!        (&poomadownloadpage;) available off the &pooma; home page
!        (&poomahomepage;).</para>
!       </listitem>
  	<listitem>
  	 <para>Extract the source code using <command>tar xzvf
!          mm-1.1.3.tar.gz</command>.  Change directories into the
!          resulting source code directory <filename
           class="directory">mm-1.1.3</filename>.</para>
  	</listitem>
  	<listitem>
*************** UNFINISHED</para>
*** 3754,3763 ****
           &dashdash;prefix=${HOME}/pooma/mm-1.1.3</command>.</para>
  	</listitem>
  	<listitem>
! 	 <para>Create the library by issuing the <command>make</command>
!      command.  This compiles the source code using a &c; compiler.  To
!      use a different compiler than the &mm; configuration chooses, set
!      the <envar>CC</envar> to the compiler before configuring.</para>
        </listitem>
      <listitem>
       <para>Optionally test the library by issuing the <command>make
--- 3781,3792 ----
           &dashdash;prefix=${HOME}/pooma/mm-1.1.3</command>.</para>
  	</listitem>
  	<listitem>
! 	 <para>Create the library by issuing the
!          <command>make</command> command.  This compiles the source
!          code using a &c; compiler.  To use a different compiler than
!          the &mm; configuration chooses, set the <envar>CC</envar>
!          environment variable to the desired compiler before
!          configuring.</para>
        </listitem>
      <listitem>
       <para>Optionally test the library by issuing the <command>make
*************** UNFINISHED</para>
*** 3791,3798 ****
  
      <para>&cheetah;'s messaging is implemented using an underlying
      messaging library such as the Message Passing Interface (&mpi;)
!     Communications Library (FIXME: xref linkend="mpi99", <ulink
!     url="http://www-unix.mcs.anl.gov/mpi/"></ulink>) or the &mm;
      Shared Memory Library.  &mpi; works on a wide variety of platforms
      and has achieved widespread usage.  &mm; works under Unix on any
      computer with shared memory.  Both libraries are available for
--- 3820,3831 ----
  
      <para>&cheetah;'s messaging is implemented using an underlying
      messaging library such as the Message Passing Interface (&mpi;)
!     Communications Library
! <![%unfinished;[
!  (FIXME: xref linkend="mpi99", <ulink
!     url="http://www-unix.mcs.anl.gov/mpi/"></ulink>)
! ]]>  <!-- end unfinished -->
!     or the &mm;
      Shared Memory Library.  &mpi; works on a wide variety of platforms
      and has achieved widespread usage.  &mm; works under Unix on any
      computer with shared memory.  Both libraries are available for
*************** UNFINISHED</para>
*** 3803,3814 ****
       <orderedlist spacing="compact">
        <listitem>
         <para>Download the library from the &pooma; Download page
!        available off the &pooma; home page (&poomahomepage;).</para>
        </listitem>
        <listitem>
         <para>Extract the source code using <command>tar xzvf
!        cheetah-1.0.tgz</command>.  Move into the resulting source code
!        directory <filename
         class="directory">cheetah-1.0</filename>.</para>
        </listitem>
        <listitem>
--- 3836,3848 ----
       <orderedlist spacing="compact">
        <listitem>
         <para>Download the library from the &pooma; Download page
!        (&poomadownloadpage;) available off the &pooma; home page
!        (&poomahomepage;).</para>
        </listitem>
        <listitem>
         <para>Extract the source code using <command>tar xzvf
!        cheetah-1.0.tgz</command>.  Change directories into the
!        resulting source code directory <filename
         class="directory">cheetah-1.0</filename>.</para>
        </listitem>
        <listitem>
*************** UNFINISHED</para>
*** 3935,3941 ****
          installed &cheetah; library.  For
          example, <command>declare -x
          CHEETAHDIR=${HOME}/pooma/cheetah-1.0</command> specifies the
!         installation directory used in the previous section.</para>
        </listitem>
        <listitem>
         <para>When configuring &pooma;, specify the
--- 3969,3977 ----
          installed &cheetah; library.  For
          example, <command>declare -x
          CHEETAHDIR=${HOME}/pooma/cheetah-1.0</command> specifies the
!         installation directory used in the previous section.  If using
!         the <application>csh</application> shell, use <command>setenv 
!         CHEETAHDIR ${HOME}/pooma/cheetah-1.0</command>.</para>
        </listitem>
        <listitem>
         <para>When configuring &pooma;, specify the
*************** UNFINISHED</para>
*** 4137,4142 ****
--- 4173,4180 ----
  
   <!-- Index -->
  
+ <![%unfinished;[
    &genindex.sgm;
+ ]]>  <!-- end unfinished -->
  
  </book>

From oldham at codesourcery.com  Fri Jan 25 03:05:26 2002
From: oldham at codesourcery.com (Jeffrey Oldham)
Date: Thu, 24 Jan 2002 19:05:26 -0800
Subject: Manual Figures
Message-ID: <20020124190526.A7778@codesourcery.com>

These are updates to the MetaPost figures for the POOMA manual.

2002-Jan-24  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* doof2d.mp (210): Fix operator layout.  Modify indices.  Add
	indices for lhs.
	* introduction.mp (101): Add comments of unfinished work.
	* macros.ltx: Add many new definitions.
	* makefile: Several minor changes.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: doof2d.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/doof2d.mp,v
retrieving revision 1.3
diff -c -p -r1.3 doof2d.mp
*** doof2d.mp	2002/01/04 17:42:43	1.3
--- doof2d.mp	2002/01/25 02:53:47
*************** beginfig(210)
*** 127,134 ****
    for t = 0 upto 2:
      drawGrid(nuCells, unit, z[t]);
    endfor
!   label(btex = etex, z1 + unit*(-0.9operatorWidth, 0.5nuCells));
!   label(btex + etex, z2 + unit*(-0.9operatorWidth, 0.5nuCells));
    
    %% Label the grid cells' values.
    % Label b(I,J) grid values.
--- 127,134 ----
    for t = 0 upto 2:
      drawGrid(nuCells, unit, z[t]);
    endfor
!   label(btex = etex, z1 + unit*(-0.6operatorWidth, 0.5nuCells));
!   label(btex + etex, z2 + unit*(-0.6operatorWidth, 0.5nuCells));
    
    %% Label the grid cells' values.
    % Label b(I,J) grid values.
*************** beginfig(210)
*** 164,182 ****
  
    %% Label the indices.
    % Label b(I,J) grid indices.
!   labelCellBottom(btex \footnotesize 1 etex, (0,0), z1);
!   labelCellBottom(btex \footnotesize 2 etex, (1,0), z1);
!   labelCellBottom(btex \footnotesize 3 etex, (2,0), z1);
!   labelCellLeft(btex \footnotesize 1 etex, (0,0), z1);
!   labelCellLeft(btex \footnotesize 2 etex, (0,1), z1);
!   labelCellLeft(btex \footnotesize 3 etex, (0,2), z1);
    % Label b(I+1,J-1) grid indices.
!   labelCellBottom(btex \footnotesize 2 etex, (0,0), z2);
!   labelCellBottom(btex \footnotesize 3 etex, (1,0), z2);
!   labelCellBottom(btex \footnotesize 4 etex, (2,0), z2);
    labelCellLeft(btex \footnotesize 0 etex, (0,0), z2);
    labelCellLeft(btex \footnotesize 1 etex, (0,1), z2);
    labelCellLeft(btex \footnotesize 2 etex, (0,2), z2);
    
    %% Label the grids.
    labelGrid(btex $b(I,J)+b(I+1,J-1)$ etex, nuCells, z0);
--- 164,189 ----
  
    %% Label the indices.
    % Label b(I,J) grid indices.
!   labelCellBottom(btex \footnotesize 0 etex, (0,0), z1);
!   labelCellBottom(btex \footnotesize 1 etex, (1,0), z1);
!   labelCellBottom(btex \footnotesize 2 etex, (2,0), z1);
!   labelCellLeft(btex \footnotesize 0 etex, (0,0), z1);
!   labelCellLeft(btex \footnotesize 1 etex, (0,1), z1);
!   labelCellLeft(btex \footnotesize 2 etex, (0,2), z1);
    % Label b(I+1,J-1) grid indices.
!   labelCellBottom(btex \footnotesize 0 etex, (0,0), z2);
!   labelCellBottom(btex \footnotesize 1 etex, (1,0), z2);
!   labelCellBottom(btex \footnotesize 2 etex, (2,0), z2);
    labelCellLeft(btex \footnotesize 0 etex, (0,0), z2);
    labelCellLeft(btex \footnotesize 1 etex, (0,1), z2);
    labelCellLeft(btex \footnotesize 2 etex, (0,2), z2);
+   % Label b(I,J)+b(I+1,J-1) grid indices.
+   labelCellBottom(btex \footnotesize 0 etex, (0,0), z0);
+   labelCellBottom(btex \footnotesize 1 etex, (1,0), z0);
+   labelCellBottom(btex \footnotesize 2 etex, (2,0), z0);
+   labelCellLeft(btex \footnotesize 0 etex, (0,0), z0);
+   labelCellLeft(btex \footnotesize 1 etex, (0,1), z0);
+   labelCellLeft(btex \footnotesize 2 etex, (0,2), z0);
    
    %% Label the grids.
    labelGrid(btex $b(I,J)+b(I+1,J-1)$ etex, nuCells, z0);
Index: introduction.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/introduction.mp,v
retrieving revision 1.2
diff -c -p -r1.2 introduction.mp
*** introduction.mp	2002/01/04 17:42:43	1.2
--- introduction.mp	2002/01/25 02:53:47
*************** etex
*** 18,23 ****
--- 18,26 ----
  
  %% Relationship between science, computational science, and Pooma.
  beginfig(101)
+ %% FIXME: Ensure the arrow labels are the same distance above the arrows.
+ %% FIXME: Ensure the boxes all have the same height.
+ %% FIXME: Ensure the arrowheads do not collide.
    numeric unit; unit = 0.8cm;
    numeric horizSpace; horizSpace = 8unit;
    numeric vertSpace; vertSpace = unit;
Index: macros.ltx
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/macros.ltx,v
retrieving revision 1.1
diff -c -p -r1.1 macros.ltx
*** macros.ltx	2001/12/11 20:36:13	1.1
--- macros.ltx	2002/01/25 02:53:47
***************
*** 6,11 ****
--- 6,34 ----
  
  %% Consistency between these macros and the DocBook/Jade output is desired.
  
+ % Mathematical Notation
+ \newcommand{\dimension}{\ensuremath{d}}%
+ 	% Produce a representation for a fixed number of dimensions.
+ 	% Requires no parameters.
+ \newcommand{\naturalNus}{\ensuremath{\boldsymbol{N}}}%
+ 	% Produce a representation for discrete space.
+ 	% Requires no parameters.
+ \newcommand{\maps}{\ensuremath{\rightarrow}}%
+ 	% Produce a representation for a map.
+ 	% Requires no parameters.
+ \newcommand{\real}{\ensuremath{\boldsymbol{R}}}%
+ 	% Produce a representation for continuous space.
+ 	% Requires no parameters.
+ 
+ % Other Notation
+ \newcommand{\pooma}{POOMA}%
+ 	% Produce "Pooma."
+ 	% Requires no parameters.
+ 
+ % Programming Notation
+ \newcommand{\statement}[1]{\texttt{#1}}%
+ 	% Produce a C++ (or other programming language) statement or fragment.
+ 	% Requires:	1. the statement.
  \newcommand{\type}[1]{\texttt{#1}}%
  	% Produce a C++ (or other programming language) type.
  	% Requires:	1. the type's name.
Index: makefile
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/makefile,v
retrieving revision 1.1
diff -c -p -r1.1 makefile
*** makefile	2001/12/04 00:07:00	1.1
--- makefile	2002/01/25 02:53:47
*************** INDEXOPTIONS=		-t 'Index' -i 'index' -g 
*** 23,30 ****
  
  CXXFLAGS= -g -Wall -pedantic -W -Wstrict-prototypes -Wpointer-arith -Wbad-function-cast -Wcast-align -Wconversion -Wnested-externs -Wundef -Winline -static
  
! all: outline.ps
  
  %.all:	%.ps %.pdf %.html
  	chmod 644 $*.ps $*.pdf
  	mv $*.ps $*.pdf $*
--- 23,34 ----
  
  CXXFLAGS= -g -Wall -pedantic -W -Wstrict-prototypes -Wpointer-arith -Wbad-function-cast -Wcast-align -Wconversion -Wnested-externs -Wundef -Winline -static
  
! all: manual.ps
  
+ manual.dvi: manual.xml introduction.xml template.xml tutorial.xml \
+             concepts.xml arrays.xml data-parallel.xml glossary.xml \
+             bibliography.xml
+ 
  %.all:	%.ps %.pdf %.html
  	chmod 644 $*.ps $*.pdf
  	mv $*.ps $*.pdf $*
*************** all: outline.ps
*** 41,54 ****
  %.pdf.ltx:	%.ltx
  	sed -e 's/^%\\usepackage{times}/\\usepackage{times}/' $< > $@
  
! %.pdf:	%.pdf.ps
! 	ps2pdf $< $@
  
  # This rule assumes index creation.
  %.dvi:	%.xml genindex.sgm
! 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $<
! 	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index
! 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) $(XML) $< && jadetex $*.tex && jadetex $*.tex && jadetex $*.tex
  
  genindex.sgm:
  	perl collateindex.pl $(INDEXOPTIONS) -N -o $@
--- 45,59 ----
  %.pdf.ltx:	%.ltx
  	sed -e 's/^%\\usepackage{times}/\\usepackage{times}/' $< > $@
  
! %.pdf:	%.pdf.ltx
! 	pdflatex $<
! 	mv $@.pdf $@
  
  # This rule assumes index creation.
  %.dvi:	%.xml genindex.sgm
! 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $< && \
! 	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index && \
! 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) -V tex-backend $(XML) $< && jadetex $*.tex && jadetex $*.tex && jadetex $*.tex
  
  genindex.sgm:
  	perl collateindex.pl $(INDEXOPTIONS) -N -o $@
*************** mproof-%.ps:	%.mp
*** 66,69 ****
  	detex $< > $@
  
  clean:
! 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.mpx mpxerr.tex HTML.index outline.tex
--- 71,74 ----
  	detex $< > $@
  
  clean:
! 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.mpx mpxerr.tex HTML.index manual.tex genindex.sgm

From oldham at mail.codesourcery.com  Fri Jan 25 03:31:18 2002
From: oldham at mail.codesourcery.com (Jeffrey)
Date: Thu, 24 Jan 2002 19:31:18 -0800
Subject: Manual: Move Program Annotation Files
Message-ID: <20020124193118.A575@vaio.codesourcery.com>

This patch deals with patches to convert executable code into
annotated programs suitable for DocBook.  The files are
1) moved
2) revised to varying extents.

2002-Jan-24  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* Doof2d-Array-distributed-annotated.patch: Move this file to
	examples/Doof2d/.
	* Doof2d-Array-element-annotated.patch: Likewise.
	* Doof2d-Array-parallel-annotated.patch: Likewise.
	* Doof2d-Array-stencil-annotated.patch: Likewise.
	* Doof2d-C-element-annotated.patch: Likewise.
	* Doof2d-Field-distributed-annotated.patch: Likewise.
	* Doof2d-Field-parallel-annotated.patch: Likewise.
	* Makefile: Likewise.
	* initialize-finalize-annotated.patch: Likewise.
	* pairs-templated-annotated.patch: Likewise.
	* pairs-untemplated-annotated.patch: Likewise.
	* examples/Doof2d-Array-distributed-annotated.patch: Likewise.
	* examples/Doof2d-Array-element-annotated.patch: Likewise.
	* examples/Doof2d-Array-parallel-annotated.patch: Likewise.
	* examples/Doof2d-Array-stencil-annotated.patch: Likewise.
	* examples/Doof2d-C-element-annotated.patch: Likewise.
	* examples/Doof2d-Field-distributed-annotated.patch: Likewise.
	* examples/Doof2d-Field-parallel-annotated.patch: Likewise.
	* examples/Makefile: Likewise.
	* examples/initialize-finalize-annotated.patch: Likewise.
	* examples/pairs-templated-annotated.patch: Likewise.
	* examples/pairs-untemplated-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Array-distributed-annotated.patch: Most
	recent version of this file.  Also moved here.
	* examples/Doof2d/Doof2d-Array-element-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Array-parallel-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Array-stencil-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-C-element-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Field-distributed-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Field-parallel-annotated.patch: Likewise.
	* examples/Sequential/array-copy-annotated.patch: Likewise.
	* examples/Sequential/array-size-annotated.patch: Likewise.
	* examples/Sequential/dynamicarray-annotated.patch: Likewise.
	* examples/Sequential/initialize-finalize-annotated.patch: Likewise.
	* examples/Templates/pairs-templated-annotated.patch: Likewise.

Applied to	mainline.
Approved by	no one.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: Doof2d-Array-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Array-distributed-annotated.patch
diff -N Doof2d-Array-distributed-annotated.patch
*** /tmp/cvsQs5Bce	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,184 ****
- *** Doof2d-Array-distributed.cpp	Wed Dec  5 14:04:36 2001
- --- Doof2d-Array-distributed-annotated.cpp	Wed Dec  5 14:07:56 2001
- ***************
- *** 1,3 ****
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- --- 1,5 ----
- ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- ***************
- *** 14,18 ****
-     // (i,j).  The "C" template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template <class C>
-     inline
-     typename C::Element_t
- --- 16,20 ----
-     // (i,j).  The "C" template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 42,46 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 44,48 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  <co id="tutorial-array_distributed-doof2d-io"></co>
-     Inform output;
-   
- ***************
- *** 48,52 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
-       return EXIT_FAILURE;
-     }
- --- 50,54 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 55,63 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 57,65 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 65,69 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 67,71 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 71,80 ****
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<2> interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- --- 73,82 ----
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- ***************
- *** 83,98 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.
- !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
- ! 				    GuardLayers<2>(1),  // internal
- ! 				    GuardLayers<2>(0)); // external
- !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
-   
-     // The template parameters indicate 2 dimensions and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
- !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > b(layout);
-   
-     // Set up the initial conditions.
- --- 85,100 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.  <co id="tutorial-array_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // The template parameters indicate 2 dimensions and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; b(layout);
-   
-     // Set up the initial conditions.
- ***************
- *** 104,112 ****
-   
-     // Create the stencil performing the computation.
- !   Stencil<DoofNinePt> stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 106,114 ----
-   
-     // Create the stencil performing the computation.
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_distributed-doof2d-first_write"></co>
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 117,121 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 119,123 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 125,126 ****
- --- 127,129 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: Doof2d-Array-element-annotated.patch
===================================================================
RCS file: Doof2d-Array-element-annotated.patch
diff -N Doof2d-Array-element-annotated.patch
*** /tmp/cvsW8TBRh	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,143 ****
- *** Doof2d-Array-element.cpp	Tue Dec  4 12:02:10 2001
- --- Doof2d-Array-element-annotated.cpp	Tue Dec  4 12:24:25 2001
- ***************
- *** 1,5 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
- ! #include "Pooma/Arrays.h"	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, element-wise implementation
- --- 1,6 ----
- ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include "Pooma/Arrays.h"	// has Pooma's Array  <co id="tutorial-array_elementwise-doof2d-header"></co>
-   
-   // Doof2d: Pooma Arrays, element-wise implementation
- ***************
- *** 7,17 ****
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the Pooma library for execution.
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 8,18 ----
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the Pooma library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,37 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
- !   // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
-     for (int j = 1; j < n-1; j++)
-       for (int i = 1; i < n-1; i++)
- --- 20,38 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).  <co id="tutorial-array_elementwise-doof2d-domain"></co>
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  <co id="tutorial-array_elementwise-doof2d-initialization"></co>
-     for (int j = 1; j < n-1; j++)
-       for (int i = 1; i < n-1; i++)
- ***************
- *** 43,51 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
- !         a(i,j) = weight *
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- --- 44,52 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
- !         a(i,j) = weight *  <co id="tutorial-array_elementwise-doof2d-first_write"></co>
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- ***************
- *** 53,58 ****
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- --- 54,59 ----
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- ***************
- *** 62,71 ****
-   
-     // Print out the final central value.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
- !   // The arrays are automatically deallocated.
-   
- !   // Tell the Pooma library execution has finished.
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- --- 63,74 ----
-   
-     // Print out the final central value.
- !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
- !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
-   
- !   // Tell the Pooma library execution has finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: Doof2d-Array-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Array-parallel-annotated.patch
diff -N Doof2d-Array-parallel-annotated.patch
*** /tmp/cvs0nlUsn	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,116 ****
- *** Doof2d-Array-parallel.cpp	Tue Dec  4 11:49:43 2001
- --- Doof2d-Array-parallel-annotated.cpp	Tue Dec  4 12:24:36 2001
- ***************
- *** 1,4 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- --- 1,5 ----
- ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,43 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- --- 20,44 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.  <co id="tutorial-array_parallel-doof2d-innerdomain"></co>
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.  <co id="tutorial-array_parallel-doof2d-blockAndEvaluate"></co>
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- ***************
- *** 47,52 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 48,53 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_parallel-doof2d-first_write"></co>
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 63,67 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 64,68 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 71,72 ****
- --- 72,74 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: Doof2d-Array-stencil-annotated.patch
===================================================================
RCS file: Doof2d-Array-stencil-annotated.patch
diff -N Doof2d-Array-stencil-annotated.patch
*** /tmp/cvsERegQs	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,152 ****
- *** Doof2d-Array-stencil.cpp	Tue Dec  4 11:49:39 2001
- --- Doof2d-Array-stencil-annotated.cpp	Tue Dec  4 12:26:46 2001
- ***************
- *** 1,9 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.
-   class DoofNinePt
-   {
- --- 1,10 ----
- ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
-   class DoofNinePt
-   {
- ***************
- *** 14,19 ****
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.
- !   template <class C>
-     inline
-     typename C::Element_t
- --- 15,20 ----
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.  <co id="tutorial-array_stencil-doof2d-stencil_operator"></co>
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 26,30 ****
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }
-     inline int upperExtent(int) const { return 1; }
-   
- --- 27,31 ----
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }  <co id="tutorial-array_stencil-doof2d-stencil_extent"></co>
-     inline int upperExtent(int) const { return 1; }
-   
- ***************
- *** 42,47 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 43,48 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 49,68 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<2> interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
- --- 50,69 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- ***************
- *** 73,82 ****
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.
- !   Stencil<DoofNinePt> stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 74,83 ----
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil_creation"></co>
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_stencil-doof2d-first_write"></co>
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 87,91 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 88,92 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 95,96 ****
- --- 96,98 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: Doof2d-C-element-annotated.patch
===================================================================
RCS file: Doof2d-C-element-annotated.patch
diff -N Doof2d-C-element-annotated.patch
*** /tmp/cvsgKf9Vx	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,150 ****
- *** Doof2d-C-element.cpp	Tue Nov 27 08:36:38 2001
- --- Doof2d-C-element-annotated.cpp	Tue Nov 27 12:08:03 2001
- ***************
- *** 1,4 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- --- 1,5 ----
- ! <programlisting id="tutorial-hand_coded-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- ***************
- *** 6,30 ****
-   int main()
-   {
- !   // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of elements along one dimension of
- !   // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
- !   // Allocate the arrays.
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i < n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- --- 7,31 ----
-   int main()
-   {
- !   // Ask the user for the number of averagings.  <co id="tutorial-hand_coded-doof2d-nuaveragings"></co>
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.  <co id="tutorial-hand_coded-doof2d-array_storage"></co>
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of elements along one dimension of
- !   // the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
- !   // Allocate the arrays.  <co id="tutorial-hand_coded-doof2d-allocation"></co>
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i &lt; n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- ***************
- *** 32,49 ****
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
- !   for (int j = 0; j < n; j++)
- !     for (int i = 0; i < n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- --- 33,50 ----
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  <co id="tutorial-hand_coded-doof2d-initialization"></co>
- !   for (int j = 0; j &lt; n; j++)
- !     for (int i = 0; i &lt; n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.  <co id="tutorial-hand_coded-doof2d-constants"></co>
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-hand_coded-doof2d-first_write"></co>
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- ***************
- *** 51,57 ****
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- --- 52,58 ----
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.  <co id="tutorial-hand_coded-doof2d-second_write"></co>
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- ***************
- *** 60,68 ****
-     }
-   
- !   // Print out the final central value.
- !   std::cout << (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) << std::endl;
-   
- !   // Deallocate the arrays.
- !   for (int i = 0; i < n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- --- 61,69 ----
-     }
-   
- !   // Print out the final central value.  <co id="tutorial-hand_coded-doof2d-answer"></co>
- !   std::cout &openopen; (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) &openopen; std::endl;
-   
- !   // Deallocate the arrays.  <co id="tutorial-hand_coded-doof2d-deallocation"></co>
- !   for (int i = 0; i &lt; n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- ***************
- *** 73,74 ****
- --- 74,76 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: Doof2d-Field-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Field-distributed-annotated.patch
diff -N Doof2d-Field-distributed-annotated.patch
*** /tmp/cvsg1eoJC	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,176 ****
- *** Doof2d-Field-distributed.cpp	Wed Dec  5 14:05:10 2001
- --- Doof2d-Field-distributed-annotated.cpp	Wed Dec  5 14:41:24 2001
- ***************
- *** 1,3 ****
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Fields.h"	// has Pooma's Field
-   
- --- 1,4 ----
- ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Fields.h"	// has Pooma's Field
-   
- ***************
- *** 12,16 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 13,17 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  <co id="tutorial-field_distributed-doof2d-io"></co>
-     Inform output;
-   
- ***************
- *** 18,22 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
-       return EXIT_FAILURE;
-     }
- --- 19,23 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 25,33 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 26,34 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 35,39 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 36,40 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 41,50 ****
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- --- 42,51 ----
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- ***************
- *** 52,74 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.
- !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
- ! 				    GuardLayers<2>(1),  // internal
- ! 				    GuardLayers<2>(0)); // external
- !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
- !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
-   
-     // The template parameters indicate a mesh and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
- !     Remote<Brick> > > a(cell, layout, mesh);
- !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
- !     Remote<Brick> > > b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 53,75 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.  <co id="tutorial-field_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  <co id="tutorial-field_distributed-doof2d-mesh"></co>
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // The template parameters indicate a mesh and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 83,87 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- --- 84,88 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- ***************
- *** 99,103 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The fields are automatically deallocated.
- --- 100,104 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 107,108 ****
- --- 108,110 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: Doof2d-Field-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Field-parallel-annotated.patch
diff -N Doof2d-Field-parallel-annotated.patch
*** /tmp/cvsq9uXsJ	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,120 ****
- *** Doof2d-Field-parallel.cpp	Tue Dec  4 10:01:28 2001
- --- Doof2d-Field-parallel-annotated.cpp	Tue Dec  4 11:04:26 2001
- ***************
- *** 1,5 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
- ! #include "Pooma/Fields.h"	// has Pooma's Field
-   
-   // Doof2d: Pooma Fields, data-parallel implementation
- --- 1,6 ----
- ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include "Pooma/Fields.h"	// has Pooma's Field  <co id="tutorial-field_parallel-doof2d-header"></co>
-   
-   // Doof2d: Pooma Fields, data-parallel implementation
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,44 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the field size: ";
- !   std::cin >> n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   DomainLayout<2> layout(vertDomain);
- !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
- !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The template parameters indicate a mesh, a 'double' element
- !   // type, and ordinary 'Brick' storage.
- !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
- !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 20,45 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the field size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  <co id="tutorial-field_parallel-doof2d-mesh"></co>
- !   DomainLayout&lt;2&gt; layout(vertDomain);
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The template parameters indicate a mesh, a 'double' element
- !   // type, and ordinary 'Brick' storage.  <co id="tutorial-field_parallel-doof2d-field_creation"></co>
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 51,56 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 52,57 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-field_parallel-doof2d-first_write"></co>
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 67,71 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The fields are automatically deallocated.
- --- 68,72 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 75,76 ****
- --- 76,78 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: Makefile
===================================================================
RCS file: Makefile
diff -N Makefile
*** /tmp/cvsgROIRP	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,13 ****
- ### Oldham, Jeffrey D.
- ### 2001Nov27
- ### Pooma
- ###
- ### Produce Annotated Source Code
- 
- all: Doof2d-C-element-annotated.cpp Doof2d-Array-element-annotated.cpp \
-      Doof2d-Array-parallel-annotated.cpp Doof2d-Array-stencil-annotated.cpp \
-      Doof2d-Array-distributed-annotated.cpp \
-      Doof2d-Field-parallel-annotated.cpp Doof2d-Field-distributed-annotated.cpp
- 
- %-annotated.cpp: %-annotated.patch %.cpp
- 	patch -o $@ < $<
--- 0 ----
Index: initialize-finalize-annotated.patch
===================================================================
RCS file: initialize-finalize-annotated.patch
diff -N initialize-finalize-annotated.patch
*** /tmp/cvs6U9YaW	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,14 ****
- *** initialize-finalize.cpp	Sat Dec 15 15:35:57 2001
- --- initialize-finalize-annotated.cpp	Sun Dec 16 14:24:43 2001
- ***************
- *** 1,2 ****
- --- 1,3 ----
- + <programlisting id="initialize-finalize-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   
- ***************
- *** 10,11 ****
- --- 11,13 ----
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: pairs-templated-annotated.patch
===================================================================
RCS file: pairs-templated-annotated.patch
diff -N pairs-templated-annotated.patch
*** /tmp/cvsucf6o2	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,37 ****
- *** pairs-templated.cpp	Wed Dec 26 14:01:38 2001
- --- pairs-templated-annotated.cpp	Wed Dec 26 14:12:51 2001
- ***************
- *** 1,15 ****
- ! // Declare a template class storing a pair of values with the same type.
- ! template <typename T>
-   struct pair {
- !   pair(const int& left, const int& right)
-       : left_(left), right_(right) {}
-   
- !   T left_;
-     T right_;
-   };
-   
- ! // Use a class storing a pair of integers.
- ! pair<int> pair1;
-   
-   // Use a class storing a pair of doubles;
- ! pair<double> pair2;
- --- 1,17 ----
- ! <programlisting id="template_programming-template_use-templated_pair_program" linenumbering="numbered" format="linespecific">
- ! // Declare a template class storing a pair of values with the same type.  <co id="template_programming-template_use-templated_pair_program-template_declaration"></co>
- ! template &lt;typename T&gt;
-   struct pair {
- !   pair(const T&amp; left, const T&amp; right)  // <co id="template_programming-template_use-templated_pair_program-constructor"></co>
-       : left_(left), right_(right) {}
-   
- !   T left_;  // <co id="template_programming-template_use-templated_pair_program-members"></co>
-     T right_;
-   };
-   
- ! // Use a class storing a pair of integers. <co id="template_programming-template_use-templated_pair_program-use"></co>
- ! pair&lt;int&gt; pair1;
-   
-   // Use a class storing a pair of doubles;
- ! pair&lt;double&gt; pair2;
- ! </programlisting>
--- 0 ----
Index: pairs-untemplated-annotated.patch
===================================================================
RCS file: pairs-untemplated-annotated.patch
diff -N pairs-untemplated-annotated.patch
*** /tmp/cvsqR3av8	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,35 ****
- *** pairs-untemplated.cpp	Wed Dec 26 13:48:10 2001
- --- pairs-untemplated-annotated.cpp	Wed Dec 26 14:02:58 2001
- ***************
- *** 1,5 ****
-   // Declare a class storing a pair of integers.
-   struct pairOfInts {
- !   pairOfInts(const int& left, const int& right)
-       : left_(left), right_(right) {}
-   
- --- 1,6 ----
- + <programlisting id="template_programming-template_use-untemplated_pair_program" linenumbering="numbered" format="linespecific">
-   // Declare a class storing a pair of integers.
-   struct pairOfInts {
- !   pairOfInts(const int&amp; left, const int&amp; right)
-       : left_(left), right_(right) {}
-   
- ***************
- *** 10,14 ****
-   // Declare a class storing a pair of doubles.
-   struct pairOfDoubles {
- !   pairOfDoubles(const double& left, const double& right)
-       : left_(left), right_(right) {}
-   
- --- 11,15 ----
-   // Declare a class storing a pair of doubles.
-   struct pairOfDoubles {
- !   pairOfDoubles(const double&amp; left, const double&amp; right)
-       : left_(left), right_(right) {}
-   
- ***************
- *** 16,17 ****
- --- 17,19 ----
-     double right_;
-   };
- + </programlisting>
--- 0 ----
Index: examples/Doof2d-Array-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Array-distributed-annotated.patch
diff -N Doof2d-Array-distributed-annotated.patch
*** /tmp/cvsSYg3pe	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,184 ****
- *** Doof2d-Array-distributed.cpp	Wed Dec  5 14:04:36 2001
- --- Doof2d-Array-distributed-annotated.cpp	Wed Dec  5 14:07:56 2001
- ***************
- *** 1,3 ****
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- --- 1,5 ----
- ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- ***************
- *** 14,18 ****
-     // (i,j).  The "C" template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template <class C>
-     inline
-     typename C::Element_t
- --- 16,20 ----
-     // (i,j).  The "C" template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 42,46 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 44,48 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  <co id="tutorial-array_distributed-doof2d-io"></co>
-     Inform output;
-   
- ***************
- *** 48,52 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
-       return EXIT_FAILURE;
-     }
- --- 50,54 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 55,63 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 57,65 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 65,69 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 67,71 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 71,80 ****
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<2> interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- --- 73,82 ----
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- ***************
- *** 83,98 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.
- !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
- ! 				    GuardLayers<2>(1),  // internal
- ! 				    GuardLayers<2>(0)); // external
- !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
-   
-     // The template parameters indicate 2 dimensions and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
- !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > b(layout);
-   
-     // Set up the initial conditions.
- --- 85,100 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.  <co id="tutorial-array_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // The template parameters indicate 2 dimensions and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; b(layout);
-   
-     // Set up the initial conditions.
- ***************
- *** 104,112 ****
-   
-     // Create the stencil performing the computation.
- !   Stencil<DoofNinePt> stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 106,114 ----
-   
-     // Create the stencil performing the computation.
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_distributed-doof2d-first_write"></co>
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 117,121 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 119,123 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 125,126 ****
- --- 127,129 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d-Array-element-annotated.patch
===================================================================
RCS file: Doof2d-Array-element-annotated.patch
diff -N Doof2d-Array-element-annotated.patch
*** /tmp/cvs0NfShm	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,143 ****
- *** Doof2d-Array-element.cpp	Tue Dec  4 12:02:10 2001
- --- Doof2d-Array-element-annotated.cpp	Tue Dec  4 12:24:25 2001
- ***************
- *** 1,5 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
- ! #include "Pooma/Arrays.h"	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, element-wise implementation
- --- 1,6 ----
- ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include "Pooma/Arrays.h"	// has Pooma's Array  <co id="tutorial-array_elementwise-doof2d-header"></co>
-   
-   // Doof2d: Pooma Arrays, element-wise implementation
- ***************
- *** 7,17 ****
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the Pooma library for execution.
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 8,18 ----
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the Pooma library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,37 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
- !   // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
-     for (int j = 1; j < n-1; j++)
-       for (int i = 1; i < n-1; i++)
- --- 20,38 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).  <co id="tutorial-array_elementwise-doof2d-domain"></co>
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  <co id="tutorial-array_elementwise-doof2d-initialization"></co>
-     for (int j = 1; j < n-1; j++)
-       for (int i = 1; i < n-1; i++)
- ***************
- *** 43,51 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
- !         a(i,j) = weight *
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- --- 44,52 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
- !         a(i,j) = weight *  <co id="tutorial-array_elementwise-doof2d-first_write"></co>
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- ***************
- *** 53,58 ****
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- --- 54,59 ----
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- ***************
- *** 62,71 ****
-   
-     // Print out the final central value.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
- !   // The arrays are automatically deallocated.
-   
- !   // Tell the Pooma library execution has finished.
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- --- 63,74 ----
-   
-     // Print out the final central value.
- !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
- !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
-   
- !   // Tell the Pooma library execution has finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d-Array-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Array-parallel-annotated.patch
diff -N Doof2d-Array-parallel-annotated.patch
*** /tmp/cvsaOFKTt	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,116 ****
- *** Doof2d-Array-parallel.cpp	Tue Dec  4 11:49:43 2001
- --- Doof2d-Array-parallel-annotated.cpp	Tue Dec  4 12:24:36 2001
- ***************
- *** 1,4 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- --- 1,5 ----
- ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,43 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- --- 20,44 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.  <co id="tutorial-array_parallel-doof2d-innerdomain"></co>
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.  <co id="tutorial-array_parallel-doof2d-blockAndEvaluate"></co>
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- ***************
- *** 47,52 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 48,53 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_parallel-doof2d-first_write"></co>
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 63,67 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 64,68 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 71,72 ****
- --- 72,74 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d-Array-stencil-annotated.patch
===================================================================
RCS file: Doof2d-Array-stencil-annotated.patch
diff -N Doof2d-Array-stencil-annotated.patch
*** /tmp/cvs4b053A	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,152 ****
- *** Doof2d-Array-stencil.cpp	Tue Dec  4 11:49:39 2001
- --- Doof2d-Array-stencil-annotated.cpp	Tue Dec  4 12:26:46 2001
- ***************
- *** 1,9 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.
-   class DoofNinePt
-   {
- --- 1,10 ----
- ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has Pooma's Array
-   
-   // Doof2d: Pooma Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
-   class DoofNinePt
-   {
- ***************
- *** 14,19 ****
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.
- !   template <class C>
-     inline
-     typename C::Element_t
- --- 15,20 ----
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.  <co id="tutorial-array_stencil-doof2d-stencil_operator"></co>
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 26,30 ****
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }
-     inline int upperExtent(int) const { return 1; }
-   
- --- 27,31 ----
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }  <co id="tutorial-array_stencil-doof2d-stencil_extent"></co>
-     inline int upperExtent(int) const { return 1; }
-   
- ***************
- *** 42,47 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 43,48 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 49,68 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<2> interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
- --- 50,69 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The template parameters indicate 2 dimensions, a 'double' element
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- ***************
- *** 73,82 ****
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.
- !   Stencil<DoofNinePt> stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 74,83 ----
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil_creation"></co>
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_stencil-doof2d-first_write"></co>
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 87,91 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 88,92 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 95,96 ****
- --- 96,98 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d-C-element-annotated.patch
===================================================================
RCS file: Doof2d-C-element-annotated.patch
diff -N Doof2d-C-element-annotated.patch
*** /tmp/cvsCww7hK	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,150 ****
- *** Doof2d-C-element.cpp	Tue Nov 27 08:36:38 2001
- --- Doof2d-C-element-annotated.cpp	Tue Nov 27 12:08:03 2001
- ***************
- *** 1,4 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- --- 1,5 ----
- ! <programlisting id="tutorial-hand_coded-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- ***************
- *** 6,30 ****
-   int main()
-   {
- !   // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of elements along one dimension of
- !   // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
- !   // Allocate the arrays.
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i < n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- --- 7,31 ----
-   int main()
-   {
- !   // Ask the user for the number of averagings.  <co id="tutorial-hand_coded-doof2d-nuaveragings"></co>
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.  <co id="tutorial-hand_coded-doof2d-array_storage"></co>
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of elements along one dimension of
- !   // the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
- !   // Allocate the arrays.  <co id="tutorial-hand_coded-doof2d-allocation"></co>
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i &lt; n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- ***************
- *** 32,49 ****
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
- !   for (int j = 0; j < n; j++)
- !     for (int i = 0; i < n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- --- 33,50 ----
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  <co id="tutorial-hand_coded-doof2d-initialization"></co>
- !   for (int j = 0; j &lt; n; j++)
- !     for (int i = 0; i &lt; n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.  <co id="tutorial-hand_coded-doof2d-constants"></co>
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-hand_coded-doof2d-first_write"></co>
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- ***************
- *** 51,57 ****
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- --- 52,58 ----
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.  <co id="tutorial-hand_coded-doof2d-second_write"></co>
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- ***************
- *** 60,68 ****
-     }
-   
- !   // Print out the final central value.
- !   std::cout << (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) << std::endl;
-   
- !   // Deallocate the arrays.
- !   for (int i = 0; i < n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- --- 61,69 ----
-     }
-   
- !   // Print out the final central value.  <co id="tutorial-hand_coded-doof2d-answer"></co>
- !   std::cout &openopen; (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) &openopen; std::endl;
-   
- !   // Deallocate the arrays.  <co id="tutorial-hand_coded-doof2d-deallocation"></co>
- !   for (int i = 0; i &lt; n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- ***************
- *** 73,74 ****
- --- 74,76 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d-Field-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Field-distributed-annotated.patch
diff -N Doof2d-Field-distributed-annotated.patch
*** /tmp/cvswwII7S	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,176 ****
- *** Doof2d-Field-distributed.cpp	Wed Dec  5 14:05:10 2001
- --- Doof2d-Field-distributed-annotated.cpp	Wed Dec  5 14:41:24 2001
- ***************
- *** 1,3 ****
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Fields.h"	// has Pooma's Field
-   
- --- 1,4 ----
- ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Fields.h"	// has Pooma's Field
-   
- ***************
- *** 12,16 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 13,17 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  <co id="tutorial-field_distributed-doof2d-io"></co>
-     Inform output;
-   
- ***************
- *** 18,22 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
-       return EXIT_FAILURE;
-     }
- --- 19,23 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 25,33 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 26,34 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 35,39 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 36,40 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 41,50 ****
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- --- 42,51 ----
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- ***************
- *** 52,74 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.
- !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
- ! 				    GuardLayers<2>(1),  // internal
- ! 				    GuardLayers<2>(0)); // external
- !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
- !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
-   
-     // The template parameters indicate a mesh and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
- !     Remote<Brick> > > a(cell, layout, mesh);
- !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
- !     Remote<Brick> > > b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 53,75 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.  <co id="tutorial-field_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  <co id="tutorial-field_distributed-doof2d-mesh"></co>
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // The template parameters indicate a mesh and a 'double'
-     // element type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 83,87 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- --- 84,88 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- ***************
- *** 99,103 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The fields are automatically deallocated.
- --- 100,104 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 107,108 ****
- --- 108,110 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d-Field-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Field-parallel-annotated.patch
diff -N Doof2d-Field-parallel-annotated.patch
*** /tmp/cvsOaLly1	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,120 ****
- *** Doof2d-Field-parallel.cpp	Tue Dec  4 10:01:28 2001
- --- Doof2d-Field-parallel-annotated.cpp	Tue Dec  4 11:04:26 2001
- ***************
- *** 1,5 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
- ! #include "Pooma/Fields.h"	// has Pooma's Field
-   
-   // Doof2d: Pooma Fields, data-parallel implementation
- --- 1,6 ----
- ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include "Pooma/Fields.h"	// has Pooma's Field  <co id="tutorial-field_parallel-doof2d-header"></co>
-   
-   // Doof2d: Pooma Fields, data-parallel implementation
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,44 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the field size: ";
- !   std::cin >> n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   DomainLayout<2> layout(vertDomain);
- !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
- !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The template parameters indicate a mesh, a 'double' element
- !   // type, and ordinary 'Brick' storage.
- !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
- !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 20,45 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the field size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  <co id="tutorial-field_parallel-doof2d-mesh"></co>
- !   DomainLayout&lt;2&gt; layout(vertDomain);
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The template parameters indicate a mesh, a 'double' element
- !   // type, and ordinary 'Brick' storage.  <co id="tutorial-field_parallel-doof2d-field_creation"></co>
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 51,56 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 52,57 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-field_parallel-doof2d-first_write"></co>
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 67,71 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The fields are automatically deallocated.
- --- 68,72 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 75,76 ****
- --- 76,78 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Makefile
===================================================================
RCS file: Makefile
diff -N Makefile
*** /tmp/cvsca9QN9	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,13 ****
- ### Oldham, Jeffrey D.
- ### 2001Nov27
- ### Pooma
- ###
- ### Produce Annotated Source Code
- 
- all: Doof2d-C-element-annotated.cpp Doof2d-Array-element-annotated.cpp \
-      Doof2d-Array-parallel-annotated.cpp Doof2d-Array-stencil-annotated.cpp \
-      Doof2d-Array-distributed-annotated.cpp \
-      Doof2d-Field-parallel-annotated.cpp Doof2d-Field-distributed-annotated.cpp
- 
- %-annotated.cpp: %-annotated.patch %.cpp
- 	patch -o $@ < $<
--- 0 ----
Index: examples/initialize-finalize-annotated.patch
===================================================================
RCS file: initialize-finalize-annotated.patch
diff -N initialize-finalize-annotated.patch
*** /tmp/cvsQZFDjk	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,14 ****
- *** initialize-finalize.cpp	Sat Dec 15 15:35:57 2001
- --- initialize-finalize-annotated.cpp	Sun Dec 16 14:24:43 2001
- ***************
- *** 1,2 ****
- --- 1,3 ----
- + <programlisting id="initialize-finalize-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   
- ***************
- *** 10,11 ****
- --- 11,13 ----
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/pairs-templated-annotated.patch
===================================================================
RCS file: pairs-templated-annotated.patch
diff -N pairs-templated-annotated.patch
*** /tmp/cvsWpEoKu	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,37 ****
- *** pairs-templated.cpp	Wed Dec 26 14:01:38 2001
- --- pairs-templated-annotated.cpp	Wed Dec 26 14:12:51 2001
- ***************
- *** 1,15 ****
- ! // Declare a template class storing a pair of values with the same type.
- ! template <typename T>
-   struct pair {
- !   pair(const int& left, const int& right)
-       : left_(left), right_(right) {}
-   
- !   T left_;
-     T right_;
-   };
-   
- ! // Use a class storing a pair of integers.
- ! pair<int> pair1;
-   
-   // Use a class storing a pair of doubles;
- ! pair<double> pair2;
- --- 1,17 ----
- ! <programlisting id="template_programming-template_use-templated_pair_program" linenumbering="numbered" format="linespecific">
- ! // Declare a template class storing a pair of values with the same type.  <co id="template_programming-template_use-templated_pair_program-template_declaration"></co>
- ! template &lt;typename T&gt;
-   struct pair {
- !   pair(const T&amp; left, const T&amp; right)  // <co id="template_programming-template_use-templated_pair_program-constructor"></co>
-       : left_(left), right_(right) {}
-   
- !   T left_;  // <co id="template_programming-template_use-templated_pair_program-members"></co>
-     T right_;
-   };
-   
- ! // Use a class storing a pair of integers. <co id="template_programming-template_use-templated_pair_program-use"></co>
- ! pair&lt;int&gt; pair1;
-   
-   // Use a class storing a pair of doubles;
- ! pair&lt;double&gt; pair2;
- ! </programlisting>
--- 0 ----
Index: examples/pairs-untemplated-annotated.patch
===================================================================
RCS file: pairs-untemplated-annotated.patch
diff -N pairs-untemplated-annotated.patch
*** /tmp/cvse4E61E	Thu Jan 24 20:22:23 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,35 ****
- *** pairs-untemplated.cpp	Wed Dec 26 13:48:10 2001
- --- pairs-untemplated-annotated.cpp	Wed Dec 26 14:02:58 2001
- ***************
- *** 1,5 ****
-   // Declare a class storing a pair of integers.
-   struct pairOfInts {
- !   pairOfInts(const int& left, const int& right)
-       : left_(left), right_(right) {}
-   
- --- 1,6 ----
- + <programlisting id="template_programming-template_use-untemplated_pair_program" linenumbering="numbered" format="linespecific">
-   // Declare a class storing a pair of integers.
-   struct pairOfInts {
- !   pairOfInts(const int&amp; left, const int&amp; right)
-       : left_(left), right_(right) {}
-   
- ***************
- *** 10,14 ****
-   // Declare a class storing a pair of doubles.
-   struct pairOfDoubles {
- !   pairOfDoubles(const double& left, const double& right)
-       : left_(left), right_(right) {}
-   
- --- 11,15 ----
-   // Declare a class storing a pair of doubles.
-   struct pairOfDoubles {
- !   pairOfDoubles(const double&amp; left, const double&amp; right)
-       : left_(left), right_(right) {}
-   
- ***************
- *** 16,17 ****
- --- 17,19 ----
-     double right_;
-   };
- + </programlisting>
--- 0 ----
Index: examples/Doof2d/Doof2d-Array-distributed-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Doof2d-Array-distributed-annotated.patch,v
retrieving revision 1.4
diff -c -p -r1.4 Doof2d-Array-distributed-annotated.patch
*** examples/Doof2d/Doof2d-Array-distributed-annotated.patch	2002/01/04 18:00:02	1.4
--- examples/Doof2d/Doof2d-Array-distributed-annotated.patch	2002/01/25 03:22:23
***************
*** 3,15 ****
  ***************
  *** 1,3 ****
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has Pooma's Array
    
  --- 1,5 ----
  ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has Pooma's Array
    
  ***************
  *** 14,18 ****
--- 3,15 ----
  ***************
  *** 1,3 ****
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
  --- 1,5 ----
  ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
  ***************
  *** 14,18 ****
***************
*** 117,124 ****
  ! 				    GuardLayers<2>(0)); // external
  !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
    
!     // The template parameters indicate 2 dimensions and a 'double'
!     // element type.  MultiPatch indicates multiple computation patches,
      // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.
  !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
--- 117,124 ----
  ! 				    GuardLayers<2>(0)); // external
  !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
    
!     // The Array template parameters indicate 2 dimensions and a 'double'
!     // value type.  MultiPatch indicates multiple computation patches,
      // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.
  !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
***************
*** 134,141 ****
  ! 				    GuardLayers&lt;2&gt;(0)); // external
  !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
    
!     // The template parameters indicate 2 dimensions and a 'double'
!     // element type.  MultiPatch indicates multiple computation patches,
      // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
  !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
--- 134,141 ----
  ! 				    GuardLayers&lt;2&gt;(0)); // external
  !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
    
!     // The Array template parameters indicate 2 dimensions and a 'double'
!     // value type.  MultiPatch indicates multiple computation patches,
      // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
  !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
Index: examples/Doof2d/Doof2d-Array-element-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Doof2d-Array-element-annotated.patch,v
retrieving revision 1.4
diff -c -p -r1.4 Doof2d-Array-element-annotated.patch
*** examples/Doof2d/Doof2d-Array-element-annotated.patch	2002/01/04 18:00:02	1.4
--- examples/Doof2d/Doof2d-Array-element-annotated.patch	2002/01/25 03:22:23
***************
*** 1,24 ****
  *** Doof2d-Array-element.cpp	Tue Dec  4 12:02:10 2001
! --- Doof2d-Array-element-annotated.cpp	Tue Dec  4 12:24:25 2001
  ***************
  *** 1,5 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"	// has Pooma's Array
    
!   // Doof2d: Pooma Arrays, element-wise implementation
  --- 1,6 ----
  ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"	// has Pooma's Array  <co id="tutorial-array_elementwise-doof2d-header"></co>
    
!   // Doof2d: Pooma Arrays, element-wise implementation
  ***************
  *** 7,17 ****
    int main(int argc, char *argv[])
    {
! !   // Prepare the Pooma library for execution.
      Pooma::initialize(argc,argv);
      
      // Ask the user for the number of averagings.
--- 1,24 ----
  *** Doof2d-Array-element.cpp	Tue Dec  4 12:02:10 2001
! --- Doof2d-Array-element-annotated.cpp	Wed Jan 23 16:35:29 2002
  ***************
  *** 1,5 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
!   // Doof2d: POOMA Arrays, element-wise implementation
  --- 1,6 ----
  ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations  <co id="tutorial-array_elementwise-doof2d-header"></co>
    
!   // Doof2d: POOMA Arrays, element-wise implementation
  ***************
  *** 7,17 ****
    int main(int argc, char *argv[])
    {
! !   // Prepare the POOMA library for execution.
      Pooma::initialize(argc,argv);
      
      // Ask the user for the number of averagings.
***************
*** 30,36 ****
  --- 8,18 ----
    int main(int argc, char *argv[])
    {
! !   // Prepare the Pooma library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
      Pooma::initialize(argc,argv);
      
      // Ask the user for the number of averagings.
--- 30,36 ----
  --- 8,18 ----
    int main(int argc, char *argv[])
    {
! !   // Prepare the POOMA library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
      Pooma::initialize(argc,argv);
      
      // Ask the user for the number of averagings.
***************
*** 51,57 ****
  !   Interval<2> vertDomain(N, N);
    
  !   // Create the arrays.
!     // The template parameters indicate 2 dimensions, a 'double' element
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
--- 51,57 ----
  !   Interval<2> vertDomain(N, N);
    
  !   // Create the arrays.
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
***************
*** 71,77 ****
  !   Interval&lt;2&gt; vertDomain(N, N);
    
  !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
!     // The template parameters indicate 2 dimensions, a 'double' element
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
--- 71,77 ----
  !   Interval&lt;2&gt; vertDomain(N, N);
    
  !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
***************
*** 124,130 ****
    
  !   // The arrays are automatically deallocated.
    
! !   // Tell the Pooma library execution has finished.
      Pooma::finalize();
      return EXIT_SUCCESS;
    }
--- 124,130 ----
    
  !   // The arrays are automatically deallocated.
    
! !   // Tell the POOMA library execution has finished.
      Pooma::finalize();
      return EXIT_SUCCESS;
    }
***************
*** 136,142 ****
    
  !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
    
! !   // Tell the Pooma library execution has finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
      Pooma::finalize();
      return EXIT_SUCCESS;
    }
--- 136,142 ----
    
  !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
    
! !   // Tell the POOMA library execution has finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
      Pooma::finalize();
      return EXIT_SUCCESS;
    }
Index: examples/Doof2d/Doof2d-Array-parallel-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Doof2d-Array-parallel-annotated.patch,v
retrieving revision 1.4
diff -c -p -r1.4 Doof2d-Array-parallel-annotated.patch
*** examples/Doof2d/Doof2d-Array-parallel-annotated.patch	2002/01/04 18:00:02	1.4
--- examples/Doof2d/Doof2d-Array-parallel-annotated.patch	2002/01/25 03:22:23
***************
*** 1,16 ****
  *** Doof2d-Array-parallel.cpp	Tue Dec  4 11:49:43 2001
! --- Doof2d-Array-parallel-annotated.cpp	Tue Dec  4 12:24:36 2001
  ***************
  *** 1,4 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has Pooma's Array
    
  --- 1,5 ----
  ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has Pooma's Array
    
  ***************
  *** 12,17 ****
--- 1,16 ----
  *** Doof2d-Array-parallel.cpp	Tue Dec  4 11:49:43 2001
! --- Doof2d-Array-parallel-annotated.cpp	Wed Jan 23 16:35:54 2002
  ***************
  *** 1,4 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
  --- 1,5 ----
  ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
  ***************
  *** 12,17 ****
***************
*** 43,49 ****
  !   Interval<1> J(1,n-2);
    
      // Create the arrays.
!     // The template parameters indicate 2 dimensions, a 'double' element
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
--- 43,49 ----
  !   Interval<1> J(1,n-2);
    
      // Create the arrays.
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
***************
*** 69,75 ****
  !   Interval&lt;1&gt; J(1,n-2);
    
      // Create the arrays.
!     // The template parameters indicate 2 dimensions, a 'double' element
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
--- 69,75 ----
  !   Interval&lt;1&gt; J(1,n-2);
    
      // Create the arrays.
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
Index: examples/Doof2d/Doof2d-Array-stencil-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Doof2d-Array-stencil-annotated.patch,v
retrieving revision 1.4
diff -c -p -r1.4 Doof2d-Array-stencil-annotated.patch
*** examples/Doof2d/Doof2d-Array-stencil-annotated.patch	2002/01/04 18:00:02	1.4
--- examples/Doof2d/Doof2d-Array-stencil-annotated.patch	2002/01/25 03:22:23
***************
*** 1,12 ****
  *** Doof2d-Array-stencil.cpp	Tue Dec  4 11:49:39 2001
! --- Doof2d-Array-stencil-annotated.cpp	Tue Dec  4 12:26:46 2001
  ***************
  *** 1,9 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has Pooma's Array
    
!   // Doof2d: Pooma Arrays, stencil implementation
    
  ! // Define the stencil class performing the computation.
    class DoofNinePt
--- 1,12 ----
  *** Doof2d-Array-stencil.cpp	Tue Dec  4 11:49:39 2001
! --- Doof2d-Array-stencil-annotated.cpp	Wed Jan 23 16:36:15 2002
  ***************
  *** 1,9 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
!   // Doof2d: POOMA Arrays, stencil implementation
    
  ! // Define the stencil class performing the computation.
    class DoofNinePt
***************
*** 15,23 ****
  ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has Pooma's Array
    
!   // Doof2d: Pooma Arrays, stencil implementation
    
  ! // Define the stencil class performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
    class DoofNinePt
--- 15,23 ----
  ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
!   // Doof2d: POOMA Arrays, stencil implementation
    
  ! // Define the stencil class performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
    class DoofNinePt
***************
*** 81,87 ****
  !   Interval<2> interiorDomain(I,I);
    
      // Create the arrays.
!     // The template parameters indicate 2 dimensions, a 'double' element
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
--- 81,87 ----
  !   Interval<2> interiorDomain(I,I);
    
      // Create the arrays.
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
***************
*** 102,108 ****
  !   Interval&lt;2&gt; interiorDomain(I,I);
    
      // Create the arrays.
!     // The template parameters indicate 2 dimensions, a 'double' element
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
--- 102,108 ----
  !   Interval&lt;2&gt; interiorDomain(I,I);
    
      // Create the arrays.
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
Index: examples/Doof2d/Doof2d-C-element-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Doof2d-C-element-annotated.patch,v
retrieving revision 1.4
diff -c -p -r1.4 Doof2d-C-element-annotated.patch
*** examples/Doof2d/Doof2d-C-element-annotated.patch	2002/01/04 18:00:02	1.4
--- examples/Doof2d/Doof2d-C-element-annotated.patch	2002/01/25 03:22:23
***************
*** 1,5 ****
! *** Doof2d-C-element.cpp	Tue Nov 27 08:36:38 2001
! --- Doof2d-C-element-annotated.cpp	Tue Nov 27 12:08:03 2001
  ***************
  *** 1,4 ****
  ! #include <iostream>		// has std::cout, ...
--- 1,5 ----
! *** Doof2d-C-element.cpp	Tue Dec  4 09:59:18 2001
! --- Doof2d-C-element-annotated.cpp	Wed Jan 23 16:34:20 2002
  ***************
  *** 1,4 ****
  ! #include <iostream>		// has std::cout, ...
***************
*** 26,32 ****
      double **a;
      double **b;
    
!     // Ask the user for the number n of elements along one dimension of
  !   // the grid.
      long n;
  !   std::cout << "Please enter the array size: ";
--- 26,32 ----
      double **a;
      double **b;
    
!     // Ask the user for the number n of values along one dimension of
  !   // the grid.
      long n;
  !   std::cout << "Please enter the array size: ";
***************
*** 52,58 ****
      double **a;
      double **b;
    
!     // Ask the user for the number n of elements along one dimension of
  !   // the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
      long n;
  !   std::cout &openopen; "Please enter the array size: ";
--- 52,58 ----
      double **a;
      double **b;
    
!     // Ask the user for the number n of values along one dimension of
  !   // the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
      long n;
  !   std::cout &openopen; "Please enter the array size: ";
Index: examples/Doof2d/Doof2d-Field-distributed-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Doof2d-Field-distributed-annotated.patch,v
retrieving revision 1.3
diff -c -p -r1.3 Doof2d-Field-distributed-annotated.patch
*** examples/Doof2d/Doof2d-Field-distributed-annotated.patch	2002/01/04 18:00:02	1.3
--- examples/Doof2d/Doof2d-Field-distributed-annotated.patch	2002/01/25 03:22:23
***************
*** 1,14 ****
  *** Doof2d-Field-distributed.cpp	Wed Dec  5 14:05:10 2001
! --- Doof2d-Field-distributed-annotated.cpp	Wed Dec  5 14:41:24 2001
  ***************
  *** 1,3 ****
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Fields.h"	// has Pooma's Field
    
  --- 1,4 ----
  ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Fields.h"	// has Pooma's Field
    
  ***************
  *** 12,16 ****
--- 1,14 ----
  *** Doof2d-Field-distributed.cpp	Wed Dec  5 14:05:10 2001
! --- Doof2d-Field-distributed-annotated.cpp	Wed Jan 23 16:36:34 2002
  ***************
  *** 1,3 ****
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Fields.h"	// has POOMA's Field declarations
    
  --- 1,4 ----
  ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Fields.h"	// has POOMA's Field declarations
    
  ***************
  *** 12,16 ****
***************
*** 108,115 ****
  !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
  !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
    
!     // The template parameters indicate a mesh and a 'double'
!     // element type.  MultiPatch indicates multiple computation patches,
      // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.
  !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
--- 108,115 ----
  !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
  !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
    
!     // The Field template parameters indicate a mesh and a 'double'
!     // value type.  MultiPatch indicates multiple computation patches,
      // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.
  !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
***************
*** 132,139 ****
  !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
  !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
    
!     // The template parameters indicate a mesh and a 'double'
!     // element type.  MultiPatch indicates multiple computation patches,
      // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
  !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
--- 132,139 ----
  !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
  !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
    
!     // The Field template parameters indicate a mesh and a 'double'
!     // value type.  MultiPatch indicates multiple computation patches,
      // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
  !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
Index: examples/Doof2d/Doof2d-Field-parallel-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Doof2d-Field-parallel-annotated.patch,v
retrieving revision 1.3
diff -c -p -r1.3 Doof2d-Field-parallel-annotated.patch
*** examples/Doof2d/Doof2d-Field-parallel-annotated.patch	2002/01/04 18:00:02	1.3
--- examples/Doof2d/Doof2d-Field-parallel-annotated.patch	2002/01/25 03:22:23
***************
*** 1,19 ****
! *** Doof2d-Field-parallel.cpp	Tue Dec  4 10:01:28 2001
! --- Doof2d-Field-parallel-annotated.cpp	Tue Dec  4 11:04:26 2001
  ***************
  *** 1,5 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
! ! #include "Pooma/Fields.h"	// has Pooma's Field
    
!   // Doof2d: Pooma Fields, data-parallel implementation
  --- 1,6 ----
  ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Fields.h"	// has Pooma's Field  <co id="tutorial-field_parallel-doof2d-header"></co>
    
!   // Doof2d: Pooma Fields, data-parallel implementation
  ***************
  *** 12,17 ****
      // Ask the user for the number of averagings.
--- 1,19 ----
! *** Doof2d-Field-parallel.cpp	Tue Dec  4 11:47:58 2001
! --- Doof2d-Field-parallel-annotated.cpp	Wed Jan 23 16:37:19 2002
  ***************
  *** 1,5 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
! ! #include "Pooma/Fields.h"	// has POOMA's Field declarations
    
!   // Doof2d: POOMA Fields, data-parallel implementation
  --- 1,6 ----
  ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Fields.h"	// has POOMA's Field declarations  <co id="tutorial-field_parallel-doof2d-header"></co>
    
!   // Doof2d: POOMA Fields, data-parallel implementation
  ***************
  *** 12,17 ****
      // Ask the user for the number of averagings.
***************
*** 51,57 ****
  !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
    
      // Create the fields.
!     // The template parameters indicate a mesh, a 'double' element
  !   // type, and ordinary 'Brick' storage.
  !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
  !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
--- 51,57 ----
  !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
    
      // Create the fields.
!     // The Field template parameters indicate a mesh, a 'double' value
  !   // type, and ordinary 'Brick' storage.
  !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
  !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
***************
*** 78,98 ****
  !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
    
      // Create the fields.
!     // The template parameters indicate a mesh, a 'double' element
  !   // type, and ordinary 'Brick' storage.  <co id="tutorial-field_parallel-doof2d-field_creation"></co>
  !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
  !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
    
      // Set up the initial conditions.
  ***************
! *** 51,56 ****
    
      // Perform the simulation.
  !   for (int k = 0; k < nuIterations; ++k) {
  !     // Read from b.  Write to a.
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
! --- 52,57 ----
    
      // Perform the simulation.
  !   for (int k = 0; k &lt; nuIterations; ++k) {
--- 78,98 ----
  !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
    
      // Create the fields.
!     // The Field template parameters indicate a mesh, a 'double' value
  !   // type, and ordinary 'Brick' storage.  <co id="tutorial-field_parallel-doof2d-field_creation"></co>
  !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
  !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
    
      // Set up the initial conditions.
  ***************
! *** 53,58 ****
    
      // Perform the simulation.
  !   for (int k = 0; k < nuIterations; ++k) {
  !     // Read from b.  Write to a.
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
! --- 54,59 ----
    
      // Perform the simulation.
  !   for (int k = 0; k &lt; nuIterations; ++k) {
***************
*** 100,120 ****
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
  ***************
! *** 67,71 ****
      // Print out the final central value.
      Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The fields are automatically deallocated.
! --- 68,72 ----
      // Print out the final central value.
      Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
    
      // The fields are automatically deallocated.
  ***************
! *** 75,76 ****
! --- 76,78 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
--- 100,120 ----
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
  ***************
! *** 69,73 ****
      // Print out the final central value.
      Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The fields are automatically deallocated.
! --- 70,74 ----
      // Print out the final central value.
      Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
    
      // The fields are automatically deallocated.
  ***************
! *** 77,78 ****
! --- 78,80 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
Index: examples/Sequential/array-copy-annotated.patch
===================================================================
RCS file: array-copy-annotated.patch
diff -N array-copy-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- array-copy-annotated.patch	Thu Jan 24 20:22:23 2002
***************
*** 0 ****
--- 1,77 ----
+ *** array-copy.cpp	Thu Jan 24 11:12:23 2002
+ --- array-copy-annotated.cpp	Thu Jan 24 11:12:49 2002
+ ***************
+ *** 1,8 ****
+   #include "Pooma/Pooma.h"
+   #include "Pooma/Arrays.h"
+ ! #include <iostream>
+   
+   // Changes the Array value at index (0,0).
+ ! void changeValue(Array<2,int,Brick>& z)
+   { z(0,0) = 6; }
+   
+ --- 1,9 ----
+ + <programlisting id="array-copy-program" linenumbering="numbered" format="linespecific">
+   #include "Pooma/Pooma.h"
+   #include "Pooma/Arrays.h"
+ ! #include &lt;iostream&gt;
+   
+   // Changes the Array value at index (0,0).
+ ! void changeValue(Array&lt;2,int,Brick&gt;&amp; z)
+   { z(0,0) = 6; }
+   
+ ***************
+ *** 11,17 ****
+     Pooma::initialize(argc,argv);
+   
+ !   Array<2,int,Brick> a(3,4, ModelElement<int>(4));
+ !   std::cout << "Initial value:\n";
+ !   std::cout << "a: " << a(0,0) << std::endl;
+   
+     // Array copies share the same underlying values.
+ --- 12,18 ----
+     Pooma::initialize(argc,argv);
+   
+ !   Array&lt;2,int,Brick&gt; a(3,4, ModelElement&lt;int&gt;(4));
+ !   std::cout &openopen; "Initial value:\n";
+ !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
+   
+     // Array copies share the same underlying values.
+ ***************
+ *** 19,35 ****
+     // Explicit initialization uses reference semantics so changing the
+     // copy's value at (0,0) also changes the original's value.
+ !   Array<2,int,Brick> b(a);
+     b(0,0) = 5;
+ !   std::cout << "After explicit initialization.\n";
+ !   std::cout << "a: " << a(0,0) << std::endl;
+ !   std::cout << "b: " << b(0,0) << std::endl;
+   
+     // Initialization of function arguments also uses reference semantics.
+ !   std::cout << "After function call:\n";
+     changeValue(a);
+ !   std::cout << "a: " << a(0,0) << std::endl;
+ !   std::cout << "b: " << b(0,0) << std::endl;
+   
+     Pooma::finalize();
+     return 0;
+   }
+ --- 20,37 ----
+     // Explicit initialization uses reference semantics so changing the
+     // copy's value at (0,0) also changes the original's value.
+ !   Array&lt;2,int,Brick&gt; b(a);
+     b(0,0) = 5;
+ !   std::cout &openopen; "After explicit initialization.\n";
+ !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
+ !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
+   
+     // Initialization of function arguments also uses reference semantics.
+ !   std::cout &openopen; "After function call:\n";
+     changeValue(a);
+ !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
+ !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
+   
+     Pooma::finalize();
+     return 0;
+   }
+ + </programlisting>
Index: examples/Sequential/array-size-annotated.patch
===================================================================
RCS file: array-size-annotated.patch
diff -N array-size-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- array-size-annotated.patch	Thu Jan 24 20:22:23 2002
***************
*** 0 ****
--- 1,67 ----
+ *** array-size.cpp	Tue Jan 15 12:59:40 2002
+ --- array-size-annotated.cpp	Tue Jan 15 13:30:07 2002
+ ***************
+ *** 1,5 ****
+   #include "Pooma/Pooma.h"
+   #include "Pooma/Arrays.h"
+ ! #include <iostream>
+   
+   // Print an Array's Size
+ --- 1,6 ----
+ + <programlisting id="array-size-program" linenumbering="numbered" format="linespecific">
+   #include "Pooma/Pooma.h"
+   #include "Pooma/Arrays.h"
+ ! #include &lt;iostream&gt;
+   
+   // Print an Array's Size
+ ***************
+ *** 10,22 ****
+   // member functions.
+   
+ ! template <int Dim, typename Type, typename EngineTag>
+   inline
+ ! long computeArraySize(const Array<Dim,Type,EngineTag>& a)
+   {
+ !   const Loc<Dim> fs = a.firsts();
+ !   const Loc<Dim> ls = a.lasts();
+ !   const Loc<Dim> lens = a.lengths();
+     long size = 1;
+ !   for (int d = 0; d < Dim; ++d) {
+       size *= (ls[d] - fs[d] + 1).first();
+       // Check that lengths() and our computed lengths agree.
+ --- 11,23 ----
+   // member functions.
+   
+ ! template &lt;int Dim, typename Type, typename EngineTag&gt;
+   inline
+ ! long computeArraySize(const Array&lt;Dim,Type,EngineTag&gt;&amp; a)
+   {
+ !   const Loc&lt;Dim&gt; fs = a.firsts();
+ !   const Loc&lt;Dim&gt; ls = a.lasts();
+ !   const Loc&lt;Dim&gt; lens = a.lengths();
+     long size = 1;
+ !   for (int d = 0; d &lt; Dim; ++d) {
+       size *= (ls[d] - fs[d] + 1).first();
+       // Check that lengths() and our computed lengths agree.
+ ***************
+ *** 30,38 ****
+     Pooma::initialize(argc,argv);
+   
+ !   Array<3,int,Brick> a(3,4,5, ModelElement<int>(4));
+     PAssert(computeArraySize(a) == a.size());
+ !   std::cout << "The array's size is " << a.size() << ".\n";
+   
+     Pooma::finalize();
+     return 0;
+   }
+ --- 31,40 ----
+     Pooma::initialize(argc,argv);
+   
+ !   Array&lt;3,int,Brick&gt; a(3,4,5, ModelElement&lt;int&gt;(4));
+     PAssert(computeArraySize(a) == a.size());
+ !   std::cout &openopen; "The array's size is " &openopen; a.size() &openopen; ".\n";
+   
+     Pooma::finalize();
+     return 0;
+   }
+ + </programlisting>
Index: examples/Sequential/dynamicarray-annotated.patch
===================================================================
RCS file: dynamicarray-annotated.patch
diff -N dynamicarray-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- dynamicarray-annotated.patch	Thu Jan 24 20:22:23 2002
***************
*** 0 ****
--- 1,80 ----
+ *** dynamicarray.cpp	Mon Jan 21 17:29:38 2002
+ --- dynamicarray-annotated.cpp	Tue Jan 22 07:06:15 2002
+ ***************
+ *** 1,5 ****
+   #include "Pooma/Pooma.h"
+ ! #include "Pooma/DynamicArrays.h"
+ ! #include <iostream>
+   
+   // Demonstrate using DynamicArrays.
+ --- 1,6 ----
+ + <programlisting id="dynamicarray-program" linenumbering="numbered" format="linespecific">
+   #include "Pooma/Pooma.h"
+ ! #include "Pooma/DynamicArrays.h"  <co id="arrays-dynamic_arrays-example-header"></co>
+ ! #include &lt;iostream&gt;
+   
+   // Demonstrate using DynamicArrays.
+ ***************
+ *** 9,38 ****
+     Pooma::initialize(argc,argv);
+   
+ !   // Create a DynamicArray with one element.
+ !   DynamicArray<> d0(1);
+ !   DynamicArray<double> d01(1);
+ !   DynamicArray<double, Dynamic> d02(1);
+   
+ !   // Add five more elements.
+     d0.create(5);
+     // Store values in the array.
+ !   for (int i = d0.domain().first(); i <= d0.domain().last(); ++i)
+ !     d0(i) = i;
+   
+ !   // Delete every other element.
+ !   d0.destroy(Range<1>(d0.domain().first(),d0.domain().last(),2), BackFill());
+   
+     // Print the resulting array.
+ !   std::cout << d0 << std::endl;
+   
+     // Use the iterator form of 'destroy.'
+ !   DynamicArray<> d1(6);
+     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
+       d1(i) = i;
+ !   int killList[] = { 0, 2, 4 };
+     d1.destroy(killList, killList+3);
+ !   std::cout << d1 << std::endl;
+   
+     Pooma::finalize();
+     return 0;
+   }
+ --- 10,40 ----
+     Pooma::initialize(argc,argv);
+   
+ !   // Create a DynamicArray with one element.  <co id="arrays-dynamic_arrays-example-identical_declarations"></co>
+ !   DynamicArray&lt;&gt; d0(1);
+ !   DynamicArray&lt;double&gt; d01(1);
+ !   DynamicArray&lt;double, Dynamic&gt; d02(1);
+   
+ !   // Add five more elements.  <co id="arrays-dynamic_arrays-example-extension"></co>
+     d0.create(5);
+     // Store values in the array.
+ !   for (int i = d0.domain().first(); i &lt;= d0.domain().last(); ++i)
+ !     d0(i) = i;  <co id="arrays-dynamic_arrays-example-access"></co>
+   
+ !   // Delete every other element.  <co id="arrays-dynamic_arrays-example-destroy_range"></co>
+ !   d0.destroy(Range&lt;1&gt;(d0.domain().first(),d0.domain().last(),2), BackFill());
+   
+     // Print the resulting array.
+ !   std::cout &openopen; d0 &openopen; std::endl;
+   
+     // Use the iterator form of 'destroy.'
+ !   DynamicArray<&gt; d1(6);
+     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
+       d1(i) = i;
+ !   int killList[] = { 0, 2, 4 };  <co id="arrays-dynamic_arrays-example-destroy_iterators"></co>
+     d1.destroy(killList, killList+3);
+ !   std::cout &openopen; d1 &openopen; std::endl;
+   
+     Pooma::finalize();
+     return 0;
+   }
+ + </programlisting>
Index: examples/Sequential/initialize-finalize-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/initialize-finalize-annotated.patch,v
retrieving revision 1.1
diff -c -p -r1.1 initialize-finalize-annotated.patch
*** examples/Sequential/initialize-finalize-annotated.patch	2002/01/04 18:00:02	1.1
--- examples/Sequential/initialize-finalize-annotated.patch	2002/01/25 03:22:23
***************
*** 1,14 ****
! *** initialize-finalize.cpp	Sat Dec 15 15:35:57 2001
! --- initialize-finalize-annotated.cpp	Sun Dec 16 14:24:43 2001
  ***************
! *** 1,2 ****
! --- 1,3 ----
  + <programlisting id="initialize-finalize-program" linenumbering="numbered" format="linespecific">
    #include "Pooma/Pooma.h"
    
  ***************
! *** 10,11 ****
! --- 11,13 ----
      return 0;
    }
  + </programlisting>
--- 1,20 ----
! *** initialize-finalize.cpp	Thu Jan 24 11:14:13 2002
! --- initialize-finalize-annotated.cpp	Thu Jan 24 11:14:17 2002
  ***************
! *** 1,4 ****
!   #include "Pooma/Pooma.h"
! ! #include <iostream>
!   
!   int main(int argc, char *argv[])
! --- 1,5 ----
  + <programlisting id="initialize-finalize-program" linenumbering="numbered" format="linespecific">
    #include "Pooma/Pooma.h"
+ ! #include &lt;iostream&gt;
    
+   int main(int argc, char *argv[])
  ***************
! *** 11,12 ****
! --- 12,14 ----
      return 0;
    }
  + </programlisting>
Index: examples/Templates/pairs-templated-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/pairs-templated-annotated.patch,v
retrieving revision 1.1
diff -c -p -r1.1 pairs-templated-annotated.patch
*** examples/Templates/pairs-templated-annotated.patch	2002/01/04 18:00:02	1.1
--- examples/Templates/pairs-templated-annotated.patch	2002/01/25 03:22:23
***************
*** 1,8 ****
! *** pairs-templated.cpp	Wed Dec 26 14:01:38 2001
! --- pairs-templated-annotated.cpp	Wed Dec 26 14:12:51 2001
  ***************
  *** 1,15 ****
! ! // Declare a template class storing a pair of values with the same type.
  ! template <typename T>
    struct pair {
  !   pair(const int& left, const int& right)
--- 1,8 ----
! *** pairs-templated.cpp	Mon Jan  7 16:11:56 2002
! --- pairs-templated-annotated.cpp	Wed Jan 23 12:33:13 2002
  ***************
  *** 1,15 ****
!   // Declare a template class storing a pair of values with the same type.
  ! template <typename T>
    struct pair {
  !   pair(const int& left, const int& right)
***************
*** 12,26 ****
      T right_;
    };
    
! ! // Use a class storing a pair of integers.
  ! pair<int> pair1;
    
!   // Use a class storing a pair of doubles;
  ! pair<double> pair2;
  --- 1,17 ----
! ! <programlisting id="template_programming-template_use-templated_pair_program" linenumbering="numbered" format="linespecific">
! ! // Declare a template class storing a pair of values with the same type.  <co id="template_programming-template_use-templated_pair_program-template_declaration"></co>
! ! template &lt;typename T&gt;
    struct pair {
  !   pair(const T&amp; left, const T&amp; right)  // <co id="template_programming-template_use-templated_pair_program-constructor"></co>
        : left_(left), right_(right) {}
--- 12,26 ----
      T right_;
    };
    
! ! // Define a class storing a pair of integers.
  ! pair<int> pair1;
    
! ! // Define a class storing a pair of doubles;
  ! pair<double> pair2;
  --- 1,17 ----
! + <programlisting id="template_programming-template_use-templated_pair_program" linenumbering="numbered" format="linespecific">
!   // Declare a template class storing a pair of values with the same type.
! ! template &lt;typename T&gt;  // <co id="template_programming-template_use-templated_pair_program-template_declaration"></co>
    struct pair {
  !   pair(const T&amp; left, const T&amp; right)  // <co id="template_programming-template_use-templated_pair_program-constructor"></co>
        : left_(left), right_(right) {}
***************
*** 32,37 ****
  ! // Use a class storing a pair of integers. <co id="template_programming-template_use-templated_pair_program-use"></co>
  ! pair&lt;int&gt; pair1;
    
!   // Use a class storing a pair of doubles;
  ! pair&lt;double&gt; pair2;
  ! </programlisting>
--- 32,37 ----
  ! // Use a class storing a pair of integers. <co id="template_programming-template_use-templated_pair_program-use"></co>
  ! pair&lt;int&gt; pair1;
    
! ! // Use a class storing a pair of doubles;
  ! pair&lt;double&gt; pair2;
  ! </programlisting>

From oldham at mail.codesourcery.com  Fri Jan 25 03:48:27 2002
From: oldham at mail.codesourcery.com (Jeffrey)
Date: Thu, 24 Jan 2002 19:48:27 -0800
Subject: Manual: Illustrative Programs
Message-ID: <20020124194827.A732@vaio.codesourcery.com>

This file hopefully saves all the POOMA programs illustrated in the
POOMA manual.

2002-Jan-24  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* Doof2d/Doof2d-Array-distributed.cpp: Minor comment changes.
	s/element/value/g.  s/Pooma/POOMA/ in comment.
	* Doof2d/Doof2d-Array-element.cpp: Likewise.
	* Doof2d/Doof2d-Array-parallel.cpp: Likewise.
	* Doof2d/Doof2d-Array-stencil.cpp: Likewise.
	* Doof2d/Doof2d-C-element.cpp: Likewise.
	* Doof2d/Doof2d-Field-distributed.cpp: Likewise.
	* Doof2d/Doof2d-Field-parallel.cpp: Likewise.
	* Sequential/array-copy.cpp: New file indicating Array copy
	reference semantics.
	* Sequential/array-size.cpp: New file illustrating use of Array
	member functions.
	* Sequential/data-parallel.cpp: New file illustrating use of data
	parallel expressions.
	* Sequential/dynamicarray.cpp: New file illustrating changing
	domains.
	* Sequential/initialize-finalize.cpp: New file illustrating
	simplest POOMA program.
	* Sequential/makefile: New file.
	* Templates/pairs-templated.cpp: New file demonstrating templated
	class.
	* Templates/pairs-untemplated.cpp: New file with untemplated
	classes.

Applied to	mainline.
Approved by	me.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: Doof2d/Doof2d-Array-distributed.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/Manual/Doof2d/Doof2d-Array-distributed.cpp,v
retrieving revision 1.2
diff -c -p -r1.2 Doof2d-Array-distributed.cpp
*** Doof2d/Doof2d-Array-distributed.cpp	2001/12/11 19:22:32	1.2
--- Doof2d/Doof2d-Array-distributed.cpp	2002/01/25 03:36:10
***************
*** 1,7 ****
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Arrays.h"	// has Pooma's Array
  
! // Doof2d: Pooma Arrays, stencil, multiple processor implementation
  
  // Define the stencil class performing the computation.
  class DoofNinePt
--- 1,7 ----
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
  
! // Doof2d: POOMA Arrays, stencil, multiple processor implementation
  
  // Define the stencil class performing the computation.
  class DoofNinePt
*************** private:
*** 35,41 ****
  
  int main(int argc, char *argv[])
  {
!   // Prepare the Pooma library for execution.
    Pooma::initialize(argc,argv);
  
    // Since multiple copies of this program may simultaneously run, we
--- 35,41 ----
  
  int main(int argc, char *argv[])
  {
!   // Prepare the POOMA library for execution.
    Pooma::initialize(argc,argv);
  
    // Since multiple copies of this program may simultaneously run, we
*************** int main(int argc, char *argv[])
*** 61,67 ****
    nuAveragings = strtol(argv[2], &tail, 0);
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of elements along one dimension of
    // the grid.
    long n;
    n = strtol(argv[3], &tail, 0);
--- 61,67 ----
    nuAveragings = strtol(argv[2], &tail, 0);
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of values along one dimension of
    // the grid.
    long n;
    n = strtol(argv[3], &tail, 0);
*************** int main(int argc, char *argv[])
*** 88,95 ****
  				    GuardLayers<2>(0)); // external
    UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
  
!   // The template parameters indicate 2 dimensions and a 'double'
!   // element type.  MultiPatch indicates multiple computation patches,
    // i.e., distributed computation.  The UniformTag indicates the
    // patches should have the same size.  Each patch has Brick type.
    Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
--- 88,95 ----
  				    GuardLayers<2>(0)); // external
    UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
  
!   // The Array template parameters indicate 2 dimensions and a 'double'
!   // value type.  MultiPatch indicates multiple computation patches,
    // i.e., distributed computation.  The UniformTag indicates the
    // patches should have the same size.  Each patch has Brick type.
    Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
*************** int main(int argc, char *argv[])
*** 120,126 ****
  
    // The arrays are automatically deallocated.
  
!   // Tell the Pooma library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
--- 120,126 ----
  
    // The arrays are automatically deallocated.
  
!   // Tell the POOMA library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
Index: Doof2d/Doof2d-Array-element.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/Manual/Doof2d/Doof2d-Array-element.cpp,v
retrieving revision 1.2
diff -c -p -r1.2 Doof2d-Array-element.cpp
*** Doof2d/Doof2d-Array-element.cpp	2001/12/11 19:22:32	1.2
--- Doof2d/Doof2d-Array-element.cpp	2002/01/25 03:36:10
***************
*** 1,12 ****
  #include <iostream>		// has std::cout, ...
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Arrays.h"	// has Pooma's Array
  
! // Doof2d: Pooma Arrays, element-wise implementation
  
  int main(int argc, char *argv[])
  {
!   // Prepare the Pooma library for execution.
    Pooma::initialize(argc,argv);
    
    // Ask the user for the number of averagings.
--- 1,12 ----
  #include <iostream>		// has std::cout, ...
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
  
! // Doof2d: POOMA Arrays, element-wise implementation
  
  int main(int argc, char *argv[])
  {
!   // Prepare the POOMA library for execution.
    Pooma::initialize(argc,argv);
    
    // Ask the user for the number of averagings.
*************** int main(int argc, char *argv[])
*** 15,21 ****
    std::cin >> nuAveragings;
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of elements along one dimension of
    // the grid.
    long n;
    std::cout << "Please enter the array size: ";
--- 15,21 ----
    std::cin >> nuAveragings;
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of values along one dimension of
    // the grid.
    long n;
    std::cout << "Please enter the array size: ";
*************** int main(int argc, char *argv[])
*** 26,32 ****
    Interval<2> vertDomain(N, N);
  
    // Create the arrays.
!   // The template parameters indicate 2 dimensions, a 'double' element
    // type, and ordinary 'Brick' storage.
    Array<2, double, Brick> a(vertDomain);
    Array<2, double, Brick> b(vertDomain);
--- 26,32 ----
    Interval<2> vertDomain(N, N);
  
    // Create the arrays.
!   // The Array template parameters indicate 2 dimensions, a 'double' value
    // type, and ordinary 'Brick' storage.
    Array<2, double, Brick> a(vertDomain);
    Array<2, double, Brick> b(vertDomain);
*************** int main(int argc, char *argv[])
*** 65,71 ****
  
    // The arrays are automatically deallocated.
  
!   // Tell the Pooma library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
--- 65,71 ----
  
    // The arrays are automatically deallocated.
  
!   // Tell the POOMA library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
Index: Doof2d/Doof2d-Array-parallel.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/Manual/Doof2d/Doof2d-Array-parallel.cpp,v
retrieving revision 1.2
diff -c -p -r1.2 Doof2d-Array-parallel.cpp
*** Doof2d/Doof2d-Array-parallel.cpp	2001/12/11 19:22:32	1.2
--- Doof2d/Doof2d-Array-parallel.cpp	2002/01/25 03:36:10
***************
*** 1,12 ****
  #include <iostream>		// has std::cout, ...
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Arrays.h"	// has Pooma's Array
  
! // Doof2d: Pooma Arrays, data-parallel implementation
  
  int main(int argc, char *argv[])
  {
!   // Prepare the Pooma library for execution.
    Pooma::initialize(argc,argv);
    
    // Ask the user for the number of averagings.
--- 1,12 ----
  #include <iostream>		// has std::cout, ...
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
  
! // Doof2d: POOMA Arrays, data-parallel implementation
  
  int main(int argc, char *argv[])
  {
!   // Prepare the POOMA library for execution.
    Pooma::initialize(argc,argv);
    
    // Ask the user for the number of averagings.
*************** int main(int argc, char *argv[])
*** 15,21 ****
    std::cin >> nuAveragings;
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of elements along one dimension of
    // the grid.
    long n;
    std::cout << "Please enter the array size: ";
--- 15,21 ----
    std::cin >> nuAveragings;
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of values along one dimension of
    // the grid.
    long n;
    std::cout << "Please enter the array size: ";
*************** int main(int argc, char *argv[])
*** 30,36 ****
    Interval<1> J(1,n-2);
  
    // Create the arrays.
!   // The template parameters indicate 2 dimensions, a 'double' element
    // type, and ordinary 'Brick' storage.
    Array<2, double, Brick> a(vertDomain);
    Array<2, double, Brick> b(vertDomain);
--- 30,36 ----
    Interval<1> J(1,n-2);
  
    // Create the arrays.
!   // The Array template parameters indicate 2 dimensions, a 'double' value
    // type, and ordinary 'Brick' storage.
    Array<2, double, Brick> a(vertDomain);
    Array<2, double, Brick> b(vertDomain);
*************** int main(int argc, char *argv[])
*** 66,72 ****
  
    // The arrays are automatically deallocated.
  
!   // Tell the Pooma library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
--- 66,72 ----
  
    // The arrays are automatically deallocated.
  
!   // Tell the POOMA library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
Index: Doof2d/Doof2d-Array-stencil.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/Manual/Doof2d/Doof2d-Array-stencil.cpp,v
retrieving revision 1.2
diff -c -p -r1.2 Doof2d-Array-stencil.cpp
*** Doof2d/Doof2d-Array-stencil.cpp	2001/12/11 19:22:32	1.2
--- Doof2d/Doof2d-Array-stencil.cpp	2002/01/25 03:36:10
***************
*** 1,8 ****
  #include <iostream>		// has std::cout, ...
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Arrays.h"	// has Pooma's Array
  
! // Doof2d: Pooma Arrays, stencil implementation
  
  // Define the stencil class performing the computation.
  class DoofNinePt
--- 1,8 ----
  #include <iostream>		// has std::cout, ...
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
  
! // Doof2d: POOMA Arrays, stencil implementation
  
  // Define the stencil class performing the computation.
  class DoofNinePt
*************** private:
*** 36,42 ****
  
  int main(int argc, char *argv[])
  {
!   // Prepare the Pooma library for execution.
    Pooma::initialize(argc,argv);
    
    // Ask the user for the number of averagings.
--- 36,42 ----
  
  int main(int argc, char *argv[])
  {
!   // Prepare the POOMA library for execution.
    Pooma::initialize(argc,argv);
    
    // Ask the user for the number of averagings.
*************** int main(int argc, char *argv[])
*** 45,51 ****
    std::cin >> nuAveragings;
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of elements along one dimension of
    // the grid.
    long n;
    std::cout << "Please enter the array size: ";
--- 45,51 ----
    std::cin >> nuAveragings;
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of values along one dimension of
    // the grid.
    long n;
    std::cout << "Please enter the array size: ";
*************** int main(int argc, char *argv[])
*** 60,66 ****
    Interval<2> interiorDomain(I,I);
  
    // Create the arrays.
!   // The template parameters indicate 2 dimensions, a 'double' element
    // type, and ordinary 'Brick' storage.
    Array<2, double, Brick> a(vertDomain);
    Array<2, double, Brick> b(vertDomain);
--- 60,66 ----
    Interval<2> interiorDomain(I,I);
  
    // Create the arrays.
!   // The Array template parameters indicate 2 dimensions, a 'double' value
    // type, and ordinary 'Brick' storage.
    Array<2, double, Brick> a(vertDomain);
    Array<2, double, Brick> b(vertDomain);
*************** int main(int argc, char *argv[])
*** 90,96 ****
  
    // The arrays are automatically deallocated.
  
!   // Tell the Pooma library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
--- 90,96 ----
  
    // The arrays are automatically deallocated.
  
!   // Tell the POOMA library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
Index: Doof2d/Doof2d-C-element.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/Manual/Doof2d/Doof2d-C-element.cpp,v
retrieving revision 1.2
diff -c -p -r1.2 Doof2d-C-element.cpp
*** Doof2d/Doof2d-C-element.cpp	2001/12/11 19:22:32	1.2
--- Doof2d/Doof2d-C-element.cpp	2002/01/25 03:36:10
*************** int main()
*** 15,21 ****
    double **a;
    double **b;
  
!   // Ask the user for the number n of elements along one dimension of
    // the grid.
    long n;
    std::cout << "Please enter the array size: ";
--- 15,21 ----
    double **a;
    double **b;
  
!   // Ask the user for the number n of values along one dimension of
    // the grid.
    long n;
    std::cout << "Please enter the array size: ";
Index: Doof2d/Doof2d-Field-distributed.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/Manual/Doof2d/Doof2d-Field-distributed.cpp,v
retrieving revision 1.2
diff -c -p -r1.2 Doof2d-Field-distributed.cpp
*** Doof2d/Doof2d-Field-distributed.cpp	2001/12/11 19:22:32	1.2
--- Doof2d/Doof2d-Field-distributed.cpp	2002/01/25 03:36:10
***************
*** 1,11 ****
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Fields.h"	// has Pooma's Field
  
! // Doof2d: Pooma Fields, data-parallel, multiple processor implementation
  
  int main(int argc, char *argv[])
  {
!   // Prepare the Pooma library for execution.
    Pooma::initialize(argc,argv);
    
    // Since multiple copies of this program may simultaneously run, we
--- 1,11 ----
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Fields.h"	// has POOMA's Field declarations
  
! // Doof2d: POOMA Fields, data-parallel, multiple processor implementation
  
  int main(int argc, char *argv[])
  {
!   // Prepare the POOMA library for execution.
    Pooma::initialize(argc,argv);
    
    // Since multiple copies of this program may simultaneously run, we
*************** int main(int argc, char *argv[])
*** 31,37 ****
    nuAveragings = strtol(argv[2], &tail, 0);
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of elements along one dimension of
    // the grid.
    long n;
    n = strtol(argv[3], &tail, 0);
--- 31,37 ----
    nuAveragings = strtol(argv[2], &tail, 0);
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of values along one dimension of
    // the grid.
    long n;
    n = strtol(argv[3], &tail, 0);
*************** int main(int argc, char *argv[])
*** 62,69 ****
    UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
    Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
  
!   // The template parameters indicate a mesh and a 'double'
!   // element type.  MultiPatch indicates multiple computation patches,
    // i.e., distributed computation.  The UniformTag indicates the
    // patches should have the same size.  Each patch has Brick type.
    Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
--- 62,69 ----
    UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
    Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
  
!   // The Field template parameters indicate a mesh and a 'double'
!   // value type.  MultiPatch indicates multiple computation patches,
    // i.e., distributed computation.  The UniformTag indicates the
    // patches should have the same size.  Each patch has Brick type.
    Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
*************** int main(int argc, char *argv[])
*** 102,108 ****
  
    // The fields are automatically deallocated.
  
!   // Tell the Pooma library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
--- 102,108 ----
  
    // The fields are automatically deallocated.
  
!   // Tell the POOMA library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
Index: Doof2d/Doof2d-Field-parallel.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/Manual/Doof2d/Doof2d-Field-parallel.cpp,v
retrieving revision 1.2
diff -c -p -r1.2 Doof2d-Field-parallel.cpp
*** Doof2d/Doof2d-Field-parallel.cpp	2001/12/11 19:22:32	1.2
--- Doof2d/Doof2d-Field-parallel.cpp	2002/01/25 03:36:10
***************
*** 1,12 ****
  #include <iostream>		// has std::cout, ...
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Fields.h"	// has Pooma's Field
  
! // Doof2d: Pooma Fields, data-parallel implementation
  
  int main(int argc, char *argv[])
  {
!   // Prepare the Pooma library for execution.
    Pooma::initialize(argc,argv);
    
    // Ask the user for the number of averagings.
--- 1,12 ----
  #include <iostream>		// has std::cout, ...
  #include <stdlib.h>		// has EXIT_SUCCESS
! #include "Pooma/Fields.h"	// has POOMA's Field declarations
  
! // Doof2d: POOMA Fields, data-parallel implementation
  
  int main(int argc, char *argv[])
  {
!   // Prepare the POOMA library for execution.
    Pooma::initialize(argc,argv);
    
    // Ask the user for the number of averagings.
*************** int main(int argc, char *argv[])
*** 15,21 ****
    std::cin >> nuAveragings;
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of elements along one dimension of
    // the grid.
    long n;
    std::cout << "Please enter the field size: ";
--- 15,21 ----
    std::cin >> nuAveragings;
    nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
  
!   // Ask the user for the number n of values along one dimension of
    // the grid.
    long n;
    std::cout << "Please enter the field size: ";
*************** int main(int argc, char *argv[])
*** 36,42 ****
    Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
  
    // Create the fields.
!   // The template parameters indicate a mesh, a 'double' element
    // type, and ordinary 'Brick' storage.
    Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
    Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
--- 36,42 ----
    Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
  
    // Create the fields.
!   // The Field template parameters indicate a mesh, a 'double' value
    // type, and ordinary 'Brick' storage.
    Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
    Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
*************** int main(int argc, char *argv[])
*** 72,78 ****
  
    // The fields are automatically deallocated.
  
!   // Tell the Pooma library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
--- 72,78 ----
  
    // The fields are automatically deallocated.
  
!   // Tell the POOMA library execution has finished.
    Pooma::finalize();
    return EXIT_SUCCESS;
  }
Index: Sequential/array-copy.cpp
===================================================================
RCS file: array-copy.cpp
diff -N array-copy.cpp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- array-copy.cpp	Thu Jan 24 20:36:10 2002
***************
*** 0 ****
--- 1,35 ----
+ #include "Pooma/Pooma.h"
+ #include "Pooma/Arrays.h"
+ #include <iostream>
+ 
+ // Changes the Array value at index (0,0).
+ void changeValue(Array<2,int,Brick>& z)
+ { z(0,0) = 6; }
+ 
+ int main(int argc, char *argv[])
+ {
+   Pooma::initialize(argc,argv);
+ 
+   Array<2,int,Brick> a(3,4, ModelElement<int>(4));
+   std::cout << "Initial value:\n";
+   std::cout << "a: " << a(0,0) << std::endl;
+ 
+   // Array copies share the same underlying values.
+ 
+   // Explicit initialization uses reference semantics so changing the
+   // copy's value at (0,0) also changes the original's value.
+   Array<2,int,Brick> b(a);
+   b(0,0) = 5;
+   std::cout << "After explicit initialization.\n";
+   std::cout << "a: " << a(0,0) << std::endl;
+   std::cout << "b: " << b(0,0) << std::endl;
+ 
+   // Initialization of function arguments also uses reference semantics.
+   std::cout << "After function call:\n";
+   changeValue(a);
+   std::cout << "a: " << a(0,0) << std::endl;
+   std::cout << "b: " << b(0,0) << std::endl;
+ 
+   Pooma::finalize();
+   return 0;
+ }
Index: Sequential/array-size.cpp
===================================================================
RCS file: array-size.cpp
diff -N array-size.cpp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- array-size.cpp	Thu Jan 24 20:36:10 2002
***************
*** 0 ****
--- 1,38 ----
+ #include "Pooma/Pooma.h"
+ #include "Pooma/Arrays.h"
+ #include <iostream>
+ 
+ // Print an Array's Size
+ 
+ // This program illustrates using the Array member functions.
+ // computeArraySize's computation is redundant because Array's size()
+ // function computes the same value, but it illustrates using Array
+ // member functions.
+ 
+ template <int Dim, typename Type, typename EngineTag>
+ inline
+ long computeArraySize(const Array<Dim,Type,EngineTag>& a)
+ {
+   const Loc<Dim> fs = a.firsts();
+   const Loc<Dim> ls = a.lasts();
+   const Loc<Dim> lens = a.lengths();
+   long size = 1;
+   for (int d = 0; d < Dim; ++d) {
+     size *= lens[d].first();
+     // Check that lengths() and our computed lengths agree.
+     PAssert((ls[d] - fs[d] + 1).first() == a.length(d));
+   }
+   return size;
+ }
+ 
+ int main(int argc, char *argv[])
+ {
+   Pooma::initialize(argc,argv);
+ 
+   Array<3,int,Brick> a(3,4,5, ModelElement<int>(4));
+   PAssert(computeArraySize(a) == a.size());
+   std::cout << "The array's size is " << a.size() << ".\n";
+ 
+   Pooma::finalize();
+   return 0;
+ }
Index: Sequential/data-parallel.cpp
===================================================================
RCS file: data-parallel.cpp
diff -N data-parallel.cpp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- data-parallel.cpp	Thu Jan 24 20:36:10 2002
***************
*** 0 ****
--- 1,17 ----
+ // Illustrate data-parallel expressions.
+ 
+ #include "Pooma/Arrays.h"
+ 
+ int main(int argc, char *argv[])
+ {
+   Pooma::initialize(argc,argv);
+ 
+   Array<1, double, Brick> A(Interval<1>(0,2));
+   Array<1, double, Brick> B(Interval<1>(1,3));
+   A = 1.0;
+   B = 2.0;
+   std::cout << A-B << std::endl;
+ 
+   Pooma::finalize();
+   return 0;
+ }
Index: Sequential/dynamicarray.cpp
===================================================================
RCS file: dynamicarray.cpp
diff -N dynamicarray.cpp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- dynamicarray.cpp	Thu Jan 24 20:36:10 2002
***************
*** 0 ****
--- 1,38 ----
+ #include "Pooma/Pooma.h"
+ #include "Pooma/DynamicArrays.h"
+ #include <iostream>
+ 
+ // Demonstrate using DynamicArrays.
+ 
+ int main(int argc, char *argv[])
+ {
+   Pooma::initialize(argc,argv);
+ 
+   // Create a DynamicArray with one element.
+   DynamicArray<> d0(1);
+   DynamicArray<double> d01(1);
+   DynamicArray<double, Dynamic> d02(1);
+ 
+   // Add five more elements.
+   d0.create(5);
+   // Store values in the array.
+   for (int i = d0.domain().first(); i <= d0.domain().last(); ++i)
+     d0(i) = i;
+ 
+   // Delete every other element.
+   d0.destroy(Range<1>(d0.domain().first(),d0.domain().last(),2), BackFill());
+ 
+   // Print the resulting array.
+   std::cout << d0 << std::endl;
+ 
+   // Use the iterator form of 'destroy.'
+   DynamicArray<> d1(6);
+   for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
+     d1(i) = i;
+   int killList[] = { 0, 2, 4 };
+   d1.destroy(killList, killList+3);
+   std::cout << d1 << std::endl;
+ 
+   Pooma::finalize();
+   return 0;
+ }
Index: Sequential/initialize-finalize.cpp
===================================================================
RCS file: initialize-finalize.cpp
diff -N initialize-finalize.cpp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- initialize-finalize.cpp	Thu Jan 24 20:36:10 2002
***************
*** 0 ****
--- 1,12 ----
+ #include "Pooma/Pooma.h"
+ #include <iostream>
+ 
+ int main(int argc, char *argv[])
+ {
+   // Prepare the Pooma library for execution.
+   Pooma::initialize(argc,argv);
+ 
+   // Tell the Pooma library execution has finished.
+   Pooma::finalize();
+   return 0;
+ }
Index: Sequential/makefile
===================================================================
RCS file: makefile
diff -N makefile
*** /dev/null	Fri Mar 23 21:37:44 2001
--- makefile	Thu Jan 24 20:36:10 2002
***************
*** 0 ****
--- 1,80 ----
+ # Generated by mm.pl: Mon Mar  9 13:58:39 MST 1998
+ # ACL:license
+ #  ----------------------------------------------------------------------
+ #  This software and ancillary information (herein called "SOFTWARE")
+ #  called POOMA (Parallel Object-Oriented Methods and Applications) is
+ #  made available under the terms described here.  The SOFTWARE has been
+ #  approved for release with associated LA-CC Number LA-CC-98-65.
+ #  
+ #  Unless otherwise indicated, this SOFTWARE has been authored by an
+ #  employee or employees of the University of California, operator of the
+ #  Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
+ #  the U.S. Department of Energy.  The U.S. Government has rights to use,
+ #  reproduce, and distribute this SOFTWARE. The public may copy, distribute,
+ #  prepare derivative works and publicly display this SOFTWARE without 
+ #  charge, provided that this Notice and any statement of authorship are 
+ #  reproduced on all copies.  Neither the Government nor the University 
+ #  makes any warranty, express or implied, or assumes any liability or 
+ #  responsibility for the use of this SOFTWARE.
+ #  
+ #  If SOFTWARE is modified to produce derivative works, such modified
+ #  SOFTWARE should be clearly marked, so as not to confuse it with the
+ #  version available from LANL.
+ #  
+ #  For more information about POOMA, send e-mail to pooma at acl.lanl.gov,
+ #  or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
+ #  ----------------------------------------------------------------------
+ # ACL:license
+ 
+ # This file is user-editable
+ 
+ PROJECT_ROOT = $(shell cd ../../..; pwd)
+ include $(PROJECT_ROOT)/config/head.mk
+ 
+ PASS=APP
+ 
+ default:: array-copy array-size data-parallel dynamicarray initialize-finalize
+ 
+ .PHONY: array-copy
+ 
+ array-copy:: $(ODIR)/array-copy
+ 
+ $(ODIR)/array-copy: $(ODIR)/array-copy.o
+ 	$(LinkToSuite)
+ 
+ .PHONY: array-size
+ 
+ array-size:: $(ODIR)/array-size
+ 
+ $(ODIR)/array-size: $(ODIR)/array-size.o
+ 	$(LinkToSuite)
+ 
+ .PHONY: data-parallel
+ 
+ data-parallel:: $(ODIR)/data-parallel
+ 
+ $(ODIR)/data-parallel: $(ODIR)/data-parallel.o
+ 	$(LinkToSuite)
+ 
+ .PHONY: dynamicarray
+ 
+ dynamicarray:: $(ODIR)/dynamicarray
+ 
+ $(ODIR)/dynamicarray: $(ODIR)/dynamicarray.o
+ 	$(LinkToSuite)
+ 
+ .PHONY: initialize-finalize
+ 
+ initialize-finalize:: $(ODIR)/initialize-finalize
+ 
+ $(ODIR)/initialize-finalize: $(ODIR)/initialize-finalize.o
+ 	$(LinkToSuite)
+ 
+ include $(SHARED_ROOT)/tail.mk
+ 
+ # ACL:rcsinfo
+ #  ----------------------------------------------------------------------
+ #  $RCSfile: makefile,v $   $Author: oldham $
+ #  $Revision: 1.1 $   $Date: 2001/12/04 00:07:00 $
+ #  ----------------------------------------------------------------------
+ # ACL:rcsinfo
Index: Templates/pairs-templated.cpp
===================================================================
RCS file: pairs-templated.cpp
diff -N pairs-templated.cpp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- pairs-templated.cpp	Thu Jan 24 20:36:10 2002
***************
*** 0 ****
--- 1,15 ----
+ // Declare a template class storing a pair of values with the same type.
+ template <typename T>
+ struct pair {
+   pair(const int& left, const int& right)
+     : left_(left), right_(right) {}
+ 
+   T left_;
+   T right_;
+ };
+ 
+ // Use a class storing a pair of integers.
+ pair<int> pair1;
+ 
+ // Use a class storing a pair of doubles;
+ pair<double> pair2;
Index: Templates/pairs-untemplated.cpp
===================================================================
RCS file: pairs-untemplated.cpp
diff -N pairs-untemplated.cpp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- pairs-untemplated.cpp	Thu Jan 24 20:36:10 2002
***************
*** 0 ****
--- 1,17 ----
+ // Declare a class storing a pair of integers.
+ struct pairOfInts {
+   pairOfInts(const int& left, const int& right)
+     : left_(left), right_(right) {}
+ 
+   int left_;
+   int right_;
+ };
+ 
+ // Declare a class storing a pair of doubles.
+ struct pairOfDoubles {
+   pairOfDoubles(const double& left, const double& right)
+     : left_(left), right_(right) {}
+ 
+   double left_;
+   double right_;
+ };

From oldham at mail.codesourcery.com  Tue Jan 29 17:59:47 2002
From: oldham at mail.codesourcery.com (Jeffrey)
Date: Tue, 29 Jan 2002 09:59:47 -0800
Subject: Patch: Fix Typos in Comments
Message-ID: <20020129095947.A21227@vaio.codesourcery.com>

2002-Jan-29  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* Domain/Grid.h: Fix typos in comments.  Change "bidirectional
	iterator" to "forward iterator" in comment to reflect code.
	* Domain/IndirectionList.h: Likewise.
	* Domain/Interval.h: Likewise.
	* Domain/Loc.h: Likewise.
	* Domain/Range.h: Likewise.
	* Domain/Region.h: Likewise.
	* Domain/tests/grid.cpp: End comment with a period.
	* Engine/BrickBase.h (BrickBase<Dim>::first):
	s/direction/dimension/ in comment.
	(BrickBase<Dim>::strides_m): Likewise.
	(BrickViewBase<Dim>::first): Likewise.
	* Engine/DynamicEngine.h (Engine<1,T,Dynamic>::destroy): Remove
	incorrect space in comment.
	(Engine<1,T,Dynamic>::performDestroy): Remove incorrect apostrophe
	in comment.
	* Engine/RemoteDynamicEngine.h: End comment with a period.
	* Engine/Stencil.h: Remove non-existent 'ArrayStencil' from comment.
	* Field/DiffOps/FieldStencil.h: Fix spacing in comment.
	* Field/tests/TestBasicRelations.cpp: Fix spacing.
	* PETE/Combiners.h: Fix typos in comments.
	* PETE/TypeComputations.h: Fix typo in comment.
	* Tiny/VectorTensor.h: Likewise.
	* Utilities/DataBlockPtr.h (DataBlockController): Fix spelling
	mistake in comment.
	
Applied to	mainline
Approved by	Stephen Smith
Not tested.  Only comments (and one whitespace change) so no testing.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: Domain/Grid.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Grid.h,v
retrieving revision 1.13
diff -c -p -r1.13 Grid.h
*** Domain/Grid.h	2002/01/14 16:48:21	1.13
--- Domain/Grid.h	2002/01/25 03:50:52
***************
*** 84,90 ****
  // in the constructor for Grid; it acts like a Loc<1> object
  // in that context.  The domain arguments for the Grid
  // constructors are combined together to form a single domain object with
! // a dimension equal to the sum of the arguments dimensions; for example,
  // if you try to create a Grid<3> from a Loc<2> and an Interval<1>, e.g.
  //   Grid<3> a(Loc<2>(1,2), Interval<1>(3,5));
  // the Loc<2> and Interval arguments are combined into a (2+1=3) dimensional
--- 84,90 ----
  // in the constructor for Grid; it acts like a Loc<1> object
  // in that context.  The domain arguments for the Grid
  // constructors are combined together to form a single domain object with
! // a dimension equal to the sum of the argument's dimensions; for example,
  // if you try to create a Grid<3> from a Loc<2> and an Interval<1>, e.g.
  //   Grid<3> a(Loc<2>(1,2), Interval<1>(3,5));
  // the Loc<2> and Interval arguments are combined into a (2+1=3) dimensional
***************
*** 116,122 ****
  // Grid<N> interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lenghts of the N 1D Grids
  //   bool empty() - return if any of the Grid<1> objects have length == 0
  //   Grid<1> operator[](int N) - return the Nth Grid<1> in a
  //      multidimensional Grid<M>.  For Grid<1> objects, this just
--- 116,122 ----
  // Grid<N> interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lengths of the N 1D Grids
  //   bool empty() - return if any of the Grid<1> objects have length == 0
  //   Grid<1> operator[](int N) - return the Nth Grid<1> in a
  //      multidimensional Grid<M>.  For Grid<1> objects, this just
***************
*** 124,130 ****
  //   comparison operators: <, >, !=, ==, <=, >= : compare a Grid<N> to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or substract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
--- 124,130 ----
  //   comparison operators: <, >, !=, ==, <=, >= : compare a Grid<N> to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or subtract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
***************
*** 134,140 ****
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Grid negates the endpoints and stride.
! //   binary arithmethic operators +, -, *, / : for + and -, adding a Grid
  //      to another Loc or int returns a new Grid.  For * and /, scaling
  //      by a Loc or int also returns a Grid object, since the stride may
  //      change.
--- 134,140 ----
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Grid negates the endpoints and stride.
! //   binary arithmetic operators +, -, *, / : for + and -, adding a Grid
  //      to another Loc or int returns a new Grid.  For * and /, scaling
  //      by a Loc or int also returns a Grid object, since the stride may
  //      change.
***************
*** 152,159 ****
  //   int first() - the beginning endpoint.
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
! //   Interval<1>::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) bidirectional iterators.
  //
  // For the special case of Grid<1>, there is a specialization given
  // after the general case that has different constructors.
--- 152,159 ----
  //   int first() - the beginning endpoint.
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
! //   Grid<1>::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) forward iterators.
  //
  // For the special case of Grid<1>, there is a specialization given
  // after the general case that has different constructors.
Index: Domain/IndirectionList.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/IndirectionList.h,v
retrieving revision 1.16
diff -c -p -r1.16 IndirectionList.h
*** Domain/IndirectionList.h	2001/04/13 02:12:59	1.16
--- Domain/IndirectionList.h	2002/01/25 03:50:52
***************
*** 85,91 ****
  // IndirectionList<T> interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lenghts of the N 1D IndirectionLists
  //   bool empty() - return if any of the IndirectionList objects have
  //      length == 0
  //   IndirectionList operator[](int N) - return the Nth IndirectionList
--- 85,91 ----
  // IndirectionList<T> interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lengths of the N 1D IndirectionLists
  //   bool empty() - return if any of the IndirectionList objects have
  //      length == 0
  //   IndirectionList operator[](int N) - return the Nth IndirectionList
***************
*** 94,100 ****
  //   comparison operators: <, >, !=, ==, <=, >= : compare a IndirectionList
  //      to another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or substract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
--- 94,100 ----
  //   comparison operators: <, >, !=, ==, <=, >= : compare a IndirectionList
  //      to another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or subtract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
***************
*** 120,126 ****
  //   int last() - the ending endpoint.  
  //   int min(), int max() - min or max of the endpoints.
  //   IndirectionList::iterator begin() and end() - return iterators for
! //   the 1D domain.  These act like (at least) bidirectional iterators.
  //
  //-----------------------------------------------------------------------------
  
--- 120,126 ----
  //   int last() - the ending endpoint.  
  //   int min(), int max() - min or max of the endpoints.
  //   IndirectionList::iterator begin() and end() - return iterators for
! //   the 1D domain.  These act like (at least) forward iterators.
  //
  //-----------------------------------------------------------------------------
  
Index: Domain/Interval.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Interval.h,v
retrieving revision 1.19
diff -c -p -r1.19 Interval.h
*** Domain/Interval.h	2002/01/14 16:48:21	1.19
--- Domain/Interval.h	2002/01/25 03:50:52
***************
*** 78,84 ****
  // in the constructor for Interval; it acts like a Loc<1> object
  // in that context.  The domain arguments for the Interval
  // constructors are combined together to form a single domain object with
! // a dimension equal to the sum of the arguments dimensions; for example,
  // if you try to create an Interval<3> from a Loc<2> and an Interval<1>, e.g.
  //   Interval<3> a(Loc<2>(1,2), Interval<1>(3,5));
  // the Loc<2> and Interval arguments are combined into a (2+1=3) dimensional
--- 78,84 ----
  // in the constructor for Interval; it acts like a Loc<1> object
  // in that context.  The domain arguments for the Interval
  // constructors are combined together to form a single domain object with
! // a dimension equal to the sum of the arguments' dimensions; for example,
  // if you try to create an Interval<3> from a Loc<2> and an Interval<1>, e.g.
  //   Interval<3> a(Loc<2>(1,2), Interval<1>(3,5));
  // the Loc<2> and Interval arguments are combined into a (2+1=3) dimensional
***************
*** 104,110 ****
  // Interval<N> interface:
  // ----------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lenghts of the N 1D Intervals
  //   bool empty() - return if any of the Interval<1> objects have length == 0
  //   Interval<1> operator[](int N) - return the Nth Interval<1> in a
  //      multidimensional Interval<M>.  For Interval<1> objects, this just
--- 104,110 ----
  // Interval<N> interface:
  // ----------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lengths of the N 1D Intervals
  //   bool empty() - return if any of the Interval<1> objects have length == 0
  //   Interval<1> operator[](int N) - return the Nth Interval<1> in a
  //      multidimensional Interval<M>.  For Interval<1> objects, this just
***************
*** 112,118 ****
  //   comparison operators: <, >, !=, ==, <=, >= : compare an Interval <N> to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -= : add or substract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
--- 112,118 ----
  //   comparison operators: <, >, !=, ==, <=, >= : compare an Interval <N> to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -= : add or subtract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
***************
*** 120,126 ****
  //      allowed, since these operators would change the stride and that is
  //      not allowed for Interval (it has a hard-coded stride of 1).
  //      The negation operator (operator-) is also NOT allowed for Interval.
! //   binary arithmethic operators +, -, *, / : for + and -, adding an Interval
  //      to another Loc or int returns a new Interval.  For * and /, scaling
  //      by a Loc or int returns a Range object, since the stride may
  //      change.
--- 120,126 ----
  //      allowed, since these operators would change the stride and that is
  //      not allowed for Interval (it has a hard-coded stride of 1).
  //      The negation operator (operator-) is also NOT allowed for Interval.
! //   binary arithmetic operators +, -, *, / : for + and -, adding an Interval
  //      to another Loc or int returns a new Interval.  For * and /, scaling
  //      by a Loc or int returns a Range object, since the stride may
  //      change.
***************
*** 135,141 ****
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
  //   Interval<1>::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) bidirectional iterators.
  //
  // Interval inherits much of its activity from Domain<DomainTraits<Interval>>.
  //
--- 135,141 ----
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
  //   Interval<1>::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) forward iterators.
  //
  // Interval inherits much of its activity from Domain<DomainTraits<Interval>>.
  //
Index: Domain/Loc.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Loc.h,v
retrieving revision 1.25
diff -c -p -r1.25 Loc.h
*** Domain/Loc.h	2002/01/14 16:48:21	1.25
--- Domain/Loc.h	2002/01/25 03:50:52
***************
*** 113,119 ****
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
  //      is true for Loc and int's). 
! //   binary arithmethic operators +, -, *, / : for + and -, adding a Loc
  //      to another Loc or int returns a new Loc object.  For * and /, scaling
  //      by a Loc or int returns a Range object, since the stride may
  //      change.
--- 113,119 ----
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
  //      is true for Loc and int's). 
! //   binary arithmetic operators +, -, *, / : for + and -, adding a Loc
  //      to another Loc or int returns a new Loc object.  For * and /, scaling
  //      by a Loc or int returns a Range object, since the stride may
  //      change.
***************
*** 129,135 ****
  //   int last() - the ending endpoint, for Loc<1> just the point itself.
  //   int min(), int max() - min or max of the endpoints.
  //   Loc<1>::iterator begin() and end() - return iterators for the 1D domain.
! //      These act like (at least) bidirectional iterators.
  //
  // Loc inherits much of its activity from Domain<DomainTraits<Loc>,Dim>.
  // Domain is a base class that uses the template argument as a traits class
--- 129,135 ----
  //   int last() - the ending endpoint, for Loc<1> just the point itself.
  //   int min(), int max() - min or max of the endpoints.
  //   Loc<1>::iterator begin() and end() - return iterators for the 1D domain.
! //      These act like (at least) forward iterators.
  //
  // Loc inherits much of its activity from Domain<DomainTraits<Loc>,Dim>.
  // Domain is a base class that uses the template argument as a traits class
Index: Domain/Range.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Range.h,v
retrieving revision 1.20
diff -c -p -r1.20 Range.h
*** Domain/Range.h	2002/01/14 16:48:21	1.20
--- Domain/Range.h	2002/01/25 03:50:52
*************** void fillRangeScalar(Range<Dim> &r, cons
*** 111,117 ****
  // Range<N> interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lenghts of the N 1D Ranges
  //   bool empty() - return if any of the Range<1> objects have length == 0
  //   Range<1> operator[](int N) - return the Nth Range<1> in a
  //      multidimensional Range<M>.  For Range<1> objects, this just
--- 111,117 ----
  // Range<N> interface:
  // -------------------
  //   long size() - return the 'volume' of the domain, which is the product
! //      of the lengths of the N 1D Ranges
  //   bool empty() - return if any of the Range<1> objects have length == 0
  //   Range<1> operator[](int N) - return the Nth Range<1> in a
  //      multidimensional Range<M>.  For Range<1> objects, this just
*************** void fillRangeScalar(Range<Dim> &r, cons
*** 119,125 ****
  //   comparison operators: <, >, !=, ==, <=, >= : compare a Range<N> to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or substract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
--- 119,125 ----
  //   comparison operators: <, >, !=, ==, <=, >= : compare a Range<N> to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or subtract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
*************** void fillRangeScalar(Range<Dim> &r, cons
*** 129,135 ****
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Range negates the endpoints and stride.
! //   binary arithmethic operators +, -, *, / : for + and -, adding a Range
  //      to another Loc or int returns a new Range.  For * and /, scaling
  //      by a Loc or int also returns a Range object, since the stride may
  //      change.
--- 129,135 ----
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Range negates the endpoints and stride.
! //   binary arithmetic operators +, -, *, / : for + and -, adding a Range
  //      to another Loc or int returns a new Range.  For * and /, scaling
  //      by a Loc or int also returns a Range object, since the stride may
  //      change.
*************** void fillRangeScalar(Range<Dim> &r, cons
*** 147,154 ****
  //   int first() - the beginning endpoint.
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
! //   Interval<1>::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) bidirectional iterators.
  //
  // For the special case of Range<1>, there is a specialization given
  // after the general case that has different constructors.
--- 147,154 ----
  //   int first() - the beginning endpoint.
  //   int last() - the ending endpoint.
  //   int min(), int max() - min or max of the endpoints.
! //   Range<1>::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) forward iterators.
  //
  // For the special case of Range<1>, there is a specialization given
  // after the general case that has different constructors.
Index: Domain/Region.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/Region.h,v
retrieving revision 1.23
diff -c -p -r1.23 Region.h
*** Domain/Region.h	2001/04/13 02:12:59	1.23
--- Domain/Region.h	2002/01/25 03:50:52
***************
*** 78,84 ****
  //
  // You can construct a Region object using other domain objects.
  // The constructors accept up to 7 domain objects of various types.
! // Domain types are, for example, Loc, Region, Interval. an int, double, or
  // float may also be used
  // in the constructor for Region; it acts like a Loc<1> object
  // in that context.  The domain arguments for the Region
--- 78,84 ----
  //
  // You can construct a Region object using other domain objects.
  // The constructors accept up to 7 domain objects of various types.
! // Domain types are, for example, Loc, Region, Interval. An int, double, or
  // float may also be used
  // in the constructor for Region; it acts like a Loc<1> object
  // in that context.  The domain arguments for the Region
***************
*** 117,123 ****
  // Region<N,T> interface:
  // -------------------
  //   T size() - return the 'volume' of the domain, which is the product
! //      of the lenghts of the N 1D Regions
  //   bool empty() - always false here
  //   Region<1,T> operator[](int N) - return the Nth Region<1,T> in a
  //      multidimensional Region<M,T>.  For Region<1,T> objects, this just
--- 117,123 ----
  // Region<N,T> interface:
  // -------------------
  //   T size() - return the 'volume' of the domain, which is the product
! //      of the lengths of the N 1D Regions
  //   bool empty() - always false here
  //   Region<1,T> operator[](int N) - return the Nth Region<1,T> in a
  //      multidimensional Region<M,T>.  For Region<1,T> objects, this just
***************
*** 125,131 ****
  //   comparison operators: <, >, !=, ==, <=, >= : compare a Region<N,T> to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or substract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
--- 125,131 ----
  //   comparison operators: <, >, !=, ==, <=, >= : compare a Region<N,T> to
  //      another domain object.  The compared domains must have the same
  //      number of dimensions.
! //   arithmetic accumulation operators +=, -=, *=, /= : add or subtract in a
  //      given domain.  The added domain must have the same number of
  //      dimensions, or a dimension of 1 (in which case, the same value
  //      is used for all dimensions), and be known to be single-valued (which
***************
*** 135,141 ****
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Region negates the endpoints and stride.
! //   binary arithmethic operators +, -, *, / : for + and -, adding a Region
  //      to another Loc or int returns a new Region.  For * and /, scaling
  //      by a Loc or int also returns a Region object, since the stride may
  //      change.
--- 135,141 ----
  //      the length (and size) the same.  += and -= shift the beginning
  //      endpoints by the given values, also leaving the length and size the
  //      same.  Negation of a Region negates the endpoints and stride.
! //   binary arithmetic operators +, -, *, / : for + and -, adding a Region
  //      to another Loc or int returns a new Region.  For * and /, scaling
  //      by a Loc or int also returns a Region object, since the stride may
  //      change.
***************
*** 147,162 ****
  //   all the methods for Region<N,T> are also available for Region<1,T>. Plus:
  //   T length() - number of elements (including endpoints) of the domain.
  //     Really, this should be either 1 or infinity, but it defined here
! //     somewhat differently, as just the distance betweent the endpoints.  So
  //     a length of zero really means this just refers to one point, not that
! //     this is empty.  A Region cannot be empty, it must refer to SOME point(s)
  //   T first() - the beginning endpoint.
  //   T last() - the ending endpoint.
  //   T stride() - here, the same as the length()
  //   T min(), T max() - min or max of the endpoints.
  //   bool empty() - always false for a Region
  //   Region<1,T>::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) bidirectional iterators.
  //
  // For the special case of Region<1,T>, there is a specialization given
  // after the general case that has different constructors.
--- 147,162 ----
  //   all the methods for Region<N,T> are also available for Region<1,T>. Plus:
  //   T length() - number of elements (including endpoints) of the domain.
  //     Really, this should be either 1 or infinity, but it defined here
! //     somewhat differently, as just the distance between the endpoints.  So
  //     a length of zero really means this just refers to one point, not that
! //     this is empty.  A Region cannot be empty, it must refer to SOME point(s).
  //   T first() - the beginning endpoint.
  //   T last() - the ending endpoint.
  //   T stride() - here, the same as the length()
  //   T min(), T max() - min or max of the endpoints.
  //   bool empty() - always false for a Region
  //   Region<1,T>::iterator begin() and end() - return iterators for the 1D
! //      domain.  These act like (at least) forward iterators.
  //
  // For the special case of Region<1,T>, there is a specialization given
  // after the general case that has different constructors.
Index: Domain/tests/grid.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Domain/tests/grid.cpp,v
retrieving revision 1.5
diff -c -p -r1.5 grid.cpp
*** Domain/tests/grid.cpp	2000/03/07 13:16:42	1.5
--- Domain/tests/grid.cpp	2002/01/25 03:50:53
*************** int main(int argc, char *argv[]) {
*** 60,66 ****
  
    tester.out() << "Created Range = " << range << std::endl;
  
!   // Construct a 1D Grid from the IndirectionList, and from the range
  
    Grid<1> g1(list);
    Grid<1> g2(range);
--- 60,66 ----
  
    tester.out() << "Created Range = " << range << std::endl;
  
!   // Construct a 1D Grid from the IndirectionList and from the range.
  
    Grid<1> g1(list);
    Grid<1> g2(range);
Index: Engine/BrickBase.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/BrickBase.h,v
retrieving revision 1.13
diff -c -p -r1.13 BrickBase.h
*** Engine/BrickBase.h	2001/10/24 15:39:42	1.13
--- Engine/BrickBase.h	2002/01/25 03:50:53
*************** public:
*** 173,179 ****
    
    inline const int *originalStrides() const { return &ostrides_m[0]; }
  
!   // Return the first index value for the specified direction.
    
    int first(int i) const;
    
--- 173,179 ----
    
    inline const int *originalStrides() const { return &ostrides_m[0]; }
  
!   // Return the first index value for the specified dimension.
    
    int first(int i) const;
    
*************** protected:
*** 315,321 ****
  
    Layout_t layout_m;
  
!   // Strides through actual data block when stepping in different directions.
    // We keep two copies - strides_m is used by the offset calculations. 
    // If we are compressible, then when compressed, these will all be 
    // set to zero. 
--- 315,321 ----
  
    Layout_t layout_m;
  
!   // Strides through actual data block when stepping in different dimensions.
    // We keep two copies - strides_m is used by the offset calculations. 
    // If we are compressible, then when compressed, these will all be 
    // set to zero. 
*************** public:
*** 538,544 ****
    
    inline const int *originalStrides() const { return &ostrides_m[0]; }
  
!   // Return the first index value for the specified direction.
    // (Always zero since views are zero-based).
    
    inline int first(int) const { return 0; }
--- 538,544 ----
    
    inline const int *originalStrides() const { return &ostrides_m[0]; }
  
!   // Return the first index value for the specified dimension.
    // (Always zero since views are zero-based).
    
    inline int first(int) const { return 0; }
*************** protected:
*** 663,669 ****
    
    Domain_t domain_m;
  
!   // Strides through actual data block when stepping in each direction.
    // We keep two copies - strides_m is used by the offset calculations. 
    // If we are compressible, then when compressed, these will all be 
    // set to zero. 
--- 663,669 ----
    
    Domain_t domain_m;
  
!   // Strides through actual data block when stepping in each dimension.
    // We keep two copies - strides_m is used by the offset calculations. 
    // If we are compressible, then when compressed, these will all be 
    // set to zero. 
Index: Engine/DynamicEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/DynamicEngine.h,v
retrieving revision 1.16
diff -c -p -r1.16 DynamicEngine.h
*** Engine/DynamicEngine.h	2001/04/09 21:34:27	1.16
--- Engine/DynamicEngine.h	2002/01/25 03:50:53
*************** public:
*** 275,281 ****
    void destroy(const Dom &killList);
  
    // Same, but with iterators into some container holding the
!   // points of the domain. These must be random-access iterators ( a
    // requirement of the underlying delete algorithm).
    
    template <class Iter>
--- 275,281 ----
    void destroy(const Dom &killList);
  
    // Same, but with iterators into some container holding the
!   // points of the domain. These must be random-access iterators (a
    // requirement of the underlying delete algorithm).
    
    template <class Iter>
*************** private:
*** 359,365 ****
    // versions that take iterators into the killList. This allows one
    // to use many more data structures for holding the kill list.
    
!   // If offsetFlag is true (delete default's it to false), the domain 
    // is interpreted as a list of offsets rather than a subset of 
    // the engine's domain.
  
--- 359,365 ----
    // versions that take iterators into the killList. This allows one
    // to use many more data structures for holding the kill list.
    
!   // If offsetFlag is true (delete defaults it to false), the domain 
    // is interpreted as a list of offsets rather than a subset of 
    // the engine's domain.
  
Index: Engine/RemoteDynamicEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/RemoteDynamicEngine.h,v
retrieving revision 1.16
diff -c -p -r1.16 RemoteDynamicEngine.h
*** Engine/RemoteDynamicEngine.h	2001/05/16 21:21:06	1.16
--- Engine/RemoteDynamicEngine.h	2002/01/25 03:50:54
***************
*** 40,46 ****
  //
  //   Engine<1, T, Remote<Dynamic> >
  //    - A wrapper engine that remotifies an Engine<1, T, Dynamic>.
! //      The remote version belongs to a particular context
  //
  //-----------------------------------------------------------------------------
  
--- 40,46 ----
  //
  //   Engine<1, T, Remote<Dynamic> >
  //    - A wrapper engine that remotifies an Engine<1, T, Dynamic>.
! //      The remote version belongs to a particular context.
  //
  //-----------------------------------------------------------------------------
  
Index: Engine/Stencil.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/Stencil.h,v
retrieving revision 1.44
diff -c -p -r1.44 Stencil.h
*** Engine/Stencil.h	2001/09/14 22:37:56	1.44
--- Engine/Stencil.h	2002/01/25 03:50:54
***************
*** 30,37 ****
  // Classes: 
  //   Stencil               - Base class for defining stencils
  //   StencilEngine         - An tag for an engine for representing a stencil
- //   ArrayStencil          - contains utility functions for building stencils
- //                           on arrays
  //   View1                 - Specialization for Stencil
  //   Engine                - Specialization for StencilEngine
  //   NewEngine             - Specialization for StencilEngine
--- 30,35 ----
Index: Field/DiffOps/FieldStencil.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Field/DiffOps/FieldStencil.h,v
retrieving revision 1.1
diff -c -p -r1.1 FieldStencil.h
*** Field/DiffOps/FieldStencil.h	2001/08/30 01:15:09	1.1
--- Field/DiffOps/FieldStencil.h	2002/01/25 03:50:54
*************** struct LeafFunctor<Engine<Dim, T, ApplyF
*** 716,722 ****
  };
  
  //---------------------------------------------------------------------------
! // Specialization of  DataObjectRequest engineFunctor to pass the request to
  // the contained engine.
  //---------------------------------------------------------------------------
  
--- 716,722 ----
  };
  
  //---------------------------------------------------------------------------
! // Specialization of DataObjectRequest engineFunctor to pass the request to
  // the contained engine.
  //---------------------------------------------------------------------------
  
Index: Field/tests/TestBasicRelations.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Field/tests/TestBasicRelations.cpp,v
retrieving revision 1.2
diff -c -p -r1.2 TestBasicRelations.cpp
*** Field/tests/TestBasicRelations.cpp	2001/10/12 02:09:27	1.2
--- Field/tests/TestBasicRelations.cpp	2002/01/25 03:50:54
*************** struct ComputeVelocity
*** 63,69 ****
  {
    void doit(const Field_t &v, const Field_t &p, const Field_t &m)
    {
!     v = p /  m;
    }
  };
  
--- 63,69 ----
  {
    void doit(const Field_t &v, const Field_t &p, const Field_t &m)
    {
!     v = p / m;
    }
  };
  
Index: PETE/Combiners.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/PETE/Combiners.h,v
retrieving revision 1.10
diff -c -p -r1.10 Combiners.h
*** PETE/Combiners.h	2000/12/04 21:19:37	1.10
--- PETE/Combiners.h	2002/01/25 03:50:55
*************** peteCombine(const A &a, const B &b, cons
*** 158,164 ****
  //   back with modified leaves.
  //
  //   This type of operation is useful when expressions are being
! //   passed around.  For example, you might subset and expression and pass
  //   that result to another function.  The type of expression tree that you
  //   are passing has subsetted nodes, and could be a different type from the
  //   original expression.
--- 158,164 ----
  //   back with modified leaves.
  //
  //   This type of operation is useful when expressions are being
! //   passed around.  For example, you might subset an expression and pass
  //   that result to another function.  The type of expression tree that you
  //   are passing has subsetted nodes, and could be a different type from the
  //   original expression.
*************** struct Combine2<bool, bool, Op, OrCombin
*** 311,317 ****
  //
  // DESCRIPTION
  //   This combiner doesn't do anything. Used when the combination isn't meant
! //   return anything since combiners cannot return void.
  //
  //-----------------------------------------------------------------------------
  
--- 311,317 ----
  //
  // DESCRIPTION
  //   This combiner doesn't do anything. Used when the combination isn't meant
! //   to return anything since combiners cannot return void.
  //
  //-----------------------------------------------------------------------------
  
Index: PETE/TypeComputations.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/PETE/TypeComputations.h,v
retrieving revision 1.11
diff -c -p -r1.11 TypeComputations.h
*** PETE/TypeComputations.h	2000/08/08 17:34:09	1.11
--- PETE/TypeComputations.h	2002/01/25 03:50:55
***************
*** 44,50 ****
  //        function/operation. For example, operator-(T) should return a T.
  //      o return a type based entirely on the operation. 
  //        For example, operator! always returns a bool.
! //      o sythesize a type based on the type of the argument and the operation.
  //    The first case is most common. We therefore make it the behavior
  //    for the base template. The other cases are handled by partial
  //    specialization.
--- 44,50 ----
  //        function/operation. For example, operator-(T) should return a T.
  //      o return a type based entirely on the operation. 
  //        For example, operator! always returns a bool.
! //      o synthesize a type based on the type of the argument and the operation.
  //    The first case is most common. We therefore make it the behavior
  //    for the base template. The other cases are handled by partial
  //    specialization.
Index: Tiny/VectorTensor.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Tiny/VectorTensor.h,v
retrieving revision 1.14
diff -c -p -r1.14 VectorTensor.h
*** Tiny/VectorTensor.h	2000/03/07 13:18:16	1.14
--- Tiny/VectorTensor.h	2002/01/25 03:50:55
*************** dot( const Tensor<D,T1,E1>& v1 , const V
*** 297,303 ****
  //
  // Full Description:
  //
! // Subroutine for taking outper product between two vectors, yielding a tensor.
  // Takes the outer product of vector of type V1 and vector of type V2
  //
  // The chain of operations is:
--- 297,303 ----
  //
  // Full Description:
  //
! // Subroutine for taking outer product between two vectors, yielding a tensor.
  // Takes the outer product of vector of type V1 and vector of type V2
  //
  // The chain of operations is:
Index: Utilities/DataBlockPtr.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Utilities/DataBlockPtr.h,v
retrieving revision 1.20
diff -c -p -r1.20 DataBlockPtr.h
*** Utilities/DataBlockPtr.h	2001/05/04 15:41:29	1.20
--- Utilities/DataBlockPtr.h	2002/01/25 03:50:55
*************** public:
*** 190,196 ****
    //   Ordinarily, this will NOT be used. However, if one
    //   wants to have a RefCountedBlockPtr<T1> where T1 itself
    //   is or contains a RefCountedBlockPtr<T2>, then this
!   //   may occaisionally be used. When it IS used, a DEEP
    //   copy is required. The RefCounted base class's copy
    //   constructor properly sets the count of the new
    //   class to zero.
--- 190,196 ----
    //   Ordinarily, this will NOT be used. However, if one
    //   wants to have a RefCountedBlockPtr<T1> where T1 itself
    //   is or contains a RefCountedBlockPtr<T2>, then this
!   //   may occasionally be used. When it IS used, a DEEP
    //   copy is required. The RefCounted base class's copy
    //   constructor properly sets the count of the new
    //   class to zero.

From oldham at mail.codesourcery.com  Tue Jan 29 21:49:48 2002
From: oldham at mail.codesourcery.com (Jeffrey)
Date: Tue, 29 Jan 2002 13:49:48 -0800
Subject: Manual Patch: More Wordsmithing and Formatting
Message-ID: <20020129134948.A22638@vaio.codesourcery.com>

2002-Jan-29  Jeffrey D. Oldham  <oldham at codesourcery.com>

	These changes to the POOMA manual continue the process of working
	toward delivery.  Most of the changes involve wordsmithing and
	formatting of the PostScript version.
	
	* arrays.xml: Fix formatting.  Minor wording changes.
	* concepts.xml: Likewise.
	* data-parallel.xml: Change section title.  Fix formatting of
	verbatim sections.
	* introduction.xml: Change use of the word "free."  Other minor
	wording and formatting changes.
	* manual.xml: Update download page entity.  Add acknowledgements.
	Fix use of the word "Unix."  Fix some formatting, particularly
	verbatim environments.
	* template.xml: Be consist in use of "programming time."  Minor
	formatting and wordsmithing.
	* tutorial.xml: Replace use of "Unix."  Fix formatting.

Applied to	mainline
Approved by	me.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.4
diff -c -p -r1.4 arrays.xml
*** arrays.xml	2002/01/25 02:28:25	1.4
--- arrays.xml	2002/01/29 18:11:18
***************
*** 239,248 ****
       <title>Declaring &domain;s</title>
  
       <para>Since &domain;s are mainly used to declare container
!      domains, we focus on declaring &domain;s.  We subsequently
!      describe a few &domain; operations but most, including arithmetic
!      operations with &domain;s, are described in <xref
!      linkend="views"></xref>.</para>
  
       <para>All &domain; declarations require a dimension template
       parameter&nbsp;<varname>&dim;</varname>.  This positive integer
--- 239,248 ----
       <title>Declaring &domain;s</title>
  
       <para>Since &domain;s are mainly used to declare container
!      domains, we focus on declaring &domain;s, deferring most
!      discussion of their use.  We subsequently describe a few &domain;
!      operations but most, including arithmetic operations with
!      &domain;s, are described in <xref linkend="views"></xref>.</para>
  
       <para>All &domain; declarations require a dimension template
       parameter&nbsp;<varname>&dim;</varname>.  This positive integer
*************** Grid&lt;1&gt; g(list);
*** 1099,1109 ****
  <!-- FIXME: This paragraph is poorly worded. -->
  
      <para>&array; values need not just be stored values, as &c; arrays
!     have.  They can also be computed by its engine.  We defer
!     discussion of computing values to the next chapter discussing
!     engines (<xref linkend="engines"></xref>).  To avoid being verbose
!     in this chapter, when we discuss stored values, the values might
!     instead be computed.</para>
  
      <para>Declaring an &array; requires four arguments: the domain's
      dimensionality, the type of values stored or computed, a
--- 1099,1110 ----
  <!-- FIXME: This paragraph is poorly worded. -->
  
      <para>&array; values need not just be stored values, as &c; arrays
!     have.  The values can also be computed dynamically by the engine
!     associated with the &array;.  We defer discussion of computing
!     values to the next chapter discussing engines (<xref
!     linkend="engines"></xref>).  Therefore, when we mention <quote>the
!     values stored in an &array;</quote>, we implicitly mean <quote>the
!     values stored in or computed by the &array;</quote>.</para>
  
      <para>Declaring an &array; requires four arguments: the domain's
      dimensionality, the type of values stored or computed, a
*************** Array&lt;2,bool&gt; c(2,3, ModelElement&
*** 1395,1401 ****
      seven &double;s all equaling &pi;, use
  <programlisting>
  const double pi = 4.0*atan(1.0);
! Array&lt;1,double,CompressibleBrick&gt; d(7, ModelElement&lt;double&gt;(pi));.
  </programlisting>  We use a &compressiblebrick; &engine;, rather than
      a &brick; &engine;, so all seven values will be stored in one
      location rather than in seven separate locations when they are all the
--- 1396,1403 ----
      seven &double;s all equaling &pi;, use
  <programlisting>
  const double pi = 4.0*atan(1.0);
! Array&lt;1,double,CompressibleBrick&gt;
!   d(7, ModelElement&lt;double&gt;(pi));.
  </programlisting>  We use a &compressiblebrick; &engine;, rather than
      a &brick; &engine;, so all seven values will be stored in one
      location rather than in seven separate locations when they are all the
*************** Array&lt;1,double,CompressibleBrick&gt; 
*** 1420,1426 ****
  // Create an Array and its domain.
  Array<2,float,Brick> a(Interval<1>(2,7), Interval<1>(-2,4));
  
! // Create an Array without a domain and then specify its domain.
  Array<2,float,Brick> b();
  b.initialize(Interval<1>(2,7), Interval<1>(-2,4));.
  </programlisting>  Invoking <methodname>initialize</methodname> on an
--- 1422,1429 ----
  // Create an Array and its domain.
  Array<2,float,Brick> a(Interval<1>(2,7), Interval<1>(-2,4));
  
! // Create an Array without a domain and then specify
! // its domain.
  Array<2,float,Brick> b();
  b.initialize(Interval<1>(2,7), Interval<1>(-2,4));.
  </programlisting>  Invoking <methodname>initialize</methodname> on an
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1623,1629 ****
      <varname>a</varname>'s values are the same as <varname>b</varname>
      at the time of assignment only.  Subsequent changes to
      <varname>a</varname>'s values do not change <varname>b</varname>'s
!     values or vice versa.</para>
  
      <para>The &array; class has internal type definitions and
      constants useful for both compile-time and run-time computations.
--- 1626,1637 ----
      <varname>a</varname>'s values are the same as <varname>b</varname>
      at the time of assignment only.  Subsequent changes to
      <varname>a</varname>'s values do not change <varname>b</varname>'s
!     values or vice versa.  Assignment is more expensive than creating
!     a reference.  Creating a reference requires creating a very small
!     object and incrementing a reference-counted pointer.  An
!     assignment requires storage for both the left-hand side and
!     right-hand side operands and traversing all of the right-hand
!     side's data.</para>
  
      <para>The &array; class has internal type definitions and
      constants useful for both compile-time and run-time computations.
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.9
diff -c -p -r1.9 concepts.xml
*** concepts.xml	2002/01/25 02:28:26	1.9
--- concepts.xml	2002/01/29 18:11:19
***************
*** 52,60 ****
     <tgroup cols="3" align="center">
      <thead>
       <row>
        <entry>Container</entry>
! 	<entry>Computation Modes</entry>
! 	<entry>Computation Environment</entry>
       </row>
      </thead>
      <tbody valign="top">
--- 52,65 ----
     <tgroup cols="3" align="center">
      <thead>
       <row>
+       <entry></entry>
+       <entry></entry>
+       <entry>Computation</entry>
+      </row>
+      <row>
        <entry>Container</entry>
!       <entry>Computation Modes</entry>
!       <entry>Environment</entry>
       </row>
      </thead>
      <tbody valign="top">
***************
*** 377,384 ****
     are several different types of domains.  An <glossterm
     linkend="glossary-interval"><firstterm>interval</firstterm></glossterm>
     consists of all integral points between two endpoints.  It is
!    frequently represented using mathematical interval notation [a,b]
!    even though it contains only the integral points, e.g., a, a+1,
     a+2, &hellip;, b.  The concept is generalized to multiple
     dimensions by forming direct products of intervals, i.e., all the
     integral tuples in an &n;-dimensional space.  For example, the
--- 382,389 ----
     are several different types of domains.  An <glossterm
     linkend="glossary-interval"><firstterm>interval</firstterm></glossterm>
     consists of all integral points between two endpoints.  It is
!    frequently represented using mathematical interval notation [a,b];
!    it contains only the integral points, e.g., a, a+1,
     a+2, &hellip;, b.  The concept is generalized to multiple
     dimensions by forming direct products of intervals, i.e., all the
     integral tuples in an &n;-dimensional space.  For example, the
***************
*** 501,511 ****
    involves explicitly accessing a container's values.  A data-parallel
    computation operates on larger subsets of a container's values.
    Stencil-based computations express a computation as repeatedly
!   applying a local computation to each element of an array.  A
!   relation among containers establishes a dependency among them so the
!   values of one container are updated whenever any other's values
!   change.  A program may use any or all of these styles, which are
!   described below.</para>
  
    <para><glossterm
    linkend="glossary-element_wise"><firstterm>Element-wise</firstterm></glossterm>
--- 506,516 ----
    involves explicitly accessing a container's values.  A data-parallel
    computation operates on larger subsets of a container's values.
    Stencil-based computations express a computation as repeatedly
!   applying a local computation to each element of an array.
!   Relation-based computations use relations on containers to establish
!   dependencies among them so the values of one container are updated
!   whenever any other's values change.  A program may use any or all of
!   these styles, which are described below.</para>
  
    <para><glossterm
    linkend="glossary-element_wise"><firstterm>Element-wise</firstterm></glossterm>
***************
*** 528,536 ****
    data-parallel expressions frequently eliminates the need for writing
    explicit loops.</para>
  
!   <para>A <glossterm
!   linkend="glossary-stencil"><firstterm>stencil</firstterm></glossterm>
!   computes a container's value using neighboring data values.  Each
    stencil consists of a specification of which neighboring values to
    read and a function using those values.  For example, an averaging
    stencil may access all its adjacent neighbors, averaging them.  In
--- 533,541 ----
    data-parallel expressions frequently eliminates the need for writing
    explicit loops.</para>
  
!   <para>Stencil-based computation uses <glossterm
!   linkend="glossary-stencil"><firstterm>stencils</firstterm></glossterm>
!   to compute containers' values using neighboring data values.  Each
    stencil consists of a specification of which neighboring values to
    read and a function using those values.  For example, an averaging
    stencil may access all its adjacent neighbors, averaging them.  In
***************
*** 540,548 ****
    differential equations, image processing, and geometric
    modeling.</para>
  
!   <para>A <glossterm
!   linkend="glossary-relation"><firstterm>relation</firstterm></glossterm>
!   is a dependence among containers such the dependent container's
    values are updated when its values are needed and any of its related
    containers' values have changed.  A relation is specified by a
    dependent container, independent containers, and a function
--- 545,553 ----
    differential equations, image processing, and geometric
    modeling.</para>
  
!   <para>Relation-based computation uses <glossterm
!   linkend="glossary-relation"><firstterm>relations</firstterm></glossterm>
!   to create dependences among containers such the dependent container's
    values are updated when its values are needed and any of its related
    containers' values have changed.  A relation is specified by a
    dependent container, independent containers, and a function
Index: data-parallel.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/data-parallel.xml,v
retrieving revision 1.3
diff -c -p -r1.3 data-parallel.xml
*** data-parallel.xml	2002/01/25 02:28:26	1.3
--- data-parallel.xml	2002/01/29 18:11:20
***************
*** 57,63 ****
  
  
     <section id="data_parallel-use">
!     <title>Their Use</title>
  
      <para>&pooma; containers can be used in data-parallel expressions
      and statements.  The basic guidelines are simple:
--- 57,63 ----
  
  
     <section id="data_parallel-use">
!     <title>Using Data-Parallel Expressions</title>
  
      <para>&pooma; containers can be used in data-parallel expressions
      and statements.  The basic guidelines are simple:
*************** std::cout &openopen; A &openopen; std::e
*** 969,981 ****
       For example, the overloaded unary minus operator yields a tree
       node representing <statement>-A</statement>, having a unary-minus
       function object, and having type
!      <type>Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;</type>.
!      The binary nodes continue the construction process yielding a
       parse tree object for the entire right-hand side and having type
!      <type>Expression&lt;BinaryNode&lt;OpAdd, UnaryNode&lt;OpMinus,
!      Ar&gt;,
!      BinaryNode&lt;OpMultiply&lt;Scalar&lt;int&gt;,Ar&closecloseclose;</type>.
!      Evaluating the left-hand side yields an object
       representing&nbsp;<varname>A</varname>.</para>
  
       <figure float="1" id="data_parallel-implementation-pete-tree_figure">
--- 969,983 ----
       For example, the overloaded unary minus operator yields a tree
       node representing <statement>-A</statement>, having a unary-minus
       function object, and having type
! <programlisting>
! Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;
! </programlisting>  The binary nodes continue the construction process yielding a
       parse tree object for the entire right-hand side and having type
! <programlisting>
! Expression&lt;BinaryNode&lt;OpAdd,
!                       UnaryNode&lt;OpMinus, Ar&gt;,
!                       BinaryNode&lt;OpMultiply&lt;Scalar&lt;int&gt;,Ar&closecloseclose;
! </programlisting> Evaluating the left-hand side yields an object
       representing&nbsp;<varname>A</varname>.</para>
  
       <figure float="1" id="data_parallel-implementation-pete-tree_figure">
*************** struct CreateLeaf&lt;Array&lt;Dim, T, En
*** 1122,1128 ****
  <programlisting>
  template&lt;int D1,class T1,class E1&gt;
  inline typename MakeReturn&lt;UnaryNode&lt;OpUnaryMinus,
!   typename CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::Leaf_t&gt; &gt;::Expression_t
  operator-(const Array&lt;D1,T1,E1&gt; &amp; l)
  {
    typedef UnaryNode&lt;OpUnaryMinus,
--- 1124,1131 ----
  <programlisting>
  template&lt;int D1,class T1,class E1&gt;
  inline typename MakeReturn&lt;UnaryNode&lt;OpUnaryMinus,
!   typename CreateLeaf&lt;Array&lt;D1,T1,E1&closeclose;::Leaf_t&closeclose;::
!     Expression_t
  operator-(const Array&lt;D1,T1,E1&gt; &amp; l)
  {
    typedef UnaryNode&lt;OpUnaryMinus,
*************** operator-(const Array&lt;D1,T1,E1&gt; &a
*** 1133,1140 ****
  </programlisting>  <type>Tree_t</type> specifies the node's unique
      type.  Constructing the object first involves creating a leaf
      containing the &array; reference through the call to
!     <function>CreateLeaf&lt;Array&lt;D1,T1,E1&gt;
!     &gt;::make</function>.  The call to
      <function>MakeReturn&lt;Tree_t&gt;::make</function> permits
      programmers to store trees in different formats.  The &pooma;
      implementation stores them as <type>Expression</type>s.  The
--- 1136,1144 ----
  </programlisting>  <type>Tree_t</type> specifies the node's unique
      type.  Constructing the object first involves creating a leaf
      containing the &array; reference through the call to
! <programlisting>
! CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;::make
! </programlisting>  The call to
      <function>MakeReturn&lt;Tree_t&gt;::make</function> permits
      programmers to store trees in different formats.  The &pooma;
      implementation stores them as <type>Expression</type>s.  The
*************** for (int i = a's domain[0].first(); i < 
*** 1199,1205 ****
      performs a <emphasis>compile-time</emphasis> post-order parse-tree
      traversal.  Its general form is
  <programlisting>
! forEach(const Expression&amp; e, const LeafTag&amp; f, const CombineTag&amp; c).
  </programlisting> That is, it traverses the nodes of the
      <type>Expression</type> object&nbsp;<varname>e</varname>.  At
      leaves, it applies the operation specified by
--- 1203,1210 ----
      performs a <emphasis>compile-time</emphasis> post-order parse-tree
      traversal.  Its general form is
  <programlisting>
! forEach(const Expression&amp; e, const LeafTag&amp; f,
!         const CombineTag&amp; c).
  </programlisting> That is, it traverses the nodes of the
      <type>Expression</type> object&nbsp;<varname>e</varname>.  At
      leaves, it applies the operation specified by
*************** struct ForEach&lt;UnaryNode&lt;Op, A&gt;
*** 1232,1238 ****
      const CTag &amp;c) 
    {
      return Combine1&lt;TypeA_t, Op, CTag&gt;::
!       combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.child(), f, c), c);
    }
  };
  </programlisting>  Since this structure is specialized for
--- 1237,1244 ----
      const CTag &amp;c) 
    {
      return Combine1&lt;TypeA_t, Op, CTag&gt;::
!       combine(ForEach&lt;A, FTag, CTag&gt;::
!         apply(expr.child(), f, c), c);
    }
  };
  </programlisting>  Since this structure is specialized for
Index: introduction.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/introduction.xml,v
retrieving revision 1.4
diff -c -p -r1.4 introduction.xml
*** introduction.xml	2002/01/24 05:11:21	1.4
--- introduction.xml	2002/01/29 18:11:21
***************
*** 33,40 ****
   Using these high-level abstractions, the same code runs on a
   sequential, parallel, and distributed computers.  It runs almost as
   fast as carefully crafted machine-specific hand-written programs.
!  The &toolkit; is freely available, open-source software compatible
!  with any modern &cc; compiler.</para>
  
  
   <section id="introduction-goals">
--- 33,40 ----
   Using these high-level abstractions, the same code runs on a
   sequential, parallel, and distributed computers.  It runs almost as
   fast as carefully crafted machine-specific hand-written programs.
!  The &toolkit; is open-source software, available for no cost, and
!  compatible with any modern &cc; compiler.</para>
  
  
   <section id="introduction-goals">
***************
*** 79,85 ****
          </indexterm>
    The same &pooma; programs run on sequential, distributed, and
    parallel computers.  No change in source code is required.  Two or
!   three lines specify how each container's domain should be
    distributed among available processors.  Using these directives and
    run-time information about the computer's configuration, the
    &toolkit; automatically distributes pieces of the container domains,
--- 79,85 ----
          </indexterm>
    The same &pooma; programs run on sequential, distributed, and
    parallel computers.  No change in source code is required.  Two or
!   three lines specify how each container's data should be
    distributed among available processors.  Using these directives and
    run-time information about the computer's configuration, the
    &toolkit; automatically distributes pieces of the container domains,
***************
*** 283,289 ****
    <indexterm zone="introduction-goals-efficient-pete">
     <primary>inner-loop evaluation</primary>
    </indexterm>
!   &pooma; uses &pete; technology to ensure inner loops involving
    &pooma;'s object-oriented containers run as quickly as hand-coded
    <!-- FIXME: Add a citation to Dr. Dobb's Journal article
    pete-99. --> loops.  &pete; (the <application>Portable Expression Template
--- 283,289 ----
    <indexterm zone="introduction-goals-efficient-pete">
     <primary>inner-loop evaluation</primary>
    </indexterm>
!   &pooma; uses the &pete; Library to ensure inner loops involving
    &pooma;'s object-oriented containers run as quickly as hand-coded
    <!-- FIXME: Add a citation to Dr. Dobb's Journal article
    pete-99. --> loops.  &pete; (the <application>Portable Expression Template
*************** A += -B + 2 * C;
*** 303,317 ****
    converted, at compile time, to a loop directly evaluating each component of
    the result without computing intermediate values.
    For example, the code corresponding to the statement above is
!   <programlisting>
!   vector&lt;double&gt;::iterator iterA = A.begin();
!   vector&lt;int&gt;::const_iterator iterB = B.begin();
!   vector&lt;double&gt;::const_iterator iterC = C.begin();
!   while (iterA != A.end()) {
!     *iterA += -*iterB + 2 * *iterC;
!     ++iterA; ++iterB; ++iterC;
!   }</programlisting>
!   Furthermore, since the code is available at compile time, not run time,
    it can be further optimized, e.g., moving any loop-invariant code out
    of the loop.</para>
  
--- 303,317 ----
    converted, at compile time, to a loop directly evaluating each component of
    the result without computing intermediate values.
    For example, the code corresponding to the statement above is
! <programlisting>
! vector&lt;double&gt;::iterator iterA = A.begin();
! vector&lt;int&gt;::const_iterator iterB = B.begin();
! vector&lt;double&gt;::const_iterator iterC = C.begin();
! while (iterA != A.end()) {
!   *iterA += -*iterB + 2 * *iterC;
!   ++iterA; ++iterB; ++iterC;
! }
! </programlisting>  Furthermore, since the code is available at compile time, not run time,
    it can be further optimized, e.g., moving any loop-invariant code out
    of the loop.</para>
  
*************** A += -B + 2 * C;
*** 330,340 ****
    </indexterm>
    as
    part of the U.S. government's science-based Stockpile Stewardship
!   Program
    <indexterm>
     <primary>Stockpile Stewardship Program</primary>
    </indexterm>
!   to simulate nuclear weapons.  Other applications include a
    matrix solver, an accelerator code simulating the dynamics of
    high-intensity charged particle beams in linear accelerators, and a
    Monte Carlo
--- 330,340 ----
    </indexterm>
    as
    part of the U.S. government's science-based Stockpile Stewardship
!   Program.
    <indexterm>
     <primary>Stockpile Stewardship Program</primary>
    </indexterm>
!   Other applications include a
    matrix solver, an accelerator code simulating the dynamics of
    high-intensity charged particle beams in linear accelerators, and a
    Monte Carlo
*************** A += -B + 2 * C;
*** 400,406 ****
  
  
   <section id="introduction-open_source">
!   <title>&pooma; is Free, Open-Source Software</title>
  
    <indexterm zone="introduction-open_source">
     <primary>open-source software</primary>
--- 400,406 ----
  
  
   <section id="introduction-open_source">
!   <title>&pooma; is Open-Source Software</title>
  
    <indexterm zone="introduction-open_source">
     <primary>open-source software</primary>
*************** A += -B + 2 * C;
*** 416,426 ****
    available, any programmer may add it.  Any programmer can extend it
    to solve problems in previously unsupported domains.  Companies
    using the &toolkit; can read the source code to ensure it has no
!   security holes.  It may be downloaded for free
    and used for perpetuity.  There are no annual licenses and no
    on-going costs.  By keeping their own copies, companies are
    guaranteed the software will never disappear.  In summary, the
!   &poomatoolkit; is free, low-risk software.</para>
   </section>
  
  
--- 416,426 ----
    available, any programmer may add it.  Any programmer can extend it
    to solve problems in previously unsupported domains.  Companies
    using the &toolkit; can read the source code to ensure it has no
!   security holes.  It may be downloaded at no cost
    and used for perpetuity.  There are no annual licenses and no
    on-going costs.  By keeping their own copies, companies are
    guaranteed the software will never disappear.  In summary, the
!   &poomatoolkit; is low-risk software.</para>
   </section>
  
  
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.10
diff -c -p -r1.10 manual.xml
*** manual.xml	2002/01/25 02:28:26	1.10
--- manual.xml	2002/01/29 18:11:24
***************
*** 2,8 ****
  <!-- FIXME: Index this file. -->
  <!-- FIXME: What font does DocBook/JadeTeX use?  Can we use it for the figures? -->
  
! <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "file://usr/lib/sgml/docbookx.dtd" [
  
  <!-- Text to Check, Revise, Replace -->
    <!-- FIXME: Revise before releasing. -->
--- 2,8 ----
  <!-- FIXME: Index this file. -->
  <!-- FIXME: What font does DocBook/JadeTeX use?  Can we use it for the figures? -->
  
! <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "file:///usr/lib/sgml/docbookx.dtd" [
  
  <!-- Text to Check, Revise, Replace -->
    <!-- FIXME: Revise before releasing. -->
***************
*** 188,194 ****
  <!ENTITY poomadownloadpage '<ulink url="http://pooma.codesourcery.com/pooma/download">http://pooma.codesourcery.com/pooma/download</ulink>'>
    <!-- The WWW page supporting downloading the &pooma; source code. -->
    <!-- UPDATE this URL. -->
! <!ENTITY poomahomepage '<ulink url="http://www.pooma.com/">http://www.pooma.com/</ulink>'>
    <!-- The canonical Pooma home page. -->
    <!-- UPDATE this filename. -->
  <!ENTITY poomasource "pooma-2.3.0">
--- 188,194 ----
  <!ENTITY poomadownloadpage '<ulink url="http://pooma.codesourcery.com/pooma/download">http://pooma.codesourcery.com/pooma/download</ulink>'>
    <!-- The WWW page supporting downloading the &pooma; source code. -->
    <!-- UPDATE this URL. -->
! <!ENTITY poomahomepage '<ulink url="http://www.codesourcery.com/pooma/pooma/">http://www.codesourcery.com/pooma/pooma/</ulink>'>
    <!-- The canonical Pooma home page. -->
    <!-- UPDATE this filename. -->
  <!ENTITY poomasource "pooma-2.3.0">
***************
*** 352,359 ****
  
    <section id="preface-acknowledgements">
     <title>Acknowledgements</title>
  
!    <para>Mark Mitchell, Stephen Smith</para>
    </section>
  
   </preface>
--- 352,397 ----
  
    <section id="preface-acknowledgements">
     <title>Acknowledgements</title>
+ ]]>  <!-- end unfinished -->
  
! <![%temporary;[
!   <preface id="acknowledgements">
!    <title>Acknowledgements</title>
! ]]>  <!-- end temporary -->
! 
!    <para>This &book; would not have been completed without the help
!    and encouragement of a lot of people and organizations.  Los Alamos
!    National Laboratory funded the writing of this manual and the
!    development of the &poomatoolkit;.  John Reynders conceived,
!    advocated, and headed &pooma; development in its early days, and
!    Scott Haney continued the leadership.  Susan Atlas, Subhankar
!    Banerjee, Timothy Cleland, Julian Cummings, James Crotinger, David
!    Forslund, Salman Habib, Scott Haney, Paul Hinker, William Humphrey,
!    Steve Karmesin, Graham Mark, Jeffrey&nbsp;D. Oldham, Ji Qiang, John
!    Reynders, Robert Ryne, Stephen Smith, M.&nbsp;Srikant, Marydell
!    Tholburn, and Timothy Williams all helped develop &pooma;. Rod
!    Oldehoeft and Jeff Brown of Los Alamos National Laboratory
!    supported CodeSourcery's and Proximation's work, including the
!    development of this manual.  John Hall, Don Marshall, Jean
!    Marshall, and the rest of the BLANCA team at Los Alamos worked
!    closely with the developers and provided valuable suggestions for
!    improvements.</para>
! 
!    <para>I am grateful to James Crotinger, Mark Mitchell, and Stephen
!    Smith who answered my many questions during the writing of this
!    &book;.</para>
! 
!   <!-- We cheat and abuse an epigraph here. -->
!   <epigraph>
!    <attribution>Jeffrey&nbsp;D. Oldham, 2002 January</attribution>
!    <para></para>
!   </epigraph>
! 
! <![%temporary;[
!  </preface>
! ]]>  <!-- end temporary -->
! 
! <![%unfinished;[
    </section>
  
   </preface>
*************** UNFINISHED</para>
*** 3728,3734 ****
  
  <![%unfinished;[
    <para>ADD: Write this section, including extensive instructions
!   for Unix, MS Windows, and MacOS.  List the configuration options.
    Be sure to describe configuring for parallel execution.</para>
  ]]>  <!-- end unfinished -->
  
--- 3766,3772 ----
  
  <![%unfinished;[
    <para>ADD: Write this section, including extensive instructions
!   for Unix-like, MS Windows, and MacOS.  List the configuration options.
    Be sure to describe configuring for parallel execution.</para>
  ]]>  <!-- end unfinished -->
  
*************** UNFINISHED</para>
*** 3751,3758 ****
      example, the &author; uses this library on a two-processor
      computer running &linux;.  The library, available at <ulink
      url="http://www.engelschall.com/sw/mm/">http://www.engelschall.com/sw/mm/</ulink>,
!     is available for free and has been successfully tested on a
!     variety of Unix platforms.</para>
  
      <para>We describe how to download and install the &mm; library.
       <orderedlist spacing="compact">
--- 3789,3796 ----
      example, the &author; uses this library on a two-processor
      computer running &linux;.  The library, available at <ulink
      url="http://www.engelschall.com/sw/mm/">http://www.engelschall.com/sw/mm/</ulink>,
!     is available at no cost and has been successfully tested on a
!     variety of Unix-like platforms.</para>
  
      <para>We describe how to download and install the &mm; library.
       <orderedlist spacing="compact">
*************** UNFINISHED</para>
*** 3777,3784 ****
           specifying the <command>&dashdash;help</command> option.  Since the
           &author; prefers to keep all &pooma;-related code in his
           <filename class="directory">pooma</filename>subdirectory, he
!          uses <command>./configure
!          &dashdash;prefix=${HOME}/pooma/mm-1.1.3</command>.</para>
  	</listitem>
  	<listitem>
  	 <para>Create the library by issuing the
--- 3815,3824 ----
           specifying the <command>&dashdash;help</command> option.  Since the
           &author; prefers to keep all &pooma;-related code in his
           <filename class="directory">pooma</filename>subdirectory, he
!          uses
! <programlisting>
! ./configure &dashdash;prefix=${HOME}/pooma/mm-1.1.3
! </programlisting></para>
  	</listitem>
  	<listitem>
  	 <para>Create the library by issuing the
*************** UNFINISHED</para>
*** 3825,3836 ****
   (FIXME: xref linkend="mpi99", <ulink
      url="http://www-unix.mcs.anl.gov/mpi/"></ulink>)
  ]]>  <!-- end unfinished -->
!     or the &mm;
!     Shared Memory Library.  &mpi; works on a wide variety of platforms
!     and has achieved widespread usage.  &mm; works under Unix on any
!     computer with shared memory.  Both libraries are available for
!     free.  The instructions below work for whichever library you
!     choose.</para>
  
      <para>We describe how to download and install &cheetah;.
       <orderedlist spacing="compact">
--- 3865,3875 ----
   (FIXME: xref linkend="mpi99", <ulink
      url="http://www-unix.mcs.anl.gov/mpi/"></ulink>)
  ]]>  <!-- end unfinished -->
!     or the &mm; Shared Memory Library.  &mpi; works on a wide variety
!     of platforms and has achieved widespread usage.  &mm; works under
!     Unix-like operating systems on any computer with shared memory.  Both libraries are
!     available at no cost.  The instructions below work for whichever
!     library you choose.</para>
  
      <para>We describe how to download and install &cheetah;.
       <orderedlist spacing="compact">
*************** UNFINISHED</para>
*** 3967,3974 ****
         <para>Set the &cheetah; directory environment variable
          <envar>CHEETAHDIR</envar> to the directory containing the
          installed &cheetah; library.  For
!         example, <command>declare -x
!         CHEETAHDIR=${HOME}/pooma/cheetah-1.0</command> specifies the
          installation directory used in the previous section.  If using
          the <application>csh</application> shell, use <command>setenv 
          CHEETAHDIR ${HOME}/pooma/cheetah-1.0</command>.</para>
--- 4006,4015 ----
         <para>Set the &cheetah; directory environment variable
          <envar>CHEETAHDIR</envar> to the directory containing the
          installed &cheetah; library.  For
!         example,
! <programlisting>
! declare -x CHEETAHDIR=${HOME}/pooma/cheetah-1.0
! </programlisting> specifies the
          installation directory used in the previous section.  If using
          the <application>csh</application> shell, use <command>setenv 
          CHEETAHDIR ${HOME}/pooma/cheetah-1.0</command>.</para>
Index: template.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/template.xml,v
retrieving revision 1.2
diff -c -p -r1.2 template.xml
*** template.xml	2002/01/24 05:11:21	1.2
--- template.xml	2002/01/29 18:11:25
***************
*** 104,111 ****
      values.</para>
  
      <para>All computation not involving run-time input or output can
!     occur at program time, compile time, or run time, whichever is
!     more convenient.  At program time, a programmer can perform
      computations by hand rather than writing code to compute it.  &cc;
      templates are Turing-complete so they can compute anything
      computable.  Unfortunately, syntax for compile-time computation is
--- 104,111 ----
      values.</para>
  
      <para>All computation not involving run-time input or output can
!     occur at programming time, compile time, or run time, whichever is
!     more convenient.  At programming time, a programmer can perform
      computations by hand rather than writing code to compute it.  &cc;
      templates are Turing-complete so they can compute anything
      computable.  Unfortunately, syntax for compile-time computation is
***************
*** 257,265 ****
       <primary>function</primary>
       <secondary>application</secondary>
      </indexterm>
!     A template class is analogous to a
!     function.  The analogy between compile-time and run-time
!     programming constructs can be extended.  <xref
      linkend="template_programming-template_use-correspondence_table"></xref>
      lists these correspondences.  For example, at run time, values
      consist of things such as integers, floating point numbers,
--- 257,265 ----
       <primary>function</primary>
       <secondary>application</secondary>
      </indexterm>
!     A template class is analogous to a function; it is a function from
!     types and constants to classes.  The analogy between compile-time
!     and run-time programming constructs can be extended.  <xref
      linkend="template_programming-template_use-correspondence_table"></xref>
      lists these correspondences.  For example, at run time, values
      consist of things such as integers, floating point numbers,
*************** struct usuallySimpleClass&lt;false&gt; {
*** 770,778 ****
      </indexterm>
      creates a file
      containing the intermediate code.  Unfortunately,
!     reading and understanding the code is frequently difficult.
!     Perhaps future &cc; compilers will support easy inspection of
!     optimized code.</para>
  
      <para>Each category<firstterm></firstterm> of values supports a
      distinct set of operations.  For example, the run-time category of
--- 770,776 ----
      </indexterm>
      creates a file
      containing the intermediate code.  Unfortunately,
!     reading and understanding the code is frequently difficult.</para>
  
      <para>Each category<firstterm></firstterm> of values supports a
      distinct set of operations.  For example, the run-time category of
*************** struct ExpressionTraits&lt;BinaryNode&lt
*** 834,840 ****
  {
    typedef typename ExpressionTraits&lt;Left&gt;::Type_t  Left_t;
    typedef typename ExpressionTraits&lt;Right&gt;::Type_t Right_t;
!   typedef typename CombineExpressionTraits&lt;Left_t, Right_t&gt;::Type_t Type_t;
  };
  </programlisting> consists of a class definition and internal type
      definitions.  This traits class contains three values, all types
--- 832,839 ----
  {
    typedef typename ExpressionTraits&lt;Left&gt;::Type_t  Left_t;
    typedef typename ExpressionTraits&lt;Right&gt;::Type_t Right_t;
!   typedef typename
!     CombineExpressionTraits&lt;Left_t, Right_t&gt;::Type_t Type_t;
  };
  </programlisting> consists of a class definition and internal type
      definitions.  This traits class contains three values, all types
*************** class F {
*** 1027,1035 ****
      <operator>+</operator> operator is overloaded to add two &array;s,
      which require template parameters to specify:
  <programlisting>
! template &lt;int D1,class T1,class E1,int D2,class T2,class E2&gt;
  // complicated return type omitted
! operator+(const Array&lt;D1,T1,E1&gt; & l,const Array&lt;D2,T2,E2&gt; & r);
  </programlisting>  Without using function templates, it would not be
      possible to write expressions such as <statement>a1 +
      a2</statement>.  Member functions can also be templated.  This
--- 1026,1036 ----
      <operator>+</operator> operator is overloaded to add two &array;s,
      which require template parameters to specify:
  <programlisting>
! template &lt;int D1,class T1,class E1,
!              int D2,class T2,class E2&gt;
  // complicated return type omitted
! operator+(const Array&lt;D1,T1,E1&gt; & l,
!           const Array&lt;D2,T2,E2&gt; & r);
  </programlisting>  Without using function templates, it would not be
      possible to write expressions such as <statement>a1 +
      a2</statement>.  Member functions can also be templated.  This
*************** template&lt;class T&gt;
*** 1080,1086 ****
  struct CreateLeaf
  {
    typedef Scalar&lt;T&gt; Leaf_t;
!   inline static Leaf_t make(const T&amp; a) { return Scalar&lt;T&gt;(a); }
  };
  </programlisting>  Thus,
      <function>CreateLeaf&lt;T&gt;::make</function> is a function with
--- 1081,1088 ----
  struct CreateLeaf
  {
    typedef Scalar&lt;T&gt; Leaf_t;
!   inline static Leaf_t make(const T&amp; a)
!     { return Scalar&lt;T&gt;(a); }
  };
  </programlisting>  Thus,
      <function>CreateLeaf&lt;T&gt;::make</function> is a function with
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.7
diff -c -p -r1.7 tutorial.xml
*** tutorial.xml	2002/01/24 05:11:21	1.7
--- tutorial.xml	2002/01/29 18:11:25
***************
*** 114,125 ****
  ]]>  <!-- end unfinished -->
  
    <para>In this section, we describe how to obtain, build, and
!   install the &poomatoolkit;.  We focus on installing under the
!   Unix operating system.
  <![%unfinished;[
    Instructions for installing on computers
    running Microsoft Windows or MacOS, as well as more extensive
!   instructions for Unix, appear in <xref
    linkend="installation"></xref>.
  ]]>  <!-- end unfinished -->
    </para>
--- 114,125 ----
  ]]>  <!-- end unfinished -->
  
    <para>In this section, we describe how to obtain, build, and
!   install the &poomatoolkit;.  We focus on installing under a
!   Unix-like operating system.
  <![%unfinished;[
    Instructions for installing on computers
    running Microsoft Windows or MacOS, as well as more extensive
!   instructions for Unix-like operating systems, appear in <xref
    linkend="installation"></xref>.
  ]]>  <!-- end unfinished -->
    </para>
***************
*** 141,147 ****
    class="libraryfile">LINUXgcc.conf</filename> supports compiling
    under a &linux; operating system with &gcc;, while <filename
    class="libraryfile">SGI64KCC.conf</filename> supports compiling
!   under a 64-bit <application>SGI</application> Unix operating system
  <!-- FIXME: Center the following command. -->
    with &kcc;.  Next, configure the source code: <command>./configure
    &dashdash;arch LINUXgcc &dashdash;opt &dashdash;suite
--- 141,147 ----
    class="libraryfile">LINUXgcc.conf</filename> supports compiling
    under a &linux; operating system with &gcc;, while <filename
    class="libraryfile">SGI64KCC.conf</filename> supports compiling
!   under a 64-bit <application>SGI</application> Irix operating system
  <!-- FIXME: Center the following command. -->
    with &kcc;.  Next, configure the source code: <command>./configure
    &dashdash;arch LINUXgcc &dashdash;opt &dashdash;suite
***************
*** 715,721 ****
       <imagedata fileref="figures/distributed.101" format="EPS" align="center"></imagedata>
      </imageobject>
      <textobject>
!      <phrase>the &pooma; distributed computation model</phrase>
      </textobject>
      <caption>
       <para>The &pooma; distributed computation model creates a layout
--- 715,723 ----
       <imagedata fileref="figures/distributed.101" format="EPS" align="center"></imagedata>
      </imageobject>
      <textobject>
!      <phrase>The &pooma; distributed computation model has three
!       pieces: partitioning domain, computer configuration, and
!       layout.</phrase>
      </textobject>
      <caption>
       <para>The &pooma; distributed computation model creates a layout
***************
*** 793,801 ****
    template parameter is <type>Remote</type>.  Its <type>Brick</type>
    template parameter specifies the &engine; for a particular patch on
    a particular context.  Most distributed programs use
!   <type>MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt;</type> or
!   <type>MultiPatch&lt;UniformTag, Remote&lt;CompressibleBrick&gt;
!   &gt;</type> &engine;s.</para>
  
    <para>The computations for a distributed implementation are exactly
    the same as for a sequential implementation.  The &poomatoolkit; and
--- 795,806 ----
    template parameter is <type>Remote</type>.  Its <type>Brick</type>
    template parameter specifies the &engine; for a particular patch on
    a particular context.  Most distributed programs use
! <programlisting>
! MultiPatch&lt;UniformTag, Remote&lt;Brick&closeclose;
! </programlisting> or
! <programlisting>
! MultiPatch&lt;UniformTag, Remote&lt;CompressibleBrick&closeclose;
! </programlisting> or &engine;s.</para>
  
    <para>The computations for a distributed implementation are exactly
    the same as for a sequential implementation.  The &poomatoolkit; and

From oldham at codesourcery.com  Wed Jan 30 23:13:24 2002
From: oldham at codesourcery.com (Jeffrey D . Oldham)
Date: Wed, 30 Jan 2002 15:13:24 -0800
Subject: Manual: Today's Patch
Message-ID: <20020130151324.A25694@vaio.codesourcery.com>

The POOMA manual must be delivered tomorrow.  The formatting changes
continue, but the volume decreases.

2002-Jan-30  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* Makefile: Clean to convert from a general Makefile to one for
	creating the POOMA manual.
	* arrays.xml: Revise tags to ones that are implemented by DocBook.
	* concepts.xml: Revise figures to support PostScript and HTML/PDF.
	* data-parallel.xml: Likewise.
	* introduction.xml: Likewise.
	* manual.xml: Remove FIXME comment.
	* template.xml: Shorten section titles.  Reformat type.
	* tutorial.xml: Revise figures to support PostScript and HTML/PDF.

Applied to	mainline
Approved by	Jeff Brown.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: Makefile
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/Makefile,v
retrieving revision 1.2
diff -c -p -r1.2 Makefile
*** Makefile	2002/01/25 02:28:25	1.2
--- Makefile	2002/01/30 22:59:22
***************
*** 1,74 ****
  ### Oldham, Jeffrey D.
! ### 1997 Dec 26
! ### misc
  ###
! ### LaTeX -> PostScript/PDF/WWW
! ### XML -> TeX/DVI/PS/PDF
  
- # Definitions for PostScript and WWW Creation
  TEX=		latex
- WWWHOMEDIR=	/u/oldham/www
- LATEX2HTML=	latex2html
- BASICLATEX2HTMLOPTIONS=	-info "" -no_footnode -no_math -html_version 3.2,math
- #LATEX2HTMLOPTIONS=	-local_icons -split +1 $(BASICLATEX2HTMLOPTIONS)
- LATEX2HTMLOPTIONS=	-no_navigation -split 0 $(BASICLATEX2HTMLOPTIONS)
- MPOST=		mpost
  
  # Definitions for Jade.
  JADEDIR=		/usr/lib/sgml/stylesheets/docbook
! PRINTDOCBOOKDSL=	print/docbook.dsl
! HTMLDOCBOOKDSL=		html/docbook.dsl
  XML=			dtds/decls/xml.dcl
  INDEXOPTIONS=		-t 'Index' -i 'index' -g -p
  
! CXXFLAGS= -g -Wall -pedantic -W -Wstrict-prototypes -Wpointer-arith -Wbad-function-cast -Wcast-align -Wconversion -Wnested-externs -Wundef -Winline -static
  
! all: manual.ps
  
! manual.dvi: manual.xml introduction.xml template.xml tutorial.xml \
!             concepts.xml arrays.xml data-parallel.xml glossary.xml \
!             bibliography.xml
  
! %.all:	%.ps %.pdf %.html
! 	chmod 644 $*.ps $*.pdf
! 	mv $*.ps $*.pdf $*
! 
! %.dvi:	%.ltx
! 	$(TEX) $<
! 	# bibtex $*
! 	# $(TEX) $<
! 	$(TEX) $<
! 
! %.ps:	%.dvi
! 	dvips -t letter $< -o
! 
! %.pdf.ltx:	%.ltx
! 	sed -e 's/^%\\usepackage{times}/\\usepackage{times}/' $< > $@
! 
! %.pdf:	%.pdf.ltx
! 	pdflatex $<
! 	mv $@.pdf $@
  
! # This rule assumes index creation.
! %.dvi:	%.xml genindex.sgm
! 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $< && \
! 	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index && \
! 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) -V tex-backend $(XML) $< && jadetex $*.tex && jadetex $*.tex && jadetex $*.tex
  
  genindex.sgm:
  	perl collateindex.pl $(INDEXOPTIONS) -N -o $@
  
! %.html:	%.xml
  	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) $(XML) $<
  
! %.pdf:	%.xml
! 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) $(XML) $< && pdfjadetex $*.tex && pdfjadetex $*.tex
! 
! mproof-%.ps:	%.mp
! 	declare -x TEX=latex && $(MPOST) $< && tex mproof.tex $*.[0-9]* && dvips mproof.dvi -o $@
  
! %.txt:	%.ltx
! 	detex $< > $@
  
  clean:
! 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.mpx mpxerr.tex HTML.index manual.tex genindex.sgm
--- 1,54 ----
  ### Oldham, Jeffrey D.
! ### 2002Jan29
! ### POOMA
  ###
! ### POOMA Manual Creation
  
  TEX=		latex
  
  # Definitions for Jade.
  JADEDIR=		/usr/lib/sgml/stylesheets/docbook
! PRINTDOCBOOKDSL=	print.dsl # print/docbook.dsl
! HTMLDOCBOOKDSL=		html.dsl # html/docbook.dsl
  XML=			dtds/decls/xml.dcl
  INDEXOPTIONS=		-t 'Index' -i 'index' -g -p
  
! XMLSOURCES= manual.xml introduction.xml template.xml tutorial.xml \
!             concepts.xml arrays.xml data-parallel.xml glossary.xml \
!             bibliography.xml 
  
! ## HERE  How do I include dependences on programs?
  
! all: manual.ps manual.pdf manual.html
  
! manual.dvi manual.pdf manual.html: $(XMLSOURCES) figures
  
! figures:
! 	$(MAKE) -C figures
  
  genindex.sgm:
  	perl collateindex.pl $(INDEXOPTIONS) -N -o $@
  
! %.html:	%.xml html.dsl
  	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) $(XML) $<
  
! # This rule assumes index creation.
! %.dvi:	%.xml genindex.sgm print.dsl
! 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $<
! 	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index
! 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) -V tex-backend -V use-eps $(XML) $<
! 	jadetex $*.tex
! 	jadetex $*.tex
! 	jadetex $*.tex
  
! # This rule assumes index creation.
! %.pdf:	%.xml genindex.sgm print.dsl
! 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $<
! 	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index
! 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) $(XML) $<
! 	pdfjadetex $*.tex
! 	pdfjadetex $*.tex
! 	pdfjadetex $*.tex
  
  clean:
! 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.html *.mpx mpxerr.tex HTML.index manual.tex genindex.sgm pooma-html.manifest
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.5
diff -c -p -r1.5 arrays.xml
*** arrays.xml	2002/01/29 21:45:42	1.5
--- arrays.xml	2002/01/30 22:59:23
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1644,1651 ****
      domain index to a particular processor and memory used to compute
      the associated value.<!-- FIXME: Add a reference to the
      corresponding chapter. --> The two internal enumerations
!     <fieldsynopsis><varname>dimensions</varname></fieldsynopsis> and
!     <fieldsynopsis><varname>rank</varname></fieldsynopsis> both record
      the &array;'s dimension.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
--- 1644,1651 ----
      domain index to a particular processor and memory used to compute
      the associated value.<!-- FIXME: Add a reference to the
      corresponding chapter. --> The two internal enumerations
!     <varname>dimensions</varname> and
!     <varname>rank</varname> both record
      the &array;'s dimension.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.10
diff -c -p -r1.10 concepts.xml
*** concepts.xml	2002/01/29 21:45:42	1.10
--- concepts.xml	2002/01/30 22:59:24
***************
*** 330,335 ****
--- 330,338 ----
       <imageobject>
  	<imagedata fileref="figures/concepts.111" format="EPS" align="center"></imagedata>
       </imageobject>
+      <imageobject>
+ 	<imagedata fileref="figures/concepts-111.png" format="PNG" align="center"></imagedata>
+      </imageobject>
       <textobject>
  	<phrase>concepts involved in declaring containers</phrase>
       </textobject>
***************
*** 355,360 ****
--- 358,366 ----
      <mediaobject>
       <imageobject>
  	<imagedata fileref="figures/concepts.101" format="EPS" align="center"></imagedata>
+      </imageobject>
+      <imageobject>
+ 	<imagedata fileref="figures/concepts-101.png" format="PNG" align="center"></imagedata>
       </imageobject>
       <textobject>
  	<phrase>&array;s and &field;s map from indices to values.</phrase>
Index: data-parallel.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/data-parallel.xml,v
retrieving revision 1.4
diff -c -p -r1.4 data-parallel.xml
*** data-parallel.xml	2002/01/29 21:45:42	1.4
--- data-parallel.xml	2002/01/30 22:59:25
*************** Array<2, double, Brick> A(I,I), B(J,H);
*** 123,128 ****
--- 123,131 ----
  	<imageobject>
  	 <imagedata fileref="figures/data-parallel.212" format="EPS" align="center"></imagedata>
  	</imageobject>
+ 	<imageobject>
+ 	 <imagedata fileref="figures/data-parallel-212.png" format="PNG" align="center"></imagedata>
+ 	</imageobject>
  	<textobject>
  	 <phrase>Adding two arrays with different domains adds values
         with the same indices.</phrase>
*************** Expression&lt;BinaryNode&lt;OpAdd,
*** 985,990 ****
--- 988,996 ----
         <mediaobject>
  	<imageobject>
  	 <imagedata fileref="figures/data-parallel.101" format="EPS" align="center"></imagedata>
+ 	</imageobject>
+ 	<imageobject>
+ 	 <imagedata fileref="figures/data-parallel-101.png" format="PNG" align="center"></imagedata>
  	</imageobject>
  	<textobject>
  	 <phrase>A parse tree for the statement is produced.</phrase>
Index: introduction.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/introduction.xml,v
retrieving revision 1.5
diff -c -p -r1.5 introduction.xml
*** introduction.xml	2002/01/29 21:45:42	1.5
--- introduction.xml	2002/01/30 22:59:26
***************
*** 126,131 ****
--- 126,134 ----
      <imageobject>
       <imagedata fileref="figures/introduction.101" format="EPS" align="center"></imagedata>
      </imageobject>
+     <imageobject>
+      <imagedata fileref="figures/introduction-101.png" format="PNG" align="center"></imagedata>
+     </imageobject>
      <textobject>
       <phrase>&pooma; helps translate algorithms into programs.</phrase>
      </textobject>
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.11
diff -c -p -r1.11 manual.xml
*** manual.xml	2002/01/29 21:45:42	1.11
--- manual.xml	2002/01/30 22:59:29
***************
*** 1,6 ****
  <?xml version="1.0"?>
  <!-- FIXME: Index this file. -->
- <!-- FIXME: What font does DocBook/JadeTeX use?  Can we use it for the figures? -->
  
  <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "file:///usr/lib/sgml/docbookx.dtd" [
  
--- 1,5 ----
Index: template.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/template.xml,v
retrieving revision 1.3
diff -c -p -r1.3 template.xml
*** template.xml	2002/01/29 21:45:42	1.3
--- template.xml	2002/01/30 22:59:30
***************
*** 281,287 ****
  	   orient="port" pgwide="0"
  	   id="template_programming-template_use-correspondence_table">
       <title>Correspondences Between Run-Time and Compile-Time
!      Programming Constructs</title>
        
        <tgroup cols="3" align="left">
         <thead>
--- 281,287 ----
  	   orient="port" pgwide="0"
  	   id="template_programming-template_use-correspondence_table">
       <title>Correspondences Between Run-Time and Compile-Time
!      Constructs</title>
        
        <tgroup cols="3" align="left">
         <thead>
*************** typedef typename Engine_t::Domain_t Doma
*** 524,530 ****
       orient="port" pgwide="0"
       id="template_programming-pooma_implementation-correspondence_table">
       <title>More Correspondences Between Run-Time and Compile-Time
!      Programming Constructs</title>
       
       <tgroup cols="3" align="left">
        <thead>
--- 524,530 ----
       orient="port" pgwide="0"
       id="template_programming-pooma_implementation-correspondence_table">
       <title>More Correspondences Between Run-Time and Compile-Time
!      Constructs</title>
       
       <tgroup cols="3" align="left">
        <thead>
*************** struct CreateLeaf&lt;Expression&lt;T&clo
*** 943,949 ****
      matches the condition is executed.  If no case label matches the
      condition, the default code, if present, is used.  In template
      programming, instantiating a template, e.g.,
!     <type>CreateLeaf&lt;Expression&lt;int&closeclose;</type> serves as
      the condition.  The set of template parameters for the indicated
      template class, e.g., <type>CreateLeaf</type>, are analogous to
      the case labels, and each has an associated definition.  In our
--- 943,951 ----
      matches the condition is executed.  If no case label matches the
      condition, the default code, if present, is used.  In template
      programming, instantiating a template, e.g.,
! <programlisting>
! CreateLeaf&lt;Expression&lt;int&closeclose;
! </programlisting> serves as
      the condition.  The set of template parameters for the indicated
      template class, e.g., <type>CreateLeaf</type>, are analogous to
      the case labels, and each has an associated definition.  In our
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.8
diff -c -p -r1.8 tutorial.xml
*** tutorial.xml	2002/01/29 21:45:42	1.8
--- tutorial.xml	2002/01/30 22:59:31
***************
*** 69,74 ****
--- 69,77 ----
     <imageobject>
      <imagedata fileref="figures/doof2d.201" format="EPS" align="center"></imagedata>
     </imageobject>
+    <imageobject>
+     <imagedata fileref="figures/doof2d-201.png" format="PNG" align="center"></imagedata>
+    </imageobject>
     <textobject>
      <phrase>The Initial &doof2d; Configuration</phrase>
     </textobject>
***************
*** 77,82 ****
--- 80,88 ----
     <imageobject>
      <imagedata fileref="figures/doof2d.202" format="EPS"></imagedata>
     </imageobject>
+    <imageobject>
+     <imagedata fileref="figures/doof2d-202.png" format="PNG"></imagedata>
+    </imageobject>
     <textobject>
      <phrase>After the First Averaging</phrase>
     </textobject>
***************
*** 85,90 ****
--- 91,99 ----
     <imageobject>
      <imagedata fileref="figures/doof2d.203" format="EPS"></imagedata>
     </imageobject>
+    <imageobject>
+     <imagedata fileref="figures/doof2d-203.png" format="PNG"></imagedata>
+    </imageobject>
     <textobject>
      <phrase>After the Second Averaging</phrase>
     </textobject>
***************
*** 484,489 ****
--- 493,501 ----
      <imageobject>
       <imagedata fileref="figures/doof2d.210" format="EPS" align="center"></imagedata>
      </imageobject>
+     <imageobject>
+      <imagedata fileref="figures/doof2d-210.png" format="PNG" align="center"></imagedata>
+     </imageobject>
      <textobject>
       <phrase>Adding two arrays is supported.</phrase>
      </textobject>
***************
*** 580,585 ****
--- 592,600 ----
      <imageobject>
       <imagedata fileref="figures/doof2d.211" format="EPS" align="center"></imagedata>
      </imageobject>
+     <imageobject>
+      <imagedata fileref="figures/doof2d-211.png" format="PNG" align="center"></imagedata>
+     </imageobject>
      <textobject>
       <phrase>Apply a stencil to position (1,3) of an &array;.</phrase>
      </textobject>
***************
*** 713,718 ****
--- 728,736 ----
     <mediaobject>
      <imageobject>
       <imagedata fileref="figures/distributed.101" format="EPS" align="center"></imagedata>
+     </imageobject>
+     <imageobject>
+      <imagedata fileref="figures/distributed-101.png" format="PNG" align="center"></imagedata>
      </imageobject>
      <textobject>
       <phrase>The &pooma; distributed computation model has three

From oldham at codesourcery.com  Wed Jan 30 23:43:15 2002
From: oldham at codesourcery.com (Jeffrey D . Oldham)
Date: Wed, 30 Jan 2002 15:43:15 -0800
Subject: Manual Patch: Figure Code
Message-ID: <20020130154315.A25949@vaio.codesourcery.com>

2002-Jan-30  Jeffrey D. Oldham  <oldham at codesourcery.com>

This patch moves most, hopefully all, of the manual's figure creation code
into the CVS tree.  Including the PNG files, used for the HTML and PDF
versions of the manual, is not strictly necessary since they can be
created.  However, converting the EPS files created MetaPost to PNG uses
the non-standard peps program so I include them in the tree.

The MetaPost source files were modified to include fonts in the initial
comments.
	
	* concepts-101.png: New illustration.
	* concepts-111.png: Likewise.
	* concepts.mp: Minor tweaking.  Include fonts in comments.
	* data-parallel-101.png: New illustration.
	* data-parallel-212.png: Likewise.
	* data-parallel.mp: Minor tweaking.  Include fonts in comments.
	* distributed-101.png: New illustration.
	* distributed.mp: Minor tweaking.  Include fonts in comments.  Fix
	labelling of context box.
	* doof2d-201.png: New illustration.
	* doof2d-202.png: Likewise.
	* doof2d-203.png: Likewise.
	* doof2d-210.png: Likewise.
	* doof2d-211.png: Likewise.
	* doof2d.mp: Minor tweaking.  Include fonts in comments.  Modify
	to avoid kerning problems.  Avoid math font problem by omitting
	'$...$'.
	* introduction-101.png: New illustration.
	* introduction.mp: Minor tweaking.  Include fonts in comments.
	* macros.ltx: Avoid macros to avoid kerning problems.

Applied to	mainline.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: concepts-101.png
===================================================================
RCS file: concepts-101.png
diff -N concepts-101.png
Binary files /dev/null and concepts-101.png differ
Index: concepts-111.png
===================================================================
RCS file: concepts-111.png
diff -N concepts-111.png
Binary files /dev/null and concepts-111.png differ
Index: concepts.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/concepts.mp,v
retrieving revision 1.3
diff -c -p -r1.3 concepts.mp
*** concepts.mp	2001/12/14 04:18:13	1.3
--- concepts.mp	2002/01/30 23:17:45
***************
*** 6,23 ****
  
  %% Assumes TEX=latex.
  
  input boxes;
  
  verbatimtex
! \documentclass[10pt]{article}
  \input{macros.ltx}
  \begin{document}
  etex
  
  
  %% Container Declaration Concepts and Dependences
  beginfig(111)
!   numeric unit; unit = 0.9cm;
    numeric horizSpace; horizSpace = unit;
    numeric vertSpace; vertSpace = unit;
    
--- 6,27 ----
  
  %% Assumes TEX=latex.
  
+ %% Ensure fonts are included in the output.
+ prologues := 2;			% >= 2 for PostScript
+ 
  input boxes;
  
  verbatimtex
! \documentclass[12pt]{article}
  \input{macros.ltx}
+ \usepackage{times}
  \begin{document}
  etex
  
  
  %% Container Declaration Concepts and Dependences
  beginfig(111)
!   numeric unit; unit = 0.5cm;
    numeric horizSpace; horizSpace = unit;
    numeric vertSpace; vertSpace = unit;
    
Index: data-parallel-101.png
===================================================================
RCS file: data-parallel-101.png
diff -N data-parallel-101.png
Binary files /dev/null and data-parallel-101.png differ
Index: data-parallel-212.png
===================================================================
RCS file: data-parallel-212.png
diff -N data-parallel-212.png
Binary files /dev/null and data-parallel-212.png differ
Index: data-parallel.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/data-parallel.mp,v
retrieving revision 1.1
diff -c -p -r1.1 data-parallel.mp
*** data-parallel.mp	2002/01/04 17:42:43	1.1
--- data-parallel.mp	2002/01/30 23:17:45
***************
*** 6,18 ****
  
  %% Assumes TEX=latex.
  
  input boxes;
  input box-macros;
  input grid-macros;
  
  verbatimtex
! \documentclass[10pt]{article}
  \input{macros.ltx}
  \begin{document}
  etex
  
--- 6,22 ----
  
  %% Assumes TEX=latex.
  
+ %% Ensure fonts are included in the output.
+ prologues := 2;			% >= 2 for PostScript
+ 
  input boxes;
  input box-macros;
  input grid-macros;
  
  verbatimtex
! \documentclass[12pt]{article}
  \input{macros.ltx}
+ \usepackage{times}
  \begin{document}
  etex
  
Index: distributed-101.png
===================================================================
RCS file: distributed-101.png
diff -N distributed-101.png
Binary files /dev/null and distributed-101.png differ
Index: distributed.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/distributed.mp,v
retrieving revision 1.2
diff -c -p -r1.2 distributed.mp
*** distributed.mp	2001/12/11 20:36:13	1.2
--- distributed.mp	2002/01/30 23:17:47
***************
*** 6,16 ****
  
  %% Assumes TEX=latex.
  
  input boxes;
  
  verbatimtex
! \documentclass[10pt]{article}
  \input{macros.ltx}
  \begin{document}
  etex
  
--- 6,20 ----
  
  %% Assumes TEX=latex.
  
+ %% Ensure fonts are included in the output.
+ prologues := 2;			% >= 2 for PostScript
+ 
  input boxes;
  
  verbatimtex
! \documentclass[12pt]{article}
  \input{macros.ltx}
+ \usepackage{times}
  \begin{document}
  etex
  
*************** beginfig(101)
*** 174,181 ****
      drawboxed(c[t]);
    endfor
    label.top(btex contexts etex, c[1].n);
-   label.bot(btex \begin{tabular}{c} Each context has memory and\\ processors to execute a program. \end{tabular} etex, c[1].s);
    drawboxed(configurationBoundary);
    label.top(btex Computer Configuration etex, configurationBoundary.n);
  
    %% Draw the Computer Computation structures.
--- 178,188 ----
      drawboxed(c[t]);
    endfor
    label.top(btex contexts etex, c[1].n);
    drawboxed(configurationBoundary);
+   picture foo;
+   foo = thelabel.bot(btex \begin{tabular}{c} Each context has memory and\\ processors to execute a program. \end{tabular} etex, c[1].s);
+   unfill bbox foo;
+   draw foo;
    label.top(btex Computer Configuration etex, configurationBoundary.n);
  
    %% Draw the Computer Computation structures.
Index: doof2d-201.png
===================================================================
RCS file: doof2d-201.png
diff -N doof2d-201.png
Binary files /dev/null and doof2d-201.png differ
Index: doof2d-202.png
===================================================================
RCS file: doof2d-202.png
diff -N doof2d-202.png
Binary files /dev/null and doof2d-202.png differ
Index: doof2d-203.png
===================================================================
RCS file: doof2d-203.png
diff -N doof2d-203.png
Binary files /dev/null and doof2d-203.png differ
Index: doof2d-210.png
===================================================================
RCS file: doof2d-210.png
diff -N doof2d-210.png
Binary files /dev/null and doof2d-210.png differ
Index: doof2d-211.png
===================================================================
RCS file: doof2d-211.png
diff -N doof2d-211.png
Binary files /dev/null and doof2d-211.png differ
Index: doof2d.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/doof2d.mp,v
retrieving revision 1.4
diff -c -p -r1.4 doof2d.mp
*** doof2d.mp	2002/01/25 02:58:25	1.4
--- doof2d.mp	2002/01/30 23:17:47
***************
*** 6,17 ****
  
  %% Assumes TEX=latex.
  
  verbatimtex
! \documentclass[10pt]{article}
  \input{macros.ltx}
  \begin{document}
  etex
  
  input grid-macros;
  
  %% Global Declarations
--- 6,23 ----
  
  %% Assumes TEX=latex.
  
+ %% Ensure fonts are included in the output.
+ prologues := 2;			% >= 2 for PostScript
+ 
  verbatimtex
! \documentclass[12pt]{article}
! \usepackage{times}
  \input{macros.ltx}
  \begin{document}
+ 
  etex
  
+ 
  input grid-macros;
  
  %% Global Declarations
*************** beginfig(201)
*** 37,43 ****
    endfor
  
    % Label the grid.
!   labelGrid(btex Array \varname{b}: Initial Configuration etex, nuCells, origin);
  endfig;
  
  
--- 43,49 ----
    endfor
  
    % Label the grid.
!   labelGrid(btex Array \varname{b}: Initial Con\avoidfi guration etex, nuCells, origin);
  endfig;
  
  
*************** beginfig(202)
*** 66,72 ****
    endfor
    
    % Label the grid.
!   labelGrid(btex Array \varname{a}: After the first averaging etex, nuCells, origin);
  endfig;
  
  
--- 72,78 ----
    endfor
    
    % Label the grid.
!   labelGrid(btex Array \varname{a}: After the \avoidfi rst averaging etex, nuCells, origin);
  endfig;
  
  
*************** beginfig(210)
*** 186,194 ****
    labelCellLeft(btex \footnotesize 2 etex, (0,2), z0);
    
    %% Label the grids.
!   labelGrid(btex $b(I,J)+b(I+1,J-1)$ etex, nuCells, z0);
!   labelGrid(btex $b(I,J)$ etex, nuCells, z1);
!   labelGrid(btex $b(I+1,J-1)$ etex, nuCells, z2);
  endfig;
  
  
--- 192,203 ----
    labelCellLeft(btex \footnotesize 2 etex, (0,2), z0);
    
    %% Label the grids.
! %% Avoid mpost problem.  labelGrid(btex $b(I,J)+b(I+1,J-1)$ etex, nuCells, z0);
! %% Avoid mpost problem.  labelGrid(btex $b(I,J)$ etex, nuCells, z1);
! %% Avoid mpost problem.  labelGrid(btex $b(I+1,J-1)$ etex, nuCells, z2);
!   labelGrid(btex b(I,J)+b(I+1,J-1) etex, nuCells, z0);
!   labelGrid(btex b(I,J) etex, nuCells, z1);
!   labelGrid(btex b(I+1,J-1) etex, nuCells, z2);
  endfig;
  
  
Index: introduction-101.png
===================================================================
RCS file: introduction-101.png
diff -N introduction-101.png
Binary files /dev/null and introduction-101.png differ
Index: introduction.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/introduction.mp,v
retrieving revision 1.3
diff -c -p -r1.3 introduction.mp
*** introduction.mp	2002/01/25 02:58:25	1.3
--- introduction.mp	2002/01/30 23:17:47
***************
*** 6,18 ****
  
  %% Assumes TEX=latex.
  
  input boxes;
  input box-macros;
  
  verbatimtex
! \documentclass[10pt]{article}
  \usepackage{amsmath}
  \input{macros.ltx}
  \begin{document}
  etex
  
--- 6,22 ----
  
  %% Assumes TEX=latex.
  
+ %% Ensure fonts are included in the output.
+ prologues := 2;			% >= 2 for PostScript
+ 
  input boxes;
  input box-macros;
  
  verbatimtex
! \documentclass[12pt]{article}
  \usepackage{amsmath}
  \input{macros.ltx}
+ \usepackage{times}
  \begin{document}
  etex
  
Index: macros.ltx
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/macros.ltx,v
retrieving revision 1.2
diff -c -p -r1.2 macros.ltx
*** macros.ltx	2002/01/25 02:58:25	1.2
--- macros.ltx	2002/01/30 23:17:47
***************
*** 35,37 ****
--- 35,43 ----
  \newcommand{\varname}[1]{\texttt{#1}}%
  	% Produce a C++ (or other programming language) variable.
  	% Requires:	1. the variable's name.
+ 
+ % Avoid dvitomp Errors.
+ \newcommand{\avoidfi}{f\mbox{}i}%
+ 	% Avoid a problem with dvitomp and ligatures.
+ \newcommand{\avoidFi}{F\mbox{}i}%
+ 	% Avoid a problem with dvitomp and ligatures.

From oldham at codesourcery.com  Wed Jan 30 23:54:45 2002
From: oldham at codesourcery.com (Jeffrey D . Oldham)
Date: Wed, 30 Jan 2002 15:54:45 -0800
Subject: Manual Patch: Use Standard DocBook Tags
Message-ID: <20020130155445.A26013@vaio.codesourcery.com>

2002-Jan-30  Jeffrey D. Oldham  <oldham at codesourcery.com>

Before this change, the POOMA manual used non-standard tags to describe
programming language features: <statement>, <keywordname>, <methodname>,
<operator>.  Since these are not standard, we replace them with <literal>,
losing information. :(

	* arrays.xml: Replace <statement>, <keywordname>, <methodname>, and
	<operator> with <literal>.
	* concepts.xml: Likewise.
	* data-parallel.xml: Likewise.
	* glossary.xml: Likewise.
	* introduction.xml: Likewise.
	* manual.xml: Likewise.
	* template.xml: Likewise.
	* tutorial.xml: Likewise.

Applied to	mainline.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.6
diff -c -p -r1.6 arrays.xml
*** arrays.xml	2002/01/30 23:09:06	1.6
--- arrays.xml	2002/01/30 23:47:30
***************
*** 79,85 ****
      objects<firstterm></firstterm></glossterm> so they can be used
      more easily than built-in &cc; arrays.  For example, &array;s can
      be used as operands and in assignment statements.  The statement
!     <statement>a = a + b;</statement> adds corresponding values of
      &array;s <varname>a</varname> and <varname>b</varname>, assigning
      the sums to the &array; <varname>a</varname>.  The statement
      treats each array as an object, rather than requiring the use of
--- 79,85 ----
      objects<firstterm></firstterm></glossterm> so they can be used
      more easily than built-in &cc; arrays.  For example, &array;s can
      be used as operands and in assignment statements.  The statement
!     <literal>a = a + b;</literal> adds corresponding values of
      &array;s <varname>a</varname> and <varname>b</varname>, assigning
      the sums to the &array; <varname>a</varname>.  The statement
      treats each array as an object, rather than requiring the use of
***************
*** 87,94 ****
      statements such as this are further discussed in <xref
      linkend="data_parallel"></xref>.  &array;s also handle their own
      memory allocation and deallocation.  For example, the &array;
!     declaration <statement>Array&lt;2, double, Brick&gt;
!     a(vertDomain)</statement> creates an
      &array;&nbsp;<varname>a</varname>, allocating whatever memory it
      needs.  When <varname>a</varname> goes out of scope, it and its
      memory are automatically deallocated.  Automatic memory allocation
--- 87,94 ----
      statements such as this are further discussed in <xref
      linkend="data_parallel"></xref>.  &array;s also handle their own
      memory allocation and deallocation.  For example, the &array;
!     declaration <literal>Array&lt;2, double, Brick&gt;
!     a(vertDomain)</literal> creates an
      &array;&nbsp;<varname>a</varname>, allocating whatever memory it
      needs.  When <varname>a</varname> goes out of scope, it and its
      memory are automatically deallocated.  Automatic memory allocation
***************
*** 96,102 ****
  
      <para>Individual &array; values can be accessed using parentheses,
      not square brackets, as for &cc; arrays.  For example,
!     <statement>a(3,4)</statement> yields the value at position (3,4)
      of <varname>a</varname>'s two-dimensional domain.</para>
     </section>
  
--- 96,102 ----
  
      <para>Individual &array; values can be accessed using parentheses,
      not square brackets, as for &cc; arrays.  For example,
!     <literal>a(3,4)</literal> yields the value at position (3,4)
      of <varname>a</varname>'s two-dimensional domain.</para>
     </section>
  
***************
*** 179,188 ****
      <para>All the &domain; categories listed above except &grid; can
      be represented using domain triplet notation.  Since the triplet
      [7:7:1] represents {7}, or more simply&nbsp;7, it can also
!     represent the one-dimensional <statement>Loc<1>(7)</statement>.
      Multidimensional &loc;s are similarly represented.  For example,
      [0:0:1,10:10:1,2:2:1] represents
!     <statement>Loc<3>(0,10,2)</statement>, but it is frequently
      abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
      [a:b:1], while a &range; has specific stride&nbsp;s, e.g.,
      [a:b:s].</para>
--- 179,188 ----
      <para>All the &domain; categories listed above except &grid; can
      be represented using domain triplet notation.  Since the triplet
      [7:7:1] represents {7}, or more simply&nbsp;7, it can also
!     represent the one-dimensional <literal>Loc<1>(7)</literal>.
      Multidimensional &loc;s are similarly represented.  For example,
      [0:0:1,10:10:1,2:2:1] represents
!     <literal>Loc<3>(0,10,2)</literal>, but it is frequently
      abbreviated as [0,10,2].  An &interval; [a,b] has unit stride:
      [a:b:1], while a &range; has specific stride&nbsp;s, e.g.,
      [a:b:s].</para>
***************
*** 192,199 ****
      &interval; is the direct product of two one-dimensional
      &interval;s, it can be specified using two one-dimensional
      &interval;s.  For example,
!     <statement>Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
!     Interval&lt;1&gt;(4,5))</statement> creates a [2:3:1,4:5:1]
      &domain;.  The resulting dimensionality equals the sum of the
      components' dimensions.  For example, a four-dimension &loc; can
      be specified using three- and one-dimension &loc;s or using four
--- 192,199 ----
      &interval; is the direct product of two one-dimensional
      &interval;s, it can be specified using two one-dimensional
      &interval;s.  For example,
!     <literal>Interval&lt;2&gt;(Interval&lt;1&gt;(2,3),
!     Interval&lt;1&gt;(4,5))</literal> creates a [2:3:1,4:5:1]
      &domain;.  The resulting dimensionality equals the sum of the
      components' dimensions.  For example, a four-dimension &loc; can
      be specified using three- and one-dimension &loc;s or using four
***************
*** 206,217 ****
      different types.  A &loc; object can be constructed from other
      &loc; objects and integers.  &interval;s, &range;s, and &grid;s
      can be constructed using any of these types, &loc;s, and integers.
!     For example, <statement>Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2),
!     Interval&lt;1&gt;(3,5))</statement> uses a two-dimensional &loc;
      and a one-dimensional &interval; to create a [1:1:1,2:2:1,3:5:1]
      &domain;.  During creation of a &domain;, the type of each object
      is changed to the &domain;'s type.  In the example,
!     <statement>Loc&lt;2&gt;(1,2)</statement> is first converted to an
      &interval;.</para>
  
      <para>&domain;s can participate in some arithmetic and comparison
--- 206,217 ----
      different types.  A &loc; object can be constructed from other
      &loc; objects and integers.  &interval;s, &range;s, and &grid;s
      can be constructed using any of these types, &loc;s, and integers.
!     For example, <literal>Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2),
!     Interval&lt;1&gt;(3,5))</literal> uses a two-dimensional &loc;
      and a one-dimensional &interval; to create a [1:1:1,2:2:1,3:5:1]
      &domain;.  During creation of a &domain;, the type of each object
      is changed to the &domain;'s type.  In the example,
!     <literal>Loc&lt;2&gt;(1,2)</literal> is first converted to an
      &interval;.</para>
  
      <para>&domain;s can participate in some arithmetic and comparison
***************
*** 293,317 ****
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><statement>Loc&lt;1&gt;()</statement></entry>
  	  <entry>indicates zero.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
  	  <entry>creates an uninitialized &locone;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
  	  <entry>creates a &locone; with the integer converted from <varname>t1</varname>.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
  	  <entry>creates a &locone; with the integer converted from
  	  <varname>t1</varname>.  <varname>t2</varname> must equal
  	  <varname>t1</varname>.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
  	  <entry>creates a &locone; with the integer converted from
  	  <varname>t1</varname>.  <varname>t2</varname> must equal
  	  <varname>t1</varname>, and <varname>t3</varname> is
--- 293,317 ----
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><literal>Loc&lt;1&gt;()</literal></entry>
  	  <entry>indicates zero.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;1&gt;(const Pooma::NoInit&amp; no)</literal></entry>
  	  <entry>creates an uninitialized &locone;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1)</literal></entry>
  	  <entry>creates a &locone; with the integer converted from <varname>t1</varname>.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</literal></entry>
  	  <entry>creates a &locone; with the integer converted from
  	  <varname>t1</varname>.  <varname>t2</varname> must equal
  	  <varname>t1</varname>.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</literal></entry>
  	  <entry>creates a &locone; with the integer converted from
  	  <varname>t1</varname>.  <varname>t2</varname> must equal
  	  <varname>t1</varname>, and <varname>t3</varname> is
***************
*** 360,405 ****
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;()</statement></entry>
  	  <entry>indicates zero.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
  	  <entry>creates an uninitialized &loc;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
  	  <entry>creates a &loc; using the given &domain; object.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</statement></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</statement></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	</tbody>
--- 360,405 ----
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><literal>Loc&lt;&dim;&gt;()</literal></entry>
  	  <entry>indicates zero.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</literal></entry>
  	  <entry>creates an uninitialized &loc;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</literal></entry>
  	  <entry>creates a &loc; using the given &domain; object.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</literal></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</literal></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</literal></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</literal></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</literal></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Loc&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</literal></entry>
  	  <entry>creates a &loc; using the given &domain; objects.</entry>
  	 </row>
  	</tbody>
***************
*** 418,425 ****
        to a multidimensional &domain; object that itself can be converted
        into a &loc;.  The total dimensionality of all the arguments'
        types should be at most&nbsp;<varname>&dim;</varname>.  For example,
!       <statement>Loc<5>(Range<1>(2,2,2), Loc<2>(2,3),
!       Interval<1>(4,4))</statement> creates a five-dimensional &loc;
        [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
        &loc;, and a one-dimensional &interval;.  The final fifth
        dimension has an unspecified value, in this case&nbsp;1.  The
--- 418,425 ----
        to a multidimensional &domain; object that itself can be converted
        into a &loc;.  The total dimensionality of all the arguments'
        types should be at most&nbsp;<varname>&dim;</varname>.  For example,
!       <literal>Loc<5>(Range<1>(2,2,2), Loc<2>(2,3),
!       Interval<1>(4,4))</literal> creates a five-dimensional &loc;
        [2,2,3,4,1] using a one-dimensional &range;, a two-dimensional
        &loc;, and a one-dimensional &interval;.  The final fifth
        dimension has an unspecified value, in this case&nbsp;1.  The
***************
*** 466,489 ****
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><statement>Interval&lt;1&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized interval.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
  	  <entry>creates an uninitialized &intervalone;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
  	  <entry>creates an &intervalone;.  See the text for an explanation.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
  	  <entry>creates an &intervalone; with the integers converted from
  	  <varname>t1</varname> and <varname>t2</varname>.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
  	  <entry>creates an &intervalone; with the integers converted from
  	  <varname>t1</varname> and <varname>t2</varname>.
  	  <varname>t3</varname> must equal&nbsp;1.</entry>
--- 466,489 ----
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><literal>Interval&lt;1&gt;()</literal></entry>
  	  <entry>creates an empty, uninitialized interval.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;1&gt;(const Pooma::NoInit&amp; no)</literal></entry>
  	  <entry>creates an uninitialized &intervalone;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1)</literal></entry>
  	  <entry>creates an &intervalone;.  See the text for an explanation.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</literal></entry>
  	  <entry>creates an &intervalone; with the integers converted from
  	  <varname>t1</varname> and <varname>t2</varname>.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</literal></entry>
  	  <entry>creates an &intervalone; with the integers converted from
  	  <varname>t1</varname> and <varname>t2</varname>.
  	  <varname>t3</varname> must equal&nbsp;1.</entry>
***************
*** 532,577 ****
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
  	  <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
  	  <entry>creates an &interval; using the given &domain; object.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</statement></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</statement></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	</tbody>
--- 532,577 ----
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><literal>Interval&lt;&dim;&gt;()</literal></entry>
  	  <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</literal></entry>
  	  <entry>creates an empty, uninitialized &interval;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</literal></entry>
  	  <entry>creates an &interval; using the given &domain; object.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</literal></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</literal></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</literal></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</literal></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</literal></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Interval&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</literal></entry>
  	  <entry>creates an &interval; using the given &domain; objects.</entry>
  	 </row>
  	</tbody>
***************
*** 637,661 ****
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><statement>Range&lt;1&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized range.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;1&gt;(const Pooma::NoInit&amp; no)</statement></entry>
  	  <entry>creates an uninitialized &rangeone;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
  	  <entry>creates a &rangeone;.  See the text for an explanation.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
  	  <entry>creates a &rangeone; with an interval specified by the
  	  integers converted from <varname>t1</varname> and
  	  <varname>t2</varname>.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
  	  <entry>creates a &rangeone; by converting the arguments to
  	  integers <varname>i1</varname>, <varname>i2</varname>, and
  	  <varname>i3</varname> and then making a range [i1:i2:i3].</entry>
--- 637,661 ----
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><literal>Range&lt;1&gt;()</literal></entry>
  	  <entry>creates an empty, uninitialized range.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;1&gt;(const Pooma::NoInit&amp; no)</literal></entry>
  	  <entry>creates an uninitialized &rangeone;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;1&gt;(const &domaintemplate;1&amp; t1)</literal></entry>
  	  <entry>creates a &rangeone;.  See the text for an explanation.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</literal></entry>
  	  <entry>creates a &rangeone; with an interval specified by the
  	  integers converted from <varname>t1</varname> and
  	  <varname>t2</varname>.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</literal></entry>
  	  <entry>creates a &rangeone; by converting the arguments to
  	  integers <varname>i1</varname>, <varname>i2</varname>, and
  	  <varname>i3</varname> and then making a range [i1:i2:i3].</entry>
***************
*** 702,747 ****
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</statement></entry>
  	  <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
  	  <entry>creates a &range; using the given &domain; object.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</statement></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</statement></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	</tbody>
--- 702,747 ----
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><literal>Range&lt;&dim;&gt;()</literal></entry>
  	  <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;&dim;&gt;(const Pooma::NoInit&amp; no)</literal></entry>
  	  <entry>creates an empty, uninitialized &range;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</literal></entry>
  	  <entry>creates a &range; using the given &domain; object.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</literal></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</literal></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</literal></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</literal></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</literal></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Range&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</literal></entry>
  	  <entry>creates a &range; using the given &domain; objects.</entry>
  	 </row>
  	</tbody>
***************
*** 811,831 ****
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><statement>Grid&lt;1&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized grid.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
  	  <entry>creates a &gridone;.  See the text for an explanation.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
  	  <entry>creates a &gridone; from the interval specified by the
  	  integers converted from <varname>t1</varname> and
  	  <varname>t2</varname>.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
  	  <entry>creates a &gridone; from the domain triplet specified
  	  by the integers converted from <varname>t1</varname>,
  	  <varname>t2</varname>, and <varname>t3</varname>.</entry>
--- 811,831 ----
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><literal>Grid&lt;1&gt;()</literal></entry>
  	  <entry>creates an empty, uninitialized grid.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1)</literal></entry>
  	  <entry>creates a &gridone;.  See the text for an explanation.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</literal></entry>
  	  <entry>creates a &gridone; from the interval specified by the
  	  integers converted from <varname>t1</varname> and
  	  <varname>t2</varname>.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Grid&lt;1&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</literal></entry>
  	  <entry>creates a &gridone; from the domain triplet specified
  	  by the integers converted from <varname>t1</varname>,
  	  <varname>t2</varname>, and <varname>t3</varname>.</entry>
*************** Grid&lt;1&gt; g(list);
*** 889,930 ****
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;()</statement></entry>
  	  <entry>creates an empty, uninitialized &grid;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</statement></entry>
  	  <entry>creates a &grid; using the given &domain; object.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</statement></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</statement></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</statement></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</statement></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</statement></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><statement>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</statement></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	</tbody>
--- 889,930 ----
  	</tfoot>
  	<tbody valign="top">
  	 <row>
! 	  <entry><literal>Grid&lt;&dim;&gt;()</literal></entry>
  	  <entry>creates an empty, uninitialized &grid;, to be assigned a value later.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1)</literal></entry>
  	  <entry>creates a &grid; using the given &domain; object.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2)</literal></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3)</literal></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
! 	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4)</literal></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5)</literal></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6)</literal></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	 <row>
! 	  <entry><literal>Grid&lt;&dim;&gt;(const &domaintemplate;1&amp; t1, const
  	  &domaintemplate;2&amp; t2, const &domaintemplate;3&amp; t3, const &domaintemplate;4&amp; t4, const &domaintemplate;5&amp;
! 	  t5, const &domaintemplate;6&amp; t6, const &domaintemplate;7&amp; t7)</literal></entry>
  	  <entry>creates a &grid; using the given &domain; objects.</entry>
  	 </row>
  	</tbody>
*************** Grid&lt;1&gt; g(list);
*** 995,1009 ****
  	 <entry>Multidimensional &domain; Accessors</entry>
  	</row>
  	<row>
! 	 <entry><statement>long size()</statement></entry>
  	 <entry>returns the total number of indices.</entry>
  	</row>
  	<row>
! 	 <entry><statement>bool empty()</statement></entry>
  	 <entry>returns &true; if and only if the &domain; has no indices.</entry>
  	</row>
  	<row>
! 	 <entry><statement>D&lt;1&gt; operator[](int dimension)</statement></entry>
  	 <entry>returns the one-dimensional &domain; for the specified
  	 dimension.  The return type is a one-dimensional version of
  	 the &domain;.</entry>
--- 995,1009 ----
  	 <entry>Multidimensional &domain; Accessors</entry>
  	</row>
  	<row>
! 	 <entry><literal>long size()</literal></entry>
  	 <entry>returns the total number of indices.</entry>
  	</row>
  	<row>
! 	 <entry><literal>bool empty()</literal></entry>
  	 <entry>returns &true; if and only if the &domain; has no indices.</entry>
  	</row>
  	<row>
! 	 <entry><literal>D&lt;1&gt; operator[](int dimension)</literal></entry>
  	 <entry>returns the one-dimensional &domain; for the specified
  	 dimension.  The return type is a one-dimensional version of
  	 the &domain;.</entry>
*************** Grid&lt;1&gt; g(list);
*** 1012,1043 ****
  	 <entry>One-dimensional &domain; Accessors</entry>
  	</row>
  	<row>
! 	 <entry><statement>long length()</statement></entry>
  	 <entry>returns the number of indices.</entry>
  	</row>
  	<row>
! 	 <entry><statement>int first()</statement></entry>
  	 <entry>returns the beginning of the domain.</entry>
  	</row>
  	<row>
! 	 <entry><statement>int last()</statement></entry>
  	 <entry>returns the ending of the domain.</entry>
  	</row>
  	<row>
! 	 <entry><statement>int min()</statement></entry>
  	 <entry>returns the minimum index in the domain.</entry>
  	</row>
  	<row>
! 	 <entry><statement>int max()</statement></entry>
  	 <entry>returns the maximum index in the domain.</entry>
  	</row>
  	<row>
! 	 <entry><statement>D&lt;1&gt;::iterator begin()</statement></entry>
  	 <entry>returns a forward iterator pointing to the
  	 beginning domain index.</entry>
  	</row>
  	<row>
! 	 <entry><statement>D&lt;1&gt;::iterator end()</statement></entry>
  	 <entry>returns a forward iterator pointing to the ending
  	 domain index.</entry>
  	</row>
--- 1012,1043 ----
  	 <entry>One-dimensional &domain; Accessors</entry>
  	</row>
  	<row>
! 	 <entry><literal>long length()</literal></entry>
  	 <entry>returns the number of indices.</entry>
  	</row>
  	<row>
! 	 <entry><literal>int first()</literal></entry>
  	 <entry>returns the beginning of the domain.</entry>
  	</row>
  	<row>
! 	 <entry><literal>int last()</literal></entry>
  	 <entry>returns the ending of the domain.</entry>
  	</row>
  	<row>
! 	 <entry><literal>int min()</literal></entry>
  	 <entry>returns the minimum index in the domain.</entry>
  	</row>
  	<row>
! 	 <entry><literal>int max()</literal></entry>
  	 <entry>returns the maximum index in the domain.</entry>
  	</row>
  	<row>
! 	 <entry><literal>D&lt;1&gt;::iterator begin()</literal></entry>
  	 <entry>returns a forward iterator pointing to the
  	 beginning domain index.</entry>
  	</row>
  	<row>
! 	 <entry><literal>D&lt;1&gt;::iterator end()</literal></entry>
  	 <entry>returns a forward iterator pointing to the ending
  	 domain index.</entry>
  	</row>
*************** Grid&lt;1&gt; g(list);
*** 1049,1087 ****
       linkend="arrays-domains-use-table"></xref>.  Functions applicable
       to both one-dimensional and multidimensional &domain;s are listed
       before functions that only applicable to one-dimensional
!      &domain;s.  The <methodname>size</methodname> member function
       yields the total number of indices in a given &domain;.  If and
!      only if this number is zero, <methodname>empty</methodname> will
       yield &true;.  A multidimensional
       <type>domain&lt;&dim;&gt;</type> is the direct product of &dim;
!      one-dimensional &domain;s.  The <methodname>operator[](int
!      dimension)</methodname> operator extracts the one-dimensional
       &domain; corresponding to its parameter.  For example, the three
       one-dimensional <type>Range&lt;1&gt;</type> &domain;s can be
       extracted from a <type>Range&lt;3&gt;</type>
       object&nbsp;<varname>r</varname> using
!      <statement>r[0]</statement>, <statement>r[1]</statement>, and
!      <statement>r[2]</statement>.</para>
  
       <para>&domain; accessors applicable only to one-dimensional
       &domain;s are listed in the second half of <xref
       linkend="arrays-domains-use-table"></xref>.  The
!      <methodname>length</methodname> member function, analogous to the
!      multidimensional <methodname>size</methodname> function, returns
       the number of indices in the &domain;.  The
!      <methodname>first</methodname> and <methodname>last</methodname>
       member functions return the domain's beginning and ending
!      indices.  The <methodname>begin</methodname> and
!      <methodname>end</methodname> member functions return forward
       iterators pointing to these respective locations.  They have type
       <type>D&lt;1&gt;::iterator</type>, where <type>D</type>
       abbreviates the &domain;'s type, e.g., &interval; or &grid;.
       <!-- FIXME: Do I need to explain input iterators and their use?
!      --> The <methodname>min</methodname> and
!      <methodname>max</methodname> member functions return the minimum
       and maximum indices in the &domain; object, respectively.  For
       &locone; and &intervalone;, these yield the same values as
!      <methodname>first</methodname> and <methodname>last</methodname>,
       but &rangeone; and &gridone; can have their numerically largest
       index at the beginning of their &domain;s.</para>
      </section>
--- 1049,1087 ----
       linkend="arrays-domains-use-table"></xref>.  Functions applicable
       to both one-dimensional and multidimensional &domain;s are listed
       before functions that only applicable to one-dimensional
!      &domain;s.  The <literal>size</literal> member function
       yields the total number of indices in a given &domain;.  If and
!      only if this number is zero, <literal>empty</literal> will
       yield &true;.  A multidimensional
       <type>domain&lt;&dim;&gt;</type> is the direct product of &dim;
!      one-dimensional &domain;s.  The <literal>operator[](int
!      dimension)</literal> operator extracts the one-dimensional
       &domain; corresponding to its parameter.  For example, the three
       one-dimensional <type>Range&lt;1&gt;</type> &domain;s can be
       extracted from a <type>Range&lt;3&gt;</type>
       object&nbsp;<varname>r</varname> using
!      <literal>r[0]</literal>, <literal>r[1]</literal>, and
!      <literal>r[2]</literal>.</para>
  
       <para>&domain; accessors applicable only to one-dimensional
       &domain;s are listed in the second half of <xref
       linkend="arrays-domains-use-table"></xref>.  The
!      <literal>length</literal> member function, analogous to the
!      multidimensional <literal>size</literal> function, returns
       the number of indices in the &domain;.  The
!      <literal>first</literal> and <literal>last</literal>
       member functions return the domain's beginning and ending
!      indices.  The <literal>begin</literal> and
!      <literal>end</literal> member functions return forward
       iterators pointing to these respective locations.  They have type
       <type>D&lt;1&gt;::iterator</type>, where <type>D</type>
       abbreviates the &domain;'s type, e.g., &interval; or &grid;.
       <!-- FIXME: Do I need to explain input iterators and their use?
!      --> The <literal>min</literal> and
!      <literal>max</literal> member functions return the minimum
       and maximum indices in the &domain; object, respectively.  For
       &locone; and &intervalone;, these yield the same values as
!      <literal>first</literal> and <literal>last</literal>,
       but &rangeone; and &gridone; can have their numerically largest
       index at the beginning of their &domain;s.</para>
      </section>
*************** Grid&lt;1&gt; g(list);
*** 1204,1210 ****
      &hellip;, <varname>DT7</varname>.  The first constructor, with no
      domain arguments, creates an empty, uninitialized &array; for
      which a domain must be specified before it is used.  Specify the
!     array's domain using its <methodname>initialize</methodname>
      function.  The next seven constructors combine their domain
      arguments to compute the resulting &array;'s domain.  These are
      combined in the same way that multidimensional &interval;s are
--- 1204,1210 ----
      &hellip;, <varname>DT7</varname>.  The first constructor, with no
      domain arguments, creates an empty, uninitialized &array; for
      which a domain must be specified before it is used.  Specify the
!     array's domain using its <literal>initialize</literal>
      function.  The next seven constructors combine their domain
      arguments to compute the resulting &array;'s domain.  These are
      combined in the same way that multidimensional &interval;s are
*************** Grid&lt;1&gt; g(list);
*** 1259,1358 ****
        </tfoot>
        <tbody valign="top">
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;()</statement></entry>
  	<entry>creates an empty, uninitialized &array; which must be
! 	<methodname>initialize</methodname>()d before use.</entry>
         </row>
         <!-- Omit Indirection Array because src/Engine/IndirectionEngine.h indicates it is not yet finished. -->
         <!-- Omit the two Array&lt;D1,T1,E1&gt; a constructors, which
         should not be used by users. -->
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1)</statement></entry>
  	<entry>creates an &array; using the given &domain; object or integer.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
! 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6, const DT7&amp; t7)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates an &array; using the given &domain; object or
  	integer and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
--- 1259,1358 ----
        </tfoot>
        <tbody valign="top">
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;()</literal></entry>
  	<entry>creates an empty, uninitialized &array; which must be
! 	<literal>initialize</literal>()d before use.</entry>
         </row>
         <!-- Omit Indirection Array because src/Engine/IndirectionEngine.h indicates it is not yet finished. -->
         <!-- Omit the two Array&lt;D1,T1,E1&gt; a constructors, which
         should not be used by users. -->
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1)</literal></entry>
  	<entry>creates an &array; using the given &domain; object or integer.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
! 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6, const DT7&amp; t7)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates an &array; using the given &domain; object or
  	integer and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;&dim;,T,E&gt;(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates an &array; using the given &domain; objects and
  	integers and
  	then initializes all entries using <varname>model</varname>.</entry>
*************** Array&lt;3&gt; b(2,3,1);
*** 1389,1395 ****
  <programlisting>
  Array&lt;2,bool&gt; c(2,3);
  </programlisting>  To specify a default &array; value of &true;, use
!     <statement>ModelElement&lt;bool&gt;(true)</statement>:
  <programlisting>
  Array&lt;2,bool&gt; c(2,3, ModelElement&lt;bool&gt;(true));.
  </programlisting>  To create a one-dimensional &array; containing
--- 1389,1395 ----
  <programlisting>
  Array&lt;2,bool&gt; c(2,3);
  </programlisting>  To specify a default &array; value of &true;, use
!     <literal>ModelElement&lt;bool&gt;(true)</literal>:
  <programlisting>
  Array&lt;2,bool&gt; c(2,3, ModelElement&lt;bool&gt;(true));.
  </programlisting>  To create a one-dimensional &array; containing
*************** Array&lt;1,double,CompressibleBrick&gt;
*** 1407,1416 ****
      constructor, must have a specified domain before it can be used.
      For example, one must use the parameter-less &array; constructor
      when creating an array of &array;s using
!     <keywordname>new</keywordname> so their domains must be specified.
      (It would probably be better to create an &array; of &array;s
      since memory allocation and deallocation would automatically be
!     handled.)  &array;'s <methodname>initialize</methodname> functions
      accept the same set of domain object specifications and model
      elements that the &array; constructors do, creating the specified
      domain.  See <xref
--- 1407,1416 ----
      constructor, must have a specified domain before it can be used.
      For example, one must use the parameter-less &array; constructor
      when creating an array of &array;s using
!     <literal>new</literal> so their domains must be specified.
      (It would probably be better to create an &array; of &array;s
      since memory allocation and deallocation would automatically be
!     handled.)  &array;'s <literal>initialize</literal> functions
      accept the same set of domain object specifications and model
      elements that the &array; constructors do, creating the specified
      domain.  See <xref
*************** Array<2,float,Brick> a(Interval<1>(2,7),
*** 1426,1432 ****
  // its domain.
  Array<2,float,Brick> b();
  b.initialize(Interval<1>(2,7), Interval<1>(-2,4));.
! </programlisting>  Invoking <methodname>initialize</methodname> on an
      &array; with an existing domain yields unspecified behavior.  All
      &array; values may be lost and memory may be leaked.</para>
  
--- 1426,1432 ----
  // its domain.
  Array<2,float,Brick> b();
  b.initialize(Interval<1>(2,7), Interval<1>(-2,4));.
! </programlisting>  Invoking <literal>initialize</literal> on an
      &array; with an existing domain yields unspecified behavior.  All
      &array; values may be lost and memory may be leaked.</para>
  
*************** b.initialize(Interval<1>(2,7), Interval<
*** 1437,1448 ****
       <tgroup cols="2" align="left">
        <thead>
         <row>
! 	<entry>An &array;'s <methodname>initialize</methodname> member
  	functions sets its domain and should be invoked only for an
  	array created without a domain.  It returns nothing.</entry>
         </row>
         <row>
! 	<entry><methodname>initialize</methodname> declaration</entry>
  	<entry>result</entry>
         </row>
        </thead>
--- 1437,1448 ----
       <tgroup cols="2" align="left">
        <thead>
         <row>
! 	<entry>An &array;'s <literal>initialize</literal> member
  	functions sets its domain and should be invoked only for an
  	array created without a domain.  It returns nothing.</entry>
         </row>
         <row>
! 	<entry><literal>initialize</literal> declaration</entry>
  	<entry>result</entry>
         </row>
        </thead>
*************** b.initialize(Interval<1>(2,7), Interval<
*** 1457,1546 ****
         <!-- Omit Indirection Array initialize because it does not exist! -->
         <!-- Omit the two Array&lt;D1,T1,E1&gt; functions, which should not be used by users. -->
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain;
  object or integer.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const
! 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6, const DT7&amp; t7)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain;
  	object or integer and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain;
  	objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain;
  	objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
! 	const ModelElement&lt;T&gt;&amp; model)</statement></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
--- 1457,1546 ----
         <!-- Omit Indirection Array initialize because it does not exist! -->
         <!-- Omit the two Array&lt;D1,T1,E1&gt; functions, which should not be used by users. -->
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain;
  object or integer.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const DT2&amp; t2)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const
! 	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
! 	 t5, const DT6&amp; t6, const DT7&amp; t7)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain;
  	object or integer and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const DT2&amp; t2,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain;
  	objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const DT2&amp; t2, const DT3&amp; t3,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain;
  	objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>initialize(const DT1&amp; t1, const
  	 DT2&amp; t2, const DT3&amp; t3, const DT4&amp; t4, const DT5&amp;
  	 t5, const DT6&amp; t6, const DT7&amp; t7,
! 	const ModelElement&lt;T&gt;&amp; model)</literal></entry>
  	<entry>creates the &array;'s domain using the given &domain; objects and integers and
  	then initializes all entries using <varname>model</varname>.</entry>
         </row>
*************** std::cout &openopen; a(2,-2) &openopen; 
*** 1583,1593 ****
      numbers.</para>
  
      <para>For read-only access to a value, use the
!     <methodname>read</methodname> member function, which takes the
      same index notation as its nameless read-write counterpart:
  <programlisting>
  std::cout &openopen; a.read(2,-2) &openopen; std::endl;
! </programlisting> Using <methodname>read</methodname> sometimes
      permits the optimizer to produce faster executing code.</para>
  
      <para>Copying &array;s requires little execution time because
--- 1583,1593 ----
      numbers.</para>
  
      <para>For read-only access to a value, use the
!     <literal>read</literal> member function, which takes the
      same index notation as its nameless read-write counterpart:
  <programlisting>
  std::cout &openopen; a.read(2,-2) &openopen; std::endl;
! </programlisting> Using <literal>read</literal> sometimes
      permits the optimizer to produce faster executing code.</para>
  
      <para>Copying &array;s requires little execution time because
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1622,1628 ****
      Destruction is similarly inexpensive.</para>
  
      <para>Array assignment does not have reference semantics.  Thus,
!     the assignment <statement>a = b</statement> ensures that all of
      <varname>a</varname>'s values are the same as <varname>b</varname>
      at the time of assignment only.  Subsequent changes to
      <varname>a</varname>'s values do not change <varname>b</varname>'s
--- 1622,1628 ----
      Destruction is similarly inexpensive.</para>
  
      <para>Array assignment does not have reference semantics.  Thus,
!     the assignment <literal>a = b</literal> ensures that all of
      <varname>a</varname>'s values are the same as <varname>b</varname>
      at the time of assignment only.  Subsequent changes to
      <varname>a</varname>'s values do not change <varname>b</varname>'s
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1637,1645 ****
      constants useful for both compile-time and run-time computations.
      See <xref linkend="arrays-arrays_use-compile_time_table"></xref>.
      These may be accessed using the &array;'s type and the scope
!     resolution operator (<operator>::</operator>).  The table begins
      with a list of internal type definitions, e.g.,
!     <statement>Array&lt;&dim;,T,E&gt;::This_t</statement>.  A
      <glossterm linkend="glossary-layout">layout</glossterm> maps a
      domain index to a particular processor and memory used to compute
      the associated value.<!-- FIXME: Add a reference to the
--- 1637,1645 ----
      constants useful for both compile-time and run-time computations.
      See <xref linkend="arrays-arrays_use-compile_time_table"></xref>.
      These may be accessed using the &array;'s type and the scope
!     resolution operator (<literal>::</literal>).  The table begins
      with a list of internal type definitions, e.g.,
!     <literal>Array&lt;&dim;,T,E&gt;::This_t</literal>.  A
      <glossterm linkend="glossary-layout">layout</glossterm> maps a
      domain index to a particular processor and memory used to compute
      the associated value.<!-- FIXME: Add a reference to the
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1690,1700 ****
  	<entry>the type of the &array;'s layout.</entry>
         </row>
         <row>
! 	<entry><statement>const int dimensions</statement></entry>
  	<entry>the number&nbsp;&dim; of dimensions of the &array;.</entry>
         </row>
         <row>
! 	<entry><statement>const int rank</statement></entry>
  	<entry>synonym for <varname>dimensions</varname>.</entry>
         </row>
        </tbody>
--- 1690,1700 ----
  	<entry>the type of the &array;'s layout.</entry>
         </row>
         <row>
! 	<entry><literal>const int dimensions</literal></entry>
  	<entry>the number&nbsp;&dim; of dimensions of the &array;.</entry>
         </row>
         <row>
! 	<entry><literal>const int rank</literal></entry>
  	<entry>synonym for <varname>dimensions</varname>.</entry>
         </row>
        </tbody>
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1708,1727 ****
      returning the &array;'s domain, which has type
      <type>Array&lt;&dim;,T,E&gt;::Domain_t</type> (abbreviated
      <type>Domain_t</type> in the table).  The next seven functions
!     query the domain.  <methodname>first</methodname>,
!     <methodname>last</methodname>, and <methodname>length</methodname>
      return the first index, last index, and number of indices for the
      specified dimension.  The domain's dimensions are numbered 0, 1,
      &hellip;,
!     <statement>Array&lt;&dim;,T,E&gt;::dimensions</statement>-1.  If
      these values are needed for all dimensions, use
!     <methodname>firsts</methodname>, <methodname>lasts</methodname>,
!     and <methodname>lengths</methodname>.  The returned
      <type>Loc&lt;&dim;&gt;</type>s have &dim; entries, one for each
!     dimension.  <methodname>size</methodname> returns the total number
      of indices in the entire domain.  This is the product of all the
!     dimensions' <methodname>length</methodname>s.  The
!     <methodname>layout</methodname> member function returns the
      &array;'s layout, which specifies the mapping of indices to
      processors and memory.<!-- FIXME: Add a reference to the
      corresponding chapter. --> The last two functions return the
--- 1708,1727 ----
      returning the &array;'s domain, which has type
      <type>Array&lt;&dim;,T,E&gt;::Domain_t</type> (abbreviated
      <type>Domain_t</type> in the table).  The next seven functions
!     query the domain.  <literal>first</literal>,
!     <literal>last</literal>, and <literal>length</literal>
      return the first index, last index, and number of indices for the
      specified dimension.  The domain's dimensions are numbered 0, 1,
      &hellip;,
!     <literal>Array&lt;&dim;,T,E&gt;::dimensions</literal>-1.  If
      these values are needed for all dimensions, use
!     <literal>firsts</literal>, <literal>lasts</literal>,
!     and <literal>lengths</literal>.  The returned
      <type>Loc&lt;&dim;&gt;</type>s have &dim; entries, one for each
!     dimension.  <literal>size</literal> returns the total number
      of indices in the entire domain.  This is the product of all the
!     dimensions' <literal>length</literal>s.  The
!     <literal>layout</literal> member function returns the
      &array;'s layout, which specifies the mapping of indices to
      processors and memory.<!-- FIXME: Add a reference to the
      corresponding chapter. --> The last two functions return the
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1742,1807 ****
         <row>
  	<entry>Internal type definitions, e.g., <type>Domain_t</type>,
  	are listed here without the class type prefix
! 	<statement>Array&lt;&dim;,T,E&gt;::</statement>.</entry>
         </row>
        </tfoot>
        <tbody valign="top">
         <row>
! 	<entry><statement>Domain_t domain()</statement></entry>
  	<entry>returns the &array;'s domain.</entry>
         </row>
         <row>
! 	<entry><statement>Domain_t physicalDomain()</statement></entry>
  	<entry>returns the &array;'s domain.</entry>
         </row>
         <row>
! 	<entry><statement>Domain_t totalDomain()</statement></entry>
  	<entry>returns the &array;'s domain.</entry>
         </row>
         <row>
! 	<entry><statement>int first(int dim)</statement></entry>
  	<entry>returns the first index value for the specified
  	dimension.</entry>
         </row>
         <row>
! 	<entry><statement>int last(int dim)</statement></entry>
  	<entry>returns the last index value for the specified
  	dimension.</entry>
         </row>
         <row>
! 	<entry><statement>int length(int dim)</statement></entry>
  	<entry>returns the number of indices (including endpoints) for
  	the specified dimension.</entry>
         </row>
         <row>
! 	<entry><statement>Loc&lt;Dim&gt; firsts()</statement></entry>
  	<entry>returns the first index values for all the
  	dimensions.</entry>
         </row>
         <row>
! 	<entry><statement>Loc&lt;Dim&gt; lasts()</statement></entry>
  	<entry>returns the last index values for all the specified
  	dimensions.</entry>
         </row>
         <row>
! 	<entry><statement>Loc&lt;Dim&gt; lengths()</statement></entry>
  	<entry>returns the numbers of indices (including endpoints)
  	for all the specified dimensions.</entry>
         </row>
         <row>
! 	<entry><statement>long size()</statement></entry>
  	<entry>returns the total number of indices in the domain.</entry>
         </row>
         <row>
! 	<entry><statement>Layout_t layout()</statement></entry>
  	<entry>returns the &array;'s layout.</entry>
         </row>
         <row>
! 	<entry><statement>Engine_t engine()</statement></entry>
  	<entry>returns the &array;'s engine.</entry>
         </row>
         <row>
! 	<entry><statement>const Engine_t engine()</statement></entry>
  	<entry>returns the &array;'s engine.</entry>
         </row>
        </tbody>
--- 1742,1807 ----
         <row>
  	<entry>Internal type definitions, e.g., <type>Domain_t</type>,
  	are listed here without the class type prefix
! 	<literal>Array&lt;&dim;,T,E&gt;::</literal>.</entry>
         </row>
        </tfoot>
        <tbody valign="top">
         <row>
! 	<entry><literal>Domain_t domain()</literal></entry>
  	<entry>returns the &array;'s domain.</entry>
         </row>
         <row>
! 	<entry><literal>Domain_t physicalDomain()</literal></entry>
  	<entry>returns the &array;'s domain.</entry>
         </row>
         <row>
! 	<entry><literal>Domain_t totalDomain()</literal></entry>
  	<entry>returns the &array;'s domain.</entry>
         </row>
         <row>
! 	<entry><literal>int first(int dim)</literal></entry>
  	<entry>returns the first index value for the specified
  	dimension.</entry>
         </row>
         <row>
! 	<entry><literal>int last(int dim)</literal></entry>
  	<entry>returns the last index value for the specified
  	dimension.</entry>
         </row>
         <row>
! 	<entry><literal>int length(int dim)</literal></entry>
  	<entry>returns the number of indices (including endpoints) for
  	the specified dimension.</entry>
         </row>
         <row>
! 	<entry><literal>Loc&lt;Dim&gt; firsts()</literal></entry>
  	<entry>returns the first index values for all the
  	dimensions.</entry>
         </row>
         <row>
! 	<entry><literal>Loc&lt;Dim&gt; lasts()</literal></entry>
  	<entry>returns the last index values for all the specified
  	dimensions.</entry>
         </row>
         <row>
! 	<entry><literal>Loc&lt;Dim&gt; lengths()</literal></entry>
  	<entry>returns the numbers of indices (including endpoints)
  	for all the specified dimensions.</entry>
         </row>
         <row>
! 	<entry><literal>long size()</literal></entry>
  	<entry>returns the total number of indices in the domain.</entry>
         </row>
         <row>
! 	<entry><literal>Layout_t layout()</literal></entry>
  	<entry>returns the &array;'s layout.</entry>
         </row>
         <row>
! 	<entry><literal>Engine_t engine()</literal></entry>
  	<entry>returns the &array;'s engine.</entry>
         </row>
         <row>
! 	<entry><literal>const Engine_t engine()</literal></entry>
  	<entry>returns the &array;'s engine.</entry>
         </row>
        </tbody>
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1811,1819 ****
      <para>We illustrate using &array; member functions in <xref
      linkend="arrays-arrays_use-members_example"></xref>.  The program
      computes the total number of &array;'s indices, comparing the
!     result with invoking its <methodname>size</methodname> method.
      Since the &array;'s name is <varname>a</varname>,
!     <statement>a.size()</statement> returns its size.  The
      <function>computeArraySize</function> function also computes the
      &array;'s size.  This templated function uses its three template
      parameters to accept any &array;, regardless of its dimension,
--- 1811,1819 ----
      <para>We illustrate using &array; member functions in <xref
      linkend="arrays-arrays_use-members_example"></xref>.  The program
      computes the total number of &array;'s indices, comparing the
!     result with invoking its <literal>size</literal> method.
      Since the &array;'s name is <varname>a</varname>,
!     <literal>a.size()</literal> returns its size.  The
      <function>computeArraySize</function> function also computes the
      &array;'s size.  This templated function uses its three template
      parameters to accept any &array;, regardless of its dimension,
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1823,1832 ****
      illustrates using member functions.  The domain's size is the
      product of the length of each dimension.  Since the lengths are
      stored in the <type>Loc&lt;&dim&gt;</type>
!     <varname>lens</varname>, <statement>lens[d]</statement> is a
      <type>Loc&lt;1&gt;</type>, for which its
!     <methodname>first</methodname> member function extracts the
!     length.  The <methodname>length</methodname> &array; member
      function is used in the <function>PAssert</function>.</para>
  
      <example id="arrays-arrays_use-members_example">
--- 1823,1832 ----
      illustrates using member functions.  The domain's size is the
      product of the length of each dimension.  Since the lengths are
      stored in the <type>Loc&lt;&dim&gt;</type>
!     <varname>lens</varname>, <literal>lens[d]</literal> is a
      <type>Loc&lt;1&gt;</type>, for which its
!     <literal>first</literal> member function extracts the
!     length.  The <literal>length</literal> &array; member
      function is used in the <function>PAssert</function>.</para>
  
      <example id="arrays-arrays_use-members_example">
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1844,1853 ****
         functions' names.  These functions return &loc;s.</para>
        </callout>
        <callout arearefs="arrays-arrays_use-members-example-loc_use">
!        <para><statement>lens[d]</statement> returns a
         <type>Loc&lt;1&gt;</type> for
         dimension&nbsp;<varname>d</varname>'s length.  Invoking
!        <type>Loc&lt;1&gt;</type> <methodname>first</methodname> method
         yields its value.</para>
        </callout>
        <callout arearefs="arrays-arrays_use-members-example-check_length">
--- 1844,1853 ----
         functions' names.  These functions return &loc;s.</para>
        </callout>
        <callout arearefs="arrays-arrays_use-members-example-loc_use">
!        <para><literal>lens[d]</literal> returns a
         <type>Loc&lt;1&gt;</type> for
         dimension&nbsp;<varname>d</varname>'s length.  Invoking
!        <type>Loc&lt;1&gt;</type> <literal>first</literal> method
         yields its value.</para>
        </callout>
        <callout arearefs="arrays-arrays_use-members-example-check_length">
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1855,1861 ****
         using member functions.</para>
        </callout>
        <callout arearefs="arrays-arrays_use-members-example-compare_size">
!        <para>The <methodname>size</methodname> is invoked by
         prepending the &array;'s name followed by a period.  This
         assertion is unnecessary, but the
         <function>computeArraySize</function> function further
--- 1855,1861 ----
         using member functions.</para>
        </callout>
        <callout arearefs="arrays-arrays_use-members-example-compare_size">
!        <para>The <literal>size</literal> is invoked by
         prepending the &array;'s name followed by a period.  This
         assertion is unnecessary, but the
         <function>computeArraySize</function> function further
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1890,1905 ****
      &dynamic; &engine; is analogous to a one-dimensional &brick;
      &engine; supporting a dynamically-resizable domain.  It is also
      usually the default value for this tag.  For example,
!     <statement>DynamicArray&lt;&gt; d0(1);</statement>,
!     <statement>DynamicArray&lt;double&gt; d1(1);</statement>, and
!     <statement>DynamicArray&lt;double, Dynamic&gt; d2(1);</statement>
      all declare the same &dynamicarray;s explicitly storing one
      &double; value.  A &dynamicarray; automatically allocates its
      initial memory and deallocates its final memory, just as an
      &array; does.</para>
  
!     <para>The <methodname>create</methodname> and
!     <methodname>destroy</methodname> member functions permit changing
      a &dynamicarray;'s domain.  <xref
      linkend="arrays-dynamic_arrays-change_size"></xref> lists these member
      functions but omits functions exclusively used in distributed
--- 1890,1905 ----
      &dynamic; &engine; is analogous to a one-dimensional &brick;
      &engine; supporting a dynamically-resizable domain.  It is also
      usually the default value for this tag.  For example,
!     <literal>DynamicArray&lt;&gt; d0(1);</literal>,
!     <literal>DynamicArray&lt;double&gt; d1(1);</literal>, and
!     <literal>DynamicArray&lt;double, Dynamic&gt; d2(1);</literal>
      all declare the same &dynamicarray;s explicitly storing one
      &double; value.  A &dynamicarray; automatically allocates its
      initial memory and deallocates its final memory, just as an
      &array; does.</para>
  
!     <para>The <literal>create</literal> and
!     <literal>destroy</literal> member functions permit changing
      a &dynamicarray;'s domain.  <xref
      linkend="arrays-dynamic_arrays-change_size"></xref> lists these member
      functions but omits functions exclusively used in distributed
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1927,1945 ****
        </tfoot>
        <tbody valign="top">
         <row>
! 	<entry><statement>void create(int num)</statement></entry>
  	<entry>extend the current domain by the requested number of
          elements.</entry>
         </row>
         <row>
! 	<entry><statement>void destroy(const Dom&amp; killList)</statement></entry>
  	<entry>remove the values specified by the indices in the given
  	&domain; argument.  The <quote>Backfill</quote> method moves
  	values from the end of the domain to replace the deleted
  	values.</entry>
         </row>
         <row>
! 	<entry><statement>void destroy(Iter killBegin, Iter killEnd)</statement></entry>
  	<entry>remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
  	iterators.  The <quote>Backfill</quote> method moves values
--- 1927,1945 ----
        </tfoot>
        <tbody valign="top">
         <row>
! 	<entry><literal>void create(int num)</literal></entry>
  	<entry>extend the current domain by the requested number of
          elements.</entry>
         </row>
         <row>
! 	<entry><literal>void destroy(const Dom&amp; killList)</literal></entry>
  	<entry>remove the values specified by the indices in the given
  	&domain; argument.  The <quote>Backfill</quote> method moves
  	values from the end of the domain to replace the deleted
  	values.</entry>
         </row>
         <row>
! 	<entry><literal>void destroy(Iter killBegin, Iter killEnd)</literal></entry>
  	<entry>remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
  	iterators.  The <quote>Backfill</quote> method moves values
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1947,1954 ****
  	values.</entry>
         </row>
         <row>
! 	<entry><statement>void destroy(const Dom&amp; killList, const
! 	DeleteMethod&amp; method)</statement></entry>
  
  	<entry>remove the values specified by the indices in the
  	given &domain; argument.  Deleted values can be replaced by
--- 1947,1954 ----
  	values.</entry>
         </row>
         <row>
! 	<entry><literal>void destroy(const Dom&amp; killList, const
! 	DeleteMethod&amp; method)</literal></entry>
  
  	<entry>remove the values specified by the indices in the
  	given &domain; argument.  Deleted values can be replaced by
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1958,1965 ****
  	ordering.</entry>
         </row>
         <row>
! 	<entry><statement>void destroy(Iter killBegin, Iter killEnd,
! 	const DeleteMethod&amp; method)</statement></entry>
          <entry>remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
  	iterators.  Deleted values can be replaced by
--- 1958,1965 ----
  	ordering.</entry>
         </row>
         <row>
! 	<entry><literal>void destroy(Iter killBegin, Iter killEnd,
! 	const DeleteMethod&amp; method)</literal></entry>
          <entry>remove the values specified by the indices in the
  	container range [begin,end) specified by the random-access
  	iterators.  Deleted values can be replaced by
*************** std::cout &openopen; a.read(2,-2) &openo
*** 1972,1985 ****
       </tgroup>
      </table>
  
!     <para>The <methodname>destroy</methodname> member function deletes
      the specified indices.  The indices may be specified using either
      a &domain; object (<type>Interval&lt;1&gt;</type>,
      <type>Range&lt;1&gt;</type>, or <type>IndirectionList</type>) or
      by random-access iterators pointing into a container.  For
      example, every other value from a ten-value
      array&nbsp;<varname>d</varname> might be removed using
!     <statement>Range&lt;1&gt;(0,9,2)</statement>.  Alternatively,
  <programlisting>
  int killList[] = {0, 2, 4, 6, 8};
  d.destroy(killList, killList+5);
--- 1972,1985 ----
       </tgroup>
      </table>
  
!     <para>The <literal>destroy</literal> member function deletes
      the specified indices.  The indices may be specified using either
      a &domain; object (<type>Interval&lt;1&gt;</type>,
      <type>Range&lt;1&gt;</type>, or <type>IndirectionList</type>) or
      by random-access iterators pointing into a container.  For
      example, every other value from a ten-value
      array&nbsp;<varname>d</varname> might be removed using
!     <literal>Range&lt;1&gt;(0,9,2)</literal>.  Alternatively,
  <programlisting>
  int killList[] = {0, 2, 4, 6, 8};
  d.destroy(killList, killList+5);
*************** d.destroy(killList, killList+5);
*** 2002,2012 ****
  	<entry>0 1 2 3</entry>
         </row>
         <row>
! 	<entry><methodname>destroy</methodname> using <type>BackFill</type>:</entry>
  	<entry>3 1 2</entry>
         </row>
         <row>
! 	<entry><methodname>destroy</methodname> using <type>ShiftUp</type>:</entry>
  	<entry>1 2 3</entry>
         </row>
        </tbody>
--- 2002,2012 ----
  	<entry>0 1 2 3</entry>
         </row>
         <row>
! 	<entry><literal>destroy</literal> using <type>BackFill</type>:</entry>
  	<entry>3 1 2</entry>
         </row>
         <row>
! 	<entry><literal>destroy</literal> using <type>ShiftUp</type>:</entry>
  	<entry>1 2 3</entry>
         </row>
        </tbody>
*************** d.destroy(killList, killList+5);
*** 2025,2032 ****
      original indices of 0 1 2 3.  Removing 2 yields 0 1 3 because 3 is
      moved into 2's position.  Removing 0 yields 3 1 because 3 is again
      moved.  Use an object with the desired type to indicate which fill
!     method is desired, i.e., <statement>BackFill()</statement> or
!     <statement>ShiftUp()</statement>.</para>
  
      <para>We illustrate &dynamicarray; resizing in <xref
      linkend="arrays-dynamic_arrays-example"></xref>.  &dynamicarray;s
--- 2025,2032 ----
      original indices of 0 1 2 3.  Removing 2 yields 0 1 3 because 3 is
      moved into 2's position.  Removing 0 yields 3 1 because 3 is again
      moved.  Use an object with the desired type to indicate which fill
!     method is desired, i.e., <literal>BackFill()</literal> or
!     <literal>ShiftUp()</literal>.</para>
  
      <para>We illustrate &dynamicarray; resizing in <xref
      linkend="arrays-dynamic_arrays-example"></xref>.  &dynamicarray;s
*************** d.destroy(killList, killList+5);
*** 2037,2055 ****
      be one-dimensional.  The three arrays, each having one &double;
      value, are equivalent.  (The &poomatoolkit; can be configured to
      support different default template values.)  Invoking
!     <varname>d0</varname>'s <methodname>create</methodname> with an
      argument of five increases its domain size from one to six.  The
      additional indices are added to the end of the domain so the value
      at index&nbsp;0 is not changed.  To illustrate which indices are
      removed and which indices are reordered, the program first sets
      all values equal to their indices.  This illustrates that
      &dynamicarray; values are accessed the same way as &array; values.
!     For example, <statement>d0(i)</statement> accesses the
      <varname>i</varname><superscript>th</superscript> value.  The
!     <methodname>destroy</methodname> member function removes every
      other index from the array because the one-dimensional &range;
      specifies the domain's entire interval with a stride of&nbsp;2.
!     The <statement>BackFill</statement> function call creates a
      <type>BackFill</type> object indicating the <type>BackFill</type>
      method should be used.  We illustrate the steps of this method:
      <informaltable frame="none" colsep="0" rowsep="0" tocentry="1"
--- 2037,2055 ----
      be one-dimensional.  The three arrays, each having one &double;
      value, are equivalent.  (The &poomatoolkit; can be configured to
      support different default template values.)  Invoking
!     <varname>d0</varname>'s <literal>create</literal> with an
      argument of five increases its domain size from one to six.  The
      additional indices are added to the end of the domain so the value
      at index&nbsp;0 is not changed.  To illustrate which indices are
      removed and which indices are reordered, the program first sets
      all values equal to their indices.  This illustrates that
      &dynamicarray; values are accessed the same way as &array; values.
!     For example, <literal>d0(i)</literal> accesses the
      <varname>i</varname><superscript>th</superscript> value.  The
!     <literal>destroy</literal> member function removes every
      other index from the array because the one-dimensional &range;
      specifies the domain's entire interval with a stride of&nbsp;2.
!     The <literal>BackFill</literal> function call creates a
      <type>BackFill</type> object indicating the <type>BackFill</type>
      method should be used.  We illustrate the steps of this method:
      <informaltable frame="none" colsep="0" rowsep="0" tocentry="1"
*************** d.destroy(killList, killList+5);
*** 2081,2090 ****
      originally at 5 is again moved into 2's position.  Finally,
      index&nbsp;0 is replaced by index&nbsp;3.  The rest of the program
      repeats the computation, using the random-access iterator version
!     of <methodname>destroy</methodname>.  Since this &dynamicarray;'s
      indices are specified using &int;s, the
      <varname>killList</varname> explicitly lists the indices to
!     remove.  The <methodname>destroy</methodname> call uses pointers
      to the beginning and end of the <varname>killList</varname> array
      to specify which of its indices to use.  Since no replacement
      method is specified, the default <type>BackFill</type> method is
--- 2081,2090 ----
      originally at 5 is again moved into 2's position.  Finally,
      index&nbsp;0 is replaced by index&nbsp;3.  The rest of the program
      repeats the computation, using the random-access iterator version
!     of <literal>destroy</literal>.  Since this &dynamicarray;'s
      indices are specified using &int;s, the
      <varname>killList</varname> explicitly lists the indices to
!     remove.  The <literal>destroy</literal> call uses pointers
      to the beginning and end of the <varname>killList</varname> array
      to specify which of its indices to use.  Since no replacement
      method is specified, the default <type>BackFill</type> method is
*************** d.destroy(killList, killList+5);
*** 2104,2110 ****
         &dynamicarray;s, storing one &double; value.</para>
        </callout>
        <callout arearefs="arrays-dynamic_arrays-example-extension">
!        <para>This <methodname>create</methodname> member function call
         adds five indices to the end of the domain.</para>
        </callout>
        <callout arearefs="arrays-dynamic_arrays-example-access">
--- 2104,2110 ----
         &dynamicarray;s, storing one &double; value.</para>
        </callout>
        <callout arearefs="arrays-dynamic_arrays-example-extension">
!        <para>This <literal>create</literal> member function call
         adds five indices to the end of the domain.</para>
        </callout>
        <callout arearefs="arrays-dynamic_arrays-example-access">
*************** d.destroy(killList, killList+5);
*** 2113,2124 ****
        </callout>
        <callout arearefs="arrays-dynamic_arrays-example-destroy_range">
         <para>The &range; object specifies that every other index
!        should be removed.  The <statement>BackFill()</statement>
         object is unnecessary since it is the default replacement
         method.</para>
        </callout>
        <callout arearefs="arrays-dynamic_arrays-example-destroy_iterators">
!        <para>This <methodname>destroy</methodname> call is equivalent
         to the previous one but uses iterators.</para>
        </callout>
       </calloutlist>
--- 2113,2124 ----
        </callout>
        <callout arearefs="arrays-dynamic_arrays-example-destroy_range">
         <para>The &range; object specifies that every other index
!        should be removed.  The <literal>BackFill()</literal>
         object is unnecessary since it is the default replacement
         method.</para>
        </callout>
        <callout arearefs="arrays-dynamic_arrays-example-destroy_iterators">
!        <para>This <literal>destroy</literal> call is equivalent
         to the previous one but uses iterators.</para>
        </callout>
       </calloutlist>
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.11
diff -c -p -r1.11 concepts.xml
*** concepts.xml	2002/01/30 23:09:06	1.11
--- concepts.xml	2002/01/30 23:47:30
***************
*** 251,258 ****
    versa.  While users sometimes explicitly create views, they are
    perhaps more frequently created as temporaries in expressions.  For
    example, if <varname>A</varname> is an &array; and
!   <varname>I</varname> is a domain, <statement>A(I) -
!   A(I-1)</statement> uses two views to form the difference between
    adjacent values.</para>
  
  
--- 251,258 ----
    versa.  While users sometimes explicitly create views, they are
    perhaps more frequently created as temporaries in expressions.  For
    example, if <varname>A</varname> is an &array; and
!   <varname>I</varname> is a domain, <literal>A(I) -
!   A(I-1)</literal> uses two views to form the difference between
    adjacent values.</para>
  
  
***************
*** 523,530 ****
    computation accesses individual container values through explicit
    notation.  For example, values in a two-dimensional
    container&nbsp;&container; might be referenced as
!   <statement>&container(3,4)</statement> or
!   <statement>&container(i,j+1)</statement>.  This is the usual
    notation for non-object-oriented languages such as &c;.</para>
  
    <para><glossterm
--- 523,530 ----
    computation accesses individual container values through explicit
    notation.  For example, values in a two-dimensional
    container&nbsp;&container; might be referenced as
!   <literal>&container(3,4)</literal> or
!   <literal>&container(i,j+1)</literal>.  This is the usual
    notation for non-object-oriented languages such as &c;.</para>
  
    <para><glossterm
***************
*** 532,538 ****
    computation uses expressions to access subsets of a container's
    values.  For example, in <xref
    linkend="tutorial-array_parallel-doof2d"></xref>,
!   <statement>a(I,J)</statement> represents the subset of &array;
    <varname>a</varname>'s values having coordinates in the domain
    specified by the direct product of one-dimensional &interval;s
    <varname>I</varname> and&nbsp;<varname>J</varname>.  Using
--- 532,538 ----
    computation uses expressions to access subsets of a container's
    values.  For example, in <xref
    linkend="tutorial-array_parallel-doof2d"></xref>,
!   <literal>a(I,J)</literal> represents the subset of &array;
    <varname>a</varname>'s values having coordinates in the domain
    specified by the direct product of one-dimensional &interval;s
    <varname>I</varname> and&nbsp;<varname>J</varname>.  Using
Index: data-parallel.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/data-parallel.xml,v
retrieving revision 1.5
diff -c -p -r1.5 data-parallel.xml
*** data-parallel.xml	2002/01/30 23:09:06	1.5
--- data-parallel.xml	2002/01/30 23:47:31
***************
*** 83,94 ****
      <para>The data-parallel operators operate element-wise on
      containers' values.  For example, if <varname>A</varname> is a
      one-dimensional array,
!     <statement>-<varname>A</varname></statement> is a one-dimensional
      array with the same size such that the value at the
      i<superscript>th</superscript> position equals -A(i).  If
      <varname>A</varname> and <varname>B</varname> are two-dimensional
      &array;s on the same domain,
!     <statement><varname>A</varname>+<varname>B</varname></statement>
      is an array on the same domain with values equaling the sum of
      corresponding values in <varname>A</varname> and
      <varname>B</varname>.</para>
--- 83,94 ----
      <para>The data-parallel operators operate element-wise on
      containers' values.  For example, if <varname>A</varname> is a
      one-dimensional array,
!     <literal>-<varname>A</varname></literal> is a one-dimensional
      array with the same size such that the value at the
      i<superscript>th</superscript> position equals -A(i).  If
      <varname>A</varname> and <varname>B</varname> are two-dimensional
      &array;s on the same domain,
!     <literal><varname>A</varname>+<varname>B</varname></literal>
      is an array on the same domain with values equaling the sum of
      corresponding values in <varname>A</varname> and
      <varname>B</varname>.</para>
***************
*** 103,110 ****
      with a one-dimensional interval&nbsp;[0,3].  Its first and last
      entries equal <varname>A</varname>'s first and last entries, while
      its middle two entries are the sums
!     <statement>A(1)+B(1)</statement> and
!     <statement>A(2)+B(2)</statement>.  We assume zero is the default
      value for the type of values stored in&nbsp;<varname>B</varname>.
      A more complicated example of adding two &array;s with different
      domains is illustrated in <xref
--- 103,110 ----
      with a one-dimensional interval&nbsp;[0,3].  Its first and last
      entries equal <varname>A</varname>'s first and last entries, while
      its middle two entries are the sums
!     <literal>A(1)+B(1)</literal> and
!     <literal>A(2)+B(2)</literal>.  We assume zero is the default
      value for the type of values stored in&nbsp;<varname>B</varname>.
      A more complicated example of adding two &array;s with different
      domains is illustrated in <xref
*************** Array<2, double, Brick> A(I,I), B(J,H);
*** 143,155 ****
      their domains' extent differ, as indicated by the solid lines in
      the figure.  The sum has domain equal to the left operand's
      domain.  Values with the same indices are added.  For example,
!     <statement>A(2,2)</statement> and <statement>B(2,2)</statement>
      are added.  <varname>B</varname>'s domain does not include index
!     (1,1) so, when adding <statement>A(1,1)</statement> and
!     <statement>B(1,1)</statement>, the default value for
      <varname>B</varname>'s value type is used.  Usually this
!     is&nbsp;0.  Thus, <statement>A(1,1) + B(1,1)</statement> equals
!     <statement>9 + 0</statement>.</para>
  
      <para>Operations with both &array;s and scalar values are
      supported.  Conceptually, a scalar value can be thought of as an
--- 143,155 ----
      their domains' extent differ, as indicated by the solid lines in
      the figure.  The sum has domain equal to the left operand's
      domain.  Values with the same indices are added.  For example,
!     <literal>A(2,2)</literal> and <literal>B(2,2)</literal>
      are added.  <varname>B</varname>'s domain does not include index
!     (1,1) so, when adding <literal>A(1,1)</literal> and
!     <literal>B(1,1)</literal>, the default value for
      <varname>B</varname>'s value type is used.  Usually this
!     is&nbsp;0.  Thus, <literal>A(1,1) + B(1,1)</literal> equals
!     <literal>9 + 0</literal>.</para>
  
      <para>Operations with both &array;s and scalar values are
      supported.  Conceptually, a scalar value can be thought of as an
*************** Array<2, double, Brick> A(I,I), B(J,H);
*** 158,171 ****
  <programlisting>
  Array<1, double, Brick> D(Interval<1>(7,10));
  D += 2*D + 7;
! </programlisting><statement>2*D</statement> obeys the guidelines
!     because the scalar <statement>2</statement> can be thought of as
      an array with the same domain as <varname>D</varname>.  It has the
!     same value <statement>2</statement> everywhere.  Likewise the
!     conceptual domain for the scalar <statement>7</statement> is the
!     same as <statement>2*D</statement>'s domain.  Thus,
!     <statement>2*D(i) + 7</statement> is added to
!     <statement>D(i)</statement> wherever index&nbsp;i is in
      <varname>D</varname>'s domain.  In practice, the &toolkit; does
      not first convert scalar values to arrays but instead uses them
      directly in expressions.</para>
--- 158,171 ----
  <programlisting>
  Array<1, double, Brick> D(Interval<1>(7,10));
  D += 2*D + 7;
! </programlisting><literal>2*D</literal> obeys the guidelines
!     because the scalar <literal>2</literal> can be thought of as
      an array with the same domain as <varname>D</varname>.  It has the
!     same value <literal>2</literal> everywhere.  Likewise the
!     conceptual domain for the scalar <literal>7</literal> is the
!     same as <literal>2*D</literal>'s domain.  Thus,
!     <literal>2*D(i) + 7</literal> is added to
!     <literal>D(i)</literal> wherever index&nbsp;i is in
      <varname>D</varname>'s domain.  In practice, the &toolkit; does
      not first convert scalar values to arrays but instead uses them
      directly in expressions.</para>
*************** Array<2, double, Brick> A(I,I), B(H,J), 
*** 201,215 ****
  Array<1, double, Brick> A(Interval<1>(0,1));
  Array<1, double, Brick> B(Interval<1>(1,2));
  A = B;
! </programlisting> <statement>A(0)</statement> is assigned
!     <statement>B(1)</statement> and <statement>A(1)</statement> is
!     assigned <statement>B(2)</statement>.</para>
  
      <para>Assigning a scalar value to an &array; also is supported,
      but assigning an &array; to a scalar is not.  A scalar value is
      conformable to any domain because, conceptually it can be viewed
      as an &array; with any desired domain and having the same value
!     everywhere.  Thus, the assignment <statement>B = 3</statement>
  						   ensures every value in <varname>B</varname> equals&nbsp;3.  Even
      though a scalar value is conformable to any &array;, it is not an
      l-value so it cannot appear on the left-hand side of an
--- 201,215 ----
  Array<1, double, Brick> A(Interval<1>(0,1));
  Array<1, double, Brick> B(Interval<1>(1,2));
  A = B;
! </programlisting> <literal>A(0)</literal> is assigned
!     <literal>B(1)</literal> and <literal>A(1)</literal> is
!     assigned <literal>B(2)</literal>.</para>
  
      <para>Assigning a scalar value to an &array; also is supported,
      but assigning an &array; to a scalar is not.  A scalar value is
      conformable to any domain because, conceptually it can be viewed
      as an &array; with any desired domain and having the same value
!     everywhere.  Thus, the assignment <literal>B = 3</literal>
  						   ensures every value in <varname>B</varname> equals&nbsp;3.  Even
      though a scalar value is conformable to any &array;, it is not an
      l-value so it cannot appear on the left-hand side of an
*************** A = B;
*** 217,225 ****
  
      <para>Data-parallel expressions can involve typical mathematical
      functions and output operations.  For example,
!     <statement>sin(A)</statement> yields an &array; with values equal
      to the sine of each of &array; <varname>A</varname>'s values.
!     <statement>dot(A,B)</statement> has values equaling the dot
      product of corresponding values in &array;s <varname>A</varname>
      and <varname>B</varname>.  The contents of an entire &array; can
      be easily printed to standard output.  For example, the program
--- 217,225 ----
  
      <para>Data-parallel expressions can involve typical mathematical
      functions and output operations.  For example,
!     <literal>sin(A)</literal> yields an &array; with values equal
      to the sine of each of &array; <varname>A</varname>'s values.
!     <literal>dot(A,B)</literal> has values equaling the dot
      product of corresponding values in &array;s <varname>A</varname>
      and <varname>B</varname>.  The contents of an entire &array; can
      be easily printed to standard output.  For example, the program
*************** std::cout &openopen; A-B &openopen; std:
*** 234,240 ****
      (000:002:001) = 1 -1 -1</computeroutput>.  The initial
      <computeroutput>(000:002:001)</computeroutput> indicates the
      &array;'s domain ranges from 0 to 2 with a stride of&nbsp;1.  The
!     three values in <statement>A-B</statement> follow.</para>
  
      <para>The following four tables list the data-parallel operators
      that operate on &array;s.  <xref
--- 234,240 ----
      (000:002:001) = 1 -1 -1</computeroutput>.  The initial
      <computeroutput>(000:002:001)</computeroutput> indicates the
      &array;'s domain ranges from 0 to 2 with a stride of&nbsp;1.  The
!     three values in <literal>A-B</literal> follow.</para>
  
      <para>The following four tables list the data-parallel operators
      that operate on &array;s.  <xref
*************** std::cout &openopen; A-B &openopen; std:
*** 242,261 ****
      &cc; operators that can be applied to &array;s and also scalar
      values if appropriate.  Each unary operator takes an &array;
      parameter and returns an &array;.  The types of the two &array;s
!     need not be the same.  For example, <operator>!</operator> can
      take an <type>Array&lt;bool&gt;</type>,
      <type>Array&lt;int&gt;</type>, <type>Array&lt;long&gt;</type>, or
!     any other value type to which <operator>!</operator> can be
      applied.  The result is an <type>Array&lt;bool&gt;</type>.  Each
      binary operator also returns an &array;.  When specifying two
      &array;s or an &array; and a scalar value, a full set of operators
      is supported.  When specifying an &array; and a &tensor;,
      &matrix;, or &vector;, a more limited set of operators is
!     supported.  For example, <operator>==</operator> can take two
      &array;s, an &array; and a scalar value, or a scalar value and an
      &array;.  If given two &array;s, corresponding values are used.
      If an argument is a scalar value, its same value is the used with
!     each &array; value.  The <operator>+</operator> supports the same
      set of parameters but also supports adding an &array; and a
      &tensor;, an &array; and a &matrix;, an &array; and a &vector;, a
      &tensor; and an &array;, a &matrix; and an &array;, and a &vector;
--- 242,261 ----
      &cc; operators that can be applied to &array;s and also scalar
      values if appropriate.  Each unary operator takes an &array;
      parameter and returns an &array;.  The types of the two &array;s
!     need not be the same.  For example, <literal>!</literal> can
      take an <type>Array&lt;bool&gt;</type>,
      <type>Array&lt;int&gt;</type>, <type>Array&lt;long&gt;</type>, or
!     any other value type to which <literal>!</literal> can be
      applied.  The result is an <type>Array&lt;bool&gt;</type>.  Each
      binary operator also returns an &array;.  When specifying two
      &array;s or an &array; and a scalar value, a full set of operators
      is supported.  When specifying an &array; and a &tensor;,
      &matrix;, or &vector;, a more limited set of operators is
!     supported.  For example, <literal>==</literal> can take two
      &array;s, an &array; and a scalar value, or a scalar value and an
      &array;.  If given two &array;s, corresponding values are used.
      If an argument is a scalar value, its same value is the used with
!     each &array; value.  The <literal>+</literal> supports the same
      set of parameters but also supports adding an &array; and a
      &tensor;, an &array; and a &matrix;, an &array; and a &vector;, a
      &tensor; and an &array;, a &matrix; and an &array;, and a &vector;
*************** std::cout &openopen; A-B &openopen; std:
*** 277,297 ****
        <tbody valign="top">
         <row>
          <entry>unary operators </entry>
!         <entry><operator>+</operator>, <operator>-</operator>, <operator>~</operator>, <operator>!</operator></entry>
         </row>
         <row>
          <entry>binary operators with at least one &array; and at most
          one scalar value</entry>
!         <entry><operator>+</operator>, <operator>-</operator>, <operator>*</operator>, <operator>/</operator>, <operator>%</operator>, <operator>&amp;</operator>, <operator>|</operator>, <operator>^</operator>, <operator>&lt;</operator>, <operator>&lt;=</operator>, <operator>&gt;=</operator>, <operator>&gt;</operator>, <operator>==</operator>, <operator>!=</operator>, <operator>&amp;&amp;</operator>, <operator>||</operator>, <operator>&openopen;</operator>, <operator>&closeclose;</operator></entry>
         </row>
         <row>
          <entry>binary operators with at least one &array; and at most
          one &tensor;, &matrix;, or &vector;</entry>
!         <entry><operator>+</operator>, <operator>-</operator>,
!         <operator>*</operator>, <operator>/</operator>,
!         <operator>%</operator>, <operator>&amp;</operator>,
!         <operator>|</operator>, <operator>^</operator>,
!         <operator>==</operator>, <operator>!=</operator></entry>
         </row>
        </tbody>
       </tgroup>
--- 277,297 ----
        <tbody valign="top">
         <row>
          <entry>unary operators </entry>
!         <entry><literal>+</literal>, <literal>-</literal>, <literal>~</literal>, <literal>!</literal></entry>
         </row>
         <row>
          <entry>binary operators with at least one &array; and at most
          one scalar value</entry>
!         <entry><literal>+</literal>, <literal>-</literal>, <literal>*</literal>, <literal>/</literal>, <literal>%</literal>, <literal>&amp;</literal>, <literal>|</literal>, <literal>^</literal>, <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;=</literal>, <literal>&gt;</literal>, <literal>==</literal>, <literal>!=</literal>, <literal>&amp;&amp;</literal>, <literal>||</literal>, <literal>&openopen;</literal>, <literal>&closeclose;</literal></entry>
         </row>
         <row>
          <entry>binary operators with at least one &array; and at most
          one &tensor;, &matrix;, or &vector;</entry>
!         <entry><literal>+</literal>, <literal>-</literal>,
!         <literal>*</literal>, <literal>/</literal>,
!         <literal>%</literal>, <literal>&amp;</literal>,
!         <literal>|</literal>, <literal>^</literal>,
!         <literal>==</literal>, <literal>!=</literal></entry>
         </row>
        </tbody>
       </tgroup>
*************** std::cout &openopen; A-B &openopen; std:
*** 361,445 ****
        <tbody valign="top">
         <row rowsep="1">
  	<entry>Trigonometric and Hyperbolic Functions</entry>
! 	<entry><statement>#include &lt;math.h&gt;</statement></entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; cos (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the cosines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; sin (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the sines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; tan (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the tangents of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; acos (const Array&lt;T1&gt;&amp; A)</statement></entry>
  	<entry>Returns the arc cosines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; asin (const Array&lt;T1&gt;&amp; A)</statement></entry>
  	<entry>Returns the arc sines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; atan (const Array&lt;T1&gt;&amp; A)</statement></entry>
  	<entry>Returns the arc tangents of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Computes the arc tangents of the values from the division
  	of elements in <varname>B</varname> by the elements
  	in&nbsp;<varname>A</varname>.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Computes the arc tangents of the values from the division
  	of <varname>r</varname> by the elements
  	in&nbsp;<varname>A</varname>.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; atan2 (const T1&amp; l, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Computes the arc tangents of the values from the division
  	of elements in <varname>B</varname> by&nbsp;<varname>l</varname>.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; cosh (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the hyperbolic cosines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; sinh (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the hyperbolic sines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; tanh (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the hyperbolic tangents of the &array;'s values.</entry>
         </row>
         <row rowsep="1">
  	<entry>Absolute Value, Rounding, and Modulus Functions</entry>
! 	<entry><statement>#include &lt;math.h&gt;</statement></entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; fabs (const Array&lt;T1&gt;&amp; A)</statement></entry>
  	<entry>Returns the absolute values of the floating point
  	numbers in the &array;.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)</statement></entry>
  	<entry>For each of the &array;'s values, return the integer
  	larger than or equal to it (as a floating point number).</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; floor (const Array&lt;T1&gt;&amp; A)</statement></entry>
  	<entry>For each of the &array;'s values, return the integer
  	smaller than or equal to it (as a floating point number).</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Computes the floating-point modulus (remainder) of
  	<varname>A</varname>'s values with the corresponding value
  	in&nbsp;<varname>B</varname>.  The results have the same signs
--- 361,445 ----
        <tbody valign="top">
         <row rowsep="1">
  	<entry>Trigonometric and Hyperbolic Functions</entry>
! 	<entry><literal>#include &lt;math.h&gt;</literal></entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; cos (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the cosines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; sin (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the sines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; tan (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the tangents of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; acos (const Array&lt;T1&gt;&amp; A)</literal></entry>
  	<entry>Returns the arc cosines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; asin (const Array&lt;T1&gt;&amp; A)</literal></entry>
  	<entry>Returns the arc sines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; atan (const Array&lt;T1&gt;&amp; A)</literal></entry>
  	<entry>Returns the arc tangents of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Computes the arc tangents of the values from the division
  	of elements in <varname>B</varname> by the elements
  	in&nbsp;<varname>A</varname>.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; atan2 (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Computes the arc tangents of the values from the division
  	of <varname>r</varname> by the elements
  	in&nbsp;<varname>A</varname>.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; atan2 (const T1&amp; l, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Computes the arc tangents of the values from the division
  	of elements in <varname>B</varname> by&nbsp;<varname>l</varname>.  The resulting values are the
  	signed angles in the range -&pi; to &pi;, inclusive.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; cosh (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the hyperbolic cosines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; sinh (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the hyperbolic sines of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; tanh (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the hyperbolic tangents of the &array;'s values.</entry>
         </row>
         <row rowsep="1">
  	<entry>Absolute Value, Rounding, and Modulus Functions</entry>
! 	<entry><literal>#include &lt;math.h&gt;</literal></entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; fabs (const Array&lt;T1&gt;&amp; A)</literal></entry>
  	<entry>Returns the absolute values of the floating point
  	numbers in the &array;.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; ceil (const Array&lt;T1&gt;&amp; A)</literal></entry>
  	<entry>For each of the &array;'s values, return the integer
  	larger than or equal to it (as a floating point number).</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; floor (const Array&lt;T1&gt;&amp; A)</literal></entry>
  	<entry>For each of the &array;'s values, return the integer
  	smaller than or equal to it (as a floating point number).</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Computes the floating-point modulus (remainder) of
  	<varname>A</varname>'s values with the corresponding value
  	in&nbsp;<varname>B</varname>.  The results have the same signs
*************** std::cout &openopen; A-B &openopen; std:
*** 447,460 ****
  	absolute values of&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Computes the floating-point modulus (remainder) of
  	<varname>A</varname>'s values with&nbsp;<varname>r</varname>.  The results have the same signs
  	as <varname>A</varname> and absolute values less than the
  	absolute value of&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; fmod (const T1&amp; l, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Computes the floating-point modulus (remainder) of
  	<varname>l</varname> with the values
  	in&nbsp;<varname>B</varname>.  The results have the same signs
--- 447,460 ----
  	absolute values of&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; fmod (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Computes the floating-point modulus (remainder) of
  	<varname>A</varname>'s values with&nbsp;<varname>r</varname>.  The results have the same signs
  	as <varname>A</varname> and absolute values less than the
  	absolute value of&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; fmod (const T1&amp; l, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Computes the floating-point modulus (remainder) of
  	<varname>l</varname> with the values
  	in&nbsp;<varname>B</varname>.  The results have the same signs
*************** std::cout &openopen; A-B &openopen; std:
*** 463,618 ****
         </row>
         <row rowsep="1">
  	<entry>Powers, Exponentiation, and Logarithmic Functions</entry>
! 	<entry><statement>#include &lt;math.h&gt;</statement></entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; PETE_identity (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the &array;.  That is, it applies the identity operation.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; sqrt (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the square roots of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Raises <varname>A</varname>'s values by the
  	corresponding power in&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Raises <varname>A</varname>'s values by the power&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; pow (const T1&amp; l, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Raises <varname>l</varname> by the powers
  	in&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; pow2 (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the squares of <varname>A</varname>'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; pow3 (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the cubes of <varname>A</varname>'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; pow4 (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the fourth powers of <varname>A</varname>'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, const Array&lt;int&gt;&amp; B)</statement></entry>
  	<entry>Multiplies <varname>A</varname>'s values by two raised
  	to the corresponding value in&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, int r)</statement></entry>
  	<entry>Multiplies <varname>A</varname>'s values by two raised
  	to the <varname>r</varname><subscript>th</subscript>
  	power.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; ldexp (const T1&amp; l, const Array&lt;int&gt;&amp; B)</statement></entry>
  	<entry>Multiplies <varname>l</varname> by two raised
  	to the values in&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; exp (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the exponentiations of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; log (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the natural logarithms of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; log10 (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the base-10 logarithms of the &array;'s values.</entry>
         </row>
         <row rowsep="1">
  	<entry>Functions Involving Complex Numbers</entry>
! 	<entry><statement>#include &lt;complex&gt;</statement></entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; real (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
  	<entry>Returns the real parts of <varname>A</varname>'s complex numbers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; imag (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
  	<entry>Returns the imaginary parts of <varname>A</varname>'s complex numbers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; abs (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
  	<entry>Returns the absolute values (magnitudes) of
  	<varname>A</varname>'s complex numbers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; abs (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the absolute values of <varname>A</varname>'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; arg (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
  	<entry>Returns the angle representations (in radians) of the
  	 polar representations of <varname>A</varname>'s complex
  	 numbers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; norm (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
  	<entry>Returns the squared absolute values of
  	 <varname>A</varname>'s complex numbers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;complex&lt;T&closeclose; conj (const Array&lt;complex&lt;T&closeclose;&amp; A)</statement></entry>
  	<entry>Returns the complex conjugates of
  	 <varname>A</varname>'s complex numbers.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns the complex numbers created from polar
  	 coordinates (magnitudes and phase angles) in corresponding
  	 &array;s.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;complex&lt;T&closeclose; polar (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns the complex numbers created from polar
  	 coordinates with magnitude&nbsp;<varname>l</varname> and
  	 phase angles in the &array;.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns the complex numbers created from polar
  	 coordinates with magnitudes in the &array; and phase
  	 angle&nbsp;<varname>r</varname>.</entry>
         </row>
         <row rowsep="1">
  	<entry>Functions Involving Matrices and Tensors</entry>
! 	<entry><statement>#include "Pooma/Tiny.h"</statement></entry>
         </row>
         <row>
! 	<entry><statement>T trace (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the sum of the <varname>A</varname>'s diagonal
  	 entries, viewed as a matrix.</entry>
         </row>
         <row>
! 	<entry><statement>T det (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the determinant of <varname>A</varname>, viewed as a matrix.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; transpose (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the transpose of <varname>A</varname>, viewed as a matrix.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; symmetrize (const Array&lt;T&gt;&amp; A)</statement></entry>
  	<entry>Returns the tensors of <varname>A</varname> with the
  	 requested output symmetry.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns the dot products of values in the two &array;s.
  	 Value type <type>T</type> equals the type of the
  	 <function>dot</function> operating on <type>T1</type>
  	 and <type>T2</type>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns the dot products of values in the &array;
  	 with&nbsp;<varname>r</varname>.
  	 Value type <type>T</type> equals the type of the
--- 463,618 ----
         </row>
         <row rowsep="1">
  	<entry>Powers, Exponentiation, and Logarithmic Functions</entry>
! 	<entry><literal>#include &lt;math.h&gt;</literal></entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; PETE_identity (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the &array;.  That is, it applies the identity operation.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; sqrt (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the square roots of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Raises <varname>A</varname>'s values by the
  	corresponding power in&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; pow (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Raises <varname>A</varname>'s values by the power&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; pow (const T1&amp; l, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Raises <varname>l</varname> by the powers
  	in&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; pow2 (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the squares of <varname>A</varname>'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; pow3 (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the cubes of <varname>A</varname>'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; pow4 (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the fourth powers of <varname>A</varname>'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, const Array&lt;int&gt;&amp; B)</literal></entry>
  	<entry>Multiplies <varname>A</varname>'s values by two raised
  	to the corresponding value in&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; ldexp (const Array&lt;T1&gt;&amp; A, int r)</literal></entry>
  	<entry>Multiplies <varname>A</varname>'s values by two raised
  	to the <varname>r</varname><subscript>th</subscript>
  	power.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; ldexp (const T1&amp; l, const Array&lt;int&gt;&amp; B)</literal></entry>
  	<entry>Multiplies <varname>l</varname> by two raised
  	to the values in&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; exp (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the exponentiations of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; log (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the natural logarithms of the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; log10 (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the base-10 logarithms of the &array;'s values.</entry>
         </row>
         <row rowsep="1">
  	<entry>Functions Involving Complex Numbers</entry>
! 	<entry><literal>#include &lt;complex&gt;</literal></entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; real (const Array&lt;complex&lt;T&closeclose;&amp; A)</literal></entry>
  	<entry>Returns the real parts of <varname>A</varname>'s complex numbers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; imag (const Array&lt;complex&lt;T&closeclose;&amp; A)</literal></entry>
  	<entry>Returns the imaginary parts of <varname>A</varname>'s complex numbers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; abs (const Array&lt;complex&lt;T&closeclose;&amp; A)</literal></entry>
  	<entry>Returns the absolute values (magnitudes) of
  	<varname>A</varname>'s complex numbers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; abs (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the absolute values of <varname>A</varname>'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; arg (const Array&lt;complex&lt;T&closeclose;&amp; A)</literal></entry>
  	<entry>Returns the angle representations (in radians) of the
  	 polar representations of <varname>A</varname>'s complex
  	 numbers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; norm (const Array&lt;complex&lt;T&closeclose;&amp; A)</literal></entry>
  	<entry>Returns the squared absolute values of
  	 <varname>A</varname>'s complex numbers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;complex&lt;T&closeclose; conj (const Array&lt;complex&lt;T&closeclose;&amp; A)</literal></entry>
  	<entry>Returns the complex conjugates of
  	 <varname>A</varname>'s complex numbers.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns the complex numbers created from polar
  	 coordinates (magnitudes and phase angles) in corresponding
  	 &array;s.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;complex&lt;T&closeclose; polar (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns the complex numbers created from polar
  	 coordinates with magnitude&nbsp;<varname>l</varname> and
  	 phase angles in the &array;.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;complex&lt;T&closeclose; polar (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns the complex numbers created from polar
  	 coordinates with magnitudes in the &array; and phase
  	 angle&nbsp;<varname>r</varname>.</entry>
         </row>
         <row rowsep="1">
  	<entry>Functions Involving Matrices and Tensors</entry>
! 	<entry><literal>#include "Pooma/Tiny.h"</literal></entry>
         </row>
         <row>
! 	<entry><literal>T trace (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the sum of the <varname>A</varname>'s diagonal
  	 entries, viewed as a matrix.</entry>
         </row>
         <row>
! 	<entry><literal>T det (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the determinant of <varname>A</varname>, viewed as a matrix.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; transpose (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the transpose of <varname>A</varname>, viewed as a matrix.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; symmetrize (const Array&lt;T&gt;&amp; A)</literal></entry>
  	<entry>Returns the tensors of <varname>A</varname> with the
  	 requested output symmetry.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns the dot products of values in the two &array;s.
  	 Value type <type>T</type> equals the type of the
  	 <function>dot</function> operating on <type>T1</type>
  	 and <type>T2</type>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; dot (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns the dot products of values in the &array;
  	 with&nbsp;<varname>r</varname>.
  	 Value type <type>T</type> equals the type of the
*************** std::cout &openopen; A-B &openopen; std:
*** 620,633 ****
  	 and <type>T2</type>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; dot (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns the dot products of <varname>l</varname> with
  	 values in the &array;.  Value type <type>T</type> equals the type of the
  	 <function>dot</function> operating on <type>T1</type>
  	 and <type>T2</type>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns tensors created by computing the outer product
  	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
--- 620,633 ----
  	 and <type>T2</type>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; dot (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns the dot products of <varname>l</varname> with
  	 values in the &array;.  Value type <type>T</type> equals the type of the
  	 <function>dot</function> operating on <type>T1</type>
  	 and <type>T2</type>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns tensors created by computing the outer product
  	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
*************** std::cout &openopen; A-B &openopen; std:
*** 635,641 ****
  	 must have the same length.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns tensors created by computing the outer product
  	 of <varname>l</varname> with the vectors in the &array;.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
--- 635,641 ----
  	 must have the same length.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;Tensor&lt;T&closeclose; outerProduct (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns tensors created by computing the outer product
  	 of <varname>l</varname> with the vectors in the &array;.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
*************** std::cout &openopen; A-B &openopen; std:
*** 643,649 ****
  	 must have the same length.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns tensors created by computing the outer product
  	 of vectors in the &array; with&nbsp;<varname>r</varname>.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
--- 643,649 ----
  	 must have the same length.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;Tensor&lt;T&closeclose; outerProduct (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns tensors created by computing the outer product
  	 of vectors in the &array; with&nbsp;<varname>r</varname>.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
*************** std::cout &openopen; A-B &openopen; std:
*** 651,658 ****
  	 must have the same length.</entry>
         </row>
         <row>
! 	<entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const Array&lt;T1&gt;&amp; A, const
! 	 Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns matrices created by computing the outer product
  	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
--- 651,658 ----
  	 must have the same length.</entry>
         </row>
         <row>
! 	<entry><literal>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const Array&lt;T1&gt;&amp; A, const
! 	 Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns matrices created by computing the outer product
  	 of corresponding vectors in the two &array;s.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
*************** std::cout &openopen; A-B &openopen; std:
*** 660,667 ****
  	 the same length.</entry>
         </row>
         <row>
! 	<entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const T1&amp; l, const
! 	 Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns matrices created by computing the outer
  	 product of <varname>l</varname> with the vectors in the &array;.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
--- 660,667 ----
  	 the same length.</entry>
         </row>
         <row>
! 	<entry><literal>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const T1&amp; l, const
! 	 Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns matrices created by computing the outer
  	 product of <varname>l</varname> with the vectors in the &array;.  Value
  	 type&nbsp;<type>T</type> equals the type of the product of
*************** std::cout &openopen; A-B &openopen; std:
*** 669,676 ****
  	 have the same length.</entry>
         </row>
         <row>
! 	<entry><statement>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const
! 	 Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns matrices created by computing the outer
  	 product of the vectors in the &array;
  	 with&nbsp;<varname>r</varname>.  Value
--- 669,676 ----
  	 have the same length.</entry>
         </row>
         <row>
! 	<entry><literal>TinyMatrix&lt;T&gt; outerProductAsTinyMatrix (const
! 	 Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns matrices created by computing the outer
  	 product of the vectors in the &array;
  	 with&nbsp;<varname>r</varname>.  Value
*************** std::cout &openopen; A-B &openopen; std:
*** 687,694 ****
      <function>max</function> and <function>min</function> functions
      supplement named comparison functions.  For example,
      <function>LT</function> and <function>LE</function> compute the
!     same thing as the <operator>&lt;</operator> and
!     <operator>&lt;=</operator> operators.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="data_parallel-use-comparison_functions_table">
--- 687,694 ----
      <function>max</function> and <function>min</function> functions
      supplement named comparison functions.  For example,
      <function>LT</function> and <function>LE</function> compute the
!     same thing as the <literal>&lt;</literal> and
!     <literal>&lt;=</literal> operators.</para>
  
      <table frame="none" colsep="0" rowsep="0" tocentry="1"
  	   orient="port" pgwide="0" id="data_parallel-use-comparison_functions_table">
*************** std::cout &openopen; A-B &openopen; std:
*** 703,826 ****
        </thead>
        <tbody valign="top">
         <row>
! 	<entry><statement>Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns the maximum of corresponding &array; values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; max (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns the maximums of <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns the maximums of the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns the minimum of corresponding &array; values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; min (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns the minimums of <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns the minimums of the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;<operator>&lt;</operator> to compare corresponding &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; LT (const T1&amp; r, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;<operator>&lt;</operator> to compare <varname>l</varname> with the &array;'s
  	 values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;<operator>&lt;</operator> to compare the &array;'s
  	 values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;<operator>&lt;=</operator> to compare &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; LE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;<operator>&lt;=</operator> to compare <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;<operator>&lt;=</operator> to compare the &array;'s values
  	 with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;<operator>&gt;=</operator> to compare &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; GE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;<operator>&gt;=</operator> to compare <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;<operator>&gt;=</operator> to compare the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;<operator>&gt;</operator> to compare &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; GT (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;<operator>&gt;</operator> to compare <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;<operator>&gt;</operator> to compare the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from determining whether
  	 corresponding &array; values in <varname>A</varname> and
  	 <varname>B</varname> are equal.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; EQ (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from determining whether
  	 <varname>l</varname> equals the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from determining whether the &array;'s values equal&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</statement></entry>
  	<entry>Returns booleans from determining whether
  	 corresponding &array; values in <varname>A</varname> and
  	 <varname>B</varname> are not equal.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; NE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</statement></entry>
  	<entry>Returns booleans from determining whether
  	 <varname>l</varname> does not equal the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><statement>Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</statement></entry>
  	<entry>Returns booleans from determining whether the 
  	 &array;'s values are not equal to&nbsp;<varname>r</varname>.</entry>
         </row>
--- 703,826 ----
        </thead>
        <tbody valign="top">
         <row>
! 	<entry><literal>Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns the maximum of corresponding &array; values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; max (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns the maximums of <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; max (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns the maximums of the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns the minimum of corresponding &array; values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; min (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns the minimums of <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;T&gt; min (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns the minimums of the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;<literal>&lt;</literal> to compare corresponding &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; LT (const T1&amp; r, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;<literal>&lt;</literal> to compare <varname>l</varname> with the &array;'s
  	 values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; LT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns booleans from using the less-than
! 	 operator&nbsp;<literal>&lt;</literal> to compare the &array;'s
  	 values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;<literal>&lt;=</literal> to compare &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; LE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;<literal>&lt;=</literal> to compare <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; LE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns booleans from using the less-than-or-equal
! 	 operator&nbsp;<literal>&lt;=</literal> to compare the &array;'s values
  	 with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;<literal>&gt;=</literal> to compare &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; GE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;<literal>&gt;=</literal> to compare <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; GE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns booleans from using the greater-than-or-equal
! 	 operator&nbsp;<literal>&gt;=</literal> to compare the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;<literal>&gt;</literal> to compare &array; values in
  	 <varname>A</varname> and&nbsp;<varname>B</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; GT (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;<literal>&gt;</literal> to compare <varname>l</varname> with the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; GT (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns booleans from using the greater-than
! 	 operator&nbsp;<literal>&gt;</literal> to compare the &array;'s values with&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns booleans from determining whether
  	 corresponding &array; values in <varname>A</varname> and
  	 <varname>B</varname> are equal.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; EQ (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns booleans from determining whether
  	 <varname>l</varname> equals the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; EQ (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns booleans from determining whether the &array;'s values equal&nbsp;<varname>r</varname>.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const Array&lt;T2&gt;&amp; B)</literal></entry>
  	<entry>Returns booleans from determining whether
  	 corresponding &array; values in <varname>A</varname> and
  	 <varname>B</varname> are not equal.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; NE (const T1&amp; l, const Array&lt;T2&gt;&amp; A)</literal></entry>
  	<entry>Returns booleans from determining whether
  	 <varname>l</varname> does not equal the &array;'s values.</entry>
         </row>
         <row>
! 	<entry><literal>Array&lt;bool&gt; NE (const Array&lt;T1&gt;&amp; A, const T2&amp; r)</literal></entry>
  	<entry>Returns booleans from determining whether the 
  	 &array;'s values are not equal to&nbsp;<varname>r</varname>.</entry>
         </row>
*************** std::cout &openopen; A-B &openopen; std:
*** 834,840 ****
      two functions.  <function>peteCast</function> casts all values in
      an &array; to the type specified by its first parameter.  The
      <function>where</function> function generalizes the trinary
!     <operator>?:</operator> operator.  Using its first &array;
      argument as boolean values, it returns an &array; of just two
      values: <parameter>t</parameter> and <parameter>f</parameter>.</para>
  
--- 834,840 ----
      two functions.  <function>peteCast</function> casts all values in
      an &array; to the type specified by its first parameter.  The
      <function>where</function> function generalizes the trinary
!     <literal>?:</literal> operator.  Using its first &array;
      argument as boolean values, it returns an &array; of just two
      values: <parameter>t</parameter> and <parameter>f</parameter>.</para>
  
*************** std::cout &openopen; A-B &openopen; std:
*** 851,862 ****
  	 </thead>
  	 <tbody valign="top">
  	  <row>
! 	   <entry><statement>Array&lt;T&gt; peteCast (const T1&amp;, const Array&lt;T&gt;&amp; A)</statement></entry>
  	   <entry>Returns the casting of the &array;'s values to type <type>T1</type>.</entry>
  	  </row>
  	  <row>
! 	   <entry><statement>Array&lt;T&gt; where (const Array&lt;T1&gt;&amp; A, const T2&amp; t, const T3&amp; f)</statement></entry>
! 	   <entry>Generalizes the <operator>?:</operator> operator,
  	returning an &array; of <varname>t</varname> and
  	<varname>f</varname> values depending on whether
  	<varname>A</varname>'s values are true or false,
--- 851,862 ----
  	 </thead>
  	 <tbody valign="top">
  	  <row>
! 	   <entry><literal>Array&lt;T&gt; peteCast (const T1&amp;, const Array&lt;T&gt;&amp; A)</literal></entry>
  	   <entry>Returns the casting of the &array;'s values to type <type>T1</type>.</entry>
  	  </row>
  	  <row>
! 	   <entry><literal>Array&lt;T&gt; where (const Array&lt;T1&gt;&amp; A, const T2&amp; t, const T3&amp; f)</literal></entry>
! 	   <entry>Generalizes the <literal>?:</literal> operator,
  	returning an &array; of <varname>t</varname> and
  	<varname>f</varname> values depending on whether
  	<varname>A</varname>'s values are true or false,
*************** B = 2.0;
*** 926,932 ****
  A += -A + 2*B;
  std::cout &openopen; A &openopen; std::endl;
  </programlisting> Our goal is to transform the data-parallel
!      statement <statement>A += -A + 2*B</statement> into a single
       loop, preferably without using intermediary containers.  To
       simplify notation, let <type>Ar</type> abbreviate the type
       <type>Array&lt;1, double, Brick&gt;</type>.</para>
--- 926,932 ----
  A += -A + 2*B;
  std::cout &openopen; A &openopen; std::endl;
  </programlisting> Our goal is to transform the data-parallel
!      statement <literal>A += -A + 2*B</literal> into a single
       loop, preferably without using intermediary containers.  To
       simplify notation, let <type>Ar</type> abbreviate the type
       <type>Array&lt;1, double, Brick&gt;</type>.</para>
*************** std::cout &openopen; A &openopen; std::e
*** 934,945 ****
       <para>Using overloaded arithmetic operators would require using
       intermediate containers to evaluate the statement.  For example,
       <!-- FIXME: What is the proper tag for an inline function
!      prototype? --> the sum's left operand <statement>-A</statement>
!      would be computed by the overloaded unary operator <statement>Ar
!      operator-(const Ar&amp;)</statement>, which would produce an
!      intermediate &array;.  <statement>Ar operator*(double,
!      const Ar&amp;)</statement> would produce another intermediate
!      &array; holding <statement>2*B</statement>.  Yet another
       intermediate container would hold their sum, all before
       performing the assignment.  Thus, three intermediate containers
       would be created and destroyed.  Below, we show these are
--- 934,945 ----
       <para>Using overloaded arithmetic operators would require using
       intermediate containers to evaluate the statement.  For example,
       <!-- FIXME: What is the proper tag for an inline function
!      prototype? --> the sum's left operand <literal>-A</literal>
!      would be computed by the overloaded unary operator <literal>Ar
!      operator-(const Ar&amp;)</literal>, which would produce an
!      intermediate &array;.  <literal>Ar operator*(double,
!      const Ar&amp;)</literal> would produce another intermediate
!      &array; holding <literal>2*B</literal>.  Yet another
       intermediate container would hold their sum, all before
       performing the assignment.  Thus, three intermediate containers
       would be created and destroyed.  Below, we show these are
*************** std::cout &openopen; A &openopen; std::e
*** 965,976 ****
       intermediate loops or temporary values are needed.</para>
  
       <para>Before explaining the implementation, let us illustrate
!      using our example statement <statement>A += -A + 2*B</statement>.
       Evaluating the right-hand side creates a parse tree similar to
       the one in <xref
       linkend="data_parallel-implementation-pete-tree_figure"></xref>.
       For example, the overloaded unary minus operator yields a tree
!      node representing <statement>-A</statement>, having a unary-minus
       function object, and having type
  <programlisting>
  Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;
--- 965,976 ----
       intermediate loops or temporary values are needed.</para>
  
       <para>Before explaining the implementation, let us illustrate
!      using our example statement <literal>A += -A + 2*B</literal>.
       Evaluating the right-hand side creates a parse tree similar to
       the one in <xref
       linkend="data_parallel-implementation-pete-tree_figure"></xref>.
       For example, the overloaded unary minus operator yields a tree
!      node representing <literal>-A</literal>, having a unary-minus
       function object, and having type
  <programlisting>
  Expression&lt;UnaryNode&lt;OpMinus,Ar&closeclose;
*************** Expression&lt;BinaryNode&lt;OpAdd,
*** 984,990 ****
       representing&nbsp;<varname>A</varname>.</para>
  
       <figure float="1" id="data_parallel-implementation-pete-tree_figure">
!       <title>Annotated Parse Tree for <statement>-A + 2*B</statement></title>
         <mediaobject>
  	<imageobject>
  	 <imagedata fileref="figures/data-parallel.101" format="EPS" align="center"></imagedata>
--- 984,990 ----
       representing&nbsp;<varname>A</varname>.</para>
  
       <figure float="1" id="data_parallel-implementation-pete-tree_figure">
!       <title>Annotated Parse Tree for <literal>-A + 2*B</literal></title>
         <mediaobject>
  	<imageobject>
  	 <imagedata fileref="figures/data-parallel.101" format="EPS" align="center"></imagedata>
*************** Expression&lt;BinaryNode&lt;OpAdd,
*** 996,1009 ****
  	 <phrase>A parse tree for the statement is produced.</phrase>
  	</textobject>
  	<caption>
! 	 <para>The parse tree for <statement>-A + 2*B</statement> with
          type annotations.  The complete type of a node equals the
          concatenation of the preorder traversal of annotated types.</para>
  	</caption>
         </mediaobject>
        </figure>
  
!      <para>Finally, the assignment operator <statement>+=</statement>
       calls the <function>evaluate</function> function corresponding to
       the left-hand side's type.  At compile time, it produces the code
       for the computation.  Since this templated function is
--- 996,1009 ----
  	 <phrase>A parse tree for the statement is produced.</phrase>
  	</textobject>
  	<caption>
! 	 <para>The parse tree for <literal>-A + 2*B</literal> with
          type annotations.  The complete type of a node equals the
          concatenation of the preorder traversal of annotated types.</para>
  	</caption>
         </mediaobject>
        </figure>
  
!      <para>Finally, the assignment operator <literal>+=</literal>
       calls the <function>evaluate</function> function corresponding to
       the left-hand side's type.  At compile time, it produces the code
       for the computation.  Since this templated function is
*************** Expression&lt;BinaryNode&lt;OpAdd,
*** 1033,1039 ****
       the three things it must store:
       <variablelist>
  	<varlistentry>
! 	 <term><statement>Op</statement></term>
  	 <listitem>
  	  <para>the type of the node's operation.  For example, the
  	 <type>OpAdd</type> type represents adding two operands
--- 1033,1039 ----
       the three things it must store:
       <variablelist>
  	<varlistentry>
! 	 <term><literal>Op</literal></term>
  	 <listitem>
  	  <para>the type of the node's operation.  For example, the
  	 <type>OpAdd</type> type represents adding two operands
*************** Expression&lt;BinaryNode&lt;OpAdd,
*** 1041,1053 ****
  	 </listitem>
  	</varlistentry>
  	<varlistentry>
! 	 <term><statement>Left</statement></term>
  	 <listitem>
  	  <para>the type of the left child.</para>
  	 </listitem>
  	</varlistentry>
  	<varlistentry>
! 	 <term><statement>Right</statement></term>
  	 <listitem>
  	  <para>the type of the right child.</para>
  	 </listitem>
--- 1041,1053 ----
  	 </listitem>
  	</varlistentry>
  	<varlistentry>
! 	 <term><literal>Left</literal></term>
  	 <listitem>
  	  <para>the type of the left child.</para>
  	 </listitem>
  	</varlistentry>
  	<varlistentry>
! 	 <term><literal>Right</literal></term>
  	 <listitem>
  	  <para>the type of the right child.</para>
  	 </listitem>
*************** struct CreateLeaf
*** 1096,1102 ****
  };
  </programlisting> The <type>Scalar</type> class stores the scalar
      value.  The <type>CreateLeaf</type>'s <type>Leaf_t</type> type
!     indicates its type.  The <statement>static</statement>
      <function>make</function> function is invoked by an overloaded
      operator function when creating its children.</para>
  
--- 1096,1102 ----
  };
  </programlisting> The <type>Scalar</type> class stores the scalar
      value.  The <type>CreateLeaf</type>'s <type>Leaf_t</type> type
!     indicates its type.  The <literal>static</literal>
      <function>make</function> function is invoked by an overloaded
      operator function when creating its children.</para>
  
*************** CreateLeaf&lt;Array&lt;D1,T1,E1&gt; &gt;
*** 1149,1155 ****
      programmers to store trees in different formats.  The &pooma;
      implementation stores them as <type>Expression</type>s.  The
      function's return type is similar to the
!     <statement>return</statement> statement except it extracts the
      type from <type>Expression</type>'s internal
      <type>Expression_t</type> type.</para>
  
--- 1149,1155 ----
      programmers to store trees in different formats.  The &pooma;
      implementation stores them as <type>Expression</type>s.  The
      function's return type is similar to the
!     <literal>return</literal> statement except it extracts the
      type from <type>Expression</type>'s internal
      <type>Expression_t</type> type.</para>
  
*************** classes
*** 1171,1178 ****
      Inside the &array; class definition, each such operator just
      invokes the <function>assign</function> function with a
      corresponding function object.  For example,
!     <function>operator+=</function> invokes <statement>assign(*this,
!     rhs, OpAddAssign())</statement>.  <varname>rhs</varname> is the
      parse tree object for the right-hand side.  Calling this function
      invokes <function>evaluate</function>, which begins the
      evaluation.</para>
--- 1171,1178 ----
      Inside the &array; class definition, each such operator just
      invokes the <function>assign</function> function with a
      corresponding function object.  For example,
!     <function>operator+=</function> invokes <literal>assign(*this,
!     rhs, OpAddAssign())</literal>.  <varname>rhs</varname> is the
      parse tree object for the right-hand side.  Calling this function
      invokes <function>evaluate</function>, which begins the
      evaluation.</para>
*************** for (int i = a's domain[0].first(); i < 
*** 1204,1210 ****
      assignment operation, and <varname>rhs</varname> is the right-hand
      side's parse tree.</para>
  
!      <para>Evaluating <statement>rhs.read(i)</statement> inlines into a
      call to the <function>forEach</function> function.  This function
      performs a <emphasis>compile-time</emphasis> post-order parse-tree
      traversal.  Its general form is
--- 1204,1210 ----
      assignment operation, and <varname>rhs</varname> is the right-hand
      side's parse tree.</para>
  
!      <para>Evaluating <literal>rhs.read(i)</literal> inlines into a
      call to the <function>forEach</function> function.  This function
      performs a <emphasis>compile-time</emphasis> post-order parse-tree
      traversal.  Its general form is
*************** struct ForEach&lt;UnaryNode&lt;Op, A&gt;
*** 1249,1255 ****
  };
  </programlisting>  Since this structure is specialized for
      <type>UnaryNode</type>s, the first parameter of its
!     <statement>static </statement> <function>apply</function> function
      is a <type>UnaryNode</type>.  After recursively calling its child,
      it invokes the combination function indicated by the
      <type>Combine1</type> traits class.  In our example, the
--- 1249,1255 ----
  };
  </programlisting>  Since this structure is specialized for
      <type>UnaryNode</type>s, the first parameter of its
!     <literal>static </literal> <function>apply</function> function
      is a <type>UnaryNode</type>.  After recursively calling its child,
      it invokes the combination function indicated by the
      <type>Combine1</type> traits class.  In our example, the
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.9
diff -c -p -r1.9 glossary.xml
*** glossary.xml	2002/01/25 02:28:26	1.9
--- glossary.xml	2002/01/30 23:47:32
***************
*** 227,233 ****
     <glossdef>
      <para>describes an expression involving a (non-singleton) subset
      of a container's values.  For example,
!     <statement>sin(&container;)</statement> is an expression
      indicating that the <function>sin</function> is applied to each
      value in container&nbsp;&container;.</para>
      <glossseealso otherterm="glossary-element_wise">element wise</glossseealso>
--- 227,233 ----
     <glossdef>
      <para>describes an expression involving a (non-singleton) subset
      of a container's values.  For example,
!     <literal>sin(&container;)</literal> is an expression
      indicating that the <function>sin</function> is applied to each
      value in container&nbsp;&container;.</para>
      <glossseealso otherterm="glossary-element_wise">element wise</glossseealso>
***************
*** 305,311 ****
     <glossterm>element wise</glossterm>
     <glossdef>
      <para>describes accesses to individual values within a container.
!     For example, <statement>&container(-4,3)</statement> represents one
      particular value in the container&nbsp;&container;.</para>
      <glossseealso otherterm="glossary-data_parallel">data parallel</glossseealso>
      <glossseealso otherterm="glossary-relation">relation</glossseealso>
--- 305,311 ----
     <glossterm>element wise</glossterm>
     <glossdef>
      <para>describes accesses to individual values within a container.
!     For example, <literal>&container(-4,3)</literal> represents one
      particular value in the container&nbsp;&container;.</para>
      <glossseealso otherterm="glossary-data_parallel">data parallel</glossseealso>
      <glossseealso otherterm="glossary-relation">relation</glossseealso>
***************
*** 413,419 ****
     <glossdef>
      <para>object that can behave as a function.  The object can store
      values that the function uses.  If its function is called
!     <methodname>operator()</methodname>, the object can be invoked as
      a function.</para>
     </glossdef>
    </glossentry>
--- 413,419 ----
     <glossdef>
      <para>object that can behave as a function.  The object can store
      values that the function uses.  If its function is called
!     <literal>operator()</literal>, the object can be invoked as
      a function.</para>
     </glossdef>
    </glossentry>
*************** guard layer</glossseealso>
*** 602,608 ****
       </indexterm>
      function defining a function invoked using a &cc; operator.  For
      example, the <function>operator+</function> function defines the
!     result of using the <operator>+</operator>.</para>
     </glossdef>
    </glossentry>
   </glossdiv>
--- 602,608 ----
       </indexterm>
      function defining a function invoked using a &cc; operator.  For
      example, the <function>operator+</function> function defines the
!     result of using the <literal>+</literal>.</para>
     </glossdef>
    </glossentry>
   </glossdiv>
*************** guard layer</glossseealso>
*** 814,822 ****
       <primary>template instantiation</primary>
      </indexterm>
      applying a template class to template parameter arguments to create a
!     type.  For example, <statement>foo&lt;double,3&gt;</statement>
!     instantiates <statement>template &lt;typename T, int n&gt; class
!     foo</statement> with the type &double; and the constant
      integer&nbsp;3.  Template instantiation is analogous to applying a
      function to function arguments.</para>
      <glossseealso otherterm="glossary-template">template</glossseealso>
--- 814,822 ----
       <primary>template instantiation</primary>
      </indexterm>
      applying a template class to template parameter arguments to create a
!     type.  For example, <literal>foo&lt;double,3&gt;</literal>
!     instantiates <literal>template &lt;typename T, int n&gt; class
!     foo</literal> with the type &double; and the constant
      integer&nbsp;3.  Template instantiation is analogous to applying a
      function to function arguments.</para>
      <glossseealso otherterm="glossary-template">template</glossseealso>
Index: introduction.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/introduction.xml,v
retrieving revision 1.6
diff -c -p -r1.6 introduction.xml
*** introduction.xml	2002/01/30 23:09:06	1.6
--- introduction.xml	2002/01/30 23:47:32
*************** A += -B + 2 * C;
*** 298,305 ****
  </programlisting> where <varname>A</varname> and <varname>C</varname> are
    <type>vector&lt;double&gt;</type>s and <varname>B</varname> is a
    <type>vector&lt;int&gt;</type>.  &naivecap; evaluation might introduce
!   intermediaries for <statement>-B</statement>,
!   <statement>2*C</statement>, and their sum.  The presence of these
    intermediaries in inner loops can measurably slow performance.  To
    produce a loop without intermediaries, &pete; stores each expression
    as a parse tree.  Using its templates, the parse tree is
--- 298,305 ----
  </programlisting> where <varname>A</varname> and <varname>C</varname> are
    <type>vector&lt;double&gt;</type>s and <varname>B</varname> is a
    <type>vector&lt;int&gt;</type>.  &naivecap; evaluation might introduce
!   intermediaries for <literal>-B</literal>,
!   <literal>2*C</literal>, and their sum.  The presence of these
    intermediaries in inner loops can measurably slow performance.  To
    produce a loop without intermediaries, &pete; stores each expression
    as a parse tree.  Using its templates, the parse tree is
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.12
diff -c -p -r1.12 manual.xml
*** manual.xml	2002/01/30 23:09:06	1.12
--- manual.xml	2002/01/30 23:47:35
***************
*** 108,114 ****
    <!-- The "DynamicArray" type. -->
  <!ENTITY engine "<type>Engine</type>">
    <!-- The "Engine" type. -->
! <!ENTITY false "<statement>false</statement>">
    <!-- The false Boolean value. -->
    <!-- Modify its tag to the appropriate one. -->
  <!ENTITY field "<type>Field</type>">
--- 108,114 ----
    <!-- The "DynamicArray" type. -->
  <!ENTITY engine "<type>Engine</type>">
    <!-- The "Engine" type. -->
! <!ENTITY false "<literal>false</literal>">
    <!-- The false Boolean value. -->
    <!-- Modify its tag to the appropriate one. -->
  <!ENTITY field "<type>Field</type>">
***************
*** 157,163 ****
    <!-- The "Stencil" type. -->
  <!ENTITY tensor "<type>Tensor</type>">
    <!-- The Pooma tensor type. -->
! <!ENTITY true "<statement>true</statement>">
    <!-- The true Boolean value. -->
    <!-- Modify its tag to the appropriate one. -->
  <!ENTITY vector "<type>Vector</type>">
--- 157,163 ----
    <!-- The "Stencil" type. -->
  <!ENTITY tensor "<type>Tensor</type>">
    <!-- The Pooma tensor type. -->
! <!ENTITY true "<literal>true</literal>">
    <!-- The true Boolean value. -->
    <!-- Modify its tag to the appropriate one. -->
  <!ENTITY vector "<type>Vector</type>">
***************
*** 446,454 ****
      and accessor functions returning individual elements.  The &pooma;
      &engine; class and its specializations implement the engine
      concept.  Given an index within the domain, an &engine;'s
!     <methodname>operator()</methodname> function returns the
      associated value, which can be used or changed.  Its
!     <methodname>read</methodname> member function returns the same
      value but permitting only use, not modification.  The acceptable
      indices are determined by each &engine;.  Most accept indices
      specified using &int; and <type>Loc&lt;&dim;&gt;</type>
--- 446,454 ----
      and accessor functions returning individual elements.  The &pooma;
      &engine; class and its specializations implement the engine
      concept.  Given an index within the domain, an &engine;'s
!     <literal>operator()</literal> function returns the
      associated value, which can be used or changed.  Its
!     <literal>read</literal> member function returns the same
      value but permitting only use, not modification.  The acceptable
      indices are determined by each &engine;.  Most accept indices
      specified using &int; and <type>Loc&lt;&dim;&gt;</type>
***************
*** 499,505 ****
      Thus, copying an &engine; or a container requires little execution
      time.  If an &engine; has the same data as another &engine; but it
      needs its own data to modify, the
!     <methodname>makeOwnCopy</methodname> member function creates such
      a copy.</para>
  
      <para>&engine;s are rarely explicitly declared.  Instead a
--- 499,505 ----
      Thus, copying an &engine; or a container requires little execution
      time.  If an &engine; has the same data as another &engine; but it
      needs its own data to modify, the
!     <literal>makeOwnCopy</literal> member function creates such
      a copy.</para>
  
      <para>&engine;s are rarely explicitly declared.  Instead a
***************
*** 517,524 ****
      &brick; &engine; tag indicates a &brick; &engine; should be used.
      Some &engine;s, such as <type>CompFwd</type>, are rarely declared
      even using &engine; tags.  Instead the &array;'s
!     <methodname>comp</methodname> and
!     <methodname>readComp</methodname> member functions return views of
      containers using <type>CompFwd</type> &engine;s.</para>
     </section>
  
--- 517,524 ----
      &brick; &engine; tag indicates a &brick; &engine; should be used.
      Some &engine;s, such as <type>CompFwd</type>, are rarely declared
      even using &engine; tags.  Instead the &array;'s
!     <literal>comp</literal> and
!     <literal>readComp</literal> member functions return views of
      containers using <type>CompFwd</type> &engine;s.</para>
     </section>
  
***************
*** 569,575 ****
  	 <entry><type>CompFwd</type></entry>
  	 <entry>extracts specified components of an engine's vectors,
  	 tensors, arrays, etc.; usually created using the
! 	 <methodname>comp</methodname> container function.</entry>
  	</row>
  	<row>
  	 <entry><type>ConstantFunction</type></entry>
--- 569,575 ----
  	 <entry><type>CompFwd</type></entry>
  	 <entry>extracts specified components of an engine's vectors,
  	 tensors, arrays, etc.; usually created using the
! 	 <literal>comp</literal> container function.</entry>
  	</row>
  	<row>
  	 <entry><type>ConstantFunction</type></entry>
***************
*** 644,652 ****
      value, not every value.  Using less storage space may also permit
      more useful values to be stored in cache, improving cache
      performance.  Reading a value in a compressed &engine; using the
!     <methodname>read</methodname> member function is as fast as
      reading a value in a &brick; &engine;, but writing a value always
!     requires executing an additional <keywordname>if</keywordname>
      conditional.  Thus, if an &engine; infrequently has multiple
      different values during its life time, a &compressiblebrick;
      &engine; may be faster than a &brick; &engine;.  If an &engine; is
--- 644,652 ----
      value, not every value.  Using less storage space may also permit
      more useful values to be stored in cache, improving cache
      performance.  Reading a value in a compressed &engine; using the
!     <literal>read</literal> member function is as fast as
      reading a value in a &brick; &engine;, but writing a value always
!     requires executing an additional <literal>if</literal>
      conditional.  Thus, if an &engine; infrequently has multiple
      different values during its life time, a &compressiblebrick;
      &engine; may be faster than a &brick; &engine;.  If an &engine; is
***************
*** 664,683 ****
      distributed computing.</para>
  
      <para>Both &brick; and &compressiblebrick; &engine;s have
!     <methodname>read</methodname> and
!     <methodname>operator()</methodname> member functions taking &int;
      and &loc; parameters.  The parameters should match the &array;'s
      dimensionality.  For example, if &array; <varname>a</varname> has
      dimensionality&nbsp;3, <function>a.read(int, int, int)</function>
      and <function>a(int, int, int)</function> should be used.  The
      former returns a value that cannot be modified, while the latter
!     can be changed.  Using the <methodname>read</methodname> member
      function can lead to faster code.  Alternatively, an index can be
      specified using a &loc;.  For example,
!     <statement>a.read(Loc&lt;3&gt;(1,-2,5))</statement> and
!     <statement>a(Loc&lt;3&gt;(1,-2,5))</statement> are equivalent to
!     <statement>a.read(1,-2,5))</statement> and
!     <statement>a(1,-2,5)</statement>.</para>
  
      <para>The &dynamic; &engine; supports changing domain sizes while
      a program is executing.  It is basically a one-dimensional
--- 664,683 ----
      distributed computing.</para>
  
      <para>Both &brick; and &compressiblebrick; &engine;s have
!     <literal>read</literal> and
!     <literal>operator()</literal> member functions taking &int;
      and &loc; parameters.  The parameters should match the &array;'s
      dimensionality.  For example, if &array; <varname>a</varname> has
      dimensionality&nbsp;3, <function>a.read(int, int, int)</function>
      and <function>a(int, int, int)</function> should be used.  The
      former returns a value that cannot be modified, while the latter
!     can be changed.  Using the <literal>read</literal> member
      function can lead to faster code.  Alternatively, an index can be
      specified using a &loc;.  For example,
!     <literal>a.read(Loc&lt;3&gt;(1,-2,5))</literal> and
!     <literal>a(Loc&lt;3&gt;(1,-2,5))</literal> are equivalent to
!     <literal>a.read(1,-2,5))</literal> and
!     <literal>a(1,-2,5)</literal>.</para>
  
      <para>The &dynamic; &engine; supports changing domain sizes while
      a program is executing.  It is basically a one-dimensional
***************
*** 685,695 ****
      order of stored values to change.  Thus, it supports the same
      interface as &brick; except that all member functions are
      restricted to their one-dimensional versions.  For example,
!     <methodname>read</methodname> and
!     <methodname>operator()</methodname> take <type>Loc&lt;1&gt;</type>
      or one &int; parameter.  In addition, the one-dimensional domain
!     can be dynamically resized using <methodname>create</methodname>
!     and <methodname>destroy</methodname>.
  <![%unfinished;[
  ; see .
  
--- 685,695 ----
      order of stored values to change.  Thus, it supports the same
      interface as &brick; except that all member functions are
      restricted to their one-dimensional versions.  For example,
!     <literal>read</literal> and
!     <literal>operator()</literal> take <type>Loc&lt;1&gt;</type>
      or one &int; parameter.  In addition, the one-dimensional domain
!     can be dynamically resized using <literal>create</literal>
!     and <literal>destroy</literal>.
  <![%unfinished;[
  ; see .
  
*************** a(I,J) = (1.0/9.0) *
*** 809,822 ****
     b(I-1,J+1) + b(I-1,J  ) + b(I-1,J-1));
  </programlisting>  The last statement creates ten views.  For example,
  
!    <statement>a(I,J)</statement> creates a view of
     <varname>a</varname> using the smaller domain specified by
     <varname>I</varname> and <varname>J</varname>.  This omits the
     outermost rows of columns of&nbsp;<varname>a</varname>.  The views
     of <varname>b</varname> illustrate the use of views in
!    data-parallel statements.  <statement>b(I-1,J-1)</statement> has a
     subset shifted up one row and left one column compared with
!    <statement>b(I,J)</statement>.</para>
  ]]>  <!-- end temporary -->
  <![%unfinished;[
     <para>Be sure to list the various arithmetic operations on domains
--- 809,822 ----
     b(I-1,J+1) + b(I-1,J  ) + b(I-1,J-1));
  </programlisting>  The last statement creates ten views.  For example,
  
!    <literal>a(I,J)</literal> creates a view of
     <varname>a</varname> using the smaller domain specified by
     <varname>I</varname> and <varname>J</varname>.  This omits the
     outermost rows of columns of&nbsp;<varname>a</varname>.  The views
     of <varname>b</varname> illustrate the use of views in
!    data-parallel statements.  <literal>b(I-1,J-1)</literal> has a
     subset shifted up one row and left one column compared with
!    <literal>b(I,J)</literal>.</para>
  ]]>  <!-- end temporary -->
  <![%unfinished;[
     <para>Be sure to list the various arithmetic operations on domains
*************** UNFINISHED</para>
*** 1601,1607 ****
      </programlisting> where <varname>A</varname>, <varname>B</varname> and
      <varname>C</varname> are &array;s and <function>foo</function> is
      a function taking an &array; as an argument.  The expression
!     <statement><varname>A</varname>*<varname>B</varname>+<varname>C</varname></statement>
      will only be evaluated by the expression engine as needed by
      <function>foo</function>.</para>
  
--- 1601,1607 ----
      </programlisting> where <varname>A</varname>, <varname>B</varname> and
      <varname>C</varname> are &array;s and <function>foo</function> is
      a function taking an &array; as an argument.  The expression
!     <literal><varname>A</varname>*<varname>B</varname>+<varname>C</varname></literal>
      will only be evaluated by the expression engine as needed by
      <function>foo</function>.</para>
  
*************** UNFINISHED</para>
*** 1718,1724 ****
        incorrect.  To help diagnose if calls to
        <function>Pooma::blockAndEvaluate</function> are missing, invoke
        a &pooma; executable with the
!       <statement>&dashdash;pooma-blocking-expressions</statement> option.
        This automatically causes
        <function>Pooma::blockAndEvaluate</function> to be called after
        each statement.  Doing so ensures program correctness, but it
--- 1718,1724 ----
        incorrect.  To help diagnose if calls to
        <function>Pooma::blockAndEvaluate</function> are missing, invoke
        a &pooma; executable with the
!       <literal>&dashdash;pooma-blocking-expressions</literal> option.
        This automatically causes
        <function>Pooma::blockAndEvaluate</function> to be called after
        each statement.  Doing so ensures program correctness, but it
*************** UNFINISHED</para>
*** 1728,1741 ****
        important than execution speed.</para>
  
        <para>If using
!       <statement>&dashdash;pooma-blocking-expressions</statement> changes a
        program's output, it is missing one or more calls to
        <function>Pooma::blockAndEvaluate</function>.  To narrow the
        region with a missing call, surround the region in question with
!       calls to <statement>Pooma::blockingExpressions(true)</statement>
!       and <statement>Pooma::blockingExpressions(false)</statement>,
        but do not use the
!       <statement>&dashdash;pooma-blocking-expressions</statement> option.
        Within the region, <function>Pooma::blockAndEvaluate</function>
        will be invoked after each statement.  Repeatedly reducing the
        region's size should reveal where calls are missing.</para>
--- 1728,1741 ----
        important than execution speed.</para>
  
        <para>If using
!       <literal>&dashdash;pooma-blocking-expressions</literal> changes a
        program's output, it is missing one or more calls to
        <function>Pooma::blockAndEvaluate</function>.  To narrow the
        region with a missing call, surround the region in question with
!       calls to <literal>Pooma::blockingExpressions(true)</literal>
!       and <literal>Pooma::blockingExpressions(false)</literal>,
        but do not use the
!       <literal>&dashdash;pooma-blocking-expressions</literal> option.
        Within the region, <function>Pooma::blockAndEvaluate</function>
        will be invoked after each statement.  Repeatedly reducing the
        region's size should reveal where calls are missing.</para>
*************** UNFINISHED</para>
*** 1767,1773 ****
     class="libraryfile">.cmpl.cpp</filename>, <filename
     class="libraryfile">.mk</filename>, <filename
     class="libraryfile">.conf</filename>.  Should we also explain use
!    of <keywordname>inline</keywordname> even when necessary and the template
     model, e.g., including <filename
     class="libraryfile">.cpp</filename> files.</para>
  
--- 1767,1773 ----
     class="libraryfile">.cmpl.cpp</filename>, <filename
     class="libraryfile">.mk</filename>, <filename
     class="libraryfile">.conf</filename>.  Should we also explain use
!    of <literal>inline</literal> even when necessary and the template
     model, e.g., including <filename
     class="libraryfile">.cpp</filename> files.</para>
  
*************** UNFINISHED</para>
*** 2090,2096 ****
  	<row>
  	 <entry>
            <constructorsynopsis>
! 	   <methodname>Array</methodname>
  	   <void></void>
  	  </constructorsynopsis>
           </entry>
--- 2090,2096 ----
  	<row>
  	 <entry>
            <constructorsynopsis>
! 	   <literal>Array</literal>
  	   <void></void>
  	  </constructorsynopsis>
           </entry>
*************** UNFINISHED</para>
*** 2100,2106 ****
  	<row>
  	 <entry>
            <constructorsynopsis>
! 	   <methodname>Array</methodname>
  	   <methodparam><modifier>const</modifier> <type>Engine_t&</type>
  	    <parameter>engine</parameter></methodparam>
  	  </constructorsynopsis>
--- 2100,2106 ----
  	<row>
  	 <entry>
            <constructorsynopsis>
! 	   <literal>Array</literal>
  	   <methodparam><modifier>const</modifier> <type>Engine_t&</type>
  	    <parameter>engine</parameter></methodparam>
  	  </constructorsynopsis>
*************** UNFINISHED</para>
*** 2114,2120 ****
  	<row>
  	 <entry>
            <constructorsynopsis>
! 	   <methodname>Array</methodname>
  	   <methodparam>
  	    <modifier>const</modifier>
  	    <type> Engine&lt;Dim2, T2, EngineTag2&gt;&</type>
--- 2114,2120 ----
  	<row>
  	 <entry>
            <constructorsynopsis>
! 	   <literal>Array</literal>
  	   <methodparam>
  	    <modifier>const</modifier>
  	    <type> Engine&lt;Dim2, T2, EngineTag2&gt;&</type>
*************** UNFINISHED</para>
*** 2162,2168 ****
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>Element_t</type> <methodname>read</methodname>
  	   <void></void>
  	  </methodsynopsis>
           </entry>
--- 2162,2168 ----
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>Element_t</type> <literal>read</literal>
  	   <void></void>
  	  </methodsynopsis>
           </entry>
*************** UNFINISHED</para>
*** 2171,2177 ****
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>Element_t</type> <methodname>read</methodname>
  	   <methodparam>
  	    <modifier>const</modifier>
  	    <type>Sub1&</type> <parameter>s1</parameter>
--- 2171,2177 ----
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>Element_t</type> <literal>read</literal>
  	   <methodparam>
  	    <modifier>const</modifier>
  	    <type>Sub1&</type> <parameter>s1</parameter>
*************** UNFINISHED</para>
*** 2189,2195 ****
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>Element_t</type> <methodname>operator()</methodname>
  	   <methodparam>
  	    <modifier>const</modifier>
  	    <type>Sub1&</type> <parameter>s1</parameter>
--- 2189,2195 ----
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>Element_t</type> <literal>operator()</literal>
  	   <methodparam>
  	    <modifier>const</modifier>
  	    <type>Sub1&</type> <parameter>s1</parameter>
*************** UNFINISHED</para>
*** 2200,2207 ****
  	   </methodparam>
  	  </methodsynopsis>
           </entry>
! 	 <entry><para>How does this differ from <statement>read(const
!           Sub1& s1, const Sub2& s2)</statement>?  </para></entry>
  	</row>
  	<row>
  	 <entry>ADD ALL <function>read</function>s and
--- 2200,2207 ----
  	   </methodparam>
  	  </methodsynopsis>
           </entry>
! 	 <entry><para>How does this differ from <literal>read(const
!           Sub1& s1, const Sub2& s2)</literal>?  </para></entry>
  	</row>
  	<row>
  	 <entry>ADD ALL <function>read</function>s and
*************** UNFINISHED</para>
*** 2218,2231 ****
  
       <para>When an array stores elements having components, e.g., an
       array of vectors, tensors, or arrays, the
!      <methodname>comp</methodname> returns an array consisting of the
       specified components.  The original and component array share the
       same engine so changing the values in one affects values in the
       other.</para>
  
       <para>For example, if &n; &times; &n; array <varname>a</varname>
       consists of three-dimensional real-valued vectors,
!      <statement>a.comp(1)</statement> returns a &n; &times; &n;
       real-valued array of all the middle vector components.  Assigning
       to the component array will also modify the middle components of
       the vectors in <varname>a</varname>.</para>
--- 2218,2231 ----
  
       <para>When an array stores elements having components, e.g., an
       array of vectors, tensors, or arrays, the
!      <literal>comp</literal> returns an array consisting of the
       specified components.  The original and component array share the
       same engine so changing the values in one affects values in the
       other.</para>
  
       <para>For example, if &n; &times; &n; array <varname>a</varname>
       consists of three-dimensional real-valued vectors,
!      <literal>a.comp(1)</literal> returns a &n; &times; &n;
       real-valued array of all the middle vector components.  Assigning
       to the component array will also modify the middle components of
       the vectors in <varname>a</varname>.</para>
*************** UNFINISHED</para>
*** 2245,2251 ****
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>UNKNOWN compute this</type> <methodname>comp</methodname>
  	   <methodparam>
  	    <modifier>const</modifier>
  	    <type>int&</type>
--- 2245,2251 ----
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>UNKNOWN compute this</type> <literal>comp</literal>
  	   <methodparam>
  	    <modifier>const</modifier>
  	    <type>int&</type>
*************** UNFINISHED</para>
*** 2256,2262 ****
  	 <entry><para>unknown: See line 1989.</para></entry>
  	</row>
  	<row>
! 	 <entry>ADD ALL <methodname>comp</methodname>s.</entry>
  	</row>
         </tbody>
        </tgroup>
--- 2256,2262 ----
  	 <entry><para>unknown: See line 1989.</para></entry>
  	</row>
  	<row>
! 	 <entry>ADD ALL <literal>comp</literal>s.</entry>
  	</row>
         </tbody>
        </tgroup>
*************** UNFINISHED</para>
*** 2281,2287 ****
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>int</type> <methodname>first</methodname>
  	   <methodparam>
  	    <type>int</type>
  	    <parameter>d</parameter>
--- 2281,2287 ----
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>int</type> <literal>first</literal>
  	   <methodparam>
  	    <type>int</type>
  	    <parameter>d</parameter>
*************** UNFINISHED</para>
*** 2292,2298 ****
  	</row>
  	<row>
  	 <entry>ADD ALL other accessor methods, including
! 	 <methodname>engine</methodname>.</entry>
  	</row>
         </tbody>
        </tgroup>
--- 2292,2298 ----
  	</row>
  	<row>
  	 <entry>ADD ALL other accessor methods, including
! 	 <literal>engine</literal>.</entry>
  	</row>
         </tbody>
        </tgroup>
*************** UNFINISHED</para>
*** 2327,2333 ****
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>void</type> <methodname>makeOwnCopy</methodname>
  	   <void></void>
  	  </methodsynopsis>
           </entry>
--- 2327,2333 ----
  	<row>
  	 <entry>
            <methodsynopsis>
! 	   <type>void</type> <literal>makeOwnCopy</literal>
  	   <void></void>
  	  </methodsynopsis>
           </entry>
*************** UNFINISHED</para>
*** 2346,2353 ****
       <title>Implementation Details</title>
  
       <para>As a container, an &array;'s implementation is quite
!      simple.  Its <keywordname>private</keywordname>data consists of
!      an engine, and it has no <keywordname>private</keywordname>
       functions.</para>
  
       <table frame="none" colsep="0" rowsep="0" tocentry="1"
--- 2346,2353 ----
       <title>Implementation Details</title>
  
       <para>As a container, an &array;'s implementation is quite
!      simple.  Its <literal>private</literal>data consists of
!      an engine, and it has no <literal>private</literal>
       functions.</para>
  
       <table frame="none" colsep="0" rowsep="0" tocentry="1"
*************** UNFINISHED</para>
*** 2406,2413 ****
       <title>Implementation Details</title>
  
       <para><type>DynamicArray</type> has no
!      <keywordname>protected</keywordname> or
!      <keywordname>private</keywordname> members.</para>
      </section>
     </section>
  
--- 2406,2413 ----
       <title>Implementation Details</title>
  
       <para><type>DynamicArray</type> has no
!      <literal>protected</literal> or
!      <literal>private</literal> members.</para>
      </section>
     </section>
  
*************** UNFINISHED</para>
*** 2456,2462 ****
      <para>In &pooma;, expressions may contain entire &array;s.  That
      is, &array;s are first-class objects with respect to expressions.
      For example, given &array;s <varname>a</varname> and
!     <varname>b</varname>, the expression <statement>a + b</statement>
      is equivalent to an array containing the element-wise sum of the
      two arrays.</para>
  
--- 2456,2462 ----
      <para>In &pooma;, expressions may contain entire &array;s.  That
      is, &array;s are first-class objects with respect to expressions.
      For example, given &array;s <varname>a</varname> and
!     <varname>b</varname>, the expression <literal>a + b</literal>
      is equivalent to an array containing the element-wise sum of the
      two arrays.</para>
  
*************** UNFINISHED</para>
*** 2696,2702 ****
       <title>Element Access</title>
  
       <para>ADD: a table ala &array;.  Be sure to include
!      <methodname>all</methodname>.</para>
      </section>
  
  
--- 2696,2702 ----
       <title>Element Access</title>
  
       <para>ADD: a table ala &array;.  Be sure to include
!      <literal>all</literal>.</para>
      </section>
  
  
*************** UNFINISHED</para>
*** 2718,2726 ****
  
       <para>See <filename
  			 class="headerfile">src/Field/Field.h</filename>'s
!       <methodname>operator[]</methodname>,
!       <methodname>subField</methodname>, &hellip;,
!       <methodname>material</methodname>.</para>
      </section>
  
  
--- 2718,2726 ----
  
       <para>See <filename
  			 class="headerfile">src/Field/Field.h</filename>'s
!       <literal>operator[]</literal>,
!       <literal>subField</literal>, &hellip;,
!       <literal>material</literal>.</para>
      </section>
  
  
*************** UNFINISHED</para>
*** 2728,2737 ****
       <title>Supporting Relations</title>
  
       <para>ADD: a table with the member functions including
!      <methodname>addRelation</methodname>,
!      <methodname>removeRelations</methodname>,
!      <methodname>applyRelations</methodname>, and
!      <methodname>setDirty</methodname>.</para>
      </section>
  
  
--- 2728,2737 ----
       <title>Supporting Relations</title>
  
       <para>ADD: a table with the member functions including
!      <literal>addRelation</literal>,
!      <literal>removeRelations</literal>,
!      <literal>applyRelations</literal>, and
!      <literal>setDirty</literal>.</para>
      </section>
  
  
*************** UNFINISHED</para>
*** 2747,2753 ****
       <title>Utility Methods</title>
  
       <para>ADD: a table including
!       <methodname>makeOwnCopy</methodname>.</para>
      </section>
  
  
--- 2747,2753 ----
       <title>Utility Methods</title>
  
       <para>ADD: a table including
!       <literal>makeOwnCopy</literal>.</para>
      </section>
  
  
*************** UNFINISHED</para>
*** 2767,2773 ****
      <para>Be sure to relate to &array; views.  Note only three
      dimensions are supported.</para>
  
!     <para>Be sure to describe <statement>f[i]</statement>.  Does this
      refer to a particular material or a particular value within a
      cell?  I do not remember.  See <type>SubFieldView</type> in
      <filename class="headerfile">src/Field/Field.h</filename>.</para>
--- 2767,2773 ----
      <para>Be sure to relate to &array; views.  Note only three
      dimensions are supported.</para>
  
!     <para>Be sure to describe <literal>f[i]</literal>.  Does this
      refer to a particular material or a particular value within a
      cell?  I do not remember.  See <type>SubFieldView</type> in
      <filename class="headerfile">src/Field/Field.h</filename>.</para>
*************** UNFINISHED</para>
*** 3180,3187 ****
     <section id="engines_ref-access">
      <title>Element Access</title>
  
!     <para>ADD: a table with <methodname>read</methodname> and
!     <methodname>operator()</methodname>.</para>
     </section>
  
  
--- 3180,3187 ----
     <section id="engines_ref-access">
      <title>Element Access</title>
  
!     <para>ADD: a table with <literal>read</literal> and
!     <literal>operator()</literal>.</para>
     </section>
  
  
*************** UNFINISHED</para>
*** 3204,3213 ****
      <title>Utility Methods</title>
  
      <para>ADD: a table including
!     <methodname>makeOwnCopy</methodname>.</para>
  
!     <para>QUESTION: What are <methodname>dataObject</methodname>,
!     <methodname>isShared</methodname>, and related methods?</para>
     </section>
  
  
--- 3204,3213 ----
      <title>Utility Methods</title>
  
      <para>ADD: a table including
!     <literal>makeOwnCopy</literal>.</para>
  
!     <para>QUESTION: What are <literal>dataObject</literal>,
!     <literal>isShared</literal>, and related methods?</para>
     </section>
  
  
*************** UNFINISHED</para>
*** 3226,3232 ****
  
      <para>ADD: description of what a brick means.  ADD: whatever
      specializations the class has, e.g.,
!     <methodname>offset</methodname>.</para>
  
      <para>QUESTION: What does <type>DoubleSliceHelper</type> do?</para>
     </section>
--- 3226,3232 ----
  
      <para>ADD: description of what a brick means.  ADD: whatever
      specializations the class has, e.g.,
!     <literal>offset</literal>.</para>
  
      <para>QUESTION: What does <type>DoubleSliceHelper</type> do?</para>
     </section>
*************** UNFINISHED</para>
*** 3375,3381 ****
      created by <function>Pooma::initialize</function>, storing
      run-time configurable values found in <varname>argv</varname>.
      Default options are found in
!     <methodname>Options::usage</methodname>.</para>
  
      <para>See <filename
      class="headerfile">src/Utilities/Options.h</filename> and
--- 3375,3381 ----
      created by <function>Pooma::initialize</function>, storing
      run-time configurable values found in <varname>argv</varname>.
      Default options are found in
!     <literal>Options::usage</literal>.</para>
  
      <para>See <filename
      class="headerfile">src/Utilities/Options.h</filename> and
*************** UNFINISHED</para>
*** 3593,3599 ****
       class="headerfile">src/Utilities/DerefIterator.h</filename>:
       <type>DerefIterator&lt;T&gt;</type> and
       <type>ConstDerefIterator&lt;T&gt;</type> automatically
!      dereference themselves to maintain <keywordname>const</keywordname>
       correctness.</para>
      </listitem>
  
--- 3593,3599 ----
       class="headerfile">src/Utilities/DerefIterator.h</filename>:
       <type>DerefIterator&lt;T&gt;</type> and
       <type>ConstDerefIterator&lt;T&gt;</type> automatically
!      dereference themselves to maintain <literal>const</literal>
       correctness.</para>
      </listitem>
  
*************** UNFINISHED</para>
*** 3896,3902 ****
         modification.  However, if you are using &mm;, ensure
         <varname>shmem_default_dir</varname> specifies its location.
         For example, the &author; modified the value to
!        <statement>"/home/oldham/pooma/mm-1.1.3"</statement>.</para>
        </listitem>
        <listitem>
         <para>Prepare to compile the source code by configuring it
--- 3896,3902 ----
         modification.  However, if you are using &mm;, ensure
         <varname>shmem_default_dir</varname> specifies its location.
         For example, the &author; modified the value to
!        <literal>"/home/oldham/pooma/mm-1.1.3"</literal>.</para>
        </listitem>
        <listitem>
         <para>Prepare to compile the source code by configuring it
Index: template.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/template.xml,v
retrieving revision 1.4
diff -c -p -r1.4 template.xml
*** template.xml	2002/01/30 23:09:06	1.4
--- template.xml	2002/01/30 23:47:36
***************
*** 95,101 ****
      its dimension, the type of its values, and its &engine; type.  To
      use this, a programmer specifies values for the template
      parameters:
!     <statement><type>Array&lt;2,double,Brick&gt;</type></statement>
      specifies a dimension of 2, a value type of &double;, and the
      &brick; &engine; type.  At compile time, the compiler creates a
      type definition by substituting the values for the template
--- 95,101 ----
      its dimension, the type of its values, and its &engine; type.  To
      use this, a programmer specifies values for the template
      parameters:
!     <literal><type>Array&lt;2,double,Brick&gt;</type></literal>
      specifies a dimension of 2, a value type of &double;, and the
      &brick; &engine; type.  At compile time, the compiler creates a
      type definition by substituting the values for the template
***************
*** 195,201 ****
      these concrete types with a template
      parameter&nbsp;<varname>T</varname>.  We
      <emphasis>precede</emphasis>, not follow, the class definition
!     with <statement>template &lt;typename T&gt;</statement>.  The
      constructor's parameters' types are changed
      to&nbsp;<varname>T</varname>, as are the data members'
      types.</para>
--- 195,201 ----
      these concrete types with a template
      parameter&nbsp;<varname>T</varname>.  We
      <emphasis>precede</emphasis>, not follow, the class definition
!     with <literal>template &lt;typename T&gt;</literal>.  The
      constructor's parameters' types are changed
      to&nbsp;<varname>T</varname>, as are the data members'
      types.</para>
***************
*** 223,236 ****
         arearefs="template_programming-template_use-templated_pair_program-use">
         <para>To use a templated class, specify the template
         parameter's argument after the class's name and surrounded by
!        angle brackets&nbsp;(<statement>&lt;&gt;</statement>).</para>
        </callout>
       </calloutlist>
       </example>
  
      <para>To use a template class definition, template arguments
      follow the class name surrounded by angle
!     brackets&nbsp;(<statement>&lt;&gt;</statement>).  For example,
      <type>pair&lt;int&gt;</type> <glossterm
      linkend="glossary-template_instantiation"><firstterm>instantiates</firstterm></glossterm>
      <indexterm>
--- 223,236 ----
         arearefs="template_programming-template_use-templated_pair_program-use">
         <para>To use a templated class, specify the template
         parameter's argument after the class's name and surrounded by
!        angle brackets&nbsp;(<literal>&lt;&gt;</literal>).</para>
        </callout>
       </calloutlist>
       </example>
  
      <para>To use a template class definition, template arguments
      follow the class name surrounded by angle
!     brackets&nbsp;(<literal>&lt;&gt;</literal>).  For example,
      <type>pair&lt;int&gt;</type> <glossterm
      linkend="glossary-template_instantiation"><firstterm>instantiates</firstterm></glossterm>
      <indexterm>
***************
*** 242,249 ****
      creates a definition for <type>pair&lt;int&gt;</type> by copying
      <classname>pair</classname>'s template definition and substituting
      &int; for each occurrence of&nbsp;<varname>T</varname>.  The copy
!     omits the template parameter declaration <statement>template
!     &lt;typename T&gt;</statement> at the beginning of its definition.
      The result is a definition exactly the same as
      <classname>pairOfInts</classname>.</para>
  
--- 242,249 ----
      creates a definition for <type>pair&lt;int&gt;</type> by copying
      <classname>pair</classname>'s template definition and substituting
      &int; for each occurrence of&nbsp;<varname>T</varname>.  The copy
!     omits the template parameter declaration <literal>template
!     &lt;typename T&gt;</literal> at the beginning of its definition.
      The result is a definition exactly the same as
      <classname>pairOfInts</classname>.</para>
  
***************
*** 273,279 ****
      compile-time operations use these types.  For both run-time and
      compile-time programming, &cc; defines default sets of values that
      all conforming compilers must support.  For example,
!     <statement>3</statement> and <statement>6.022e+23</statement> are
      run-time values that any &cc; compiler must accept.  It must also
      accept the &int;, &bool;, and <type>int*</type> types.</para>
  
--- 273,279 ----
      compile-time operations use these types.  For both run-time and
      compile-time programming, &cc; defines default sets of values that
      all conforming compilers must support.  For example,
!     <literal>3</literal> and <literal>6.022e+23</literal> are
      run-time values that any &cc; compiler must accept.  It must also
      accept the &int;, &bool;, and <type>int*</type> types.</para>
  
*************** maxOut(0, 3);
*** 422,450 ****
      with the templated class in <xref
      linkend="template_programming-template_use-templated_pair_example"></xref>.
      Note the notation for the template class parameters.
!     <statement>template &lt;typename T&gt;</statement>
      <emphasis>precedes</emphasis> the class definition.  The keyword
!     <keywordname>typename</keywordname>
      <indexterm>
!      <primary><keywordname>typename</keywordname></primary>
      </indexterm>
      indicates the template
      parameter is a type.  <varname>T</varname>&nbsp;is the template
      parameter's name.  (We could have used any other identifier such
      as <varname>pairElementType</varname> or <varname>foo</varname>.)
!     Note that using <keywordname>class</keywordname>
      <indexterm>
!      <primary><keywordname>class</keywordname></primary>
      </indexterm>
      is equivalent to
!     using <keywordname>typename</keywordname> so <statement>template
!     &lt;class T&gt;</statement> is equivalent to <statement>template
!     &lt;typename T&gt;</statement>.  While declaring a template class
      requires prefix notation, using a templated class requires postfix
      notation.  The class's name precedes angle
      brackets&nbsp;(&lt;&gt;) surrounding specific values, i.e., types,
      for its parameters.  As we showed above,
!     <statement>pair&lt;int&gt;</statement> <glossterm
      linkend="glossary-template_instantiation">instantiates</glossterm>
      <indexterm>
       <primary>template</primary>
--- 422,450 ----
      with the templated class in <xref
      linkend="template_programming-template_use-templated_pair_example"></xref>.
      Note the notation for the template class parameters.
!     <literal>template &lt;typename T&gt;</literal>
      <emphasis>precedes</emphasis> the class definition.  The keyword
!     <literal>typename</literal>
      <indexterm>
!      <primary><literal>typename</literal></primary>
      </indexterm>
      indicates the template
      parameter is a type.  <varname>T</varname>&nbsp;is the template
      parameter's name.  (We could have used any other identifier such
      as <varname>pairElementType</varname> or <varname>foo</varname>.)
!     Note that using <literal>class</literal>
      <indexterm>
!      <primary><literal>class</literal></primary>
      </indexterm>
      is equivalent to
!     using <literal>typename</literal> so <literal>template
!     &lt;class T&gt;</literal> is equivalent to <literal>template
!     &lt;typename T&gt;</literal>.  While declaring a template class
      requires prefix notation, using a templated class requires postfix
      notation.  The class's name precedes angle
      brackets&nbsp;(&lt;&gt;) surrounding specific values, i.e., types,
      for its parameters.  As we showed above,
!     <literal>pair&lt;int&gt;</literal> <glossterm
      linkend="glossary-template_instantiation">instantiates</glossterm>
      <indexterm>
       <primary>template</primary>
*************** maxOut(0, 3);
*** 471,479 ****
      domain:
  <programlisting>
  typedef typename Engine_t::Domain_t Domain_t;
! </programlisting> This <keywordname>typedef</keywordname>,
      <indexterm>
!      <primary><keywordname>typedef</keywordname></primary>
       <see>type, definition.</see>
      </indexterm>
      <indexterm>
--- 471,479 ----
      domain:
  <programlisting>
  typedef typename Engine_t::Domain_t Domain_t;
! </programlisting> This <literal>typedef</literal>,
      <indexterm>
!      <primary><literal>typedef</literal></primary>
       <see>type, definition.</see>
      </indexterm>
      <indexterm>
*************** typedef typename Engine_t::Domain_t Doma
*** 483,491 ****
      i.e., type
      definition, defines the type <type>Domain_t</type> as equivalent
      to <type>Engine_t::Domain_t</type>.  The
!     <operator>::</operator>&nbsp;operator
      <indexterm>
!      <primary><operator>::</operator>&nbsp;operator</primary>
      </indexterm>
      selects the <type>Domain_t</type> nested type from inside the
      <type>Engine_t</type> type.  This illustrates how to access
--- 483,491 ----
      i.e., type
      definition, defines the type <type>Domain_t</type> as equivalent
      to <type>Engine_t::Domain_t</type>.  The
!     <literal>::</literal>&nbsp;operator
      <indexterm>
!      <primary><literal>::</literal>&nbsp;operator</primary>
      </indexterm>
      selects the <type>Domain_t</type> nested type from inside the
      <type>Engine_t</type> type.  This illustrates how to access
*************** typedef typename Engine_t::Domain_t Doma
*** 544,557 ****
         </row>
         <row>
  	<entry>operations on values</entry>
! 	<entry>Integral values support <operator>+</operator>,
! 	<operator>-</operator>, <operator>&gt;</operator>,
! 	<operator>==</operator>, &hellip;.  String values support
! 	<operator>[]</operator>, <operator>==</operator>, &hellip;.</entry>
  	<entry>Types may be declared and used.  Constant integral and
! 	enumeration values can be combined using <operator>+</operator>,
! 	<operator>-</operator>, <operator>&gt;</operator>,
! 	<operator>==</operator>, &hellip;.  There are no permitted
  	operations on code.</entry>
         </row>
         <row>
--- 544,557 ----
         </row>
         <row>
  	<entry>operations on values</entry>
! 	<entry>Integral values support <literal>+</literal>,
! 	<literal>-</literal>, <literal>&gt;</literal>,
! 	<literal>==</literal>, &hellip;.  String values support
! 	<literal>[]</literal>, <literal>==</literal>, &hellip;.</entry>
  	<entry>Types may be declared and used.  Constant integral and
! 	enumeration values can be combined using <literal>+</literal>,
! 	<literal>-</literal>, <literal>&gt;</literal>,
! 	<literal>==</literal>, &hellip;.  There are no permitted
  	operations on code.</entry>
         </row>
         <row>
*************** typedef typename Engine_t::Domain_t Doma
*** 572,586 ****
         <row>
  	<entry>extracting values from collections</entry>
  	<entry>An object's named values are extracted using the
! 	<operator>.</operator>&nbsp;operator.
          <indexterm>
!          <primary><operator>.</operator>&nbsp;operator</primary>
          </indexterm>
          </entry>
  	<entry>A class's nested types and classes are extracted using
! 	the <operator>::</operator>&nbsp;operator.
          <indexterm>
!          <primary><operator>::</operator>&nbsp;operator</primary>
          </indexterm>
          </entry>
         </row>
--- 572,586 ----
         <row>
  	<entry>extracting values from collections</entry>
  	<entry>An object's named values are extracted using the
! 	<literal>.</literal>&nbsp;operator.
          <indexterm>
!          <primary><literal>.</literal>&nbsp;operator</primary>
          </indexterm>
          </entry>
  	<entry>A class's nested types and classes are extracted using
! 	the <literal>::</literal>&nbsp;operator.
          <indexterm>
!          <primary><literal>::</literal>&nbsp;operator</primary>
          </indexterm>
          </entry>
         </row>
*************** typedef typename Engine_t::Domain_t Doma
*** 590,596 ****
           <primary>control flow</primary>
          </indexterm>
          to choose among operations</entry>
! 	<entry><keywordname>if</keywordname>, <keywordname>while</keywordname>, <keywordname>goto</keywordname>, &hellip;</entry>
  	<entry>template class specializations with pattern matching</entry>
         </row>
        </tbody>
--- 590,596 ----
           <primary>control flow</primary>
          </indexterm>
          to choose among operations</entry>
! 	<entry><literal>if</literal>, <literal>while</literal>, <literal>goto</literal>, &hellip;</entry>
  	<entry>template class specializations with pattern matching</entry>
         </row>
        </tbody>
*************** typedef typename Engine_t::Domain_t Doma
*** 609,615 ****
      </indexterm>
      The only compile-time values described in the previous
      section were types, but any compile-time constant can also be used.
!     Integral literals, <keywordname>const</keywordname> variables, and
      other constructs can be used, but the main use is enumerations.
      An <glossterm
      linkend="glossary-enumeration"><firstterm>enumeration</firstterm></glossterm>
--- 609,615 ----
      </indexterm>
      The only compile-time values described in the previous
      section were types, but any compile-time constant can also be used.
!     Integral literals, <literal>const</literal> variables, and
      other constructs can be used, but the main use is enumerations.
      An <glossterm
      linkend="glossary-enumeration"><firstterm>enumeration</firstterm></glossterm>
*************** struct usuallySimpleClass {
*** 741,747 ****
      should be true only if the constructor must perform some very
      complicated, time-expensive computation.  When instantiated with
      &false;, the compiler substitutes this value into the template
!     class definition.  Since the <keywordname>if</keywordname>
      statement's conditional is false, the compiler optimizer can
      eliminate the statement, yielding internal code similar to
  <programlisting>
--- 741,747 ----
      should be true only if the constructor must perform some very
      complicated, time-expensive computation.  When instantiated with
      &false;, the compiler substitutes this value into the template
!     class definition.  Since the <literal>if</literal>
      statement's conditional is false, the compiler optimizer can
      eliminate the statement, yielding internal code similar to
  <programlisting>
*************** struct usuallySimpleClass&lt;false&gt; {
*** 774,791 ****
  
      <para>Each category<firstterm></firstterm> of values supports a
      distinct set of operations.  For example, the run-time category of
!     integer values supports combination using <operator>+</operator>
!     and <operator>-</operator> and comparison using
!     <operator>&gt;</operator> and <operator>==</operator>.  At run
      time, the category of strings can be compared using
!     <operator>==</operator> and characters can be extracted using
!     subscripts with the <operator>[]</operator> operator.  Compile-time
      operations are more limited.  Types may be declared and used.  The
!     <keywordname>sizeof</keywordname> operator yields the number of
      bytes to represent an object of the specified type.  Enumerations,
!     constant integers, <keywordname>sizeof</keywordname> expressions,
      and simple arithmetic and comparison operators such as
!     <operator>+</operator> and <operator>==</operator> can form
      constant expressions that can be used at compile time.  These
      values can initialize enumerations and integer constants and be
      used as template arguments.  At compile time, pointers and
--- 774,791 ----
  
      <para>Each category<firstterm></firstterm> of values supports a
      distinct set of operations.  For example, the run-time category of
!     integer values supports combination using <literal>+</literal>
!     and <literal>-</literal> and comparison using
!     <literal>&gt;</literal> and <literal>==</literal>.  At run
      time, the category of strings can be compared using
!     <literal>==</literal> and characters can be extracted using
!     subscripts with the <literal>[]</literal> operator.  Compile-time
      operations are more limited.  Types may be declared and used.  The
!     <literal>sizeof</literal> operator yields the number of
      bytes to represent an object of the specified type.  Enumerations,
!     constant integers, <literal>sizeof</literal> expressions,
      and simple arithmetic and comparison operators such as
!     <literal>+</literal> and <literal>==</literal> can form
      constant expressions that can be used at compile time.  These
      values can initialize enumerations and integer constants and be
      used as template arguments.  At compile time, pointers and
*************** struct usuallySimpleClass&lt;false&gt; {
*** 809,822 ****
      can store multiple values, each
      having its own name.  For example, a <type>pair&lt;int&gt;</type>
      object&nbsp;<varname>p</varname> stores two &int;s named
!     <methodname>left_</methodname> and
!     <methodname>right_</methodname>.  The <operator>.</operator>
      operator
      <indexterm>
!      <primary><operator>.</operator>&nbsp;operator</primary>
      </indexterm>
      extracts a named member from an object:
!     <statement>p.left_</statement>.  At compile time, a class can
      store multiple values, each having its own name.  These are
      sometimes called <glossterm
      linkend="glossary-traits_class"><firstterm>traits
--- 809,822 ----
      can store multiple values, each
      having its own name.  For example, a <type>pair&lt;int&gt;</type>
      object&nbsp;<varname>p</varname> stores two &int;s named
!     <literal>left_</literal> and
!     <literal>right_</literal>.  The <literal>.</literal>
      operator
      <indexterm>
!      <primary><literal>.</literal>&nbsp;operator</primary>
      </indexterm>
      extracts a named member from an object:
!     <literal>p.left_</literal>.  At compile time, a class can
      store multiple values, each having its own name.  These are
      sometimes called <glossterm
      linkend="glossary-traits_class"><firstterm>traits
*************** struct ExpressionTraits&lt;BinaryNode&lt
*** 848,863 ****
  
      <para id="template_programming-pooma_implementation-double_colon_operator">
      <indexterm zone="template_programming-pooma_implementation-double_colon_operator">
!      <primary><operator>::</operator>&nbsp;operator</primary>
      </indexterm>
!     The example also illustrates using the <operator>::</operator>
      operator to extract a member of a traits class.  The type
      <type>ExpressionTraits&lt;Left&gt;</type> contains an internal
      type definition of <type>Type_t</type>.  Using the
!     <operator>::</operator> operator extracts it:
!     <statement>ExpressionTraits&lt;Left&gt;::Type_t</statement>.
      Enumerations and other values can also be extracted.  For example,
!     <statement>Array&lt;2, int, Brick&gt;::dimensions</statement>
      yields the dimension of the array's domain.</para>
  
      <para id="template_programming-pooma_implementation-template_specialization">
--- 848,863 ----
  
      <para id="template_programming-pooma_implementation-double_colon_operator">
      <indexterm zone="template_programming-pooma_implementation-double_colon_operator">
!      <primary><literal>::</literal>&nbsp;operator</primary>
      </indexterm>
!     The example also illustrates using the <literal>::</literal>
      operator to extract a member of a traits class.  The type
      <type>ExpressionTraits&lt;Left&gt;</type> contains an internal
      type definition of <type>Type_t</type>.  Using the
!     <literal>::</literal> operator extracts it:
!     <literal>ExpressionTraits&lt;Left&gt;::Type_t</literal>.
      Enumerations and other values can also be extracted.  For example,
!     <literal>Array&lt;2, int, Brick&gt;::dimensions</literal>
      yields the dimension of the array's domain.</para>
  
      <para id="template_programming-pooma_implementation-template_specialization">
*************** struct ExpressionTraits&lt;BinaryNode&lt
*** 869,877 ****
       <primary>control flow</primary>
      </indexterm>
      Control flow determines which code is used.  At run time,
!     control-flow statements such as <keywordname>if</keywordname>,
!     <keywordname>while</keywordname>, and
!     <keywordname>goto</keywordname> determine which statements to
      execute.  Template programming uses two mechanisms: template class
      specializations and pattern matching.  These are similar to
      control flow in functional programming languages.  A <glossterm
--- 869,877 ----
       <primary>control flow</primary>
      </indexterm>
      Control flow determines which code is used.  At run time,
!     control-flow statements such as <literal>if</literal>,
!     <literal>while</literal>, and
!     <literal>goto</literal> determine which statements to
      execute.  Template programming uses two mechanisms: template class
      specializations and pattern matching.  These are similar to
      control flow in functional programming languages.  A <glossterm
*************** struct CreateLeaf&lt;Expression&lt;T&clo
*** 932,943 ****
      <type>Expression&lt;int&gt;</type>.</para>
  
      <para>Control flow using template specializations and pattern
!     matching is similar to <keywordname>switch</keywordname>
      statements.
      <indexterm>
!      <primary><keywordname>switch</keywordname></primary>
      </indexterm>
!     A <keywordname>switch</keywordname> statement has a
      condition and one or more pairs of case labels and associated
      code.  The code associated with the the case label whose value
      matches the condition is executed.  If no case label matches the
--- 932,943 ----
      <type>Expression&lt;int&gt;</type>.</para>
  
      <para>Control flow using template specializations and pattern
!     matching is similar to <literal>switch</literal>
      statements.
      <indexterm>
!      <primary><literal>switch</literal></primary>
      </indexterm>
!     A <literal>switch</literal> statement has a
      condition and one or more pairs of case labels and associated
      code.  The code associated with the the case label whose value
      matches the condition is executed.  If no case label matches the
*************** CreateLeaf&lt;Expression&lt;int&closeclo
*** 949,959 ****
      the condition.  The set of template parameters for the indicated
      template class, e.g., <type>CreateLeaf</type>, are analogous to
      the case labels, and each has an associated definition.  In our
!     example, the set of template parameters are <statement>&lt;class
!     T&gt;</statement> and <statement>&lt;Expression&lt;class
!     T&closeclose;</statement>.  The <quote>best match</quote>, if any,
      indicates the matching code that will be used.  In our example,
!     the <statement>&lt;class T&gt;</statement> parameter serves as the
      default label since it matches any arguments.  If no set of
      template parameters match (which is impossible for our example) or
      if more than one set are best matches, the code is
--- 949,959 ----
      the condition.  The set of template parameters for the indicated
      template class, e.g., <type>CreateLeaf</type>, are analogous to
      the case labels, and each has an associated definition.  In our
!     example, the set of template parameters are <literal>&lt;class
!     T&gt;</literal> and <literal>&lt;Expression&lt;class
!     T&closeclose;</literal>.  The <quote>best match</quote>, if any,
      indicates the matching code that will be used.  In our example,
!     the <literal>&lt;class T&gt;</literal> parameter serves as the
      default label since it matches any arguments.  If no set of
      template parameters match (which is impossible for our example) or
      if more than one set are best matches, the code is
*************** class F {
*** 1012,1018 ****
  </programlisting>  Both the templated class and the templated function
      take the same template arguments, but the class uses a static
      member function.  Thus, the notation to invoke it is slightly more
!     verbose: <statement>F&lt;T&gt;::f(t)</statement>.</para>
  
      <para id="template_programming-pooma_implementation-function_template-overloaded">
      <indexterm zone="template_programming-pooma_implementation-function_template-overloaded">
--- 1012,1018 ----
  </programlisting>  Both the templated class and the templated function
      take the same template arguments, but the class uses a static
      member function.  Thus, the notation to invoke it is slightly more
!     verbose: <literal>F&lt;T&gt;::f(t)</literal>.</para>
  
      <para id="template_programming-pooma_implementation-function_template-overloaded">
      <indexterm zone="template_programming-pooma_implementation-function_template-overloaded">
*************** class F {
*** 1025,1031 ****
      </indexterm>
      The advantage of a function template is that it can be overloaded,
      particularly operator functions.  For example, the
!     <operator>+</operator> operator is overloaded to add two &array;s,
      which require template parameters to specify:
  <programlisting>
  template &lt;int D1,class T1,class E1,
--- 1025,1031 ----
      </indexterm>
      The advantage of a function template is that it can be overloaded,
      particularly operator functions.  For example, the
!     <literal>+</literal> operator is overloaded to add two &array;s,
      which require template parameters to specify:
  <programlisting>
  template &lt;int D1,class T1,class E1,
*************** template &lt;int D1,class T1,class E1,
*** 1034,1041 ****
  operator+(const Array&lt;D1,T1,E1&gt; & l,
            const Array&lt;D2,T2,E2&gt; & r);
  </programlisting>  Without using function templates, it would not be
!     possible to write expressions such as <statement>a1 +
!     a2</statement>.  Member functions can also be templated.  This
      permits, for example, overloading of assignment operators defined
      within templated classes.
      <indexterm class="endofrange" startref="template_programming-pooma_implementation-function_template">
--- 1034,1041 ----
  operator+(const Array&lt;D1,T1,E1&gt; & l,
            const Array&lt;D2,T2,E2&gt; & r);
  </programlisting>  Without using function templates, it would not be
!     possible to write expressions such as <literal>a1 +
!     a2</literal>.  Member functions can also be templated.  This
      permits, for example, overloading of assignment operators defined
      within templated classes.
      <indexterm class="endofrange" startref="template_programming-pooma_implementation-function_template">
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.9
diff -c -p -r1.9 tutorial.xml
*** tutorial.xml	2002/01/30 23:09:06	1.9
--- tutorial.xml	2002/01/30 23:47:37
***************
*** 215,221 ****
    value is assigned the average of its corresponding value in
    <varname>b</varname> and the latter's neighbors.  Values in the
    two-dimensional grids are accessed using two sets of brackets, e.g.,
!   <statement>a[i][j]</statement>.  After assigning values to
    <varname>a</varname>, a second averaging reads values in
    <varname>a</varname>, writing values in <varname>b</varname>.</para>
  
--- 215,221 ----
    value is assigned the average of its corresponding value in
    <varname>b</varname> and the latter's neighbors.  Values in the
    two-dimensional grids are accessed using two sets of brackets, e.g.,
!   <literal>a[i][j]</literal>.  After assigning values to
    <varname>a</varname>, a second averaging reads values in
    <varname>a</varname>, writing values in <varname>b</varname>.</para>
  
***************
*** 250,256 ****
       <para>Initially, all grid values are zero except for the one
       nonzero value at the center of the second array.  Array
       positions are indicated using two brackets, e.g.,
!      <statement>a[i][j]</statement>.  A better implementation might
       initialize only the outermost values of the
       <varname>a</varname> array.</para>
      </callout>
--- 250,256 ----
       <para>Initially, all grid values are zero except for the one
       nonzero value at the center of the second array.  Array
       positions are indicated using two brackets, e.g.,
!      <literal>a[i][j]</literal>.  A better implementation might
       initialize only the outermost values of the
       <varname>a</varname> array.</para>
      </callout>
***************
*** 335,342 ****
       its value type, and how the values will be stored or computed.
       The &brick; &engine; type indicates values will be directly
       stored.  It is responsible for allocating and deallocating
!      storage so <statement>new</statement> and
!      <statement>delete</statement> statements are not necessary.
       The <varname>vertDomain</varname> specifies the array index
       domain.</para>
      </callout>
--- 335,342 ----
       its value type, and how the values will be stored or computed.
       The &brick; &engine; type indicates values will be directly
       stored.  It is responsible for allocating and deallocating
!      storage so <literal>new</literal> and
!      <literal>delete</literal> statements are not necessary.
       The <varname>vertDomain</varname> specifies the array index
       domain.</para>
      </callout>
***************
*** 345,351 ****
       same scalar value.  The second statement
       illustrates assigning one &array; value.  Indices, separated by
       commas, are surrounded by parentheses rather than surrounded by
!      square brackets (<statement>[]</statement>).</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-first_write">
       <para>&array; element access uses parentheses, rather than
--- 345,351 ----
       same scalar value.  The second statement
       illustrates assigning one &array; value.  Indices, separated by
       commas, are surrounded by parentheses rather than surrounded by
!      square brackets (<literal>[]</literal>).</para>
      </callout>
      <callout arearefs="tutorial-array_elementwise-doof2d-first_write">
       <para>&array; element access uses parentheses, rather than
***************
*** 394,413 ****
  
    <para>&array;s support both element-wise access and scalar
    assignment.  Element-wise access uses parentheses, not square
!   brackets.  For example, <statement>b(n/2,n/2)</statement>
!   specifies the central element.  The scalar assignment <statement>b
!   = 0.0</statement> assigns the same 0.0 value to all array
    elements.  This is possible because the array knows the extent of
    its domain.  We illustrate these data-parallel statements in the
    next section.</para>
  
    <para>Any program using the &poomatoolkit; must initialize the
    &toolkit;'s data structures using
!   <statement>Pooma::initialize(argc,argv)</statement>.  This extracts
    &pooma;-specific command-line options from the program's
    command-line arguments and initializes the interprocessor
    communication and other data structures.  When finished,
!   <statement>Pooma::finalize()</statement> ensures all computation and
    communication has finished and the data structures are
    destructed.</para>
   </section>
--- 394,413 ----
  
    <para>&array;s support both element-wise access and scalar
    assignment.  Element-wise access uses parentheses, not square
!   brackets.  For example, <literal>b(n/2,n/2)</literal>
!   specifies the central element.  The scalar assignment <literal>b
!   = 0.0</literal> assigns the same 0.0 value to all array
    elements.  This is possible because the array knows the extent of
    its domain.  We illustrate these data-parallel statements in the
    next section.</para>
  
    <para>Any program using the &poomatoolkit; must initialize the
    &toolkit;'s data structures using
!   <literal>Pooma::initialize(argc,argv)</literal>.  This extracts
    &pooma;-specific command-line options from the program's
    command-line arguments and initializes the interprocessor
    communication and other data structures.  When finished,
!   <literal>Pooma::finalize()</literal> ensures all computation and
    communication has finished and the data structures are
    destructed.</para>
   </section>
***************
*** 443,449 ****
      </callout>
      <callout arearefs="tutorial-array_parallel-doof2d-first_write">
       <para>Data-parallel expressions replace nested loops and array
!      element accesses.  For example, <statement>a(I,J)</statement>
       represents the subset of the <varname>a</varname> array having
       a domain equal to the Cartesian product of <varname>I</varname>
       and <varname>J</varname>.  Intervals can shifted by an additive
--- 443,449 ----
      </callout>
      <callout arearefs="tutorial-array_parallel-doof2d-first_write">
       <para>Data-parallel expressions replace nested loops and array
!      element accesses.  For example, <literal>a(I,J)</literal>
       represents the subset of the <varname>a</varname> array having
       a domain equal to the Cartesian product of <varname>I</varname>
       and <varname>J</varname>.  Intervals can shifted by an additive
***************
*** 454,483 ****
  
    <para>Data-parallel expressions use containers and domain objects to
    indicate a set of parallel expressions.  For example, in the program
!   listed above, <statement>a(I,J)</statement> specifies the subset of
    <varname>a</varname> array omitting the outermost elements.  The
    array's <varname>vertDomain</varname> domain consists of the
    Cartesian product of {0, 1, 2, &hellip;, n-1} with itself, while
    <varname>I</varname> and <varname>J</varname> each specify {1, 2,
!   &hellip;, n-2}.  Thus, <statement>a(I,J)</statement> is the subset
    with a domain of the Cartesian product of {1, 2, &hellip;, n-2} with
    itself.  It is called a <firstterm>view</firstterm> of an array.  It
    is itself an &array;, with a domain and supporting element access, but
    its storage is the same as <varname>a</varname>'s.  Changing a value
!   in <statement>a(I,J)</statement> also changes the same value in
    <varname>a</varname>.  Changing a value in the latter also changes
    the former if the value is not one of <varname>a</varname>'s
    outermost elements.  The expression
!   <statement>b(I+1,J+1)</statement> indicates the subset of
    <varname>b</varname> with a domain consisting of the Cartesian
    product of {2, 3, &hellip;, n-1}, i.e., the same domain as
!   <statement>a(I,J)</statement> but shifted up one unit and to the
    right one unit.  Only an &interval;'s value, not its name, is
    important so all uses of <varname>J</varname> in this program
    could be replaced by <varname>I</varname> without changing the
    semantics.</para>
  
!   <para>The statement assigning to <statement>a(I,J)</statement>
    illustrates that &array;s may participate in expressions.  Each
    addend is a view of an array, which is itself an array.  The views'
    indices are zero-based so their sum can be formed by adding
--- 454,483 ----
  
    <para>Data-parallel expressions use containers and domain objects to
    indicate a set of parallel expressions.  For example, in the program
!   listed above, <literal>a(I,J)</literal> specifies the subset of
    <varname>a</varname> array omitting the outermost elements.  The
    array's <varname>vertDomain</varname> domain consists of the
    Cartesian product of {0, 1, 2, &hellip;, n-1} with itself, while
    <varname>I</varname> and <varname>J</varname> each specify {1, 2,
!   &hellip;, n-2}.  Thus, <literal>a(I,J)</literal> is the subset
    with a domain of the Cartesian product of {1, 2, &hellip;, n-2} with
    itself.  It is called a <firstterm>view</firstterm> of an array.  It
    is itself an &array;, with a domain and supporting element access, but
    its storage is the same as <varname>a</varname>'s.  Changing a value
!   in <literal>a(I,J)</literal> also changes the same value in
    <varname>a</varname>.  Changing a value in the latter also changes
    the former if the value is not one of <varname>a</varname>'s
    outermost elements.  The expression
!   <literal>b(I+1,J+1)</literal> indicates the subset of
    <varname>b</varname> with a domain consisting of the Cartesian
    product of {2, 3, &hellip;, n-1}, i.e., the same domain as
!   <literal>a(I,J)</literal> but shifted up one unit and to the
    right one unit.  Only an &interval;'s value, not its name, is
    important so all uses of <varname>J</varname> in this program
    could be replaced by <varname>I</varname> without changing the
    semantics.</para>
  
!   <para>The statement assigning to <literal>a(I,J)</literal>
    illustrates that &array;s may participate in expressions.  Each
    addend is a view of an array, which is itself an array.  The views'
    indices are zero-based so their sum can be formed by adding
***************
*** 581,587 ****
    Applying the stencil's function call <function>operator()</function>
    yields the computed value.  To compute multiple &array; values,
    apply a stencil to the array and a domain object:
!   <statement>stencil(b, interiorDomain)</statement>.  This applies the
    stencil to each position in the domain.  The user must ensure that
    applying the stencil does not access nonexistent &array;
    values.</para>
--- 581,587 ----
    Applying the stencil's function call <function>operator()</function>
    yields the computed value.  To compute multiple &array; values,
    apply a stencil to the array and a domain object:
!   <literal>stencil(b, interiorDomain)</literal>.  This applies the
    stencil to each position in the domain.  The user must ensure that
    applying the stencil does not access nonexistent &array;
    values.</para>
***************
*** 611,632 ****
  
    <para>To create a stencil object, apply the &stencil; type to a
    function object class.  For example,
!   <statement>Stencil&lt;DoofNinePt&gt; stencil</statement> declares
    the <varname>stencil</varname> object.  The function object class
    must define a function call <function>operator()</function> with a
    container parameter and index parameters.  The number of index
    parameters, indicating the stencil's center, must equal the
    container's dimension.  For example, <type>DoofNinePt</type> defines
!   <methodname>operator()(const C& c, int i, int j)</methodname>.  We
    templated the container type <varname>C</varname> although this is
    not strictly necessary.  The two index parameters
    <varname>i</varname> and <varname>j</varname> ensure the stencil
    works with two-dimensional containers.  The
!   <methodname>lowerExtent</methodname> function indicates how far to
    the left (or below) the stencil extends beyond its center.  Its
    parameter indicates a particular dimension.  Index parameters
    <varname>i</varname> and <varname>j</varname> are in dimension 0
!   and&nbsp;1.  <methodname>upperExtent</methodname> serves an
    analogous purpose.  The &poomatoolkit; uses these functions when
    distributing computation among various processors, but it does not
    use these functions to ensure nonexistent &array; values are not
--- 611,632 ----
  
    <para>To create a stencil object, apply the &stencil; type to a
    function object class.  For example,
!   <literal>Stencil&lt;DoofNinePt&gt; stencil</literal> declares
    the <varname>stencil</varname> object.  The function object class
    must define a function call <function>operator()</function> with a
    container parameter and index parameters.  The number of index
    parameters, indicating the stencil's center, must equal the
    container's dimension.  For example, <type>DoofNinePt</type> defines
!   <literal>operator()(const C& c, int i, int j)</literal>.  We
    templated the container type <varname>C</varname> although this is
    not strictly necessary.  The two index parameters
    <varname>i</varname> and <varname>j</varname> ensure the stencil
    works with two-dimensional containers.  The
!   <literal>lowerExtent</literal> function indicates how far to
    the left (or below) the stencil extends beyond its center.  Its
    parameter indicates a particular dimension.  Index parameters
    <varname>i</varname> and <varname>j</varname> are in dimension 0
!   and&nbsp;1.  <literal>upperExtent</literal> serves an
    analogous purpose.  The &poomatoolkit; uses these functions when
    distributing computation among various processors, but it does not
    use these functions to ensure nonexistent &array; values are not

From oldham at codesourcery.com  Thu Jan 31 21:23:24 2002
From: oldham at codesourcery.com (Jeffrey D . Oldham)
Date: Thu, 31 Jan 2002 13:23:24 -0800
Subject: Manual Patch: Formatting Changes
Message-ID: <20020131132324.A29384@vaio.codesourcery.com>

2002-Jan-31  Jeffrey D. Oldham  <oldham at codesourcery.com>

This patch continues the formatting to prepare the manual for delivery.
No substantive semantic changes were made.
	
	* Makefile: Generalize to support any top-level name.  Fix
	mistakes in PostScript and PDF rules.
	* arrays.xml: Reformat and reword to avoid bad line breaks and
	incursions into the right margin.
	* data-parallel.xml: Reformat to avoid bad line breaks and
	incursions into the right margin.
	* html.dsl: New file controlling conversion of DocBook into HTML.
	* jadetex.cfg: New file controlling jadetex, which converts TeX to
	PostScript and PDF.  The changes support better line breaking for
	URLs and pathnames.
	* manual.xml: Renamed pooma.xml.
	* pooma.xml: New file moved from manual.xml.
	* print.dsl: New file controlling conversion of DocBook into
	PostScript and PDF.
	* template.xml: Fix parameter type.
	* tutorial.xml: Reformat and reword to avoid bad line breaks and
	incursions into the right margin.

Applied to	mainline.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: Makefile
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/Makefile,v
retrieving revision 1.3
diff -c -p -r1.3 Makefile
*** Makefile	2002/01/30 23:09:06	1.3
--- Makefile	2002/01/31 21:10:37
*************** HTMLDOCBOOKDSL=		html.dsl # html/docbook
*** 13,27 ****
  XML=			dtds/decls/xml.dcl
  INDEXOPTIONS=		-t 'Index' -i 'index' -g -p
  
! XMLSOURCES= manual.xml introduction.xml template.xml tutorial.xml \
              concepts.xml arrays.xml data-parallel.xml glossary.xml \
              bibliography.xml 
  
  ## HERE  How do I include dependences on programs?
  
! all: manual.ps manual.pdf manual.html
  
! manual.dvi manual.pdf manual.html: $(XMLSOURCES) figures
  
  figures:
  	$(MAKE) -C figures
--- 13,28 ----
  XML=			dtds/decls/xml.dcl
  INDEXOPTIONS=		-t 'Index' -i 'index' -g -p
  
! MANUALNAME= pooma
! XMLSOURCES= $(MANUALNAME).xml introduction.xml template.xml tutorial.xml \
              concepts.xml arrays.xml data-parallel.xml glossary.xml \
              bibliography.xml 
  
  ## HERE  How do I include dependences on programs?
  
! all: $(MANUALNAME).ps $(MANUALNAME).pdf $(MANUALNAME).html
  
! $(MANUALNAME).dvi $(MANUALNAME).pdf $(MANUALNAME).html: $(XMLSOURCES) figures
  
  figures:
  	$(MAKE) -C figures
*************** genindex.sgm:
*** 33,54 ****
  	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) $(XML) $<
  
  # This rule assumes index creation.
! %.dvi:	%.xml genindex.sgm print.dsl
  	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $<
  	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index
  	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) -V tex-backend -V use-eps $(XML) $<
! 	jadetex $*.tex
! 	jadetex $*.tex
! 	jadetex $*.tex
  
  # This rule assumes index creation.
! %.pdf:	%.xml genindex.sgm print.dsl
  	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $<
  	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index
  	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) $(XML) $<
! 	pdfjadetex $*.tex
! 	pdfjadetex $*.tex
! 	pdfjadetex $*.tex
  
  clean:
! 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.html *.mpx mpxerr.tex HTML.index manual.tex genindex.sgm pooma-html.manifest
--- 34,58 ----
  	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) $(XML) $<
  
  # This rule assumes index creation.
! $(MANUALNAME).dvi: $(XMLSOURCES) genindex.sgm print.dsl
  	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $<
  	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index
  	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) -V tex-backend -V use-eps $(XML) $<
! 	jadetex $(MANUALNAME).tex
! 	jadetex $(MANUALNAME).tex
! 	jadetex $(MANUALNAME).tex
  
+ %.ps:	%.dvi
+ 	dvips -t letter $< -o
+ 
  # This rule assumes index creation.
! $(MANUALNAME).pdf: $(XMLSOURCES) genindex.sgm print.dsl
  	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $<
  	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index
  	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) $(XML) $<
! 	pdfjadetex $(MANUALNAME).tex
! 	pdfjadetex $(MANUALNAME).tex
! 	pdfjadetex $(MANUALNAME).tex
  
  clean:
! 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.html *.mpx mpxerr.tex HTML.index $(MANUALNAME).tex genindex.sgm pooma-html.manifest
Index: arrays.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/arrays.xml,v
retrieving revision 1.7
diff -c -p -r1.7 arrays.xml
*** arrays.xml	2002/01/30 23:51:45	1.7
--- arrays.xml	2002/01/31 21:10:38
***************
*** 156,162 ****
      interval&nbsp;[2,9].  Its indices are ordered pairs such as (0,2),
      (0,3), (1,2), (1,9), and&nbsp;(3,7).</para>
  
!     <para>Many domains can be represented using domain triplets.  A
      <glossterm linkend="glossary-domain_triplet"><firstterm>domain
      triplet</firstterm></glossterm>
      [<varname>begin</varname>:<varname>end</varname>:<varname>stride</varname>]
--- 156,163 ----
      interval&nbsp;[2,9].  Its indices are ordered pairs such as (0,2),
      (0,3), (1,2), (1,9), and&nbsp;(3,7).</para>
  
!     <para>Many domains can be represented using domain triplets.  That
!     is, a
      <glossterm linkend="glossary-domain_triplet"><firstterm>domain
      triplet</firstterm></glossterm>
      [<varname>begin</varname>:<varname>end</varname>:<varname>stride</varname>]
*************** Array&lt;1,double,CompressibleBrick&gt;
*** 1420,1431 ****
      domains:
  <programlisting>
  // Create an Array and its domain.
! Array<2,float,Brick> a(Interval<1>(2,7), Interval<1>(-2,4));
  
  // Create an Array without a domain and then specify
  // its domain.
! Array<2,float,Brick> b();
! b.initialize(Interval<1>(2,7), Interval<1>(-2,4));.
  </programlisting>  Invoking <literal>initialize</literal> on an
      &array; with an existing domain yields unspecified behavior.  All
      &array; values may be lost and memory may be leaked.</para>
--- 1421,1433 ----
      domains:
  <programlisting>
  // Create an Array and its domain.
! Array&lt;2,float,Brick&gt; a(Interval&lt;1&gt;(2,7),
!                        Interval&lt;1&gt;(-2,4));
  
  // Create an Array without a domain and then specify
  // its domain.
! Array&lt;2,float,Brick&gt; b();
! b.initialize(Interval&lt;1&gt;(2,7), Interval&lt;1&gt;(-2,4));.
  </programlisting>  Invoking <literal>initialize</literal> on an
      &array; with an existing domain yields unspecified behavior.  All
      &array; values may be lost and memory may be leaked.</para>
*************** object or integer.</entry>
*** 1570,1576 ****
      following code prints the initial value at index (2,-2) and
      increments its value, printing the new value:
  <programlisting>
! Array&lt;2,int,Brick&gt; a(Interval&lt;1&gt;(0,3), Interval&lt;1&gt;(-2,4),
       	               ModelElement&lt;int&gt;(4));
  std::cout &openopen; a(2,-2) &openopen; std::endl;
  ++a(2,-2);
--- 1572,1579 ----
      following code prints the initial value at index (2,-2) and
      increments its value, printing the new value:
  <programlisting>
! Array&lt;2,int,Brick&gt; a(Interval&lt;1&gt;(0,3),
!                        Interval&lt;1&gt;(-2,4),
       	               ModelElement&lt;int&gt;(4));
  std::cout &openopen; a(2,-2) &openopen; std::endl;
  ++a(2,-2);
Index: data-parallel.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/data-parallel.xml,v
retrieving revision 1.6
diff -c -p -r1.6 data-parallel.xml
*** data-parallel.xml	2002/01/30 23:51:45	1.6
--- data-parallel.xml	2002/01/31 21:10:40
*************** Expression&lt;UnaryNode&lt;OpMinus,Ar&cl
*** 977,985 ****
  </programlisting>  The binary nodes continue the construction process yielding a
       parse tree object for the entire right-hand side and having type
  <programlisting>
! Expression&lt;BinaryNode&lt;OpAdd,
!                       UnaryNode&lt;OpMinus, Ar&gt;,
!                       BinaryNode&lt;OpMultiply&lt;Scalar&lt;int&gt;,Ar&closecloseclose;
  </programlisting> Evaluating the left-hand side yields an object
       representing&nbsp;<varname>A</varname>.</para>
  
--- 977,986 ----
  </programlisting>  The binary nodes continue the construction process yielding a
       parse tree object for the entire right-hand side and having type
  <programlisting>
! Expression&lt;
!   BinaryNode&lt;OpAdd,
!              UnaryNode&lt;OpMinus, Ar&gt;,
!              BinaryNode&lt;OpMultiply&lt;Scalar&lt;int&gt;,Ar&closecloseclose;
  </programlisting> Evaluating the left-hand side yields an object
       representing&nbsp;<varname>A</varname>.</para>
  
*************** forEach(const Expression&amp; e, const L
*** 1218,1224 ****
      nodes, it combines the results using the <type>CombineTag</type>
      operator&nbsp;<varname>c</varname>.  It inlines into a call to
  <programlisting>
! ForEach&lt;Expression, LeafTag, CombineTag&gt;::apply(e, f, c).
  </programlisting>  The <function>apply</function> function continues
      the traversal through the tree.  For our example,
      <type>LeafTag</type> equals <type>EvalLeaf&lt;1&gt;</type>, and
--- 1219,1225 ----
      nodes, it combines the results using the <type>CombineTag</type>
      operator&nbsp;<varname>c</varname>.  It inlines into a call to
  <programlisting>
! ForEach&lt;Expression, LeafTag, CombineTag&gt;::apply(e, f, c)
  </programlisting>  The <function>apply</function> function continues
      the traversal through the tree.  For our example,
      <type>LeafTag</type> equals <type>EvalLeaf&lt;1&gt;</type>, and
*************** ForEach&lt;Expression, LeafTag, CombineT
*** 1236,1246 ****
  template&lt;class Op, class A, class FTag, class CTag&gt;
  struct ForEach&lt;UnaryNode&lt;Op, A&gt;, FTag, CTag&gt;
  {
!   typedef typename ForEach&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
!   typedef typename Combine1&lt;TypeA_t, Op, CTag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const UnaryNode&lt;Op, A&gt; &amp;expr, const FTag &amp;f, 
!     const CTag &amp;c) 
    {
      return Combine1&lt;TypeA_t, Op, CTag&gt;::
        combine(ForEach&lt;A, FTag, CTag&gt;::
--- 1237,1248 ----
  template&lt;class Op, class A, class FTag, class CTag&gt;
  struct ForEach&lt;UnaryNode&lt;Op, A&gt;, FTag, CTag&gt;
  {
!   typedef typename ForEach&lt;A,FTag,CTag&gt;::Type_t TypeA_t;
!   typedef typename
!     Combine1&lt;TypeA_t,Op,CTag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const UnaryNode&lt;Op,A&gt;&amp;expr,const FTag&amp;f, 
!     const CTag&amp; c) 
    {
      return Combine1&lt;TypeA_t, Op, CTag&gt;::
        combine(ForEach&lt;A, FTag, CTag&gt;::
*************** struct ForEach&lt;UnaryNode&lt;Op, A&gt;
*** 1264,1272 ****
  template&lt;class Expr, class FTag, class CTag&gt;
  struct ForEach
  {
!   typedef typename LeafFunctor&lt;Expr, FTag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const Expr &amp;expr, const FTag &amp;f, const CTag &amp;)
    {
      return LeafFunctor&lt;Expr, FTag&gt;::apply(expr, f);
    }
--- 1266,1275 ----
  template&lt;class Expr, class FTag, class CTag&gt;
  struct ForEach
  {
!   typedef typename
!     LeafFunctor&lt;Expr, FTag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const Expr&amp;expr,const FTag&amp;f,const CTag&amp;)
    {
      return LeafFunctor&lt;Expr, FTag&gt;::apply(expr, f);
    }
*************** struct ForEach
*** 1286,1292 ****
  <programlisting>
  int end = A.domain[0].first() + A.domain[0].length();
  for (int i = A.domain[0].first(); i < end; ++i)
!   A.engine(i) += -A.engine.read(i) + 2 * B.engine.read(i);
  </programlisting>  The loop iterates through <varname>A</varname>'s
      domain, using &array;'s engines to obtain values and assigning
      values.  Notice there is no use of the run-time parse tree so the
--- 1289,1295 ----
  <programlisting>
  int end = A.domain[0].first() + A.domain[0].length();
  for (int i = A.domain[0].first(); i < end; ++i)
!   A.engine(i) += -A.engine.read(i)+2*B.engine.read(i);
  </programlisting>  The loop iterates through <varname>A</varname>'s
      domain, using &array;'s engines to obtain values and assigning
      values.  Notice there is no use of the run-time parse tree so the
Index: html.dsl
===================================================================
RCS file: html.dsl
diff -N html.dsl
*** /dev/null	Fri Mar 23 21:37:44 2001
--- html.dsl	Thu Jan 31 14:10:40 2002
***************
*** 0 ****
--- 1,82 ----
+ <!-- DSSSL style sheet for generating HTML from DocBook documents. -->
+ 
+ <!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN" [
+ <!ENTITY docbook.dsl PUBLIC "-//Norman Walsh//DOCUMENT DocBook HTML Stylesheet//EN" CDATA DSSSL>
+ ]>
+ 
+ <!-- This DSSSL stylesheet formats the POOMA manual, written in
+      DocBook, as converted to HTML.
+ 
+      Jeffrey D. Oldham
+      2002 January 29 -->
+ 
+ <style-sheet>
+ <style-specification use="docbook">
+ <style-specification-body>
+ 
+ ;; $Id: plain.dsl,v 1.2 2000/09/28 12:50:20 ndw Exp $
+ ;;
+ ;; This file is part of the Modular DocBook Stylesheet distribution.
+ ;; See ../README or http://www.berkshire.net/~norm/dsssl/
+ ;;
+ ;; Example of a customization layer on top of the modular docbook style
+ ;; sheet.  Definitions inserted in this file take precedence over 
+ ;; definitions in the 'use'd stylesheet(s).
+ 
+ ;; Use the extension .html for output files.
+ (define %html-ext% ".html")
+ 
+ ;; The main file is named index.
+ (define %root-filename% "pooma")
+ 
+ ;; Number chapters and sections.
+ (define %chapter-autolabel% #t)
+ (define %section-autolabel% #t)
+ 
+ ;; Don't place the first section of each chapter in the same chunk as
+ ;; the chapter head.
+ (define (chunk-skip-first-element-list) (list))
+ 
+ ;; Write a manifest of created files to pooma-html.manifest.
+ (define html-manifest #t)
+ (define html-manifest-filename "pooma-html.manifest")
+ 
+ ;; Use element ids to generate chunk filenames
+ (define %use-id-as-filename% #t)
+ 
+ ;; Support block elements inside para.
+ (define %fix-para-wrappers% #t)
+ 
+ ;; Avoid a hack to force 'correct' vertical spacing.
+ (define %spacing-para% #f)
+ 
+ ;; Prevent verbatim text from being displayed at a different size.
+ (define %verbatim-size-factor% 1.1)
+ 
+ ;; Change the default presentation for various tags.
+ ; Use mono-space font for computer items.
+ (element command ($mono-seq$))
+ (element envar ($mono-seq$))
+ (element errorname ($mono-seq$))
+ (element errortype ($mono-seq$))
+ (element keywordname ($mono-seq$))	; new tag aded by Oldham
+ (element methodname ($mono-seq$))	; new tag aded by Oldham
+ (element operator ($mono-seq$))		; new tag aded by Oldham
+ (element statement ($mono-seq$))	; new tag aded by Oldham
+ (element symbol ($mono-seq$))
+ (element token ($mono-seq$))
+ (element type ($mono-seq$))
+ 
+ ; Center figures.
+ (element mediaobject
+   (make element gi: "DIV"
+ 	attributes: (list (list "CLASS" (gi)) (list "ALIGN" "center"))
+ 	(make element gi: "P"
+ 	      ($mediaobject$))))
+ 
+ </style-specification-body>
+ </style-specification>
+ 
+ <external-specification id="docbook" document="docbook.dsl">
+ 
+ </style-sheet>
Index: jadetex.cfg
===================================================================
RCS file: jadetex.cfg
diff -N jadetex.cfg
*** /dev/null	Fri Mar 23 21:37:44 2001
--- jadetex.cfg	Thu Jan 31 14:10:41 2002
***************
*** 0 ****
--- 1,6 ----
+ %% Support better hyphenation for URLs and paths.
+ %% Idea taken from http://cyberelk.net/tim/docbook/selfdocbook/jadetex.cfg.htm
+ \usepackage{url}
+ \tolerance=2000
+ \hypersetup{colorlinks=false}
+ \hyphenation{block-And-Eval-u-ate}
Index: manual.xml
===================================================================
RCS file: manual.xml
diff -N manual.xml
*** /tmp/cvsWATf4H	Thu Jan 31 14:10:46 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,4220 ****
- <?xml version="1.0"?>
- <!-- FIXME: Index this file. -->
- 
- <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "file:///usr/lib/sgml/docbookx.dtd" [
- 
- <!-- Text to Check, Revise, Replace -->
-   <!-- FIXME: Revise before releasing. -->
-   <!-- UPDATE: Check before publishing to see if any needs changing. -->
-   <!-- ADD: Write more material. -->
- 
- <!-- Conditional Inclusion Entity Declarations -->
- <!ENTITY % unfinished "IGNORE">
-   <!-- Unfinished sections should not be included in published versions. -->
- <!ENTITY % temporary "INCLUDE">
-   <!-- Temporary sections to be included in published versions until the final version is written. -->
- 
- <!-- Index Entity Declarations -->
- <!ENTITY genindex.sgm SYSTEM "genindex.sgm">
- 
- <!-- General Entity Declarations -->
- 
- <!ENTITY book "book">
-   <!-- Produce a notation for the book/manual/report/WWW page.  -->
-   <!-- Modify this to the desired noun. -->
- <!ENTITY bookcap "Book">
-   <!-- Produce a capitalized version of &book;  -->
-   <!-- Modify this to the desired noun. -->
- <!ENTITY c "<application class='software'>C</application>">
-   <!-- Produce a notation for the C programming language.  -->
-   <!-- Modify this to the desired formatting. -->
- <!ENTITY cc "<application class='software'>C++</application>">
-   <!-- Produce a notation for the C++ programming language.  -->
-   <!-- Modify this to the desired formatting. -->
- <!ENTITY cheetah "<application class='software'>Cheetah</application>" >
-   <!-- Produce a notation for the Cheetah Library.  -->
- <!ENTITY closeclose "&gt;&gap;&gt;" >
-   <!-- Produce a notation for ">>", which frequently occurs with templates.  Without this, TeX produces a shift symbol. -->
- <!ENTITY closecloseclose "&gt;&gap;&gt;&gap;&gt;" >
-   <!-- Produce a notation for ">>>", which infrequently occurs with templates.  Without this, TeX produces a shift symbol. -->
- <!ENTITY dashdash "-&gap;-" >
-   <!-- Produce a notation for a double dash.  Without this, TeX produces an en-hyphen. -->
- <!ENTITY dim "D">
-   <!-- the number of dimensions of an array, domain, etc. -->
- <!ENTITY doof2d "<command>Doof2d</command>" >
-   <!-- Produce a notation for the Doof2d program.  -->
- <!ENTITY fortran "<application class='software'>Fortran</application>">
-   <!-- Produce a notation for the Fortran programming language.  -->
- <!ENTITY gap "&hairsp;">
-   <!-- Produce a small gap so TeX will not combine the two characters. -->
-   <!-- FIXME: Choose something that will work for TeX and also in HTML. -->
- <!ENTITY make "<application class='software'>Make</application>">
-   <!-- Produce a notation for the GNU Make program.  -->
- <!ENTITY mm "<application class='software'>MM</application>">
-   <!-- Produce a notation for the MM Library.  -->
- <!ENTITY mpi "<application class='software'>MPI</application>">
-   <!-- Produce a notation for the MPI package.  -->
- <!ENTITY openopen "&lt;&gap;&lt;" >
-   <!-- Produce a notation for "<<", which frequently occurs with output.  Without this, TeX produces a shift symbol. -->
- <!ENTITY pdt "<application class='software'>PDToolkit</application>">
-   <!-- Produce a notation for the PDT software package.  -->
- <!ENTITY pete "<application class='software'>PETE</application>">
-   <!-- Produce a notation for the PETE framework.  -->
- <!ENTITY pooma "<application class='software'>POOMA</application>">
-   <!-- Produce a notation for Pooma software.  -->
- <!ENTITY poomatoolkit "<application class='software'>POOMA &toolkitcap;</application>">
-   <!-- Produce a notation for the Pooma toolkit.  -->
- <!ENTITY purify "<application class='software'>Purify</application>">
-   <!-- Produce a notation for the Purify library.  -->
- <!ENTITY smarts "<application class='software'>Smarts</application>">
-   <!-- Produce a notation for the Smarts software package.  -->
-   <!-- Modify this after capitalization is decided. -->
- <!ENTITY stl "<application class='software'>STL</application>">
-   <!-- Produce a notation for the C++ Standard Template Library software package.  -->
- <!ENTITY tau "<application class='software'>Tau</application>">
-   <!-- Produce a notation for the Tau software package.  -->
- <!ENTITY toolkit "toolkit">
-   <!-- Produce a notation for the name of the Pooma software.  -->
- <!ENTITY toolkitcap "Toolkit">
-   <!-- Produce a capitalized version of &toolkit;.  -->
- 
- <!-- Type Entity Declarations -->
- 
- <!ENTITY array "<type>Array</type>">
-   <!-- The "Array" type. -->
- <!ENTITY benchmark "<type>Benchmark</type>">
-   <!-- The "Benchmark" type. -->
- <!ENTITY bool "<type>bool</type>">
-   <!-- The C++ boolean type. -->
- <!ENTITY brick "<type>Brick</type>">
-   <!-- The "Brick" engine type. -->
- <!ENTITY char "<type>char</type>">
-   <!-- The C char type. -->
- <!ENTITY complex "<type>complex</type>">
-   <!-- The C++ "complex" type. -->
- <!ENTITY compressiblebrick "<type>CompressibleBrick</type>">
-   <!-- The "CompressibleBrick" engine type. -->
- <!ENTITY distributedtag "<type>DistributedTag</type>">
-   <!-- The DistributedTag Layout type. -->
- <!ENTITY domain "<type>Domain</type>">
-   <!-- The "Domain" type. -->
- <!ENTITY domaintemplate "DT">
-   <!-- A domain template parameter. -->
- <!ENTITY double "<type>double</type>">
-   <!-- The C "double" type. -->
- <!ENTITY dynamic "<type>Dynamic</type>">
-   <!-- The "Dynamic" Engine type. -->
- <!ENTITY dynamicarray "<type>DynamicArray</type>">
-   <!-- The "DynamicArray" type. -->
- <!ENTITY engine "<type>Engine</type>">
-   <!-- The "Engine" type. -->
- <!ENTITY false "<literal>false</literal>">
-   <!-- The false Boolean value. -->
-   <!-- Modify its tag to the appropriate one. -->
- <!ENTITY field "<type>Field</type>">
-   <!-- The "Field" type. -->
- <!ENTITY float "<type>float</type>">
-   <!-- The C "float" type. -->
- <!ENTITY grid "<type>Grid</type>">
-   <!-- The "Grid" domain type. -->
- <!ENTITY gridone "<type>Grid&lt;1&gt;</type>">
-   <!-- The "Grid<1>" one-dimensional domain type. -->
- <!ENTITY indirectionlist "<type>IndirectionList</type>">
-   <!-- The "IndirectionList" (domain-helper) type. -->
- <!ENTITY indirectionlistint "<type>IndirectionList&lt;int&gt;</type>">
-   <!-- The "IndirectionList<int>" (domain-helper) type. -->
- <!ENTITY inform "<type>Inform</type>">
-   <!-- The "Inform" output type. -->
- <!ENTITY int "<type>int</type>">
-   <!-- The C "int" type. -->
- <!ENTITY interval "<type>Interval</type>">
-   <!-- The "Interval" type. -->
- <!ENTITY intervalone "<type>Interval&lt;1&gt;</type>">
-   <!-- The "Interval<1>" one-dimensional domain type. -->
- <!ENTITY layout "<type>Layout</type>">
-   <!-- The "Layout" type without template parameters. -->
- <!ENTITY leaffunctor "<type>LeafFunctor</type>">
-   <!-- The "LeafFunctor" type. -->
- <!ENTITY loc "<type>Loc</type>">
-   <!-- The "Loc" domain type. -->
- <!ENTITY locone "<type>Loc&lt;1&gt;</type>">
-   <!-- The "Loc<1>" one-dimensional domain type. -->
- <!ENTITY matrix "<type>TinyMatrix</type>">
-   <!-- The Pooma matrix type. -->
- <!ENTITY multipatch "<type>MultiPatch</type>">
-   <!-- The "MultiPatch" engine without template parameters. -->
- <!ENTITY options "<type>Options</type>">
-   <!-- The &pooma; options type. -->
- <!ENTITY range "<type>Range</type>">
-   <!-- The "Range" domain type. -->
- <!ENTITY rangeone "<type>Range&lt;1&gt;</type>">
-   <!-- The "Range<1>" one-dimensional domain type. -->
- <!ENTITY remote "<type>Remote</type>">
-   <!-- The "Remote" engine type. -->
- <!ENTITY replicatedtag "<type>ReplicatedTag</type>">
-   <!-- The ReplicatedTag Layout type. -->
- <!ENTITY stencil "<type>Stencil</type>">
-   <!-- The "Stencil" type. -->
- <!ENTITY tensor "<type>Tensor</type>">
-   <!-- The Pooma tensor type. -->
- <!ENTITY true "<literal>true</literal>">
-   <!-- The true Boolean value. -->
-   <!-- Modify its tag to the appropriate one. -->
- <!ENTITY vector "<type>Vector</type>">
-   <!-- The "Vector" type. -->
- 
- <!-- Mathematical Entity Declarations -->
- 
- <!ENTITY container "C">
-   <!-- an abbreviation for a canonical container -->
- <!ENTITY containerdomain "D">
-   <!-- an abbreviation for a canonical container domain -->
- <!ENTITY n "n">
-   <!-- the size of one dimension of an array -->
- <!ENTITY space "&real;<superscript>d</superscript>">
-   <!-- a notation for multidimensional space -->
- 
- <!-- System and Operating System Entity Declarations -->
- <!ENTITY gcc "<application>g++</application>">
-   <!-- The GNU Compiler Collection C++ compiler. -->
- <!ENTITY kcc "<application>KCC</application>">
-   <!-- The KAI C++ compiler. -->
- <!ENTITY linux "<application>Linux</application>">
-   <!-- The Linux operating system. -->
- 
- <!-- &pooma; URLs and Files -->
- 
- <!ENTITY poomadownloadpage '<ulink url="http://pooma.codesourcery.com/pooma/download">http://pooma.codesourcery.com/pooma/download</ulink>'>
-   <!-- The WWW page supporting downloading the &pooma; source code. -->
-   <!-- UPDATE this URL. -->
- <!ENTITY poomahomepage '<ulink url="http://www.codesourcery.com/pooma/pooma/">http://www.codesourcery.com/pooma/pooma/</ulink>'>
-   <!-- The canonical Pooma home page. -->
-   <!-- UPDATE this filename. -->
- <!ENTITY poomasource "pooma-2.3.0">
-   <!-- The Pooma source code directory. -->
-   <!-- UPDATE this filename. -->
- <!ENTITY poomasourcefile "&poomasource;.tgz">
-   <!-- The Pooma source code archive. -->
- <!ENTITY poomaexampledirectory "examples/Manual">
-   <!-- The directory holding this manual's example codes. -->
- 
- <!-- Spelling and Formatting Decisions -->
- <!ENTITY author "author">
-   <!-- A word describing an author xor authors. -->
- <!ENTITY naive "na&iuml;ve">
-   <!-- The word "na\"{\i}ve." -->
- <!ENTITY naivecap "Na&iuml;ve">
-   <!-- The word "Na\"{\i}ve," i.e., the capitalized &naive;. -->
-   <!-- The Pooma source code directory. -->
-   <!-- spelling: dependence, not dependency -->
-   <!-- spelling: element-wise, not elementwise -->
-   <!-- phrase: function object, not functor -->
-   <!-- spelling: interprocessor, not inter-processor -->
-   <!-- spelling: multidimensional, not multi-dimensional -->
-   <!-- spelling: multiprocessor, not multi-processor -->
-   <!-- spelling: nonzero, not non-zero -->
-   <!-- formatting: for sets, no spaces between brackets and entries but spaced between entries -->
- 
- <!-- External Chapters -->
- <!ENTITY arrays-chapter SYSTEM "arrays.xml">
-   <!-- Pooma Arrays chapter -->
- <!ENTITY bibliography-chapter SYSTEM "bibliography.xml">
-   <!-- bibliography -->
- <!ENTITY concepts-chapter SYSTEM "concepts.xml">
-   <!-- Pooma concepts chapter -->
- <!ENTITY data-parallel-chapter SYSTEM "data-parallel.xml">
-   <!-- data-parallel expressions chapter -->
- <!ENTITY glossary-chapter SYSTEM "glossary.xml">
-   <!-- glossary -->
- <!ENTITY introductory-chapter SYSTEM "introduction.xml">
-   <!-- Doof2d introductory chapter -->
- <!ENTITY template-chapter SYSTEM "template.xml">
-   <!-- Doof2d template programming chapter -->
- <!ENTITY tutorial-chapter SYSTEM "tutorial.xml">
-   <!-- Doof2d tutorial programs chapter -->
- 
- <!-- External File Entities -->
- <!-- Doof2d Programs -->
- <!ENTITY doof2d-c-element SYSTEM "./programs/examples/Doof2d/Doof2d-C-element-annotated.cpp">
-   <!-- hand-coded Doof2d implementation -->
- <!ENTITY doof2d-array-element SYSTEM "./programs/examples/Doof2d/Doof2d-Array-element-annotated.cpp">
-   <!-- Array element-wise Doof2d implementation -->
- <!ENTITY doof2d-array-parallel SYSTEM "./programs/examples/Doof2d/Doof2d-Array-parallel-annotated.cpp">
-   <!-- Array data-parallel Doof2d implementation -->
- <!ENTITY doof2d-array-stencil SYSTEM "./programs/examples/Doof2d/Doof2d-Array-stencil-annotated.cpp">
-   <!-- Array stencil Doof2d implementation -->
- <!ENTITY doof2d-array-distributed SYSTEM "./programs/examples/Doof2d/Doof2d-Array-distributed-annotated.cpp">
-   <!-- distributed Array stencil Doof2d implementation -->
- <!ENTITY doof2d-field-parallel SYSTEM "./programs/examples/Doof2d/Doof2d-Field-parallel-annotated.cpp">
-   <!-- Field data-parallel Doof2d implementation -->
- <!ENTITY doof2d-field-distributed SYSTEM "./programs/examples/Doof2d/Doof2d-Field-distributed-annotated.cpp">
-   <!-- Field data-parallel distributed Doof2d implementation -->
- 
- <!-- Sequential Programs -->
- <!ENTITY array-copy SYSTEM "./programs/examples/Sequential/array-copy-annotated.cpp">
-   <!-- Illustrate Array reference semantics. -->
- <!ENTITY array-size SYSTEM "./programs/examples/Sequential/array-size-annotated.cpp">
-   <!-- Illustrate Array member functions. -->
- <!ENTITY dynamicarray-example SYSTEM "./programs/examples/Sequential/dynamicarray-annotated.cpp">
-   <!-- Illustrate using DynamicArray class. -->
- <!ENTITY initialize-finalize SYSTEM "./programs/examples/Sequential/initialize-finalize-annotated.cpp">
-   <!-- Illustrate initialize() and finalize(). -->
- 
- <!-- Template Programs -->
- <!ENTITY pairs-untemplated SYSTEM "./programs/examples/Templates/pairs-untemplated-annotated.cpp">
-   <!-- Illustrate defining classes with pairs of values of the same type. -->
- <!ENTITY pairs-templated SYSTEM "./programs/examples/Templates/pairs-templated-annotated.cpp">
-   <!-- Illustrate defining a template class with pairs of values of the same type. -->
- ]>
- 
- <book>
-  <bookinfo>
-   <title>&pooma;</title>
-   <subtitle>A &cc; &toolkitcap; for High-Performance Parallel Scientific Computing</subtitle>
-   <author><firstname>Jeffrey</firstname><othername
-   role='mi'>D.</othername><surname>Oldham</surname>
-    <affiliation>
-     <orgname>CodeSourcery, LLC</orgname>
-    </affiliation>
-   </author>
-   <copyright><year>2002</year><holder>CodeSourcery, LLC (<ulink url="http://www.codesourcery.com/"></ulink>)</holder></copyright>
-   <contractsponsor>Los Alamos National Laboratory<ulink url="http://www.lanl.gov/"></ulink></contractsponsor>
-   <legalnotice>
-    <!-- FIXME: What is the correct legal notice? -->
-    <para>All rights reserved.  This document may not be redistributed in any form without the express permission of the author.</para>
-   </legalnotice>
-   <revhistory>
-    <revision>
-     <revnumber>1.00</revnumber>
-     <date>2002 Jan 23</date>
-     <authorinitials>jdo</authorinitials>
-     <revremark>First publication.</revremark>
-    </revision>
-   </revhistory>
-  </bookinfo>
- 
-  <!-- FINISH: May we have a short table of contents followed by a -->
-  <!-- complete table of contents? -->
- 
- <![%unfinished;[
-  <preface id="preface">
-   <title>Preface</title>
- 
-   <para>FINISH: Describe the target audience for &pooma; programs and
-   for this manual: &cc; programmers writing scientific code, possibly
-   parallel execution.</para>
- 
-   <para>Assume familiarity with &cc; template programming and the
-   standard template library.  FIXME: Remove this index
-   entry.<indexterm id="oldham"><primary>Oldham,
-   Jeffrey&nbsp;D.</primary></indexterm></para>
- 
-   <section id="preface-notation">
-    <title>Notation</title>
- 
-    <para>UNFINISHED</para>
-   </section>
- 
- 
-   <section id="preface-reading_book:">
-    <title>How to Read This &bookcap;</title>
- 
-    <para>FINISH: Write this section in a style similar to Lamport's
-    LaTeX section 1.2.  FINISH: Fix the book title and the section
-    number.</para>
-   </section>
- 
- 
-   <section id="preface-downloading">
-    <title>Obtaining &pooma; and Sample Programs</title>
- 
-    <para>Available for free from what WWW site?  Include what portions
-    of <filename class="libraryfile">LICENSE</filename>?  Be sure to
-    include CVS instructions as well.</para>
- 
-    <para>Which additional packages are necessary and when?</para>
- 
-   </section>
- 
- 
-   <section id="preface-using_modifying">
-    <title>Using and Modifying &pooma;</title>
- 
-    <para>&pooma; is available under open source license.  It can be
-    used and modified by anyone, anywhere.  Can it be sold?  Include
-    <filename class="libraryfile">LICENSE</filename>.</para>
- 
-    <para>QUESTION: How do developers contribute code?</para>
- 
-   </section>
- 
- 
-   <section id="preface-acknowledgements">
-    <title>Acknowledgements</title>
- ]]>  <!-- end unfinished -->
- 
- <![%temporary;[
-   <preface id="acknowledgements">
-    <title>Acknowledgements</title>
- ]]>  <!-- end temporary -->
- 
-    <para>This &book; would not have been completed without the help
-    and encouragement of a lot of people and organizations.  Los Alamos
-    National Laboratory funded the writing of this manual and the
-    development of the &poomatoolkit;.  John Reynders conceived,
-    advocated, and headed &pooma; development in its early days, and
-    Scott Haney continued the leadership.  Susan Atlas, Subhankar
-    Banerjee, Timothy Cleland, Julian Cummings, James Crotinger, David
-    Forslund, Salman Habib, Scott Haney, Paul Hinker, William Humphrey,
-    Steve Karmesin, Graham Mark, Jeffrey&nbsp;D. Oldham, Ji Qiang, John
-    Reynders, Robert Ryne, Stephen Smith, M.&nbsp;Srikant, Marydell
-    Tholburn, and Timothy Williams all helped develop &pooma;. Rod
-    Oldehoeft and Jeff Brown of Los Alamos National Laboratory
-    supported CodeSourcery's and Proximation's work, including the
-    development of this manual.  John Hall, Don Marshall, Jean
-    Marshall, and the rest of the BLANCA team at Los Alamos worked
-    closely with the developers and provided valuable suggestions for
-    improvements.</para>
- 
-    <para>I am grateful to James Crotinger, Mark Mitchell, and Stephen
-    Smith who answered my many questions during the writing of this
-    &book;.</para>
- 
-   <!-- We cheat and abuse an epigraph here. -->
-   <epigraph>
-    <attribution>Jeffrey&nbsp;D. Oldham, 2002 January</attribution>
-    <para></para>
-   </epigraph>
- 
- <![%temporary;[
-  </preface>
- ]]>  <!-- end temporary -->
- 
- <![%unfinished;[
-   </section>
- 
-  </preface>
- ]]>  <!-- end unfinished -->
- 
- 
- <![%unfinished;[
-  <part id="programming">
-   <title>Programming with &pooma;</title>
- 
- <!-- FIXME: Add a partintro to the part above? -->
- ]]>  <!-- end unfinished -->
- 
-   &introductory-chapter; 
- 
-   &template-chapter;
- 
-   &tutorial-chapter;
- 
-   &concepts-chapter;
- 
-   &arrays-chapter;
- 
- 
-   <chapter id="engines">
-    <title>Engines</title>
- 
-    <para>Each container has one or more &engine;s to store or compute
-    its values.  As we mentioned in <xref
-    linkend="arrays-arrays_declarations"></xref>, a container's role is
-    high-level, supporting access to groups of values, and an engine's
-    role is low-level, storing or computing values and supporting
-    access to individual values.  This separation permits optimizing
-    space and computation requirements.</para>
- 
-    <para>We begin this chapter by introducing the concept of an engine
-    and how it is used.  Then, we describe the various &engine;s that
-    &pooma; provides, separating them into engines that store values
-    and engines that compute values.
- <![%unfinished;[
-    Finally, we describe how the
-    &engine;s are implemented, using tags to differentiate engines and
-    reference-counted pointers to their underlying data.
- ]]>  <!-- end unfinished -->
-    </para>
- 
- 
-    <section id="engines-concept">
-     <title>The Concept</title>
- 
-     <para>An engine performs the low-level value storage, computation,
-     and element-wise access for a container.  An engine has a domain
-     and accessor functions returning individual elements.  The &pooma;
-     &engine; class and its specializations implement the engine
-     concept.  Given an index within the domain, an &engine;'s
-     <literal>operator()</literal> function returns the
-     associated value, which can be used or changed.  Its
-     <literal>read</literal> member function returns the same
-     value but permitting only use, not modification.  The acceptable
-     indices are determined by each &engine;.  Most accept indices
-     specified using &int; and <type>Loc&lt;&dim;&gt;</type>
-     parameters, but an &engine; might accept string or floating-point
-     parameters.  An &engine;'s layout specifies maps its domain
-     indices to the processors and memory used to store and compute the
-     associated values.</para>
- 
-     <para>Since an engine's main role is to return the individual
-     values associated with specific domain indices, any implementation
-     performing this task is an engine.  &pooma; &engine;s fall into
-     three categories:
-     <itemizedlist>
-      <listitem>
-       <para>&engine;s that store values.</para>
-      </listitem>
-      <listitem>
-       <para>&engine;s that compute their values using other &engine;s'
-       values.</para>
-      </listitem>
-      <listitem>
-       <para>&engine;s that support distributed computation.</para>
-      </listitem>
-     </itemizedlist>
-     For example, the &brick; &engine; explicitly stores all its
-     values, while the &compressiblebrick; engine adds the feature of
-     reducing its storage requirements if all these values are
-     identical.  A <type>UserFunction</type> &engine; yields values by
-     applying a <glossterm linkend="glossary-function_object">function
-     object</glossterm> to each value returned by another &engine;.  A
-     <type>CompFwd</type> &engine; projects components from another
-     &engine;.  For example, <type>CompFwd</type> will use the second
-     components of each &vector; in an &array; to form its own &array;.
-     Since each container has at least one &engine;, we can also
-     describe the latter category as containers that compute their
-     values using other containers' values.  A &multipatch; &engine;
-     distributes its domain among various processors and memory spaces,
-     each responsible for computing values associated with a portion,
-     or patch, of the domain.  The &remote; &engine; also supports
-     distributed computation.</para>
- 
-     <para>Just as multiple containers can use the same engine,
-     multiple &engine;s can use the same underlying data.  As we
-     mentioned in <xref linkend="arrays-arrays_use"></xref>, &engine;s
-     have <glossterm linkend="glossary-reference_semantics">reference
-     semantics</glossterm>.  A copy of an &engine; has a
-     reference-counted pointer to the &engine;'s data (if any exists).
-     Thus, copying an &engine; or a container requires little execution
-     time.  If an &engine; has the same data as another &engine; but it
-     needs its own data to modify, the
-     <literal>makeOwnCopy</literal> member function creates such
-     a copy.</para>
- 
-     <para>&engine;s are rarely explicitly declared.  Instead a
-     container is declared using an &engine; tag, and the container
-     creates the specified &engine; to deal with its values.  For
-     example, a &brick; &engine; is explicitly declared as
-     <type>Engine&lt;&dim;,T,Brick&gt;</type>, but they are more
-     frequently created by containers, e.g.,
-     <type>Array&lt;&dim;,T,Brick&gt;</type>.  An &engine;'s first two
-     template parameters specify the domain's dimensionality and the
-     value type, as described in <xref
-     linkend="arrays-arrays_declarations"></xref>.  Unlike container
-     declarations, the third template parameter, the &engine; tag,
-     specifies which &engine; specialization to use.  For example, the
-     &brick; &engine; tag indicates a &brick; &engine; should be used.
-     Some &engine;s, such as <type>CompFwd</type>, are rarely declared
-     even using &engine; tags.  Instead the &array;'s
-     <literal>comp</literal> and
-     <literal>readComp</literal> member functions return views of
-     containers using <type>CompFwd</type> &engine;s.</para>
-    </section>
- 
- 
-    <section id="engines-types">
-     <title>Types of &engine;s</title>
- 
-     <para>In this section, we describe the different types of
-     &engine;s and illustrate their creation, when appropriate.  First,
-     we describe &engine;s that explicitly store values and then
-     &engine;s that compute values.  See <xref
-     linkend="engines-types-table"></xref>.</para>
- 
-     <table frame="none" colsep="0" rowsep="0" tocentry="1"
-            orient="port" pgwide="0" id="engines-types-table">
-      <title>Types of &engine;s</title>
-      
-      <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>&engine; tag</entry>
- 	 <entry>description</entry>
- 	</row>
-        </thead>
-        <tbody valign="top">
- 	<row rowsep="1">
- 	 <entry>&engine;s That Store</entry>
- 	</row>
- 	<row>
- 	 <entry>&brick;</entry>
- 	 <entry>explicitly stores all values; similar to &c; arrays.</entry>
- 	</row>
- 	<row>
- 	 <entry>&compressiblebrick;</entry>
- 	 <entry>stores all values, reducing storage requirements when
- 	 all values are identical.</entry>
- 	</row>
- 	<row>
- 	 <entry>&dynamic;</entry>
- 	 <entry>is a one-dimensional &brick; with dynamically
-          resizable domain.  This should be used with &dynamicarray;,
- 	 not &array;.</entry>
- 	</row>
- 	<row rowsep="1">
- 	 <entry>&engine;s That Compute</entry>
- 	</row>
- 	<row>
- 	 <entry><type>CompFwd</type></entry>
- 	 <entry>extracts specified components of an engine's vectors,
- 	 tensors, arrays, etc.; usually created using the
- 	 <literal>comp</literal> container function.</entry>
- 	</row>
- 	<row>
- 	 <entry><type>ConstantFunction</type></entry>
- 	 <entry>makes a scalar value behave like a container.</entry>
- 	</row>
- 	<row>
- 	 <entry><type>IndexFunction&lt;FunctionObject&gt;</type></entry>
- 	 <entry>makes the <type>FunctionObject</type>'s function of
- 	 indices behave like a container.</entry>
- 	</row>
- 	<row>
- 	 <entry><type>ExpressionTag&lt;Expr&gt;</type></entry>
- 	 <entry>evaluates an expression tree; usually created by
- 	 data-parallel expressions.</entry>
- 	</row>
- 	<row>
- 	 <entry><type>Stencil&lt;Function, Expression&gt;</type></entry>
-          <entry>applies a stencil computation (<type>Function</type>)
- 	 to its input (<type>Expression</type>) which is usually a
- 	 container; usually created by applying a <type>Stencil</type>
- 	 object to a container.  A stencil computation can use
- 	 multiple neighboring input values.</entry>
- 	</row>
- 	<row>
- 	 <entry><type>UserFunctionEngine&lt;Function,
- 	 Expression&gt;</type></entry>
- 	 <entry>applies the given function (or <glossterm
- 	 linkend="glossary-function_object">function
- 	 object</glossterm>) to its input (<type>Expression</type>)
- 	 which is usually a container; usually created by applying a
- 	 <type>UserFunction</type> object to a container.  The
- 	 function implements a one-to-one mapping from its input to
- 	 values.</entry>
- 	</row>
- 	<row rowsep="1">
- 	 <entry>&engine;s for Distributed Computation</entry>
- 	</row>
- 	<row>
- 	 <entry><type>MultiPatch&lt;LayoutTag,EngineTag&gt;</type></entry>
- 	 <entry>runs a separate <type>EngineTag</type> &engine; on
- 	 each context (patch) specified by the given layout.  This is
- 	 the usual &engine; for distributed computation.</entry>
- 	</row>
- 	<row>
- 	 <entry><type>Remote&lt;EngineTag&gt;</type></entry>
- 	 <entry>runs the &engine; specified by <type>EngineTag</type>
- 	 on a specified context.</entry>
- 	</row>
- 	<row>
- 	 <entry><type>Remote&lt;Dynamic&gt;</type></entry>
- 	<entry>runs a <type>Dynamic</type> one-dimensional, resizable
- 	&engine; on a specified context.  This is a specialization of
- 	<type>Remote</type>.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
- <!-- FIXME: Place in firstterm. -->
-     <para><glossterm linkend="glossary-brick">&brick;
-     &engine;s</glossterm> explicitly store values just like &c;
-     arrays.  &compressiblebrick; &engine;s optimize their storage
-     requirements when all values are identical.  Many &array;s use one
-     of these two &engine;s.  &brick;s are the default &engine;s for
-     &array; and &field; containers because they explicitly store each
-     value.  This explicit storage can require a large amount of space,
-     particularly if all these values are the same.  If all a
-     compressible brick &engine;'s values are identical, the &engine;
-     stores that one value rather than many, many copies of the same
-     value.  These engines can both save time as well as space.
-     Initializing a compressible engine requires setting only one
-     value, not every value.  Using less storage space may also permit
-     more useful values to be stored in cache, improving cache
-     performance.  Reading a value in a compressed &engine; using the
-     <literal>read</literal> member function is as fast as
-     reading a value in a &brick; &engine;, but writing a value always
-     requires executing an additional <literal>if</literal>
-     conditional.  Thus, if an &engine; infrequently has multiple
-     different values during its life time, a &compressiblebrick;
-     &engine; may be faster than a &brick; &engine;.  If an &engine; is
-     created and its values are mostly read, not written, a
-     &compressiblebrick; &engine; may also be faster.  Otherwise, a
-     &brick; &engine; may be preferable.  Timing the same program using
-     the two different &engine; types will reveal which is faster for a
-     particular situation.  In distributed computing, many &engine;s
-     may have few nonzero values so &compressiblebrick; &engine;s may
-     be preferable.  For distributed computing, a container's domain is
-     partitioned into regions each computed by a separate processor and
-     &engine;.  If the computation is concentrated in sections of the
-     domain, many &engine;s may have few, if any, nonzero values.
-     Thus, &compressiblebrick; &engine;s may be preferable for
-     distributed computing.</para>
- 
-     <para>Both &brick; and &compressiblebrick; &engine;s have
-     <literal>read</literal> and
-     <literal>operator()</literal> member functions taking &int;
-     and &loc; parameters.  The parameters should match the &array;'s
-     dimensionality.  For example, if &array; <varname>a</varname> has
-     dimensionality&nbsp;3, <function>a.read(int, int, int)</function>
-     and <function>a(int, int, int)</function> should be used.  The
-     former returns a value that cannot be modified, while the latter
-     can be changed.  Using the <literal>read</literal> member
-     function can lead to faster code.  Alternatively, an index can be
-     specified using a &loc;.  For example,
-     <literal>a.read(Loc&lt;3&gt;(1,-2,5))</literal> and
-     <literal>a(Loc&lt;3&gt;(1,-2,5))</literal> are equivalent to
-     <literal>a.read(1,-2,5))</literal> and
-     <literal>a(1,-2,5)</literal>.</para>
- 
-     <para>The &dynamic; &engine; supports changing domain sizes while
-     a program is executing.  It is basically a one-dimensional
-     &brick;, explicitly storing values, but permitting the number and
-     order of stored values to change.  Thus, it supports the same
-     interface as &brick; except that all member functions are
-     restricted to their one-dimensional versions.  For example,
-     <literal>read</literal> and
-     <literal>operator()</literal> take <type>Loc&lt;1&gt;</type>
-     or one &int; parameter.  In addition, the one-dimensional domain
-     can be dynamically resized using <literal>create</literal>
-     and <literal>destroy</literal>.
- <![%unfinished;[
- ; see .
- 
- HERE Dynamic. How does one change the domain size?  What is the model?
- ]]>  <!-- end unfinished -->
- </para>
- 
- <![%unfinished;[
- <!-- HERE: Array cannot forward domain size changes to underlying Dynamic Engine. -->
- 
-     <para>Types of &engine;s:
-    Brick - explicitly store values
-    CompressibleBrick - explicitly store values but store only one if all the same
-    ConstantFunction - convert scalar into an array
-    DynamicEngine - contiguous, local, resizable, 1D block
-    ExpressionEngine - evaluate PETE expression
-    CompFwd - array formed by extracted components from array
-      ForwardEngine
-      tut-02.html: use .comp() or .readComp()
-    IndexFunctionEngine - convert function of indices into an array
-    IndirectionEngine - incomplete
-    MultiPatch - ?How do I describe this?
-    RemoteDynamic - run a Dynamic engine on a specified context
-    Remote - permit computations on specified context
-      should discuss with MultiPatch
-    Stencil - apply a stencil to an array, returning a new Array with the results
-    UserFunction - Array = apply function to an Array
- </para>
- 
-    <para>How do I organize these engines into understandable
- 	     categories?
- 
-    storage
-     Brick
-     CompressibleBrick
-     Dynamic - resizable 1D block
-       RemoteDynamic
-     MultiPatch - ?WHAT?
-       Remote
- 
-    computation
-     CompFwd: project(array)->array
-       .comp() and .readComp()
-       view, not a copy
-     ConstantFunction: scalar(array)->array
-       explicitly use
-     IndexFunctionEngine: function(indices)->array
-       explicitly use
-     ExpressionEngine: expression(array)->array
-       created by data-parallel expression
-     Stencil: stencil(array)->array
-       implicitly used
-       explicitly use Stencil<...> type
-     UserFunction: function(array)->array
-       explicitly use
- </para>
- 
-     <para>
-       Element_t read(Loc&lt;&dim;&gt;)
-       ElementRef_t operator()(Loc&lt;&dim;&gt;)
-       Element_t read(int+)
-       ElementRef_t operator()(int+)
-     </para>
- 
-     <para>Explain the concept of an engine.  How does an engine
-     interact with a container or an &array;?  Explain the different
-     types of engines likely to be used by &pooma; programmers and how
-     to declare containers using them.  Should I list the other engines
-     that are automatically created?</para>
- ]]>  <!-- end unfinished -->
- 
-    </section>
-   </chapter>
- 
- 
-   &data-parallel-chapter;
- 
- 
-   <chapter id="views">
-    <title>Container Views</title>
- 
-    <indexterm zone="views">
-     <primary>container</primary>
-     <secondary>view</secondary>
-    </indexterm>
-    <indexterm>
-     <primary>view of a container</primary>
-     <see>container, view.</see>
-    </indexterm>
- 
- <![%temporary;[
- 
-    <para>A <glossterm linkend="glossary-view"><firstterm>view of a
-    container</firstterm></glossterm> is a container accessing a subset
-    of &container;'s domain and values.  The subset can include all of
-    the container's domain.  A <quote>view</quote> is so named because
-    it is a different way to access, or view, another container's
-    values.  Both the container and its view share the same underlying
-    engine so changing values in one also changes them in the
-    other.</para>
- 
-    <para>A view is created by following a container's name by
-    parentheses containing a domain.  For example, consider this code
-    extracted from <xref
-    linkend="tutorial-array_parallel-doof2d"></xref> in <xref
-    linkend="tutorial-array_data_parallel"></xref>.
- <programlisting>
- Interval<1> N(0, n-1);
- Interval<2> vertDomain(N, N);
- Interval<1> I(1,n-2);
- Interval<1> J(1,n-2);
- Array<2, double, Brick> a(vertDomain);
- Array<2, double, Brick> b(vertDomain);
- a(I,J) = (1.0/9.0) *
-   (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
-    b(I  ,J+1) + b(I  ,J  ) + b(I  ,J-1) +
-    b(I-1,J+1) + b(I-1,J  ) + b(I-1,J-1));
- </programlisting>  The last statement creates ten views.  For example,
- 
-    <literal>a(I,J)</literal> creates a view of
-    <varname>a</varname> using the smaller domain specified by
-    <varname>I</varname> and <varname>J</varname>.  This omits the
-    outermost rows of columns of&nbsp;<varname>a</varname>.  The views
-    of <varname>b</varname> illustrate the use of views in
-    data-parallel statements.  <literal>b(I-1,J-1)</literal> has a
-    subset shifted up one row and left one column compared with
-    <literal>b(I,J)</literal>.</para>
- ]]>  <!-- end temporary -->
- <![%unfinished;[
-    <para>Be sure to list the various arithmetic operations on domains
-    that can be used.  This was deferred from the &array; and domain
-    chapter.  Explain &array;'s <function>comp</function> function.</para>
- 
- <!-- FIXME: Finish this chapter. -->
- ]]>  <!-- end unfinished -->
-   </chapter>
- 
- 
- <![%unfinished;[
-   <chapter id="sequential">
-    <title>Writing Sequential Programs</title>
- 
-    <para>FIXME: Explain the chapter's purpose.</para>
- 
-    <para>FIXME: Explain the format of each section.</para>
- 
-    <para>FIXME: Explain the order of the sections.</para>
- 
-    <para>Proposed order.  Basically follow the order in the proposed
-    reference section.
-     <orderedlist>
-      <listitem><para>starting, stopping</para></listitem>
-      <listitem><para>&array;</para></listitem>
-      <listitem><para>&dynamicarray;</para></listitem>
-      <listitem><para>&field;</para></listitem>
-      <listitem><para>&vector;</para></listitem>
-      <listitem><para>&matrix;</para></listitem>
-      <listitem><para>&tensor;</para></listitem>
-      <listitem><para>&engine;</para></listitem>
-      <listitem><para>domain</para></listitem>
-      <listitem><para>correctness, e.g., <function>PAssert</function></para></listitem>
-      <listitem><para>&pooma; command-line options</para></listitem>
-     </orderedlist>
-     Include views of containers in the appropriate sections.</para>
- 
-    <para><emphasis>&c;: A Reference Manual</emphasis> uses this
-    structure for &c; libraries:
-     <orderedlist>
-      <listitem>
-       <para>function declarations, separated by rules from rest of text</para>
-      </listitem>
-      <listitem>
-       <para>text explanation</para>
-      </listitem>
-      <listitem>
-       <para>table of structure members if appropriate</para>
-      </listitem>
-      <listitem>
-       <para>example</para>
-      </listitem>
-     </orderedlist>
-    </para>
- 
-    <para><emphasis>STL Tutorial and Reference Guide</emphasis>, second
-    edition, uses this structure for STL functions:
-     <orderedlist>
-      <listitem>
-       <para>text description with declaration mixed in</para>
-      </listitem>
-      <listitem>
-       <para>example program mixed into text.  It is an entire program,
-       not a program fragment.</para>
-      </listitem>
-     </orderedlist>
-    </para>
- 
-    <para>A tutorial chapter for containers has
-     <orderedlist>
-      <listitem>
-       <para>explanation of template types</para>
-      </listitem>
-      <listitem>
-       <para>bulleted list of container types</para>
-      </listitem>
-      <listitem>
-       <para>example constructors</para>
-      </listitem>
-      <listitem>
-       <para>example programs</para>
-      </listitem>
-      <listitem>
-       <para>member and related functions with example programs</para>
-      </listitem>
-      <listitem>
-       <para>list of accessors and relation functions</para>
-      </listitem>
-     </orderedlist>
-    </para>
- 
-    <para>The reference chapter for containers has
-     <orderedlist>
-      <listitem>
-       <para>a section listing common members and types for all containers</para>
-      </listitem>
-      <listitem>
-       <para>a section listing common member functions for all containers</para>
-      </listitem>
-      <listitem>
-       <para>requirements for various container specialties</para>
-      </listitem>
-     </orderedlist>
-     The section describing <type>vector</type>s contains
-     <orderedlist>
-      <listitem>
-       <para>files (header files)</para>
-      </listitem>
-      <listitem>
-       <para>class declaration</para>
-      </listitem>
-      <listitem>
-       <para>description</para>
-      </listitem>
-      <listitem>
-       <para>type definitions</para>
-      </listitem>
-      <listitem>
-       <para>constructors, destructors, and related functions</para>
-      </listitem>
-      <listitem>
-       <para>comparison operators</para>
-      </listitem>
-      <listitem>
-       <para>element access member functions</para>
-      </listitem>
-      <listitem>
-       <para>insert and erase member functions</para>
-      </listitem>
-      <listitem>
-       <para>notes</para>
-      </listitem>
-     </orderedlist>
-    </para>
- 
-    <para>Josuttis's <emphasis>The &cc; Standard Library: A Tutorial
-    and Reference</emphasis> uses this structure for its STL container
-    chapter:
-     <orderedlist>
-      <listitem>
-       <para>short introduction</para>
-      </listitem>
-      <listitem>
-       <para>common container abilities</para>
-      </listitem>
-      <listitem>
-       <para>common container operations (with table)</para>
-      </listitem>
-      <listitem>
-       <para>vector abilities</para>
-      </listitem>
-      <listitem>
-       <para>vector operations:
-        <orderedlist>
- 	<listitem>
- 	 <para>create, copy, and destroy operations (mostly table)</para>
- 	</listitem>
- 	<listitem>
- 	 <para>non-modifying operations (mostly table)</para>
- 	</listitem>
- 	<listitem>
- 	 <para>assignments (mostly table)</para>
- 	</listitem>
- 	<listitem>
- 	 <para>element access (mostly table)</para>
- 	</listitem>
- 	<listitem>
- 	 <para>iterator functions (mostly table)</para>
- 	</listitem>
- 	<listitem>
- 	 <para>inserting and removing elements (mostly table)</para>
- 	</listitem>
-        </orderedlist>
-       </para>
-      </listitem>
-      <listitem>
-       <para>using vectors as ordinary arrays</para>
-      </listitem>
-      <listitem>
-       <para>exception handling</para>
-      </listitem>
-      <listitem>
-       <para>example program</para>
-      </listitem>
-     </orderedlist>
-    </para>
- 
-    <section id="sequential-begin_end">
-     <title>Beginning and Ending &pooma; Programs</title>
- 
-     <para>Every &pooma; program must begin with a call to
-     <function>initialize</function> and end with a call to
-     <function>finalize</function>.  These functions respectively
-     prepare and shut down &pooma;'s run-time structures.</para>
- 
-     <bridgehead id="sequential-begin_end-files" renderas="sect2">Files</bridgehead>
- 
-      <programlisting>
-      #include "Pooma/Pooma.h"  // or "Pooma/Arrays.h" or "Pooma/Fields.h" or ...
-      </programlisting>
- 
-     <bridgehead id="sequential-begin_end-declarations" renderas="sect2">Declarations</bridgehead>
- 
-      <funcsynopsis>
-       <funcprototype>
-        <funcdef>bool <function>Pooma::initialize</function></funcdef>
-        <paramdef>
-         <parameter class="function">int &amp;argc,</parameter>
-         <parameter class="function">char ** &amp;argv,</parameter>
-         <parameter class="function">bool initRTS = true,</parameter>
-         <parameter class="function">bool getCLArgsArch = true,</parameter>
-         <parameter class="function">bool initArch = true</parameter>
-        </paramdef>
-       </funcprototype>
- 
-       <funcprototype>
-        <funcdef>bool <function>Pooma::initialize</function></funcdef>
-        <paramdef>
-         <parameter class="function">Pooma::Options &amp;opts,</parameter>
-         <parameter class="function">bool initRTS = true,</parameter>
-         <parameter class="function">bool initArch = true</parameter>
-        </paramdef>
-       </funcprototype>
- 
-       <funcprototype>
-        <funcdef>bool <function>Pooma::finalize</function></funcdef>
-        <void></void>
-       </funcprototype>
- 
-       <funcprototype>
-        <funcdef>bool <function>Pooma::finalize</function></funcdef>
-        <paramdef>
-         <parameter class="function">bool quitRTS,</parameter>
-         <parameter class="function">bool quitArch</parameter>
-        </paramdef>
-       </funcprototype>
-      </funcsynopsis>
- 
-     <bridgehead id="sequential-begin_end-description" renderas="sect2">Description</bridgehead>
- 
-      <para>Before its use, the &poomatoolkit; must be initialized by a
-      call to <function>initialize</function>.  This usually occurs in
-      the <function>main</function> function.  The first form removes
-      and processes any &pooma;-specific arguments from the
-      command-line arguments <varname>argv</varname> and
-      <varname>argc</varname>.  <xref
-      linkend="sequential-options"></xref> describes these options.
-      The third, fourth, and fifth arguments all have a default value
-      of &true;.  If <parameter class="function">initRTS</parameter> is
-      &true;, the run-time system is initialized.  E.g., the contexts
-      are prepared for use.  If <parameter
-      class="function">getCLArgsArch</parameter> is &true,
-      architecture-specific command-line arguments are removed from
-      <varname>argv</varname> and <varname>argc</varname>.
-      Architecture-specific initialization occurs if <parameter
-      class="function">getCLArgsArch</parameter> is &true;.  An <link
-      linkend="glossary-architecture">architecture</link> is specified
-      by a hardware interface, e.g., processor type, but frequently is
-      also associated with an operating system or compiler.  For
-      example, Metrowerks for the Macintosh has an
-      architecture-specific initialization.  The function always
-      returns &true;.</para>
- 
-      <para><function>initialize</function>'s alternative form
-      assumes the &pooma;-specific and architecture-specific
-      command-line arguments have already been removed from
-      <varname>argv</varname> and <varname>argc</varname> and stored in
-      <parameter class="function">opts</parameter>.  Its other two
-      parameters have the same meaning, and the two functions'
-      semantics are otherwise the same.</para>
- 
-      <para>After its use, the &poomatoolkit; should be shut down using
-      a call to <function>finalize</function>.  This usually occurs in
-      the <function>main</function> function.  The former, and more
-      frequently used, form first prints any statistics and turns off
-      all default &pooma; streams.  Then it shuts down the run-time
-      system if it was previously initialized and then shuts down
-      architecture-specific objects if they were previously
-      initialized.  The latter form gives provides explicit control
-      whether the run-time system (<parameter
-      class="function">quitRTS</parameter>) and architecture-specific
-      objects (<parameter class="function">quitArch</parameter>) are
-      shut down.  Both functions always returns &true;.</para>
- 
-      <para>Including almost any &pooma; header file, rather than just
-      <filename class="headerfile">Pooma/Pooma.h</filename> suffices
-      since most other &pooma; header files include it.</para>
- 
-     <bridgehead id="sequential-begin_end-example" renderas="sect2">Example Program</bridgehead>
- 
-      <para>Since every &pooma; program must call
-      <function>initialize</function> and
-      <function>finalize</function>, the simplest &pooma; program also
-      must call them.  This program also illustrates their usual
-      use.</para>
- 
-      &initialize-finalize;
- 
-    </section><!-- end sequential-begin_end -->
- 
- 
-    <section id="sequential-global">
-     <title>Global Variables</title>
- 
-     <para>&pooma; makes a few global variables available after
-     initialization.</para>
- 
-     <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	   orient="port" pgwide="0">
-      <title>&pooma; Global Variables</title>
-      
-      <tgroup cols="2" align="left">
-       <thead>
-        <row>
- 	<entry>variable</entry>
- 	<entry>description</entry>
-        </row>
-       </thead>
-       <tbody valign="top">
-        <row>
- 	<entry>&inform; <varname>pinfo</varname></entry>
- 	<entry>output stream used to print informative messages to the
- 	user while the program executes.  The stream accepts a
- 	superset of standard output operations.</entry>
-        </row>
-        <row>
- 	<entry>&inform; <varname>pwarn</varname></entry>
- 	<entry>FIXME: output stream used to print informative messages to the
- 	user while the program executes.  The stream accepts a
- 	superset of standard output operations.</entry>
-        </row>
-       </tbody>
-      </tgroup>
-     </table>
- 
-    </section>
- 
-    <section id="sequential-options">
-     <title>&pooma; Command-line Options</title>
- 
-     <para>Every &pooma; program accepts a set of &pooma;-specific
-     command-line options to set values at run-time.</para>
- 
-     <para>QUESTION: Should I defer documenting &options; to the
-     reference manual, instead just listing commonly used options in
-     the previous section?
- 
- UNFINISHED</para>
- 
-     <section id="sequential-options-list">
-      <title>Options Summary</title>
- 
-      <variablelist>
-       <varlistentry>
-        <term><parameter class="option">&dashdash;pooma-info</parameter></term>
-        <listitem>
- 	<para>enable use of the <varname>pinfo</varname>, used to
- 	print informative messages to the user while the program
- 	executes.</para>
-        </listitem>
-       </varlistentry>
- <!-- UNFINISHED -->
-      </variablelist>
- 
-      <para>FIXME: Be sure to list default values.</para>
- <!-- FIXME: need to describe the pinfo, pwarn, and perr streams somewhere.  To do so requires describing informs.-->
- <!-- FIXME: Which streams are buffered and which are not? -->
- 
-     </section>
- 
-    </section><!-- end sequential-options -->
- 
-    <section>
-     <title>TMP: Place these somewhere.</title>
- 
-     <para>&pooma; can reorder computations to permit more efficient
-     computation.  When running a sequential program, reordering may
-     permit omission of unneeded computations.  For example, if only
-     values from a particular field are printed, only computations
-     involving the field and containers dependent on it need to occur.
-     When running a distributed program, reordering may permit
-     computation and communication among processors to overlap.
-     &pooma; automatically tracks dependences between data-parallel
-     expressions, ensuring correct ordering.  It does not track
-     statements accessing particular &array; and &field; values so the
-     programmer must precede these statements with calls to
-     <function>Pooma::blockAndEvaluate()</function>.  Each call forces
-     the executable to wait until all computation has completed.  Thus,
-     the desired values are known to be available.  In practice, some
-     calls to <function>Pooma::blockAndEvaluate</function> may not be
-     necessary, but omitting them requires knowledge of &pooma;'s
-     dependence computations, so the &author; recommends calling
-     <function>Pooma::blockAndEvaluate</function> before each access to
-     a particular value in an &array; or &field;.  Omitting a necessary
-     call may lead to a race condition.
- <![%unfinished;[
-     See <xref
-     linkend="debugging_profiling-missing_blockandevaluate"></xref> for
-     instructions how to diagnose and eliminate these race
-     conditions.
- ]]>  <!-- end unfinished -->
- </para>
- 
-     <para>Where talk about various &pooma; streams?</para>
- 
-    <para>UNFINISHED</para>
- 
-    </section>
- 
- 
-    <section id="sequential-benchmarks">
-     <title>&benchmark; Programs</title>
- 
-     <para>Define a &benchmark; program vs. an example or an
-     executable.  Provide a short overview of how to run these
-     programs.  Provide an overview of how to write these programs.
-     See <filename
-     class="headerfile">src/Utilities/Benchmark.h</filename>.</para>
-    </section>
- 
- 
-    <section>
-     <title>Miscellaneous</title>
- 
-     <para>Section&nbsp;3, "Domains and Views," of
-     <filename>papers/iscope98.pdf</filename> describes four types of
-     domains.</para>
- 
-     <section id="concepts-data_parallel">
-      <title>Data-Parallel Statements</title>
- 
-      <para>Can we use "An Overview of &pete;" from
-     <filename>papers/PETE_DDJ/ddj_article.html</filename> or is this
-     too low-level?</para>
- 
-      <para>Section&nbsp;3.2.1 of <filename>papers/pooma.ps</filename>
-     gives a simple example of data-parallel expression.  It also has a
-     paragraph introducing data-parallel operations and selecting
-     subsets of domains.  Section&nbsp;3.4 describes the Chained
-     Expression Object (<acronym>CEO</acronym>), apparently a precursor
-     of &pete;.  Regardless, it provides some motivation and
-     introductory material.</para>
- 
-     <para>From Section&nbsp;4 of
-     <filename>papers/SiamOO98_paper.ps</filename>:</para>
- 
-      <para>This version of &pete; reduces compile time of user codes
-     and utilizes compile-time knowledge of expression &domain;s for
-     better optimization.  For example, more efficient loops for
-     evaluating an expression can be generated if &pete; knows that the
-     &domain; has unit stride in memory.</para>
- 
-     <para>Section&nbsp;4, "Expressions and Evaluators", of
-     <filename>papers/iscope98.pdf</filename> has a good explanation of
-     &pooma;&nbsp;II's expression trees and expression engines.</para>
- 
-     <para>COMMENT: <filename
-     class="libraryfile">background.html</filename> has some related
-     &pete; material.</para>
-    </section>
- 
- 
-    <section>
- 	     <title>Containers</title>
- 
- 	     <section id="concepts-containers-array">
-      <title>&array;</title>
- 
-      <blockquote>
- 	     <attribution>Section&nbsp;4 "Future Improvements in
-      &pooma;&nbsp;II" of
-      <filename>papers/SiamOO98_paper.ps</filename></attribution>
- 	     <para>
-      An &array; can be thought of as a map from one &domain; to
-      another.&hellip; &array;s depend only on the interface of
-      &domain;s.  Thus, a subset of view of an &array; can be
-      manipulated in all the same ways as the original &array;.
-      &array;s can perform indirect addressing because the output
-      &domain; one one &array; can be used as the input &domain; of
-      another &array;.  &array;s also provide individual element
-      access.</para>
-      </blockquote>
- 
- 
-      <para>
-       (unformatted) From
-       <filename>papers/GenericProgramming_CSE/dubois.html</filename>:
-       The &pooma; &array; concept provides an example of how these
-       generic-programming features can lead to flexible and efficient
-       code. An Array maps a fairly arbitrary input domain to an
-       arbitrary range of outputs. When used by itself, an &array;
-       object <varname>A</varname> refers to all of the values in its
-       domain. Element-wise mathematical operations or functions can be
-       applied to an array using straightforward notation, like A + B
-       or sin(A). Expressions involving Array objects are themselves
-       Arrays. The operation A(d), where d is a domain object that
-       describes a subset of A's domain, creates a view of A that
-       refers to that subset of points. Like an array expression, a
-       view is also an Array. If d represents a single point in the
-       domain, this indexing operation returns a single value from the
-       range. Equivalently, one can index an N-dimensional Array by
-       specifying N indices, which collectively specify a single point
-       in the input domain: A(i1, i2, ..., iN).</para>
- 
-      <para>The &pooma; multidimensional Array concept is similar to
-       the &fortran;&nbsp;90 array facility, but extends it in several
-       ways. Both &pooma; and &fortran; arrays can have up to seven
-       dimensions, and can serve as containers for arbitrary
-       types. Both support the notion of views of a portion of the
-       array, known as array sections in F90. The &pooma; Array concept
-       supports more complex domains, including bounded, continuous
-       (floating-point) domains. Furthermore, Array indexing in &pooma;
-       is polymorphic; that is, the indexing operation X(i1,i2) can
-       perform the mapping from domain to range in a variety of ways,
-       depending on the particular type of the Array being
-       indexed.</para>
- 
-      <para>&fortran; arrays are dense and the elements are arranged
- 		   according to column-major conventions. Therefore, X(i1,i2)
-       refers to element number i1-1+(i2-1)*numberRowsInA. However, as
-       Fig. 1 shows, &fortran;-style "Brick" storage is not the only
-       storage format of interest to scientific programmers. For
-       compatibility with C conventions, one might want to use an array
-       featuring dense, row-major storage (a C-style Brick). To save
-       memory, it might be advantageous to use an array that only
-       stores a single value if all its element values are the
-       same. Other sparse storage schemes that only store certain
-       values may also be desirable. To exploit parallelism, it is
-       convenient for an array's storage to be broken up into patches,
-       which can be processed independently by different CPUs. Finally,
-       one can imagine an array with no data at all. For example, the
-       values can be computed from an expression involving other
-       arrays, or analytically from the indices.
-      </para>
- 
-      <para>The &pooma; &array; Class Template</para>
- 
-      <para>Next we describe &pooma;'s model of the Array concept, the
-      Array class template. The three most important requirements from
-      the point of view of overall design are: (1) arbitrary domain,
-      (2) arbitrary range, and (3) polymorphic indexing. These express
-      themselves in the template parameters for the &pooma; Array
-      class. The template
-      <programlisting>
-      template &lt;int Dim, class T = double, class EngineTag = Brick&gt;
-      class Array;
-      </programlisting>
-      is a specification for creating a set of classes all named
-      Array. The template parameters Dim, T, and EngineTag determine
-      the precise type of the Array. Dim represents the dimension of
-      the array's domain. T gives the type of array elements, thereby
-      defining the output range of the array. EngineTag specifies the
-      the manner of indexing and types of the indices.</para>
- 
-      <para>End From
-      <filename>papers/GenericProgramming_CSE/dubois.html</filename>:</para>
- 
-      <para>Section&nbsp;2, "Arrays and Engines," of
-      <filename>papers/iscope98.pdf</filename> describes both &array;s
-      and &engine;s.  This may or may not duplicate the material in
-      <filename>papers/GenericProgramming_CSE/dubois.html</filename>.</para>
- 
-      <section id="concepts-containers-array-views">
-       <title>Views of &array;s</title>
- 
-       <para>Section&nbsp;3, "Domains and Views," of
-       <filename>papers/iscope98.pdf</filename> motivates the need for
-       views:
-        <blockquote>
- 	<para>One of the primary uses of domains is to specify
- 	subsections of &array; objects.  Subarrays are a common
- 	feature of array classes; however, it is often difficult to
- 	make such subarrays behave like first-class objects.  The
- 	&pooma;&nbsp;II engine concept provides a clean solution to
- 	this problem: subsetting an &array; with a domain object
- 	creates a new &array; that has a view engine.</para>
-        </blockquote>
-       </para>
-      </section>
-     </section>
- 
-     <section id="concepts-containers-field">
-      <title>&field;</title>
- 
- 	     <para>QUESTION: Do we include boundary conditions here?
- 
-      FINISH: Do we have an example that shows something not possible
-      with &array;?</para>
- 
- 	     <para>Describe and illustrate multi-material and
-      multivalue?</para>
- 
- 	     <para>ADD: description of meshes and guard layers.</para>
- 
- 	    </section>
-      </section>
- 
-      <section id="concepts-engines">
-       <title>Engines</title>
- 
-       <para>(unformatted) From
-     <filename>papers/GenericProgramming_CSE/dubois.html</filename>:</para>
- 
-       <para>The Engine Concept</para>
- 
-       <para>To implement polymorphic indexing, the &array; class defers
-       data storage and data lookup to an &engine; object. The
-       requirements that the &array; template places on its &engine;
-       provide the definition for the &engine; concept. We'll describe
-       these by examining a simplified version of the &array; template,
-       shown in Fig. 2.</para>
- 
-       <para>First, the &array; class determines and exports (makes
-     Engine_t part of &array;'s public interface) the type of the engine
-     class that it will use:
-     <programlisting>
-     typedef Engine&lt;Dim, T, EngineTag&gt; Engine_t;
-     </programlisting>
-     This statement declares Engine_t to be an alias for the type
-     Engine&lt;Dim,T,EngineTag&gt;. This is the first requirement
-     placed on engine classes: they must be specializations of a
-     general Engine template whose template parameters are identical to
-     those of &array;. Next, the &array; template determines the type of
-     scalar arguments (indices) to be used in operator(), the function
-     that implements &pooma;'s &fortran;-style indexing syntax X(i1,i2):
-     <programlisting>
-     typedef typename Engine_t::Index_t Index_t;
-     </programlisting>
-     This statement defines another type alias:
-     Array&lt;Dim,T,EngineTag&gt;::Index_t is simply an alias for
-     Engine_t::Index_t. Engine_t::Index_t is a qualified name, which
-     means that the type Index_t is found in the class Engine_t. This
-     is the second requirement for the Engine concept: the class
-     Engine_t must define a public type called Index_t. This line will
-     not compile if that definition is not supplied. This indirection
-     is one of the ways that &pooma; supports polymorphic indexing. If
-     the Engine works with a discrete integer domain, it defines its
-     Index_t to be an integral type. If the Engine works in a
-     continuous domain, it defines its Index_t to be a floating-point
-     type.</para>
- 
-     <para>The data lookup is performed in the operator() function. We
-     see that &array; simply passes the indices on to its engine
-     object. Thus, we have the third requirement for the Engine
-     concept: it must provide a version of operator() that takes Dim
-     values of type Index_t.</para>
- 
-       <para>Simply passing the indices on to the engine object may seem
-     odd. After all, engine(i,j) looks like we're just indexing another
-     array. There are several advantages to this extra level of
-     indirection. The &array; class is as faithful a model of the &array;
-     concept as possible, while the Engine class is a low-level
-     interface to a user-defined data source. As a result, &array; has a
-     wide variety of constructors for user convenience, while engines
-     have but a few. &array; supports a wide variety of overloaded
-     operator() functions for view creation and indexing. Engines
-     support indexing only. &array; does not have direct access to the
-     data, which is managed by the engine object. Finally, &array; has a
-     wide variety of overloaded mathematical operators and functions,
-     and works with the Portable Expression Template Engine (PETE) [4]
-     to provide efficient evaluation of &array; expressions. Engines have
-     no such support. In general, &array; is much more complex and
-     feature-laden than Engine. This is the prime advantage of the
-     separation of interface and implementation: &array; only has to be
-     implemented once by the &pooma; developers. Engines are simple
-     enough to be written by users and plugged directly into the &array;
-     framework.</para>
- 
-     <para>Figure 3 illustrates the "Brick" specialization of the
-     Engine template, which implements &fortran;-style lookup into a
-     block of memory. First, there is the general Engine template,
-     which is empty as there is no default behavior for an unknown
-     EngineTag. The general template is therefore not a model for the
-     Engine concept and &array; classes attempting to use it will not
-     compile. Next, there is the definition of the Brick class, a
-     policy tag whose sole purpose is to select a particular
-     specialization of the Engine template. Finally, there is the
-     partial specialization of the Engine template. Examining its body,
-     we see the required Index_t typedef and the required operator(),
-     which follows the &fortran; prescription for generating an offset
-     into the data block based on the row, column, and the number of
-     rows. All of the requirements are met, so the Brick-Engine class
-     is a model of the Engine concept.</para>
- 
-     <para>End From
-     <filename>papers/GenericProgramming_CSE/dubois.html</filename>:</para>
- 
-     <para>(unformatted) From
-     <filename>papers/GenericProgramming_CSE/dubois.html</filename>:</para>
- 
-     <para>Compile-time Versus Run-Time Polymorphism</para>
- 
-     <para>Encapsulating the indexing in an Engine class has important
-     advantages, both in terms of flexibility and efficiency. To
-     illustrate this point, we introduce the PolarGaussian-Engine
-     specialization in Fig. 4. This is an analytic engine that
-     calculates its values directly from its inputs. Unlike the
-     Brick-Engine, this engine is "indexed" with data of the same type
-     as its output: it maps a set of T's to a single T. Therefore, the
-     Index_t typedef selects T as the index type, as opposed to the int
-     in the Brick-Engine specialization. The operator() function also
-     differs in that it computes the return value according to an
-     analytic formula.</para>
- 
-     <para>Both Engine&lt;Dim,T,Brick&gt; and
-     Engine&lt;Dim,T,PolarGaussian&gt; can be plugged in to an &array; by
-     simply varying the &array;'s EngineTag. This is possible despite the
-     fact that the two classes exhibit dramatically different behavior
-     because they are both models of the Engine concept.</para>
- 
-     <para>Notice that we have achieved polymorphic indexing without
-     the use of inheritance or virtual functions. For instance,
-     consider the following code snippet:
-     <programlisting>
-     Array<2, double, Brick> a;
-     Array<2, double, PolarGaussian> b;
- 
-     double x = a(2, 3);     // x = a.engine.data[2 + 3 * a.engine.numRows];
-     double y = b(2.0, 3.0); // y = exp(-(2.0*2.0+3.0*3.0) / b.engine.delta);
-     </programlisting>
-     The data lookup functions for the two &array;s perform completely
-     different operations. Since this is accomplished using static
-     types, it is known as compile-time polymorphism. Moreover,
-     everything is known at compile time, so the functions are fully
-     inlined and optimized, thereby yielding code equivalent to that
-     shown in the comments above.</para>
- 
-     <para>The flexibility and efficiency of compile-time polymorphism
-     cannot be duplicated with a run-time implementation. To illustrate
-     this point, in Fig. 5, we re-implement our &array; concept using the
-     classic Envelope-Letter pattern [5], with the array class,
-     RTArray, being the envelope and the run-time-engine, RTEngine,
-     being the letter. RTArray defers data lookup to the engine object
-     by invoking the engine's functions through a pointer to the
-     RTEngine base class. Figure 6 illustrates the RTEngine base class
-     and Fig. 7 illustrates two descendants: RTBrick and
-     RTPolarGaussian.</para>
- 
-     <para>The run-time implementation provides the same basic
-     functionality as the compile-time implementation, but it is not as
-     flexible or as efficient. It lacks flexibility in that the return
-     type of the indexing operation must be specified in the RTEngine
-     base class and in the RTArray class. Thus, in Figs. 5 and 6,we see
-     versions of RTArray::operator() and RTEngine::index functions that
-     take both int's and T's. If the programmer wants to add another
-     index-type option, these classes must be modified. This is a
-     violation of the open-closed principle proposed by Meyer
-     [6]. Also, since RTEngine descendants will usually only implement
-     one version of index, we cannot make RTEngine an abstract base
-     class. Instead, we have the default versions of index throw an
-     exception. Thus, compile-time error checking is
-     weakened. Furthermore, since indexing is done via a virtual
-     function call, it will almost never be inlined, which is not
-     acceptable in most scientific applications.</para>
- 
-     <para>There are advantages to the Envelope-Letter approach. First,
-     all RTArray objects have the same type, allowing them to be stored
-     in homogeneous collections. This can simplify the design of some
-     applications. Second, RTArray objects can change their engines at
-     runtime, and thus effectively change their types on the fly??this
-     is the primary reason for using the Envelope-Letter idiom, and can
-     be very important in some applications.</para>
- 
-     <para>For most scientific applications, however, these issues are
-     minor, and maximum performance for array indexing is of paramount
-     importance. Our compile-time approach achieves this performance
-     while providing the desired polymorphic indexing.</para>
- 
-     <para>From Section&nbsp;4 of
-     <filename>papers/SiamOO98_paper.ps</filename>:</para>
- 
-     <para>The &array; class is templated on an &engine; type that
-     handles the actual implementation of the mapping from input to
-     output.  Thus, the &array; interface features are completely
-     separate from the implementation, which could be a single &c;
-     array, a function of some kind or some other mechanism.  This
-     flexibility allows an expression itself to be viewed through the
-     &array; interface.  Thus, one can write something like
-     <programlisting>
-     foo(A*B+C);
-     </programlisting> where <varname>A</varname>, <varname>B</varname> and
-     <varname>C</varname> are &array;s and <function>foo</function> is
-     a function taking an &array; as an argument.  The expression
-     <literal><varname>A</varname>*<varname>B</varname>+<varname>C</varname></literal>
-     will only be evaluated by the expression engine as needed by
-     <function>foo</function>.</para>
- 
-     <para>In fact, one can even write &engine;s which are wrappers
-     around external data structures created in non-&pooma; codes and
-     know to manipulate these structures.  Once this is done, the
-     external entities have access to the entire &array; interface and
-     can utilize all of the powerful features of
-     &pooma;&nbsp;II.</para>
- 
-     <para>Section&nbsp;2, "Arrays and Engines," of
-     <filename>papers/iscope98.pdf</filename> describes both &array;s
-     and &engine;s.  This may or may not duplicate the material in
-     <filename>papers/GenericProgramming_CSE/dubois.html</filename>.</para>
- 
-     <para>Section&nbsp;4, "Expressions and Evaluators", of
-     <filename>papers/iscope98.pdf</filename> has a good explanation of
-     &pooma;&nbsp;II's expression trees and expression engines.</para>
- 
-     <variablelist>
-      <varlistentry><term>&multipatch; Engine</term>
-       <listitem><para>From <filename
-       class="libraryfile">README</filename>: To actually use multiple
-       contexts effectively, you need to use the MultiPatch engine with
-       patch engines that are Remote engines.  Then the data will be
-       distributed across multiple contexts instead of being copied on
-       every context.  See the files in example/Doof2d for a simple
-       example that creates a MultiPatch array that can be distributed
-       across multiple contexts and performs a stencil computation on
-       that array.</para></listitem>
-      </varlistentry>
-     </variablelist>
-    </section>
- 
-    </section>
-   </chapter>
- ]]>  <!-- end unfinished -->
- 
- 
- <![%unfinished;[
-   <chapter id="parallel">
-    <title>Writing Distributed Programs</title>
- 
-    <para>Discuss the distributed model and guard cells.  See <filename
-    class="libraryfile">docs/parallelism.html</filename>.</para>
- 
-    <para>Does any of the parallel implementation described in
-    <filename>papers/SCPaper-95.html</filename> still apply?</para>
- 
-    <para>?Tuning program for maximize parallel performance?</para>
- 
-    <para>external references to &mpi; and threads</para>
- 
-    <para>QUESTION: Are there interesting, short parallel programs in
-    any &mpi; book that we can convert to &pooma;?</para>
- 
-    <section>
-     <title>Layouts</title>
- 
-     <para>An out-of-date description can be found in Section&nbsp;3.3,
-     especially 3.3.2, of <filename>papers/pooma.ps</filename>
-     describes the global/local interactions and parallel abstraction
-     layers.</para>
-    </section>
- 
-    <section>
-     <title>Parallel Communication</title>
- 
-     <para>An out-of-date description can be found in
-      Section&nbsp;3.3.3 of <filename>papers/pooma.ps</filename></para>
-    </section>
- 
-    <section>
-     <title>Using Threads</title>
- 
-     <para>QUESTION: Where do threads fit into the manual?  Do threads
-     even work?</para>
- 
-     <para>From Section&nbsp;4, of
-     <filename>papers/SiamOO98_paper.ps</filename></para>
- 
-     <para>&pooma;&nbsp;II will make use of a new parallel run-time
-     system called &smarts; that is under development at the ACL.
-     &smarts; supports lightweight threads, so the evaluator will be
-     able to farm out data communication tasks and the evaluation of
-     subsets of an expression to multiple threads, thus increasing the
-     overlap of communication and computation.  Threads will also be
-     available at the user level for situations in which a
-     task-parallel approach is deemed appropriate.</para>
-    </section>
- 
-   </chapter>
- ]]>  <!-- end unfinished -->
- 
- 
- <![%unfinished;[
-   <chapter id="debugging_profiling">
-    <title>Debugging and Profiling &pooma; Programs</title>
- 
-    <para>Consider &dashdash;pooma-debug <replaceable>number</replaceable>.
-    See also other &pooma; options in <filename
-    class="headerfile">src/Utilities/Options.h</filename>.</para>
- 
-    <para>UNFINISHED</para>
-     <section id="debugging_profiling-missing_blockandevaluate">
-      <title>Finding Race Conditions From Missing
-      <function>blockAndEvaluate</function> Calls</title>
- 
-       <para>&pooma; may reorder computations so calls to
-       <function>Pooma::blockAndEvaluate()</function> are necessary
-       before accessing particular &array; and &field; values.
-       Omission of necessary calls can lead to race conditions where
-       the ordering of reads and writes to particular values is
-       incorrect.  To help diagnose if calls to
-       <function>Pooma::blockAndEvaluate</function> are missing, invoke
-       a &pooma; executable with the
-       <literal>&dashdash;pooma-blocking-expressions</literal> option.
-       This automatically causes
-       <function>Pooma::blockAndEvaluate</function> to be called after
-       each statement.  Doing so ensures program correctness, but it
-       may increase running times, particularly if multiple processors
-       are used, because computation and communication may not overlap
-       as much as possible.  Of course, program correctness is more
-       important than execution speed.</para>
- 
-       <para>If using
-       <literal>&dashdash;pooma-blocking-expressions</literal> changes a
-       program's output, it is missing one or more calls to
-       <function>Pooma::blockAndEvaluate</function>.  To narrow the
-       region with a missing call, surround the region in question with
-       calls to <literal>Pooma::blockingExpressions(true)</literal>
-       and <literal>Pooma::blockingExpressions(false)</literal>,
-       but do not use the
-       <literal>&dashdash;pooma-blocking-expressions</literal> option.
-       Within the region, <function>Pooma::blockAndEvaluate</function>
-       will be invoked after each statement.  Repeatedly reducing the
-       region's size should reveal where calls are missing.</para>
-     </section>
-   </chapter>
- ]]>  <!-- end unfinished -->
- 
- 
- <![%unfinished;[
-  </part>
- ]]>  <!-- end unfinished -->
- 
- <![%unfinished;[
-  <part id="reference">
-   <title>&pooma; Reference Manual</title>
- 
-   <chapter id="tmp_ref">
-    <title>TMP: This Chapter Holds These Comments But Will Be Removed</title>
- 
-    <para>For each template parameter need to describe the constraints
-    on it.</para>
- 
-    <para>Remove this section when the following concerns have been
-    addressed.</para>
- 
-    <para>Add a partintro explaining file suffixes such as <filename
-    class="headerfile">.h</filename>, <filename
-    class="libraryfile">.cpp</filename>, <filename
-    class="libraryfile">.cmpl.cpp</filename>, <filename
-    class="libraryfile">.mk</filename>, <filename
-    class="libraryfile">.conf</filename>.  Should we also explain use
-    of <literal>inline</literal> even when necessary and the template
-    model, e.g., including <filename
-    class="libraryfile">.cpp</filename> files.</para>
- 
-    <para>QUESTION: What are the key concepts around which to organize
-    the manual?</para>
- 
-    <para>QUESTION: What format should the manual use?</para>
- 
-    <blockquote>
-     <attribution>Musser, Derge, and Sanai, &sect;20.0.</attribution>
-     <para>It is important to state the requirements on the components
-     as generally as possible.  For example, instead of saying
-     <quote>class <type>X</type> must define a member function
-     <function>operator++()</function>,</quote> we say <quote>for any
-     object&nbsp;<varname>x</varname> of type&nbsp;<type>X</type>,
-     <classname>++x</classname> is defined.</quote></para>
-    </blockquote>
-   </chapter>
- 
- 
-   <chapter id="class_structure_ref">
-    <title>A Typical &pooma; Class</title>
- 
-    <variablelist>
-     <title>Class Member Notation</title>
-     <varlistentry>
-      <term><fieldsynopsis>
-        <varname>*_t</varname>
-       </fieldsynopsis>
-      </term>
-      <listitem>
-       <para>type within a class.  QUESTION: What is the &cc; name for
-       this?</para>
-      </listitem>
-     </varlistentry>
-     <varlistentry>
-      <term><fieldsynopsis>
-        <varname>*_m</varname>
-       </fieldsynopsis>
-      </term>
-      <listitem>
-       <para>data member</para>
-      </listitem>
-     </varlistentry>
-    </variablelist>
- 
-    <variablelist>
-     <title>&pooma; Class Vocabulary</title>
-     <varlistentry>
-      <term>component</term>
-      <listitem>
-       <para>one of several values packaged together.  For example, a
-       three-dimensional vector has three components, i.e., three
-       values.</para>
-      </listitem>
-     </varlistentry>
-     <varlistentry>
-      <term>element-wise</term>
-      <listitem>
-       <para>applied to each element in the group, e.g., an array</para>
-      </listitem>
-     </varlistentry>
-     <varlistentry>
-      <term>reduction</term>
-      <listitem>
-       <para>repeated application of a binary operator to all elements,
-       yielding one value</para>
-      </listitem>
-     </varlistentry>
-     <varlistentry>
-      <term>tag</term>
-      <listitem>
-       <para>an enumerated value indicating inclusion in a particular
-       semantic class.  The set of values need not be explicitly
-       declared.</para>
-      </listitem>
-     </varlistentry>
-    </variablelist>
- 
-   </chapter>
- 
- 
-   <chapter id="installing_configuring_ref">
-    <title>Installing and Configuring &pooma;</title>
- 
-    <orderedlist>
-     <listitem>
-      <para>Installing &pooma;.</para>
-     </listitem>
-     <listitem>
-      <para>Requirements for configuration files.</para>
-     </listitem>
-    </orderedlist>
- 
-    <para>Include descriptions of using &smarts;, &cheetah;, &tau;,
-    &pdt;.</para>
- 
-    <para>QUESTION: Does it install on windows and on mac?  If so, what
-    are the instructions?  See also <filename
-    class="libraryfile">INSTALL.{mac,unix,windows}.</filename></para>
- 
-    <para><filename class="libraryfile">README</filename> has some
-    information on &cheetah; and threads in the <quote>Message-Based
-    Parallelism</quote> section.</para>
- 
-    <para>Which additional packages are necessary and when?</para>
- 
-    <para>What configure options should we list?  See <filename
-    class="libraryfile">configure</filename>.  Be sure to list
-    debugging option and how its output relates to <filename
-    class="libraryfile">config/LINUXgcc.suite.mk</filename>.</para>
- 
-    <para><filename class="directory">config/arch</filename> has files
-    for (OS, compiler) pairs.  Explain how to modify a configuration
-    file.  List requirements when making a new configuration file (low
-    priority).</para>
- 
-    <para><filename
-    class="libraryfile">config/LINUXgcc.suite.mk</filename> has output
-    from <filename class="libraryfile">configure</filename>.  Useful to
-    relate to configuration files and <filename
-    class="libraryfile">configure</filename>'s debugging output.</para>
-    
-   </chapter>
- 
- 
-   <chapter id="compilation_ref">
-    <title>Compilation and &make; Files</title>
- 
-    <para>We assume Gnu make.  Do we know what assumptions are made?</para>
- 
-    <para>How do all these files interact with each other?  Ala a make
-    interpreter, give an example of which files are read and
-    when.</para>
- 
-    <variablelist>
-     <varlistentry><term><filename
-     class="libraryfile">config/Shared/README.make</filename></term>
-     <listitem><para>This has short descriptions of many files,
-     especially in <filename
-     class="directory">config/Shared</filename>.</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">makefile</filename></term>
-     <listitem><para>These appear throughout all directories.  What are
-     the equivalences classes and what are their
-     parts?</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">include.mk</filename></term>
-     <listitem><para>What does this do?  Occurs in many directories:
-     when?  Template seems to be <filename
-     class="libraryfile">config/Shared/include2.mk</filename>.</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">subdir.mk</filename></term>
-     <listitem><para>list of subdirectories; occurs in several
-     directories: when?  <filename
-     class="libraryfile">src/subdir.mk</filename> is a good
-     example.</para></listitem>
-     </varlistentry>
-     <varlistentry>
-      <term><filename class="libraryfile">objfile.mk</filename></term>
-      <listitem>
-       <para>list of object files to construct, presumably from
-       <filename>*.cmpl.cpp</filename> files.
-       <filename>src/Utilities/objfile.mk</filename> is an
-       example.</para>
-      </listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">config/Shared/rules.mk</filename></term>
-     <listitem><para>most compiler rules</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">config/head.mk</filename></term>
-     <listitem><para>read at beginning of each
-     makefile?</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">config/Shared/tail.mk</filename></term>
-     <listitem><para>read at end of each makefile?</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">config/Shared/variables.mk</filename></term>
-     <listitem><para>Is this used?</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">config/Shared/compilerules.mk</filename></term>
-     <listitem><para>table of origin and target suffixes and commands
-     for conversion</para></listitem>
-     </varlistentry>
- 
-    </variablelist>
- 
-   </chapter>
- 
- 
-   <chapter id="arrays_ref">
-    <title>&array;s</title>
- 
-    <para>Include <filename
-    class="headerfile">src/Pooma/Arrays.h</filename> to use &array;s.
-    The implementation source code is in <filename
-    class="directory">src/Array</filename>.</para>
- 
-    <para>FINISH: Define an array.  Introduce its parts.</para>
- 
-    <para>ADD: some mention of the maximum supported number of
-    dimensions somewhere.</para>
- 
-    <section id="arrays_ref-array">
-     <title>The &array; Container</title>
- 
-     <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	   orient="port" pgwide="0">
-      <title>Template Parameters</title>
- 
-      <tgroup cols="2" align="left">
-       <thead>
-        <row>
- 	<entry>Parameter</entry>
- 	<entry>Interpretation</entry>
-        </row>
-       </thead>
-       <tbody valign="top">
-        <row>
- 	<entry><varname>Dim</varname></entry>
- 	<entry><para>dimension</para></entry>
-        </row>
-        <row>
- 	<entry><type>T</type></entry>
- 	<entry><para>array element type</para></entry>
-        </row>
-        <row>
- 	<entry>EngineTag</entry>
- 	<entry><para>type of computation engine object</para></entry>
-        </row>
-       </tbody>
-      </tgroup>
-     </table>
- 
-     <para>QUESTION: How do I introduce class type definitions, when
-     they are used, i.e., compile-time or run-time, and when
-     programmers should use them?</para>
- 
-     <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	   orient="port" pgwide="0">
-      <title>Compile-Time Types and Values</title>
- 
-      <tgroup cols="2" align="left">
-       <thead>
-        <row>
- 	<entry>Type or Value</entry>
- 	<entry>Interpretation</entry>
-        </row>
-       </thead>
-       <tbody valign="top">
-        <row>
- 	<entry><fieldsynopsis><varname>This_t</varname></fieldsynopsis></entry>
- 	<entry><para>the &array; object's type</para></entry>
-        </row>
-        <row>
- 	<entry><fieldsynopsis><varname>Engine_t</varname></fieldsynopsis></entry>
- 	<entry><para>the &array; object's engine's type</para></entry>
-        </row>
-        <row>
- 	<entry><fieldsynopsis><varname>EngineTag_t</varname></fieldsynopsis></entry>
- 	<entry><para>indication of engine's category</para></entry>
-        </row>
-        <row>
- 	<entry><fieldsynopsis><varname>Element_t</varname></fieldsynopsis></entry>
- 	<entry><para>the type of the array elements, i.e., <type>T</type></para></entry>
-        </row>
-        <row>
- 	<entry><fieldsynopsis><varname>ElementRef_t</varname></fieldsynopsis></entry>
- 	<entry><para>the type of a reference to an array element,
- 	i.e., <type>T&</type>.  Equivalently, the type to write to a
- 	single element.</para></entry>
-        </row>
-        <row>
- 	<entry><fieldsynopsis><varname>Domain_t</varname></fieldsynopsis></entry>
- 	<entry><para>the array's domain's type, i.e., the type of the
- 	union of all array indices</para></entry>
-        </row>
-        <row>
- 	<entry><fieldsynopsis><varname>Layout_t</varname></fieldsynopsis></entry>
- 	<entry><para>unknown</para></entry>
-        </row>
-        <row>
- 	<entry><fieldsynopsis><varname>dimensions</varname></fieldsynopsis></entry>
- 	<entry><para>integer equalling the number of dimensions, i.e.,
- 	<varname>Dim</varname></para></entry>
-        </row>
-        <row>
- 	<entry><fieldsynopsis><varname>rank</varname></fieldsynopsis></entry>
- 	<entry><para>integer equalling the number of dimensions, i.e.,
- 	<varname>Dim</varname>; a synonym for <fieldsynopsis>
- 	   <varname>dimensions</varname></fieldsynopsis></para></entry>
-        </row>
-       </tbody>
-      </tgroup>
-     </table>
- 
-     <section id="arrays_ref-array-constructors">
-      <title>Constructors and Destructors</title>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0">
-       <title>Constructors and Destructors</title>
- 
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>Function</entry>
- 	 <entry>Effect</entry>
- 	</row>
-        </thead>
-        <tbody valign="top">
- 	<row>
- 	 <entry>
-           <constructorsynopsis>
- 	   <literal>Array</literal>
- 	   <void></void>
- 	  </constructorsynopsis>
-          </entry>
- 	 <entry><para>Creates an array that will be resized
- 	 later.</para></entry>
- 	</row>
- 	<row>
- 	 <entry>
-           <constructorsynopsis>
- 	   <literal>Array</literal>
- 	   <methodparam><modifier>const</modifier> <type>Engine_t&</type>
- 	    <parameter>engine</parameter></methodparam>
- 	  </constructorsynopsis>
-          </entry>
- 	 <entry><para>Creates an array with an engine equivalent to
-          the <parameter>engine</parameter>.  This array will have the
-          same values as <parameter>engine</parameter>.  QUESTION: Why
-          would a user every want to use this
-          constructor?</para></entry>
- 	</row>
- 	<row>
- 	 <entry>
-           <constructorsynopsis>
- 	   <literal>Array</literal>
- 	   <methodparam>
- 	    <modifier>const</modifier>
- 	    <type> Engine&lt;Dim2, T2, EngineTag2&gt;&</type>
- 	    <parameter>engine</parameter>
- 	   </methodparam>
- 	   <methodparam>
- 	    <modifier>const</modifier>
- 	    <type>Initializer&</type> <parameter>init</parameter>
- 	   </methodparam>
- 	  </constructorsynopsis>
-          </entry>
- 	 <entry><para>What does this do?</para></entry>
- 	</row>
- 	<row>
- 	 <entry>ADD ALL CONSTRUCTORS AND DESTRUCTORS.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
-     </section>
- 
- 
-     <section id="arrays_ref-array-initializers">
-      <title>Initializers</title>
- 
-      <para>Add a table.</para>
-     </section>
- 
- 
-     <section id="arrays_ref-array-access">
-      <title>Element Access</title>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0">
-       <title>&array; Element Access</title>
- 
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>Function</entry>
- 	 <entry>Effect</entry>
- 	</row>
-        </thead>
-        <tbody valign="top">
- 	<row>
- 	 <entry>
-           <methodsynopsis>
- 	   <type>Element_t</type> <literal>read</literal>
- 	   <void></void>
- 	  </methodsynopsis>
-          </entry>
- 	 <entry><para>unknown: See line 1839.</para></entry>
- 	</row>
- 	<row>
- 	 <entry>
-           <methodsynopsis>
- 	   <type>Element_t</type> <literal>read</literal>
- 	   <methodparam>
- 	    <modifier>const</modifier>
- 	    <type>Sub1&</type> <parameter>s1</parameter>
- 	   </methodparam>
- 	   <methodparam>
- 	    <modifier>const</modifier>
- 	    <type> Sub2&</type> <parameter>s2</parameter>
- 	   </methodparam>
- 	  </methodsynopsis>
-          </entry>
- 	 <entry><para>How does the version with template parameters,
-          e.g., <type>Sub1</type> differ from the <type>int</type>
-          version?</para></entry>
- 	</row>
- 	<row>
- 	 <entry>
-           <methodsynopsis>
- 	   <type>Element_t</type> <literal>operator()</literal>
- 	   <methodparam>
- 	    <modifier>const</modifier>
- 	    <type>Sub1&</type> <parameter>s1</parameter>
- 	   </methodparam>
- 	   <methodparam>
- 	    <modifier>const</modifier>
- 	    <type>Sub2&</type> <parameter>s2</parameter>
- 	   </methodparam>
- 	  </methodsynopsis>
-          </entry>
- 	 <entry><para>How does this differ from <literal>read(const
-           Sub1& s1, const Sub2& s2)</literal>?  </para></entry>
- 	</row>
- 	<row>
- 	 <entry>ADD ALL <function>read</function>s and
- 	 <function>operator()</function>s.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
-     </section>
- 
- 
-     <section id="arrays_ref-array-component">
-      <title>Component Access</title>
- 
-      <para>When an array stores elements having components, e.g., an
-      array of vectors, tensors, or arrays, the
-      <literal>comp</literal> returns an array consisting of the
-      specified components.  The original and component array share the
-      same engine so changing the values in one affects values in the
-      other.</para>
- 
-      <para>For example, if &n; &times; &n; array <varname>a</varname>
-      consists of three-dimensional real-valued vectors,
-      <literal>a.comp(1)</literal> returns a &n; &times; &n;
-      real-valued array of all the middle vector components.  Assigning
-      to the component array will also modify the middle components of
-      the vectors in <varname>a</varname>.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0">
-       <title>&array; Component Access</title>
- 
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>Function</entry>
- 	 <entry>Effect</entry>
- 	</row>
-        </thead>
-        <tbody valign="top">
- 	<row>
- 	 <entry>
-           <methodsynopsis>
- 	   <type>UNKNOWN compute this</type> <literal>comp</literal>
- 	   <methodparam>
- 	    <modifier>const</modifier>
- 	    <type>int&</type>
- 	    <parameter>i1</parameter>
- 	   </methodparam>
- 	  </methodsynopsis>
-          </entry>
- 	 <entry><para>unknown: See line 1989.</para></entry>
- 	</row>
- 	<row>
- 	 <entry>ADD ALL <literal>comp</literal>s.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
-     </section>
- 
-     <section id="arrays_ref-array-accessors">
-      <title>Accessors</title>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0">
-       <title>&array; Accessor Methods</title>
- 
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>Function</entry>
- 	 <entry>Effect</entry>
- 	</row>
-        </thead>
-        <tbody valign="top">
- 	<row>
- 	 <entry>
-           <methodsynopsis>
- 	   <type>int</type> <literal>first</literal>
- 	   <methodparam>
- 	    <type>int</type>
- 	    <parameter>d</parameter>
- 	   </methodparam>
- 	  </methodsynopsis>
-          </entry>
- 	 <entry><para>unknown: See line 2050</para></entry>
- 	</row>
- 	<row>
- 	 <entry>ADD ALL other accessor methods, including
- 	 <literal>engine</literal>.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
-     </section>
- 
- 
-     <section id="arrays_ref-array-copying">
-      <title>Copying &array;s</title>
- 
-      <para>Explain how copied arrays and views of arrays share the
-      same underlying engine so changing values in one also affects the
-      other.  This is called a shallow copy.</para>
-     </section>
- 
- 
-     <section id="arrays_ref-array-utilities">
-      <title>Utility Methods</title>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0">
-       <title>&array; Utility Methods</title>
- 
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>Function</entry>
- 	 <entry>Effect</entry>
- 	</row>
-        </thead>
-        <tbody valign="top">
- 	<row>
- 	 <entry>
-           <methodsynopsis>
- 	   <type>void</type> <literal>makeOwnCopy</literal>
- 	   <void></void>
- 	  </methodsynopsis>
-          </entry>
- 	 <entry><para>unknown: See line 2044</para></entry>
- 	</row>
- 	<row>
- 	 <entry>ADD ALL other utility methods.</entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
-     </section>
- 
-     
-     <section id="arrays_ref-array-implementation">
-      <title>Implementation Details</title>
- 
-      <para>As a container, an &array;'s implementation is quite
-      simple.  Its <literal>private</literal>data consists of
-      an engine, and it has no <literal>private</literal>
-      functions.</para>
- 
-      <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	    orient="port" pgwide="0">
-       <title>&array; Implementation Data</title>
- 
-       <tgroup cols="2" align="left">
-        <thead>
- 	<row>
- 	 <entry>Data Member</entry>
- 	 <entry>Meaning</entry>
- 	</row>
-        </thead>
-        <tbody valign="top">
- 	<row>
- 	 <entry>
-           <fieldsynopsis>
- 	   <modifier>private</modifier>
- 	   <type>Engine_t</type> <varname>engine_m</varname>
- 	  </fieldsynopsis>
-          </entry>
- 	 <entry><para>engine computing the array's values</para></entry>
- 	</row>
-        </tbody>
-       </tgroup>
-      </table>
- 
-     </section>
-    </section>
- 
- 
-    <section id="arrays_ref-dynamicarray">
-     <title>&dynamicarray;s: Dynamically-Sized Domains</title>
- 
-     <para>A DynamicArray is a read-write array with extra
-     create/destroy methods.  It can act just like a regular Array, but
-     can have a dynamically-changing domain.  See <filename
- 							   class="headerfile">src/DynamicArray/DynamicArray.h</filename>.</para>
- 
-     <para>ADD: Briefly describe what the class does and an example of
-     where it is used.</para>
- 
-     <para>ADD: Check that its interface is actually the same as for
-     &array;.</para>
- 
-     <para>ADD: Check that the operations on dynamic arrays are
-     actually the same as for &array;.  See <filename
- 						     class="headerfile">src/DynamicArray/DynamicArrayOperators.h</filename>,
-     <filename
- 	      class="headerfile">src/DynamicArray/PoomaDynamicArrayOperators.h</filename>,
-     and <filename
- 		  class="headerfile">src/DynamicArray/VectorDynamicArrayOperators.h</filename>.</para>
- 
-     
-     <section id="arrays_ref-dynamicarray-implementation">
-      <title>Implementation Details</title>
- 
-      <para><type>DynamicArray</type> has no
-      <literal>protected</literal> or
-      <literal>private</literal> members.</para>
-     </section>
-    </section>
- 
- 
-    <section id="arrays_ref-views">
-     <title>Views of &array;s</title>
- 
-     <para>UNFINISHED</para>
-    </section>
- 
- 
-    <section id="arrays_ref-assignment">
-     <title>&array; Assignments</title>
- 
-     <para>&pooma; supports assignments to &array;s of other &array;s
-     and scalar values.  QUESTION: Is the following correct?  For the
-     former, the right-hand side array's domain must be at least as
-     large as the left-hand side array's domain.  Corresponding values
-     are copied.  Assigning a scalar value to an array ensures all the
-     array elements have the same scalar value.</para>
- 
-     <para>UNFINISHED: Add a table containing assignment operators
-     found one lines 2097&ndash;2202.</para>
-    </section>
- 
- 
-    <section id="arrays_ref-print">
-     <title>Printing &array;s</title>
- 
-     <para>&array;s support output to but not input from IO streams.
-     In particular, output to <type>ostream</type>s and file streams is
-     supported.</para>
- 
-     <para>Add a table, using <filename
-     class="headerfile">src/Array/Array.h</filename>, lines
-     2408&ndash;2421.  See the implementation in <filename
-     class="headerfile">src/Array/PrintArray.h</filename>.</para>
- 
-     <para>QUESTION: How does one print a &dynamicarray;.</para>
-    </section>
- 
- 
-    <section>
-     <title>Expressions Involving &array;s</title>
- 
-     <para>In &pooma;, expressions may contain entire &array;s.  That
-     is, &array;s are first-class objects with respect to expressions.
-     For example, given &array;s <varname>a</varname> and
-     <varname>b</varname>, the expression <literal>a + b</literal>
-     is equivalent to an array containing the element-wise sum of the
-     two arrays.</para>
- 
-     <para>Any finite number of the operators listed below can be used
-     in an expression.  The precedence and order of operation is the
-     same as with ordinary built-in types.</para>
- 
-     <para>QUESTION: Do &field;s also support the same set of
-     operations?</para>
- 
-     <para>QUESTION: Some operations in <filename
- 						 class="headerfile">src/Field/FieldOperators.h</filename> use both
-     &array; and &field;.  Do we list them here or in the &field;
-     section or both or somewhere else?</para>
- 
-     <para>In the table below, &array; supplants the exact return types
-     because they are complicated and rarely need to be explicitly
-     written down.</para>
- 
-     <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	   orient="port" pgwide="0">
-      <title>Operators on &array;</title>
- 
-      <tgroup cols="2" align="left">
-       <thead>
-        <row>
- 	<entry>Operator</entry>
- 	<entry>Value</entry>
-        </row>
-       </thead>
-       <tbody valign="top">
-        <row>
- 	<entry>
-           <funcsynopsis>
- 	  <funcprototype>
- 	   <funcdef>Array <function>acos</function></funcdef>
- 	   <paramdef>const <parameter>Array&lt;Dim,T,EngineTag&gt;& a</parameter></paramdef>
- 	  </funcprototype>
- 	 </funcsynopsis>
-          </entry>
- 	<entry><para>an array containing the element-wise inverse
-          cosine of the array <parameter>a</parameter></para></entry>
-        </row>
-        <row>
- 	<entry>ADD ALL other operators appearing in <filename
- 							      class="headerfile">src/Array/ArrayOperators.h</filename>,
-         <filename
- 		  class="headerfile">src/Array/ArrayOperatorSpecializations.h</filename>,
-         <filename
- 		  class="headerfile">src/Array/PoomaArrayOperators.h</filename>,
-         and <filename
- 		      class="headerfile">src/Array/VectorArrayOperators.h</filename>.</entry>
-        </row>
-       </tbody>
-      </tgroup>
-     </table>
- 
-     <para>FINISH: Write one or two examples or refer to ones
-     previously in the text.</para>
-    </section>
- 
- 
-    <section id="arrays_ref-reductions">
-     <title>Reducing All &array; Elements to One Value</title>
- 
-     <para>These reduction functions repeatedly apply a binary
-     operation to all array elements to yield a value.  These functions
-     are similar to the Standard Template Library's
-     <function>accumulate</function> function.  For example,
-     <function>sum</function> repeatedly applies the binary plus
-     operator to all array elements, yielding the sum of all array
-     elements.</para>
- 
-     <para>FINISH: What order of operation, if any, is
-     guaranteed?</para>
- 
-     <para>FINISH: Add a table of the functions in <filename
- 							    class="headerfile">src/Array/Reductions.h</filename>.</para>
- 
-     <para>How does one use one's own binary function?  See <filename
-     class="headerfile">src/Engine/Reduction.h</filename>.</para>
-    </section>
- 
- 
-    <section id="arrays_ref-utilities">
-     <title>Utility Functions</title>
- 
-     <section id="arrays_ref-utilities-compression">
-      <title>Compressed Data</title>
- 
-      <para>Add a table containing
-      <function>elementsCompressed</function>,
-      <function>compressed</function>, <function>compress</function>,
-      and <function>uncompress</function>.</para>
-     </section>
- 
- 
-     <section id="arrays_ref-utilities-sizes">
-      <title>Centering Sizes and Number of Materials</title>
- 
-      <para>ADD: a description of <function>numMaterials</function> and
-      <function>centeringSize</function> found in <filename
-      class="headerfile">src/Field/Field.h</filename>.  These functions
-      are meaningless for &array; but are provided for consistency with
-      &field;.</para>
-     </section>
- 
-     <section id="arrays_ref-utilities-subfield">
-      <title>Obtaining Subfields</title>
- 
-      <para>ADD: a description of <function>subField</function> found
-      in <filename class="headerfile">src/Field/Field.h</filename>.
-      This function, meaningless for &array;, is provided for
-      consistency with &field;.</para>
-     </section>
-    </section>
- 
- 
-    <section id="arrays_ref-tmp">
-     <title>TMP: What do we do with these &hellip;? Remove this
-     section.</title>
- 
-     <blockquote>
-      <attribution><filename
-       class="libraryfile">introduction.html</filename></attribution>
- 
-      <para>&pooma; was designed and implemented by scientists working
-      at the Los Alamos National Laboratory's Advanced Computing
-      Laboratory. Between them, these scientists have written and tuned
-      large applications on almost every commercial and experimental
-      supercomputer built in the last two decades. As the technology
-      used in those machines migrates down into departmental computing
-      servers and desktop multiprocessors, &pooma; is a vehicle for its
-      designers' experience to migrate as well. In particular,
-      &pooma;'s authors understand how to get good performance out of
-      modern architectures, with their many processors and multi-level
-      memory hierarchies, and how to handle the subtly complex problems
-      that arise in real-world applications.</para>
-     </blockquote>
- 
-     <para>QUESTION: Do we describe the &leaffunctor;s specialized for
-     &array;s in <filename
-     class="headerfile">src/Array/Array.h</filename> or in the &pete;
-     reference section?  What about the functions in <filename
-     class="headerfile">src/Array/CreateLeaf.h</filename>?</para>
- 
-     <para>QUESTION: What is an <type>EngineFunctor</type>?  We
-     probably should describe it in an analogous way as for
-     &leaffunctor;s.</para>
- 
-     <para>QUESTION: Where do we write about
-     <type>ExpressionTraits</type> for &array;s?</para>
- 
-     <para>QUESTION: Do we describe the <type>ElementProperties</type>
-     specialization at this place or in its section?</para>
- 
-     <para>QUESTION: Do we describe the <type>Patch</type>
-     specialization for &array;s (<filename
-     class="headerfile">src/Array/Array.h</filename>:1300) in this
-     place or in a section for patches?</para>
-    </section>
-   </chapter>
- 
- 
-   <chapter id="fields_ref">
-    <title>&field;s</title>
- 
-    <para>An &array; is a set of values indexed by
-    coordinates, one value per coordinate.  It models the computer
-    science idea of an array.  Similarly, a &field; is a set of values
-    indexed by coordinate.  It models the mathematical and physical
-    idea of a field represented by a grid of rectangular cells, each
-    having at least one value.  A &field;'s functionality is a superset
-    of an &array;'s functionality because:
-     <itemizedlist>
-      <listitem>
-       <para>A &field; is distributed through space so one can compute
-       the distances between cells.</para>
-      </listitem>
-      <listitem>
-       <para>Each cell can hold multiple values.  For example, a
-       rectangular cell can have one value on each of its faces.</para>
-      </listitem>
-      <listitem>
-       <para>Multiple materials can share the same cell.  For example,
-       different values can be stored in the same cell for carbon,
-       oxygen, and nitrogen.</para>
-      </listitem>
-     </itemizedlist>
-    Also, &field;s' values can be related by relations.  Thus, if one
-    field's values change, a dependent field's values can be
-    automatically computed when needed.  FIXME: See also the unfinished
-    works chapter's entry concerning relations and arrays.</para>
- 
-    <para>QUESTION: Should we add a picture comparing and contrasting
-    an array and a field?</para>
- 
-    <para>QUESTION: How much structure can be copied from the &array;
-    chapter?</para>
- 
-    <para>QUESTION: Where is <type>NewMeshTag</type>, defined in
-    <filename class="headerfile">src/Field/Field.h</filename>,
-    used?</para>
- 
-    <para>QUESTION: Do we describe the &leaffunctor;s specialized for
-    &field;s in <filename
-    class="headerfile">src/Field/Field.h</filename> or in the &pete;
-    reference section?  Use the same decision for &array;s.</para>
- 
-    <para>QUESTION: What do the structure and functions in <filename
-    class="headerfile">src/Field/Mesh/PositionFunctions.h</filename>
-    do?</para>
- 
- 
-    <section id="fields_ref-field">
-     <title>The &field; Container</title>
- 
-     <para>ADD: table of template parameters and table of compile-time
-     types and values.</para>
- 
- 
-     <section id="fields_ref-field-constructors">
-      <title>Constructors and Destructors</title>
- 
-      <para>ADD: this section similar to &array;s's constructor and
-      destructor section.</para>
-     </section>
- 
-     <section id="fields_ref-field-initializers">
-      <title>Initializers</title>
- 
-      <para>Add a table.</para>
-     </section>
- 
- 
-     <section id="fields_ref-field-access">
-      <title>Element Access</title>
- 
-      <para>ADD: a table ala &array;.  Be sure to include
-      <literal>all</literal>.</para>
-     </section>
- 
- 
-     <section id="fields_ref-field-component">
-      <title>Component Access</title>
- 
-      <para>ADD: a table ala &array;.</para>
-     </section>
- 
- 
-     <section id="fields_ref-field-subfields">
-      <title>Obtaining Subfields</title>
- 
-      <para>ADD: discussion and a table listing ways to obtain
-       subfields.  Although the implementation may treat subfield views
-       and other field views similarly (?Is this true?), they are
-       conceptually different ideas so we present them
-       separately.</para>
- 
-      <para>See <filename
- 			 class="headerfile">src/Field/Field.h</filename>'s
-       <literal>operator[]</literal>,
-       <literal>subField</literal>, &hellip;,
-       <literal>material</literal>.</para>
-     </section>
- 
- 
-     <section id="fields_ref-field-relations">
-      <title>Supporting Relations</title>
- 
-      <para>ADD: a table with the member functions including
-      <literal>addRelation</literal>,
-      <literal>removeRelations</literal>,
-      <literal>applyRelations</literal>, and
-      <literal>setDirty</literal>.</para>
-     </section>
- 
- 
-     <section id="fields_ref-field-accessors">
-      <title>Accessors</title>
- 
-      <para>ADD: a table using lines like <filename
-      class="headerfile">src/Field/Field.h</filename>:1243&ndash;1333.</para>
-     </section>
- 
- 
-     <section id="fields_ref-field-utilities">
-      <title>Utility Methods</title>
- 
-      <para>ADD: a table including
-       <literal>makeOwnCopy</literal>.</para>
-     </section>
- 
- 
-     <section id="fields_ref-field-implementation">
-      <title>Implementation Details</title>
- 
-      <para>ADD: a table similar to &array;'s.</para>
- 
-     </section>
- 
-    </section>
- 
- 
-    <section id="engines_ref-views">
-     <title>Views of &field;s</title>
- 
-     <para>Be sure to relate to &array; views.  Note only three
-     dimensions are supported.</para>
- 
-     <para>Be sure to describe <literal>f[i]</literal>.  Does this
-     refer to a particular material or a particular value within a
-     cell?  I do not remember.  See <type>SubFieldView</type> in
-     <filename class="headerfile">src/Field/Field.h</filename>.</para>
-    </section>
- 
- 
-    <section id="fields_ref-assignment">
-     <title>&field; Assignments</title>
- 
-     <para>ADD: Describe supported assignments, relating to &array;'s
-     assignments.</para>
- 
-     <para>UNFINISHED: Add a table containing assignment operators
-     found on <filename
- 		       class="headerfile">src/Field/Field.h</filename>:2097&ndash;2202
-     and 1512&ndash;1611.</para>
-    </section>
- 
- 
-    <section id="fields_ref-print">
-     <title>Printing &field;s</title>
- 
-     <para>QUESTION: How similar is this to printing &array;s?</para>
- 
-     <para>&field;s support output to but not input from IO streams.
-     In particular, output to <type>ostream</type>s and file streams is
-     supported.</para>
- 
-     <para>Add a table, using <filename
- 				       class="headerfile">src/Field/Field.h</filename>, lines
-     1996&ndash;2009.  See the implementation in <filename
- 							  class="headerfile">src/Field/PrintField.h</filename>.</para>
-    </section>
- 
- 
-    <section id="fields_ref-reductions">
-     <title>Combining &field; Elements</title>
- 
-     <para>Like &array;s, &field;s support reduction of all elements to
-     one value.  Additionally, the latter supports computing a field's
-     values using field stencils.  QUESTION: How do I describe this
-     with a minimum of jargon?</para>
- 
-     <para>ADD: something similar to &array; reductions.</para>
- 
-     <para>FINISH: Add a table of the functions in <filename
-     class="headerfile">src/Field/FieldReductions.h</filename>.</para>
- 
-     <para>FINISH: Add a table of the functions in <filename
-     class="headerfile">src/Field/DiffOps/FieldOffsetReductions.h</filename>.
-     QUESTION: Why is only <function>sum</function> defined?</para>
-    </section>
- 
- 
-    <section id="fields_ref-expressions">
-     <title>Expressions Involving &field;s</title>
- 
-     <para>Do something similar to &array;'s section.  See the
-     operations defined in <filename
-     class="headerfile">src/Field/FieldOperators.h</filename>,
-     <filename
-     class="headerfile">src/Field/FieldOperatorSpecializations.h</filename>,
-     <filename
-     class="headerfile">src/Field/PoomaFieldOperators.h</filename>, and
-     <filename
-     class="headerfile">src/Field/VectorFieldOperators.h</filename>.</para>
- 
-     <para>Some operations involve both &array; and &field;
-     parameters.  Where do we list them?</para>
-    </section>
- 
- 
-    <section id="fields_ref-stencils">
-     <title>&field; Stencils: Faster, Local Computations</title>
- 
-     <para>ADD: a description of a stencil.  Why is it needed?  How
-     does a user use it?  How does a user know when to use one?  Add
-     documentation of the material from <filename
-     class="headerfile">src/Field/DiffOps/FieldStencil.h</filename>.</para>
- 
-     <para>How is <type>FieldShiftEngine</type> used by &field;
-     stencils?  Should it be described here or in the &engine; section?
-     See the the code in <filename
-     class="headerfile">src/Field/DiffOps/FieldShiftEngine.h</filename>.</para>
-    </section>
- 
- 
-    <section>
-     <title>Cell Volumes, Face Areas, Edge Lengths, Normals</title>
- 
-     <para>ADD: a description of these functions.  See <filename
-     class="headerfile">src/Field/Mesh/MeshFunctions.h</filename>.
-     These are initialized in, e.g., <filename
-     class="headerfile">src/Field/Mesh/UniformRectilinearMesh.h</filename>.
-     Note that these do not work for <type>NoMesh</type>.</para>
-    </section>
- 
- 
-    <section id="fields_ref-div">
-     <title>Divergence Operators</title>
- 
-     <para>ADD: a table having divergence operators, explaining the
-     current restrictions imposed by what is implemented.  See
-     <filename class="headerfile">src/Field/DiffOps/Div.h</filename>
-     and <filename
-     class="headerfile">src/Field/DiffOps/Div.UR.h</filename>.  What
-     restrictions does <quote>UR</quote> (mesh) connote?</para>
-    </section>
- 
- 
-    <section id="fields_ref-utilities">
-     <title>Utility Functions</title>
- 
-     <section id="fields_ref-utilities-compression">
-      <title>Compressed Data</title>
- 
-      <para>Add a table containing
-      <function>elementsCompressed</function>,
-      <function>compressed</function>, <function>compress</function>,
-      and <function>uncompress</function>.</para>
-     </section>
- 
- 
-     <section id="fields_ref-utilities-sizes">
-      <title>Centering Sizes and Number of Materials</title>
- 
-      <para>ADD: a description of <function>numMaterials</function> and
-      <function>centeringSize</function> found in <filename
-      class="headerfile">src/Field/Field.h</filename>.</para>
- 
-      <para>QUESTION: How do these relate to any method functions?</para>
-     </section>
- 
- 
-     <section id="fields_ref-utilities-subfield">
-      <title>Obtaining Subfields</title>
- 
-      <para>ADD: a description of <function>subField</function> found
-      in <filename
-      class="headerfile">src/Field/Field.h</filename>.</para>
-     </section>
- 
-    </section>
- 
- 
-    <section id="fields_ref-centerings">
-     <title>&field; Centerings</title>
- 
-     <para>DO: Describe the purpose of a centering and its definition.
-     Describe the ability to obtain canonical centerings.  Explain how
-     to construct a unique centering.  See <filename
-     class="headerfile">src/Field/FieldDentering.h</filename>.</para>
-    </section>
- 
- 
-    <section id="fields_ref-fieldoffsets">
-     <title>Relative &field; Positions</title>
- 
-     <para>Permit specifying field positions relative to a field
-     location.  Describe <type>FieldOffset</type> and
-     <type>FieldOffsetList</type>.  See <filename
-     class="headerfile">src/Field/FieldOffset.h</filename></para>
-    </section>
- 
- 
-    <section id="fields_ref-nearestneighbors">
-     <title>Computing Close-by Field Positions</title>
- 
-     <para>Given a field location, return the set of field locations
-     that are closest using ?Manhattan? distance.  See <filename
-     class="headerfile">src/Field/NearestNeighbors.h</filename>.</para>
-    </section>
- 
- 
-    <section id="fields_ref-mesh">
-     <title>Mesh ???</title>
- 
-     <para>Unlike &array;s, &field;s are distributed throughout space
-     so distances between values within the &field can be computed.  A
-     &field;'s mesh stores this spatial distribution.</para>
- 
-     <para>QUESTION: What do we need to write about meshes?  What is
-     unimportant implementation and what should be described in this
-     reference section?</para>
- 
-     <para>QUESTION: Where in here should emphasize vertex, not cell,
-     positions?  <quote>VERTEX</quote> appears repeatedly in <filename
-     class="headerfile">src/Field/Mesh/NoMesh.h</filename>.</para>
- 
-     <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	   orient="port" pgwide="0">
-      <title>Mesh Types</title>
- 
-      <tgroup cols="2" align="left">
-       <thead>
-        <row>
- 	<entry>Mesh Type</entry>
- 	<entry>Description</entry>
-        </row>
-       </thead>
-       <tbody valign="top">
-        <row>
- 	<entry><type>NoMesh&lt;Dim&gt;</type></entry>
- 	<entry><para>no physical spacing, causing a &field; to mimic
- 	an &array; with multiple engines.</para></entry>
-        </row>
-        <row>
- 	<entry><type>UniformRectilinearMesh&lt;Dim,T&gt;</type></entry>
- 	<entry><para>physical spacing formed by the Cartesian product
- 	of ????.</para></entry>
-        </row>
-       </tbody>
-      </tgroup>
-     </table>
- 
- 
-     <section id="fields_ref-mesh-accessors">
-      <title>Mesh Accessors</title>
- 
-      <para>ADD: a table listing accessors, explaining the difference
-      between (physical and total) and (cell and vertex) domains.  See
-      <filename class="headerfile">src/Field/Mesh/NoMesh.h</filename>.
-      Also, include <function>spacings</function> and
-      <function>origin</function> in <filename
-      class="headerfile">src/Field/Mesh/UniformRectilinearMesh.h</filename>.
-      Note <type>NoMesh</type> does not provide the latter two.</para>
-     </section>
- 
-    </section>
- 
- 
-    <section id="fields_ref-tmp">
-     <title>TMP: What do we do with these &hellip;? Remove this
-     section.</title>
- 
-     <para>QUESTION: Do we describe the <type>Patch</type>
-     specialization for &field; at this place or in some common place?
-     Follow &array;'s lead.</para>
- 
-     <para>QUESTION: Where do we describe <type>CreateLeaf</type> and
-     <type>MakeFieldReturn</type> in <filename
-     class="headerfile">src/Field/FieldCreateLeaf.h</filename> and
-     <filename
-     class="headerfile">src/Field/FieldMakeReturn.h</filename>.</para>
- 
-     <para>QUESTION: What do we do with <type>FieldEnginePatch</type>
-     in <filename
-     class="headerfile">src/Field/FieldEngine/FieldEnginePatch.h</filename>.</para>
-    </section>
-   </chapter>
- 
- 
-   <chapter id="engines_ref">
-    <title>&engine;s</title>
- 
-    <para>From a user's point of view, a container makes data available
-    for reading and writing.  In fact, the container's &engine; stores
-    the data or, if the data is computed, performs a computation to
-    yield the data.</para>
- 
-    <para>FINISH: Introduce the various types of engines.  Add a table
-    with a short description of each engine type.</para>
- 
-    <para>FINISH: First, we specify a generic &engine;'s interface.
-    Then, we present &engine; specializations.</para>
-    
-    <table frame="none" colsep="0" rowsep="0" tocentry="1"
- 	  orient="port" pgwide="0">
-     <title>Types of &engine;s</title>
- 
-     <tgroup cols="3" align="left">
-      <thead>
-       <row>
-        <entry>Engine Type</entry>
-        <entry>Engine Tag</entry>
-        <entry>Description</entry>
-       </row>
-      </thead>
-      <tbody valign="top">
-       <row>
-        <entry><para>Brick</para></entry>
-        <entry><para><literal>Brick</literal></para></entry>
-        <entry><para>Explicitly store all elements in, e.g., a &cc;
- 	array.</para></entry>
-       </row>
-       <row>
-        <entry><para>Compressible</para></entry>
-        <entry><para><literal>CompressibleBrick</literal></para></entry>
-        <entry><para>If all values are the same, use constant storage
- 	for that single value.  Otherwise, explicitly store all
- 	elements.</para></entry>
-       </row>
-       <row>
-        <entry><para>Constant</para></entry>
-        <entry><para><literal>ConstantFunction</literal></para></entry>
-        <entry><para>Returns the same constant value for all
-        indices.</para></entry>
-       </row>
-       <row>
-        <entry><para>Dynamic</para></entry>
-        <entry><para><literal>Dynamic</literal></para></entry>
-        <entry><para>Manages a contiguous, local, one-dimensional,
-        dynamically resizable block of data.</para></entry>
-       </row>
-       <row>
-        <entry><para>Component Forwarding</para></entry>
-        <entry><para><literal>CompFwd&lt;EngineTag,
-        Components&gt;</literal></para></entry>
-        <entry><para>Returns the specified components from
-        <literal>EngineTag</literal>'s engine.  Components are
-        <quote>pieces</quote> of multi-value elements such as vectors
-        and tensors.</para></entry>
-       </row>
-       <row>
-        <entry><para>Expression</para></entry>
-        <entry><para><literal>ExpressionTag&lt;Expr&gt;</literal></para></entry>
-        <entry><para>Returns the value of the specified &pete;
-        expression.</para></entry>
-       </row>
-       <row>
-        <entry><para>Index Function</para></entry>
-        <entry><para><literal>IndexFunction&lt;Functor&gt;</literal></para></entry>
-        <entry><para>Makes the function
-        <literal>Functor</literal>accepting indices mimic an
-        array.</para></entry>
-       </row>
-       <row>
-        <entry><para>MultiPatch</para></entry>
-        <entry><para><literal>MultiPatch&lt;LayoutTag,PatchTag&gt;</literal></para></entry>
-        <entry><para>Support distributed computation using several
-        processors (???contexts???).  <literal>LayoutTag</literal>
-        indicates how the entire array is distributed among the
-        processors.  Each processor uses a <literal>PatchTag</literal>
-        engine.</para></entry>
-       </row>
-       <row>
-        <entry><para>Remote</para></entry>
-        <entry><para><literal>Remote&lt;EngineTag&gt;</literal></para></entry>
-        <entry><para>unknown</para></entry>
-       </row>
-       <row>
-        <entry><para>Remote Dynamic</para></entry>
-        <entry><para><literal>Remote&lt;Dynamic&gt;</literal></para></entry>
-        <entry><para>unknown: specialization</para></entry>
-       </row>
-       <row>
-        <entry><para>Stencil</para></entry>
-        <entry><para><literal>StencilEngine&lt;Function,
-        Expression&gt;</literal></para></entry>
-        <entry><para>Returns values computed by applying the
-        user-specified function to sets of contiguous values in the
-        given engine or container.  Compare with user function
-        engines.</para></entry>
-       </row>
-       <row>
-        <entry><para>User Function</para></entry>
-        <entry><para><literal>UserFunctionEngine&lt;UserFunction,Expression&gt;</literal></para></entry>
-        <entry><para> Returns values computed by applying the
-        user-specified function to the given engine or container.
-        QUESTION: Is the following claim correct? For each returned
-        value, only one value from the engine or container is
-        used.</para></entry>
-       </row>
-      </tbody>
-     </tgroup>
-    </table>
- 
-    <para>QUESTION: Where do we describe views?</para>
- 
-    <para>QUESTION: What does <type>NewEngine</type> do?  Should it be
-     described when describing views?  Should it be omitted as an
-     implementation detail?</para>
- 
-    <para>QUESTION: Where do we describe &engine; patches found in
-    <filename class="headerfile">src/Engine/EnginePatch.h</filename>?
-    All patch data in a separate chapter or engine-specific pieces in
-    this chapter?</para>
- 
-    <para>QUESTION: What is <function>notifyEngineWrite</function>?
-    See also <filename
- 		      class="headerfile">src/Engine/NotifyEngineWrite.h</filename>.</para>
- 
-    <para>QUESTION: What aspect of MultiPatch uses <type>IsValid</type> in
-    <filename
- 	     class="headerfile">src/Engine/IsValidLocation.h</filename>?</para>
- 
-    <para>QUESTION: Who uses intersections?  Where should this be
-    described?  See <filename
- 			     class="headerfile">src/Engine/Intersector.h</filename>, <filename
- 											       class="headerfile">src/Engine/IntersectEngine.h</filename>, and
-    <filename
- 	     class="headerfile">src/Engine/ViewEngine.h</filename>.</para>
- 
-    <section id="engines_ref-compile_time_interface">
-     <title>&engine; Compile-Time Interface</title>
- 
-     <para>ADD: a table of template parameters ala &array;.  ADD:
-     compile-time types and values.</para>
-    </section>
- 
- 
-    <section id="engines_ref-constructors">
-     <title>Constructors and Destructors</title>
- 
-     <para>ADD: a table of constructors and destructors ala
-     &array;'s.</para>
-    </section>
- 
- 
-    <section id="engines_ref-access">
-     <title>Element Access</title>
- 
-     <para>ADD: a table with <literal>read</literal> and
-     <literal>operator()</literal>.</para>
-    </section>
- 
- 
-    <section id="engines_ref-accessors">
-     <title>Accessors</title>
- 
-     <para>ADD: a table of accessors.</para>
-    </section>
- 
- 
-    <section id="engines_ref-assignments">
-     <title>&engine; Assignments</title>
- 
-     <para>similar to &array;'s assignments.  shallow copies.  ADD: a
-     table with one entry</para>
-    </section>
- 
- 
-    <section id="engines_ref-utilities">
-     <title>Utility Methods</title>
- 
-     <para>ADD: a table including
-     <literal>makeOwnCopy</literal>.</para>
- 
-     <para>QUESTION: What are <literal>dataObject</literal>,
-     <literal>isShared</literal>, and related methods?</para>
-    </section>
- 
- 
-    <section id="engines_ref-implementation">
-     <title>Implementation Details</title>
- 
-     <para>ADD: this section.  Explain that
-     <varname>dataBlock_m</varname> and <varname>data_m</varname> point
-     to the same place.  The latter speeds access, but what is the
-     purpose of the former?</para>
-    </section>
- 
- 
-    <section id="engines_ref-brick">
-     <title>Brick and BrickView Engines</title>
- 
-     <para>ADD: description of what a brick means.  ADD: whatever
-     specializations the class has, e.g.,
-     <literal>offset</literal>.</para>
- 
-     <para>QUESTION: What does <type>DoubleSliceHelper</type> do?</para>
-    </section>
- 
- 
-    <section id="engines_ref-compressible">
-     <title>Compressible Brick and BrickView Engines</title>
- 
-     <para>ADD this.</para>
-    </section>
- 
- 
-    <section id="engines_ref-dynamic">
-     <title>Dynamic and DynamicView Engines:</title>
- 
-     <para>ADD this.  Manages a contiguous, local, resizable, 1D block
-     of data.</para>
-    </section>
- 
- 
-    <section id="engines_ref-components">
-     <title>Component Engines</title>
- 
-     <para>I believe these implement array component-forwarding.  See
-     <filename
- 	      class="headerfile">src/Engine/ForwardingEngine.h</filename>.</para>
-    </section>
- 
- 
-    <section id="engines_ref-expressions">
-     <title>Expression Engines</title>
- 
-     <para>Should this be described in the &pete; section?  Unlikely.
-     See <filename
- 		  class="headerfile">src/Engine/ExpressionEngine.h</filename>.</para>
-    </section>
- 
- 
-    <section id="engines_ref-enginefunctor">
-     <title>&engine; Functors</title>
- 
-     <para>QUESTION: What is an <type>EngineFunctor</type>?  Should it
-     have its own section?  See <filename
- 					 class="headerfile">src/Engine/EngineFunctor.h</filename>.</para>
-    </section>
- 
- 
-    <section id="engines_ref-fieldengines">
-     <title><type>FieldEngine</type>: A Hierarchy of &engine;s</title>
- 
-     <para>A &field; consists of a hierarchy of materials and
-     centerings.  These are implemented using a hierarchy of engines.
-     See <filename
- 		  class="headerfile">src/Field/FieldEngine/FieldEngine.h</filename>
-     and <filename
- 		  class="headerfile">src/Field/FieldEngine/FieldEngine.ExprEngine.h</filename>.</para>
-    </section>
-   </chapter>
- 
- 
-   <chapter id="benchmarks_ref">
-    <title>&benchmark; Programs</title>
- 
-    <para>Explain how to use &benchmark; programs, especially the
-    options.  Explain how to write a &benchmark; program.  See also
-    <filename class="headerfile">src/Utilities/Benchmark.h</filename>
-    and <filename
-    class="libraryfile">src/Utilities/Benchmark.cmpl.cpp</filename>.</para>
- 
-   </chapter>
- 
- 
-   <chapter id="layouts_ref">
-    <title>Layouts and Partitions: Distribute Computation Among
-    Contexts</title>
- 
-    <para>What is the difference between <type>ReplicatedTag</type> and
-    <type>DistributedTag</type>?</para>
- 
-   </chapter>
- 
- 
-   <chapter id="pete_ref">
-    <title>&pete;: Evaluating Parallel Expressions</title>
- 
-    <section>
-     <title>UNKNOWN</title>
- 
-     <section id="pete_ref-unknown-leaf-tags">
-      <title>Leaf Tag Classes</title>
- 
-      <para><type>NotifyPreReadTag</type> indicates a term is about to
-      be read.  Why is this needed?  Defined in <filename
-      class="headerfile">src/Utilities/NotifyPreRead.h</filename>.</para>
-     </section>
-    </section>
- 
-   </chapter>
- 
- 
-   <chapter id="views_ref">
-    <title>Views</title>
- 
-    <para>QUESTION: Should this have its own chapter or be part of a
-    container chapter?</para>
- 
-    <para>Describe <type>View0</type>, <type>View1</type>, &hellip;,
-    <type>View7</type> and <type>View1Implementation</type>.</para>
- 
-    <para>QUESTION: What causes the need for <type>AltView0</type> and
-    <type>AltComponentView</type>?</para>
- 
-    <para>Be sure to describe <type>ComponentView</type> in the same
-    place.  This is specialized for &array;s in <filename
-    class="headerfile">src/Array/Array.h</filename>:1323&ndash;1382.</para>
- 
-    <section>
-     <title><type>ViewIndexer&lt;Dim,Dim2&gt;</type></title>
- 
-     <para>Defined in <filename
-     class="headerfile">src/Utilities/ViewIndexer.h</filename>, this
-     type translates indices between a domain and a view of it.</para>
-    </section>
-   </chapter>
- 
-   <chapter id="threads_ref">
-    <title>Threads</title>
- 
-    <para>Perhaps include information in <filename
-    class="headerfile">src/Engine/DataObject.h</filename>.</para>
- 
-    <para>&pooma; options include UNFINISHED</para>
- 
-   </chapter>
- 
- 
-   <chapter id="utilities_ref">
-    <title>Utility Types</title>
- 
-    <para>TMP: What is a good order?</para>
- 
-    <section id="utilities_ref-options">
-     <title><type>Options</type>: Varying Run-Time Execution</title>
- 
-     <para>Each &pooma; executable has a <type>Options</type> object,
-     created by <function>Pooma::initialize</function>, storing
-     run-time configurable values found in <varname>argv</varname>.
-     Default options are found in
-     <literal>Options::usage</literal>.</para>
- 
-     <para>See <filename
-     class="headerfile">src/Utilities/Options.h</filename> and
-     <filename
-     class="libraryfile">src/Utilities/Options.cmpl.cpp</filename>.</para>
- 
-     <para>Scatter the specific options to other parts of the
-     manual.</para>
-    </section>
- 
-    <section id="utilities_ref-assertions">
-     <title>Check Correctness: <type>CTAssert</type>,
-     <type>PAssert</type>, <type>PInsist</type>,
-     <type>SameType</type></title>
- 
-     <para>Assertions ensure program invariants are obeyed.
-     <type>CTAssert</type>, checked at compile time, incur no run-time
-     cost.  <type>PAssert</type> and <type>PInsist</type> are checked
-     to run-time, the latter producing an explanatory message if the
-     assertion fails.  Compiling with <envar>NOCTAssert</envar> and
-     <envar>NOPTAssert</envar> disable these checks.  Compiling with just
-     <envar>NOPTAssert</envar> disables only the run-time checks.</para>
- 
-     <para><type>SameType</type> ensures, at compile-time, two types
-     are the same.</para>
- 
-     <para>These are implemented in <filename
-     class="headerfile">src/Utilities/PAssert.h</filename> and
-     <filename
-     class="libraryfile">src/Utilities/PAssert.cmpl.cpp</filename>.</para>
-    </section>
- 
-    <section id="utilities_ref-clock">
-     <title><type>Clock</type>: Measuring a Program's Execution Time</title>
- 
-     <para>See <filename
-     class="headerfile">src/Utilities/Clock.h</filename>.</para>
-    </section>
- 
- 
-    <section id="utilities_ref-smart_pointers">
-     <title>Smart Pointers: <type>RefCountedPtr</type>,
-     <type>RefCountedBlockPtr</type>, and
-     <type>DataBlockPtr</type></title>
- 
-     <para>See <filename
-     class="headerfile">src/Utilities/{RefCountedPtr,RefCountedBlockPtr,DataBlockPtr}.h</filename>.
-     <filename class="headerfile">src/Utilities/RefCounted.h</filename>
-     helps implement it.  <type>DataBlockPtr</type> uses
-     &smarts;.</para>
-    </section>
- 
-    <section id="utilities_ref-inform">
-     <title><type>Inform</type>: Formatted Output for Multi-context
-     Execution</title>
- 
-     <para>See <filename
-     class="headerfile">src/Utilities/Inform.h</filename> and <filename
-     class="libraryfile">src/Utilities/Inform.cmpl.cpp</filename>.</para>
-    </section>
- 
-    <section id="utilities_ref-statistics">
-     <title><type>Statistics</type>: Report &pooma; Execution Statistics</title>
- 
-     <para>Collect and print execution statistics.  Defined in
-     <filename
-     class="headerfile">src/Utilities/Statistics.h</filename>.</para>
-    </section>
- 
-    <section id="utilities_ref-random_numbers">
-     <title>Random Numbers: <type>Unique</type></title>
- 
-     <para>See <filename
-     class="headerfile">src/Utilities/Unique.h</filename>.</para>
-    </section>
-   </chapter>
- 
- 
-   <chapter id="implementation_types_ref">
-    <title>Types for Implementing &pooma;</title>
- 
-    <para>TMP: What is a good order?</para>
- 
-    <para>Describe types defined to implement &pooma; but that users do
-    not directly use.  This chapter has lower priority than other
-    chapters since users (hopefully) do not need to know about these
-    classes.</para>
- 
-    <section id="implementation_types_ref-tester">
-     <title><type>Tester</type>: Check Implementation Correctness</title>
- 
-     <para>&pooma; implementation test programs frequently consist of a
-     series of operations followed by correctness checks.  The
-     <type>Tester</type> object supports these tests, returning a
-     boolean whether all the correctness checks yield true.  Under
-     verbose output, messages are printed for each test.  See <filename
-     class="headerfile">src/Utilities/Tester.h</filename>.</para>
-    </section>
- 
-    <section id="implementation_types_ref-elementproperties">
-     <title><type>ElementProperties&lt;T&gt;</type>: Properties a Type
-     Supports</title>
- 
-     <para>This traits class permits optimizations in other templated
-     classes.  See <filename
-     class="headerfile">src/Utilities/ElementProperties.h</filename>.</para>
- 
-    </section>
- 
-    <section id="implementation_types_ref-typeinfo">
-     <title><type>TypeInfo&lt;T&gt;</type>: Print a String Describing
-     the Type</title>
- 
-     <para>Print a string describing the type.  Defined in <filename
-     class="headerfile">src/Utilities/TypeInfo.h</filename>.  It is
-     specialized for other types in other files, e.g., <filename
-     class="headerfile">src/Engine/EngineTypeInfo.h</filename> and
-     <filename class="headerfile">src/Field/FieldTypeInfo.h</filename>.
-     Is this a compile-time version of RTTI?</para>
-    </section>
- 
-    <section id="implementation_types_ref-looputils">
-     <title><type>LoopUtils</type>: Loop Computations at Compile Time</title>
- 
-     <para>At compile time, <type>LoopUtils</type> supports copying
-     between arrays and computing the dot product of arrays.  See
-     <filename
- 	      class="headerfile">src/Utilities/MetaProg.h</filename>.</para>
-    </section>
- 
-    <section id="implementation_types_ref-modelelement">
-     <title><type>ModelElement&lt;T&gt;</type>: Wrap a Type</title>
- 
-     <para>A wrapper class used to differentiate overloaded functions.
-     Defined in <filename
-     class="headerfile">src/Utilities/ModelElement.h</filename>.  Used
-     only by &array; and <type>DynamicArray</type>.</para>
-    </section>
- 
-    <section id="implementation_types_ref-wrappedint">
-     <title><type>WrappedInt&lt;int&gt;</type>: Wrap a Number</title>
- 
-     <para>A wrapper class used to differentiate overloaded functions
-     among different integers.  Defined in <filename
-     class="headerfile">src/Utilities/WrappedInt.h</filename>.  Is this
-     class deprecated?  Is it even necessary?</para>
-    </section>
-    
-    <section id="implementation_types_ref-empty_classes">
-     <title>Supporting Empty Classes</title>
- 
-     <para>The <type>NoInit</type> tag class indicates certain
-     initializations should be skipped.  Defined in <filename
-     class="headerfile">src/Utilities/NoInit.h</filename>.</para>
- 
-     <para>FIXME: Should be macro, not function.
-     <function>POOMA_PURIFY_CONSTRUCTORS</function> generates an empty
-     constructor, copy constructor, and destructor to avoid &purify;
-     warnings.  Defined in <filename
-     class="headerfile">src/Utilities/PurifyConstructors.h</filename>.</para>
- 
-    </section>
- 
-    <section id="implementation_types_ref-pool">
-     <title><type>Pooled&lt;T&gt;</type>: Fast Memory Allocation of
-     Small Blocks</title>
- 
-     <para><type>Pooled&lt;T&gt;</type> speeds allocation and
-     deallocation of memory blocks for small objects with
-     type&nbsp;<type>T</type>.  Defined in <filename
-     class="headerfile">src/Utilities/Pooled.h</filename>, it is
-     implemented in <filename
-     class="headerfile">src/Utilities/Pool.h</filename> and <filename
-     class="libraryfile">src/Utilities/Pool.cmpl.cpp</filename>.
-     <filename class="headerfile">src/Utilities/StaticPool.h</filename>
-     no longer seems to be used.</para>
-    </section>
- 
-    <section id="implementation_types_ref-uninitialized_vector">
-     <title><type>UninitializedVector&lt;T,Dim&gt;</type>: Create
-     Without Initializing</title>
- 
-     <para>This class optimizes creation of an array of objects by
-     avoiding running the default constructors.  Later initialization
-     can occur, perhaps using a loop that can be unrolled.  Defined in
-     <filename
-     class="headerfile">src/Utilities/UninitializedVector.h</filename>,
-     this is used only by <type>DomainTraits</type>.</para>
-    </section>
-   </chapter>
- 
-   <chapter id="implementation_algorithms_ref">
-    <title>Algorithms for Implementing &pooma;</title>
- 
-    <para>In <filename>src/Utilities/algorithms.h</filename>,
-    <function>copy</function>, <function>delete_back</function>, and
-    <function>delete_shiftup</function> provide additional algorithms
-    using iterators.</para>
-   </chapter>
- 
- 
-   <chapter id="where_place_these_ref">
-    <title>TMP: Where do we describe these files?</title>
- 
-    <itemizedlist>
-     <listitem>
-      <para><filename
-      class="headerfile">src/Utilities/Conform.h</filename>: tag for
-      checking whether terms in expression have conforming
-      domains</para>
-     </listitem>
- 
-     <listitem>
-      <para><filename
-      class="headerfile">src/Utilities/DerefIterator.h</filename>:
-      <type>DerefIterator&lt;T&gt;</type> and
-      <type>ConstDerefIterator&lt;T&gt;</type> automatically
-      dereference themselves to maintain <literal>const</literal>
-      correctness.</para>
-     </listitem>
- 
-     <listitem>
-      <para><filename
-      class="headerfile">src/Utilities/Observable.h</filename>,
-      <filename class="headerfile">src/Utilities/Observer.h</filename>,
-      and <filename
-      class="headerfile">src/Utilities/ObserverEvent.h</filename>:
-      <type>Observable&lt;T&gt;</type>,
-      <type>SingleObserveable&lt;T&gt;</type>,
-      <type>Observer&lt;T&gt;</type>, and <type>ObserverEvent</type>
-      implement the observer pattern.  What is the observer pattern?
-      Where is this used in the code?</para>
-     </listitem>
-    </itemizedlist>
- 
-   </chapter>
- 
- 
-   <chapter id="needed_reference_items_ref">
-    <title>TMP: Items to Discuss in Reference Manual</title>
- 
-    <itemizedlist>
-     <listitem>
-      <para>Discuss &options; and related material.  Add developer
-      command-line options listed in <filename
-      class="libraryfile">Utilities/Options.cmpl.cpp</filename> and also
-      possibly <parameter class="option">&dashdash;pooma-threads
-      <replaceable>n</replaceable></parameter>.</para>
-     </listitem>
-    </itemizedlist>
-   </chapter>
-  </part>
- ]]>  <!-- end unfinished -->
- 
- 
- <![%unfinished;[
-  <appendix id="future_development">
-   <title>Future Development</title>
- 
-   <section id="future_development-particles">
-    <title>Particles</title>
- 
-    <para><filename
-    class="libraryfile">docs/ParticlesDoc.txt</filename> has
-    out-of-date information.</para>
- 
-    <para>See Section&nbsp;3.2.3 of
-    <filename>papers/pooma.ps</filename> for an out-of-date
-    description.</para>
- 
-    <para><filename>papers/jvwr.ps</filename> concerns mainly
-    particles.  <filename>papers/8thSIAMPOOMAParticles.pdf</filename>,
-    by Julian Cummings and Bill Humphrey, concerns parallel particle
-    simulations.  <filename>papers/iscope98linac.pdf</filename>
-    describes a particle beam simulation using &pooma;; it mainly
-    concerns particles.</para>
- 
-    <section>
-     <title>Particles</title>
- 
-     <para>Do we want to include such a section?</para>
- 
-     <para>Section&nbsp;3, "Sample Applications" of
-     <filename>papers/SiamOO98_paper.ps</filename> describes porting a
-     particle program written using High-Performance &fortran; to
-     &pooma; and presumably why particles were added to &pooma;.  It
-     also describes <application>MC++</application>, a Monte Carlo
-     neutron transport code.</para>
- 
-    </section>
- 
-   </section>
- 
- 
-   <section id="future_development-composition_engine">
-    <title>Composition of &engine;s</title>
- 
-    <para>The i,j-th element of the composition
-    <varname>a</varname>&compfn;<varname>b</varname> of two arrays
-    <varname>a</varname> and <varname>b</varname> equals a(b(i,j)).
-    The composition engine tagged <literal>IndirectionTag&lt;Array1,
-    Array2&gt;</literal>, defined in <filename
- 					      class="headerfile">src/Engine/IndirectionEngine.h</filename> is
-    unfinished.</para>
-   </section>
- 
- 
-   <section id="future_development-container_consistency">
-    <title>Improving Consistency of Container Interfaces</title>
- 
-    <section id="future_development-container_consistency-array_relations">
-     <title>Relations for &array;s</title>
- 
-     <para>Do &array;s currently support relations?  If not, why not?
-    Should they be added?</para>
-    </section>
- 
-    <section id="future_development-container_consistency-dimensions">
-     <title>Supporting the Same Number of Dimensions</title>
- 
-     <para>&array; and &field; should support the same maximum number
-     of dimensions.  Currently, &array;s support seven dimensions and
-     &field;s support only three.  By definition, &dynamicarray;
-     supports only one dimension.</para>
- 
-     <para>Relations for &array;s.</para>
- 
-     <para>External guards for &array;s.</para>
- 
-     <para>QUESTION: What is <quote>tiny</quote> about &matrix;?  Should
-     they be renamed?</para>
-    </section>
- 
-   </section>
- 
- 
-   <section id="future_development-where">
-    <title><function>where</function> Proxies</title>
- 
-    <para>QUESTION: Do we even discuss this broken
-    <quote>feature</quote>?  Where is it used?  Some related code is in
-    <filename>src/Array/Array.h</filename>:2511&ndash;2520.</para>
-   </section>
- 
- 
-   <section id="future_development-distributed_input">
-    <title>Easing Input for Distributed Programs</title>
- 
-    <para>Currently, standard input to distributed programs is not
-    supported.  Instead input can be passed via command-line arguments,
-    which are replicated to each context.  &inform; streams support for
-    input could be added.  For context&nbsp;0, standard input could be
-    used.  Other contexts would use a <type>RemoteProxy</type> to
-    distribute the value to the other contests.  See <filename
-    class="headerfile">src/Engine/RemoteEngine.h</filename> for example
-    uses of <type>RemoteProxy</type>.</para>
-   </section>
- 
- 
-   <section id="future_development-cheetah_pooma_consistency">
-    <title>Improving Consistency Between &pooma; and &cheetah;</title>
- 
-    <para>Improve the consistency between &cheetah;'s and &pooma;'s
-    configurations.  Currently, their defaults differ regarding
-    &cc; exceptions and static/shared libraries.</para>
-   </section>
- 
- 
-   <section id="future_development-long_term">
-    <title>Very Long Term Development Ideas</title>
- 
-    <para>Describe how to write a new configuration file.</para>
-   </section>
- 
-  </appendix>
- ]]>  <!-- end unfinished -->
- 
- 
-  <appendix id="installation">
-   <title>Obtaining and Installing &pooma;</title>
- 
- <![%temporary;[
-   <para>In <xref linkend="tutorial-installation"></xref>, we described
-   how to install &pooma;.  In the following section, we describe how
-   to install &pooma; to support distributed computation.</para>
- ]]>  <!-- end temporary -->
- 
- <![%unfinished;[
-   <para>ADD: Write this section, including extensive instructions
-   for Unix-like, MS Windows, and MacOS.  List the configuration options.
-   Be sure to describe configuring for parallel execution.</para>
- ]]>  <!-- end unfinished -->
- 
-   <section id="installation-distributed_computing">
-    <title>Supporting Distributed Computation</title>
- 
-    <para>To use multiple processors with &pooma; requires installing
-    the &cheetah; messaging library and an underlying messaging library
-    such as the Message Passing Interface (&mpi;) Communications
-    Library or the &mm; Shared Memory Library.  In the following
-    section, we first describe how to install &mm;.  Read it only if
-    using &mm;, not &mpi;.  Then we describe how to install &cheetah;
-    and configure &pooma; to use it.</para>
- 
-    <section id="installation-distributed_computing-mm">
-     <title>Obtaining and Installing the &mm; Shared Memory Library</title>
- 
-     <para>&cheetah;, and thus &pooma;, can use Ralf Engelschall's &mm;
-     Shared Memory Library to pass messages between processors.  For
-     example, the &author; uses this library on a two-processor
-     computer running &linux;.  The library, available at <ulink
-     url="http://www.engelschall.com/sw/mm/">http://www.engelschall.com/sw/mm/</ulink>,
-     is available at no cost and has been successfully tested on a
-     variety of Unix-like platforms.</para>
- 
-     <para>We describe how to download and install the &mm; library.
-      <orderedlist spacing="compact">
-       <listitem>
-        <para>Download the library from the &pooma; Download page
-        (&poomadownloadpage;) available off the &pooma; home page
-        (&poomahomepage;).</para>
-       </listitem>
- 	<listitem>
- 	 <para>Extract the source code using <command>tar xzvf
-          mm-1.1.3.tar.gz</command>.  Change directories into the
-          resulting source code directory <filename
-          class="directory">mm-1.1.3</filename>.</para>
- 	</listitem>
- 	<listitem>
- 	 <para>Prepare to compile the source code by configuring it
-          using the <command>configure</command> command.  To change
-          the default installation directory <filename
-          class="directory">/usr/local</filename>, specify
-          <command>&dashdash;prefix=<replaceable>directory</replaceable></command>
-          option.  The other configuration options can be listed by
-          specifying the <command>&dashdash;help</command> option.  Since the
-          &author; prefers to keep all &pooma;-related code in his
-          <filename class="directory">pooma</filename>subdirectory, he
-          uses
- <programlisting>
- ./configure &dashdash;prefix=${HOME}/pooma/mm-1.1.3
- </programlisting></para>
- 	</listitem>
- 	<listitem>
- 	 <para>Create the library by issuing the
-          <command>make</command> command.  This compiles the source
-          code using a &c; compiler.  To use a different compiler than
-          the &mm; configuration chooses, set the <envar>CC</envar>
-          environment variable to the desired compiler before
-          configuring.</para>
-       </listitem>
-     <listitem>
-      <para>Optionally test the library by issuing the <command>make
-      test</command> command.  If successful, the penultimate line
-      should be <computeroutput>OK - ALL TESTS SUCCESSFULLY
-      PASSED</computeroutput>.</para>
-     </listitem>
-     <listitem>
-      <para>Install the &mm; Library by issuing the <command>make
-      install</command> command.  This copies the library files to the
-      installation directory.  The <filename
-      class="directory">mm-1.1.3</filename> directory containing the
-      source code may now be removed.</para>
-     </listitem>
-    </orderedlist>
-    </para>
-    </section>
- 
-    
-    <section id="installation-distributed_computing-cheetah">
-     <title>Obtaining and Installing the &cheetah; Messaging Library</title>
- 
-     <para>The &cheetah; Library decouples communication from
-     synchronization.  Using asynchronous messaging rather than
-     synchronous messaging permits a message sender to operate without
-     the cooperation of the message recipient.  Thus, implementing
-     message sending is simpler and processing is more efficiently
-     overlapped with it.  Remote method invocation is also supported.
-     The library was developed at the Los Alamos National Laboratory's
-     Advanced Computing Laboratory.</para>
- 
-     <para>&cheetah;'s messaging is implemented using an underlying
-     messaging library such as the Message Passing Interface (&mpi;)
-     Communications Library
- <![%unfinished;[
-  (FIXME: xref linkend="mpi99", <ulink
-     url="http://www-unix.mcs.anl.gov/mpi/"></ulink>)
- ]]>  <!-- end unfinished -->
-     or the &mm; Shared Memory Library.  &mpi; works on a wide variety
-     of platforms and has achieved widespread usage.  &mm; works under
-     Unix-like operating systems on any computer with shared memory.  Both libraries are
-     available at no cost.  The instructions below work for whichever
-     library you choose.</para>
- 
-     <para>We describe how to download and install &cheetah;.
-      <orderedlist spacing="compact">
-       <listitem>
-        <para>Download the library from the &pooma; Download page
-        (&poomadownloadpage;) available off the &pooma; home page
-        (&poomahomepage;).</para>
-       </listitem>
-       <listitem>
-        <para>Extract the source code using <command>tar xzvf
-        cheetah-1.0.tgz</command>.  Change directories into the
-        resulting source code directory <filename
-        class="directory">cheetah-1.0</filename>.</para>
-       </listitem>
-       <listitem>
-        <para>Edit a configuration file corresponding to your operating
-        system and compiler.  These <filename
-        class="libraryfile">.conf</filename> files are located in the
-        <filename class="directory">config</filename> directory.  For
-        example, to use &gcc; with the &linux; operating system, use
-        <filename
-        class="libraryfile">config/LINUXGCC.conf</filename>.</para>
- 
-        <para>The configuration file usually does not need
-        modification.  However, if you are using &mm;, ensure
-        <varname>shmem_default_dir</varname> specifies its location.
-        For example, the &author; modified the value to
-        <literal>"/home/oldham/pooma/mm-1.1.3"</literal>.</para>
-       </listitem>
-       <listitem>
-        <para>Prepare to compile the source code by configuring it
-        using the <command>configure</command> command.  Specify the
-        configuration file using the <command>&dashdash;arch</command> option.
-        Its argument should be the configuration file's name, omitting
-        its <filename class="libraryfile">.conf</filename> suffix.  For
-        example, <command>&dashdash;arch LINUXGCC</command>.  Some other
-        options include
-        <variablelist>
-        <varlistentry>
- 	<term>&dashdash;help</term>
- 	<listitem>
- 	 <para>lists all the available options</para>
- 	</listitem>
-        </varlistentry>
-        <varlistentry>
- 	<term>&dashdash;shmem &dashdash;nompi</term>
- 	<listitem>
- 	 <para>indicates use of &mm;, not &mpi;</para>
- 	</listitem>
-        </varlistentry>
-        <varlistentry>
- 	<term>&dashdash;mpi &dashdash;noshmem</term>
- 	<listitem>
- 	 <para>indicates use of &mpi;, not &mm;</para>
- 	</listitem>
-        </varlistentry>
-        <varlistentry>
- 	<term>&dashdash;opt</term>
- 	<listitem>
- 	 <para>causes the compiler to produce optimized source code</para>
- 	</listitem>
-        </varlistentry>
-        <varlistentry>
- 	<term>&dashdash;noex</term>
- 	<listitem>
- 	 <para>prevents use of &cc; exceptions</para>
- 	</listitem>
-        </varlistentry>
-        <varlistentry>
- 	 <term>&dashdash;static</term>
- 	 <listitem>
- 	  <para>creates a static library, not a shared library</para>
- 	 </listitem>
-        </varlistentry>
-        <varlistentry>
- 	 <term>&dashdash;shared</term>
- 	 <listitem>
- 	  <para>creates a shared library, not a static library.  This
- 	  is the default.</para>
- 	 </listitem>
-        </varlistentry>
-        <varlistentry>
- 	<term>&dashdash;prefix <replaceable>directory</replaceable></term>
- 	<listitem>
- 	 <para>specifies the installation directory where the
- 	   library will be copied rather than the default.</para>
- 	</listitem>
-        </varlistentry>
-       </variablelist>
-         For example, the &author; uses <command>./configure &dashdash;arch
-         LINUXGCC &dashdash;shmem &dashdash;nompi &dashdash;noex &dashdash;static &dashdash;prefix
-         ${HOME}/pooma/cheetah-1.0 &dashdash;opt</command>.  The
-         <command>&dashdash;arch LINUXGCC</command> indicates use of &gcc;
-         under a &linux; operating system.  The &mm; library is used,
-         but &cc; exceptions are not.  The latter choice matches
-         &pooma;'s default choice.  A static library, not a shared
-         library, is created.  This is also &pooma;'s default choice.
-         The library will be installed in the <filename
-         class="directory">${HOME}/pooma/cheetah-1.0</filename>.
-         Finally, the library code will be optimized, hopefully running
-         faster than unoptimized code.</para>
-       </listitem>
-       <listitem>
-        <para>Follow the directions printed by
-        <command>configure</command>: Change directories to the
-        <filename class="directory">lib</filename> subdirectory named
-        by the <command>&dashdash;arch</command> argument and then type
-        <command>make</command> to compile the source code and create
-        the library.</para>
-       </listitem>
-       <listitem>
-        <para>Optionally ensure the library works correctly by issuing
-        the <command>make tests</command> command.</para>
-       </listitem>
-       <listitem>
-        <para>Install the library by issuing the <command>make
-        install</command> command.  This copies the library files to
-        the installation directory.  The <filename
-        class="directory">cheetah-1.0</filename> directory containing
-        the source code may now be removed.</para>
-       </listitem>
-      </orderedlist>
-    </para>
-    </section>
- 
-    <section id="installation-distributed_computing-pooma">
-     <title>Configuring &pooma; When Using &cheetah;</title>
- 
-     <para>To use &pooma; with &cheetah;, one must tell &pooma; the
-     location of the &cheetah; library using the
-     <command>&dashdash;messaging</command> configuration option.  To do this,
-      <orderedlist spacing="compact">
-       <listitem>
-        <para>Set the &cheetah; directory environment variable
-         <envar>CHEETAHDIR</envar> to the directory containing the
-         installed &cheetah; library.  For
-         example,
- <programlisting>
- declare -x CHEETAHDIR=${HOME}/pooma/cheetah-1.0
- </programlisting> specifies the
-         installation directory used in the previous section.  If using
-         the <application>csh</application> shell, use <command>setenv 
-         CHEETAHDIR ${HOME}/pooma/cheetah-1.0</command>.</para>
-       </listitem>
-       <listitem>
-        <para>When configuring &pooma;, specify the
-        <command>&dashdash;messaging</command> option.  For example,
-        <command>./configure &dashdash;arch LINUXgcc &dashdash;opt
-        &dashdash;messaging</command> configures for &linux;, &gcc;, and an
-        optimized library using &cheetah;.</para>
-       </listitem>
-      </orderedlist>
-     </para>
-    </section>
-   </section>
-  </appendix>
- 
- 
- <![%unfinished;[
-  <appendix id="compilation_errors">
-   <title>Dealing with Compilation Errors</title>
- 
-   <para>Base this low-priority section on <filename
-   class="libraryfile">errors.html</filename>.  QUESTION: Where is
-   <filename class="libraryfile">errors.html</filename>?</para>
- 
-  </appendix>
- 
- 
-  <appendix id="tmp_appendix">
-   <title>TMP: Notes to Myself</title>
- 
-   <section id="tmp-miscellaneous">
-    <title>Miscellaneous</title>
- 
-    <orderedlist>
-     <listitem>
-      <para>Section&nbsp;5, "Performance," of
-      <filename>papers/iscope98.pdf</filename> motivates and explains
-      stencils.</para>
-     </listitem>
- 
-     <listitem>
-      <para>If there is time, present another example program, e.g., a
-      Jacobi solver.</para>
-     </listitem>
- 
-     <listitem>
-      <para>If a reference manual for &pooma; implementors is written,
-      begin with a chapter <quote>Under the Hood: How &pooma;
-      Works</quote>, written from the point of view of &cc;
-      interpreter.  For &pete;, use the material in
-      <filename>papers/PETE_DDJ/ddj_article.html</filename>, which
-      gives example code and descriptions of how the code works, and
-      see material in <filename
-      class="libraryfile">background.html</filename>'s
-      <quote>Expression Templates.</quote></para>
-     </listitem>
- 
-     <listitem>
-      <para>QUESTION: How do &pooma; parallel concepts compare with
-      &fortran;&nbsp;D or high-performance &fortran; FINISH CITE:
-      {koelbel94:_high_perfor_fortr_handb}?</para>
-     </listitem>
- 
-     <listitem>
-      <para>QUESTION: How do I know when to use a type name versus just
-      the concept?  For example, when do I use <quote>array</quote>
-      versus &array;?</para>
-     </listitem>
- 
-     <listitem>
-      <para>Krylov solvers are described in Section&nbsp;3.5.2 of
-      <filename>papers/pooma.ps</filename>.</para>
-     </listitem>
- 
-     <listitem>
-      <para>Section&nbsp;5, "The Polygon Overlay Problem," describes
-      porting an <acronym>ANSI</acronym> &c; program to &pooma;.</para>
-     </listitem>
- 
-     <listitem>
-      <para>A good example book: <emphasis>STL Tutorial and Reference
-      Guide: &cc; Programming with the Standard Template
-      Library</emphasis>, second edition, by David&nbsp;R. Musser,
-      Gillmer&nbsp;J. Derge, and Atul Sanai, ISBN 0-201-37923-6,
-      QA76.73.C153.M87 2001.</para>
-     </listitem>
- 
-     <listitem>
-      <para>One STL reference book listed functions in margin notes,
-      easing finding material.  Do this.</para>
-     </listitem>
- 
-     <listitem>
-      <para>QUESTION: Does Berna Massingill at Trinity University have
-      any interest ior access to any parallel computers?</para>
-     </listitem>
-    </orderedlist>
- 
-   </section>
- 
- 
-   <section id="tmp-html_tutorials">
-    <title>Existing HTML Tutorials</title>
- 
-    <para>All these tutorials are out-of-date, but the ideas and text
-    may still be relevant.</para>
- 
-    <variablelist>
-     <varlistentry><term><filename
- 				  class="libraryfile">index.html</filename></term>
-      <listitem><para>list of all tutorials.  No useful
-     material.</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
- 				  class="libraryfile">introduction.html</filename></term>
-      <listitem><para>data-parallel Laplace solver using Jacobi
-     iteration ala <command>Doof2d</command></para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
- 				  class="libraryfile">background.html</filename></term>
-      <listitem><para>short, indirect introduction to &pete;; parallel
-     execution model; &cc;; templates; &stl;; expression
-     templates</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
- 				  class="libraryfile">tut-01.html</filename></term>
-      <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
- 				  class="libraryfile">Layout.html</filename></term>
-      <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
- 				  class="libraryfile">parallelism.html</filename></term>
-      <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
- 				  class="libraryfile">self-test.html</filename></term>
-      <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">threading.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-03.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-04.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-05.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-06.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-07.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-08.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-09.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-10.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-11.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-12.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-     <varlistentry><term><filename
-     class="libraryfile">tut-13.html</filename></term>
-     <listitem><para>UNFINISHED</para></listitem>
-     </varlistentry>
-    </variablelist>
- 
-   </section>
- 
-  </appendix>
- ]]>  <!-- end unfinished -->
- 
- 
-  &bibliography-chapter;
- 
-  &glossary-chapter; 
- 
-  <!-- Index -->
- 
- <![%unfinished;[
-   &genindex.sgm;
- ]]>  <!-- end unfinished -->
- 
- </book>
--- 0 ----
Index: pooma.xml
===================================================================
RCS file: pooma.xml
diff -N pooma.xml
*** /dev/null	Fri Mar 23 21:37:44 2001
--- pooma.xml	Thu Jan 31 14:10:44 2002
***************
*** 0 ****
--- 1,4223 ----
+ <?xml version="1.0"?>
+ <!-- FIXME: Index this file. -->
+ 
+ <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "file:///usr/lib/sgml/docbookx.dtd" [
+ 
+ <!-- Text to Check, Revise, Replace -->
+   <!-- FIXME: Revise before releasing. -->
+   <!-- UPDATE: Check before publishing to see if any needs changing. -->
+   <!-- ADD: Write more material. -->
+ 
+ <!-- Conditional Inclusion Entity Declarations -->
+ <!ENTITY % unfinished "IGNORE">
+   <!-- Unfinished sections should not be included in published versions. -->
+ <!ENTITY % temporary "INCLUDE">
+   <!-- Temporary sections to be included in published versions until the final version is written. -->
+ 
+ <!-- Index Entity Declarations -->
+ <!ENTITY genindex.sgm SYSTEM "genindex.sgm">
+ 
+ <!-- General Entity Declarations -->
+ 
+ <!ENTITY book "book">
+   <!-- Produce a notation for the book/manual/report/WWW page.  -->
+   <!-- Modify this to the desired noun. -->
+ <!ENTITY bookcap "Book">
+   <!-- Produce a capitalized version of &book;  -->
+   <!-- Modify this to the desired noun. -->
+ <!ENTITY c "<application class='software'>C</application>">
+   <!-- Produce a notation for the C programming language.  -->
+   <!-- Modify this to the desired formatting. -->
+ <!ENTITY cc "<application class='software'>C++</application>">
+   <!-- Produce a notation for the C++ programming language.  -->
+   <!-- Modify this to the desired formatting. -->
+ <!ENTITY cheetah "<application class='software'>Cheetah</application>" >
+   <!-- Produce a notation for the Cheetah Library.  -->
+ <!ENTITY closeclose "&gt;&gap;&gap;&gt;" >
+   <!-- Produce a notation for ">>", which frequently occurs with templates.  Without this, TeX produces a shift symbol. -->
+ <!ENTITY closecloseclose "&gt;&gap;&gap;&gt;&gap;&gap;&gt;" >
+   <!-- Produce a notation for ">>>", which infrequently occurs with templates.  Without this, TeX produces a shift symbol. -->
+ <!ENTITY dashdash "-&gap;-" >
+   <!-- Produce a notation for a double dash.  Without this, TeX produces an en-hyphen. -->
+ <!ENTITY dim "D">
+   <!-- the number of dimensions of an array, domain, etc. -->
+ <!ENTITY doof2d "<command>Doof2d</command>" >
+   <!-- Produce a notation for the Doof2d program.  -->
+ <!ENTITY fortran "<application class='software'>Fortran</application>">
+   <!-- Produce a notation for the Fortran programming language.  -->
+ <!ENTITY gap "&hairsp;">
+   <!-- Produce a small gap so TeX will not combine the two characters. -->
+   <!-- FIXME: Choose something that will work for TeX and also in HTML. -->
+ <!ENTITY make "<application class='software'>Make</application>">
+   <!-- Produce a notation for the GNU Make program.  -->
+ <!ENTITY mm "<application class='software'>MM</application>">
+   <!-- Produce a notation for the MM Library.  -->
+ <!ENTITY mpi "<application class='software'>MPI</application>">
+   <!-- Produce a notation for the MPI package.  -->
+ <!ENTITY openopen "&lt;&gap;&lt;" >
+   <!-- Produce a notation for "<<", which frequently occurs with output.  Without this, TeX produces a shift symbol. -->
+ <!ENTITY pdt "<application class='software'>PDToolkit</application>">
+   <!-- Produce a notation for the PDT software package.  -->
+ <!ENTITY pete "<application class='software'>PETE</application>">
+   <!-- Produce a notation for the PETE framework.  -->
+ <!ENTITY pooma "<application class='software'>POOMA</application>">
+   <!-- Produce a notation for Pooma software.  -->
+ <!ENTITY poomatoolkit "<application class='software'>POOMA &toolkitcap;</application>">
+   <!-- Produce a notation for the Pooma toolkit.  -->
+ <!ENTITY purify "<application class='software'>Purify</application>">
+   <!-- Produce a notation for the Purify library.  -->
+ <!ENTITY smarts "<application class='software'>Smarts</application>">
+   <!-- Produce a notation for the Smarts software package.  -->
+   <!-- Modify this after capitalization is decided. -->
+ <!ENTITY stl "<application class='software'>STL</application>">
+   <!-- Produce a notation for the C++ Standard Template Library software package.  -->
+ <!ENTITY tau "<application class='software'>Tau</application>">
+   <!-- Produce a notation for the Tau software package.  -->
+ <!ENTITY toolkit "toolkit">
+   <!-- Produce a notation for the name of the Pooma software.  -->
+ <!ENTITY toolkitcap "Toolkit">
+   <!-- Produce a capitalized version of &toolkit;.  -->
+ 
+ <!-- Type Entity Declarations -->
+ 
+ <!ENTITY array "<type>Array</type>">
+   <!-- The "Array" type. -->
+ <!ENTITY benchmark "<type>Benchmark</type>">
+   <!-- The "Benchmark" type. -->
+ <!ENTITY bool "<type>bool</type>">
+   <!-- The C++ boolean type. -->
+ <!ENTITY brick "<type>Brick</type>">
+   <!-- The "Brick" engine type. -->
+ <!ENTITY char "<type>char</type>">
+   <!-- The C char type. -->
+ <!ENTITY complex "<type>complex</type>">
+   <!-- The C++ "complex" type. -->
+ <!ENTITY compressiblebrick "<type>CompressibleBrick</type>">
+   <!-- The "CompressibleBrick" engine type. -->
+ <!ENTITY distributedtag "<type>DistributedTag</type>">
+   <!-- The DistributedTag Layout type. -->
+ <!ENTITY domain "<type>Domain</type>">
+   <!-- The "Domain" type. -->
+ <!ENTITY domaintemplate "DT">
+   <!-- A domain template parameter. -->
+ <!ENTITY double "<type>double</type>">
+   <!-- The C "double" type. -->
+ <!ENTITY dynamic "<type>Dynamic</type>">
+   <!-- The "Dynamic" Engine type. -->
+ <!ENTITY dynamicarray "<type>DynamicArray</type>">
+   <!-- The "DynamicArray" type. -->
+ <!ENTITY engine "<type>Engine</type>">
+   <!-- The "Engine" type. -->
+ <!ENTITY false "<literal>false</literal>">
+   <!-- The false Boolean value. -->
+   <!-- Modify its tag to the appropriate one. -->
+ <!ENTITY field "<type>Field</type>">
+   <!-- The "Field" type. -->
+ <!ENTITY float "<type>float</type>">
+   <!-- The C "float" type. -->
+ <!ENTITY grid "<type>Grid</type>">
+   <!-- The "Grid" domain type. -->
+ <!ENTITY gridone "<type>Grid&lt;1&gt;</type>">
+   <!-- The "Grid<1>" one-dimensional domain type. -->
+ <!ENTITY indirectionlist "<type>IndirectionList</type>">
+   <!-- The "IndirectionList" (domain-helper) type. -->
+ <!ENTITY indirectionlistint "<type>IndirectionList&lt;int&gt;</type>">
+   <!-- The "IndirectionList<int>" (domain-helper) type. -->
+ <!ENTITY inform "<type>Inform</type>">
+   <!-- The "Inform" output type. -->
+ <!ENTITY int "<type>int</type>">
+   <!-- The C "int" type. -->
+ <!ENTITY interval "<type>Interval</type>">
+   <!-- The "Interval" type. -->
+ <!ENTITY intervalone "<type>Interval&lt;1&gt;</type>">
+   <!-- The "Interval<1>" one-dimensional domain type. -->
+ <!ENTITY layout "<type>Layout</type>">
+   <!-- The "Layout" type without template parameters. -->
+ <!ENTITY leaffunctor "<type>LeafFunctor</type>">
+   <!-- The "LeafFunctor" type. -->
+ <!ENTITY loc "<type>Loc</type>">
+   <!-- The "Loc" domain type. -->
+ <!ENTITY locone "<type>Loc&lt;1&gt;</type>">
+   <!-- The "Loc<1>" one-dimensional domain type. -->
+ <!ENTITY matrix "<type>TinyMatrix</type>">
+   <!-- The Pooma matrix type. -->
+ <!ENTITY multipatch "<type>MultiPatch</type>">
+   <!-- The "MultiPatch" engine without template parameters. -->
+ <!ENTITY options "<type>Options</type>">
+   <!-- The &pooma; options type. -->
+ <!ENTITY range "<type>Range</type>">
+   <!-- The "Range" domain type. -->
+ <!ENTITY rangeone "<type>Range&lt;1&gt;</type>">
+   <!-- The "Range<1>" one-dimensional domain type. -->
+ <!ENTITY remote "<type>Remote</type>">
+   <!-- The "Remote" engine type. -->
+ <!ENTITY replicatedtag "<type>ReplicatedTag</type>">
+   <!-- The ReplicatedTag Layout type. -->
+ <!ENTITY stencil "<type>Stencil</type>">
+   <!-- The "Stencil" type. -->
+ <!ENTITY tensor "<type>Tensor</type>">
+   <!-- The Pooma tensor type. -->
+ <!ENTITY true "<literal>true</literal>">
+   <!-- The true Boolean value. -->
+   <!-- Modify its tag to the appropriate one. -->
+ <!ENTITY vector "<type>Vector</type>">
+   <!-- The "Vector" type. -->
+ 
+ <!-- Mathematical Entity Declarations -->
+ 
+ <!ENTITY container "C">
+   <!-- an abbreviation for a canonical container -->
+ <!ENTITY containerdomain "D">
+   <!-- an abbreviation for a canonical container domain -->
+ <!ENTITY n "n">
+   <!-- the size of one dimension of an array -->
+ <!ENTITY space "&real;<superscript>d</superscript>">
+   <!-- a notation for multidimensional space -->
+ 
+ <!-- System and Operating System Entity Declarations -->
+ <!ENTITY gcc "<application>g++</application>">
+   <!-- The GNU Compiler Collection C++ compiler. -->
+ <!ENTITY kcc "<application>KCC</application>">
+   <!-- The KAI C++ compiler. -->
+ <!ENTITY linux "<application>Linux</application>">
+   <!-- The Linux operating system. -->
+ 
+ <!-- &pooma; URLs and Files -->
+ 
+ <!ENTITY poomadownloadpage '<ulink url="http://pooma.codesourcery.com/pooma/download">http://pooma.codesourcery.com/pooma/download</ulink>'>
+   <!-- The WWW page supporting downloading the &pooma; source code. -->
+   <!-- UPDATE this URL. -->
+ <!ENTITY poomahomepage '<ulink url="http://www.codesourcery.com/pooma/pooma/">http://www.codesourcery.com/pooma/pooma/</ulink>'>
+   <!-- The canonical Pooma home page. -->
+   <!-- UPDATE this filename. -->
+ <!ENTITY poomasource "pooma-2.3.0">
+   <!-- The Pooma source code directory. -->
+   <!-- UPDATE this filename. -->
+ <!ENTITY poomasourcefile "&poomasource;.tgz">
+   <!-- The Pooma source code archive. -->
+ <!ENTITY poomaexampledirectory "examples/Manual">
+   <!-- The directory holding this manual's example codes. -->
+ 
+ <!-- Spelling and Formatting Decisions -->
+ <!ENTITY author "author">
+   <!-- A word describing an author xor authors. -->
+ <!ENTITY naive "na&iuml;ve">
+   <!-- The word "na\"{\i}ve." -->
+ <!ENTITY naivecap "Na&iuml;ve">
+   <!-- The word "Na\"{\i}ve," i.e., the capitalized &naive;. -->
+   <!-- The Pooma source code directory. -->
+   <!-- spelling: dependence, not dependency -->
+   <!-- spelling: element-wise, not elementwise -->
+   <!-- phrase: function object, not functor -->
+   <!-- spelling: interprocessor, not inter-processor -->
+   <!-- spelling: multidimensional, not multi-dimensional -->
+   <!-- spelling: multiprocessor, not multi-processor -->
+   <!-- spelling: nonzero, not non-zero -->
+   <!-- formatting: for sets, no spaces between brackets and entries but spaced between entries -->
+ 
+ <!-- External Chapters -->
+ <!ENTITY arrays-chapter SYSTEM "arrays.xml">
+   <!-- Pooma Arrays chapter -->
+ <!ENTITY bibliography-chapter SYSTEM "bibliography.xml">
+   <!-- bibliography -->
+ <!ENTITY concepts-chapter SYSTEM "concepts.xml">
+   <!-- Pooma concepts chapter -->
+ <!ENTITY data-parallel-chapter SYSTEM "data-parallel.xml">
+   <!-- data-parallel expressions chapter -->
+ <!ENTITY glossary-chapter SYSTEM "glossary.xml">
+   <!-- glossary -->
+ <!ENTITY introductory-chapter SYSTEM "introduction.xml">
+   <!-- Doof2d introductory chapter -->
+ <!ENTITY template-chapter SYSTEM "template.xml">
+   <!-- Doof2d template programming chapter -->
+ <!ENTITY tutorial-chapter SYSTEM "tutorial.xml">
+   <!-- Doof2d tutorial programs chapter -->
+ 
+ <!-- External File Entities -->
+ <!-- Doof2d Programs -->
+ <!ENTITY doof2d-c-element SYSTEM "./programs/examples/Doof2d/Doof2d-C-element-annotated.cpp">
+   <!-- hand-coded Doof2d implementation -->
+ <!ENTITY doof2d-array-element SYSTEM "./programs/examples/Doof2d/Doof2d-Array-element-annotated.cpp">
+   <!-- Array element-wise Doof2d implementation -->
+ <!ENTITY doof2d-array-parallel SYSTEM "./programs/examples/Doof2d/Doof2d-Array-parallel-annotated.cpp">
+   <!-- Array data-parallel Doof2d implementation -->
+ <!ENTITY doof2d-array-stencil SYSTEM "./programs/examples/Doof2d/Doof2d-Array-stencil-annotated.cpp">
+   <!-- Array stencil Doof2d implementation -->
+ <!ENTITY doof2d-array-distributed SYSTEM "./programs/examples/Doof2d/Doof2d-Array-distributed-annotated.cpp">
+   <!-- distributed Array stencil Doof2d implementation -->
+ <!ENTITY doof2d-field-parallel SYSTEM "./programs/examples/Doof2d/Doof2d-Field-parallel-annotated.cpp">
+   <!-- Field data-parallel Doof2d implementation -->
+ <!ENTITY doof2d-field-distributed SYSTEM "./programs/examples/Doof2d/Doof2d-Field-distributed-annotated.cpp">
+   <!-- Field data-parallel distributed Doof2d implementation -->
+ 
+ <!-- Sequential Programs -->
+ <!ENTITY array-copy SYSTEM "./programs/examples/Sequential/array-copy-annotated.cpp">
+   <!-- Illustrate Array reference semantics. -->
+ <!ENTITY array-size SYSTEM "./programs/examples/Sequential/array-size-annotated.cpp">
+   <!-- Illustrate Array member functions. -->
+ <!ENTITY dynamicarray-example SYSTEM "./programs/examples/Sequential/dynamicarray-annotated.cpp">
+   <!-- Illustrate using DynamicArray class. -->
+ <!ENTITY initialize-finalize SYSTEM "./programs/examples/Sequential/initialize-finalize-annotated.cpp">
+   <!-- Illustrate initialize() and finalize(). -->
+ 
+ <!-- Template Programs -->
+ <!ENTITY pairs-untemplated SYSTEM "./programs/examples/Templates/pairs-untemplated-annotated.cpp">
+   <!-- Illustrate defining classes with pairs of values of the same type. -->
+ <!ENTITY pairs-templated SYSTEM "./programs/examples/Templates/pairs-templated-annotated.cpp">
+   <!-- Illustrate defining a template class with pairs of values of the same type. -->
+ ]>
+ 
+ <book>
+  <bookinfo>
+   <title>&pooma;</title>
+   <subtitle>A &cc; &toolkitcap; for High-Performance Parallel Scientific Computing</subtitle>
+   <author><firstname>Jeffrey</firstname><othername
+   role='mi'>D.</othername><surname>Oldham</surname>
+    <affiliation>
+     <orgname>CodeSourcery, LLC</orgname>
+    </affiliation>
+   </author>
+   <copyright><year>2002</year><holder>CodeSourcery, LLC (<ulink url="http://www.codesourcery.com/"></ulink>)</holder></copyright>
+   <contractsponsor>Los Alamos National Laboratory<ulink url="http://www.lanl.gov/"></ulink></contractsponsor>
+   <legalnotice>
+    <!-- FIXME: What is the correct legal notice? -->
+    <para>All rights reserved.  This document may not be redistributed in any form without the express permission of the author.</para>
+   </legalnotice>
+   <revhistory>
+    <revision>
+     <revnumber>1.00</revnumber>
+     <date>2002 Jan 31</date>
+     <authorinitials>jdo</authorinitials>
+     <revremark>First publication.</revremark>
+    </revision>
+   </revhistory>
+  </bookinfo>
+ 
+  <!-- FINISH: May we have a short table of contents followed by a -->
+  <!-- complete table of contents? -->
+ 
+ <![%unfinished;[
+  <preface id="preface">
+   <title>Preface</title>
+ 
+   <para>FINISH: Describe the target audience for &pooma; programs and
+   for this manual: &cc; programmers writing scientific code, possibly
+   parallel execution.</para>
+ 
+   <para>Assume familiarity with &cc; template programming and the
+   standard template library.  FIXME: Remove this index
+   entry.<indexterm id="oldham"><primary>Oldham,
+   Jeffrey&nbsp;D.</primary></indexterm></para>
+ 
+   <section id="preface-notation">
+    <title>Notation</title>
+ 
+    <para>UNFINISHED</para>
+   </section>
+ 
+ 
+   <section id="preface-reading_book:">
+    <title>How to Read This &bookcap;</title>
+ 
+    <para>FINISH: Write this section in a style similar to Lamport's
+    LaTeX section 1.2.  FINISH: Fix the book title and the section
+    number.</para>
+   </section>
+ 
+ 
+   <section id="preface-downloading">
+    <title>Obtaining &pooma; and Sample Programs</title>
+ 
+    <para>Available for free from what WWW site?  Include what portions
+    of <filename class="libraryfile">LICENSE</filename>?  Be sure to
+    include CVS instructions as well.</para>
+ 
+    <para>Which additional packages are necessary and when?</para>
+ 
+   </section>
+ 
+ 
+   <section id="preface-using_modifying">
+    <title>Using and Modifying &pooma;</title>
+ 
+    <para>&pooma; is available under open source license.  It can be
+    used and modified by anyone, anywhere.  Can it be sold?  Include
+    <filename class="libraryfile">LICENSE</filename>.</para>
+ 
+    <para>QUESTION: How do developers contribute code?</para>
+ 
+   </section>
+ 
+ 
+   <section id="preface-acknowledgements">
+    <title>Acknowledgements</title>
+ ]]>  <!-- end unfinished -->
+ 
+ <![%temporary;[
+   <preface id="acknowledgements">
+    <title>Acknowledgements</title>
+ ]]>  <!-- end temporary -->
+ 
+    <para>This &book; would not have been completed without the help
+    and encouragement of a lot of people and organizations.  Los Alamos
+    National Laboratory funded the writing of this manual and the
+    development of the &poomatoolkit;.  John Reynders conceived,
+    advocated, and headed &pooma; development in its early days, and
+    Scott Haney continued the leadership.  Susan Atlas, Subhankar
+    Banerjee, Timothy Cleland, Julian Cummings, James Crotinger, David
+    Forslund, Salman Habib, Scott Haney, Paul Hinker, William Humphrey,
+    Steve Karmesin, Graham Mark, Jeffrey&nbsp;D. Oldham, Ji Qiang, John
+    Reynders, Robert Ryne, Stephen Smith, M.&nbsp;Srikant, Marydell
+    Tholburn, and Timothy Williams all helped develop &pooma;. Rod
+    Oldehoeft and Jeff Brown of Los Alamos National Laboratory
+    supported CodeSourcery's and Proximation's work, including the
+    development of this manual.  John Hall, Don Marshall, Jean
+    Marshall, and the rest of the BLANCA team at Los Alamos worked
+    closely with the developers and provided valuable suggestions for
+    improvements.</para>
+ 
+    <para>I am grateful to James Crotinger, Mark Mitchell, and Stephen
+    Smith who answered my many questions during the writing of this
+    &book;.</para>
+ 
+   <!-- We cheat and abuse an epigraph here. -->
+   <epigraph>
+    <attribution>Jeffrey&nbsp;D. Oldham, 2002 January</attribution>
+    <para></para>
+   </epigraph>
+ 
+ <![%temporary;[
+  </preface>
+ ]]>  <!-- end temporary -->
+ 
+ <![%unfinished;[
+   </section>
+ 
+  </preface>
+ ]]>  <!-- end unfinished -->
+ 
+ 
+ <![%unfinished;[
+  <part id="programming">
+   <title>Programming with &pooma;</title>
+ 
+ <!-- FIXME: Add a partintro to the part above? -->
+ ]]>  <!-- end unfinished -->
+ 
+   &introductory-chapter; 
+ 
+   &template-chapter;
+ 
+   &tutorial-chapter;
+ 
+   &concepts-chapter;
+ 
+   &arrays-chapter;
+ 
+ 
+   <chapter id="engines">
+    <title>Engines</title>
+ 
+    <para>Each container has one or more &engine;s to store or compute
+    its values.  As we mentioned in <xref
+    linkend="arrays-arrays_declarations"></xref>, a container's role is
+    high-level, supporting access to groups of values, and an engine's
+    role is low-level, storing or computing values and supporting
+    access to individual values.  This separation permits optimizing
+    space and computation requirements.</para>
+ 
+    <para>We begin this chapter by introducing the concept of an engine
+    and how it is used.  Then, we describe the various &engine;s that
+    &pooma; provides, separating them into engines that store values
+    and engines that compute values.
+ <![%unfinished;[
+    Finally, we describe how the
+    &engine;s are implemented, using tags to differentiate engines and
+    reference-counted pointers to their underlying data.
+ ]]>  <!-- end unfinished -->
+    </para>
+ 
+ 
+    <section id="engines-concept">
+     <title>The Concept</title>
+ 
+     <para>An engine performs the low-level value storage, computation,
+     and element-wise access for a container.  An engine has a domain
+     and accessor functions returning individual elements.  The &pooma;
+     &engine; class and its specializations implement the engine
+     concept.  Given an index within the domain, an &engine;'s
+     <literal>operator()</literal> function returns the
+     associated value, which can be used or changed.  Its
+     <literal>read</literal> member function returns the same
+     value but permitting only use, not modification.  The acceptable
+     indices are determined by each &engine;.  Most accept indices
+     specified using &int; and <type>Loc&lt;&dim;&gt;</type>
+     parameters, but an &engine; might accept string or floating-point
+     parameters.  An &engine;'s layout specifies maps its domain
+     indices to the processors and memory used to store and compute the
+     associated values.</para>
+ 
+     <para>Since an engine's main role is to return the individual
+     values associated with specific domain indices, any implementation
+     performing this task is an engine.  &pooma; &engine;s fall into
+     three categories:
+     <itemizedlist>
+      <listitem>
+       <para>&engine;s that store values.</para>
+      </listitem>
+      <listitem>
+       <para>&engine;s that compute their values using other &engine;s'
+       values.</para>
+      </listitem>
+      <listitem>
+       <para>&engine;s that support distributed computation.</para>
+      </listitem>
+     </itemizedlist>
+     For example, the &brick; &engine; explicitly stores all its
+     values, while the &compressiblebrick; engine adds the feature of
+     reducing its storage requirements if all these values are
+     identical.  A <type>UserFunction</type> &engine; yields values by
+     applying a <glossterm linkend="glossary-function_object">function
+     object</glossterm> to each value returned by another &engine;.  A
+     <type>CompFwd</type> &engine; projects components from another
+     &engine;.  For example, <type>CompFwd</type> will use the second
+     components of each &vector; in an &array; to form its own &array;.
+     Since each container has at least one &engine;, we can also
+     describe the latter category as containers that compute their
+     values using other containers' values.  A &multipatch; &engine;
+     distributes its domain among various processors and memory spaces,
+     each responsible for computing values associated with a portion,
+     or patch, of the domain.  The &remote; &engine; also supports
+     distributed computation.</para>
+ 
+     <para>Just as multiple containers can use the same engine,
+     multiple &engine;s can use the same underlying data.  As we
+     mentioned in <xref linkend="arrays-arrays_use"></xref>, &engine;s
+     have <glossterm linkend="glossary-reference_semantics">reference
+     semantics</glossterm>.  A copy of an &engine; has a
+     reference-counted pointer to the &engine;'s data (if any exists).
+     Thus, copying an &engine; or a container requires little execution
+     time.  If an &engine; has the same data as another &engine; but it
+     needs its own data to modify, the
+     <literal>makeOwnCopy</literal> member function creates such
+     a copy.</para>
+ 
+     <para>&engine;s are rarely explicitly declared.  Instead a
+     container is declared using an &engine; tag, and the container
+     creates the specified &engine; to deal with its values.  For
+     example, a &brick; &engine; is explicitly declared as
+     <type>Engine&lt;&dim;,T,Brick&gt;</type>, but they are more
+     frequently created by containers, e.g.,
+     <type>Array&lt;&dim;,T,Brick&gt;</type>.  An &engine;'s first two
+     template parameters specify the domain's dimensionality and the
+     value type, as described in <xref
+     linkend="arrays-arrays_declarations"></xref>.  Unlike container
+     declarations, the third template parameter, the &engine; tag,
+     specifies which &engine; specialization to use.  For example, the
+     &brick; &engine; tag indicates a &brick; &engine; should be used.
+     Some &engine;s, such as <type>CompFwd</type>, are rarely declared
+     even using &engine; tags.  Instead the &array;'s
+     <literal>comp</literal> and
+     <literal>readComp</literal> member functions return views of
+     containers using <type>CompFwd</type> &engine;s.</para>
+    </section>
+ 
+ 
+    <section id="engines-types">
+     <title>Types of &engine;s</title>
+ 
+     <para>In this section, we describe the different types of
+     &engine;s and illustrate their creation, when appropriate.  First,
+     we describe &engine;s that explicitly store values and then
+     &engine;s that compute values.  See <xref
+     linkend="engines-types-table"></xref>.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+            orient="port" pgwide="0" id="engines-types-table">
+      <title>Types of &engine;s</title>
+      
+      <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>&engine; tag</entry>
+ 	 <entry>description</entry>
+ 	</row>
+        </thead>
+        <tbody valign="top">
+ 	<row rowsep="1">
+ 	 <entry>&engine;s That Store</entry>
+ 	</row>
+ 	<row>
+ 	 <entry>&brick;</entry>
+ 	 <entry>explicitly stores all values; similar to &c; arrays.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry>&compressiblebrick;</entry>
+ 	 <entry>stores all values, reducing storage requirements when
+ 	 all values are identical.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry>&dynamic;</entry>
+ 	 <entry>is a one-dimensional &brick; with dynamically
+          resizable domain.  This should be used with &dynamicarray;,
+ 	 not &array;.</entry>
+ 	</row>
+ 	<row rowsep="1">
+ 	 <entry>&engine;s That Compute</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><type>CompFwd</type></entry>
+ 	 <entry>extracts specified components of an engine's vectors,
+ 	 tensors, arrays, etc.; usually created using the
+ 	 <literal>comp</literal> container function.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><type>ConstantFunction</type></entry>
+ 	 <entry>makes a scalar value behave like a container.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><type>IndexFunction&lt;FunctionObject&gt;</type></entry>
+ 	 <entry>makes the <type>FunctionObject</type>'s function of
+ 	 indices behave like a container.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><type>ExpressionTag&lt;Expr&gt;</type></entry>
+ 	 <entry>evaluates an expression tree; usually created by
+ 	 data-parallel expressions.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><type>Stencil&lt;Function, Expression&gt;</type></entry>
+          <entry>applies a stencil computation (<type>Function</type>)
+ 	 to its input (<type>Expression</type>) which is usually a
+ 	 container; usually created by applying a <type>Stencil</type>
+ 	 object to a container.  A stencil computation can use
+ 	 multiple neighboring input values.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><type>UserFunctionEngine&lt;Function,
+ 	 Expression&gt;</type></entry>
+ 	 <entry>applies the given function (or <glossterm
+ 	 linkend="glossary-function_object">function
+ 	 object</glossterm>) to its input (<type>Expression</type>)
+ 	 which is usually a container; usually created by applying a
+ 	 <type>UserFunction</type> object to a container.  The
+ 	 function implements a one-to-one mapping from its input to
+ 	 values.</entry>
+ 	</row>
+ 	<row rowsep="1">
+ 	 <entry>&engine;s for Distributed Computation</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><type>MultiPatch&lt;LayoutTag,EngineTag&gt;</type></entry>
+ 	 <entry>runs a separate <type>EngineTag</type> &engine; on
+ 	 each context (patch) specified by the given layout.  This is
+ 	 the usual &engine; for distributed computation.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><type>Remote&lt;EngineTag&gt;</type></entry>
+ 	 <entry>runs the &engine; specified by <type>EngineTag</type>
+ 	 on a specified context.</entry>
+ 	</row>
+ 	<row>
+ 	 <entry><type>Remote&lt;Dynamic&gt;</type></entry>
+ 	<entry>runs a <type>Dynamic</type> one-dimensional, resizable
+ 	&engine; on a specified context.  This is a specialization of
+ 	<type>Remote</type>.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+ 
+ <!-- FIXME: Place in firstterm. -->
+     <para><glossterm linkend="glossary-brick">&brick;
+     &engine;s</glossterm> explicitly store values just like &c;
+     arrays.  &compressiblebrick; &engine;s optimize their storage
+     requirements when all values are identical.  Many &array;s use one
+     of these two &engine;s.  &brick;s are the default &engine;s for
+     &array; and &field; containers because they explicitly store each
+     value.  This explicit storage can require a large amount of space,
+     particularly if all these values are the same.  If all a
+     compressible brick &engine;'s values are identical, the &engine;
+     stores that one value rather than many, many copies of the same
+     value.  These engines can both save time as well as space.
+     Initializing a compressible engine requires setting only one
+     value, not every value.  Using less storage space may also permit
+     more useful values to be stored in cache, improving cache
+     performance.  Reading a value in a compressed &engine; using the
+     <literal>read</literal> member function is as fast as
+     reading a value in a &brick; &engine;, but writing a value always
+     requires executing an additional <literal>if</literal>
+     conditional.  Thus, if an &engine; infrequently has multiple
+     different values during its life time, a &compressiblebrick;
+     &engine; may be faster than a &brick; &engine;.  If an &engine; is
+     created and its values are mostly read, not written, a
+     &compressiblebrick; &engine; may also be faster.  Otherwise, a
+     &brick; &engine; may be preferable.  Timing the same program using
+     the two different &engine; types will reveal which is faster for a
+     particular situation.  In distributed computing, many &engine;s
+     may have few nonzero values so &compressiblebrick; &engine;s may
+     be preferable.  For distributed computing, a container's domain is
+     partitioned into regions each computed by a separate processor and
+     &engine;.  If the computation is concentrated in sections of the
+     domain, many &engine;s may have few, if any, nonzero values.
+     Thus, &compressiblebrick; &engine;s may be preferable for
+     distributed computing.</para>
+ 
+     <para>Both &brick; and &compressiblebrick; &engine;s have
+     <literal>read</literal> and
+     <literal>operator()</literal> member functions taking &int;
+     and &loc; parameters.  The parameters should match the &array;'s
+     dimensionality.  For example, if &array; <varname>a</varname> has
+     dimensionality&nbsp;3, <function>a.read(int, int, int)</function>
+     and <function>a(int, int, int)</function> should be used.  The
+     former returns a value that cannot be modified, while the latter
+     can be changed.  Using the <literal>read</literal> member
+     function can lead to faster code.  Alternatively, an index can be
+     specified using a &loc;.  For example,
+     <literal>a.read(Loc&lt;3&gt;(1,-2,5))</literal> and
+     <literal>a(Loc&lt;3&gt;(1,-2,5))</literal> are equivalent to
+     <literal>a.read(1,-2,5))</literal> and
+     <literal>a(1,-2,5)</literal>.</para>
+ 
+     <para>The &dynamic; &engine; supports changing domain sizes while
+     a program is executing.  It is basically a one-dimensional
+     &brick;, explicitly storing values, but permitting the number and
+     order of stored values to change.  Thus, it supports the same
+     interface as &brick; except that all member functions are
+     restricted to their one-dimensional versions.  For example,
+     <literal>read</literal> and
+     <literal>operator()</literal> take <type>Loc&lt;1&gt;</type>
+     or one &int; parameter.  In addition, the one-dimensional domain
+     can be dynamically resized using <literal>create</literal>
+     and <literal>destroy</literal>.
+ <![%unfinished;[
+ ; see .
+ 
+ HERE Dynamic. How does one change the domain size?  What is the model?
+ ]]>  <!-- end unfinished -->
+ </para>
+ 
+ <![%unfinished;[
+ <!-- HERE: Array cannot forward domain size changes to underlying Dynamic Engine. -->
+ 
+     <para>Types of &engine;s:
+    Brick - explicitly store values
+    CompressibleBrick - explicitly store values but store only one if all the same
+    ConstantFunction - convert scalar into an array
+    DynamicEngine - contiguous, local, resizable, 1D block
+    ExpressionEngine - evaluate PETE expression
+    CompFwd - array formed by extracted components from array
+      ForwardEngine
+      tut-02.html: use .comp() or .readComp()
+    IndexFunctionEngine - convert function of indices into an array
+    IndirectionEngine - incomplete
+    MultiPatch - ?How do I describe this?
+    RemoteDynamic - run a Dynamic engine on a specified context
+    Remote - permit computations on specified context
+      should discuss with MultiPatch
+    Stencil - apply a stencil to an array, returning a new Array with the results
+    UserFunction - Array = apply function to an Array
+ </para>
+ 
+    <para>How do I organize these engines into understandable
+ 	     categories?
+ 
+    storage
+     Brick
+     CompressibleBrick
+     Dynamic - resizable 1D block
+       RemoteDynamic
+     MultiPatch - ?WHAT?
+       Remote
+ 
+    computation
+     CompFwd: project(array)->array
+       .comp() and .readComp()
+       view, not a copy
+     ConstantFunction: scalar(array)->array
+       explicitly use
+     IndexFunctionEngine: function(indices)->array
+       explicitly use
+     ExpressionEngine: expression(array)->array
+       created by data-parallel expression
+     Stencil: stencil(array)->array
+       implicitly used
+       explicitly use Stencil<...> type
+     UserFunction: function(array)->array
+       explicitly use
+ </para>
+ 
+     <para>
+       Element_t read(Loc&lt;&dim;&gt;)
+       ElementRef_t operator()(Loc&lt;&dim;&gt;)
+       Element_t read(int+)
+       ElementRef_t operator()(int+)
+     </para>
+ 
+     <para>Explain the concept of an engine.  How does an engine
+     interact with a container or an &array;?  Explain the different
+     types of engines likely to be used by &pooma; programmers and how
+     to declare containers using them.  Should I list the other engines
+     that are automatically created?</para>
+ ]]>  <!-- end unfinished -->
+ 
+    </section>
+   </chapter>
+ 
+ 
+   &data-parallel-chapter;
+ 
+ 
+   <chapter id="views">
+    <title>Container Views</title>
+ 
+    <indexterm zone="views">
+     <primary>container</primary>
+     <secondary>view</secondary>
+    </indexterm>
+    <indexterm>
+     <primary>view of a container</primary>
+     <see>container, view.</see>
+    </indexterm>
+ 
+ <![%temporary;[
+ 
+    <para>A <glossterm linkend="glossary-view"><firstterm>view of a
+    container</firstterm></glossterm> is a container accessing a subset
+    of &container;'s domain and values.  The subset can include all of
+    the container's domain.  A <quote>view</quote> is so named because
+    it is a different way to access, or view, another container's
+    values.  Both the container and its view share the same underlying
+    engine so changing values in one also changes them in the
+    other.</para>
+ 
+    <para>A view is created by following a container's name by
+    parentheses containing a domain.  For example, consider this code
+    extracted from <xref
+    linkend="tutorial-array_parallel-doof2d"></xref> in <xref
+    linkend="tutorial-array_data_parallel"></xref>.
+ <programlisting>
+ Interval<1> N(0, n-1);
+ Interval<2> vertDomain(N, N);
+ Interval<1> I(1,n-2);
+ Interval<1> J(1,n-2);
+ Array<2, double, Brick> a(vertDomain);
+ Array<2, double, Brick> b(vertDomain);
+ a(I,J) = (1.0/9.0) *
+   (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+    b(I  ,J+1) + b(I  ,J  ) + b(I  ,J-1) +
+    b(I-1,J+1) + b(I-1,J  ) + b(I-1,J-1));
+ </programlisting>  The last statement creates ten views.  For example,
+ 
+    <literal>a(I,J)</literal> creates a view of
+    <varname>a</varname> using the smaller domain specified by
+    <varname>I</varname> and <varname>J</varname>.  This omits the
+    outermost rows of columns of&nbsp;<varname>a</varname>.  The views
+    of <varname>b</varname> illustrate the use of views in
+    data-parallel statements.  <literal>b(I-1,J-1)</literal> has a
+    subset shifted up one row and left one column compared with
+    <literal>b(I,J)</literal>.</para>
+ ]]>  <!-- end temporary -->
+ <![%unfinished;[
+    <para>Be sure to list the various arithmetic operations on domains
+    that can be used.  This was deferred from the &array; and domain
+    chapter.  Explain &array;'s <function>comp</function> function.</para>
+ 
+ <!-- FIXME: Finish this chapter. -->
+ ]]>  <!-- end unfinished -->
+   </chapter>
+ 
+ 
+ <![%unfinished;[
+   <chapter id="sequential">
+    <title>Writing Sequential Programs</title>
+ 
+    <para>FIXME: Explain the chapter's purpose.</para>
+ 
+    <para>FIXME: Explain the format of each section.</para>
+ 
+    <para>FIXME: Explain the order of the sections.</para>
+ 
+    <para>Proposed order.  Basically follow the order in the proposed
+    reference section.
+     <orderedlist>
+      <listitem><para>starting, stopping</para></listitem>
+      <listitem><para>&array;</para></listitem>
+      <listitem><para>&dynamicarray;</para></listitem>
+      <listitem><para>&field;</para></listitem>
+      <listitem><para>&vector;</para></listitem>
+      <listitem><para>&matrix;</para></listitem>
+      <listitem><para>&tensor;</para></listitem>
+      <listitem><para>&engine;</para></listitem>
+      <listitem><para>domain</para></listitem>
+      <listitem><para>correctness, e.g., <function>PAssert</function></para></listitem>
+      <listitem><para>&pooma; command-line options</para></listitem>
+     </orderedlist>
+     Include views of containers in the appropriate sections.</para>
+ 
+    <para><emphasis>&c;: A Reference Manual</emphasis> uses this
+    structure for &c; libraries:
+     <orderedlist>
+      <listitem>
+       <para>function declarations, separated by rules from rest of text</para>
+      </listitem>
+      <listitem>
+       <para>text explanation</para>
+      </listitem>
+      <listitem>
+       <para>table of structure members if appropriate</para>
+      </listitem>
+      <listitem>
+       <para>example</para>
+      </listitem>
+     </orderedlist>
+    </para>
+ 
+    <para><emphasis>STL Tutorial and Reference Guide</emphasis>, second
+    edition, uses this structure for STL functions:
+     <orderedlist>
+      <listitem>
+       <para>text description with declaration mixed in</para>
+      </listitem>
+      <listitem>
+       <para>example program mixed into text.  It is an entire program,
+       not a program fragment.</para>
+      </listitem>
+     </orderedlist>
+    </para>
+ 
+    <para>A tutorial chapter for containers has
+     <orderedlist>
+      <listitem>
+       <para>explanation of template types</para>
+      </listitem>
+      <listitem>
+       <para>bulleted list of container types</para>
+      </listitem>
+      <listitem>
+       <para>example constructors</para>
+      </listitem>
+      <listitem>
+       <para>example programs</para>
+      </listitem>
+      <listitem>
+       <para>member and related functions with example programs</para>
+      </listitem>
+      <listitem>
+       <para>list of accessors and relation functions</para>
+      </listitem>
+     </orderedlist>
+    </para>
+ 
+    <para>The reference chapter for containers has
+     <orderedlist>
+      <listitem>
+       <para>a section listing common members and types for all containers</para>
+      </listitem>
+      <listitem>
+       <para>a section listing common member functions for all containers</para>
+      </listitem>
+      <listitem>
+       <para>requirements for various container specialties</para>
+      </listitem>
+     </orderedlist>
+     The section describing <type>vector</type>s contains
+     <orderedlist>
+      <listitem>
+       <para>files (header files)</para>
+      </listitem>
+      <listitem>
+       <para>class declaration</para>
+      </listitem>
+      <listitem>
+       <para>description</para>
+      </listitem>
+      <listitem>
+       <para>type definitions</para>
+      </listitem>
+      <listitem>
+       <para>constructors, destructors, and related functions</para>
+      </listitem>
+      <listitem>
+       <para>comparison operators</para>
+      </listitem>
+      <listitem>
+       <para>element access member functions</para>
+      </listitem>
+      <listitem>
+       <para>insert and erase member functions</para>
+      </listitem>
+      <listitem>
+       <para>notes</para>
+      </listitem>
+     </orderedlist>
+    </para>
+ 
+    <para>Josuttis's <emphasis>The &cc; Standard Library: A Tutorial
+    and Reference</emphasis> uses this structure for its STL container
+    chapter:
+     <orderedlist>
+      <listitem>
+       <para>short introduction</para>
+      </listitem>
+      <listitem>
+       <para>common container abilities</para>
+      </listitem>
+      <listitem>
+       <para>common container operations (with table)</para>
+      </listitem>
+      <listitem>
+       <para>vector abilities</para>
+      </listitem>
+      <listitem>
+       <para>vector operations:
+        <orderedlist>
+ 	<listitem>
+ 	 <para>create, copy, and destroy operations (mostly table)</para>
+ 	</listitem>
+ 	<listitem>
+ 	 <para>non-modifying operations (mostly table)</para>
+ 	</listitem>
+ 	<listitem>
+ 	 <para>assignments (mostly table)</para>
+ 	</listitem>
+ 	<listitem>
+ 	 <para>element access (mostly table)</para>
+ 	</listitem>
+ 	<listitem>
+ 	 <para>iterator functions (mostly table)</para>
+ 	</listitem>
+ 	<listitem>
+ 	 <para>inserting and removing elements (mostly table)</para>
+ 	</listitem>
+        </orderedlist>
+       </para>
+      </listitem>
+      <listitem>
+       <para>using vectors as ordinary arrays</para>
+      </listitem>
+      <listitem>
+       <para>exception handling</para>
+      </listitem>
+      <listitem>
+       <para>example program</para>
+      </listitem>
+     </orderedlist>
+    </para>
+ 
+    <section id="sequential-begin_end">
+     <title>Beginning and Ending &pooma; Programs</title>
+ 
+     <para>Every &pooma; program must begin with a call to
+     <function>initialize</function> and end with a call to
+     <function>finalize</function>.  These functions respectively
+     prepare and shut down &pooma;'s run-time structures.</para>
+ 
+     <bridgehead id="sequential-begin_end-files" renderas="sect2">Files</bridgehead>
+ 
+      <programlisting>
+      #include "Pooma/Pooma.h"  // or "Pooma/Arrays.h" or "Pooma/Fields.h" or ...
+      </programlisting>
+ 
+     <bridgehead id="sequential-begin_end-declarations" renderas="sect2">Declarations</bridgehead>
+ 
+      <funcsynopsis>
+       <funcprototype>
+        <funcdef>bool <function>Pooma::initialize</function></funcdef>
+        <paramdef>
+         <parameter class="function">int &amp;argc,</parameter>
+         <parameter class="function">char ** &amp;argv,</parameter>
+         <parameter class="function">bool initRTS = true,</parameter>
+         <parameter class="function">bool getCLArgsArch = true,</parameter>
+         <parameter class="function">bool initArch = true</parameter>
+        </paramdef>
+       </funcprototype>
+ 
+       <funcprototype>
+        <funcdef>bool <function>Pooma::initialize</function></funcdef>
+        <paramdef>
+         <parameter class="function">Pooma::Options &amp;opts,</parameter>
+         <parameter class="function">bool initRTS = true,</parameter>
+         <parameter class="function">bool initArch = true</parameter>
+        </paramdef>
+       </funcprototype>
+ 
+       <funcprototype>
+        <funcdef>bool <function>Pooma::finalize</function></funcdef>
+        <void></void>
+       </funcprototype>
+ 
+       <funcprototype>
+        <funcdef>bool <function>Pooma::finalize</function></funcdef>
+        <paramdef>
+         <parameter class="function">bool quitRTS,</parameter>
+         <parameter class="function">bool quitArch</parameter>
+        </paramdef>
+       </funcprototype>
+      </funcsynopsis>
+ 
+     <bridgehead id="sequential-begin_end-description" renderas="sect2">Description</bridgehead>
+ 
+      <para>Before its use, the &poomatoolkit; must be initialized by a
+      call to <function>initialize</function>.  This usually occurs in
+      the <function>main</function> function.  The first form removes
+      and processes any &pooma;-specific arguments from the
+      command-line arguments <varname>argv</varname> and
+      <varname>argc</varname>.  <xref
+      linkend="sequential-options"></xref> describes these options.
+      The third, fourth, and fifth arguments all have a default value
+      of &true;.  If <parameter class="function">initRTS</parameter> is
+      &true;, the run-time system is initialized.  E.g., the contexts
+      are prepared for use.  If <parameter
+      class="function">getCLArgsArch</parameter> is &true,
+      architecture-specific command-line arguments are removed from
+      <varname>argv</varname> and <varname>argc</varname>.
+      Architecture-specific initialization occurs if <parameter
+      class="function">getCLArgsArch</parameter> is &true;.  An <link
+      linkend="glossary-architecture">architecture</link> is specified
+      by a hardware interface, e.g., processor type, but frequently is
+      also associated with an operating system or compiler.  For
+      example, Metrowerks for the Macintosh has an
+      architecture-specific initialization.  The function always
+      returns &true;.</para>
+ 
+      <para><function>initialize</function>'s alternative form
+      assumes the &pooma;-specific and architecture-specific
+      command-line arguments have already been removed from
+      <varname>argv</varname> and <varname>argc</varname> and stored in
+      <parameter class="function">opts</parameter>.  Its other two
+      parameters have the same meaning, and the two functions'
+      semantics are otherwise the same.</para>
+ 
+      <para>After its use, the &poomatoolkit; should be shut down using
+      a call to <function>finalize</function>.  This usually occurs in
+      the <function>main</function> function.  The former, and more
+      frequently used, form first prints any statistics and turns off
+      all default &pooma; streams.  Then it shuts down the run-time
+      system if it was previously initialized and then shuts down
+      architecture-specific objects if they were previously
+      initialized.  The latter form gives provides explicit control
+      whether the run-time system (<parameter
+      class="function">quitRTS</parameter>) and architecture-specific
+      objects (<parameter class="function">quitArch</parameter>) are
+      shut down.  Both functions always returns &true;.</para>
+ 
+      <para>Including almost any &pooma; header file, rather than just
+      <filename class="headerfile">Pooma/Pooma.h</filename> suffices
+      since most other &pooma; header files include it.</para>
+ 
+     <bridgehead id="sequential-begin_end-example" renderas="sect2">Example Program</bridgehead>
+ 
+      <para>Since every &pooma; program must call
+      <function>initialize</function> and
+      <function>finalize</function>, the simplest &pooma; program also
+      must call them.  This program also illustrates their usual
+      use.</para>
+ 
+      &initialize-finalize;
+ 
+    </section><!-- end sequential-begin_end -->
+ 
+ 
+    <section id="sequential-global">
+     <title>Global Variables</title>
+ 
+     <para>&pooma; makes a few global variables available after
+     initialization.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0">
+      <title>&pooma; Global Variables</title>
+      
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>variable</entry>
+ 	<entry>description</entry>
+        </row>
+       </thead>
+       <tbody valign="top">
+        <row>
+ 	<entry>&inform; <varname>pinfo</varname></entry>
+ 	<entry>output stream used to print informative messages to the
+ 	user while the program executes.  The stream accepts a
+ 	superset of standard output operations.</entry>
+        </row>
+        <row>
+ 	<entry>&inform; <varname>pwarn</varname></entry>
+ 	<entry>FIXME: output stream used to print informative messages to the
+ 	user while the program executes.  The stream accepts a
+ 	superset of standard output operations.</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+    </section>
+ 
+    <section id="sequential-options">
+     <title>&pooma; Command-line Options</title>
+ 
+     <para>Every &pooma; program accepts a set of &pooma;-specific
+     command-line options to set values at run-time.</para>
+ 
+     <para>QUESTION: Should I defer documenting &options; to the
+     reference manual, instead just listing commonly used options in
+     the previous section?
+ 
+ UNFINISHED</para>
+ 
+     <section id="sequential-options-list">
+      <title>Options Summary</title>
+ 
+      <variablelist>
+       <varlistentry>
+        <term><parameter class="option">&dashdash;pooma-info</parameter></term>
+        <listitem>
+ 	<para>enable use of the <varname>pinfo</varname>, used to
+ 	print informative messages to the user while the program
+ 	executes.</para>
+        </listitem>
+       </varlistentry>
+ <!-- UNFINISHED -->
+      </variablelist>
+ 
+      <para>FIXME: Be sure to list default values.</para>
+ <!-- FIXME: need to describe the pinfo, pwarn, and perr streams somewhere.  To do so requires describing informs.-->
+ <!-- FIXME: Which streams are buffered and which are not? -->
+ 
+     </section>
+ 
+    </section><!-- end sequential-options -->
+ 
+    <section>
+     <title>TMP: Place these somewhere.</title>
+ 
+     <para>&pooma; can reorder computations to permit more efficient
+     computation.  When running a sequential program, reordering may
+     permit omission of unneeded computations.  For example, if only
+     values from a particular field are printed, only computations
+     involving the field and containers dependent on it need to occur.
+     When running a distributed program, reordering may permit
+     computation and communication among processors to overlap.
+     &pooma; automatically tracks dependences between data-parallel
+     expressions, ensuring correct ordering.  It does not track
+     statements accessing particular &array; and &field; values so the
+     programmer must precede these statements with calls to
+     <function>Pooma::blockAndEvaluate()</function>.  Each call forces
+     the executable to wait until all computation has completed.  Thus,
+     the desired values are known to be available.  In practice, some
+     calls to <function>Pooma::blockAndEvaluate</function> may not be
+     necessary, but omitting them requires knowledge of &pooma;'s
+     dependence computations, so the &author; recommends calling
+     <function>Pooma::blockAndEvaluate</function> before each access to
+     a particular value in an &array; or &field;.  Omitting a necessary
+     call may lead to a race condition.
+ <![%unfinished;[
+     See <xref
+     linkend="debugging_profiling-missing_blockandevaluate"></xref> for
+     instructions how to diagnose and eliminate these race
+     conditions.
+ ]]>  <!-- end unfinished -->
+ </para>
+ 
+     <para>Where talk about various &pooma; streams?</para>
+ 
+    <para>UNFINISHED</para>
+ 
+    </section>
+ 
+ 
+    <section id="sequential-benchmarks">
+     <title>&benchmark; Programs</title>
+ 
+     <para>Define a &benchmark; program vs. an example or an
+     executable.  Provide a short overview of how to run these
+     programs.  Provide an overview of how to write these programs.
+     See <filename
+     class="headerfile">src/Utilities/Benchmark.h</filename>.</para>
+    </section>
+ 
+ 
+    <section>
+     <title>Miscellaneous</title>
+ 
+     <para>Section&nbsp;3, "Domains and Views," of
+     <filename>papers/iscope98.pdf</filename> describes four types of
+     domains.</para>
+ 
+     <section id="concepts-data_parallel">
+      <title>Data-Parallel Statements</title>
+ 
+      <para>Can we use "An Overview of &pete;" from
+     <filename>papers/PETE_DDJ/ddj_article.html</filename> or is this
+     too low-level?</para>
+ 
+      <para>Section&nbsp;3.2.1 of <filename>papers/pooma.ps</filename>
+     gives a simple example of data-parallel expression.  It also has a
+     paragraph introducing data-parallel operations and selecting
+     subsets of domains.  Section&nbsp;3.4 describes the Chained
+     Expression Object (<acronym>CEO</acronym>), apparently a precursor
+     of &pete;.  Regardless, it provides some motivation and
+     introductory material.</para>
+ 
+     <para>From Section&nbsp;4 of
+     <filename>papers/SiamOO98_paper.ps</filename>:</para>
+ 
+      <para>This version of &pete; reduces compile time of user codes
+     and utilizes compile-time knowledge of expression &domain;s for
+     better optimization.  For example, more efficient loops for
+     evaluating an expression can be generated if &pete; knows that the
+     &domain; has unit stride in memory.</para>
+ 
+     <para>Section&nbsp;4, "Expressions and Evaluators", of
+     <filename>papers/iscope98.pdf</filename> has a good explanation of
+     &pooma;&nbsp;II's expression trees and expression engines.</para>
+ 
+     <para>COMMENT: <filename
+     class="libraryfile">background.html</filename> has some related
+     &pete; material.</para>
+    </section>
+ 
+ 
+    <section>
+ 	     <title>Containers</title>
+ 
+ 	     <section id="concepts-containers-array">
+      <title>&array;</title>
+ 
+      <blockquote>
+ 	     <attribution>Section&nbsp;4 "Future Improvements in
+      &pooma;&nbsp;II" of
+      <filename>papers/SiamOO98_paper.ps</filename></attribution>
+ 	     <para>
+      An &array; can be thought of as a map from one &domain; to
+      another.&hellip; &array;s depend only on the interface of
+      &domain;s.  Thus, a subset of view of an &array; can be
+      manipulated in all the same ways as the original &array;.
+      &array;s can perform indirect addressing because the output
+      &domain; one one &array; can be used as the input &domain; of
+      another &array;.  &array;s also provide individual element
+      access.</para>
+      </blockquote>
+ 
+ 
+      <para>
+       (unformatted) From
+       <filename>papers/GenericProgramming_CSE/dubois.html</filename>:
+       The &pooma; &array; concept provides an example of how these
+       generic-programming features can lead to flexible and efficient
+       code. An Array maps a fairly arbitrary input domain to an
+       arbitrary range of outputs. When used by itself, an &array;
+       object <varname>A</varname> refers to all of the values in its
+       domain. Element-wise mathematical operations or functions can be
+       applied to an array using straightforward notation, like A + B
+       or sin(A). Expressions involving Array objects are themselves
+       Arrays. The operation A(d), where d is a domain object that
+       describes a subset of A's domain, creates a view of A that
+       refers to that subset of points. Like an array expression, a
+       view is also an Array. If d represents a single point in the
+       domain, this indexing operation returns a single value from the
+       range. Equivalently, one can index an N-dimensional Array by
+       specifying N indices, which collectively specify a single point
+       in the input domain: A(i1, i2, ..., iN).</para>
+ 
+      <para>The &pooma; multidimensional Array concept is similar to
+       the &fortran;&nbsp;90 array facility, but extends it in several
+       ways. Both &pooma; and &fortran; arrays can have up to seven
+       dimensions, and can serve as containers for arbitrary
+       types. Both support the notion of views of a portion of the
+       array, known as array sections in F90. The &pooma; Array concept
+       supports more complex domains, including bounded, continuous
+       (floating-point) domains. Furthermore, Array indexing in &pooma;
+       is polymorphic; that is, the indexing operation X(i1,i2) can
+       perform the mapping from domain to range in a variety of ways,
+       depending on the particular type of the Array being
+       indexed.</para>
+ 
+      <para>&fortran; arrays are dense and the elements are arranged
+ 		   according to column-major conventions. Therefore, X(i1,i2)
+       refers to element number i1-1+(i2-1)*numberRowsInA. However, as
+       Fig. 1 shows, &fortran;-style "Brick" storage is not the only
+       storage format of interest to scientific programmers. For
+       compatibility with C conventions, one might want to use an array
+       featuring dense, row-major storage (a C-style Brick). To save
+       memory, it might be advantageous to use an array that only
+       stores a single value if all its element values are the
+       same. Other sparse storage schemes that only store certain
+       values may also be desirable. To exploit parallelism, it is
+       convenient for an array's storage to be broken up into patches,
+       which can be processed independently by different CPUs. Finally,
+       one can imagine an array with no data at all. For example, the
+       values can be computed from an expression involving other
+       arrays, or analytically from the indices.
+      </para>
+ 
+      <para>The &pooma; &array; Class Template</para>
+ 
+      <para>Next we describe &pooma;'s model of the Array concept, the
+      Array class template. The three most important requirements from
+      the point of view of overall design are: (1) arbitrary domain,
+      (2) arbitrary range, and (3) polymorphic indexing. These express
+      themselves in the template parameters for the &pooma; Array
+      class. The template
+      <programlisting>
+      template &lt;int Dim, class T = double, class EngineTag = Brick&gt;
+      class Array;
+      </programlisting>
+      is a specification for creating a set of classes all named
+      Array. The template parameters Dim, T, and EngineTag determine
+      the precise type of the Array. Dim represents the dimension of
+      the array's domain. T gives the type of array elements, thereby
+      defining the output range of the array. EngineTag specifies the
+      the manner of indexing and types of the indices.</para>
+ 
+      <para>End From
+      <filename>papers/GenericProgramming_CSE/dubois.html</filename>:</para>
+ 
+      <para>Section&nbsp;2, "Arrays and Engines," of
+      <filename>papers/iscope98.pdf</filename> describes both &array;s
+      and &engine;s.  This may or may not duplicate the material in
+      <filename>papers/GenericProgramming_CSE/dubois.html</filename>.</para>
+ 
+      <section id="concepts-containers-array-views">
+       <title>Views of &array;s</title>
+ 
+       <para>Section&nbsp;3, "Domains and Views," of
+       <filename>papers/iscope98.pdf</filename> motivates the need for
+       views:
+        <blockquote>
+ 	<para>One of the primary uses of domains is to specify
+ 	subsections of &array; objects.  Subarrays are a common
+ 	feature of array classes; however, it is often difficult to
+ 	make such subarrays behave like first-class objects.  The
+ 	&pooma;&nbsp;II engine concept provides a clean solution to
+ 	this problem: subsetting an &array; with a domain object
+ 	creates a new &array; that has a view engine.</para>
+        </blockquote>
+       </para>
+      </section>
+     </section>
+ 
+     <section id="concepts-containers-field">
+      <title>&field;</title>
+ 
+ 	     <para>QUESTION: Do we include boundary conditions here?
+ 
+      FINISH: Do we have an example that shows something not possible
+      with &array;?</para>
+ 
+ 	     <para>Describe and illustrate multi-material and
+      multivalue?</para>
+ 
+ 	     <para>ADD: description of meshes and guard layers.</para>
+ 
+ 	    </section>
+      </section>
+ 
+      <section id="concepts-engines">
+       <title>Engines</title>
+ 
+       <para>(unformatted) From
+     <filename>papers/GenericProgramming_CSE/dubois.html</filename>:</para>
+ 
+       <para>The Engine Concept</para>
+ 
+       <para>To implement polymorphic indexing, the &array; class defers
+       data storage and data lookup to an &engine; object. The
+       requirements that the &array; template places on its &engine;
+       provide the definition for the &engine; concept. We'll describe
+       these by examining a simplified version of the &array; template,
+       shown in Fig. 2.</para>
+ 
+       <para>First, the &array; class determines and exports (makes
+     Engine_t part of &array;'s public interface) the type of the engine
+     class that it will use:
+     <programlisting>
+     typedef Engine&lt;Dim, T, EngineTag&gt; Engine_t;
+     </programlisting>
+     This statement declares Engine_t to be an alias for the type
+     Engine&lt;Dim,T,EngineTag&gt;. This is the first requirement
+     placed on engine classes: they must be specializations of a
+     general Engine template whose template parameters are identical to
+     those of &array;. Next, the &array; template determines the type of
+     scalar arguments (indices) to be used in operator(), the function
+     that implements &pooma;'s &fortran;-style indexing syntax X(i1,i2):
+     <programlisting>
+     typedef typename Engine_t::Index_t Index_t;
+     </programlisting>
+     This statement defines another type alias:
+     Array&lt;Dim,T,EngineTag&gt;::Index_t is simply an alias for
+     Engine_t::Index_t. Engine_t::Index_t is a qualified name, which
+     means that the type Index_t is found in the class Engine_t. This
+     is the second requirement for the Engine concept: the class
+     Engine_t must define a public type called Index_t. This line will
+     not compile if that definition is not supplied. This indirection
+     is one of the ways that &pooma; supports polymorphic indexing. If
+     the Engine works with a discrete integer domain, it defines its
+     Index_t to be an integral type. If the Engine works in a
+     continuous domain, it defines its Index_t to be a floating-point
+     type.</para>
+ 
+     <para>The data lookup is performed in the operator() function. We
+     see that &array; simply passes the indices on to its engine
+     object. Thus, we have the third requirement for the Engine
+     concept: it must provide a version of operator() that takes Dim
+     values of type Index_t.</para>
+ 
+       <para>Simply passing the indices on to the engine object may seem
+     odd. After all, engine(i,j) looks like we're just indexing another
+     array. There are several advantages to this extra level of
+     indirection. The &array; class is as faithful a model of the &array;
+     concept as possible, while the Engine class is a low-level
+     interface to a user-defined data source. As a result, &array; has a
+     wide variety of constructors for user convenience, while engines
+     have but a few. &array; supports a wide variety of overloaded
+     operator() functions for view creation and indexing. Engines
+     support indexing only. &array; does not have direct access to the
+     data, which is managed by the engine object. Finally, &array; has a
+     wide variety of overloaded mathematical operators and functions,
+     and works with the Portable Expression Template Engine (PETE) [4]
+     to provide efficient evaluation of &array; expressions. Engines have
+     no such support. In general, &array; is much more complex and
+     feature-laden than Engine. This is the prime advantage of the
+     separation of interface and implementation: &array; only has to be
+     implemented once by the &pooma; developers. Engines are simple
+     enough to be written by users and plugged directly into the &array;
+     framework.</para>
+ 
+     <para>Figure 3 illustrates the "Brick" specialization of the
+     Engine template, which implements &fortran;-style lookup into a
+     block of memory. First, there is the general Engine template,
+     which is empty as there is no default behavior for an unknown
+     EngineTag. The general template is therefore not a model for the
+     Engine concept and &array; classes attempting to use it will not
+     compile. Next, there is the definition of the Brick class, a
+     policy tag whose sole purpose is to select a particular
+     specialization of the Engine template. Finally, there is the
+     partial specialization of the Engine template. Examining its body,
+     we see the required Index_t typedef and the required operator(),
+     which follows the &fortran; prescription for generating an offset
+     into the data block based on the row, column, and the number of
+     rows. All of the requirements are met, so the Brick-Engine class
+     is a model of the Engine concept.</para>
+ 
+     <para>End From
+     <filename>papers/GenericProgramming_CSE/dubois.html</filename>:</para>
+ 
+     <para>(unformatted) From
+     <filename>papers/GenericProgramming_CSE/dubois.html</filename>:</para>
+ 
+     <para>Compile-time Versus Run-Time Polymorphism</para>
+ 
+     <para>Encapsulating the indexing in an Engine class has important
+     advantages, both in terms of flexibility and efficiency. To
+     illustrate this point, we introduce the PolarGaussian-Engine
+     specialization in Fig. 4. This is an analytic engine that
+     calculates its values directly from its inputs. Unlike the
+     Brick-Engine, this engine is "indexed" with data of the same type
+     as its output: it maps a set of T's to a single T. Therefore, the
+     Index_t typedef selects T as the index type, as opposed to the int
+     in the Brick-Engine specialization. The operator() function also
+     differs in that it computes the return value according to an
+     analytic formula.</para>
+ 
+     <para>Both Engine&lt;Dim,T,Brick&gt; and
+     Engine&lt;Dim,T,PolarGaussian&gt; can be plugged in to an &array; by
+     simply varying the &array;'s EngineTag. This is possible despite the
+     fact that the two classes exhibit dramatically different behavior
+     because they are both models of the Engine concept.</para>
+ 
+     <para>Notice that we have achieved polymorphic indexing without
+     the use of inheritance or virtual functions. For instance,
+     consider the following code snippet:
+     <programlisting>
+     Array<2, double, Brick> a;
+     Array<2, double, PolarGaussian> b;
+ 
+     double x = a(2, 3);     // x = a.engine.data[2 + 3 * a.engine.numRows];
+     double y = b(2.0, 3.0); // y = exp(-(2.0*2.0+3.0*3.0) / b.engine.delta);
+     </programlisting>
+     The data lookup functions for the two &array;s perform completely
+     different operations. Since this is accomplished using static
+     types, it is known as compile-time polymorphism. Moreover,
+     everything is known at compile time, so the functions are fully
+     inlined and optimized, thereby yielding code equivalent to that
+     shown in the comments above.</para>
+ 
+     <para>The flexibility and efficiency of compile-time polymorphism
+     cannot be duplicated with a run-time implementation. To illustrate
+     this point, in Fig. 5, we re-implement our &array; concept using the
+     classic Envelope-Letter pattern [5], with the array class,
+     RTArray, being the envelope and the run-time-engine, RTEngine,
+     being the letter. RTArray defers data lookup to the engine object
+     by invoking the engine's functions through a pointer to the
+     RTEngine base class. Figure 6 illustrates the RTEngine base class
+     and Fig. 7 illustrates two descendants: RTBrick and
+     RTPolarGaussian.</para>
+ 
+     <para>The run-time implementation provides the same basic
+     functionality as the compile-time implementation, but it is not as
+     flexible or as efficient. It lacks flexibility in that the return
+     type of the indexing operation must be specified in the RTEngine
+     base class and in the RTArray class. Thus, in Figs. 5 and 6,we see
+     versions of RTArray::operator() and RTEngine::index functions that
+     take both int's and T's. If the programmer wants to add another
+     index-type option, these classes must be modified. This is a
+     violation of the open-closed principle proposed by Meyer
+     [6]. Also, since RTEngine descendants will usually only implement
+     one version of index, we cannot make RTEngine an abstract base
+     class. Instead, we have the default versions of index throw an
+     exception. Thus, compile-time error checking is
+     weakened. Furthermore, since indexing is done via a virtual
+     function call, it will almost never be inlined, which is not
+     acceptable in most scientific applications.</para>
+ 
+     <para>There are advantages to the Envelope-Letter approach. First,
+     all RTArray objects have the same type, allowing them to be stored
+     in homogeneous collections. This can simplify the design of some
+     applications. Second, RTArray objects can change their engines at
+     runtime, and thus effectively change their types on the fly??this
+     is the primary reason for using the Envelope-Letter idiom, and can
+     be very important in some applications.</para>
+ 
+     <para>For most scientific applications, however, these issues are
+     minor, and maximum performance for array indexing is of paramount
+     importance. Our compile-time approach achieves this performance
+     while providing the desired polymorphic indexing.</para>
+ 
+     <para>From Section&nbsp;4 of
+     <filename>papers/SiamOO98_paper.ps</filename>:</para>
+ 
+     <para>The &array; class is templated on an &engine; type that
+     handles the actual implementation of the mapping from input to
+     output.  Thus, the &array; interface features are completely
+     separate from the implementation, which could be a single &c;
+     array, a function of some kind or some other mechanism.  This
+     flexibility allows an expression itself to be viewed through the
+     &array; interface.  Thus, one can write something like
+     <programlisting>
+     foo(A*B+C);
+     </programlisting> where <varname>A</varname>, <varname>B</varname> and
+     <varname>C</varname> are &array;s and <function>foo</function> is
+     a function taking an &array; as an argument.  The expression
+     <literal><varname>A</varname>*<varname>B</varname>+<varname>C</varname></literal>
+     will only be evaluated by the expression engine as needed by
+     <function>foo</function>.</para>
+ 
+     <para>In fact, one can even write &engine;s which are wrappers
+     around external data structures created in non-&pooma; codes and
+     know to manipulate these structures.  Once this is done, the
+     external entities have access to the entire &array; interface and
+     can utilize all of the powerful features of
+     &pooma;&nbsp;II.</para>
+ 
+     <para>Section&nbsp;2, "Arrays and Engines," of
+     <filename>papers/iscope98.pdf</filename> describes both &array;s
+     and &engine;s.  This may or may not duplicate the material in
+     <filename>papers/GenericProgramming_CSE/dubois.html</filename>.</para>
+ 
+     <para>Section&nbsp;4, "Expressions and Evaluators", of
+     <filename>papers/iscope98.pdf</filename> has a good explanation of
+     &pooma;&nbsp;II's expression trees and expression engines.</para>
+ 
+     <variablelist>
+      <varlistentry><term>&multipatch; Engine</term>
+       <listitem><para>From <filename
+       class="libraryfile">README</filename>: To actually use multiple
+       contexts effectively, you need to use the MultiPatch engine with
+       patch engines that are Remote engines.  Then the data will be
+       distributed across multiple contexts instead of being copied on
+       every context.  See the files in example/Doof2d for a simple
+       example that creates a MultiPatch array that can be distributed
+       across multiple contexts and performs a stencil computation on
+       that array.</para></listitem>
+      </varlistentry>
+     </variablelist>
+    </section>
+ 
+    </section>
+   </chapter>
+ ]]>  <!-- end unfinished -->
+ 
+ 
+ <![%unfinished;[
+   <chapter id="parallel">
+    <title>Writing Distributed Programs</title>
+ 
+    <para>Discuss the distributed model and guard cells.  See <filename
+    class="libraryfile">docs/parallelism.html</filename>.</para>
+ 
+    <para>Does any of the parallel implementation described in
+    <filename>papers/SCPaper-95.html</filename> still apply?</para>
+ 
+    <para>?Tuning program for maximize parallel performance?</para>
+ 
+    <para>external references to &mpi; and threads</para>
+ 
+    <para>QUESTION: Are there interesting, short parallel programs in
+    any &mpi; book that we can convert to &pooma;?</para>
+ 
+    <section>
+     <title>Layouts</title>
+ 
+     <para>An out-of-date description can be found in Section&nbsp;3.3,
+     especially 3.3.2, of <filename>papers/pooma.ps</filename>
+     describes the global/local interactions and parallel abstraction
+     layers.</para>
+    </section>
+ 
+    <section>
+     <title>Parallel Communication</title>
+ 
+     <para>An out-of-date description can be found in
+      Section&nbsp;3.3.3 of <filename>papers/pooma.ps</filename></para>
+    </section>
+ 
+    <section>
+     <title>Using Threads</title>
+ 
+     <para>QUESTION: Where do threads fit into the manual?  Do threads
+     even work?</para>
+ 
+     <para>From Section&nbsp;4, of
+     <filename>papers/SiamOO98_paper.ps</filename></para>
+ 
+     <para>&pooma;&nbsp;II will make use of a new parallel run-time
+     system called &smarts; that is under development at the ACL.
+     &smarts; supports lightweight threads, so the evaluator will be
+     able to farm out data communication tasks and the evaluation of
+     subsets of an expression to multiple threads, thus increasing the
+     overlap of communication and computation.  Threads will also be
+     available at the user level for situations in which a
+     task-parallel approach is deemed appropriate.</para>
+    </section>
+ 
+   </chapter>
+ ]]>  <!-- end unfinished -->
+ 
+ 
+ <![%unfinished;[
+   <chapter id="debugging_profiling">
+    <title>Debugging and Profiling &pooma; Programs</title>
+ 
+    <para>Consider &dashdash;pooma-debug <replaceable>number</replaceable>.
+    See also other &pooma; options in <filename
+    class="headerfile">src/Utilities/Options.h</filename>.</para>
+ 
+    <para>UNFINISHED</para>
+     <section id="debugging_profiling-missing_blockandevaluate">
+      <title>Finding Race Conditions From Missing
+      <function>blockAndEvaluate</function> Calls</title>
+ 
+       <para>&pooma; may reorder computations so calls to
+       <function>Pooma::blockAndEvaluate()</function> are necessary
+       before accessing particular &array; and &field; values.
+       Omission of necessary calls can lead to race conditions where
+       the ordering of reads and writes to particular values is
+       incorrect.  To help diagnose if calls to
+       <function>Pooma::blockAndEvaluate</function> are missing, invoke
+       a &pooma; executable with the
+       <literal>&dashdash;pooma-blocking-expressions</literal> option.
+       This automatically causes
+       <function>Pooma::blockAndEvaluate</function> to be called after
+       each statement.  Doing so ensures program correctness, but it
+       may increase running times, particularly if multiple processors
+       are used, because computation and communication may not overlap
+       as much as possible.  Of course, program correctness is more
+       important than execution speed.</para>
+ 
+       <para>If using
+       <literal>&dashdash;pooma-blocking-expressions</literal> changes a
+       program's output, it is missing one or more calls to
+       <function>Pooma::blockAndEvaluate</function>.  To narrow the
+       region with a missing call, surround the region in question with
+       calls to <literal>Pooma::blockingExpressions(true)</literal>
+       and <literal>Pooma::blockingExpressions(false)</literal>,
+       but do not use the
+       <literal>&dashdash;pooma-blocking-expressions</literal> option.
+       Within the region, <function>Pooma::blockAndEvaluate</function>
+       will be invoked after each statement.  Repeatedly reducing the
+       region's size should reveal where calls are missing.</para>
+     </section>
+   </chapter>
+ ]]>  <!-- end unfinished -->
+ 
+ 
+ <![%unfinished;[
+  </part>
+ ]]>  <!-- end unfinished -->
+ 
+ <![%unfinished;[
+  <part id="reference">
+   <title>&pooma; Reference Manual</title>
+ 
+   <chapter id="tmp_ref">
+    <title>TMP: This Chapter Holds These Comments But Will Be Removed</title>
+ 
+    <para>For each template parameter need to describe the constraints
+    on it.</para>
+ 
+    <para>Remove this section when the following concerns have been
+    addressed.</para>
+ 
+    <para>Add a partintro explaining file suffixes such as <filename
+    class="headerfile">.h</filename>, <filename
+    class="libraryfile">.cpp</filename>, <filename
+    class="libraryfile">.cmpl.cpp</filename>, <filename
+    class="libraryfile">.mk</filename>, <filename
+    class="libraryfile">.conf</filename>.  Should we also explain use
+    of <literal>inline</literal> even when necessary and the template
+    model, e.g., including <filename
+    class="libraryfile">.cpp</filename> files.</para>
+ 
+    <para>QUESTION: What are the key concepts around which to organize
+    the manual?</para>
+ 
+    <para>QUESTION: What format should the manual use?</para>
+ 
+    <blockquote>
+     <attribution>Musser, Derge, and Sanai, &sect;20.0.</attribution>
+     <para>It is important to state the requirements on the components
+     as generally as possible.  For example, instead of saying
+     <quote>class <type>X</type> must define a member function
+     <function>operator++()</function>,</quote> we say <quote>for any
+     object&nbsp;<varname>x</varname> of type&nbsp;<type>X</type>,
+     <classname>++x</classname> is defined.</quote></para>
+    </blockquote>
+   </chapter>
+ 
+ 
+   <chapter id="class_structure_ref">
+    <title>A Typical &pooma; Class</title>
+ 
+    <variablelist>
+     <title>Class Member Notation</title>
+     <varlistentry>
+      <term><fieldsynopsis>
+        <varname>*_t</varname>
+       </fieldsynopsis>
+      </term>
+      <listitem>
+       <para>type within a class.  QUESTION: What is the &cc; name for
+       this?</para>
+      </listitem>
+     </varlistentry>
+     <varlistentry>
+      <term><fieldsynopsis>
+        <varname>*_m</varname>
+       </fieldsynopsis>
+      </term>
+      <listitem>
+       <para>data member</para>
+      </listitem>
+     </varlistentry>
+    </variablelist>
+ 
+    <variablelist>
+     <title>&pooma; Class Vocabulary</title>
+     <varlistentry>
+      <term>component</term>
+      <listitem>
+       <para>one of several values packaged together.  For example, a
+       three-dimensional vector has three components, i.e., three
+       values.</para>
+      </listitem>
+     </varlistentry>
+     <varlistentry>
+      <term>element-wise</term>
+      <listitem>
+       <para>applied to each element in the group, e.g., an array</para>
+      </listitem>
+     </varlistentry>
+     <varlistentry>
+      <term>reduction</term>
+      <listitem>
+       <para>repeated application of a binary operator to all elements,
+       yielding one value</para>
+      </listitem>
+     </varlistentry>
+     <varlistentry>
+      <term>tag</term>
+      <listitem>
+       <para>an enumerated value indicating inclusion in a particular
+       semantic class.  The set of values need not be explicitly
+       declared.</para>
+      </listitem>
+     </varlistentry>
+    </variablelist>
+ 
+   </chapter>
+ 
+ 
+   <chapter id="installing_configuring_ref">
+    <title>Installing and Configuring &pooma;</title>
+ 
+    <orderedlist>
+     <listitem>
+      <para>Installing &pooma;.</para>
+     </listitem>
+     <listitem>
+      <para>Requirements for configuration files.</para>
+     </listitem>
+    </orderedlist>
+ 
+    <para>Include descriptions of using &smarts;, &cheetah;, &tau;,
+    &pdt;.</para>
+ 
+    <para>QUESTION: Does it install on windows and on mac?  If so, what
+    are the instructions?  See also <filename
+    class="libraryfile">INSTALL.{mac,unix,windows}.</filename></para>
+ 
+    <para><filename class="libraryfile">README</filename> has some
+    information on &cheetah; and threads in the <quote>Message-Based
+    Parallelism</quote> section.</para>
+ 
+    <para>Which additional packages are necessary and when?</para>
+ 
+    <para>What configure options should we list?  See <filename
+    class="libraryfile">configure</filename>.  Be sure to list
+    debugging option and how its output relates to <filename
+    class="libraryfile">config/LINUXgcc.suite.mk</filename>.</para>
+ 
+    <para><filename class="directory">config/arch</filename> has files
+    for (OS, compiler) pairs.  Explain how to modify a configuration
+    file.  List requirements when making a new configuration file (low
+    priority).</para>
+ 
+    <para><filename
+    class="libraryfile">config/LINUXgcc.suite.mk</filename> has output
+    from <filename class="libraryfile">configure</filename>.  Useful to
+    relate to configuration files and <filename
+    class="libraryfile">configure</filename>'s debugging output.</para>
+    
+   </chapter>
+ 
+ 
+   <chapter id="compilation_ref">
+    <title>Compilation and &make; Files</title>
+ 
+    <para>We assume Gnu make.  Do we know what assumptions are made?</para>
+ 
+    <para>How do all these files interact with each other?  Ala a make
+    interpreter, give an example of which files are read and
+    when.</para>
+ 
+    <variablelist>
+     <varlistentry><term><filename
+     class="libraryfile">config/Shared/README.make</filename></term>
+     <listitem><para>This has short descriptions of many files,
+     especially in <filename
+     class="directory">config/Shared</filename>.</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">makefile</filename></term>
+     <listitem><para>These appear throughout all directories.  What are
+     the equivalences classes and what are their
+     parts?</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">include.mk</filename></term>
+     <listitem><para>What does this do?  Occurs in many directories:
+     when?  Template seems to be <filename
+     class="libraryfile">config/Shared/include2.mk</filename>.</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">subdir.mk</filename></term>
+     <listitem><para>list of subdirectories; occurs in several
+     directories: when?  <filename
+     class="libraryfile">src/subdir.mk</filename> is a good
+     example.</para></listitem>
+     </varlistentry>
+     <varlistentry>
+      <term><filename class="libraryfile">objfile.mk</filename></term>
+      <listitem>
+       <para>list of object files to construct, presumably from
+       <filename>*.cmpl.cpp</filename> files.
+       <filename>src/Utilities/objfile.mk</filename> is an
+       example.</para>
+      </listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">config/Shared/rules.mk</filename></term>
+     <listitem><para>most compiler rules</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">config/head.mk</filename></term>
+     <listitem><para>read at beginning of each
+     makefile?</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">config/Shared/tail.mk</filename></term>
+     <listitem><para>read at end of each makefile?</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">config/Shared/variables.mk</filename></term>
+     <listitem><para>Is this used?</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">config/Shared/compilerules.mk</filename></term>
+     <listitem><para>table of origin and target suffixes and commands
+     for conversion</para></listitem>
+     </varlistentry>
+ 
+    </variablelist>
+ 
+   </chapter>
+ 
+ 
+   <chapter id="arrays_ref">
+    <title>&array;s</title>
+ 
+    <para>Include <filename
+    class="headerfile">src/Pooma/Arrays.h</filename> to use &array;s.
+    The implementation source code is in <filename
+    class="directory">src/Array</filename>.</para>
+ 
+    <para>FINISH: Define an array.  Introduce its parts.</para>
+ 
+    <para>ADD: some mention of the maximum supported number of
+    dimensions somewhere.</para>
+ 
+    <section id="arrays_ref-array">
+     <title>The &array; Container</title>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0">
+      <title>Template Parameters</title>
+ 
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>Parameter</entry>
+ 	<entry>Interpretation</entry>
+        </row>
+       </thead>
+       <tbody valign="top">
+        <row>
+ 	<entry><varname>Dim</varname></entry>
+ 	<entry><para>dimension</para></entry>
+        </row>
+        <row>
+ 	<entry><type>T</type></entry>
+ 	<entry><para>array element type</para></entry>
+        </row>
+        <row>
+ 	<entry>EngineTag</entry>
+ 	<entry><para>type of computation engine object</para></entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <para>QUESTION: How do I introduce class type definitions, when
+     they are used, i.e., compile-time or run-time, and when
+     programmers should use them?</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0">
+      <title>Compile-Time Types and Values</title>
+ 
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>Type or Value</entry>
+ 	<entry>Interpretation</entry>
+        </row>
+       </thead>
+       <tbody valign="top">
+        <row>
+ 	<entry><fieldsynopsis><varname>This_t</varname></fieldsynopsis></entry>
+ 	<entry><para>the &array; object's type</para></entry>
+        </row>
+        <row>
+ 	<entry><fieldsynopsis><varname>Engine_t</varname></fieldsynopsis></entry>
+ 	<entry><para>the &array; object's engine's type</para></entry>
+        </row>
+        <row>
+ 	<entry><fieldsynopsis><varname>EngineTag_t</varname></fieldsynopsis></entry>
+ 	<entry><para>indication of engine's category</para></entry>
+        </row>
+        <row>
+ 	<entry><fieldsynopsis><varname>Element_t</varname></fieldsynopsis></entry>
+ 	<entry><para>the type of the array elements, i.e., <type>T</type></para></entry>
+        </row>
+        <row>
+ 	<entry><fieldsynopsis><varname>ElementRef_t</varname></fieldsynopsis></entry>
+ 	<entry><para>the type of a reference to an array element,
+ 	i.e., <type>T&</type>.  Equivalently, the type to write to a
+ 	single element.</para></entry>
+        </row>
+        <row>
+ 	<entry><fieldsynopsis><varname>Domain_t</varname></fieldsynopsis></entry>
+ 	<entry><para>the array's domain's type, i.e., the type of the
+ 	union of all array indices</para></entry>
+        </row>
+        <row>
+ 	<entry><fieldsynopsis><varname>Layout_t</varname></fieldsynopsis></entry>
+ 	<entry><para>unknown</para></entry>
+        </row>
+        <row>
+ 	<entry><fieldsynopsis><varname>dimensions</varname></fieldsynopsis></entry>
+ 	<entry><para>integer equalling the number of dimensions, i.e.,
+ 	<varname>Dim</varname></para></entry>
+        </row>
+        <row>
+ 	<entry><fieldsynopsis><varname>rank</varname></fieldsynopsis></entry>
+ 	<entry><para>integer equalling the number of dimensions, i.e.,
+ 	<varname>Dim</varname>; a synonym for <fieldsynopsis>
+ 	   <varname>dimensions</varname></fieldsynopsis></para></entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <section id="arrays_ref-array-constructors">
+      <title>Constructors and Destructors</title>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0">
+       <title>Constructors and Destructors</title>
+ 
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>Function</entry>
+ 	 <entry>Effect</entry>
+ 	</row>
+        </thead>
+        <tbody valign="top">
+ 	<row>
+ 	 <entry>
+           <constructorsynopsis>
+ 	   <literal>Array</literal>
+ 	   <void></void>
+ 	  </constructorsynopsis>
+          </entry>
+ 	 <entry><para>Creates an array that will be resized
+ 	 later.</para></entry>
+ 	</row>
+ 	<row>
+ 	 <entry>
+           <constructorsynopsis>
+ 	   <literal>Array</literal>
+ 	   <methodparam><modifier>const</modifier> <type>Engine_t&</type>
+ 	    <parameter>engine</parameter></methodparam>
+ 	  </constructorsynopsis>
+          </entry>
+ 	 <entry><para>Creates an array with an engine equivalent to
+          the <parameter>engine</parameter>.  This array will have the
+          same values as <parameter>engine</parameter>.  QUESTION: Why
+          would a user every want to use this
+          constructor?</para></entry>
+ 	</row>
+ 	<row>
+ 	 <entry>
+           <constructorsynopsis>
+ 	   <literal>Array</literal>
+ 	   <methodparam>
+ 	    <modifier>const</modifier>
+ 	    <type> Engine&lt;Dim2, T2, EngineTag2&gt;&</type>
+ 	    <parameter>engine</parameter>
+ 	   </methodparam>
+ 	   <methodparam>
+ 	    <modifier>const</modifier>
+ 	    <type>Initializer&</type> <parameter>init</parameter>
+ 	   </methodparam>
+ 	  </constructorsynopsis>
+          </entry>
+ 	 <entry><para>What does this do?</para></entry>
+ 	</row>
+ 	<row>
+ 	 <entry>ADD ALL CONSTRUCTORS AND DESTRUCTORS.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+     </section>
+ 
+ 
+     <section id="arrays_ref-array-initializers">
+      <title>Initializers</title>
+ 
+      <para>Add a table.</para>
+     </section>
+ 
+ 
+     <section id="arrays_ref-array-access">
+      <title>Element Access</title>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0">
+       <title>&array; Element Access</title>
+ 
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>Function</entry>
+ 	 <entry>Effect</entry>
+ 	</row>
+        </thead>
+        <tbody valign="top">
+ 	<row>
+ 	 <entry>
+           <methodsynopsis>
+ 	   <type>Element_t</type> <literal>read</literal>
+ 	   <void></void>
+ 	  </methodsynopsis>
+          </entry>
+ 	 <entry><para>unknown: See line 1839.</para></entry>
+ 	</row>
+ 	<row>
+ 	 <entry>
+           <methodsynopsis>
+ 	   <type>Element_t</type> <literal>read</literal>
+ 	   <methodparam>
+ 	    <modifier>const</modifier>
+ 	    <type>Sub1&</type> <parameter>s1</parameter>
+ 	   </methodparam>
+ 	   <methodparam>
+ 	    <modifier>const</modifier>
+ 	    <type> Sub2&</type> <parameter>s2</parameter>
+ 	   </methodparam>
+ 	  </methodsynopsis>
+          </entry>
+ 	 <entry><para>How does the version with template parameters,
+          e.g., <type>Sub1</type> differ from the <type>int</type>
+          version?</para></entry>
+ 	</row>
+ 	<row>
+ 	 <entry>
+           <methodsynopsis>
+ 	   <type>Element_t</type> <literal>operator()</literal>
+ 	   <methodparam>
+ 	    <modifier>const</modifier>
+ 	    <type>Sub1&</type> <parameter>s1</parameter>
+ 	   </methodparam>
+ 	   <methodparam>
+ 	    <modifier>const</modifier>
+ 	    <type>Sub2&</type> <parameter>s2</parameter>
+ 	   </methodparam>
+ 	  </methodsynopsis>
+          </entry>
+ 	 <entry><para>How does this differ from <literal>read(const
+           Sub1& s1, const Sub2& s2)</literal>?  </para></entry>
+ 	</row>
+ 	<row>
+ 	 <entry>ADD ALL <function>read</function>s and
+ 	 <function>operator()</function>s.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+     </section>
+ 
+ 
+     <section id="arrays_ref-array-component">
+      <title>Component Access</title>
+ 
+      <para>When an array stores elements having components, e.g., an
+      array of vectors, tensors, or arrays, the
+      <literal>comp</literal> returns an array consisting of the
+      specified components.  The original and component array share the
+      same engine so changing the values in one affects values in the
+      other.</para>
+ 
+      <para>For example, if &n; &times; &n; array <varname>a</varname>
+      consists of three-dimensional real-valued vectors,
+      <literal>a.comp(1)</literal> returns a &n; &times; &n;
+      real-valued array of all the middle vector components.  Assigning
+      to the component array will also modify the middle components of
+      the vectors in <varname>a</varname>.</para>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0">
+       <title>&array; Component Access</title>
+ 
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>Function</entry>
+ 	 <entry>Effect</entry>
+ 	</row>
+        </thead>
+        <tbody valign="top">
+ 	<row>
+ 	 <entry>
+           <methodsynopsis>
+ 	   <type>UNKNOWN compute this</type> <literal>comp</literal>
+ 	   <methodparam>
+ 	    <modifier>const</modifier>
+ 	    <type>int&</type>
+ 	    <parameter>i1</parameter>
+ 	   </methodparam>
+ 	  </methodsynopsis>
+          </entry>
+ 	 <entry><para>unknown: See line 1989.</para></entry>
+ 	</row>
+ 	<row>
+ 	 <entry>ADD ALL <literal>comp</literal>s.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+     </section>
+ 
+     <section id="arrays_ref-array-accessors">
+      <title>Accessors</title>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0">
+       <title>&array; Accessor Methods</title>
+ 
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>Function</entry>
+ 	 <entry>Effect</entry>
+ 	</row>
+        </thead>
+        <tbody valign="top">
+ 	<row>
+ 	 <entry>
+           <methodsynopsis>
+ 	   <type>int</type> <literal>first</literal>
+ 	   <methodparam>
+ 	    <type>int</type>
+ 	    <parameter>d</parameter>
+ 	   </methodparam>
+ 	  </methodsynopsis>
+          </entry>
+ 	 <entry><para>unknown: See line 2050</para></entry>
+ 	</row>
+ 	<row>
+ 	 <entry>ADD ALL other accessor methods, including
+ 	 <literal>engine</literal>.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+     </section>
+ 
+ 
+     <section id="arrays_ref-array-copying">
+      <title>Copying &array;s</title>
+ 
+      <para>Explain how copied arrays and views of arrays share the
+      same underlying engine so changing values in one also affects the
+      other.  This is called a shallow copy.</para>
+     </section>
+ 
+ 
+     <section id="arrays_ref-array-utilities">
+      <title>Utility Methods</title>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0">
+       <title>&array; Utility Methods</title>
+ 
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>Function</entry>
+ 	 <entry>Effect</entry>
+ 	</row>
+        </thead>
+        <tbody valign="top">
+ 	<row>
+ 	 <entry>
+           <methodsynopsis>
+ 	   <type>void</type> <literal>makeOwnCopy</literal>
+ 	   <void></void>
+ 	  </methodsynopsis>
+          </entry>
+ 	 <entry><para>unknown: See line 2044</para></entry>
+ 	</row>
+ 	<row>
+ 	 <entry>ADD ALL other utility methods.</entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+     </section>
+ 
+     
+     <section id="arrays_ref-array-implementation">
+      <title>Implementation Details</title>
+ 
+      <para>As a container, an &array;'s implementation is quite
+      simple.  Its <literal>private</literal>data consists of
+      an engine, and it has no <literal>private</literal>
+      functions.</para>
+ 
+      <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	    orient="port" pgwide="0">
+       <title>&array; Implementation Data</title>
+ 
+       <tgroup cols="2" align="left">
+        <thead>
+ 	<row>
+ 	 <entry>Data Member</entry>
+ 	 <entry>Meaning</entry>
+ 	</row>
+        </thead>
+        <tbody valign="top">
+ 	<row>
+ 	 <entry>
+           <fieldsynopsis>
+ 	   <modifier>private</modifier>
+ 	   <type>Engine_t</type> <varname>engine_m</varname>
+ 	  </fieldsynopsis>
+          </entry>
+ 	 <entry><para>engine computing the array's values</para></entry>
+ 	</row>
+        </tbody>
+       </tgroup>
+      </table>
+ 
+     </section>
+    </section>
+ 
+ 
+    <section id="arrays_ref-dynamicarray">
+     <title>&dynamicarray;s: Dynamically-Sized Domains</title>
+ 
+     <para>A DynamicArray is a read-write array with extra
+     create/destroy methods.  It can act just like a regular Array, but
+     can have a dynamically-changing domain.  See <filename
+ 							   class="headerfile">src/DynamicArray/DynamicArray.h</filename>.</para>
+ 
+     <para>ADD: Briefly describe what the class does and an example of
+     where it is used.</para>
+ 
+     <para>ADD: Check that its interface is actually the same as for
+     &array;.</para>
+ 
+     <para>ADD: Check that the operations on dynamic arrays are
+     actually the same as for &array;.  See <filename
+ 						     class="headerfile">src/DynamicArray/DynamicArrayOperators.h</filename>,
+     <filename
+ 	      class="headerfile">src/DynamicArray/PoomaDynamicArrayOperators.h</filename>,
+     and <filename
+ 		  class="headerfile">src/DynamicArray/VectorDynamicArrayOperators.h</filename>.</para>
+ 
+     
+     <section id="arrays_ref-dynamicarray-implementation">
+      <title>Implementation Details</title>
+ 
+      <para><type>DynamicArray</type> has no
+      <literal>protected</literal> or
+      <literal>private</literal> members.</para>
+     </section>
+    </section>
+ 
+ 
+    <section id="arrays_ref-views">
+     <title>Views of &array;s</title>
+ 
+     <para>UNFINISHED</para>
+    </section>
+ 
+ 
+    <section id="arrays_ref-assignment">
+     <title>&array; Assignments</title>
+ 
+     <para>&pooma; supports assignments to &array;s of other &array;s
+     and scalar values.  QUESTION: Is the following correct?  For the
+     former, the right-hand side array's domain must be at least as
+     large as the left-hand side array's domain.  Corresponding values
+     are copied.  Assigning a scalar value to an array ensures all the
+     array elements have the same scalar value.</para>
+ 
+     <para>UNFINISHED: Add a table containing assignment operators
+     found one lines 2097&ndash;2202.</para>
+    </section>
+ 
+ 
+    <section id="arrays_ref-print">
+     <title>Printing &array;s</title>
+ 
+     <para>&array;s support output to but not input from IO streams.
+     In particular, output to <type>ostream</type>s and file streams is
+     supported.</para>
+ 
+     <para>Add a table, using <filename
+     class="headerfile">src/Array/Array.h</filename>, lines
+     2408&ndash;2421.  See the implementation in <filename
+     class="headerfile">src/Array/PrintArray.h</filename>.</para>
+ 
+     <para>QUESTION: How does one print a &dynamicarray;.</para>
+    </section>
+ 
+ 
+    <section>
+     <title>Expressions Involving &array;s</title>
+ 
+     <para>In &pooma;, expressions may contain entire &array;s.  That
+     is, &array;s are first-class objects with respect to expressions.
+     For example, given &array;s <varname>a</varname> and
+     <varname>b</varname>, the expression <literal>a + b</literal>
+     is equivalent to an array containing the element-wise sum of the
+     two arrays.</para>
+ 
+     <para>Any finite number of the operators listed below can be used
+     in an expression.  The precedence and order of operation is the
+     same as with ordinary built-in types.</para>
+ 
+     <para>QUESTION: Do &field;s also support the same set of
+     operations?</para>
+ 
+     <para>QUESTION: Some operations in <filename
+ 						 class="headerfile">src/Field/FieldOperators.h</filename> use both
+     &array; and &field;.  Do we list them here or in the &field;
+     section or both or somewhere else?</para>
+ 
+     <para>In the table below, &array; supplants the exact return types
+     because they are complicated and rarely need to be explicitly
+     written down.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0">
+      <title>Operators on &array;</title>
+ 
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>Operator</entry>
+ 	<entry>Value</entry>
+        </row>
+       </thead>
+       <tbody valign="top">
+        <row>
+ 	<entry>
+           <funcsynopsis>
+ 	  <funcprototype>
+ 	   <funcdef>Array <function>acos</function></funcdef>
+ 	   <paramdef>const <parameter>Array&lt;Dim,T,EngineTag&gt;& a</parameter></paramdef>
+ 	  </funcprototype>
+ 	 </funcsynopsis>
+          </entry>
+ 	<entry><para>an array containing the element-wise inverse
+          cosine of the array <parameter>a</parameter></para></entry>
+        </row>
+        <row>
+ 	<entry>ADD ALL other operators appearing in <filename
+ 							      class="headerfile">src/Array/ArrayOperators.h</filename>,
+         <filename
+ 		  class="headerfile">src/Array/ArrayOperatorSpecializations.h</filename>,
+         <filename
+ 		  class="headerfile">src/Array/PoomaArrayOperators.h</filename>,
+         and <filename
+ 		      class="headerfile">src/Array/VectorArrayOperators.h</filename>.</entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+     <para>FINISH: Write one or two examples or refer to ones
+     previously in the text.</para>
+    </section>
+ 
+ 
+    <section id="arrays_ref-reductions">
+     <title>Reducing All &array; Elements to One Value</title>
+ 
+     <para>These reduction functions repeatedly apply a binary
+     operation to all array elements to yield a value.  These functions
+     are similar to the Standard Template Library's
+     <function>accumulate</function> function.  For example,
+     <function>sum</function> repeatedly applies the binary plus
+     operator to all array elements, yielding the sum of all array
+     elements.</para>
+ 
+     <para>FINISH: What order of operation, if any, is
+     guaranteed?</para>
+ 
+     <para>FINISH: Add a table of the functions in <filename
+ 							    class="headerfile">src/Array/Reductions.h</filename>.</para>
+ 
+     <para>How does one use one's own binary function?  See <filename
+     class="headerfile">src/Engine/Reduction.h</filename>.</para>
+    </section>
+ 
+ 
+    <section id="arrays_ref-utilities">
+     <title>Utility Functions</title>
+ 
+     <section id="arrays_ref-utilities-compression">
+      <title>Compressed Data</title>
+ 
+      <para>Add a table containing
+      <function>elementsCompressed</function>,
+      <function>compressed</function>, <function>compress</function>,
+      and <function>uncompress</function>.</para>
+     </section>
+ 
+ 
+     <section id="arrays_ref-utilities-sizes">
+      <title>Centering Sizes and Number of Materials</title>
+ 
+      <para>ADD: a description of <function>numMaterials</function> and
+      <function>centeringSize</function> found in <filename
+      class="headerfile">src/Field/Field.h</filename>.  These functions
+      are meaningless for &array; but are provided for consistency with
+      &field;.</para>
+     </section>
+ 
+     <section id="arrays_ref-utilities-subfield">
+      <title>Obtaining Subfields</title>
+ 
+      <para>ADD: a description of <function>subField</function> found
+      in <filename class="headerfile">src/Field/Field.h</filename>.
+      This function, meaningless for &array;, is provided for
+      consistency with &field;.</para>
+     </section>
+    </section>
+ 
+ 
+    <section id="arrays_ref-tmp">
+     <title>TMP: What do we do with these &hellip;? Remove this
+     section.</title>
+ 
+     <blockquote>
+      <attribution><filename
+       class="libraryfile">introduction.html</filename></attribution>
+ 
+      <para>&pooma; was designed and implemented by scientists working
+      at the Los Alamos National Laboratory's Advanced Computing
+      Laboratory. Between them, these scientists have written and tuned
+      large applications on almost every commercial and experimental
+      supercomputer built in the last two decades. As the technology
+      used in those machines migrates down into departmental computing
+      servers and desktop multiprocessors, &pooma; is a vehicle for its
+      designers' experience to migrate as well. In particular,
+      &pooma;'s authors understand how to get good performance out of
+      modern architectures, with their many processors and multi-level
+      memory hierarchies, and how to handle the subtly complex problems
+      that arise in real-world applications.</para>
+     </blockquote>
+ 
+     <para>QUESTION: Do we describe the &leaffunctor;s specialized for
+     &array;s in <filename
+     class="headerfile">src/Array/Array.h</filename> or in the &pete;
+     reference section?  What about the functions in <filename
+     class="headerfile">src/Array/CreateLeaf.h</filename>?</para>
+ 
+     <para>QUESTION: What is an <type>EngineFunctor</type>?  We
+     probably should describe it in an analogous way as for
+     &leaffunctor;s.</para>
+ 
+     <para>QUESTION: Where do we write about
+     <type>ExpressionTraits</type> for &array;s?</para>
+ 
+     <para>QUESTION: Do we describe the <type>ElementProperties</type>
+     specialization at this place or in its section?</para>
+ 
+     <para>QUESTION: Do we describe the <type>Patch</type>
+     specialization for &array;s (<filename
+     class="headerfile">src/Array/Array.h</filename>:1300) in this
+     place or in a section for patches?</para>
+    </section>
+   </chapter>
+ 
+ 
+   <chapter id="fields_ref">
+    <title>&field;s</title>
+ 
+    <para>An &array; is a set of values indexed by
+    coordinates, one value per coordinate.  It models the computer
+    science idea of an array.  Similarly, a &field; is a set of values
+    indexed by coordinate.  It models the mathematical and physical
+    idea of a field represented by a grid of rectangular cells, each
+    having at least one value.  A &field;'s functionality is a superset
+    of an &array;'s functionality because:
+     <itemizedlist>
+      <listitem>
+       <para>A &field; is distributed through space so one can compute
+       the distances between cells.</para>
+      </listitem>
+      <listitem>
+       <para>Each cell can hold multiple values.  For example, a
+       rectangular cell can have one value on each of its faces.</para>
+      </listitem>
+      <listitem>
+       <para>Multiple materials can share the same cell.  For example,
+       different values can be stored in the same cell for carbon,
+       oxygen, and nitrogen.</para>
+      </listitem>
+     </itemizedlist>
+    Also, &field;s' values can be related by relations.  Thus, if one
+    field's values change, a dependent field's values can be
+    automatically computed when needed.  FIXME: See also the unfinished
+    works chapter's entry concerning relations and arrays.</para>
+ 
+    <para>QUESTION: Should we add a picture comparing and contrasting
+    an array and a field?</para>
+ 
+    <para>QUESTION: How much structure can be copied from the &array;
+    chapter?</para>
+ 
+    <para>QUESTION: Where is <type>NewMeshTag</type>, defined in
+    <filename class="headerfile">src/Field/Field.h</filename>,
+    used?</para>
+ 
+    <para>QUESTION: Do we describe the &leaffunctor;s specialized for
+    &field;s in <filename
+    class="headerfile">src/Field/Field.h</filename> or in the &pete;
+    reference section?  Use the same decision for &array;s.</para>
+ 
+    <para>QUESTION: What do the structure and functions in <filename
+    class="headerfile">src/Field/Mesh/PositionFunctions.h</filename>
+    do?</para>
+ 
+ 
+    <section id="fields_ref-field">
+     <title>The &field; Container</title>
+ 
+     <para>ADD: table of template parameters and table of compile-time
+     types and values.</para>
+ 
+ 
+     <section id="fields_ref-field-constructors">
+      <title>Constructors and Destructors</title>
+ 
+      <para>ADD: this section similar to &array;s's constructor and
+      destructor section.</para>
+     </section>
+ 
+     <section id="fields_ref-field-initializers">
+      <title>Initializers</title>
+ 
+      <para>Add a table.</para>
+     </section>
+ 
+ 
+     <section id="fields_ref-field-access">
+      <title>Element Access</title>
+ 
+      <para>ADD: a table ala &array;.  Be sure to include
+      <literal>all</literal>.</para>
+     </section>
+ 
+ 
+     <section id="fields_ref-field-component">
+      <title>Component Access</title>
+ 
+      <para>ADD: a table ala &array;.</para>
+     </section>
+ 
+ 
+     <section id="fields_ref-field-subfields">
+      <title>Obtaining Subfields</title>
+ 
+      <para>ADD: discussion and a table listing ways to obtain
+       subfields.  Although the implementation may treat subfield views
+       and other field views similarly (?Is this true?), they are
+       conceptually different ideas so we present them
+       separately.</para>
+ 
+      <para>See <filename
+ 			 class="headerfile">src/Field/Field.h</filename>'s
+       <literal>operator[]</literal>,
+       <literal>subField</literal>, &hellip;,
+       <literal>material</literal>.</para>
+     </section>
+ 
+ 
+     <section id="fields_ref-field-relations">
+      <title>Supporting Relations</title>
+ 
+      <para>ADD: a table with the member functions including
+      <literal>addRelation</literal>,
+      <literal>removeRelations</literal>,
+      <literal>applyRelations</literal>, and
+      <literal>setDirty</literal>.</para>
+     </section>
+ 
+ 
+     <section id="fields_ref-field-accessors">
+      <title>Accessors</title>
+ 
+      <para>ADD: a table using lines like <filename
+      class="headerfile">src/Field/Field.h</filename>:1243&ndash;1333.</para>
+     </section>
+ 
+ 
+     <section id="fields_ref-field-utilities">
+      <title>Utility Methods</title>
+ 
+      <para>ADD: a table including
+       <literal>makeOwnCopy</literal>.</para>
+     </section>
+ 
+ 
+     <section id="fields_ref-field-implementation">
+      <title>Implementation Details</title>
+ 
+      <para>ADD: a table similar to &array;'s.</para>
+ 
+     </section>
+ 
+    </section>
+ 
+ 
+    <section id="engines_ref-views">
+     <title>Views of &field;s</title>
+ 
+     <para>Be sure to relate to &array; views.  Note only three
+     dimensions are supported.</para>
+ 
+     <para>Be sure to describe <literal>f[i]</literal>.  Does this
+     refer to a particular material or a particular value within a
+     cell?  I do not remember.  See <type>SubFieldView</type> in
+     <filename class="headerfile">src/Field/Field.h</filename>.</para>
+    </section>
+ 
+ 
+    <section id="fields_ref-assignment">
+     <title>&field; Assignments</title>
+ 
+     <para>ADD: Describe supported assignments, relating to &array;'s
+     assignments.</para>
+ 
+     <para>UNFINISHED: Add a table containing assignment operators
+     found on <filename
+ 		       class="headerfile">src/Field/Field.h</filename>:2097&ndash;2202
+     and 1512&ndash;1611.</para>
+    </section>
+ 
+ 
+    <section id="fields_ref-print">
+     <title>Printing &field;s</title>
+ 
+     <para>QUESTION: How similar is this to printing &array;s?</para>
+ 
+     <para>&field;s support output to but not input from IO streams.
+     In particular, output to <type>ostream</type>s and file streams is
+     supported.</para>
+ 
+     <para>Add a table, using <filename
+ 				       class="headerfile">src/Field/Field.h</filename>, lines
+     1996&ndash;2009.  See the implementation in <filename
+ 							  class="headerfile">src/Field/PrintField.h</filename>.</para>
+    </section>
+ 
+ 
+    <section id="fields_ref-reductions">
+     <title>Combining &field; Elements</title>
+ 
+     <para>Like &array;s, &field;s support reduction of all elements to
+     one value.  Additionally, the latter supports computing a field's
+     values using field stencils.  QUESTION: How do I describe this
+     with a minimum of jargon?</para>
+ 
+     <para>ADD: something similar to &array; reductions.</para>
+ 
+     <para>FINISH: Add a table of the functions in <filename
+     class="headerfile">src/Field/FieldReductions.h</filename>.</para>
+ 
+     <para>FINISH: Add a table of the functions in <filename
+     class="headerfile">src/Field/DiffOps/FieldOffsetReductions.h</filename>.
+     QUESTION: Why is only <function>sum</function> defined?</para>
+    </section>
+ 
+ 
+    <section id="fields_ref-expressions">
+     <title>Expressions Involving &field;s</title>
+ 
+     <para>Do something similar to &array;'s section.  See the
+     operations defined in <filename
+     class="headerfile">src/Field/FieldOperators.h</filename>,
+     <filename
+     class="headerfile">src/Field/FieldOperatorSpecializations.h</filename>,
+     <filename
+     class="headerfile">src/Field/PoomaFieldOperators.h</filename>, and
+     <filename
+     class="headerfile">src/Field/VectorFieldOperators.h</filename>.</para>
+ 
+     <para>Some operations involve both &array; and &field;
+     parameters.  Where do we list them?</para>
+    </section>
+ 
+ 
+    <section id="fields_ref-stencils">
+     <title>&field; Stencils: Faster, Local Computations</title>
+ 
+     <para>ADD: a description of a stencil.  Why is it needed?  How
+     does a user use it?  How does a user know when to use one?  Add
+     documentation of the material from <filename
+     class="headerfile">src/Field/DiffOps/FieldStencil.h</filename>.</para>
+ 
+     <para>How is <type>FieldShiftEngine</type> used by &field;
+     stencils?  Should it be described here or in the &engine; section?
+     See the the code in <filename
+     class="headerfile">src/Field/DiffOps/FieldShiftEngine.h</filename>.</para>
+    </section>
+ 
+ 
+    <section>
+     <title>Cell Volumes, Face Areas, Edge Lengths, Normals</title>
+ 
+     <para>ADD: a description of these functions.  See <filename
+     class="headerfile">src/Field/Mesh/MeshFunctions.h</filename>.
+     These are initialized in, e.g., <filename
+     class="headerfile">src/Field/Mesh/UniformRectilinearMesh.h</filename>.
+     Note that these do not work for <type>NoMesh</type>.</para>
+    </section>
+ 
+ 
+    <section id="fields_ref-div">
+     <title>Divergence Operators</title>
+ 
+     <para>ADD: a table having divergence operators, explaining the
+     current restrictions imposed by what is implemented.  See
+     <filename class="headerfile">src/Field/DiffOps/Div.h</filename>
+     and <filename
+     class="headerfile">src/Field/DiffOps/Div.UR.h</filename>.  What
+     restrictions does <quote>UR</quote> (mesh) connote?</para>
+    </section>
+ 
+ 
+    <section id="fields_ref-utilities">
+     <title>Utility Functions</title>
+ 
+     <section id="fields_ref-utilities-compression">
+      <title>Compressed Data</title>
+ 
+      <para>Add a table containing
+      <function>elementsCompressed</function>,
+      <function>compressed</function>, <function>compress</function>,
+      and <function>uncompress</function>.</para>
+     </section>
+ 
+ 
+     <section id="fields_ref-utilities-sizes">
+      <title>Centering Sizes and Number of Materials</title>
+ 
+      <para>ADD: a description of <function>numMaterials</function> and
+      <function>centeringSize</function> found in <filename
+      class="headerfile">src/Field/Field.h</filename>.</para>
+ 
+      <para>QUESTION: How do these relate to any method functions?</para>
+     </section>
+ 
+ 
+     <section id="fields_ref-utilities-subfield">
+      <title>Obtaining Subfields</title>
+ 
+      <para>ADD: a description of <function>subField</function> found
+      in <filename
+      class="headerfile">src/Field/Field.h</filename>.</para>
+     </section>
+ 
+    </section>
+ 
+ 
+    <section id="fields_ref-centerings">
+     <title>&field; Centerings</title>
+ 
+     <para>DO: Describe the purpose of a centering and its definition.
+     Describe the ability to obtain canonical centerings.  Explain how
+     to construct a unique centering.  See <filename
+     class="headerfile">src/Field/FieldDentering.h</filename>.</para>
+    </section>
+ 
+ 
+    <section id="fields_ref-fieldoffsets">
+     <title>Relative &field; Positions</title>
+ 
+     <para>Permit specifying field positions relative to a field
+     location.  Describe <type>FieldOffset</type> and
+     <type>FieldOffsetList</type>.  See <filename
+     class="headerfile">src/Field/FieldOffset.h</filename></para>
+    </section>
+ 
+ 
+    <section id="fields_ref-nearestneighbors">
+     <title>Computing Close-by Field Positions</title>
+ 
+     <para>Given a field location, return the set of field locations
+     that are closest using ?Manhattan? distance.  See <filename
+     class="headerfile">src/Field/NearestNeighbors.h</filename>.</para>
+    </section>
+ 
+ 
+    <section id="fields_ref-mesh">
+     <title>Mesh ???</title>
+ 
+     <para>Unlike &array;s, &field;s are distributed throughout space
+     so distances between values within the &field can be computed.  A
+     &field;'s mesh stores this spatial distribution.</para>
+ 
+     <para>QUESTION: What do we need to write about meshes?  What is
+     unimportant implementation and what should be described in this
+     reference section?</para>
+ 
+     <para>QUESTION: Where in here should emphasize vertex, not cell,
+     positions?  <quote>VERTEX</quote> appears repeatedly in <filename
+     class="headerfile">src/Field/Mesh/NoMesh.h</filename>.</para>
+ 
+     <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	   orient="port" pgwide="0">
+      <title>Mesh Types</title>
+ 
+      <tgroup cols="2" align="left">
+       <thead>
+        <row>
+ 	<entry>Mesh Type</entry>
+ 	<entry>Description</entry>
+        </row>
+       </thead>
+       <tbody valign="top">
+        <row>
+ 	<entry><type>NoMesh&lt;Dim&gt;</type></entry>
+ 	<entry><para>no physical spacing, causing a &field; to mimic
+ 	an &array; with multiple engines.</para></entry>
+        </row>
+        <row>
+ 	<entry><type>UniformRectilinearMesh&lt;Dim,T&gt;</type></entry>
+ 	<entry><para>physical spacing formed by the Cartesian product
+ 	of ????.</para></entry>
+        </row>
+       </tbody>
+      </tgroup>
+     </table>
+ 
+ 
+     <section id="fields_ref-mesh-accessors">
+      <title>Mesh Accessors</title>
+ 
+      <para>ADD: a table listing accessors, explaining the difference
+      between (physical and total) and (cell and vertex) domains.  See
+      <filename class="headerfile">src/Field/Mesh/NoMesh.h</filename>.
+      Also, include <function>spacings</function> and
+      <function>origin</function> in <filename
+      class="headerfile">src/Field/Mesh/UniformRectilinearMesh.h</filename>.
+      Note <type>NoMesh</type> does not provide the latter two.</para>
+     </section>
+ 
+    </section>
+ 
+ 
+    <section id="fields_ref-tmp">
+     <title>TMP: What do we do with these &hellip;? Remove this
+     section.</title>
+ 
+     <para>QUESTION: Do we describe the <type>Patch</type>
+     specialization for &field; at this place or in some common place?
+     Follow &array;'s lead.</para>
+ 
+     <para>QUESTION: Where do we describe <type>CreateLeaf</type> and
+     <type>MakeFieldReturn</type> in <filename
+     class="headerfile">src/Field/FieldCreateLeaf.h</filename> and
+     <filename
+     class="headerfile">src/Field/FieldMakeReturn.h</filename>.</para>
+ 
+     <para>QUESTION: What do we do with <type>FieldEnginePatch</type>
+     in <filename
+     class="headerfile">src/Field/FieldEngine/FieldEnginePatch.h</filename>.</para>
+    </section>
+   </chapter>
+ 
+ 
+   <chapter id="engines_ref">
+    <title>&engine;s</title>
+ 
+    <para>From a user's point of view, a container makes data available
+    for reading and writing.  In fact, the container's &engine; stores
+    the data or, if the data is computed, performs a computation to
+    yield the data.</para>
+ 
+    <para>FINISH: Introduce the various types of engines.  Add a table
+    with a short description of each engine type.</para>
+ 
+    <para>FINISH: First, we specify a generic &engine;'s interface.
+    Then, we present &engine; specializations.</para>
+    
+    <table frame="none" colsep="0" rowsep="0" tocentry="1"
+ 	  orient="port" pgwide="0">
+     <title>Types of &engine;s</title>
+ 
+     <tgroup cols="3" align="left">
+      <thead>
+       <row>
+        <entry>Engine Type</entry>
+        <entry>Engine Tag</entry>
+        <entry>Description</entry>
+       </row>
+      </thead>
+      <tbody valign="top">
+       <row>
+        <entry><para>Brick</para></entry>
+        <entry><para><literal>Brick</literal></para></entry>
+        <entry><para>Explicitly store all elements in, e.g., a &cc;
+ 	array.</para></entry>
+       </row>
+       <row>
+        <entry><para>Compressible</para></entry>
+        <entry><para><literal>CompressibleBrick</literal></para></entry>
+        <entry><para>If all values are the same, use constant storage
+ 	for that single value.  Otherwise, explicitly store all
+ 	elements.</para></entry>
+       </row>
+       <row>
+        <entry><para>Constant</para></entry>
+        <entry><para><literal>ConstantFunction</literal></para></entry>
+        <entry><para>Returns the same constant value for all
+        indices.</para></entry>
+       </row>
+       <row>
+        <entry><para>Dynamic</para></entry>
+        <entry><para><literal>Dynamic</literal></para></entry>
+        <entry><para>Manages a contiguous, local, one-dimensional,
+        dynamically resizable block of data.</para></entry>
+       </row>
+       <row>
+        <entry><para>Component Forwarding</para></entry>
+        <entry><para><literal>CompFwd&lt;EngineTag,
+        Components&gt;</literal></para></entry>
+        <entry><para>Returns the specified components from
+        <literal>EngineTag</literal>'s engine.  Components are
+        <quote>pieces</quote> of multi-value elements such as vectors
+        and tensors.</para></entry>
+       </row>
+       <row>
+        <entry><para>Expression</para></entry>
+        <entry><para><literal>ExpressionTag&lt;Expr&gt;</literal></para></entry>
+        <entry><para>Returns the value of the specified &pete;
+        expression.</para></entry>
+       </row>
+       <row>
+        <entry><para>Index Function</para></entry>
+        <entry><para><literal>IndexFunction&lt;Functor&gt;</literal></para></entry>
+        <entry><para>Makes the function
+        <literal>Functor</literal>accepting indices mimic an
+        array.</para></entry>
+       </row>
+       <row>
+        <entry><para>MultiPatch</para></entry>
+        <entry><para><literal>MultiPatch&lt;LayoutTag,PatchTag&gt;</literal></para></entry>
+        <entry><para>Support distributed computation using several
+        processors (???contexts???).  <literal>LayoutTag</literal>
+        indicates how the entire array is distributed among the
+        processors.  Each processor uses a <literal>PatchTag</literal>
+        engine.</para></entry>
+       </row>
+       <row>
+        <entry><para>Remote</para></entry>
+        <entry><para><literal>Remote&lt;EngineTag&gt;</literal></para></entry>
+        <entry><para>unknown</para></entry>
+       </row>
+       <row>
+        <entry><para>Remote Dynamic</para></entry>
+        <entry><para><literal>Remote&lt;Dynamic&gt;</literal></para></entry>
+        <entry><para>unknown: specialization</para></entry>
+       </row>
+       <row>
+        <entry><para>Stencil</para></entry>
+        <entry><para><literal>StencilEngine&lt;Function,
+        Expression&gt;</literal></para></entry>
+        <entry><para>Returns values computed by applying the
+        user-specified function to sets of contiguous values in the
+        given engine or container.  Compare with user function
+        engines.</para></entry>
+       </row>
+       <row>
+        <entry><para>User Function</para></entry>
+        <entry><para><literal>UserFunctionEngine&lt;UserFunction,Expression&gt;</literal></para></entry>
+        <entry><para> Returns values computed by applying the
+        user-specified function to the given engine or container.
+        QUESTION: Is the following claim correct? For each returned
+        value, only one value from the engine or container is
+        used.</para></entry>
+       </row>
+      </tbody>
+     </tgroup>
+    </table>
+ 
+    <para>QUESTION: Where do we describe views?</para>
+ 
+    <para>QUESTION: What does <type>NewEngine</type> do?  Should it be
+     described when describing views?  Should it be omitted as an
+     implementation detail?</para>
+ 
+    <para>QUESTION: Where do we describe &engine; patches found in
+    <filename class="headerfile">src/Engine/EnginePatch.h</filename>?
+    All patch data in a separate chapter or engine-specific pieces in
+    this chapter?</para>
+ 
+    <para>QUESTION: What is <function>notifyEngineWrite</function>?
+    See also <filename
+ 		      class="headerfile">src/Engine/NotifyEngineWrite.h</filename>.</para>
+ 
+    <para>QUESTION: What aspect of MultiPatch uses <type>IsValid</type> in
+    <filename
+ 	     class="headerfile">src/Engine/IsValidLocation.h</filename>?</para>
+ 
+    <para>QUESTION: Who uses intersections?  Where should this be
+    described?  See <filename
+ 			     class="headerfile">src/Engine/Intersector.h</filename>, <filename
+ 											       class="headerfile">src/Engine/IntersectEngine.h</filename>, and
+    <filename
+ 	     class="headerfile">src/Engine/ViewEngine.h</filename>.</para>
+ 
+    <section id="engines_ref-compile_time_interface">
+     <title>&engine; Compile-Time Interface</title>
+ 
+     <para>ADD: a table of template parameters ala &array;.  ADD:
+     compile-time types and values.</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-constructors">
+     <title>Constructors and Destructors</title>
+ 
+     <para>ADD: a table of constructors and destructors ala
+     &array;'s.</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-access">
+     <title>Element Access</title>
+ 
+     <para>ADD: a table with <literal>read</literal> and
+     <literal>operator()</literal>.</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-accessors">
+     <title>Accessors</title>
+ 
+     <para>ADD: a table of accessors.</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-assignments">
+     <title>&engine; Assignments</title>
+ 
+     <para>similar to &array;'s assignments.  shallow copies.  ADD: a
+     table with one entry</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-utilities">
+     <title>Utility Methods</title>
+ 
+     <para>ADD: a table including
+     <literal>makeOwnCopy</literal>.</para>
+ 
+     <para>QUESTION: What are <literal>dataObject</literal>,
+     <literal>isShared</literal>, and related methods?</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-implementation">
+     <title>Implementation Details</title>
+ 
+     <para>ADD: this section.  Explain that
+     <varname>dataBlock_m</varname> and <varname>data_m</varname> point
+     to the same place.  The latter speeds access, but what is the
+     purpose of the former?</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-brick">
+     <title>Brick and BrickView Engines</title>
+ 
+     <para>ADD: description of what a brick means.  ADD: whatever
+     specializations the class has, e.g.,
+     <literal>offset</literal>.</para>
+ 
+     <para>QUESTION: What does <type>DoubleSliceHelper</type> do?</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-compressible">
+     <title>Compressible Brick and BrickView Engines</title>
+ 
+     <para>ADD this.</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-dynamic">
+     <title>Dynamic and DynamicView Engines:</title>
+ 
+     <para>ADD this.  Manages a contiguous, local, resizable, 1D block
+     of data.</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-components">
+     <title>Component Engines</title>
+ 
+     <para>I believe these implement array component-forwarding.  See
+     <filename
+ 	      class="headerfile">src/Engine/ForwardingEngine.h</filename>.</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-expressions">
+     <title>Expression Engines</title>
+ 
+     <para>Should this be described in the &pete; section?  Unlikely.
+     See <filename
+ 		  class="headerfile">src/Engine/ExpressionEngine.h</filename>.</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-enginefunctor">
+     <title>&engine; Functors</title>
+ 
+     <para>QUESTION: What is an <type>EngineFunctor</type>?  Should it
+     have its own section?  See <filename
+ 					 class="headerfile">src/Engine/EngineFunctor.h</filename>.</para>
+    </section>
+ 
+ 
+    <section id="engines_ref-fieldengines">
+     <title><type>FieldEngine</type>: A Hierarchy of &engine;s</title>
+ 
+     <para>A &field; consists of a hierarchy of materials and
+     centerings.  These are implemented using a hierarchy of engines.
+     See <filename
+ 		  class="headerfile">src/Field/FieldEngine/FieldEngine.h</filename>
+     and <filename
+ 		  class="headerfile">src/Field/FieldEngine/FieldEngine.ExprEngine.h</filename>.</para>
+    </section>
+   </chapter>
+ 
+ 
+   <chapter id="benchmarks_ref">
+    <title>&benchmark; Programs</title>
+ 
+    <para>Explain how to use &benchmark; programs, especially the
+    options.  Explain how to write a &benchmark; program.  See also
+    <filename class="headerfile">src/Utilities/Benchmark.h</filename>
+    and <filename
+    class="libraryfile">src/Utilities/Benchmark.cmpl.cpp</filename>.</para>
+ 
+   </chapter>
+ 
+ 
+   <chapter id="layouts_ref">
+    <title>Layouts and Partitions: Distribute Computation Among
+    Contexts</title>
+ 
+    <para>What is the difference between <type>ReplicatedTag</type> and
+    <type>DistributedTag</type>?</para>
+ 
+   </chapter>
+ 
+ 
+   <chapter id="pete_ref">
+    <title>&pete;: Evaluating Parallel Expressions</title>
+ 
+    <section>
+     <title>UNKNOWN</title>
+ 
+     <section id="pete_ref-unknown-leaf-tags">
+      <title>Leaf Tag Classes</title>
+ 
+      <para><type>NotifyPreReadTag</type> indicates a term is about to
+      be read.  Why is this needed?  Defined in <filename
+      class="headerfile">src/Utilities/NotifyPreRead.h</filename>.</para>
+     </section>
+    </section>
+ 
+   </chapter>
+ 
+ 
+   <chapter id="views_ref">
+    <title>Views</title>
+ 
+    <para>QUESTION: Should this have its own chapter or be part of a
+    container chapter?</para>
+ 
+    <para>Describe <type>View0</type>, <type>View1</type>, &hellip;,
+    <type>View7</type> and <type>View1Implementation</type>.</para>
+ 
+    <para>QUESTION: What causes the need for <type>AltView0</type> and
+    <type>AltComponentView</type>?</para>
+ 
+    <para>Be sure to describe <type>ComponentView</type> in the same
+    place.  This is specialized for &array;s in <filename
+    class="headerfile">src/Array/Array.h</filename>:1323&ndash;1382.</para>
+ 
+    <section>
+     <title><type>ViewIndexer&lt;Dim,Dim2&gt;</type></title>
+ 
+     <para>Defined in <filename
+     class="headerfile">src/Utilities/ViewIndexer.h</filename>, this
+     type translates indices between a domain and a view of it.</para>
+    </section>
+   </chapter>
+ 
+   <chapter id="threads_ref">
+    <title>Threads</title>
+ 
+    <para>Perhaps include information in <filename
+    class="headerfile">src/Engine/DataObject.h</filename>.</para>
+ 
+    <para>&pooma; options include UNFINISHED</para>
+ 
+   </chapter>
+ 
+ 
+   <chapter id="utilities_ref">
+    <title>Utility Types</title>
+ 
+    <para>TMP: What is a good order?</para>
+ 
+    <section id="utilities_ref-options">
+     <title><type>Options</type>: Varying Run-Time Execution</title>
+ 
+     <para>Each &pooma; executable has a <type>Options</type> object,
+     created by <function>Pooma::initialize</function>, storing
+     run-time configurable values found in <varname>argv</varname>.
+     Default options are found in
+     <literal>Options::usage</literal>.</para>
+ 
+     <para>See <filename
+     class="headerfile">src/Utilities/Options.h</filename> and
+     <filename
+     class="libraryfile">src/Utilities/Options.cmpl.cpp</filename>.</para>
+ 
+     <para>Scatter the specific options to other parts of the
+     manual.</para>
+    </section>
+ 
+    <section id="utilities_ref-assertions">
+     <title>Check Correctness: <type>CTAssert</type>,
+     <type>PAssert</type>, <type>PInsist</type>,
+     <type>SameType</type></title>
+ 
+     <para>Assertions ensure program invariants are obeyed.
+     <type>CTAssert</type>, checked at compile time, incur no run-time
+     cost.  <type>PAssert</type> and <type>PInsist</type> are checked
+     to run-time, the latter producing an explanatory message if the
+     assertion fails.  Compiling with <envar>NOCTAssert</envar> and
+     <envar>NOPTAssert</envar> disable these checks.  Compiling with just
+     <envar>NOPTAssert</envar> disables only the run-time checks.</para>
+ 
+     <para><type>SameType</type> ensures, at compile-time, two types
+     are the same.</para>
+ 
+     <para>These are implemented in <filename
+     class="headerfile">src/Utilities/PAssert.h</filename> and
+     <filename
+     class="libraryfile">src/Utilities/PAssert.cmpl.cpp</filename>.</para>
+    </section>
+ 
+    <section id="utilities_ref-clock">
+     <title><type>Clock</type>: Measuring a Program's Execution Time</title>
+ 
+     <para>See <filename
+     class="headerfile">src/Utilities/Clock.h</filename>.</para>
+    </section>
+ 
+ 
+    <section id="utilities_ref-smart_pointers">
+     <title>Smart Pointers: <type>RefCountedPtr</type>,
+     <type>RefCountedBlockPtr</type>, and
+     <type>DataBlockPtr</type></title>
+ 
+     <para>See <filename
+     class="headerfile">src/Utilities/{RefCountedPtr,RefCountedBlockPtr,DataBlockPtr}.h</filename>.
+     <filename class="headerfile">src/Utilities/RefCounted.h</filename>
+     helps implement it.  <type>DataBlockPtr</type> uses
+     &smarts;.</para>
+    </section>
+ 
+    <section id="utilities_ref-inform">
+     <title><type>Inform</type>: Formatted Output for Multi-context
+     Execution</title>
+ 
+     <para>See <filename
+     class="headerfile">src/Utilities/Inform.h</filename> and <filename
+     class="libraryfile">src/Utilities/Inform.cmpl.cpp</filename>.</para>
+    </section>
+ 
+    <section id="utilities_ref-statistics">
+     <title><type>Statistics</type>: Report &pooma; Execution Statistics</title>
+ 
+     <para>Collect and print execution statistics.  Defined in
+     <filename
+     class="headerfile">src/Utilities/Statistics.h</filename>.</para>
+    </section>
+ 
+    <section id="utilities_ref-random_numbers">
+     <title>Random Numbers: <type>Unique</type></title>
+ 
+     <para>See <filename
+     class="headerfile">src/Utilities/Unique.h</filename>.</para>
+    </section>
+   </chapter>
+ 
+ 
+   <chapter id="implementation_types_ref">
+    <title>Types for Implementing &pooma;</title>
+ 
+    <para>TMP: What is a good order?</para>
+ 
+    <para>Describe types defined to implement &pooma; but that users do
+    not directly use.  This chapter has lower priority than other
+    chapters since users (hopefully) do not need to know about these
+    classes.</para>
+ 
+    <section id="implementation_types_ref-tester">
+     <title><type>Tester</type>: Check Implementation Correctness</title>
+ 
+     <para>&pooma; implementation test programs frequently consist of a
+     series of operations followed by correctness checks.  The
+     <type>Tester</type> object supports these tests, returning a
+     boolean whether all the correctness checks yield true.  Under
+     verbose output, messages are printed for each test.  See <filename
+     class="headerfile">src/Utilities/Tester.h</filename>.</para>
+    </section>
+ 
+    <section id="implementation_types_ref-elementproperties">
+     <title><type>ElementProperties&lt;T&gt;</type>: Properties a Type
+     Supports</title>
+ 
+     <para>This traits class permits optimizations in other templated
+     classes.  See <filename
+     class="headerfile">src/Utilities/ElementProperties.h</filename>.</para>
+ 
+    </section>
+ 
+    <section id="implementation_types_ref-typeinfo">
+     <title><type>TypeInfo&lt;T&gt;</type>: Print a String Describing
+     the Type</title>
+ 
+     <para>Print a string describing the type.  Defined in <filename
+     class="headerfile">src/Utilities/TypeInfo.h</filename>.  It is
+     specialized for other types in other files, e.g., <filename
+     class="headerfile">src/Engine/EngineTypeInfo.h</filename> and
+     <filename class="headerfile">src/Field/FieldTypeInfo.h</filename>.
+     Is this a compile-time version of RTTI?</para>
+    </section>
+ 
+    <section id="implementation_types_ref-looputils">
+     <title><type>LoopUtils</type>: Loop Computations at Compile Time</title>
+ 
+     <para>At compile time, <type>LoopUtils</type> supports copying
+     between arrays and computing the dot product of arrays.  See
+     <filename
+ 	      class="headerfile">src/Utilities/MetaProg.h</filename>.</para>
+    </section>
+ 
+    <section id="implementation_types_ref-modelelement">
+     <title><type>ModelElement&lt;T&gt;</type>: Wrap a Type</title>
+ 
+     <para>A wrapper class used to differentiate overloaded functions.
+     Defined in <filename
+     class="headerfile">src/Utilities/ModelElement.h</filename>.  Used
+     only by &array; and <type>DynamicArray</type>.</para>
+    </section>
+ 
+    <section id="implementation_types_ref-wrappedint">
+     <title><type>WrappedInt&lt;int&gt;</type>: Wrap a Number</title>
+ 
+     <para>A wrapper class used to differentiate overloaded functions
+     among different integers.  Defined in <filename
+     class="headerfile">src/Utilities/WrappedInt.h</filename>.  Is this
+     class deprecated?  Is it even necessary?</para>
+    </section>
+    
+    <section id="implementation_types_ref-empty_classes">
+     <title>Supporting Empty Classes</title>
+ 
+     <para>The <type>NoInit</type> tag class indicates certain
+     initializations should be skipped.  Defined in <filename
+     class="headerfile">src/Utilities/NoInit.h</filename>.</para>
+ 
+     <para>FIXME: Should be macro, not function.
+     <function>POOMA_PURIFY_CONSTRUCTORS</function> generates an empty
+     constructor, copy constructor, and destructor to avoid &purify;
+     warnings.  Defined in <filename
+     class="headerfile">src/Utilities/PurifyConstructors.h</filename>.</para>
+ 
+    </section>
+ 
+    <section id="implementation_types_ref-pool">
+     <title><type>Pooled&lt;T&gt;</type>: Fast Memory Allocation of
+     Small Blocks</title>
+ 
+     <para><type>Pooled&lt;T&gt;</type> speeds allocation and
+     deallocation of memory blocks for small objects with
+     type&nbsp;<type>T</type>.  Defined in <filename
+     class="headerfile">src/Utilities/Pooled.h</filename>, it is
+     implemented in <filename
+     class="headerfile">src/Utilities/Pool.h</filename> and <filename
+     class="libraryfile">src/Utilities/Pool.cmpl.cpp</filename>.
+     <filename class="headerfile">src/Utilities/StaticPool.h</filename>
+     no longer seems to be used.</para>
+    </section>
+ 
+    <section id="implementation_types_ref-uninitialized_vector">
+     <title><type>UninitializedVector&lt;T,Dim&gt;</type>: Create
+     Without Initializing</title>
+ 
+     <para>This class optimizes creation of an array of objects by
+     avoiding running the default constructors.  Later initialization
+     can occur, perhaps using a loop that can be unrolled.  Defined in
+     <filename
+     class="headerfile">src/Utilities/UninitializedVector.h</filename>,
+     this is used only by <type>DomainTraits</type>.</para>
+    </section>
+   </chapter>
+ 
+   <chapter id="implementation_algorithms_ref">
+    <title>Algorithms for Implementing &pooma;</title>
+ 
+    <para>In <filename>src/Utilities/algorithms.h</filename>,
+    <function>copy</function>, <function>delete_back</function>, and
+    <function>delete_shiftup</function> provide additional algorithms
+    using iterators.</para>
+   </chapter>
+ 
+ 
+   <chapter id="where_place_these_ref">
+    <title>TMP: Where do we describe these files?</title>
+ 
+    <itemizedlist>
+     <listitem>
+      <para><filename
+      class="headerfile">src/Utilities/Conform.h</filename>: tag for
+      checking whether terms in expression have conforming
+      domains</para>
+     </listitem>
+ 
+     <listitem>
+      <para><filename
+      class="headerfile">src/Utilities/DerefIterator.h</filename>:
+      <type>DerefIterator&lt;T&gt;</type> and
+      <type>ConstDerefIterator&lt;T&gt;</type> automatically
+      dereference themselves to maintain <literal>const</literal>
+      correctness.</para>
+     </listitem>
+ 
+     <listitem>
+      <para><filename
+      class="headerfile">src/Utilities/Observable.h</filename>,
+      <filename class="headerfile">src/Utilities/Observer.h</filename>,
+      and <filename
+      class="headerfile">src/Utilities/ObserverEvent.h</filename>:
+      <type>Observable&lt;T&gt;</type>,
+      <type>SingleObserveable&lt;T&gt;</type>,
+      <type>Observer&lt;T&gt;</type>, and <type>ObserverEvent</type>
+      implement the observer pattern.  What is the observer pattern?
+      Where is this used in the code?</para>
+     </listitem>
+    </itemizedlist>
+ 
+   </chapter>
+ 
+ 
+   <chapter id="needed_reference_items_ref">
+    <title>TMP: Items to Discuss in Reference Manual</title>
+ 
+    <itemizedlist>
+     <listitem>
+      <para>Discuss &options; and related material.  Add developer
+      command-line options listed in <filename
+      class="libraryfile">Utilities/Options.cmpl.cpp</filename> and also
+      possibly <parameter class="option">&dashdash;pooma-threads
+      <replaceable>n</replaceable></parameter>.</para>
+     </listitem>
+    </itemizedlist>
+   </chapter>
+  </part>
+ ]]>  <!-- end unfinished -->
+ 
+ 
+ <![%unfinished;[
+  <appendix id="future_development">
+   <title>Future Development</title>
+ 
+   <section id="future_development-particles">
+    <title>Particles</title>
+ 
+    <para><filename
+    class="libraryfile">docs/ParticlesDoc.txt</filename> has
+    out-of-date information.</para>
+ 
+    <para>See Section&nbsp;3.2.3 of
+    <filename>papers/pooma.ps</filename> for an out-of-date
+    description.</para>
+ 
+    <para><filename>papers/jvwr.ps</filename> concerns mainly
+    particles.  <filename>papers/8thSIAMPOOMAParticles.pdf</filename>,
+    by Julian Cummings and Bill Humphrey, concerns parallel particle
+    simulations.  <filename>papers/iscope98linac.pdf</filename>
+    describes a particle beam simulation using &pooma;; it mainly
+    concerns particles.</para>
+ 
+    <section>
+     <title>Particles</title>
+ 
+     <para>Do we want to include such a section?</para>
+ 
+     <para>Section&nbsp;3, "Sample Applications" of
+     <filename>papers/SiamOO98_paper.ps</filename> describes porting a
+     particle program written using High-Performance &fortran; to
+     &pooma; and presumably why particles were added to &pooma;.  It
+     also describes <application>MC++</application>, a Monte Carlo
+     neutron transport code.</para>
+ 
+    </section>
+ 
+   </section>
+ 
+ 
+   <section id="future_development-composition_engine">
+    <title>Composition of &engine;s</title>
+ 
+    <para>The i,j-th element of the composition
+    <varname>a</varname>&compfn;<varname>b</varname> of two arrays
+    <varname>a</varname> and <varname>b</varname> equals a(b(i,j)).
+    The composition engine tagged <literal>IndirectionTag&lt;Array1,
+    Array2&gt;</literal>, defined in <filename
+ 					      class="headerfile">src/Engine/IndirectionEngine.h</filename> is
+    unfinished.</para>
+   </section>
+ 
+ 
+   <section id="future_development-container_consistency">
+    <title>Improving Consistency of Container Interfaces</title>
+ 
+    <section id="future_development-container_consistency-array_relations">
+     <title>Relations for &array;s</title>
+ 
+     <para>Do &array;s currently support relations?  If not, why not?
+    Should they be added?</para>
+    </section>
+ 
+    <section id="future_development-container_consistency-dimensions">
+     <title>Supporting the Same Number of Dimensions</title>
+ 
+     <para>&array; and &field; should support the same maximum number
+     of dimensions.  Currently, &array;s support seven dimensions and
+     &field;s support only three.  By definition, &dynamicarray;
+     supports only one dimension.</para>
+ 
+     <para>Relations for &array;s.</para>
+ 
+     <para>External guards for &array;s.</para>
+ 
+     <para>QUESTION: What is <quote>tiny</quote> about &matrix;?  Should
+     they be renamed?</para>
+    </section>
+ 
+   </section>
+ 
+ 
+   <section id="future_development-where">
+    <title><function>where</function> Proxies</title>
+ 
+    <para>QUESTION: Do we even discuss this broken
+    <quote>feature</quote>?  Where is it used?  Some related code is in
+    <filename>src/Array/Array.h</filename>:2511&ndash;2520.</para>
+   </section>
+ 
+ 
+   <section id="future_development-distributed_input">
+    <title>Easing Input for Distributed Programs</title>
+ 
+    <para>Currently, standard input to distributed programs is not
+    supported.  Instead input can be passed via command-line arguments,
+    which are replicated to each context.  &inform; streams support for
+    input could be added.  For context&nbsp;0, standard input could be
+    used.  Other contexts would use a <type>RemoteProxy</type> to
+    distribute the value to the other contests.  See <filename
+    class="headerfile">src/Engine/RemoteEngine.h</filename> for example
+    uses of <type>RemoteProxy</type>.</para>
+   </section>
+ 
+ 
+   <section id="future_development-cheetah_pooma_consistency">
+    <title>Improving Consistency Between &pooma; and &cheetah;</title>
+ 
+    <para>Improve the consistency between &cheetah;'s and &pooma;'s
+    configurations.  Currently, their defaults differ regarding
+    &cc; exceptions and static/shared libraries.</para>
+   </section>
+ 
+ 
+   <section id="future_development-long_term">
+    <title>Very Long Term Development Ideas</title>
+ 
+    <para>Describe how to write a new configuration file.</para>
+   </section>
+ 
+  </appendix>
+ ]]>  <!-- end unfinished -->
+ 
+ 
+  <appendix id="installation">
+   <title>Obtaining and Installing &pooma;</title>
+ 
+ <![%temporary;[
+   <para>In <xref linkend="tutorial-installation"></xref>, we described
+   how to install &pooma;.  In the following section, we describe how
+   to install &pooma; to support distributed computation.</para>
+ ]]>  <!-- end temporary -->
+ 
+ <![%unfinished;[
+   <para>ADD: Write this section, including extensive instructions
+   for Unix-like, MS Windows, and MacOS.  List the configuration options.
+   Be sure to describe configuring for parallel execution.</para>
+ ]]>  <!-- end unfinished -->
+ 
+   <section id="installation-distributed_computing">
+    <title>Supporting Distributed Computation</title>
+ 
+    <para>To use multiple processors with &pooma; requires installing
+    the &cheetah; messaging library and an underlying messaging library
+    such as the Message Passing Interface (&mpi;) Communications
+    Library or the &mm; Shared Memory Library.  In the following
+    section, we first describe how to install &mm;.  Read it only if
+    using &mm;, not &mpi;.  Then we describe how to install &cheetah;
+    and configure &pooma; to use it.</para>
+ 
+    <section id="installation-distributed_computing-mm">
+     <title>Obtaining and Installing the &mm; Shared Memory Library</title>
+ 
+     <para>&cheetah;, and thus &pooma;, can use Ralf Engelschall's &mm;
+     Shared Memory Library to pass messages between processors.  For
+     example, the &author; uses this library on a two-processor
+     computer running &linux;.  The library, available at <ulink
+     url="http://www.engelschall.com/sw/mm/">http://www.engelschall.com/sw/mm/</ulink>,
+     is available at no cost and has been successfully tested on a
+     variety of Unix-like platforms.</para>
+ 
+     <para>We describe how to download and install the &mm; library.
+      <orderedlist spacing="compact">
+       <listitem>
+        <para>Download the library from the &pooma; Download page
+        (&poomadownloadpage;) available off the &pooma; home page
+        (&poomahomepage;).</para>
+       </listitem>
+ 	<listitem>
+ 	 <para>Extract the source code using <command>tar xzvf
+          mm-1.1.3.tar.gz</command>.  Change directories into the
+          resulting source code directory <filename
+          class="directory">mm-1.1.3</filename>.</para>
+ 	</listitem>
+ 	<listitem>
+ 	 <para>Prepare to compile the source code by configuring it
+          using the <command>configure</command> command.  To change
+          the default installation directory <filename
+          class="directory">/usr/local</filename>, specify
+          <command>&dashdash;prefix=<replaceable>directory</replaceable></command>
+          option.  The other configuration options can be listed by
+          specifying the <command>&dashdash;help</command> option.  Since the
+          &author; prefers to keep all &pooma;-related code in his
+          <filename class="directory">pooma</filename>subdirectory, he
+          uses
+ <programlisting>
+ ./configure &dashdash;prefix=${HOME}/pooma/mm-1.1.3
+ </programlisting></para>
+ 	</listitem>
+ 	<listitem>
+ 	 <para>Create the library by issuing the
+          <command>make</command> command.  This compiles the source
+          code using a &c; compiler.  To use a different compiler than
+          the &mm; configuration chooses, set the <envar>CC</envar>
+          environment variable to the desired compiler before
+          configuring.</para>
+       </listitem>
+     <listitem>
+      <para>Optionally test the library by issuing the <command>make
+      test</command> command.  If successful, the penultimate line
+      should be <computeroutput>OK - ALL TESTS SUCCESSFULLY
+      PASSED</computeroutput>.</para>
+     </listitem>
+     <listitem>
+      <para>Install the &mm; Library by issuing the <command>make
+      install</command> command.  This copies the library files to the
+      installation directory.  The <filename
+      class="directory">mm-1.1.3</filename> directory containing the
+      source code may now be removed.</para>
+     </listitem>
+    </orderedlist>
+    </para>
+    </section>
+ 
+    
+    <section id="installation-distributed_computing-cheetah">
+     <title>Obtaining and Installing the &cheetah; Messaging Library</title>
+ 
+     <para>The &cheetah; Library decouples communication from
+     synchronization.  Using asynchronous messaging rather than
+     synchronous messaging permits a message sender to operate without
+     the cooperation of the message recipient.  Thus, implementing
+     message sending is simpler and processing is more efficiently
+     overlapped with it.  Remote method invocation is also supported.
+     The library was developed at the Los Alamos National Laboratory's
+     Advanced Computing Laboratory.</para>
+ 
+     <para>&cheetah;'s messaging is implemented using an underlying
+     messaging library such as the Message Passing Interface (&mpi;)
+     Communications Library
+ <![%unfinished;[
+  (FIXME: xref linkend="mpi99", <ulink
+     url="http://www-unix.mcs.anl.gov/mpi/"></ulink>)
+ ]]>  <!-- end unfinished -->
+     or the &mm; Shared Memory Library.  &mpi; works on a wide variety
+     of platforms and has achieved widespread usage.  &mm; works under
+     Unix-like operating systems on any computer with shared memory.  Both libraries are
+     available at no cost.  The instructions below work for whichever
+     library you choose.</para>
+ 
+     <para>We describe how to download and install &cheetah;.
+      <orderedlist spacing="compact">
+       <listitem>
+        <para>Download the library from the &pooma; Download page
+        (&poomadownloadpage;) available off the &pooma; home page
+        (&poomahomepage;).</para>
+       </listitem>
+       <listitem>
+        <para>Extract the source code using <command>tar xzvf
+        cheetah-1.0.tgz</command>.  Change directories into the
+        resulting source code directory <filename
+        class="directory">cheetah-1.0</filename>.</para>
+       </listitem>
+       <listitem>
+        <para>Edit a configuration file corresponding to your operating
+        system and compiler.  These <filename
+        class="libraryfile">.conf</filename> files are located in the
+        <filename class="directory">config</filename> directory.  For
+        example, to use &gcc; with the &linux; operating system, use
+        <filename
+        class="libraryfile">config/LINUXGCC.conf</filename>.</para>
+ 
+        <para>The configuration file usually does not need
+        modification.  However, if you are using &mm;, ensure
+        <varname>shmem_default_dir</varname> specifies its location.
+        For example, the &author; modified the value to
+        <literal>"/home/oldham/pooma/mm-1.1.3"</literal>.</para>
+       </listitem>
+       <listitem>
+        <para>Prepare to compile the source code by configuring it
+        using the <command>configure</command> command.  Specify the
+        configuration file using the <command>&dashdash;arch</command> option.
+        Its argument should be the configuration file's name, omitting
+        its <filename class="libraryfile">.conf</filename> suffix.  For
+        example, <command>&dashdash;arch LINUXGCC</command>.  Some other
+        options include
+        <variablelist>
+        <varlistentry>
+ 	<term>&dashdash;help</term>
+ 	<listitem>
+ 	 <para>lists all the available options</para>
+ 	</listitem>
+        </varlistentry>
+        <varlistentry>
+ 	<term>&dashdash;shmem &dashdash;nompi</term>
+ 	<listitem>
+ 	 <para>indicates use of &mm;, not &mpi;</para>
+ 	</listitem>
+        </varlistentry>
+        <varlistentry>
+ 	<term>&dashdash;mpi &dashdash;noshmem</term>
+ 	<listitem>
+ 	 <para>indicates use of &mpi;, not &mm;</para>
+ 	</listitem>
+        </varlistentry>
+        <varlistentry>
+ 	<term>&dashdash;opt</term>
+ 	<listitem>
+ 	 <para>causes the compiler to produce optimized source code</para>
+ 	</listitem>
+        </varlistentry>
+        <varlistentry>
+ 	<term>&dashdash;noex</term>
+ 	<listitem>
+ 	 <para>prevents use of &cc; exceptions</para>
+ 	</listitem>
+        </varlistentry>
+        <varlistentry>
+ 	 <term>&dashdash;static</term>
+ 	 <listitem>
+ 	  <para>creates a static library, not a shared library</para>
+ 	 </listitem>
+        </varlistentry>
+        <varlistentry>
+ 	 <term>&dashdash;shared</term>
+ 	 <listitem>
+ 	  <para>creates a shared library, not a static library.  This
+ 	  is the default.</para>
+ 	 </listitem>
+        </varlistentry>
+        <varlistentry>
+ 	<term>&dashdash;prefix <replaceable>directory</replaceable></term>
+ 	<listitem>
+ 	 <para>specifies the installation directory where the
+ 	   library will be copied rather than the default.</para>
+ 	</listitem>
+        </varlistentry>
+       </variablelist>
+         For example, the &author; uses
+ <programlisting>
+ ./configure &dashdash;arch LINUXGCC &dashdash;shmem &dashdash;nompi
+ &dashdash;noex &dashdash;static &dashdash;prefix ${HOME}/pooma/cheetah-1.0
+ &dashdash;opt
+ </programlisting>  The
+         <command>&dashdash;arch LINUXGCC</command> indicates use of &gcc;
+         under a &linux; operating system.  The &mm; library is used,
+         but &cc; exceptions are not.  The latter choice matches
+         &pooma;'s default choice.  A static library, not a shared
+         library, is created.  This is also &pooma;'s default choice.
+         The library will be installed in the <filename
+         class="directory">${HOME}/pooma/cheetah-1.0</filename>.
+         Finally, the library code will be optimized, hopefully running
+         faster than unoptimized code.</para>
+       </listitem>
+       <listitem>
+        <para>Follow the directions printed by
+        <command>configure</command>: Change directories to the
+        <filename class="directory">lib</filename> subdirectory named
+        by the <command>&dashdash;arch</command> argument and then type
+        <command>make</command> to compile the source code and create
+        the library.</para>
+       </listitem>
+       <listitem>
+        <para>Optionally ensure the library works correctly by issuing
+        the <command>make tests</command> command.</para>
+       </listitem>
+       <listitem>
+        <para>Install the library by issuing the <command>make
+        install</command> command.  This copies the library files to
+        the installation directory.  The <filename
+        class="directory">cheetah-1.0</filename> directory containing
+        the source code may now be removed.</para>
+       </listitem>
+      </orderedlist>
+    </para>
+    </section>
+ 
+    <section id="installation-distributed_computing-pooma">
+     <title>Configuring &pooma; When Using &cheetah;</title>
+ 
+     <para>To use &pooma; with &cheetah;, one must tell &pooma; the
+     location of the &cheetah; library using the
+     <command>&dashdash;messaging</command> configuration option.  To do this,
+      <orderedlist spacing="compact">
+       <listitem>
+        <para>Set the &cheetah; directory environment variable
+         <envar>CHEETAHDIR</envar> to the directory containing the
+         installed &cheetah; library.  For
+         example,
+ <programlisting>
+ declare -x CHEETAHDIR=${HOME}/pooma/cheetah-1.0
+ </programlisting> specifies the
+         installation directory used in the previous section.  If using
+         the <application>csh</application> shell, use <command>setenv 
+         CHEETAHDIR ${HOME}/pooma/cheetah-1.0</command>.</para>
+       </listitem>
+       <listitem>
+        <para>When configuring &pooma;, specify the
+        <command>&dashdash;messaging</command> option.  For example,
+        <command>./configure &dashdash;arch LINUXgcc &dashdash;opt
+        &dashdash;messaging</command> configures for &linux;, &gcc;, and an
+        optimized library using &cheetah;.</para>
+       </listitem>
+      </orderedlist>
+     </para>
+    </section>
+   </section>
+  </appendix>
+ 
+ 
+ <![%unfinished;[
+  <appendix id="compilation_errors">
+   <title>Dealing with Compilation Errors</title>
+ 
+   <para>Base this low-priority section on <filename
+   class="libraryfile">errors.html</filename>.  QUESTION: Where is
+   <filename class="libraryfile">errors.html</filename>?</para>
+ 
+  </appendix>
+ 
+ 
+  <appendix id="tmp_appendix">
+   <title>TMP: Notes to Myself</title>
+ 
+   <section id="tmp-miscellaneous">
+    <title>Miscellaneous</title>
+ 
+    <orderedlist>
+     <listitem>
+      <para>Section&nbsp;5, "Performance," of
+      <filename>papers/iscope98.pdf</filename> motivates and explains
+      stencils.</para>
+     </listitem>
+ 
+     <listitem>
+      <para>If there is time, present another example program, e.g., a
+      Jacobi solver.</para>
+     </listitem>
+ 
+     <listitem>
+      <para>If a reference manual for &pooma; implementors is written,
+      begin with a chapter <quote>Under the Hood: How &pooma;
+      Works</quote>, written from the point of view of &cc;
+      interpreter.  For &pete;, use the material in
+      <filename>papers/PETE_DDJ/ddj_article.html</filename>, which
+      gives example code and descriptions of how the code works, and
+      see material in <filename
+      class="libraryfile">background.html</filename>'s
+      <quote>Expression Templates.</quote></para>
+     </listitem>
+ 
+     <listitem>
+      <para>QUESTION: How do &pooma; parallel concepts compare with
+      &fortran;&nbsp;D or high-performance &fortran; FINISH CITE:
+      {koelbel94:_high_perfor_fortr_handb}?</para>
+     </listitem>
+ 
+     <listitem>
+      <para>QUESTION: How do I know when to use a type name versus just
+      the concept?  For example, when do I use <quote>array</quote>
+      versus &array;?</para>
+     </listitem>
+ 
+     <listitem>
+      <para>Krylov solvers are described in Section&nbsp;3.5.2 of
+      <filename>papers/pooma.ps</filename>.</para>
+     </listitem>
+ 
+     <listitem>
+      <para>Section&nbsp;5, "The Polygon Overlay Problem," describes
+      porting an <acronym>ANSI</acronym> &c; program to &pooma;.</para>
+     </listitem>
+ 
+     <listitem>
+      <para>A good example book: <emphasis>STL Tutorial and Reference
+      Guide: &cc; Programming with the Standard Template
+      Library</emphasis>, second edition, by David&nbsp;R. Musser,
+      Gillmer&nbsp;J. Derge, and Atul Sanai, ISBN 0-201-37923-6,
+      QA76.73.C153.M87 2001.</para>
+     </listitem>
+ 
+     <listitem>
+      <para>One STL reference book listed functions in margin notes,
+      easing finding material.  Do this.</para>
+     </listitem>
+ 
+     <listitem>
+      <para>QUESTION: Does Berna Massingill at Trinity University have
+      any interest ior access to any parallel computers?</para>
+     </listitem>
+    </orderedlist>
+ 
+   </section>
+ 
+ 
+   <section id="tmp-html_tutorials">
+    <title>Existing HTML Tutorials</title>
+ 
+    <para>All these tutorials are out-of-date, but the ideas and text
+    may still be relevant.</para>
+ 
+    <variablelist>
+     <varlistentry><term><filename
+ 				  class="libraryfile">index.html</filename></term>
+      <listitem><para>list of all tutorials.  No useful
+     material.</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+ 				  class="libraryfile">introduction.html</filename></term>
+      <listitem><para>data-parallel Laplace solver using Jacobi
+     iteration ala <command>Doof2d</command></para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+ 				  class="libraryfile">background.html</filename></term>
+      <listitem><para>short, indirect introduction to &pete;; parallel
+     execution model; &cc;; templates; &stl;; expression
+     templates</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+ 				  class="libraryfile">tut-01.html</filename></term>
+      <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+ 				  class="libraryfile">Layout.html</filename></term>
+      <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+ 				  class="libraryfile">parallelism.html</filename></term>
+      <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+ 				  class="libraryfile">self-test.html</filename></term>
+      <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">threading.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-03.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-04.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-05.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-06.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-07.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-08.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-09.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-10.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-11.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-12.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+     <varlistentry><term><filename
+     class="libraryfile">tut-13.html</filename></term>
+     <listitem><para>UNFINISHED</para></listitem>
+     </varlistentry>
+    </variablelist>
+ 
+   </section>
+ 
+  </appendix>
+ ]]>  <!-- end unfinished -->
+ 
+ 
+  &bibliography-chapter;
+ 
+  &glossary-chapter; 
+ 
+  <!-- Index -->
+ 
+ <![%unfinished;[
+   &genindex.sgm;
+ ]]>  <!-- end unfinished -->
+ 
+ </book>
Index: print.dsl
===================================================================
RCS file: print.dsl
diff -N print.dsl
*** /dev/null	Fri Mar 23 21:37:44 2001
--- print.dsl	Thu Jan 31 14:10:44 2002
***************
*** 0 ****
--- 1,320 ----
+ <!-- DSSSL stylesheet for generating TeX from DocBook documents. -->
+ 
+ <!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN" [
+ <!ENTITY docbook.dsl PUBLIC "-//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN" CDATA DSSSL>
+ ]>
+ 
+ <!-- This DSSSL stylesheet formats the POOMA manual, written in
+      DocBook, as converted to PostScript and PDF.  When producing
+      PostScript, be sure to define 'use-eps' on the jade command line:
+         jade ... -V use-eps
+      This ensures EPS graphics files can be used. 
+ 
+      Jeffrey D. Oldham
+      2002 January 29 -->
+ 
+ <style-sheet>
+ <style-specification use="docbook">
+ <style-specification-body>
+ 
+ ;; $Id: plain.dsl,v 1.2 2000/09/28 12:50:20 ndw Exp $
+ ;;
+ ;; This file is part of the Modular DocBook Stylesheet distribution.
+ ;; See ../README or http://www.berkshire.net/~norm/dsssl/
+ ;;
+ ;; Example of a customization layer on top of the modular docbook style
+ ;; sheet.  Definitions inserted in this file take precedence over 
+ ;; definitions in the 'use'd stylesheet(s).
+ 
+ ;; Number chapters and sections.
+ (define %chapter-autolabel% #t)
+ (define %section-autolabel% #t)
+ 
+ ;; Use a readable font size.
+ (define %visual-acuity% "presbyopic")
+ ;; Prevent verbatim text from being displayed at a different size.
+ (define %verbatim-size-factor% 1.1)
+ 
+ ;; Indent program listings four spaces
+ (define %indent-programlisting-lines% "    ")
+ 
+ ;; Support two-sided printing.
+ (define %two-side% #t)	;; does not have any effect
+ 
+ ;; Produce justified text and hyphenation.
+ (define %default-quadding% 'justify)
+ (define %hyphenation% #t)
+ 
+ ;; Produce footnotes at the bottom of the page, not section end.
+ (define bop-footnotes #t)
+ 
+ ;; Use EPS for PS generation and PNG for PDF generation.
+ ;; Use '-V use-eps' to use EPS files.
+ (define use-eps #f)
+ (define %graphic-extensions% 
+   (if use-eps
+       '("eps" "epsf" "gif" "tif" "tiff" "jpg" "jpeg" "png")
+       '("gif" "tif" "tiff" "jpg" "jpeg" "png")))
+ ; modified from stylesheets/docbook/print/db31.dsl
+ (define preferred-mediaobject-notations
+   (if use-eps
+       (list "EPS" "PS" "JPG" "JPEG" "PNG" "linespecific")
+       (list "JPG" "JPEG" "PNG" "linespecific")))
+ (define preferred-mediaobject-extensions
+   (if use-eps
+       (list "eps" "ps" "jpg" "jpeg" "png")
+       (list "jpg" "jpeg" "png")))
+ 
+ ;; Layout variable lists in a reasonable way.
+ ;; does not work well (define %may-format-variablelist-as-table% #t)
+ ;; (define %always-format-variablelist-as-table #t) ;; does not work at all
+ 
+ ;; Float tables and examples.
+ (define formal-object-float #f)
+ ;(define %example-rules% #t)	Uncomment if use floats.
+ ;(define %figure-rules% %example-rules%)
+ ;(define %table-rules% %example-rules%)
+ 
+ ;; Fix space breaking for xref text.  I tried modifying
+ ;; en-xref-strings from docbook/common/dbl1en.dsl, but I could not get
+ ;; it to work because the entities in this list are not defined.
+ 
+ ;; Change the default presentation for various tags.
+ ; Use mono-space font for computer items.
+ (element command ($mono-seq$))
+ (element envar ($mono-seq$))
+ (element errorname ($mono-seq$))
+ (element errortype ($mono-seq$))
+ (element keywordname ($mono-seq$))	; new tag aded by Oldham
+ (element methodname ($mono-seq$))	; new tag aded by Oldham
+ (element operator ($mono-seq$))		; new tag aded by Oldham
+ (element statement ($mono-seq$))	; new tag aded by Oldham
+ (element symbol ($mono-seq$))
+ (element token ($mono-seq$))
+ (element type ($mono-seq$))
+ 
+ ; Number all pages sequentially, rather than separate numbering for
+ ; various pieces of the preface.
+ ; Copied from stylesheets/docbook/print/dbdivis.dsl.
+ (element book 
+   (let* ((bookinfo  (select-elements (children (current-node)) 
+ 				     (normalize "bookinfo")))
+ 	 (dedication (select-elements (children (current-node)) 
+ 				      (normalize "dedication")))
+ 	 (nl        (titlepage-info-elements (current-node) bookinfo)))
+     (make sequence
+       (if %generate-book-titlepage%
+ 	  (make sequence
+ 	    (book-titlepage nl 'recto)
+ 	    (book-titlepage nl 'verso))
+ 	  (empty-sosofo))
+ 
+       (if (node-list-empty? dedication)
+ 	  (empty-sosofo)
+ 	  (with-mode dedication-page-mode
+ 	    (process-node-list dedication)))
+ 
+       (if (not (generate-toc-in-front))
+ 	  (process-children)
+ 	  (empty-sosofo))
+ 
+       (if %generate-book-toc%
+ 	  (make simple-page-sequence
+ 	    page-n-columns: %page-n-columns%
+ 	    page-number-restart?: #f	; changed from #t
+ 	    page-number-format: ($page-number-format$ (normalize "toc"))
+ 	    use: default-text-style
+ 	    left-header:   ($left-header$ (normalize "toc"))
+ 	    center-header: ($center-header$ (normalize "toc"))
+ 	    right-header:  ($right-header$ (normalize "toc"))
+ 	    left-footer:   ($left-footer$ (normalize "toc"))
+ 	    center-footer: ($center-footer$ (normalize "toc"))
+ 	    right-footer:  ($right-footer$ (normalize "toc"))
+ 	    input-whitespace-treatment: 'collapse
+ 	    (build-toc (current-node)
+ 		       (toc-depth (current-node))))
+ 	  (empty-sosofo))
+ 	    
+       (let loop ((gilist ($generate-book-lot-list$)))
+ 	(if (null? gilist)
+ 	    (empty-sosofo)
+ 	    (if (not (node-list-empty? 
+ 		      (select-elements (descendants (current-node))
+ 				       (car gilist))))
+ 		(make simple-page-sequence
+ 		  page-n-columns: %page-n-columns%
+ 		  page-number-format: ($page-number-format$ (normalize "lot"))
+ 		  use: default-text-style
+ 		  left-header:   ($left-header$ (normalize "lot"))
+ 		  center-header: ($center-header$ (normalize "lot"))
+ 		  right-header:  ($right-header$ (normalize "lot"))
+ 		  left-footer:   ($left-footer$ (normalize "lot"))
+ 		  center-footer: ($center-footer$ (normalize "lot"))
+ 		  right-footer:  ($right-footer$ (normalize "lot"))
+ 		  input-whitespace-treatment: 'collapse
+ 		  (build-lot (current-node) (car gilist))
+ 		  (loop (cdr gilist)))
+ 		(loop (cdr gilist)))))
+ 
+       (if (generate-toc-in-front)
+ 	  (process-children)
+ 	  (empty-sosofo)))))
+ ; Copied from stylesheets/docbook/print/dbcompon.dsl.
+ (define ($component$)
+   (make simple-page-sequence
+     page-n-columns: %page-n-columns%
+     page-number-restart?: #f		; changed
+     page-number-format: ($page-number-format$)
+     use: default-text-style
+     left-header:   ($left-header$)
+     center-header: ($center-header$)
+     right-header:  ($right-header$)
+     left-footer:   ($left-footer$)
+     center-footer: ($center-footer$)
+     right-footer:  ($right-footer$)
+     start-indent: %body-start-indent%
+     input-whitespace-treatment: 'collapse
+     quadding: %default-quadding%
+     (make sequence
+       ($component-title$)
+       (process-children))
+     (make-endnotes)))
+ 
+ ; Center figures.
+ (element mediaobject
+   (make paragraph
+     quadding: 'center			; added
+     ($mediaobject$)))
+ 
+ ;; Display verbatim block environments with smaller font.
+ ; Copied from stylesheets/docbook/print/dbverb.dsl.
+ (define ($verbatim-display$ indent line-numbers?)
+   (let* ((width-in-chars (if (attribute-string (normalize "width"))
+ 			     (string->number (attribute-string (normalize "width")))
+ 			     %verbatim-default-width%))
+ 	 (fsize (lambda () (if (or (attribute-string (normalize "width"))
+ 				   (not %verbatim-size-factor%))
+ 			       (/ (/ (- %text-width% (inherited-start-indent))
+ 				     width-in-chars) 
+ 				  0.7)
+ 			      (inherited-font-size)))) ; changed
+ 	 (vspace (if (INBLOCK?)
+ 		     0pt
+ 		     (if (INLIST?)
+ 			 %para-sep% 
+ 			 %block-sep%))))
+     (make paragraph
+       use: verbatim-style
+       space-before: (if (and (string=? (gi (parent)) (normalize "entry"))
+  			     (absolute-first-sibling?))
+ 			0pt
+ 			vspace)
+       space-after:  (if (and (string=? (gi (parent)) (normalize "entry"))
+  			     (absolute-last-sibling?))
+ 			0pt
+ 			vspace)
+       font-size: (fsize)
+       line-spacing: (* (fsize) %line-spacing-factor%)
+       start-indent: (if (INBLOCK?)
+ 			(inherited-start-indent)
+ 			(+ %block-start-indent% (inherited-start-indent)))
+       (if (or indent line-numbers?)
+ 	  ($linespecific-line-by-line$ indent line-numbers?)
+ 	  (process-children)))))
+ 
+ ;; Remove initial and final spaces before programlisting embedded
+ ;; within a para.
+ (define ($verbatim-display-embedded$ indent line-numbers?)
+   (let* ((width-in-chars (if (attribute-string (normalize "width"))
+ 			     (string->number (attribute-string (normalize "width")))
+ 			     %verbatim-default-width%))
+ 	 (fsize (lambda () (if (or (attribute-string (normalize "width"))
+ 				   (not %verbatim-size-factor%))
+ 			       (/ (/ (- %text-width% (inherited-start-indent))
+ 				     width-in-chars) 
+ 				  0.7)
+ 			       (inherited-font-size))))) ; changed
+     (make paragraph
+       use: verbatim-style
+       space-before: 0pt
+       space-after: 0pt
+       min-pre-line-spacing: 0pt
+       min-post-line-spacing: 0pt
+       keep-with-previous?: #t
+       keep-with-next?: #t
+       font-size: (fsize)
+       line-spacing: (* (fsize) %line-spacing-factor%)
+       start-indent: (if (INBLOCK?)
+ 			(inherited-start-indent)
+ 			(+ %block-start-indent% (inherited-start-indent)))
+       (if (or indent line-numbers?)
+ 	  ($linespecific-line-by-line$ indent line-numbers?)
+ 	  (process-children)))))
+ (element (para programlisting)		; process the programlisting, not para
+   ($verbatim-display-embedded$
+    %indent-programlisting-lines%
+    %number-programlisting-lines%))
+ 
+ ;; Remove initial and final spaces before itemizedlist embedded
+ ;; within a para.
+ (define ($list-embedded$)
+   (make display-group
+     start-indent: (if (INBLOCK?)
+                       (inherited-start-indent)
+                       (+ %block-start-indent% (inherited-start-indent)))
+     space-after:  0pt
+     space-before: 0pt
+     min-pre-line-spacing: 0pt
+     min-post-line-spacing: 0pt
+     keep-with-previous?: #t
+     keep-with-next?: #t))
+ (element (para itemizedlist)
+   ($list-embedded$))
+ (element (para orderedlist)
+   ($list-embedded$))
+ 
+ ;;; From http://cyberelk.net/tim/docbook/selfdocbook/selfdocbook.dsl.html:
+ ;;; To make URLs line wrap we use the TeX 'url' package.
+ ;;; See also: jadetex.cfg
+ ;; First we need to declare the 'formatting-instruction' flow class.
+ (declare-flow-object-class formatting-instruction
+ "UNREGISTERED::James Clark//Flow Object Class::formatting-instruction")
+ ;; Then redefine ulink to use it.
+ (element ulink
+   (make sequence
+     (if (node-list-empty? (children (current-node)))
+         ; ulink url="...", /ulink
+         (make formatting-instruction
+           data: (string-append "\\url{"
+                                (attribute-string (normalize "url"))
+                                "}"))
+         (if (equal? (attribute-string (normalize "url"))
+                     (data-of (current-node)))
+         ; ulink url="http://...", http://..., /ulink
+             (make formatting-instruction
+ 	      data: (string-append "\\url{"
+ 				   (attribute-string (normalize "url"))
+ 				   "}"))
+         ; ulink url="http://...", some text, /ulink
+             (make sequence
+               ($charseq$)
+               (literal " (")
+               (make formatting-instruction data:
+                     (string-append "\\url{"
+                                    (attribute-string (normalize "url"))
+                                    "}"))
+               (literal ")"))))))
+ ;;; And redefine filename to use it too.
+ (element filename
+   (make formatting-instruction
+     data: (string-append "\\path{" (data-of (current-node)) "}")))
+ 
+ ;; We use ten callouts and only special symbols for nine are permitted.
+ (define %callout-fancy-bug% #f)
+ 
+ </style-specification-body>
+ </style-specification>
+ 
+ <external-specification id="docbook" document="docbook.dsl">
+ 
+ </style-sheet>
Index: template.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/template.xml,v
retrieving revision 1.5
diff -c -p -r1.5 template.xml
*** template.xml	2002/01/30 23:51:45	1.5
--- template.xml	2002/01/31 21:10:45
***************
*** 212,218 ****
        <callout
         arearefs="template_programming-template_use-templated_pair_program-constructor">
         <para>The constructor has two parameters of
!        type&nbsp;<varname>T</varname>.</para>
        </callout>
        <callout
         arearefs="template_programming-template_use-templated_pair_program-members">
--- 212,218 ----
        <callout
         arearefs="template_programming-template_use-templated_pair_program-constructor">
         <para>The constructor has two parameters of
!        type <type>const T&amp;</type>.</para>
        </callout>
        <callout
         arearefs="template_programming-template_use-templated_pair_program-members">
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.10
diff -c -p -r1.10 tutorial.xml
*** tutorial.xml	2002/01/30 23:51:45	1.10
--- tutorial.xml	2002/01/31 21:10:46
***************
*** 436,443 ****
       of the array values that are modified.</para>
      </callout>
      <callout arearefs="tutorial-array_parallel-doof2d-blockAndEvaluate">
!      <para>&pooma; may reorder computation of statements.  Calling
!      <function>Pooma::blockAndEvaluate</function> ensures all
       computation finishes before accessing a particular array
       element.</para>
      </callout>
--- 436,442 ----
       of the array values that are modified.</para>
      </callout>
      <callout arearefs="tutorial-array_parallel-doof2d-blockAndEvaluate">
!      <para>&pooma; may reorder computation.  <function>Pooma::blockAndEvaluate</function> ensures all
       computation finishes before accessing a particular array
       element.</para>
      </callout>
***************
*** 506,521 ****
     </mediaobject>
    </figure>
  
!   <para>Just before accessing individual &array; values, the code
!   contains calls to <function>Pooma::blockAndEvaluate</function>.
!   &pooma; may reorder computation or distribute them among various
!   processors.  Before reading an individual &array; value, calling
!   this function ensures all computations affecting its value have
!   finished, i.e., it has the correct value.  Calling this function is
!   necessary only when accessing individual array elements.  For
!   example, before the data-parallel operation of printing an array,
!   &pooma; will call <function>blockAndEvaluate</function>
!   itself.</para>
   </section>
  
  
--- 505,519 ----
     </mediaobject>
    </figure>
  
!   <para>&pooma; may reorder computation or distribute them among
!   various processors so, before accessing individual values,
!   the code calls <function>Pooma::blockAndEvaluate</function>.  Before
!   reading an individual &array; value, calling this function ensures
!   all computations affecting its value have finished, i.e., it has the
!   correct value.  Calling this function is necessary only when
!   accessing individual array elements.  For example, before the
!   data-parallel operation of printing an array, &pooma; will call
!   <function>blockAndEvaluate</function> itself.</para>
   </section>
  
  
*************** MultiPatch&lt;UniformTag, Remote&lt;Comp
*** 1057,1064 ****
       system-dependent.  For example, the <command>mpirun -np 4
       Doof2d-Field-distributed -mpi 2 10 1000</command> command
       might use &mpi; communication.
!      <command>Doof2d-Field-distributed -shmem -np 4 2 10
!      1000</command> might use the &mm; Shared Memory Library.</para>
      </listitem>
    </itemizedlist>
    </para>
--- 1055,1063 ----
       system-dependent.  For example, the <command>mpirun -np 4
       Doof2d-Field-distributed -mpi 2 10 1000</command> command
       might use &mpi; communication.
! <programlisting>
! Doof2d-Field-distributed -shmem -np 4 2 10 1000
! </programlisting> might use the &mm; Shared Memory Library.</para>
      </listitem>
    </itemizedlist>
    </para>

From oldham at codesourcery.com  Thu Jan 31 21:33:45 2002
From: oldham at codesourcery.com (Jeffrey D . Oldham)
Date: Thu, 31 Jan 2002 13:33:45 -0800
Subject: Manual Patch: Revise Figures
Message-ID: <20020131133345.B29384@vaio.codesourcery.com>

These changes mostly shrink the horizontal extent of some figures to
avoid intruding into the right margin.

2002-Jan-31  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* Makefile: New file moved from 'makefile'.  
	* concepts-101.png: Changed per changes to corresponding mp file.
	* concepts.mp: Use math times fonts.  Reduce horizontal width.
	* data-parallel-212.png: Changed per changes to corresponding mp file.
	* data-parallel.mp: Use math times fonts.  Reduce horizontal width.
	* distributed-101.png: Changed per changes to corresponding mp file.
	* distributed.mp: Use math times fonts.
	* doof2d.mp: Likewise.
	* introduction-101.png: Changed per changes to corresponding mp file.
	* introduction.mp: Use math times fonts.  Reduce horizontal width.
	* macros.ltx: Hack \mapsto since the symbol is broken.
	* makefile: Moved to 'Makefile'.

Applied to	mainline

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: Makefile
===================================================================
RCS file: Makefile
diff -N Makefile
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Makefile	Thu Jan 31 14:23:57 2002
***************
*** 0 ****
--- 1,66 ----
+ ### Oldham, Jeffrey D.
+ ### 2002Jan31
+ ### POOMA
+ ###
+ ### Create POOMA Manual Figures
+ 
+ ## We write our figures using the MetaPost programming language.
+ ## Applying $(MPOST) to the figures produces EPS (Encapsulated
+ ## PostScript) files.  These can be directly included in TeX files to
+ ## produce PostScript.  We use $(EPSTOPNG) to convert EPS to PNG
+ ## (Portable Network Graphics) format.
+ 
+ # Definitions for MetaPost figure creation
+ TEX=		latex
+ MPOST=		mpost
+ # This non-standard tool converts EPS format into PNG format.
+ # The EPS files must have font information in its initial comments.
+ # Set the 'prologue' MetaPost variable to a value >= 2 to ensure this.
+ # Also the pnmtopng command must be available.
+ EPSTOPNG=	/home/oldham/bin/peps
+ 
+ # MetaPost macro definitions used in multiple files.
+ MACRO_SOURCES= box-macros.mp grid-macros.mp
+ # These MetaPost files describe the figures.
+ SOURCES= concepts.mp data-parallel.mp distributed.mp doof2d.mp introduction.mp
+ # MetaPost can produce multiple files per input file.  These multiple
+ # files have names %.[0-9]+.  Since make does not deal well with
+ # producing an indeterminate number of files from the same rule, we
+ # instead produce mproof-%.ps PostScript files which can be used to
+ # proof the EPS files.
+ RESULTS= $(SOURCES:%.mp=mproof-%.ps)
+ # These files must be in the POOMA CVS tree to ensure creation of the
+ # figures.
+ TREE_SOURCES= $(SOURCES) Makefile macros.ltx
+ 
+ # Create all the EPS and PNG files.  The 'mproof-all' target creates
+ # the EPS files.  This should happen before trying to create the PNG
+ # files, but this rule may not guarantee this ordering.
+ all: mproof-all \
+ 	concepts-101.png concepts-111.png data-parallel-101.png \
+ 	data-parallel-212.png distributed-101.png \
+ 	doof2d-201.png doof2d-202.png doof2d-203.png \
+ 	doof2d-210.png doof2d-211.png introduction-101.png
+ 
+ mproof-all: $(RESULTS)
+ 
+ mproof-%.ps:	%.mp macros.ltx
+ 	declare -x TEX=latex && $(MPOST) $< && tex mproof.tex $*.[0-9]* && dvips mproof.dvi -o $@
+ 
+ # Convert from EPS to PNG.
+ # Assumes the existence of $(EPSTOPNG).
+ # There should be a way to generalize these rules to have two
+ #  different '%', but I do not know how to do this.
+ concepts-%.png: concepts.%
+ 	$(EPSTOPNG) -p -o $@ $^
+ data-parallel-%.png: data-parallel.%
+ 	$(EPSTOPNG) -p -o $@ $^
+ distributed-%.png: distributed.%
+ 	$(EPSTOPNG) -p -o $@ $^
+ doof2d-%.png: doof2d.%
+ 	$(EPSTOPNG) -p -o $@ $^
+ introduction-%.png: introduction.%
+ 	$(EPSTOPNG) -p -o $@ $^
+ 
+ clean:
+ 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.mpx mpxerr.tex
Index: concepts-101.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/concepts-101.png,v
retrieving revision 1.1
diff -c -p -r1.1 concepts-101.png
Binary files /tmp/cvs3EgRvE and concepts-101.png differ
Index: concepts.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/concepts.mp,v
retrieving revision 1.4
diff -c -p -r1.4 concepts.mp
*** concepts.mp	2002/01/30 23:40:12	1.4
--- concepts.mp	2002/01/31 21:23:57
*************** verbatimtex
*** 15,20 ****
--- 15,21 ----
  \documentclass[12pt]{article}
  \input{macros.ltx}
  \usepackage{times}
+ \usepackage{mathptm}
  \begin{document}
  etex
  
*************** endfig;
*** 122,128 ****
  beginfig(101)
    numeric unit; unit = 0.8cm;
    numeric vertSpace; vertSpace = 2.6unit;   % vertical space between sections
!   numeric horizSpace; horizSpace = 8unit; % horizontal space between sections
    
    % Create and layout boxes for computational Array and Field implementations.
    numeric interBoxSpace; interBoxSpace = unit; % space between boxes
--- 123,129 ----
  beginfig(101)
    numeric unit; unit = 0.8cm;
    numeric vertSpace; vertSpace = 2.6unit;   % vertical space between sections
!   numeric horizSpace; horizSpace = 2unit; % horizontal space between sections
    
    % Create and layout boxes for computational Array and Field implementations.
    numeric interBoxSpace; interBoxSpace = unit; % space between boxes
*************** beginfig(101)
*** 144,154 ****
    boxit.l1(btex \strut \underline{mathematical concept} etex);
    boxit.l2(btex \strut \underline{computational implementation} etex);
    boxit.l3(btex \strut \type{Array}: etex);
!   boxit.l4(btex \strut $\mbox{index} \mapsto \mbox{value}$ etex);
    boxit.l6(btex \strut \type{Field}: etex);
!   boxit.l7(btex \strut $\mbox{index} \mapsto \mbox{value}$ etex);
    boxit.l9(btex \strut \type{Field}: etex);
!   boxit.l10(btex \strut $\mbox{indices} \mapsto \mbox{spatial value}$ etex);
    fixsize(l1,l2,l3,l4,l6,l7,l9,l10);
    
    ypart(l1.c - l2.c) = 0;
--- 145,158 ----
    boxit.l1(btex \strut \underline{mathematical concept} etex);
    boxit.l2(btex \strut \underline{computational implementation} etex);
    boxit.l3(btex \strut \type{Array}: etex);
! %  boxit.l4(btex \strut $\mbox{index} \mapsto \mbox{value}$ etex);
!   boxit.l4(btex etex);
    boxit.l6(btex \strut \type{Field}: etex);
! %  boxit.l7(btex \strut $\mbox{index} \mapsto \mbox{value}$ etex);
!   boxit.l7(btex etex);
    boxit.l9(btex \strut \type{Field}: etex);
!   boxit.l10(btex etex);
! %  boxit.l10(btex \strut $\mbox{indices} \mapsto \mbox{spatial value}$ etex);
    fixsize(l1,l2,l3,l4,l6,l7,l9,l10);
    
    ypart(l1.c - l2.c) = 0;
Index: data-parallel-212.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/data-parallel-212.png,v
retrieving revision 1.1
diff -c -p -r1.1 data-parallel-212.png
Binary files /tmp/cvsLQoLwD and data-parallel-212.png differ
Index: data-parallel.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/data-parallel.mp,v
retrieving revision 1.2
diff -c -p -r1.2 data-parallel.mp
*** data-parallel.mp	2002/01/30 23:40:12	1.2
--- data-parallel.mp	2002/01/31 21:23:58
*************** verbatimtex
*** 17,22 ****
--- 17,23 ----
  \documentclass[12pt]{article}
  \input{macros.ltx}
  \usepackage{times}
+ \usepackage{mathptm}
  \begin{document}
  etex
  
*************** endfig;
*** 74,80 ****
  
  %% An illustratation of the addition of arrays.
  beginfig(212)
!   numeric unit; unit = 0.9cm;	% width or height of an individual grid cell
    numeric nuCells; nuCells = 5;	% number of cells in each dimension
  				% This number should be odd.
    numeric nuArrayCells; nuArrayCells = 3;
--- 75,81 ----
  
  %% An illustratation of the addition of arrays.
  beginfig(212)
!   numeric unit; unit = 0.7cm;	% width or height of an individual grid cell
    numeric nuCells; nuCells = 5;	% number of cells in each dimension
  				% This number should be odd.
    numeric nuArrayCells; nuArrayCells = 3;
Index: distributed-101.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/distributed-101.png,v
retrieving revision 1.1
diff -c -p -r1.1 distributed-101.png
Binary files /tmp/cvstiHEMC and distributed-101.png differ
Index: distributed.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/distributed.mp,v
retrieving revision 1.3
diff -c -p -r1.3 distributed.mp
*** distributed.mp	2002/01/30 23:40:12	1.3
--- distributed.mp	2002/01/31 21:23:59
*************** verbatimtex
*** 15,20 ****
--- 15,21 ----
  \documentclass[12pt]{article}
  \input{macros.ltx}
  \usepackage{times}
+ \usepackage{mathptm}
  \begin{document}
  etex
  
Index: doof2d.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/doof2d.mp,v
retrieving revision 1.5
diff -c -p -r1.5 doof2d.mp
*** doof2d.mp	2002/01/30 23:40:12	1.5
--- doof2d.mp	2002/01/31 21:24:00
*************** prologues := 2;			% >= 2 for PostScript
*** 12,17 ****
--- 12,18 ----
  verbatimtex
  \documentclass[12pt]{article}
  \usepackage{times}
+ \usepackage{mathptm}
  \input{macros.ltx}
  \begin{document}
  
Index: introduction-101.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/introduction-101.png,v
retrieving revision 1.1
diff -c -p -r1.1 introduction-101.png
Binary files /tmp/cvsG4g2Ad and introduction-101.png differ
Index: introduction.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/introduction.mp,v
retrieving revision 1.4
diff -c -p -r1.4 introduction.mp
*** introduction.mp	2002/01/30 23:40:12	1.4
--- introduction.mp	2002/01/31 21:24:00
*************** input boxes;
*** 13,22 ****
  input box-macros;
  
  verbatimtex
! \documentclass[12pt]{article}
  \usepackage{amsmath}
  \input{macros.ltx}
  \usepackage{times}
  \begin{document}
  etex
  
--- 13,28 ----
  input box-macros;
  
  verbatimtex
! \documentclass[10pt]{article}
  \usepackage{amsmath}
  \input{macros.ltx}
  \usepackage{times}
+ \usepackage{mathptm}
+ %% TMP
+ \renewcommand{\maps}{\ensuremath{\mbox{-}\mbox{}\!>\!}}%
+ 	% Produce a representation for a map.
+ 	% Requires no parameters.
+ 
  \begin{document}
  etex
  
*************** beginfig(101)
*** 25,31 ****
  %% FIXME: Ensure the arrow labels are the same distance above the arrows.
  %% FIXME: Ensure the boxes all have the same height.
  %% FIXME: Ensure the arrowheads do not collide.
!   numeric unit; unit = 0.8cm;
    numeric horizSpace; horizSpace = 8unit;
    numeric vertSpace; vertSpace = unit;
    numeric nuBoxes;		% number of boxes
--- 31,37 ----
  %% FIXME: Ensure the arrow labels are the same distance above the arrows.
  %% FIXME: Ensure the boxes all have the same height.
  %% FIXME: Ensure the arrowheads do not collide.
!   numeric unit; unit = 0.65cm;
    numeric horizSpace; horizSpace = 8unit;
    numeric vertSpace; vertSpace = unit;
    numeric nuBoxes;		% number of boxes
*************** beginfig(101)
*** 36,48 ****
    boxit.b2(btex \textsl{engineering} etex);
    boxit.b3(btex \strut $\real^{\dimension} \maps \text{values}$ etex);
    boxit.b4(btex \strut $\text{discrete space} \maps \text{values}$ etex);
!   boxit.b5(btex \strut $(\text{layout}, \text{engine}) \maps \text{values}$ etex);
    boxit.b6(btex \strut linear algebra etex);
    boxit.b7(btex \strut $\naturalNus^{\dimension} \maps \text{values}$ etex);
    boxit.b8(btex etex);
    nuBoxes = 8;
    boxit.b9(btex \textsl{implementation} etex);
!   sameWidthSameHeight(b3,b4,b5,b6,b7,b8);
    for t = 0 upto nuBoxes+1:
      fixsize(b[t]);
    endfor
--- 42,57 ----
    boxit.b2(btex \textsl{engineering} etex);
    boxit.b3(btex \strut $\real^{\dimension} \maps \text{values}$ etex);
    boxit.b4(btex \strut $\text{discrete space} \maps \text{values}$ etex);
!   boxit.b5(btex \strut $(\text{layout,} \text{engine}) \maps \text{values}$ etex);
    boxit.b6(btex \strut linear algebra etex);
    boxit.b7(btex \strut $\naturalNus^{\dimension} \maps \text{values}$ etex);
    boxit.b8(btex etex);
    nuBoxes = 8;
    boxit.b9(btex \textsl{implementation} etex);
! %%TMP  sameWidthSameHeight(b3,b4,b5,b6,b7,b8);
!   sameWidthSameHeight(b3,b6);
!   sameWidthSameHeight(b4,b7);
!   sameWidthSameHeight(b5,b8);
    for t = 0 upto nuBoxes+1:
      fixsize(b[t]);
    endfor
*************** beginfig(101)
*** 74,81 ****
    drawunboxed(b9);
    
    % Label the boxes.
!   label.top(btex continuous field etex, b3.n);
!   label.top(btex discrete field etex, b4.n);
    label.top(btex \pooma\ container etex, b5.n);
    label.top(btex mathematical array etex, b7.n);
  %  label.top(btex custom implementation etex, b8.n);
--- 83,90 ----
    drawunboxed(b9);
    
    % Label the boxes.
!   label.top(btex continuous \avoidfi eld etex, b3.n);
!   label.top(btex discrete \avoidfi eld etex, b4.n);
    label.top(btex \pooma\ container etex, b5.n);
    label.top(btex mathematical array etex, b7.n);
  %  label.top(btex custom implementation etex, b8.n);
Index: macros.ltx
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/macros.ltx,v
retrieving revision 1.3
diff -c -p -r1.3 macros.ltx
*** macros.ltx	2002/01/30 23:40:12	1.3
--- macros.ltx	2002/01/31 21:24:00
***************
*** 13,19 ****
  \newcommand{\naturalNus}{\ensuremath{\boldsymbol{N}}}%
  	% Produce a representation for discrete space.
  	% Requires no parameters.
! \newcommand{\maps}{\ensuremath{\rightarrow}}%
  	% Produce a representation for a map.
  	% Requires no parameters.
  \newcommand{\real}{\ensuremath{\boldsymbol{R}}}%
--- 13,20 ----
  \newcommand{\naturalNus}{\ensuremath{\boldsymbol{N}}}%
  	% Produce a representation for discrete space.
  	% Requires no parameters.
! \newcommand{\maps}{\ensuremath{\mbox{-}\mbox{}\!>\!}}%
! %% TMP Does not appear for an unknown reason. \newcommand{\maps}{\ensuremath{\mapsto}}%
  	% Produce a representation for a map.
  	% Requires no parameters.
  \newcommand{\real}{\ensuremath{\boldsymbol{R}}}%
Index: makefile
===================================================================
RCS file: makefile
diff -N makefile
*** /tmp/cvsziio0S	Thu Jan 31 14:24:00 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,74 ****
- ### Oldham, Jeffrey D.
- ### 1997 Dec 26
- ### misc
- ###
- ### LaTeX -> PostScript/PDF/WWW
- ### XML -> TeX/DVI/PS/PDF
- 
- # Definitions for PostScript and WWW Creation
- TEX=		latex
- WWWHOMEDIR=	/u/oldham/www
- LATEX2HTML=	latex2html
- BASICLATEX2HTMLOPTIONS=	-info "" -no_footnode -no_math -html_version 3.2,math
- #LATEX2HTMLOPTIONS=	-local_icons -split +1 $(BASICLATEX2HTMLOPTIONS)
- LATEX2HTMLOPTIONS=	-no_navigation -split 0 $(BASICLATEX2HTMLOPTIONS)
- MPOST=		mpost
- 
- # Definitions for Jade.
- JADEDIR=		/usr/lib/sgml/stylesheets/docbook
- PRINTDOCBOOKDSL=	print/docbook.dsl
- HTMLDOCBOOKDSL=		html/docbook.dsl
- XML=			dtds/decls/xml.dcl
- INDEXOPTIONS=		-t 'Index' -i 'index' -g -p
- 
- CXXFLAGS= -g -Wall -pedantic -W -Wstrict-prototypes -Wpointer-arith -Wbad-function-cast -Wcast-align -Wconversion -Wnested-externs -Wundef -Winline -static
- 
- all: manual.ps
- 
- manual.dvi: manual.xml introduction.xml template.xml tutorial.xml \
-             concepts.xml arrays.xml data-parallel.xml glossary.xml \
-             bibliography.xml
- 
- %.all:	%.ps %.pdf %.html
- 	chmod 644 $*.ps $*.pdf
- 	mv $*.ps $*.pdf $*
- 
- %.dvi:	%.ltx
- 	$(TEX) $<
- 	# bibtex $*
- 	# $(TEX) $<
- 	$(TEX) $<
- 
- %.ps:	%.dvi
- 	dvips -t letter $< -o
- 
- %.pdf.ltx:	%.ltx
- 	sed -e 's/^%\\usepackage{times}/\\usepackage{times}/' $< > $@
- 
- %.pdf:	%.pdf.ltx
- 	pdflatex $<
- 	mv $@.pdf $@
- 
- # This rule assumes index creation.
- %.dvi:	%.xml genindex.sgm
- 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) -V html-index $(XML) $< && \
- 	perl collateindex.pl $(INDEXOPTIONS) -o genindex.sgm HTML.index && \
- 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) -V tex-backend $(XML) $< && jadetex $*.tex && jadetex $*.tex && jadetex $*.tex
- 
- genindex.sgm:
- 	perl collateindex.pl $(INDEXOPTIONS) -N -o $@
- 
- %.html:	%.xml
- 	jade -D$(JADEDIR) -t sgml -d $(HTMLDOCBOOKDSL) $(XML) $<
- 
- %.pdf:	%.xml
- 	jade -D$(JADEDIR) -t tex -d $(PRINTDOCBOOKDSL) $(XML) $< && pdfjadetex $*.tex && pdfjadetex $*.tex
- 
- mproof-%.ps:	%.mp
- 	declare -x TEX=latex && $(MPOST) $< && tex mproof.tex $*.[0-9]* && dvips mproof.dvi -o $@
- 
- %.txt:	%.ltx
- 	detex $< > $@
- 
- clean:
- 	rm -f *.dvi *.aux *.log *.toc *.bak *.blg *.bbl *.glo *.idx *.lof *.lot *.htm *.mpx mpxerr.tex HTML.index manual.tex genindex.sgm
--- 0 ----

From oldham at codesourcery.com  Thu Jan 31 22:04:17 2002
From: oldham at codesourcery.com (Jeffrey D . Oldham)
Date: Thu, 31 Jan 2002 14:04:17 -0800
Subject: Manual Patch: Tidy Programs
Message-ID: <20020131140417.A29568@vaio.codesourcery.com>

2002-Jan-31  Jeffrey D. Oldham  <oldham at codesourcery.com>

The changes in this patch
1) Remove duplicates of files.
2) Reformat DocBook output to avoid lines that intrude into the right
margin.
	
	* array-copy-annotated.patch: Remove this file, which should not
	have been present.
	* array-size-annotated.patch: Likewise.
	* dynamicarray-annotated.patch: Likewise.
	* examples/array-copy-annotated.patch: Likewise.
	* examples/array-size-annotated.patch: Likewise.
	* examples/dynamicarray-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Array-distributed-annotated.patch:
	Reformat to avoid long lines.
	* examples/Doof2d/Doof2d-Array-element-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Array-parallel-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Array-stencil-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-C-element-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Field-distributed-annotated.patch: Likewise.
	* examples/Doof2d/Doof2d-Field-parallel-annotated.patch: Likewise.
	* examples/Doof2d/array-copy-annotated.patch: Remove this file,
	which should not have been present.
	* examples/Doof2d/array-size-annotated.patch: Likewise.
	* examples/Doof2d/dynamicarray-annotated.patch: Likewise.
	* examples/Doof2d/initialize-finalize-annotated.patch: Likewise.
	* examples/Doof2d/pairs-templated-annotated.patch: Likewise.
	* examples/Sequential/Doof2d-Array-distributed-annotated.patch: Likewise.
	* examples/Sequential/Doof2d-Array-element-annotated.patch: Likewise.
	* examples/Sequential/Doof2d-Array-parallel-annotated.patch: Likewise.
	* examples/Sequential/Doof2d-Array-stencil-annotated.patch: Likewise.
	* examples/Sequential/Doof2d-C-element-annotated.patch: Likewise.
	* examples/Sequential/Doof2d-Field-distributed-annotated.patch: Likewise.
	* examples/Sequential/Doof2d-Field-parallel-annotated.patch: Likewise.
	* examples/Sequential/array-copy-annotated.patch: Reformat to
	avoid long lines.
	* examples/Sequential/array-size-annotated.patch: Likewise.
	* examples/Sequential/pairs-templated-annotated.patch: Likewise.
	* examples/Sequential/pairs-untemplated-annotated.patch: Likewise.
	* examples/Templates/Doof2d-Array-distributed-annotated.patch:
	Remove this file, which should not have been present.
	* examples/Templates/Doof2d-Array-element-annotated.patch: Likewise.
	* examples/Templates/Doof2d-Array-parallel-annotated.patch: Likewise.
	* examples/Templates/Doof2d-Array-stencil-annotated.patch: Likewise.
	* examples/Templates/Doof2d-C-element-annotated.patch: Likewise.
	* examples/Templates/Doof2d-Field-distributed-annotated.patch: Likewise.
	* examples/Templates/Doof2d-Field-parallel-annotated.patch: Likewise.
	* examples/Templates/array-copy-annotated.patch: Likewise.
	* examples/Templates/array-size-annotated.patch: Likewise.
	* examples/Templates/dynamicarray-annotated.patch: Likewise.
	* examples/Templates/initialize-finalize-annotated.patch: Likewise.
	* examples/Templates/pairs-templated-annotated.patch: Move this
	file to the Sequential directory.

Applied to	mainline.

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: array-copy-annotated.patch
===================================================================
RCS file: array-copy-annotated.patch
diff -N array-copy-annotated.patch
*** /tmp/cvsRJePSY	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,77 ****
- *** array-copy.cpp	Thu Jan 24 11:12:23 2002
- --- array-copy-annotated.cpp	Thu Jan 24 11:12:49 2002
- ***************
- *** 1,8 ****
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include <iostream>
-   
-   // Changes the Array value at index (0,0).
- ! void changeValue(Array<2,int,Brick>& z)
-   { z(0,0) = 6; }
-   
- --- 1,9 ----
- + <programlisting id="array-copy-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include &lt;iostream&gt;
-   
-   // Changes the Array value at index (0,0).
- ! void changeValue(Array&lt;2,int,Brick&gt;&amp; z)
-   { z(0,0) = 6; }
-   
- ***************
- *** 11,17 ****
-     Pooma::initialize(argc,argv);
-   
- !   Array<2,int,Brick> a(3,4, ModelElement<int>(4));
- !   std::cout << "Initial value:\n";
- !   std::cout << "a: " << a(0,0) << std::endl;
-   
-     // Array copies share the same underlying values.
- --- 12,18 ----
-     Pooma::initialize(argc,argv);
-   
- !   Array&lt;2,int,Brick&gt; a(3,4, ModelElement&lt;int&gt;(4));
- !   std::cout &openopen; "Initial value:\n";
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
-   
-     // Array copies share the same underlying values.
- ***************
- *** 19,35 ****
-     // Explicit initialization uses reference semantics so changing the
-     // copy's value at (0,0) also changes the original's value.
- !   Array<2,int,Brick> b(a);
-     b(0,0) = 5;
- !   std::cout << "After explicit initialization.\n";
- !   std::cout << "a: " << a(0,0) << std::endl;
- !   std::cout << "b: " << b(0,0) << std::endl;
-   
-     // Initialization of function arguments also uses reference semantics.
- !   std::cout << "After function call:\n";
-     changeValue(a);
- !   std::cout << "a: " << a(0,0) << std::endl;
- !   std::cout << "b: " << b(0,0) << std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 20,37 ----
-     // Explicit initialization uses reference semantics so changing the
-     // copy's value at (0,0) also changes the original's value.
- !   Array&lt;2,int,Brick&gt; b(a);
-     b(0,0) = 5;
- !   std::cout &openopen; "After explicit initialization.\n";
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
- !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
-   
-     // Initialization of function arguments also uses reference semantics.
- !   std::cout &openopen; "After function call:\n";
-     changeValue(a);
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
- !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: array-size-annotated.patch
===================================================================
RCS file: array-size-annotated.patch
diff -N array-size-annotated.patch
*** /tmp/cvsaVwiqN	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,67 ****
- *** array-size.cpp	Tue Jan 15 12:59:40 2002
- --- array-size-annotated.cpp	Tue Jan 15 13:30:07 2002
- ***************
- *** 1,5 ****
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include <iostream>
-   
-   // Print an Array's Size
- --- 1,6 ----
- + <programlisting id="array-size-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include &lt;iostream&gt;
-   
-   // Print an Array's Size
- ***************
- *** 10,22 ****
-   // member functions.
-   
- ! template <int Dim, typename Type, typename EngineTag>
-   inline
- ! long computeArraySize(const Array<Dim,Type,EngineTag>& a)
-   {
- !   const Loc<Dim> fs = a.firsts();
- !   const Loc<Dim> ls = a.lasts();
- !   const Loc<Dim> lens = a.lengths();
-     long size = 1;
- !   for (int d = 0; d < Dim; ++d) {
-       size *= (ls[d] - fs[d] + 1).first();
-       // Check that lengths() and our computed lengths agree.
- --- 11,23 ----
-   // member functions.
-   
- ! template &lt;int Dim, typename Type, typename EngineTag&gt;
-   inline
- ! long computeArraySize(const Array&lt;Dim,Type,EngineTag&gt;&amp; a)
-   {
- !   const Loc&lt;Dim&gt; fs = a.firsts();
- !   const Loc&lt;Dim&gt; ls = a.lasts();
- !   const Loc&lt;Dim&gt; lens = a.lengths();
-     long size = 1;
- !   for (int d = 0; d &lt; Dim; ++d) {
-       size *= (ls[d] - fs[d] + 1).first();
-       // Check that lengths() and our computed lengths agree.
- ***************
- *** 30,38 ****
-     Pooma::initialize(argc,argv);
-   
- !   Array<3,int,Brick> a(3,4,5, ModelElement<int>(4));
-     PAssert(computeArraySize(a) == a.size());
- !   std::cout << "The array's size is " << a.size() << ".\n";
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 31,40 ----
-     Pooma::initialize(argc,argv);
-   
- !   Array&lt;3,int,Brick&gt; a(3,4,5, ModelElement&lt;int&gt;(4));
-     PAssert(computeArraySize(a) == a.size());
- !   std::cout &openopen; "The array's size is " &openopen; a.size() &openopen; ".\n";
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: dynamicarray-annotated.patch
===================================================================
RCS file: dynamicarray-annotated.patch
diff -N dynamicarray-annotated.patch
*** /tmp/cvsrLmG7D	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,80 ****
- *** dynamicarray.cpp	Mon Jan 21 17:29:38 2002
- --- dynamicarray-annotated.cpp	Tue Jan 22 07:06:15 2002
- ***************
- *** 1,5 ****
-   #include "Pooma/Pooma.h"
- ! #include "Pooma/DynamicArrays.h"
- ! #include <iostream>
-   
-   // Demonstrate using DynamicArrays.
- --- 1,6 ----
- + <programlisting id="dynamicarray-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
- ! #include "Pooma/DynamicArrays.h"  <co id="arrays-dynamic_arrays-example-header"></co>
- ! #include &lt;iostream&gt;
-   
-   // Demonstrate using DynamicArrays.
- ***************
- *** 9,38 ****
-     Pooma::initialize(argc,argv);
-   
- !   // Create a DynamicArray with one element.
- !   DynamicArray<> d0(1);
- !   DynamicArray<double> d01(1);
- !   DynamicArray<double, Dynamic> d02(1);
-   
- !   // Add five more elements.
-     d0.create(5);
-     // Store values in the array.
- !   for (int i = d0.domain().first(); i <= d0.domain().last(); ++i)
- !     d0(i) = i;
-   
- !   // Delete every other element.
- !   d0.destroy(Range<1>(d0.domain().first(),d0.domain().last(),2), BackFill());
-   
-     // Print the resulting array.
- !   std::cout << d0 << std::endl;
-   
-     // Use the iterator form of 'destroy.'
- !   DynamicArray<> d1(6);
-     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
-       d1(i) = i;
- !   int killList[] = { 0, 2, 4 };
-     d1.destroy(killList, killList+3);
- !   std::cout << d1 << std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 10,40 ----
-     Pooma::initialize(argc,argv);
-   
- !   // Create a DynamicArray with one element.  <co id="arrays-dynamic_arrays-example-identical_declarations"></co>
- !   DynamicArray&lt;&gt; d0(1);
- !   DynamicArray&lt;double&gt; d01(1);
- !   DynamicArray&lt;double, Dynamic&gt; d02(1);
-   
- !   // Add five more elements.  <co id="arrays-dynamic_arrays-example-extension"></co>
-     d0.create(5);
-     // Store values in the array.
- !   for (int i = d0.domain().first(); i &lt;= d0.domain().last(); ++i)
- !     d0(i) = i;  <co id="arrays-dynamic_arrays-example-access"></co>
-   
- !   // Delete every other element.  <co id="arrays-dynamic_arrays-example-destroy_range"></co>
- !   d0.destroy(Range&lt;1&gt;(d0.domain().first(),d0.domain().last(),2), BackFill());
-   
-     // Print the resulting array.
- !   std::cout &openopen; d0 &openopen; std::endl;
-   
-     // Use the iterator form of 'destroy.'
- !   DynamicArray<&gt; d1(6);
-     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
-       d1(i) = i;
- !   int killList[] = { 0, 2, 4 };  <co id="arrays-dynamic_arrays-example-destroy_iterators"></co>
-     d1.destroy(killList, killList+3);
- !   std::cout &openopen; d1 &openopen; std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/array-copy-annotated.patch
===================================================================
RCS file: array-copy-annotated.patch
diff -N array-copy-annotated.patch
*** /tmp/cvsaoaUyu	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,77 ****
- *** array-copy.cpp	Thu Jan 24 11:12:23 2002
- --- array-copy-annotated.cpp	Thu Jan 24 11:12:49 2002
- ***************
- *** 1,8 ****
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include <iostream>
-   
-   // Changes the Array value at index (0,0).
- ! void changeValue(Array<2,int,Brick>& z)
-   { z(0,0) = 6; }
-   
- --- 1,9 ----
- + <programlisting id="array-copy-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include &lt;iostream&gt;
-   
-   // Changes the Array value at index (0,0).
- ! void changeValue(Array&lt;2,int,Brick&gt;&amp; z)
-   { z(0,0) = 6; }
-   
- ***************
- *** 11,17 ****
-     Pooma::initialize(argc,argv);
-   
- !   Array<2,int,Brick> a(3,4, ModelElement<int>(4));
- !   std::cout << "Initial value:\n";
- !   std::cout << "a: " << a(0,0) << std::endl;
-   
-     // Array copies share the same underlying values.
- --- 12,18 ----
-     Pooma::initialize(argc,argv);
-   
- !   Array&lt;2,int,Brick&gt; a(3,4, ModelElement&lt;int&gt;(4));
- !   std::cout &openopen; "Initial value:\n";
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
-   
-     // Array copies share the same underlying values.
- ***************
- *** 19,35 ****
-     // Explicit initialization uses reference semantics so changing the
-     // copy's value at (0,0) also changes the original's value.
- !   Array<2,int,Brick> b(a);
-     b(0,0) = 5;
- !   std::cout << "After explicit initialization.\n";
- !   std::cout << "a: " << a(0,0) << std::endl;
- !   std::cout << "b: " << b(0,0) << std::endl;
-   
-     // Initialization of function arguments also uses reference semantics.
- !   std::cout << "After function call:\n";
-     changeValue(a);
- !   std::cout << "a: " << a(0,0) << std::endl;
- !   std::cout << "b: " << b(0,0) << std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 20,37 ----
-     // Explicit initialization uses reference semantics so changing the
-     // copy's value at (0,0) also changes the original's value.
- !   Array&lt;2,int,Brick&gt; b(a);
-     b(0,0) = 5;
- !   std::cout &openopen; "After explicit initialization.\n";
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
- !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
-   
-     // Initialization of function arguments also uses reference semantics.
- !   std::cout &openopen; "After function call:\n";
-     changeValue(a);
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
- !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/array-size-annotated.patch
===================================================================
RCS file: array-size-annotated.patch
diff -N array-size-annotated.patch
*** /tmp/cvsh5HZIk	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,67 ****
- *** array-size.cpp	Tue Jan 15 12:59:40 2002
- --- array-size-annotated.cpp	Tue Jan 15 13:30:07 2002
- ***************
- *** 1,5 ****
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include <iostream>
-   
-   // Print an Array's Size
- --- 1,6 ----
- + <programlisting id="array-size-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include &lt;iostream&gt;
-   
-   // Print an Array's Size
- ***************
- *** 10,22 ****
-   // member functions.
-   
- ! template <int Dim, typename Type, typename EngineTag>
-   inline
- ! long computeArraySize(const Array<Dim,Type,EngineTag>& a)
-   {
- !   const Loc<Dim> fs = a.firsts();
- !   const Loc<Dim> ls = a.lasts();
- !   const Loc<Dim> lens = a.lengths();
-     long size = 1;
- !   for (int d = 0; d < Dim; ++d) {
-       size *= (ls[d] - fs[d] + 1).first();
-       // Check that lengths() and our computed lengths agree.
- --- 11,23 ----
-   // member functions.
-   
- ! template &lt;int Dim, typename Type, typename EngineTag&gt;
-   inline
- ! long computeArraySize(const Array&lt;Dim,Type,EngineTag&gt;&amp; a)
-   {
- !   const Loc&lt;Dim&gt; fs = a.firsts();
- !   const Loc&lt;Dim&gt; ls = a.lasts();
- !   const Loc&lt;Dim&gt; lens = a.lengths();
-     long size = 1;
- !   for (int d = 0; d &lt; Dim; ++d) {
-       size *= (ls[d] - fs[d] + 1).first();
-       // Check that lengths() and our computed lengths agree.
- ***************
- *** 30,38 ****
-     Pooma::initialize(argc,argv);
-   
- !   Array<3,int,Brick> a(3,4,5, ModelElement<int>(4));
-     PAssert(computeArraySize(a) == a.size());
- !   std::cout << "The array's size is " << a.size() << ".\n";
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 31,40 ----
-     Pooma::initialize(argc,argv);
-   
- !   Array&lt;3,int,Brick&gt; a(3,4,5, ModelElement&lt;int&gt;(4));
-     PAssert(computeArraySize(a) == a.size());
- !   std::cout &openopen; "The array's size is " &openopen; a.size() &openopen; ".\n";
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/dynamicarray-annotated.patch
===================================================================
RCS file: dynamicarray-annotated.patch
diff -N dynamicarray-annotated.patch
*** /tmp/cvsilZAQa	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,80 ****
- *** dynamicarray.cpp	Mon Jan 21 17:29:38 2002
- --- dynamicarray-annotated.cpp	Tue Jan 22 07:06:15 2002
- ***************
- *** 1,5 ****
-   #include "Pooma/Pooma.h"
- ! #include "Pooma/DynamicArrays.h"
- ! #include <iostream>
-   
-   // Demonstrate using DynamicArrays.
- --- 1,6 ----
- + <programlisting id="dynamicarray-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
- ! #include "Pooma/DynamicArrays.h"  <co id="arrays-dynamic_arrays-example-header"></co>
- ! #include &lt;iostream&gt;
-   
-   // Demonstrate using DynamicArrays.
- ***************
- *** 9,38 ****
-     Pooma::initialize(argc,argv);
-   
- !   // Create a DynamicArray with one element.
- !   DynamicArray<> d0(1);
- !   DynamicArray<double> d01(1);
- !   DynamicArray<double, Dynamic> d02(1);
-   
- !   // Add five more elements.
-     d0.create(5);
-     // Store values in the array.
- !   for (int i = d0.domain().first(); i <= d0.domain().last(); ++i)
- !     d0(i) = i;
-   
- !   // Delete every other element.
- !   d0.destroy(Range<1>(d0.domain().first(),d0.domain().last(),2), BackFill());
-   
-     // Print the resulting array.
- !   std::cout << d0 << std::endl;
-   
-     // Use the iterator form of 'destroy.'
- !   DynamicArray<> d1(6);
-     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
-       d1(i) = i;
- !   int killList[] = { 0, 2, 4 };
-     d1.destroy(killList, killList+3);
- !   std::cout << d1 << std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 10,40 ----
-     Pooma::initialize(argc,argv);
-   
- !   // Create a DynamicArray with one element.  <co id="arrays-dynamic_arrays-example-identical_declarations"></co>
- !   DynamicArray&lt;&gt; d0(1);
- !   DynamicArray&lt;double&gt; d01(1);
- !   DynamicArray&lt;double, Dynamic&gt; d02(1);
-   
- !   // Add five more elements.  <co id="arrays-dynamic_arrays-example-extension"></co>
-     d0.create(5);
-     // Store values in the array.
- !   for (int i = d0.domain().first(); i &lt;= d0.domain().last(); ++i)
- !     d0(i) = i;  <co id="arrays-dynamic_arrays-example-access"></co>
-   
- !   // Delete every other element.  <co id="arrays-dynamic_arrays-example-destroy_range"></co>
- !   d0.destroy(Range&lt;1&gt;(d0.domain().first(),d0.domain().last(),2), BackFill());
-   
-     // Print the resulting array.
- !   std::cout &openopen; d0 &openopen; std::endl;
-   
-     // Use the iterator form of 'destroy.'
- !   DynamicArray<&gt; d1(6);
-     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
-       d1(i) = i;
- !   int killList[] = { 0, 2, 4 };  <co id="arrays-dynamic_arrays-example-destroy_iterators"></co>
-     d1.destroy(killList, killList+3);
- !   std::cout &openopen; d1 &openopen; std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d/Doof2d-Array-distributed-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Attic/Doof2d-Array-distributed-annotated.patch,v
retrieving revision 1.7
diff -c -p -r1.7 Doof2d-Array-distributed-annotated.patch
*** examples/Doof2d/Doof2d-Array-distributed-annotated.patch	2002/01/25 03:27:30	1.7
--- examples/Doof2d/Doof2d-Array-distributed-annotated.patch	2002/01/31 21:52:13
***************
*** 1,57 ****
! *** Doof2d-Array-distributed.cpp	Wed Dec  5 14:04:36 2001
! --- Doof2d-Array-distributed-annotated.cpp	Wed Dec  5 14:07:56 2001
  ***************
! *** 1,3 ****
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
! --- 1,5 ----
  ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
  ***************
! *** 14,18 ****
!     // (i,j).  The "C" template parameter permits use of this stencil
      // operator with both Arrays and Fields.
  !   template <class C>
      inline
      typename C::Element_t
! --- 16,20 ----
!     // (i,j).  The "C" template parameter permits use of this stencil
      // operator with both Arrays and Fields.
  !   template &lt;class C&gt;
      inline
      typename C::Element_t
  ***************
! *** 42,46 ****
!     // canot use standard input and output.  Instead we use command-line
!     // arguments, which are replicated, for input, and we use an Inform
! !   // stream for output.
!     Inform output;
    
! --- 44,48 ----
!     // canot use standard input and output.  Instead we use command-line
!     // arguments, which are replicated, for input, and we use an Inform
! !   // stream for output.  <co id="tutorial-array_distributed-doof2d-io"></co>
      Inform output;
    
! ***************
! *** 48,52 ****
      if (argc != 4) {
        // Incorrect number of command-line arguments.
  !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
        return EXIT_FAILURE;
      }
! --- 50,54 ----
      if (argc != 4) {
        // Incorrect number of command-line arguments.
! !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
        return EXIT_FAILURE;
      }
  ***************
! *** 55,63 ****
      // Determine the number of processors.
      long nuProcessors;
  !   nuProcessors = strtol(argv[1], &tail, 0);
--- 1,99 ----
! *** Doof2d-Array-distributed.cpp	Mon Jan 28 20:35:07 2002
! --- Doof2d-Array-distributed-annotated.cpp	Thu Jan 31 09:12:19 2002
  ***************
! *** 1,6 ****
  ! #include <stdlib.h>		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
! ! // Doof2d: POOMA Arrays, stencil, multiple processor implementation
!   
!   // Define the stencil class performing the computation.
! --- 1,10 ----
  ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"
! !     // has POOMA's Array declarations
!   
! ! // Doof2d: POOMA Arrays, stencil, multiple
! ! // processor implementation
    
+   // Define the stencil class performing the computation.
  ***************
! *** 11,26 ****
!     DoofNinePt() : weight(1.0/9.0) {}
!   
! !   // This stencil operator is applied to each interior domain position
! !   // (i,j).  The "C" template parameter permits use of this stencil
      // operator with both Arrays and Fields.
  !   template <class C>
      inline
      typename C::Element_t
! !   operator()(const C& x, int i, int j) const
! !   {
! !     return ( weight *
! !              ( x.read(i+1,j+1) + x.read(i+1,j  ) + x.read(i+1,j-1) +
! !                x.read(i  ,j+1) + x.read(i  ,j  ) + x.read(i  ,j-1) +
! !                x.read(i-1,j+1) + x.read(i-1,j  ) + x.read(i-1,j-1) ) );
!     }
!   
! --- 15,31 ----
!     DoofNinePt() : weight(1.0/9.0) {}
!   
! !   // This stencil operator is applied to each interior
! !   // domain position (i,j).  The "C" template
! !   // parameter permits use of this stencil
      // operator with both Arrays and Fields.
  !   template &lt;class C&gt;
      inline
      typename C::Element_t
+ !   operator()(const C& x, int i, int j) const {
+ !     return
+ !       weight *
+ !       (x.read(i+1,j+1)+x.read(i+1,j)+x.read(i+1,j-1) +
+ !        x.read(i  ,j+1)+x.read(i  ,j)+x.read(i  ,j-1) +
+ !        x.read(i-1,j+1)+x.read(i-1,j)+x.read(i-1,j-1));
+     }
+   
  ***************
! *** 39,52 ****
!     Pooma::initialize(argc,argv);
    
! !   // Since multiple copies of this program may simultaneously run, we
! !   // cannot use standard input and output.  Instead we use command-line
! !   // arguments, which are replicated, for input, and we use an Inform
! !   // stream for output.
      Inform output;
    
! !   // Read the program input from the command-line arguments.
      if (argc != 4) {
        // Incorrect number of command-line arguments.
  !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
        return EXIT_FAILURE;
      }
! --- 44,63 ----
!     Pooma::initialize(argc,argv);
!   
! !   // Since multiple copies of this program may simul-
! !   // taneously run, we cannot use standard input and
! !   // output.  Instead we use command-line arguments,
! !   // which are replicated, for input, and we use an
! !   // Inform stream for output.  <co id="tutorial-array_distributed-doof2d-io"></co>
!     Inform output;
!   
! !   // Read the program input from the command-line
! !   // arguments.
      if (argc != 4) {
        // Incorrect number of command-line arguments.
! !     output &openopen;
! !       argv[0] &openopen;
! !       ": number-of-processors number-of-averagings"
! !       &openopen; " number-of-values"
! !       &openopen; std::endl;
        return EXIT_FAILURE;
      }
  ***************
! *** 55,112 ****
      // Determine the number of processors.
      long nuProcessors;
  !   nuProcessors = strtol(argv[1], &tail, 0);
***************
*** 59,149 ****
      // Determine the number of averagings.
      long nuAveragings, nuIterations;
  !   nuAveragings = strtol(argv[2], &tail, 0);
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
!   
! --- 57,65 ----
!     // Determine the number of processors.
!     long nuProcessors;
! !   nuProcessors = strtol(argv[1], &amp;tail, 0);
!   
!     // Determine the number of averagings.
!     long nuAveragings, nuIterations;
! !   nuAveragings = strtol(argv[2], &amp;tail, 0);
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! ***************
! *** 65,69 ****
!     // the grid.
      long n;
  !   n = strtol(argv[3], &tail, 0);
!     // The dimension must be a multiple of the number of processors
!     // since we are using a UniformGridLayout.
! --- 67,71 ----
!     // the grid.
!     long n;
! !   n = strtol(argv[3], &amp;tail, 0);
!     // The dimension must be a multiple of the number of processors
!     // since we are using a UniformGridLayout.
! ***************
! *** 71,80 ****
    
      // Specify the arrays' domains [0,n) x [0,n).
  !   Interval<1> N(0, n-1);
  !   Interval<2> vertDomain(N, N);
    
!     // Set up interior domains [1,n-1) x [1,n-1) for computation.
  !   Interval<1> I(1,n-2);
  !   Interval<2> interiorDomain(I,I);
    
-     // Create the distributed arrays.
- --- 73,82 ----
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
      // Create the distributed arrays.
! ***************
! *** 83,98 ****
!     // dimension.  Guard layers optimize communication between patches.
!     // Internal guards surround each patch.  External guards surround
  !   // the entire array domain.
  !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
  ! 				    GuardLayers<2>(1),  // internal
  ! 				    GuardLayers<2>(0)); // external
  !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
!   
!     // The Array template parameters indicate 2 dimensions and a 'double'
!     // value type.  MultiPatch indicates multiple computation patches,
!     // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.
  !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
  !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > b(layout);
    
-     // Set up the initial conditions.
- --- 85,100 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.  <co id="tutorial-array_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // The Array template parameters indicate 2 dimensions and a 'double'
-     // value type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; b(layout);
-   
      // Set up the initial conditions.
! ***************
! *** 104,112 ****
    
      // Create the stencil performing the computation.
  !   Stencil<DoofNinePt> stencil;
--- 101,148 ----
      // Determine the number of averagings.
      long nuAveragings, nuIterations;
  !   nuAveragings = strtol(argv[2], &tail, 0);
! !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! !   // Ask the user for the number n of values along one dimension of
! !   // the grid.
      long n;
  !   n = strtol(argv[3], &tail, 0);
! !   // The dimension must be a multiple of the number of processors
! !   // since we are using a UniformGridLayout.
! !   n = ((n+nuProcessors-1) / nuProcessors) * nuProcessors;
    
      // Specify the arrays' domains [0,n) x [0,n).
  !   Interval<1> N(0, n-1);
  !   Interval<2> vertDomain(N, N);
    
! !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
  !   Interval<1> I(1,n-2);
  !   Interval<2> interiorDomain(I,I);
    
      // Create the distributed arrays.
! !   // Partition the arrays' domains uniformly, i.e., each patch has the
! !   // same size.  The first parameter tells how many patches for each
! !   // dimension.  Guard layers optimize communication between patches.
! !   // Internal guards surround each patch.  External guards surround
  !   // the entire array domain.
  !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
  ! 				    GuardLayers<2>(1),  // internal
  ! 				    GuardLayers<2>(0)); // external
  !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
! ! 
! !   // The Array template parameters indicate 2 dimensions and a 'double'
! !   // value type.  MultiPatch indicates multiple computation patches,
! !   // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.
  !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
  !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > b(layout);
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the central value.
!     a = b = 0.0;
! !   // Ensure all data-parallel computation finishes before accessing a value.
!     Pooma::blockAndEvaluate();
!     b(n/2,n/2) = 1000.0;
    
      // Create the stencil performing the computation.
  !   Stencil<DoofNinePt> stencil;
***************
*** 152,160 ****
  !   for (int k = 0; k < nuIterations; ++k) {
  !     // Read from b.  Write to a.
        a(interiorDomain) = stencil(b, interiorDomain);
    
! --- 106,114 ----
    
      // Create the stencil performing the computation.
  !   Stencil&lt;DoofNinePt&gt; stencil;
    
--- 151,222 ----
  !   for (int k = 0; k < nuIterations; ++k) {
  !     // Read from b.  Write to a.
        a(interiorDomain) = stencil(b, interiorDomain);
+   
+ --- 66,137 ----
+     // Determine the number of processors.
+     long nuProcessors;
+ !   nuProcessors = strtol(argv[1], &amp;tail, 0);
+   
+     // Determine the number of averagings.
+     long nuAveragings, nuIterations;
+ !   nuAveragings = strtol(argv[2], &amp;tail, 0);
+ !   nuIterations = (nuAveragings+1)/2;
+ !     // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along 
+ !   // one dimension of the grid.
+     long n;
+ !   n = strtol(argv[3], &amp;tail, 0);
+ !   // The dimension must be a multiple of the number 
+ !   // of processors since we are using a
+ !   // UniformGridLayout.
+ !   n=((n+nuProcessors-1)/nuProcessors)*nuProcessors;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
    
! !   // Set up interior domains [1,n-1) x [1,n-1)
! !   // for computation.
! !   Interval&lt;1&gt; I(1,n-2);
! !   Interval&lt;2&gt; interiorDomain(I,I);
!   
!     // Create the distributed arrays.
! ! 
! !   // Partition the arrays' domains uniformly, i.e.,
! !   // each patch has the same size.  The first para-
! !   // meter tells how many patches for each dimension.
! !   // Guard layers optimize communication between
! !   // patches.  Internal guards surround each patch.
! !   // External guards surround the entire array
! !   // domain.  <co id="tutorial-array_distributed-doof2d-layout"></co>
! !   UniformGridPartition&lt;2&gt; 
! !     partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
! ! 	     GuardLayers&lt;2&gt;(1),  // internal
! ! 	     GuardLayers&lt;2&gt;(0)); // external
! !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition,
! ! 				    DistributedTag());
! ! 
! !   // The Array template parameters indicate 2 dims
! !   // and a 'double' value type. MultiPatch indicates
! !   // multiple computation patches, i.e, distributed
! !   // computation.  The UniformTag indicates the
! !   // patches should have the same size.  Each patch
! !   // has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
! !   Array&lt;2, double, MultiPatch&lt;UniformTag,
! ! 	   Remote&lt;Brick&gt; &gt; &gt; a(layout);
! !   Array&lt;2, double, MultiPatch&lt;UniformTag,
! !            Remote&lt;Brick&gt; &gt; &gt; b(layout);
    
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the
+ !   // central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes
+ !   // before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+   
      // Create the stencil performing the computation.
  !   Stencil&lt;DoofNinePt&gt; stencil;
    
***************
*** 164,184 ****
        a(interiorDomain) = stencil(b, interiorDomain);
    
  ***************
! *** 117,121 ****
      // Print out the final central value.
!     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The arrays are automatically deallocated.
! --- 119,123 ----
      // Print out the final central value.
!     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
! !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
    
      // The arrays are automatically deallocated.
  ***************
  *** 125,126 ****
! --- 127,129 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
--- 226,251 ----
        a(interiorDomain) = stencil(b, interiorDomain);
    
  ***************
! *** 116,121 ****
!   
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The arrays are automatically deallocated.
! --- 141,149 ----
!   
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();
! !     // Ensure all computation has finished.
! !   output &openopen;
! !     (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
! !     &openopen; std::endl;
    
      // The arrays are automatically deallocated.
  ***************
  *** 125,126 ****
! --- 153,155 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
Index: examples/Doof2d/Doof2d-Array-element-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Attic/Doof2d-Array-element-annotated.patch,v
retrieving revision 1.7
diff -c -p -r1.7 Doof2d-Array-element-annotated.patch
*** examples/Doof2d/Doof2d-Array-element-annotated.patch	2002/01/25 03:27:30	1.7
--- examples/Doof2d/Doof2d-Array-element-annotated.patch	2002/01/31 21:52:13
***************
*** 1,5 ****
! *** Doof2d-Array-element.cpp	Tue Dec  4 12:02:10 2001
! --- Doof2d-Array-element-annotated.cpp	Wed Jan 23 16:35:29 2002
  ***************
  *** 1,5 ****
  ! #include <iostream>		// has std::cout, ...
--- 1,5 ----
! *** Doof2d-Array-element.cpp	Wed Jan 23 19:18:17 2002
! --- Doof2d-Array-element-annotated.cpp	Thu Jan 31 08:55:57 2002
  ***************
  *** 1,5 ****
  ! #include <iostream>		// has std::cout, ...
***************
*** 7,21 ****
  ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
    // Doof2d: POOMA Arrays, element-wise implementation
! --- 1,6 ----
  ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations  <co id="tutorial-array_elementwise-doof2d-header"></co>
    
    // Doof2d: POOMA Arrays, element-wise implementation
  ***************
! *** 7,17 ****
    int main(int argc, char *argv[])
    {
  !   // Prepare the POOMA library for execution.
--- 7,22 ----
  ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
    // Doof2d: POOMA Arrays, element-wise implementation
! --- 1,7 ----
  ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"
! !     // has POOMA's Array declarations  <co id="tutorial-array_elementwise-doof2d-header"></co>
    
    // Doof2d: POOMA Arrays, element-wise implementation
  ***************
! *** 7,37 ****
    int main(int argc, char *argv[])
    {
  !   // Prepare the POOMA library for execution.
***************
*** 25,47 ****
      long nuAveragings, nuIterations;
  !   std::cout << "Please enter the number of averagings: ";
  !   std::cin >> nuAveragings;
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! --- 8,18 ----
!   int main(int argc, char *argv[])
!   {
! !   // Prepare the POOMA library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
!     Pooma::initialize(argc,argv);
!     
!     // Ask the user for the number of averagings.
!     long nuAveragings, nuIterations;
! !   std::cout &openopen; "Please enter the number of averagings: ";
! !   std::cin &closeclose; nuAveragings;
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
!   
! ***************
! *** 19,37 ****
!     // the grid.
      long n;
  !   std::cout << "Please enter the array size: ";
  !   std::cin >> n;
--- 26,35 ----
      long nuAveragings, nuIterations;
  !   std::cout << "Please enter the number of averagings: ";
  !   std::cin >> nuAveragings;
! !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! !   // Ask the user for the number n of values along one dimension of
! !   // the grid.
      long n;
  !   std::cout << "Please enter the array size: ";
  !   std::cin >> n;
***************
*** 49,57 ****
  !   // Specify the arrays' domains [0,n) x [0,n).
  !   Interval<1> N(0, n-1);
  !   Interval<2> vertDomain(N, N);
!   
  !   // Create the arrays.
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
--- 37,45 ----
  !   // Specify the arrays' domains [0,n) x [0,n).
  !   Interval<1> N(0, n-1);
  !   Interval<2> vertDomain(N, N);
! ! 
  !   // Create the arrays.
! !   // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
***************
*** 60,67 ****
  !   // All grid values should be zero except for the central value.
      for (int j = 1; j < n-1; j++)
        for (int i = 1; i < n-1; i++)
! --- 20,38 ----
!     // the grid.
      long n;
  !   std::cout &openopen; "Please enter the array size: ";
  !   std::cin &closeclose; n;
--- 48,68 ----
  !   // All grid values should be zero except for the central value.
      for (int j = 1; j < n-1; j++)
        for (int i = 1; i < n-1; i++)
! --- 9,42 ----
!   int main(int argc, char *argv[])
!   {
! !   // Prepare the POOMA library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
!     Pooma::initialize(argc,argv);
!     
!     // Ask the user for the number of averagings.
!     long nuAveragings, nuIterations;
! !   std::cout &openopen; "Please enter the number of averagings: ";
! !   std::cin &closeclose; nuAveragings;
! !   nuIterations = (nuAveragings+1)/2;
! !     // Each iteration performs two averagings.
!   
! !   // Ask the user for the number n of values along
! !   // one dimension of the grid.
      long n;
  !   std::cout &openopen; "Please enter the array size: ";
  !   std::cin &closeclose; n;
***************
*** 69,83 ****
  !   // Specify the arrays' domains [0,n) x [0,n).  <co id="tutorial-array_elementwise-doof2d-domain"></co>
  !   Interval&lt;1&gt; N(0, n-1);
  !   Interval&lt;2&gt; vertDomain(N, N);
!   
  !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the central value.  <co id="tutorial-array_elementwise-doof2d-initialization"></co>
      for (int j = 1; j < n-1; j++)
        for (int i = 1; i < n-1; i++)
  ***************
--- 70,86 ----
  !   // Specify the arrays' domains [0,n) x [0,n).  <co id="tutorial-array_elementwise-doof2d-domain"></co>
  !   Interval&lt;1&gt; N(0, n-1);
  !   Interval&lt;2&gt; vertDomain(N, N);
! ! 
  !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
! !   // The Array template parameters indicate
! !   // 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the
! !   // central value.  <co id="tutorial-array_elementwise-doof2d-initialization"></co>
      for (int j = 1; j < n-1; j++)
        for (int i = 1; i < n-1; i++)
  ***************
***************
*** 91,97 ****
  !         a(i,j) = weight *
              (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
               b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
! --- 44,52 ----
    
      // Perform the simulation.
  !   for (int k = 0; k &lt; nuIterations; ++k) {
--- 94,100 ----
  !         a(i,j) = weight *
              (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
               b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
! --- 48,56 ----
    
      // Perform the simulation.
  !   for (int k = 0; k &lt; nuIterations; ++k) {
***************
*** 109,115 ****
  !       for (int i = 1; i < n-1; i++)
            b(i,j) = weight *
              (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
! --- 54,59 ----
    
        // Read from a.  Write to b.
  !     for (int j = 1; j &lt; n-1; j++)
--- 112,118 ----
  !       for (int i = 1; i < n-1; i++)
            b(i,j) = weight *
              (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
! --- 58,63 ----
    
        // Read from a.  Write to b.
  !     for (int j = 1; j &lt; n-1; j++)
***************
*** 128,142 ****
      Pooma::finalize();
      return EXIT_SUCCESS;
    }
! --- 63,74 ----
    
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
! !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
    
  !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
    
! !   // Tell the POOMA library execution has finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
      Pooma::finalize();
      return EXIT_SUCCESS;
    }
--- 131,148 ----
      Pooma::finalize();
      return EXIT_SUCCESS;
    }
! --- 67,81 ----
    
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();
! !     // Ensure all computation has finished.
! !   std::cout &openopen;
! !      (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
! !      &openopen; std::endl;
    
  !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
    
! !   // Tell the POOMA library execution finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
      Pooma::finalize();
      return EXIT_SUCCESS;
    }
Index: examples/Doof2d/Doof2d-Array-parallel-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Attic/Doof2d-Array-parallel-annotated.patch,v
retrieving revision 1.7
diff -c -p -r1.7 Doof2d-Array-parallel-annotated.patch
*** examples/Doof2d/Doof2d-Array-parallel-annotated.patch	2002/01/25 03:27:30	1.7
--- examples/Doof2d/Doof2d-Array-parallel-annotated.patch	2002/01/31 21:52:13
***************
*** 1,35 ****
! *** Doof2d-Array-parallel.cpp	Tue Dec  4 11:49:43 2001
! --- Doof2d-Array-parallel-annotated.cpp	Wed Jan 23 16:35:54 2002
  ***************
! *** 1,4 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
! --- 1,5 ----
  ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
  ***************
! *** 12,17 ****
      // Ask the user for the number of averagings.
      long nuAveragings, nuIterations;
  !   std::cout << "Please enter the number of averagings: ";
  !   std::cin >> nuAveragings;
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! --- 13,18 ----
!     // Ask the user for the number of averagings.
!     long nuAveragings, nuIterations;
! !   std::cout &openopen; "Please enter the number of averagings: ";
! !   std::cin &closeclose; nuAveragings;
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
!   
! ***************
! *** 19,43 ****
!     // the grid.
      long n;
  !   std::cout << "Please enter the array size: ";
  !   std::cin >> n;
--- 1,30 ----
! *** Doof2d-Array-parallel.cpp	Wed Jan 23 19:18:32 2002
! --- Doof2d-Array-parallel-annotated.cpp	Mon Jan 28 20:41:18 2002
  ***************
! *** 1,5 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
!   // Doof2d: POOMA Arrays, data-parallel implementation
! --- 1,7 ----
  ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"
! !     // has POOMA's Array declarations
    
+   // Doof2d: POOMA Arrays, data-parallel implementation
  ***************
! *** 12,43 ****
      // Ask the user for the number of averagings.
      long nuAveragings, nuIterations;
  !   std::cout << "Please enter the number of averagings: ";
  !   std::cin >> nuAveragings;
! !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! !   // Ask the user for the number n of values along one dimension of
! !   // the grid.
      long n;
  !   std::cout << "Please enter the array size: ";
  !   std::cin >> n;
***************
*** 43,61 ****
  !   Interval<1> J(1,n-2);
    
      // Create the arrays.
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
    
      // Set up the initial conditions.
!     // All grid values should be zero except for the central value.
      a = b = 0.0;
  !   // Ensure all data-parallel computation finishes before accessing a value.
      Pooma::blockAndEvaluate();
      b(n/2,n/2) = 1000.0;
! --- 20,44 ----
!     // the grid.
      long n;
  !   std::cout &openopen; "Please enter the array size: ";
  !   std::cin &closeclose; n;
--- 38,64 ----
  !   Interval<1> J(1,n-2);
    
      // Create the arrays.
! !   // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the central value.
      a = b = 0.0;
  !   // Ensure all data-parallel computation finishes before accessing a value.
      Pooma::blockAndEvaluate();
      b(n/2,n/2) = 1000.0;
! --- 14,50 ----
!     // Ask the user for the number of averagings.
!     long nuAveragings, nuIterations;
! !   std::cout &openopen; "Please enter the number of averagings: ";
! !   std::cin &closeclose; nuAveragings;
! !   nuIterations = (nuAveragings+1)/2;
! !     // Each iteration performs two averagings.
!   
! !   // Ask the user for the number n of values along one
! !   // dimension of the grid.
      long n;
  !   std::cout &openopen; "Please enter the array size: ";
  !   std::cin &closeclose; n;
***************
*** 64,83 ****
  !   Interval&lt;1&gt; N(0, n-1);
  !   Interval&lt;2&gt; vertDomain(N, N);
    
! !   // Set up interior domains [1,n-1) x [1,n-1) for computation.  <co id="tutorial-array_parallel-doof2d-innerdomain"></co>
  !   Interval&lt;1&gt; I(1,n-2);
  !   Interval&lt;1&gt; J(1,n-2);
    
      // Create the arrays.
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
    
      // Set up the initial conditions.
!     // All grid values should be zero except for the central value.
      a = b = 0.0;
! !   // Ensure all data-parallel computation finishes before accessing a value.  <co id="tutorial-array_parallel-doof2d-blockAndEvaluate"></co>
      Pooma::blockAndEvaluate();
      b(n/2,n/2) = 1000.0;
  ***************
--- 67,90 ----
  !   Interval&lt;1&gt; N(0, n-1);
  !   Interval&lt;2&gt; vertDomain(N, N);
    
! !   // Set up interior domains [1,n-1) x [1,n-1) 
! !   // for computation.  <co id="tutorial-array_parallel-doof2d-innerdomain"></co>
  !   Interval&lt;1&gt; I(1,n-2);
  !   Interval&lt;1&gt; J(1,n-2);
    
      // Create the arrays.
! !   // The Array template parameters indicate 2 dimensions,
! !   //  a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the
! !   // central value.
      a = b = 0.0;
! !   // Ensure all data-parallel computation finishes
! !   // before accessing a value.  <co id="tutorial-array_parallel-doof2d-blockAndEvaluate"></co>
      Pooma::blockAndEvaluate();
      b(n/2,n/2) = 1000.0;
  ***************
***************
*** 88,94 ****
  !     // Read from b.  Write to a.
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
! --- 48,53 ----
    
      // Perform the simulation.
  !   for (int k = 0; k &lt; nuIterations; ++k) {
--- 95,101 ----
  !     // Read from b.  Write to a.
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
! --- 54,59 ----
    
      // Perform the simulation.
  !   for (int k = 0; k &lt; nuIterations; ++k) {
***************
*** 96,116 ****
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
  ***************
! *** 63,67 ****
      // Print out the final central value.
!     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The arrays are automatically deallocated.
! --- 64,68 ----
      // Print out the final central value.
!     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
! !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
    
      // The arrays are automatically deallocated.
  ***************
  *** 71,72 ****
! --- 72,74 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
--- 103,128 ----
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
  ***************
! *** 62,67 ****
!   
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The arrays are automatically deallocated.
! --- 69,77 ----
!   
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();
! !     // Ensure all computation has finished.
! !   std::cout &openopen;
! !     (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
! !     &openopen; std::endl;
    
      // The arrays are automatically deallocated.
  ***************
  *** 71,72 ****
! --- 81,83 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
Index: examples/Doof2d/Doof2d-Array-stencil-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Attic/Doof2d-Array-stencil-annotated.patch,v
retrieving revision 1.7
diff -c -p -r1.7 Doof2d-Array-stencil-annotated.patch
*** examples/Doof2d/Doof2d-Array-stencil-annotated.patch	2002/01/25 03:27:30	1.7
--- examples/Doof2d/Doof2d-Array-stencil-annotated.patch	2002/01/31 21:52:13
***************
*** 1,73 ****
! *** Doof2d-Array-stencil.cpp	Tue Dec  4 11:49:39 2001
! --- Doof2d-Array-stencil-annotated.cpp	Wed Jan 23 16:36:15 2002
  ***************
  *** 1,9 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
    // Doof2d: POOMA Arrays, stencil implementation
    
  ! // Define the stencil class performing the computation.
    class DoofNinePt
    {
! --- 1,10 ----
  ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
    // Doof2d: POOMA Arrays, stencil implementation
    
! ! // Define the stencil class performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
    class DoofNinePt
    {
  ***************
! *** 14,19 ****
!     // This stencil operator is applied to each interior domain position
!     // (i,j).  The "C" template parameter permits use of this stencil
  !   // operator with both Arrays and Fields.
  !   template <class C>
      inline
-     typename C::Element_t
- --- 15,20 ----
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.  <co id="tutorial-array_stencil-doof2d-stencil_operator"></co>
- !   template &lt;class C&gt;
-     inline
      typename C::Element_t
! ***************
! *** 26,30 ****
      }
    
  !   inline int lowerExtent(int) const { return 1; }
      inline int upperExtent(int) const { return 1; }
    
! --- 27,31 ----
      }
    
  !   inline int lowerExtent(int) const { return 1; }  <co id="tutorial-array_stencil-doof2d-stencil_extent"></co>
      inline int upperExtent(int) const { return 1; }
    
  ***************
! *** 42,47 ****
      // Ask the user for the number of averagings.
      long nuAveragings, nuIterations;
  !   std::cout << "Please enter the number of averagings: ";
  !   std::cin >> nuAveragings;
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
!   
! --- 43,48 ----
!     // Ask the user for the number of averagings.
!     long nuAveragings, nuIterations;
! !   std::cout &openopen; "Please enter the number of averagings: ";
! !   std::cin &closeclose; nuAveragings;
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! ***************
! *** 49,68 ****
!     // the grid.
      long n;
  !   std::cout << "Please enter the array size: ";
  !   std::cin >> n;
--- 1,80 ----
! *** Doof2d-Array-stencil.cpp	Wed Jan 23 19:18:49 2002
! --- Doof2d-Array-stencil-annotated.cpp	Thu Jan 31 09:11:12 2002
  ***************
  *** 1,9 ****
  ! #include <iostream>		// has std::cout, ...
  ! #include <stdlib.h>		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
    
    // Doof2d: POOMA Arrays, stencil implementation
    
  ! // Define the stencil class performing the computation.
    class DoofNinePt
    {
! --- 1,11 ----
  ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Arrays.h"
! !    // has POOMA's Array declarations
    
    // Doof2d: POOMA Arrays, stencil implementation
    
! ! // Define a stencil class performing computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
    class DoofNinePt
    {
  ***************
! *** 12,30 ****
!     DoofNinePt() : weight(1.0/9.0) {}
!   
! !   // This stencil operator is applied to each interior domain position
! !   // (i,j).  The "C" template parameter permits use of this stencil
  !   // operator with both Arrays and Fields.
  !   template <class C>
      inline
      typename C::Element_t
! !   operator()(const C& c, int i, int j) const
! !   {
! !     return ( weight *
! !              ( c.read(i+1,j+1) + c.read(i+1,j  ) + c.read(i+1,j-1) +
! !                c.read(i  ,j+1) + c.read(i  ,j  ) + c.read(i  ,j-1) +
! !                c.read(i-1,j+1) + c.read(i-1,j  ) + c.read(i-1,j-1) ) );
      }
    
  !   inline int lowerExtent(int) const { return 1; }
      inline int upperExtent(int) const { return 1; }
+   
+ --- 14,33 ----
+     DoofNinePt() : weight(1.0/9.0) {}
    
! !   // This stencil operator is applied to each
! !   // interior domain position (i,j).  The "C"
! !   // template parameter permits use of this
! !   // stencil operator with both Arrays &amp; Fields.  <co id="tutorial-array_stencil-doof2d-stencil_operator"></co>
! !   template &lt;class C&gt;
!     inline
!     typename C::Element_t
! !   operator()(const C& c, int i, int j) const {
! !     return
! !       weight *
! !       (c.read(i+1,j+1)+c.read(i+1,j)+c.read(i+1,j-1)+
! !        c.read(i  ,j+1)+c.read(i  ,j)+c.read(i  ,j-1)+
! !        c.read(i-1,j+1)+c.read(i-1,j)+c.read(i-1,j-1));
      }
    
  !   inline int lowerExtent(int) const { return 1; }  <co id="tutorial-array_stencil-doof2d-stencil_extent"></co>
      inline int upperExtent(int) const { return 1; }
    
  ***************
! *** 42,82 ****
      // Ask the user for the number of averagings.
      long nuAveragings, nuIterations;
  !   std::cout << "Please enter the number of averagings: ";
  !   std::cin >> nuAveragings;
! !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! !   // Ask the user for the number n of values along one dimension of
! !   // the grid.
      long n;
  !   std::cout << "Please enter the array size: ";
  !   std::cin >> n;
***************
*** 76,94 ****
  !   Interval<1> N(0, n-1);
  !   Interval<2> vertDomain(N, N);
    
!     // Set up interior domains [1,n-1) x [1,n-1) for computation.
  !   Interval<1> I(1,n-2);
  !   Interval<2> interiorDomain(I,I);
    
      // Create the arrays.
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
    
      // Set up the initial conditions.
! --- 50,69 ----
!     // the grid.
      long n;
  !   std::cout &openopen; "Please enter the array size: ";
  !   std::cin &closeclose; n;
--- 83,123 ----
  !   Interval<1> N(0, n-1);
  !   Interval<2> vertDomain(N, N);
    
! !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
  !   Interval<1> I(1,n-2);
  !   Interval<2> interiorDomain(I,I);
    
      // Create the arrays.
! !   // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array<2, double, Brick> a(vertDomain);
  !   Array<2, double, Brick> b(vertDomain);
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the central value.
!     a = b = 0.0;
! !   // Ensure all data-parallel computation finishes before accessing a value.
!     Pooma::blockAndEvaluate();
!     b(n/2,n/2) = 1000.0;
!   
! !   // Create the stencil performing the computation.
! !   Stencil<DoofNinePt> stencil;
!   
!     // Perform the simulation.
! !   for (int k = 0; k < nuIterations; ++k) {
! !     // Read from b.  Write to a.
!       a(interiorDomain) = stencil(b, interiorDomain);
!   
! --- 45,90 ----
!     // Ask the user for the number of averagings.
!     long nuAveragings, nuIterations;
! !   std::cout &openopen; "Please enter the number of averagings: ";
! !   std::cin &closeclose; nuAveragings;
! !   nuIterations = (nuAveragings+1)/2;
! !     // Each iteration performs two averagings.
!   
! !   // Ask the user for the number n of values along one
! !   // dimension of the grid.
      long n;
  !   std::cout &openopen; "Please enter the array size: ";
  !   std::cin &closeclose; n;
***************
*** 97,129 ****
  !   Interval&lt;1&gt; N(0, n-1);
  !   Interval&lt;2&gt; vertDomain(N, N);
    
!     // Set up interior domains [1,n-1) x [1,n-1) for computation.
  !   Interval&lt;1&gt; I(1,n-2);
  !   Interval&lt;2&gt; interiorDomain(I,I);
    
      // Create the arrays.
!     // The Array template parameters indicate 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
    
      // Set up the initial conditions.
! ***************
! *** 73,82 ****
      b(n/2,n/2) = 1000.0;
    
! !   // Create the stencil performing the computation.
! !   Stencil<DoofNinePt> stencil;
!   
!     // Perform the simulation.
! !   for (int k = 0; k < nuIterations; ++k) {
! !     // Read from b.  Write to a.
!       a(interiorDomain) = stencil(b, interiorDomain);
!   
! --- 74,83 ----
!     b(n/2,n/2) = 1000.0;
!   
! !   // Create the stencil performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil_creation"></co>
  !   Stencil&lt;DoofNinePt&gt; stencil;
    
      // Perform the simulation.
--- 126,153 ----
  !   Interval&lt;1&gt; N(0, n-1);
  !   Interval&lt;2&gt; vertDomain(N, N);
    
! !   // Set up interior domains [1,n-1) x [1,n-1) for
! !   // computation.
  !   Interval&lt;1&gt; I(1,n-2);
  !   Interval&lt;2&gt; interiorDomain(I,I);
    
      // Create the arrays.
! !   // The Array template parameters indicate
! !   // 2 dimensions, a 'double' value
      // type, and ordinary 'Brick' storage.
  !   Array&lt;2, double, Brick&gt; a(vertDomain);
  !   Array&lt;2, double, Brick&gt; b(vertDomain);
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the
! !   // central value.
!     a = b = 0.0;
! !   // Ensure all data-parallel computation finishes
! !   // before accessing a value.
!     Pooma::blockAndEvaluate();
      b(n/2,n/2) = 1000.0;
    
! !   // Create a stencil performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil_creation"></co>
  !   Stencil&lt;DoofNinePt&gt; stencil;
    
      // Perform the simulation.
***************
*** 132,152 ****
        a(interiorDomain) = stencil(b, interiorDomain);
    
  ***************
! *** 87,91 ****
      // Print out the final central value.
!     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The arrays are automatically deallocated.
! --- 88,92 ----
      // Print out the final central value.
!     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
! !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
    
      // The arrays are automatically deallocated.
  ***************
  *** 95,96 ****
! --- 96,98 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
--- 156,181 ----
        a(interiorDomain) = stencil(b, interiorDomain);
    
  ***************
! *** 86,91 ****
!   
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The arrays are automatically deallocated.
! --- 94,102 ----
!   
      // Print out the final central value.
! !   Pooma::blockAndEvaluate(); 
! !     // Ensure all computation has finished.
! !   std::cout &openopen;
! !     (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
! !     &openopen; std::endl;
    
      // The arrays are automatically deallocated.
  ***************
  *** 95,96 ****
! --- 106,108 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
Index: examples/Doof2d/Doof2d-C-element-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Attic/Doof2d-C-element-annotated.patch,v
retrieving revision 1.7
diff -c -p -r1.7 Doof2d-C-element-annotated.patch
*** examples/Doof2d/Doof2d-C-element-annotated.patch	2002/01/25 03:27:30	1.7
--- examples/Doof2d/Doof2d-C-element-annotated.patch	2002/01/31 21:52:13
***************
*** 1,5 ****
! *** Doof2d-C-element.cpp	Tue Dec  4 09:59:18 2001
! --- Doof2d-C-element-annotated.cpp	Wed Jan 23 16:34:20 2002
  ***************
  *** 1,4 ****
  ! #include <iostream>		// has std::cout, ...
--- 1,5 ----
! *** Doof2d-C-element.cpp	Thu Jan 31 08:46:50 2002
! --- Doof2d-C-element-annotated.cpp	Thu Jan 31 08:47:14 2002
  ***************
  *** 1,4 ****
  ! #include <iostream>		// has std::cout, ...
***************
*** 20,32 ****
      long nuAveragings, nuIterations;
  !   std::cout << "Please enter the number of averagings: ";
  !   std::cin >> nuAveragings;
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
  !   // Use two-dimensional grids of values.
      double **a;
      double **b;
    
!     // Ask the user for the number n of values along one dimension of
  !   // the grid.
      long n;
  !   std::cout << "Please enter the array size: ";
--- 20,32 ----
      long nuAveragings, nuIterations;
  !   std::cout << "Please enter the number of averagings: ";
  !   std::cin >> nuAveragings;
! !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
  !   // Use two-dimensional grids of values.
      double **a;
      double **b;
    
! !   // Ask the user for the number n of values along one dimension of
  !   // the grid.
      long n;
  !   std::cout << "Please enter the array size: ";
***************
*** 39,59 ****
  !   for (int i = 0; i < n; i++) {
        a[i] = new double[n];
        b[i] = new double[n];
! --- 7,31 ----
    int main()
    {
  !   // Ask the user for the number of averagings.  <co id="tutorial-hand_coded-doof2d-nuaveragings"></co>
      long nuAveragings, nuIterations;
  !   std::cout &openopen; "Please enter the number of averagings: ";
  !   std::cin &closeclose; nuAveragings;
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
  !   // Use two-dimensional grids of values.  <co id="tutorial-hand_coded-doof2d-array_storage"></co>
      double **a;
      double **b;
    
!     // Ask the user for the number n of values along one dimension of
! !   // the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
      long n;
  !   std::cout &openopen; "Please enter the array size: ";
  !   std::cin &closeclose; n;
--- 39,60 ----
  !   for (int i = 0; i < n; i++) {
        a[i] = new double[n];
        b[i] = new double[n];
! --- 7,32 ----
    int main()
    {
  !   // Ask the user for the number of averagings.  <co id="tutorial-hand_coded-doof2d-nuaveragings"></co>
      long nuAveragings, nuIterations;
  !   std::cout &openopen; "Please enter the number of averagings: ";
  !   std::cin &closeclose; nuAveragings;
! !   nuIterations = (nuAveragings+1)/2;
! !     // Each iteration performs two averagings.
    
  !   // Use two-dimensional grids of values.  <co id="tutorial-hand_coded-doof2d-array_storage"></co>
      double **a;
      double **b;
    
! !   // Ask the user for the number n of values along one 
! !   // dimension of the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
      long n;
  !   std::cout &openopen; "Please enter the array size: ";
  !   std::cin &closeclose; n;
***************
*** 75,81 ****
          a[i][j] = b[i][j] = 0.0;
      b[n/2][n/2] = 1000.0;
    
! !   // In the average, weight elements with this value.
      const double weight = 1.0/9.0;
    
      // Perform the simulation.
--- 76,82 ----
          a[i][j] = b[i][j] = 0.0;
      b[n/2][n/2] = 1000.0;
    
! !   // Average using this weight.
      const double weight = 1.0/9.0;
    
      // Perform the simulation.
***************
*** 85,100 ****
  !       for (int i = 1; i < n-1; i++)
            a[i][j] = weight *
              (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
! --- 33,50 ----
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the central value.  <co id="tutorial-hand_coded-doof2d-initialization"></co>
  !   for (int j = 0; j &lt; n; j++)
  !     for (int i = 0; i &lt; n; i++)
          a[i][j] = b[i][j] = 0.0;
      b[n/2][n/2] = 1000.0;
    
! !   // In the average, weight elements with this value.  <co id="tutorial-hand_coded-doof2d-constants"></co>
      const double weight = 1.0/9.0;
    
      // Perform the simulation.
--- 86,102 ----
  !       for (int i = 1; i < n-1; i++)
            a[i][j] = weight *
              (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
! --- 34,52 ----
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the
! !   // central value.  <co id="tutorial-hand_coded-doof2d-initialization"></co>
  !   for (int j = 0; j &lt; n; j++)
  !     for (int i = 0; i &lt; n; i++)
          a[i][j] = b[i][j] = 0.0;
      b[n/2][n/2] = 1000.0;
    
! !   // Average using this weight.  <co id="tutorial-hand_coded-doof2d-constants"></co>
      const double weight = 1.0/9.0;
    
      // Perform the simulation.
***************
*** 113,119 ****
  !       for (int i = 1; i < n-1; i++)
            b[i][j] = weight *
              (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
! --- 52,58 ----
               b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
    
  !     // Read from a.  Write to b.  <co id="tutorial-hand_coded-doof2d-second_write"></co>
--- 115,121 ----
  !       for (int i = 1; i < n-1; i++)
            b[i][j] = weight *
              (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
! --- 54,60 ----
               b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
    
  !     // Read from a.  Write to b.  <co id="tutorial-hand_coded-doof2d-second_write"></co>
***************
*** 132,142 ****
  !   for (int i = 0; i < n; i++) {
        delete [] a[i];
        delete [] b[i];
! --- 61,69 ----
      }
    
  !   // Print out the final central value.  <co id="tutorial-hand_coded-doof2d-answer"></co>
! !   std::cout &openopen; (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) &openopen; std::endl;
    
  !   // Deallocate the arrays.  <co id="tutorial-hand_coded-doof2d-deallocation"></co>
  !   for (int i = 0; i &lt; n; i++) {
--- 134,146 ----
  !   for (int i = 0; i < n; i++) {
        delete [] a[i];
        delete [] b[i];
! --- 63,73 ----
      }
    
  !   // Print out the final central value.  <co id="tutorial-hand_coded-doof2d-answer"></co>
! !   std::cout &openopen;
! !     (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2])
! !     &openopen; std::endl;
    
  !   // Deallocate the arrays.  <co id="tutorial-hand_coded-doof2d-deallocation"></co>
  !   for (int i = 0; i &lt; n; i++) {
***************
*** 144,150 ****
        delete [] b[i];
  ***************
  *** 73,74 ****
! --- 74,76 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
--- 148,154 ----
        delete [] b[i];
  ***************
  *** 73,74 ****
! --- 78,80 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
Index: examples/Doof2d/Doof2d-Field-distributed-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Attic/Doof2d-Field-distributed-annotated.patch,v
retrieving revision 1.6
diff -c -p -r1.6 Doof2d-Field-distributed-annotated.patch
*** examples/Doof2d/Doof2d-Field-distributed-annotated.patch	2002/01/25 03:27:30	1.6
--- examples/Doof2d/Doof2d-Field-distributed-annotated.patch	2002/01/31 21:52:13
***************
*** 1,26 ****
! *** Doof2d-Field-distributed.cpp	Wed Dec  5 14:05:10 2001
! --- Doof2d-Field-distributed-annotated.cpp	Wed Jan 23 16:36:34 2002
  ***************
! *** 1,3 ****
  ! #include <stdlib.h>		// has EXIT_SUCCESS
!   #include "Pooma/Fields.h"	// has POOMA's Field declarations
    
! --- 1,4 ----
  ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
!   #include "Pooma/Fields.h"	// has POOMA's Field declarations
    
  ***************
! *** 12,16 ****
!     // canot use standard input and output.  Instead we use command-line
!     // arguments, which are replicated, for input, and we use an Inform
  !   // stream for output.
      Inform output;
    
! --- 13,17 ----
!     // canot use standard input and output.  Instead we use command-line
!     // arguments, which are replicated, for input, and we use an Inform
! !   // stream for output.  <co id="tutorial-field_distributed-doof2d-io"></co>
      Inform output;
    
  ***************
--- 1,41 ----
! *** Doof2d-Field-distributed.cpp	Wed Jan 23 19:20:15 2002
! --- Doof2d-Field-distributed-annotated.cpp	Wed Jan 30 16:40:27 2002
  ***************
! *** 1,6 ****
  ! #include <stdlib.h>		// has EXIT_SUCCESS
! ! #include "Pooma/Fields.h"	// has POOMA's Field declarations
    
! ! // Doof2d: POOMA Fields, data-parallel, multiple processor implementation
!   
!   int main(int argc, char *argv[])
! --- 1,9 ----
  ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Fields.h"
! !     // has POOMA's Field declarations
!   
! ! // Doof2d: POOMA Fields, data-parallel, multiple
! ! // processor implementation
    
+   int main(int argc, char *argv[])
  ***************
! *** 9,16 ****
!     Pooma::initialize(argc,argv);
!     
! !   // Since multiple copies of this program may simultaneously run, we
! !   // canot use standard input and output.  Instead we use command-line
! !   // arguments, which are replicated, for input, and we use an Inform
  !   // stream for output.
      Inform output;
    
! --- 12,20 ----
!     Pooma::initialize(argc,argv);
!     
! !   // Since multiple copies of this program may
! !   // simultaneously run, we canot use standard input
! !   // and output.  Instead we use command-line
! !   // arguments, which are replicated, for input, and we
! !   // use an Inform stream for output.  <co id="tutorial-field_distributed-doof2d-io"></co>
      Inform output;
    
  ***************
***************
*** 30,43 ****
  !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
        return EXIT_FAILURE;
      }
! --- 19,23 ----
      if (argc != 4) {
        // Incorrect number of command-line arguments.
! !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
        return EXIT_FAILURE;
      }
  ***************
! *** 25,33 ****
      // Determine the number of processors.
      long nuProcessors;
  !   nuProcessors = strtol(argv[1], &tail, 0);
--- 45,61 ----
  !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
        return EXIT_FAILURE;
      }
! --- 22,29 ----
      if (argc != 4) {
        // Incorrect number of command-line arguments.
! !     output &openopen; argv[0] &openopen;
! !       ": number-of-processors number-of-averagings"
! !       &openopen; " number-of-values"
! !       &openopen; std::endl;
        return EXIT_FAILURE;
      }
  ***************
! *** 25,79 ****
      // Determine the number of processors.
      long nuProcessors;
  !   nuProcessors = strtol(argv[1], &tail, 0);
***************
*** 45,116 ****
      // Determine the number of averagings.
      long nuAveragings, nuIterations;
  !   nuAveragings = strtol(argv[2], &tail, 0);
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
!   
! --- 26,34 ----
!     // Determine the number of processors.
!     long nuProcessors;
! !   nuProcessors = strtol(argv[1], &amp;tail, 0);
    
!     // Determine the number of averagings.
!     long nuAveragings, nuIterations;
! !   nuAveragings = strtol(argv[2], &amp;tail, 0);
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
!   
! ***************
! *** 35,39 ****
!     // the grid.
      long n;
  !   n = strtol(argv[3], &tail, 0);
!     // The dimension must be a multiple of the number of processors
!     // since we are using a UniformGridLayout.
! --- 36,40 ----
!     // the grid.
!     long n;
! !   n = strtol(argv[3], &amp;tail, 0);
!     // The dimension must be a multiple of the number of processors
!     // since we are using a UniformGridLayout.
! ***************
! *** 41,50 ****
    
      // Specify the fields' domains [0,n) x [0,n).
  !   Interval<1> N(0, n-1);
  !   Interval<2> vertDomain(N, N);
    
!     // Set up interior domains [1,n-1) x [1,n-1) for computation.
  !   Interval<1> I(1,n-2);
  !   Interval<1> J(1,n-2);
!   
!     // Partition the fields' domains uniformly, i.e., each patch has the
! --- 42,51 ----
!   
!     // Specify the fields' domains [0,n) x [0,n).
! !   Interval&lt;1&gt; N(0, n-1);
! !   Interval&lt;2&gt; vertDomain(N, N);
!   
!     // Set up interior domains [1,n-1) x [1,n-1) for computation.
! !   Interval&lt;1&gt; I(1,n-2);
! !   Interval&lt;1&gt; J(1,n-2);
!   
!     // Partition the fields' domains uniformly, i.e., each patch has the
! ***************
! *** 52,74 ****
!     // dimension.  Guard layers optimize communication between patches.
!     // Internal guards surround each patch.  External guards surround
  !   // the entire field domain.
  !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
  ! 				    GuardLayers<2>(1),  // internal
  ! 				    GuardLayers<2>(0)); // external
  !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
!   
!     // Specify the fields' mesh, i.e., its spatial extent, and its
  !   // centering type.
  !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
  !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
!   
!     // The Field template parameters indicate a mesh and a 'double'
!     // value type.  MultiPatch indicates multiple computation patches,
!     // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.
  !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
  !     Remote<Brick> > > a(cell, layout, mesh);
--- 63,104 ----
      // Determine the number of averagings.
      long nuAveragings, nuIterations;
  !   nuAveragings = strtol(argv[2], &tail, 0);
! !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! !   // Ask the user for the number n of values along one dimension of
! !   // the grid.
      long n;
  !   n = strtol(argv[3], &tail, 0);
! !   // The dimension must be a multiple of the number of processors
! !   // since we are using a UniformGridLayout.
!     n = ((n+nuProcessors-1) / nuProcessors) * nuProcessors;
    
      // Specify the fields' domains [0,n) x [0,n).
  !   Interval<1> N(0, n-1);
  !   Interval<2> vertDomain(N, N);
    
! !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
  !   Interval<1> I(1,n-2);
  !   Interval<1> J(1,n-2);
! ! 
! !   // Partition the fields' domains uniformly, i.e., each patch has the
! !   // same size.  The first parameter tells how many patches for each
! !   // dimension.  Guard layers optimize communication between patches.
! !   // Internal guards surround each patch.  External guards surround
  !   // the entire field domain.
  !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
  ! 				    GuardLayers<2>(1),  // internal
  ! 				    GuardLayers<2>(0)); // external
  !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
! ! 
! !   // Specify the fields' mesh, i.e., its spatial extent, and its
  !   // centering type.
  !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
  !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
! ! 
! !   // The Field template parameters indicate a mesh and a 'double'
! !   // value type.  MultiPatch indicates multiple computation patches,
! !   // i.e., distributed computation.  The UniformTag indicates the
  !   // patches should have the same size.  Each patch has Brick type.
  !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
  !     Remote<Brick> > > a(cell, layout, mesh);
***************
*** 118,147 ****
  !     Remote<Brick> > > b(cell, layout, mesh);
    
      // Set up the initial conditions.
! --- 53,75 ----
!     // dimension.  Guard layers optimize communication between patches.
!     // Internal guards surround each patch.  External guards surround
! !   // the entire field domain.  <co id="tutorial-field_distributed-doof2d-layout"></co>
! !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
! ! 				    GuardLayers&lt;2&gt;(1),  // internal
! ! 				    GuardLayers&lt;2&gt;(0)); // external
! !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
!   
!     // Specify the fields' mesh, i.e., its spatial extent, and its
! !   // centering type.  <co id="tutorial-field_distributed-doof2d-mesh"></co>
! !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
! !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
!   
!     // The Field template parameters indicate a mesh and a 'double'
!     // value type.  MultiPatch indicates multiple computation patches,
!     // i.e., distributed computation.  The UniformTag indicates the
! !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
! !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
! !     Remote&lt;Brick&gt; &gt; &gt; a(cell, layout, mesh);
! !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
! !     Remote&lt;Brick&gt; &gt; &gt; b(cell, layout, mesh);
    
      // Set up the initial conditions.
  ***************
  *** 83,87 ****
    
--- 106,185 ----
  !     Remote<Brick> > > b(cell, layout, mesh);
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the central value.
!     a = b = 0.0;
! !   // Ensure all data-parallel computation finishes before accessing a value.
!     Pooma::blockAndEvaluate();
!     b(n/2,n/2) = 1000.0;
! --- 32,99 ----
!     // Determine the number of processors.
!     long nuProcessors;
! !   nuProcessors = strtol(argv[1], &amp;tail, 0);
!   
!     // Determine the number of averagings.
!     long nuAveragings, nuIterations;
! !   nuAveragings = strtol(argv[2], &amp;tail, 0);
! !   nuIterations = (nuAveragings+1)/2;
! !     // Each iteration performs two averagings.
!   
! !   // Ask the user for the number n of values along
! !   // one dimension of the grid.
!     long n;
! !   n = strtol(argv[3], &amp;tail, 0);
! !   // The dimension must be a multiple of the number of
! !   // processors since we are using a UniformGridLayout.
!     n = ((n+nuProcessors-1) / nuProcessors) * nuProcessors;
!   
!     // Specify the fields' domains [0,n) x [0,n).
! !   Interval&lt;1&gt; N(0, n-1);
! !   Interval&lt;2&gt; vertDomain(N, N);
    
+ !   // Set up interior domains [1,n-1) x [1,n-1) for
+ !   // computation.
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;1&gt; J(1,n-2);
+ ! 
+ !   // Partition the fields' domains uniformly, i.e.,
+ !   // each patch has the same size.  The first parameter
+ !   // tells how many patches for each dimension.  Guard
+ !   // layers optimize communication between patches.
+ !   // Internal guards surround each patch.  External
+ !   // guards surround the entire field domain.  <co id="tutorial-field_distributed-doof2d-layout"></co>
+ !   UniformGridPartition&lt;2&gt;
+ !     partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
+ ! 	     GuardLayers&lt;2&gt;(1),  // internal
+ ! 	     GuardLayers&lt;2&gt;(0)); // external
+ !   UniformGridLayout&lt;2&gt;
+ !     layout(vertDomain, partition, DistributedTag());
+ ! 
+ !   // Specify the fields' mesh, i.e., its spatial
+ !   // extent, and its centering type.  <co id="tutorial-field_distributed-doof2d-mesh"></co>
+ !   UniformRectilinearMesh&lt;2&gt;
+ !     mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
+ !   Centering&lt;2&gt; cell =
+ !     canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
+ ! 
+ !   // The Field template parameters indicate a mesh and
+ !   // a 'double' value type.  MultiPatch indicates
+ !   // multiple computation patches, i.e., distributed
+ !   // computation.  The UniformTag indicates the patches
+ !   // should have the same size.  Each patch has Brick
+ !   // type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
+ !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double,
+ !            MultiPatch&lt;UniformTag, Remote&lt;Brick&closecloseclose;
+ !     a(cell, layout, mesh);
+ !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double,
+ !     MultiPatch&lt;UniformTag, Remote&lt;Brick&closecloseclose;
+ !     b(cell, layout, mesh);
+   
      // Set up the initial conditions.
+ !   // All grid values should be zero except for the
+ !   // central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes
+ !   // before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
  ***************
  *** 83,87 ****
    
***************
*** 149,176 ****
  !   for (int k = 0; k < nuIterations; ++k) {
        // Read from b.  Write to a.
        a(I,J) = weight *
! --- 84,88 ----
    
      // Perform the simulation.
  !   for (int k = 0; k &lt; nuIterations; ++k) {
        // Read from b.  Write to a.
        a(I,J) = weight *
  ***************
! *** 99,103 ****
      // Print out the final central value.
!     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The fields are automatically deallocated.
! --- 100,104 ----
      // Print out the final central value.
!     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
! !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
    
      // The fields are automatically deallocated.
  ***************
  *** 107,108 ****
! --- 108,110 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
--- 187,219 ----
  !   for (int k = 0; k < nuIterations; ++k) {
        // Read from b.  Write to a.
        a(I,J) = weight *
! --- 103,107 ----
    
      // Perform the simulation.
  !   for (int k = 0; k &lt; nuIterations; ++k) {
        // Read from b.  Write to a.
        a(I,J) = weight *
  ***************
! *** 98,103 ****
!   
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The fields are automatically deallocated.
! --- 118,126 ----
!   
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();
! !     // Ensure all computation has finished.
! !   output &openopen;
! !     (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
! !     &openopen; std::endl;
    
      // The fields are automatically deallocated.
  ***************
  *** 107,108 ****
! --- 130,132 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
Index: examples/Doof2d/Doof2d-Field-parallel-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Attic/Doof2d-Field-parallel-annotated.patch,v
retrieving revision 1.6
diff -c -p -r1.6 Doof2d-Field-parallel-annotated.patch
*** examples/Doof2d/Doof2d-Field-parallel-annotated.patch	2002/01/25 03:27:30	1.6
--- examples/Doof2d/Doof2d-Field-parallel-annotated.patch	2002/01/31 21:52:13
***************
*** 1,5 ****
! *** Doof2d-Field-parallel.cpp	Tue Dec  4 11:47:58 2001
! --- Doof2d-Field-parallel-annotated.cpp	Wed Jan 23 16:37:19 2002
  ***************
  *** 1,5 ****
  ! #include <iostream>		// has std::cout, ...
--- 1,5 ----
! *** Doof2d-Field-parallel.cpp	Wed Jan 23 19:20:33 2002
! --- Doof2d-Field-parallel-annotated.cpp	Thu Jan 31 09:07:32 2002
  ***************
  *** 1,5 ****
  ! #include <iostream>		// has std::cout, ...
***************
*** 7,37 ****
  ! #include "Pooma/Fields.h"	// has POOMA's Field declarations
    
    // Doof2d: POOMA Fields, data-parallel implementation
! --- 1,6 ----
  ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Fields.h"	// has POOMA's Field declarations  <co id="tutorial-field_parallel-doof2d-header"></co>
    
    // Doof2d: POOMA Fields, data-parallel implementation
  ***************
! *** 12,17 ****
      // Ask the user for the number of averagings.
      long nuAveragings, nuIterations;
  !   std::cout << "Please enter the number of averagings: ";
  !   std::cin >> nuAveragings;
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! --- 13,18 ----
!     // Ask the user for the number of averagings.
!     long nuAveragings, nuIterations;
! !   std::cout &openopen; "Please enter the number of averagings: ";
! !   std::cin &closeclose; nuAveragings;
!     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
!   
! ***************
! *** 19,44 ****
!     // the grid.
      long n;
  !   std::cout << "Please enter the field size: ";
  !   std::cin >> n;
--- 7,30 ----
  ! #include "Pooma/Fields.h"	// has POOMA's Field declarations
    
    // Doof2d: POOMA Fields, data-parallel implementation
! --- 1,7 ----
  ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
  ! #include &lt;iostream&gt;		// has std::cout, ...
  ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
! ! #include "Pooma/Fields.h"
! !    // has POOMA's Field declarations  <co id="tutorial-field_parallel-doof2d-header"></co>
    
    // Doof2d: POOMA Fields, data-parallel implementation
  ***************
! *** 12,49 ****
      // Ask the user for the number of averagings.
      long nuAveragings, nuIterations;
  !   std::cout << "Please enter the number of averagings: ";
  !   std::cin >> nuAveragings;
! !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
    
! !   // Ask the user for the number n of values along one dimension of
! !   // the grid.
      long n;
  !   std::cout << "Please enter the field size: ";
  !   std::cin >> n;
***************
*** 40,64 ****
  !   Interval<1> N(0, n-1);
  !   Interval<2> vertDomain(N, N);
    
!     // Set up interior domains [1,n-1) x [1,n-1) for computation.
  !   Interval<1> I(1,n-2);
  !   Interval<1> J(1,n-2);
!   
!     // Specify the fields' mesh, i.e., its spatial extent, and its
  !   // centering type.
  !   DomainLayout<2> layout(vertDomain);
  !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
  !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
    
      // Create the fields.
!     // The Field template parameters indicate a mesh, a 'double' value
  !   // type, and ordinary 'Brick' storage.
  !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
  !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
    
      // Set up the initial conditions.
! --- 20,45 ----
!     // the grid.
      long n;
  !   std::cout &openopen; "Please enter the field size: ";
  !   std::cin &closeclose; n;
--- 33,70 ----
  !   Interval<1> N(0, n-1);
  !   Interval<2> vertDomain(N, N);
    
! !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
  !   Interval<1> I(1,n-2);
  !   Interval<1> J(1,n-2);
! ! 
! !   // Specify the fields' mesh, i.e., its spatial extent, and its
  !   // centering type.
  !   DomainLayout<2> layout(vertDomain);
  !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
  !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
    
      // Create the fields.
! !   // The Field template parameters indicate a mesh, a 'double' value
  !   // type, and ordinary 'Brick' storage.
  !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
  !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
    
      // Set up the initial conditions.
! !   // All grid values should be zero except for the central value.
!     a = b = 0.0;
! !   // Ensure all data-parallel computation finishes before accessing a value.
!     Pooma::blockAndEvaluate();
!     b(n/2,n/2) = 1000.0;
! --- 14,60 ----
!     // Ask the user for the number of averagings.
!     long nuAveragings, nuIterations;
! !   std::cout&openopen;"Please enter the number of averagings: ";
! !   std::cin &closeclose; nuAveragings;
! !   nuIterations = (nuAveragings+1)/2;
! !     // Each iteration performs two averagings.
!   
! !   // Ask the user for the number n of values along
! !   // one dimension of the grid.
      long n;
  !   std::cout &openopen; "Please enter the field size: ";
  !   std::cin &closeclose; n;
***************
*** 67,89 ****
  !   Interval&lt;1&gt; N(0, n-1);
  !   Interval&lt;2&gt; vertDomain(N, N);
    
!     // Set up interior domains [1,n-1) x [1,n-1) for computation.
  !   Interval&lt;1&gt; I(1,n-2);
  !   Interval&lt;1&gt; J(1,n-2);
!   
!     // Specify the fields' mesh, i.e., its spatial extent, and its
! !   // centering type.  <co id="tutorial-field_parallel-doof2d-mesh"></co>
  !   DomainLayout&lt;2&gt; layout(vertDomain);
! !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
! !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
    
      // Create the fields.
!     // The Field template parameters indicate a mesh, a 'double' value
! !   // type, and ordinary 'Brick' storage.  <co id="tutorial-field_parallel-doof2d-field_creation"></co>
! !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
! !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
    
      // Set up the initial conditions.
  ***************
  *** 53,58 ****
    
--- 73,108 ----
  !   Interval&lt;1&gt; N(0, n-1);
  !   Interval&lt;2&gt; vertDomain(N, N);
    
! !   // Set up interior domains [1,n-1) x [1,n-1) for
! !   // computation.
  !   Interval&lt;1&gt; I(1,n-2);
  !   Interval&lt;1&gt; J(1,n-2);
! ! 
! !   // Specify the fields' mesh, i.e., its spatial
! !   //  extent, and its centering type.  <co id="tutorial-field_parallel-doof2d-mesh"></co>
  !   DomainLayout&lt;2&gt; layout(vertDomain);
! !   UniformRectilinearMesh&lt;2&gt;
! !     mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
! !   Centering&lt;2&gt; cell =
! !     canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
    
      // Create the fields.
! !   // The Field template parameters indicate a mesh, a
! !   // 'double' value type, and ordinary 'Brick'
! !   // storage. <co id="tutorial-field_parallel-doof2d-field_creation"></co>
! !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt;
! !     a(cell, layout, mesh);
! !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt;
! !     b(cell, layout, mesh);
    
      // Set up the initial conditions.
+ !   // All grid values should be zero except for the
+ !   // central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes
+ !   // before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
  ***************
  *** 53,58 ****
    
***************
*** 92,98 ****
  !     // Read from b.  Write to a.
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
! --- 54,59 ----
    
      // Perform the simulation.
  !   for (int k = 0; k &lt; nuIterations; ++k) {
--- 111,117 ----
  !     // Read from b.  Write to a.
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
! --- 64,69 ----
    
      // Perform the simulation.
  !   for (int k = 0; k &lt; nuIterations; ++k) {
***************
*** 100,120 ****
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
  ***************
! *** 69,73 ****
      // Print out the final central value.
!     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The fields are automatically deallocated.
! --- 70,74 ----
      // Print out the final central value.
!     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
! !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
    
      // The fields are automatically deallocated.
  ***************
  *** 77,78 ****
! --- 78,80 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
--- 119,144 ----
        a(I,J) = weight *
          (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
  ***************
! *** 68,73 ****
!   
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
  !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
    
      // The fields are automatically deallocated.
! --- 79,87 ----
!   
      // Print out the final central value.
! !   Pooma::blockAndEvaluate();
! !     // Ensure all computation has finished.
! !   std::cout &openopen;
! !     (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
! !     &openopen; std::endl;
    
      // The fields are automatically deallocated.
  ***************
  *** 77,78 ****
! --- 91,93 ----
      return EXIT_SUCCESS;
    }
  + </programlisting>
Index: examples/Doof2d/array-copy-annotated.patch
===================================================================
RCS file: array-copy-annotated.patch
diff -N array-copy-annotated.patch
*** /tmp/cvsqJ3CRs	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,77 ****
- *** array-copy.cpp	Thu Jan 24 11:12:23 2002
- --- array-copy-annotated.cpp	Thu Jan 24 11:12:49 2002
- ***************
- *** 1,8 ****
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include <iostream>
-   
-   // Changes the Array value at index (0,0).
- ! void changeValue(Array<2,int,Brick>& z)
-   { z(0,0) = 6; }
-   
- --- 1,9 ----
- + <programlisting id="array-copy-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include &lt;iostream&gt;
-   
-   // Changes the Array value at index (0,0).
- ! void changeValue(Array&lt;2,int,Brick&gt;&amp; z)
-   { z(0,0) = 6; }
-   
- ***************
- *** 11,17 ****
-     Pooma::initialize(argc,argv);
-   
- !   Array<2,int,Brick> a(3,4, ModelElement<int>(4));
- !   std::cout << "Initial value:\n";
- !   std::cout << "a: " << a(0,0) << std::endl;
-   
-     // Array copies share the same underlying values.
- --- 12,18 ----
-     Pooma::initialize(argc,argv);
-   
- !   Array&lt;2,int,Brick&gt; a(3,4, ModelElement&lt;int&gt;(4));
- !   std::cout &openopen; "Initial value:\n";
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
-   
-     // Array copies share the same underlying values.
- ***************
- *** 19,35 ****
-     // Explicit initialization uses reference semantics so changing the
-     // copy's value at (0,0) also changes the original's value.
- !   Array<2,int,Brick> b(a);
-     b(0,0) = 5;
- !   std::cout << "After explicit initialization.\n";
- !   std::cout << "a: " << a(0,0) << std::endl;
- !   std::cout << "b: " << b(0,0) << std::endl;
-   
-     // Initialization of function arguments also uses reference semantics.
- !   std::cout << "After function call:\n";
-     changeValue(a);
- !   std::cout << "a: " << a(0,0) << std::endl;
- !   std::cout << "b: " << b(0,0) << std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 20,37 ----
-     // Explicit initialization uses reference semantics so changing the
-     // copy's value at (0,0) also changes the original's value.
- !   Array&lt;2,int,Brick&gt; b(a);
-     b(0,0) = 5;
- !   std::cout &openopen; "After explicit initialization.\n";
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
- !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
-   
-     // Initialization of function arguments also uses reference semantics.
- !   std::cout &openopen; "After function call:\n";
-     changeValue(a);
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
- !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d/array-size-annotated.patch
===================================================================
RCS file: array-size-annotated.patch
diff -N array-size-annotated.patch
*** /tmp/cvsrt0L1q	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,67 ****
- *** array-size.cpp	Tue Jan 15 12:59:40 2002
- --- array-size-annotated.cpp	Tue Jan 15 13:30:07 2002
- ***************
- *** 1,5 ****
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include <iostream>
-   
-   // Print an Array's Size
- --- 1,6 ----
- + <programlisting id="array-size-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include &lt;iostream&gt;
-   
-   // Print an Array's Size
- ***************
- *** 10,22 ****
-   // member functions.
-   
- ! template <int Dim, typename Type, typename EngineTag>
-   inline
- ! long computeArraySize(const Array<Dim,Type,EngineTag>& a)
-   {
- !   const Loc<Dim> fs = a.firsts();
- !   const Loc<Dim> ls = a.lasts();
- !   const Loc<Dim> lens = a.lengths();
-     long size = 1;
- !   for (int d = 0; d < Dim; ++d) {
-       size *= (ls[d] - fs[d] + 1).first();
-       // Check that lengths() and our computed lengths agree.
- --- 11,23 ----
-   // member functions.
-   
- ! template &lt;int Dim, typename Type, typename EngineTag&gt;
-   inline
- ! long computeArraySize(const Array&lt;Dim,Type,EngineTag&gt;&amp; a)
-   {
- !   const Loc&lt;Dim&gt; fs = a.firsts();
- !   const Loc&lt;Dim&gt; ls = a.lasts();
- !   const Loc&lt;Dim&gt; lens = a.lengths();
-     long size = 1;
- !   for (int d = 0; d &lt; Dim; ++d) {
-       size *= (ls[d] - fs[d] + 1).first();
-       // Check that lengths() and our computed lengths agree.
- ***************
- *** 30,38 ****
-     Pooma::initialize(argc,argv);
-   
- !   Array<3,int,Brick> a(3,4,5, ModelElement<int>(4));
-     PAssert(computeArraySize(a) == a.size());
- !   std::cout << "The array's size is " << a.size() << ".\n";
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 31,40 ----
-     Pooma::initialize(argc,argv);
-   
- !   Array&lt;3,int,Brick&gt; a(3,4,5, ModelElement&lt;int&gt;(4));
-     PAssert(computeArraySize(a) == a.size());
- !   std::cout &openopen; "The array's size is " &openopen; a.size() &openopen; ".\n";
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d/dynamicarray-annotated.patch
===================================================================
RCS file: dynamicarray-annotated.patch
diff -N dynamicarray-annotated.patch
*** /tmp/cvs0gWRWo	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,80 ****
- *** dynamicarray.cpp	Mon Jan 21 17:29:38 2002
- --- dynamicarray-annotated.cpp	Tue Jan 22 07:06:15 2002
- ***************
- *** 1,5 ****
-   #include "Pooma/Pooma.h"
- ! #include "Pooma/DynamicArrays.h"
- ! #include <iostream>
-   
-   // Demonstrate using DynamicArrays.
- --- 1,6 ----
- + <programlisting id="dynamicarray-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
- ! #include "Pooma/DynamicArrays.h"  <co id="arrays-dynamic_arrays-example-header"></co>
- ! #include &lt;iostream&gt;
-   
-   // Demonstrate using DynamicArrays.
- ***************
- *** 9,38 ****
-     Pooma::initialize(argc,argv);
-   
- !   // Create a DynamicArray with one element.
- !   DynamicArray<> d0(1);
- !   DynamicArray<double> d01(1);
- !   DynamicArray<double, Dynamic> d02(1);
-   
- !   // Add five more elements.
-     d0.create(5);
-     // Store values in the array.
- !   for (int i = d0.domain().first(); i <= d0.domain().last(); ++i)
- !     d0(i) = i;
-   
- !   // Delete every other element.
- !   d0.destroy(Range<1>(d0.domain().first(),d0.domain().last(),2), BackFill());
-   
-     // Print the resulting array.
- !   std::cout << d0 << std::endl;
-   
-     // Use the iterator form of 'destroy.'
- !   DynamicArray<> d1(6);
-     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
-       d1(i) = i;
- !   int killList[] = { 0, 2, 4 };
-     d1.destroy(killList, killList+3);
- !   std::cout << d1 << std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 10,40 ----
-     Pooma::initialize(argc,argv);
-   
- !   // Create a DynamicArray with one element.  <co id="arrays-dynamic_arrays-example-identical_declarations"></co>
- !   DynamicArray&lt;&gt; d0(1);
- !   DynamicArray&lt;double&gt; d01(1);
- !   DynamicArray&lt;double, Dynamic&gt; d02(1);
-   
- !   // Add five more elements.  <co id="arrays-dynamic_arrays-example-extension"></co>
-     d0.create(5);
-     // Store values in the array.
- !   for (int i = d0.domain().first(); i &lt;= d0.domain().last(); ++i)
- !     d0(i) = i;  <co id="arrays-dynamic_arrays-example-access"></co>
-   
- !   // Delete every other element.  <co id="arrays-dynamic_arrays-example-destroy_range"></co>
- !   d0.destroy(Range&lt;1&gt;(d0.domain().first(),d0.domain().last(),2), BackFill());
-   
-     // Print the resulting array.
- !   std::cout &openopen; d0 &openopen; std::endl;
-   
-     // Use the iterator form of 'destroy.'
- !   DynamicArray<&gt; d1(6);
-     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
-       d1(i) = i;
- !   int killList[] = { 0, 2, 4 };  <co id="arrays-dynamic_arrays-example-destroy_iterators"></co>
-     d1.destroy(killList, killList+3);
- !   std::cout &openopen; d1 &openopen; std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d/initialize-finalize-annotated.patch
===================================================================
RCS file: initialize-finalize-annotated.patch
diff -N initialize-finalize-annotated.patch
*** /tmp/cvsxFjk1o	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,20 ****
- *** initialize-finalize.cpp	Thu Jan 24 11:14:13 2002
- --- initialize-finalize-annotated.cpp	Thu Jan 24 11:14:17 2002
- ***************
- *** 1,4 ****
-   #include "Pooma/Pooma.h"
- ! #include <iostream>
-   
-   int main(int argc, char *argv[])
- --- 1,5 ----
- + <programlisting id="initialize-finalize-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
- ! #include &lt;iostream&gt;
-   
-   int main(int argc, char *argv[])
- ***************
- *** 11,12 ****
- --- 12,14 ----
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Doof2d/pairs-templated-annotated.patch
===================================================================
RCS file: pairs-templated-annotated.patch
diff -N pairs-templated-annotated.patch
*** /tmp/cvsq1PS0o	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,37 ****
- *** pairs-templated.cpp	Mon Jan  7 16:11:56 2002
- --- pairs-templated-annotated.cpp	Wed Jan 23 12:33:13 2002
- ***************
- *** 1,15 ****
-   // Declare a template class storing a pair of values with the same type.
- ! template <typename T>
-   struct pair {
- !   pair(const int& left, const int& right)
-       : left_(left), right_(right) {}
-   
- !   T left_;
-     T right_;
-   };
-   
- ! // Define a class storing a pair of integers.
- ! pair<int> pair1;
-   
- ! // Define a class storing a pair of doubles;
- ! pair<double> pair2;
- --- 1,17 ----
- + <programlisting id="template_programming-template_use-templated_pair_program" linenumbering="numbered" format="linespecific">
-   // Declare a template class storing a pair of values with the same type.
- ! template &lt;typename T&gt;  // <co id="template_programming-template_use-templated_pair_program-template_declaration"></co>
-   struct pair {
- !   pair(const T&amp; left, const T&amp; right)  // <co id="template_programming-template_use-templated_pair_program-constructor"></co>
-       : left_(left), right_(right) {}
-   
- !   T left_;  // <co id="template_programming-template_use-templated_pair_program-members"></co>
-     T right_;
-   };
-   
- ! // Use a class storing a pair of integers. <co id="template_programming-template_use-templated_pair_program-use"></co>
- ! pair&lt;int&gt; pair1;
-   
- ! // Use a class storing a pair of doubles;
- ! pair&lt;double&gt; pair2;
- ! </programlisting>
--- 0 ----
Index: examples/Sequential/Doof2d-Array-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Array-distributed-annotated.patch
diff -N Doof2d-Array-distributed-annotated.patch
*** /tmp/cvs5nG7Ho	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,184 ****
- *** Doof2d-Array-distributed.cpp	Wed Dec  5 14:04:36 2001
- --- Doof2d-Array-distributed-annotated.cpp	Wed Dec  5 14:07:56 2001
- ***************
- *** 1,3 ****
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
- --- 1,5 ----
- ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
- ***************
- *** 14,18 ****
-     // (i,j).  The "C" template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template <class C>
-     inline
-     typename C::Element_t
- --- 16,20 ----
-     // (i,j).  The "C" template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 42,46 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 44,48 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  <co id="tutorial-array_distributed-doof2d-io"></co>
-     Inform output;
-   
- ***************
- *** 48,52 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
-       return EXIT_FAILURE;
-     }
- --- 50,54 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 55,63 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 57,65 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 65,69 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 67,71 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 71,80 ****
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<2> interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- --- 73,82 ----
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- ***************
- *** 83,98 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.
- !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
- ! 				    GuardLayers<2>(1),  // internal
- ! 				    GuardLayers<2>(0)); // external
- !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
-   
-     // The Array template parameters indicate 2 dimensions and a 'double'
-     // value type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
- !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > b(layout);
-   
-     // Set up the initial conditions.
- --- 85,100 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.  <co id="tutorial-array_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // The Array template parameters indicate 2 dimensions and a 'double'
-     // value type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; b(layout);
-   
-     // Set up the initial conditions.
- ***************
- *** 104,112 ****
-   
-     // Create the stencil performing the computation.
- !   Stencil<DoofNinePt> stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 106,114 ----
-   
-     // Create the stencil performing the computation.
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_distributed-doof2d-first_write"></co>
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 117,121 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 119,123 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 125,126 ****
- --- 127,129 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Sequential/Doof2d-Array-element-annotated.patch
===================================================================
RCS file: Doof2d-Array-element-annotated.patch
diff -N Doof2d-Array-element-annotated.patch
*** /tmp/cvsyWNCZn	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,143 ****
- *** Doof2d-Array-element.cpp	Tue Dec  4 12:02:10 2001
- --- Doof2d-Array-element-annotated.cpp	Wed Jan 23 16:35:29 2002
- ***************
- *** 1,5 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
- ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
-   // Doof2d: POOMA Arrays, element-wise implementation
- --- 1,6 ----
- ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations  <co id="tutorial-array_elementwise-doof2d-header"></co>
-   
-   // Doof2d: POOMA Arrays, element-wise implementation
- ***************
- *** 7,17 ****
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the POOMA library for execution.
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 8,18 ----
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the POOMA library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,37 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
- !   // Create the arrays.
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
-     for (int j = 1; j < n-1; j++)
-       for (int i = 1; i < n-1; i++)
- --- 20,38 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).  <co id="tutorial-array_elementwise-doof2d-domain"></co>
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  <co id="tutorial-array_elementwise-doof2d-initialization"></co>
-     for (int j = 1; j < n-1; j++)
-       for (int i = 1; i < n-1; i++)
- ***************
- *** 43,51 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
- !         a(i,j) = weight *
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- --- 44,52 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
- !         a(i,j) = weight *  <co id="tutorial-array_elementwise-doof2d-first_write"></co>
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- ***************
- *** 53,58 ****
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- --- 54,59 ----
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- ***************
- *** 62,71 ****
-   
-     // Print out the final central value.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
- !   // The arrays are automatically deallocated.
-   
- !   // Tell the POOMA library execution has finished.
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- --- 63,74 ----
-   
-     // Print out the final central value.
- !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
- !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
-   
- !   // Tell the POOMA library execution has finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Sequential/Doof2d-Array-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Array-parallel-annotated.patch
diff -N Doof2d-Array-parallel-annotated.patch
*** /tmp/cvsV9LpYm	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,116 ****
- *** Doof2d-Array-parallel.cpp	Tue Dec  4 11:49:43 2001
- --- Doof2d-Array-parallel-annotated.cpp	Wed Jan 23 16:35:54 2002
- ***************
- *** 1,4 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
- --- 1,5 ----
- ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,43 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Create the arrays.
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- --- 20,44 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.  <co id="tutorial-array_parallel-doof2d-innerdomain"></co>
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Create the arrays.
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.  <co id="tutorial-array_parallel-doof2d-blockAndEvaluate"></co>
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- ***************
- *** 47,52 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 48,53 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_parallel-doof2d-first_write"></co>
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 63,67 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 64,68 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 71,72 ****
- --- 72,74 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Sequential/Doof2d-Array-stencil-annotated.patch
===================================================================
RCS file: Doof2d-Array-stencil-annotated.patch
diff -N Doof2d-Array-stencil-annotated.patch
*** /tmp/cvscMIWSn	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,152 ****
- *** Doof2d-Array-stencil.cpp	Tue Dec  4 11:49:39 2001
- --- Doof2d-Array-stencil-annotated.cpp	Wed Jan 23 16:36:15 2002
- ***************
- *** 1,9 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
-   // Doof2d: POOMA Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.
-   class DoofNinePt
-   {
- --- 1,10 ----
- ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
-   // Doof2d: POOMA Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
-   class DoofNinePt
-   {
- ***************
- *** 14,19 ****
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.
- !   template <class C>
-     inline
-     typename C::Element_t
- --- 15,20 ----
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.  <co id="tutorial-array_stencil-doof2d-stencil_operator"></co>
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 26,30 ****
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }
-     inline int upperExtent(int) const { return 1; }
-   
- --- 27,31 ----
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }  <co id="tutorial-array_stencil-doof2d-stencil_extent"></co>
-     inline int upperExtent(int) const { return 1; }
-   
- ***************
- *** 42,47 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 43,48 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 49,68 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<2> interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
- --- 50,69 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- ***************
- *** 73,82 ****
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.
- !   Stencil<DoofNinePt> stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 74,83 ----
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil_creation"></co>
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_stencil-doof2d-first_write"></co>
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 87,91 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 88,92 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 95,96 ****
- --- 96,98 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Sequential/Doof2d-C-element-annotated.patch
===================================================================
RCS file: Doof2d-C-element-annotated.patch
diff -N Doof2d-C-element-annotated.patch
*** /tmp/cvsfhxNpo	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,150 ****
- *** Doof2d-C-element.cpp	Tue Dec  4 09:59:18 2001
- --- Doof2d-C-element-annotated.cpp	Wed Jan 23 16:34:20 2002
- ***************
- *** 1,4 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- --- 1,5 ----
- ! <programlisting id="tutorial-hand_coded-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- ***************
- *** 6,30 ****
-   int main()
-   {
- !   // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of values along one dimension of
- !   // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
- !   // Allocate the arrays.
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i < n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- --- 7,31 ----
-   int main()
-   {
- !   // Ask the user for the number of averagings.  <co id="tutorial-hand_coded-doof2d-nuaveragings"></co>
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.  <co id="tutorial-hand_coded-doof2d-array_storage"></co>
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of values along one dimension of
- !   // the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
- !   // Allocate the arrays.  <co id="tutorial-hand_coded-doof2d-allocation"></co>
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i &lt; n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- ***************
- *** 32,49 ****
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
- !   for (int j = 0; j < n; j++)
- !     for (int i = 0; i < n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- --- 33,50 ----
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  <co id="tutorial-hand_coded-doof2d-initialization"></co>
- !   for (int j = 0; j &lt; n; j++)
- !     for (int i = 0; i &lt; n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.  <co id="tutorial-hand_coded-doof2d-constants"></co>
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-hand_coded-doof2d-first_write"></co>
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- ***************
- *** 51,57 ****
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- --- 52,58 ----
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.  <co id="tutorial-hand_coded-doof2d-second_write"></co>
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- ***************
- *** 60,68 ****
-     }
-   
- !   // Print out the final central value.
- !   std::cout << (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) << std::endl;
-   
- !   // Deallocate the arrays.
- !   for (int i = 0; i < n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- --- 61,69 ----
-     }
-   
- !   // Print out the final central value.  <co id="tutorial-hand_coded-doof2d-answer"></co>
- !   std::cout &openopen; (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) &openopen; std::endl;
-   
- !   // Deallocate the arrays.  <co id="tutorial-hand_coded-doof2d-deallocation"></co>
- !   for (int i = 0; i &lt; n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- ***************
- *** 73,74 ****
- --- 74,76 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Sequential/Doof2d-Field-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Field-distributed-annotated.patch
diff -N Doof2d-Field-distributed-annotated.patch
*** /tmp/cvsCgy7wo	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,176 ****
- *** Doof2d-Field-distributed.cpp	Wed Dec  5 14:05:10 2001
- --- Doof2d-Field-distributed-annotated.cpp	Wed Jan 23 16:36:34 2002
- ***************
- *** 1,3 ****
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Fields.h"	// has POOMA's Field declarations
-   
- --- 1,4 ----
- ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Fields.h"	// has POOMA's Field declarations
-   
- ***************
- *** 12,16 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 13,17 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  <co id="tutorial-field_distributed-doof2d-io"></co>
-     Inform output;
-   
- ***************
- *** 18,22 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
-       return EXIT_FAILURE;
-     }
- --- 19,23 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 25,33 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 26,34 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 35,39 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 36,40 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 41,50 ****
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- --- 42,51 ----
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- ***************
- *** 52,74 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.
- !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
- ! 				    GuardLayers<2>(1),  // internal
- ! 				    GuardLayers<2>(0)); // external
- !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
- !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
-   
-     // The Field template parameters indicate a mesh and a 'double'
-     // value type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
- !     Remote<Brick> > > a(cell, layout, mesh);
- !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
- !     Remote<Brick> > > b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 53,75 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.  <co id="tutorial-field_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  <co id="tutorial-field_distributed-doof2d-mesh"></co>
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // The Field template parameters indicate a mesh and a 'double'
-     // value type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 83,87 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- --- 84,88 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- ***************
- *** 99,103 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The fields are automatically deallocated.
- --- 100,104 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 107,108 ****
- --- 108,110 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Sequential/Doof2d-Field-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Field-parallel-annotated.patch
diff -N Doof2d-Field-parallel-annotated.patch
*** /tmp/cvsLMrrLq	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,120 ****
- *** Doof2d-Field-parallel.cpp	Tue Dec  4 11:47:58 2001
- --- Doof2d-Field-parallel-annotated.cpp	Wed Jan 23 16:37:19 2002
- ***************
- *** 1,5 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
- ! #include "Pooma/Fields.h"	// has POOMA's Field declarations
-   
-   // Doof2d: POOMA Fields, data-parallel implementation
- --- 1,6 ----
- ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include "Pooma/Fields.h"	// has POOMA's Field declarations  <co id="tutorial-field_parallel-doof2d-header"></co>
-   
-   // Doof2d: POOMA Fields, data-parallel implementation
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,44 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the field size: ";
- !   std::cin >> n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   DomainLayout<2> layout(vertDomain);
- !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
- !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The Field template parameters indicate a mesh, a 'double' value
- !   // type, and ordinary 'Brick' storage.
- !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
- !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 20,45 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the field size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  <co id="tutorial-field_parallel-doof2d-mesh"></co>
- !   DomainLayout&lt;2&gt; layout(vertDomain);
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The Field template parameters indicate a mesh, a 'double' value
- !   // type, and ordinary 'Brick' storage.  <co id="tutorial-field_parallel-doof2d-field_creation"></co>
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 53,58 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 54,59 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-field_parallel-doof2d-first_write"></co>
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 69,73 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The fields are automatically deallocated.
- --- 70,74 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 77,78 ****
- --- 78,80 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Sequential/array-copy-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/array-copy-annotated.patch,v
retrieving revision 1.1
diff -c -p -r1.1 array-copy-annotated.patch
*** examples/Sequential/array-copy-annotated.patch	2002/01/25 03:27:30	1.1
--- examples/Sequential/array-copy-annotated.patch	2002/01/31 21:52:13
***************
*** 1,5 ****
  *** array-copy.cpp	Thu Jan 24 11:12:23 2002
! --- array-copy-annotated.cpp	Thu Jan 24 11:12:49 2002
  ***************
  *** 1,8 ****
    #include "Pooma/Pooma.h"
--- 1,5 ----
  *** array-copy.cpp	Thu Jan 24 11:12:23 2002
! --- array-copy-annotated.cpp	Thu Jan 31 09:22:57 2002
  ***************
  *** 1,8 ****
    #include "Pooma/Pooma.h"
***************
*** 21,27 ****
    { z(0,0) = 6; }
    
  ***************
! *** 11,17 ****
      Pooma::initialize(argc,argv);
    
  !   Array<2,int,Brick> a(3,4, ModelElement<int>(4));
--- 21,27 ----
    { z(0,0) = 6; }
    
  ***************
! *** 11,35 ****
      Pooma::initialize(argc,argv);
    
  !   Array<2,int,Brick> a(3,4, ModelElement<int>(4));
***************
*** 29,53 ****
  !   std::cout << "a: " << a(0,0) << std::endl;
    
      // Array copies share the same underlying values.
- --- 12,18 ----
-     Pooma::initialize(argc,argv);
-   
- !   Array&lt;2,int,Brick&gt; a(3,4, ModelElement&lt;int&gt;(4));
- !   std::cout &openopen; "Initial value:\n";
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
    
!     // Array copies share the same underlying values.
! ***************
! *** 19,35 ****
!     // Explicit initialization uses reference semantics so changing the
!     // copy's value at (0,0) also changes the original's value.
  !   Array<2,int,Brick> b(a);
      b(0,0) = 5;
  !   std::cout << "After explicit initialization.\n";
  !   std::cout << "a: " << a(0,0) << std::endl;
  !   std::cout << "b: " << b(0,0) << std::endl;
!   
!     // Initialization of function arguments also uses reference semantics.
  !   std::cout << "After function call:\n";
      changeValue(a);
  !   std::cout << "a: " << a(0,0) << std::endl;
--- 29,44 ----
  !   std::cout << "a: " << a(0,0) << std::endl;
    
      // Array copies share the same underlying values.
    
! !   // Explicit initialization uses reference semantics so changing the
! !   // copy's value at (0,0) also changes the original's value.
  !   Array<2,int,Brick> b(a);
      b(0,0) = 5;
  !   std::cout << "After explicit initialization.\n";
  !   std::cout << "a: " << a(0,0) << std::endl;
  !   std::cout << "b: " << b(0,0) << std::endl;
! ! 
! !   // Initialization of function arguments also uses reference semantics.
  !   std::cout << "After function call:\n";
      changeValue(a);
  !   std::cout << "a: " << a(0,0) << std::endl;
***************
*** 56,71 ****
      Pooma::finalize();
      return 0;
    }
! --- 20,37 ----
!     // Explicit initialization uses reference semantics so changing the
!     // copy's value at (0,0) also changes the original's value.
  !   Array&lt;2,int,Brick&gt; b(a);
      b(0,0) = 5;
  !   std::cout &openopen; "After explicit initialization.\n";
  !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
  !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
!   
!     // Initialization of function arguments also uses reference semantics.
  !   std::cout &openopen; "After function call:\n";
      changeValue(a);
  !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
--- 47,72 ----
      Pooma::finalize();
      return 0;
    }
! --- 12,39 ----
!     Pooma::initialize(argc,argv);
!   
! !   Array&lt;2,int,Brick&gt; a(3,4, ModelElement&lt;int&gt;(4));
! !   std::cout &openopen; "Initial value:\n";
! !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
!   
!     // Array copies share the same underlying values.
!   
! !   // Explicit initialization uses reference semantics
! !   // so changing the copy's value at (0,0) also
! !   // changes the original's value.
  !   Array&lt;2,int,Brick&gt; b(a);
      b(0,0) = 5;
  !   std::cout &openopen; "After explicit initialization.\n";
  !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
  !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
! ! 
! !   // Initialization of function arguments also uses
! !   // reference semantics.
  !   std::cout &openopen; "After function call:\n";
      changeValue(a);
  !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
Index: examples/Sequential/array-size-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/array-size-annotated.patch,v
retrieving revision 1.1
diff -c -p -r1.1 array-size-annotated.patch
*** examples/Sequential/array-size-annotated.patch	2002/01/25 03:27:30	1.1
--- examples/Sequential/array-size-annotated.patch	2002/01/31 21:52:13
***************
*** 1,21 ****
! *** array-size.cpp	Tue Jan 15 12:59:40 2002
! --- array-size-annotated.cpp	Tue Jan 15 13:30:07 2002
  ***************
! *** 1,5 ****
    #include "Pooma/Pooma.h"
    #include "Pooma/Arrays.h"
  ! #include <iostream>
    
    // Print an Array's Size
- --- 1,6 ----
- + <programlisting id="array-size-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include &lt;iostream&gt;
    
!   // Print an Array's Size
! ***************
! *** 10,22 ****
    // member functions.
    
  ! template <int Dim, typename Type, typename EngineTag>
--- 1,16 ----
! *** array-size.cpp	Tue Jan 15 13:30:53 2002
! --- array-size-annotated.cpp	Thu Jan 31 09:24:16 2002
  ***************
! *** 1,25 ****
    #include "Pooma/Pooma.h"
    #include "Pooma/Arrays.h"
  ! #include <iostream>
    
    // Print an Array's Size
    
! ! // This program illustrates using the Array member functions.
! ! // computeArraySize's computation is redundant because Array's size()
! ! // function computes the same value, but it illustrates using Array
    // member functions.
    
  ! template <int Dim, typename Type, typename EngineTag>
***************
*** 27,65 ****
  !   const Loc<Dim> lens = a.lengths();
      long size = 1;
  !   for (int d = 0; d < Dim; ++d) {
!       size *= (ls[d] - fs[d] + 1).first();
        // Check that lengths() and our computed lengths agree.
! --- 11,23 ----
    // member functions.
    
! ! template &lt;int Dim, typename Type, typename EngineTag&gt;
    inline
  ! long computeArraySize(const Array&lt;Dim,Type,EngineTag&gt;&amp; a)
    {
! !   const Loc&lt;Dim&gt; fs = a.firsts();
  !   const Loc&lt;Dim&gt; ls = a.lasts();
  !   const Loc&lt;Dim&gt; lens = a.lengths();
      long size = 1;
  !   for (int d = 0; d &lt; Dim; ++d) {
!       size *= (ls[d] - fs[d] + 1).first();
        // Check that lengths() and our computed lengths agree.
  ***************
  *** 30,38 ****
      Pooma::initialize(argc,argv);
    
  !   Array<3,int,Brick> a(3,4,5, ModelElement<int>(4));
!     PAssert(computeArraySize(a) == a.size());
  !   std::cout << "The array's size is " << a.size() << ".\n";
    
      Pooma::finalize();
      return 0;
    }
! --- 31,40 ----
      Pooma::initialize(argc,argv);
    
  !   Array&lt;3,int,Brick&gt; a(3,4,5, ModelElement&lt;int&gt;(4));
!     PAssert(computeArraySize(a) == a.size());
! !   std::cout &openopen; "The array's size is " &openopen; a.size() &openopen; ".\n";
    
      Pooma::finalize();
      return 0;
--- 22,78 ----
  !   const Loc<Dim> lens = a.lengths();
      long size = 1;
  !   for (int d = 0; d < Dim; ++d) {
! !     size *= lens[d].first();
        // Check that lengths() and our computed lengths agree.
! !     PAssert((ls[d] - fs[d] + 1).first() == a.length(d));
!     }
!     return size;
! --- 1,27 ----
! + <programlisting id="array-size-program" linenumbering="numbered" format="linespecific">
!   #include "Pooma/Pooma.h"
!   #include "Pooma/Arrays.h"
! ! #include &lt;iostream&gt;
!   
!   // Print an Array's Size
!   
! ! // This program illustrates using the Array member
! ! // functions.  computeArraySize's computation is
! ! // redundant because Array's size() function computes
! ! // the same value, but it illustrates using Array
    // member functions.
    
! ! template &lt;int Dim,typename Type,typename EngineTag&gt;  <co id="arrays-arrays_use-members-example-template_parameters"></co>
    inline
  ! long computeArraySize(const Array&lt;Dim,Type,EngineTag&gt;&amp; a)
    {
! !   const Loc&lt;Dim&gt; fs = a.firsts();  <co id="arrays-arrays_use-members-example-function_call"></co>
  !   const Loc&lt;Dim&gt; ls = a.lasts();
  !   const Loc&lt;Dim&gt; lens = a.lengths();
      long size = 1;
  !   for (int d = 0; d &lt; Dim; ++d) {
! !     size *= lens[d].first();  <co id="arrays-arrays_use-members-example-loc_use"></co>
        // Check that lengths() and our computed lengths agree.
+ !     PAssert((ls[d]-fs[d]+1).first()==a.length(d));  <co id="arrays-arrays_use-members-example-check_length"></co>
+     }
+     return size;
  ***************
  *** 30,38 ****
      Pooma::initialize(argc,argv);
    
  !   Array<3,int,Brick> a(3,4,5, ModelElement<int>(4));
! !   PAssert(computeArraySize(a) == a.size());
  !   std::cout << "The array's size is " << a.size() << ".\n";
    
      Pooma::finalize();
      return 0;
    }
! --- 32,42 ----
      Pooma::initialize(argc,argv);
    
  !   Array&lt;3,int,Brick&gt; a(3,4,5, ModelElement&lt;int&gt;(4));
! !   PAssert(computeArraySize(a) == a.size());  <co id="arrays-arrays_use-members-example-compare_size"></co>
! !   std::cout &openopen;
! !     "The array's size is " &openopen; a.size() &openopen; ".\n";
    
      Pooma::finalize();
      return 0;
Index: examples/Sequential/pairs-templated-annotated.patch
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/programs/Attic/pairs-templated-annotated.patch,v
retrieving revision 1.4
diff -c -p -r1.4 pairs-templated-annotated.patch
*** examples/Sequential/pairs-templated-annotated.patch	2002/01/25 03:27:30	1.4
--- examples/Sequential/pairs-templated-annotated.patch	2002/01/31 21:52:13
***************
*** 1,8 ****
  *** pairs-templated.cpp	Mon Jan  7 16:11:56 2002
! --- pairs-templated-annotated.cpp	Wed Jan 23 12:33:13 2002
  ***************
  *** 1,15 ****
!   // Declare a template class storing a pair of values with the same type.
  ! template <typename T>
    struct pair {
  !   pair(const int& left, const int& right)
--- 1,8 ----
  *** pairs-templated.cpp	Mon Jan  7 16:11:56 2002
! --- pairs-templated-annotated.cpp	Thu Jan 31 08:44:35 2002
  ***************
  *** 1,15 ****
! ! // Declare a template class storing a pair of values with the same type.
  ! template <typename T>
    struct pair {
  !   pair(const int& left, const int& right)
***************
*** 17,25 ****
    
  ! // Define a class storing a pair of doubles;
  ! pair<double> pair2;
! --- 1,17 ----
! + <programlisting id="template_programming-template_use-templated_pair_program" linenumbering="numbered" format="linespecific">
!   // Declare a template class storing a pair of values with the same type.
  ! template &lt;typename T&gt;  // <co id="template_programming-template_use-templated_pair_program-template_declaration"></co>
    struct pair {
  !   pair(const T&amp; left, const T&amp; right)  // <co id="template_programming-template_use-templated_pair_program-constructor"></co>
--- 17,26 ----
    
  ! // Define a class storing a pair of doubles;
  ! pair<double> pair2;
! --- 1,18 ----
! ! <programlisting id="template_programming-template_use-templated_pair_program" linenumbering="numbered" format="linespecific">
! ! // Declare a template class storing a pair of values
! ! // with the same type.
  ! template &lt;typename T&gt;  // <co id="template_programming-template_use-templated_pair_program-template_declaration"></co>
    struct pair {
  !   pair(const T&amp; left, const T&amp; right)  // <co id="template_programming-template_use-templated_pair_program-constructor"></co>
Index: examples/Sequential/pairs-untemplated-annotated.patch
===================================================================
RCS file: pairs-untemplated-annotated.patch
diff -N pairs-untemplated-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- pairs-untemplated-annotated.patch	Thu Jan 31 14:52:13 2002
***************
*** 0 ****
--- 1,35 ----
+ *** pairs-untemplated.cpp	Wed Dec 26 13:48:10 2001
+ --- pairs-untemplated-annotated.cpp	Wed Dec 26 14:02:58 2001
+ ***************
+ *** 1,5 ****
+   // Declare a class storing a pair of integers.
+   struct pairOfInts {
+ !   pairOfInts(const int& left, const int& right)
+       : left_(left), right_(right) {}
+   
+ --- 1,6 ----
+ + <programlisting id="template_programming-template_use-untemplated_pair_program" linenumbering="numbered" format="linespecific">
+   // Declare a class storing a pair of integers.
+   struct pairOfInts {
+ !   pairOfInts(const int&amp; left, const int&amp; right)
+       : left_(left), right_(right) {}
+   
+ ***************
+ *** 10,14 ****
+   // Declare a class storing a pair of doubles.
+   struct pairOfDoubles {
+ !   pairOfDoubles(const double& left, const double& right)
+       : left_(left), right_(right) {}
+   
+ --- 11,15 ----
+   // Declare a class storing a pair of doubles.
+   struct pairOfDoubles {
+ !   pairOfDoubles(const double&amp; left, const double&amp; right)
+       : left_(left), right_(right) {}
+   
+ ***************
+ *** 16,17 ****
+ --- 17,19 ----
+     double right_;
+   };
+ + </programlisting>
Index: examples/Templates/Doof2d-Array-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Array-distributed-annotated.patch
diff -N Doof2d-Array-distributed-annotated.patch
*** /tmp/cvsXqyFoA	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,184 ****
- *** Doof2d-Array-distributed.cpp	Wed Dec  5 14:04:36 2001
- --- Doof2d-Array-distributed-annotated.cpp	Wed Dec  5 14:07:56 2001
- ***************
- *** 1,3 ****
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
- --- 1,5 ----
- ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
- ***************
- *** 14,18 ****
-     // (i,j).  The "C" template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template <class C>
-     inline
-     typename C::Element_t
- --- 16,20 ----
-     // (i,j).  The "C" template parameter permits use of this stencil
-     // operator with both Arrays and Fields.
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 42,46 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 44,48 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  <co id="tutorial-array_distributed-doof2d-io"></co>
-     Inform output;
-   
- ***************
- *** 48,52 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
-       return EXIT_FAILURE;
-     }
- --- 50,54 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 55,63 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 57,65 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 65,69 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 67,71 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 71,80 ****
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<2> interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- --- 73,82 ----
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the distributed arrays.
- ***************
- *** 83,98 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.
- !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
- ! 				    GuardLayers<2>(1),  // internal
- ! 				    GuardLayers<2>(0)); // external
- !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
-   
-     // The Array template parameters indicate 2 dimensions and a 'double'
-     // value type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
- !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > b(layout);
-   
-     // Set up the initial conditions.
- --- 85,100 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire array domain.  <co id="tutorial-array_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // The Array template parameters indicate 2 dimensions and a 'double'
-     // value type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; a(layout);
- !   Array&lt;2, double, MultiPatch&lt;UniformTag, Remote&lt;Brick&gt; &gt; &gt; b(layout);
-   
-     // Set up the initial conditions.
- ***************
- *** 104,112 ****
-   
-     // Create the stencil performing the computation.
- !   Stencil<DoofNinePt> stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 106,114 ----
-   
-     // Create the stencil performing the computation.
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_distributed-doof2d-first_write"></co>
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 117,121 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 119,123 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 125,126 ****
- --- 127,129 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/Doof2d-Array-element-annotated.patch
===================================================================
RCS file: Doof2d-Array-element-annotated.patch
diff -N Doof2d-Array-element-annotated.patch
*** /tmp/cvsu9r3UC	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,143 ****
- *** Doof2d-Array-element.cpp	Tue Dec  4 12:02:10 2001
- --- Doof2d-Array-element-annotated.cpp	Wed Jan 23 16:35:29 2002
- ***************
- *** 1,5 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
- ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
-   // Doof2d: POOMA Arrays, element-wise implementation
- --- 1,6 ----
- ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations  <co id="tutorial-array_elementwise-doof2d-header"></co>
-   
-   // Doof2d: POOMA Arrays, element-wise implementation
- ***************
- *** 7,17 ****
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the POOMA library for execution.
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 8,18 ----
-   int main(int argc, char *argv[])
-   {
- !   // Prepare the POOMA library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
-     Pooma::initialize(argc,argv);
-     
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,37 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
- !   // Create the arrays.
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
-     for (int j = 1; j < n-1; j++)
-       for (int i = 1; i < n-1; i++)
- --- 20,38 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
- !   // Specify the arrays' domains [0,n) x [0,n).  <co id="tutorial-array_elementwise-doof2d-domain"></co>
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  <co id="tutorial-array_elementwise-doof2d-initialization"></co>
-     for (int j = 1; j < n-1; j++)
-       for (int i = 1; i < n-1; i++)
- ***************
- *** 43,51 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
- !         a(i,j) = weight *
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- --- 44,52 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
- !         a(i,j) = weight *  <co id="tutorial-array_elementwise-doof2d-first_write"></co>
-             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
-              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
- ***************
- *** 53,58 ****
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- --- 54,59 ----
-   
-       // Read from a.  Write to b.
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b(i,j) = weight *
-             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
- ***************
- *** 62,71 ****
-   
-     // Print out the final central value.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
- !   // The arrays are automatically deallocated.
-   
- !   // Tell the POOMA library execution has finished.
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- --- 63,74 ----
-   
-     // Print out the final central value.
- !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
- !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
-   
- !   // Tell the POOMA library execution has finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
-     Pooma::finalize();
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/Doof2d-Array-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Array-parallel-annotated.patch
diff -N Doof2d-Array-parallel-annotated.patch
*** /tmp/cvs9dVaoH	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,116 ****
- *** Doof2d-Array-parallel.cpp	Tue Dec  4 11:49:43 2001
- --- Doof2d-Array-parallel-annotated.cpp	Wed Jan 23 16:35:54 2002
- ***************
- *** 1,4 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
- --- 1,5 ----
- ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,43 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Create the arrays.
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- --- 20,44 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
- !   // Set up interior domains [1,n-1) x [1,n-1) for computation.  <co id="tutorial-array_parallel-doof2d-innerdomain"></co>
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Create the arrays.
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
-     // All grid values should be zero except for the central value.
-     a = b = 0.0;
- !   // Ensure all data-parallel computation finishes before accessing a value.  <co id="tutorial-array_parallel-doof2d-blockAndEvaluate"></co>
-     Pooma::blockAndEvaluate();
-     b(n/2,n/2) = 1000.0;
- ***************
- *** 47,52 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 48,53 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_parallel-doof2d-first_write"></co>
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 63,67 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 64,68 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 71,72 ****
- --- 72,74 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/Doof2d-Array-stencil-annotated.patch
===================================================================
RCS file: Doof2d-Array-stencil-annotated.patch
diff -N Doof2d-Array-stencil-annotated.patch
*** /tmp/cvsasNZwL	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,152 ****
- *** Doof2d-Array-stencil.cpp	Tue Dec  4 11:49:39 2001
- --- Doof2d-Array-stencil-annotated.cpp	Wed Jan 23 16:36:15 2002
- ***************
- *** 1,9 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
-   // Doof2d: POOMA Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.
-   class DoofNinePt
-   {
- --- 1,10 ----
- ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Arrays.h"	// has POOMA's Array declarations
-   
-   // Doof2d: POOMA Arrays, stencil implementation
-   
- ! // Define the stencil class performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
-   class DoofNinePt
-   {
- ***************
- *** 14,19 ****
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.
- !   template <class C>
-     inline
-     typename C::Element_t
- --- 15,20 ----
-     // This stencil operator is applied to each interior domain position
-     // (i,j).  The "C" template parameter permits use of this stencil
- !   // operator with both Arrays and Fields.  <co id="tutorial-array_stencil-doof2d-stencil_operator"></co>
- !   template &lt;class C&gt;
-     inline
-     typename C::Element_t
- ***************
- *** 26,30 ****
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }
-     inline int upperExtent(int) const { return 1; }
-   
- --- 27,31 ----
-     }
-   
- !   inline int lowerExtent(int) const { return 1; }  <co id="tutorial-array_stencil-doof2d-stencil_extent"></co>
-     inline int upperExtent(int) const { return 1; }
-   
- ***************
- *** 42,47 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 43,48 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 49,68 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<2> interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array<2, double, Brick> a(vertDomain);
- !   Array<2, double, Brick> b(vertDomain);
-   
-     // Set up the initial conditions.
- --- 50,69 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the arrays' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;2&gt; interiorDomain(I,I);
-   
-     // Create the arrays.
-     // The Array template parameters indicate 2 dimensions, a 'double' value
-     // type, and ordinary 'Brick' storage.
- !   Array&lt;2, double, Brick&gt; a(vertDomain);
- !   Array&lt;2, double, Brick&gt; b(vertDomain);
-   
-     // Set up the initial conditions.
- ***************
- *** 73,82 ****
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.
- !   Stencil<DoofNinePt> stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- --- 74,83 ----
-     b(n/2,n/2) = 1000.0;
-   
- !   // Create the stencil performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil_creation"></co>
- !   Stencil&lt;DoofNinePt&gt; stencil;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-array_stencil-doof2d-first_write"></co>
-       a(interiorDomain) = stencil(b, interiorDomain);
-   
- ***************
- *** 87,91 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The arrays are automatically deallocated.
- --- 88,92 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The arrays are automatically deallocated.
- ***************
- *** 95,96 ****
- --- 96,98 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/Doof2d-C-element-annotated.patch
===================================================================
RCS file: Doof2d-C-element-annotated.patch
diff -N Doof2d-C-element-annotated.patch
*** /tmp/cvsT2P9dR	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,150 ****
- *** Doof2d-C-element.cpp	Tue Dec  4 09:59:18 2001
- --- Doof2d-C-element-annotated.cpp	Wed Jan 23 16:34:20 2002
- ***************
- *** 1,4 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- --- 1,5 ----
- ! <programlisting id="tutorial-hand_coded-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   
-   // Doof2d: C-like, element-wise implementation
- ***************
- *** 6,30 ****
-   int main()
-   {
- !   // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of values along one dimension of
- !   // the grid.
-     long n;
- !   std::cout << "Please enter the array size: ";
- !   std::cin >> n;
-   
- !   // Allocate the arrays.
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i < n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- --- 7,31 ----
-   int main()
-   {
- !   // Ask the user for the number of averagings.  <co id="tutorial-hand_coded-doof2d-nuaveragings"></co>
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- !   // Use two-dimensional grids of values.  <co id="tutorial-hand_coded-doof2d-array_storage"></co>
-     double **a;
-     double **b;
-   
-     // Ask the user for the number n of values along one dimension of
- !   // the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
-     long n;
- !   std::cout &openopen; "Please enter the array size: ";
- !   std::cin &closeclose; n;
-   
- !   // Allocate the arrays.  <co id="tutorial-hand_coded-doof2d-allocation"></co>
-     typedef double* doublePtr;
-     a = new doublePtr[n];
-     b = new doublePtr[n];
- !   for (int i = 0; i &lt; n; i++) {
-       a[i] = new double[n];
-       b[i] = new double[n];
- ***************
- *** 32,49 ****
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.
- !   for (int j = 0; j < n; j++)
- !     for (int i = 0; i < n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- --- 33,50 ----
-   
-     // Set up the initial conditions.
- !   // All grid values should be zero except for the central value.  <co id="tutorial-hand_coded-doof2d-initialization"></co>
- !   for (int j = 0; j &lt; n; j++)
- !     for (int i = 0; i &lt; n; i++)
-         a[i][j] = b[i][j] = 0.0;
-     b[n/2][n/2] = 1000.0;
-   
- !   // In the average, weight elements with this value.  <co id="tutorial-hand_coded-doof2d-constants"></co>
-     const double weight = 1.0/9.0;
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-hand_coded-doof2d-first_write"></co>
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           a[i][j] = weight *
-             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
- ***************
- *** 51,57 ****
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.
- !     for (int j = 1; j < n-1; j++)
- !       for (int i = 1; i < n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- --- 52,58 ----
-              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
-   
- !     // Read from a.  Write to b.  <co id="tutorial-hand_coded-doof2d-second_write"></co>
- !     for (int j = 1; j &lt; n-1; j++)
- !       for (int i = 1; i &lt; n-1; i++)
-           b[i][j] = weight *
-             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
- ***************
- *** 60,68 ****
-     }
-   
- !   // Print out the final central value.
- !   std::cout << (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) << std::endl;
-   
- !   // Deallocate the arrays.
- !   for (int i = 0; i < n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- --- 61,69 ----
-     }
-   
- !   // Print out the final central value.  <co id="tutorial-hand_coded-doof2d-answer"></co>
- !   std::cout &openopen; (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) &openopen; std::endl;
-   
- !   // Deallocate the arrays.  <co id="tutorial-hand_coded-doof2d-deallocation"></co>
- !   for (int i = 0; i &lt; n; i++) {
-       delete [] a[i];
-       delete [] b[i];
- ***************
- *** 73,74 ****
- --- 74,76 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/Doof2d-Field-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Field-distributed-annotated.patch
diff -N Doof2d-Field-distributed-annotated.patch
*** /tmp/cvsAOUbGW	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,176 ****
- *** Doof2d-Field-distributed.cpp	Wed Dec  5 14:05:10 2001
- --- Doof2d-Field-distributed-annotated.cpp	Wed Jan 23 16:36:34 2002
- ***************
- *** 1,3 ****
- ! #include <stdlib.h>		// has EXIT_SUCCESS
-   #include "Pooma/Fields.h"	// has POOMA's Field declarations
-   
- --- 1,4 ----
- ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
-   #include "Pooma/Fields.h"	// has POOMA's Field declarations
-   
- ***************
- *** 12,16 ****
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.
-     Inform output;
-   
- --- 13,17 ----
-     // canot use standard input and output.  Instead we use command-line
-     // arguments, which are replicated, for input, and we use an Inform
- !   // stream for output.  <co id="tutorial-field_distributed-doof2d-io"></co>
-     Inform output;
-   
- ***************
- *** 18,22 ****
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
-       return EXIT_FAILURE;
-     }
- --- 19,23 ----
-     if (argc != 4) {
-       // Incorrect number of command-line arguments.
- !     output &openopen; argv[0] &openopen; ": number-of-processors number-of-averagings number-of-values" &openopen; std::endl;
-       return EXIT_FAILURE;
-     }
- ***************
- *** 25,33 ****
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 26,34 ----
-     // Determine the number of processors.
-     long nuProcessors;
- !   nuProcessors = strtol(argv[1], &amp;tail, 0);
-   
-     // Determine the number of averagings.
-     long nuAveragings, nuIterations;
- !   nuAveragings = strtol(argv[2], &amp;tail, 0);
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 35,39 ****
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- --- 36,40 ----
-     // the grid.
-     long n;
- !   n = strtol(argv[3], &amp;tail, 0);
-     // The dimension must be a multiple of the number of processors
-     // since we are using a UniformGridLayout.
- ***************
- *** 41,50 ****
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- --- 42,51 ----
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Partition the fields' domains uniformly, i.e., each patch has the
- ***************
- *** 52,74 ****
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.
- !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
- ! 				    GuardLayers<2>(1),  // internal
- ! 				    GuardLayers<2>(0)); // external
- !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
- !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
-   
-     // The Field template parameters indicate a mesh and a 'double'
-     // value type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.
- !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
- !     Remote<Brick> > > a(cell, layout, mesh);
- !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
- !     Remote<Brick> > > b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 53,75 ----
-     // dimension.  Guard layers optimize communication between patches.
-     // Internal guards surround each patch.  External guards surround
- !   // the entire field domain.  <co id="tutorial-field_distributed-doof2d-layout"></co>
- !   UniformGridPartition&lt;2&gt; partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
- ! 				    GuardLayers&lt;2&gt;(1),  // internal
- ! 				    GuardLayers&lt;2&gt;(0)); // external
- !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition, DistributedTag());
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  <co id="tutorial-field_distributed-doof2d-mesh"></co>
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // The Field template parameters indicate a mesh and a 'double'
-     // value type.  MultiPatch indicates multiple computation patches,
-     // i.e., distributed computation.  The UniformTag indicates the
- !   // patches should have the same size.  Each patch has Brick type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, MultiPatch&lt;UniformTag,
- !     Remote&lt;Brick&gt; &gt; &gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 83,87 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- --- 84,88 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
-       // Read from b.  Write to a.
-       a(I,J) = weight *
- ***************
- *** 99,103 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The fields are automatically deallocated.
- --- 100,104 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   output &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 107,108 ****
- --- 108,110 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/Doof2d-Field-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Field-parallel-annotated.patch
diff -N Doof2d-Field-parallel-annotated.patch
*** /tmp/cvsJmrxJ1	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,120 ****
- *** Doof2d-Field-parallel.cpp	Tue Dec  4 11:47:58 2001
- --- Doof2d-Field-parallel-annotated.cpp	Wed Jan 23 16:37:19 2002
- ***************
- *** 1,5 ****
- ! #include <iostream>		// has std::cout, ...
- ! #include <stdlib.h>		// has EXIT_SUCCESS
- ! #include "Pooma/Fields.h"	// has POOMA's Field declarations
-   
-   // Doof2d: POOMA Fields, data-parallel implementation
- --- 1,6 ----
- ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
- ! #include &lt;iostream&gt;		// has std::cout, ...
- ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
- ! #include "Pooma/Fields.h"	// has POOMA's Field declarations  <co id="tutorial-field_parallel-doof2d-header"></co>
-   
-   // Doof2d: POOMA Fields, data-parallel implementation
- ***************
- *** 12,17 ****
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout << "Please enter the number of averagings: ";
- !   std::cin >> nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- --- 13,18 ----
-     // Ask the user for the number of averagings.
-     long nuAveragings, nuIterations;
- !   std::cout &openopen; "Please enter the number of averagings: ";
- !   std::cin &closeclose; nuAveragings;
-     nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
-   
- ***************
- *** 19,44 ****
-     // the grid.
-     long n;
- !   std::cout << "Please enter the field size: ";
- !   std::cin >> n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval<1> N(0, n-1);
- !   Interval<2> vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval<1> I(1,n-2);
- !   Interval<1> J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.
- !   DomainLayout<2> layout(vertDomain);
- !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
- !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The Field template parameters indicate a mesh, a 'double' value
- !   // type, and ordinary 'Brick' storage.
- !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
- !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- --- 20,45 ----
-     // the grid.
-     long n;
- !   std::cout &openopen; "Please enter the field size: ";
- !   std::cin &closeclose; n;
-   
-     // Specify the fields' domains [0,n) x [0,n).
- !   Interval&lt;1&gt; N(0, n-1);
- !   Interval&lt;2&gt; vertDomain(N, N);
-   
-     // Set up interior domains [1,n-1) x [1,n-1) for computation.
- !   Interval&lt;1&gt; I(1,n-2);
- !   Interval&lt;1&gt; J(1,n-2);
-   
-     // Specify the fields' mesh, i.e., its spatial extent, and its
- !   // centering type.  <co id="tutorial-field_parallel-doof2d-mesh"></co>
- !   DomainLayout&lt;2&gt; layout(vertDomain);
- !   UniformRectilinearMesh&lt;2&gt; mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
- !   Centering&lt;2&gt; cell = canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
-   
-     // Create the fields.
-     // The Field template parameters indicate a mesh, a 'double' value
- !   // type, and ordinary 'Brick' storage.  <co id="tutorial-field_parallel-doof2d-field_creation"></co>
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; a(cell, layout, mesh);
- !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt; b(cell, layout, mesh);
-   
-     // Set up the initial conditions.
- ***************
- *** 53,58 ****
-   
-     // Perform the simulation.
- !   for (int k = 0; k < nuIterations; ++k) {
- !     // Read from b.  Write to a.
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- --- 54,59 ----
-   
-     // Perform the simulation.
- !   for (int k = 0; k &lt; nuIterations; ++k) {
- !     // Read from b.  Write to a.  <co id="tutorial-field_parallel-doof2d-first_write"></co>
-       a(I,J) = weight *
-         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
- ***************
- *** 69,73 ****
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
-   
-     // The fields are automatically deallocated.
- --- 70,74 ----
-     // Print out the final central value.
-     Pooma::blockAndEvaluate();	// Ensure all computation has finished.
- !   std::cout &openopen; (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) &openopen; std::endl;
-   
-     // The fields are automatically deallocated.
- ***************
- *** 77,78 ****
- --- 78,80 ----
-     return EXIT_SUCCESS;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/array-copy-annotated.patch
===================================================================
RCS file: array-copy-annotated.patch
diff -N array-copy-annotated.patch
*** /tmp/cvsmquTO8	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,77 ****
- *** array-copy.cpp	Thu Jan 24 11:12:23 2002
- --- array-copy-annotated.cpp	Thu Jan 24 11:12:49 2002
- ***************
- *** 1,8 ****
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include <iostream>
-   
-   // Changes the Array value at index (0,0).
- ! void changeValue(Array<2,int,Brick>& z)
-   { z(0,0) = 6; }
-   
- --- 1,9 ----
- + <programlisting id="array-copy-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include &lt;iostream&gt;
-   
-   // Changes the Array value at index (0,0).
- ! void changeValue(Array&lt;2,int,Brick&gt;&amp; z)
-   { z(0,0) = 6; }
-   
- ***************
- *** 11,17 ****
-     Pooma::initialize(argc,argv);
-   
- !   Array<2,int,Brick> a(3,4, ModelElement<int>(4));
- !   std::cout << "Initial value:\n";
- !   std::cout << "a: " << a(0,0) << std::endl;
-   
-     // Array copies share the same underlying values.
- --- 12,18 ----
-     Pooma::initialize(argc,argv);
-   
- !   Array&lt;2,int,Brick&gt; a(3,4, ModelElement&lt;int&gt;(4));
- !   std::cout &openopen; "Initial value:\n";
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
-   
-     // Array copies share the same underlying values.
- ***************
- *** 19,35 ****
-     // Explicit initialization uses reference semantics so changing the
-     // copy's value at (0,0) also changes the original's value.
- !   Array<2,int,Brick> b(a);
-     b(0,0) = 5;
- !   std::cout << "After explicit initialization.\n";
- !   std::cout << "a: " << a(0,0) << std::endl;
- !   std::cout << "b: " << b(0,0) << std::endl;
-   
-     // Initialization of function arguments also uses reference semantics.
- !   std::cout << "After function call:\n";
-     changeValue(a);
- !   std::cout << "a: " << a(0,0) << std::endl;
- !   std::cout << "b: " << b(0,0) << std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 20,37 ----
-     // Explicit initialization uses reference semantics so changing the
-     // copy's value at (0,0) also changes the original's value.
- !   Array&lt;2,int,Brick&gt; b(a);
-     b(0,0) = 5;
- !   std::cout &openopen; "After explicit initialization.\n";
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
- !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
-   
-     // Initialization of function arguments also uses reference semantics.
- !   std::cout &openopen; "After function call:\n";
-     changeValue(a);
- !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
- !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/array-size-annotated.patch
===================================================================
RCS file: array-size-annotated.patch
diff -N array-size-annotated.patch
*** /tmp/cvs3lu4Nf	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,67 ****
- *** array-size.cpp	Tue Jan 15 12:59:40 2002
- --- array-size-annotated.cpp	Tue Jan 15 13:30:07 2002
- ***************
- *** 1,5 ****
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include <iostream>
-   
-   // Print an Array's Size
- --- 1,6 ----
- + <programlisting id="array-size-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
-   #include "Pooma/Arrays.h"
- ! #include &lt;iostream&gt;
-   
-   // Print an Array's Size
- ***************
- *** 10,22 ****
-   // member functions.
-   
- ! template <int Dim, typename Type, typename EngineTag>
-   inline
- ! long computeArraySize(const Array<Dim,Type,EngineTag>& a)
-   {
- !   const Loc<Dim> fs = a.firsts();
- !   const Loc<Dim> ls = a.lasts();
- !   const Loc<Dim> lens = a.lengths();
-     long size = 1;
- !   for (int d = 0; d < Dim; ++d) {
-       size *= (ls[d] - fs[d] + 1).first();
-       // Check that lengths() and our computed lengths agree.
- --- 11,23 ----
-   // member functions.
-   
- ! template &lt;int Dim, typename Type, typename EngineTag&gt;
-   inline
- ! long computeArraySize(const Array&lt;Dim,Type,EngineTag&gt;&amp; a)
-   {
- !   const Loc&lt;Dim&gt; fs = a.firsts();
- !   const Loc&lt;Dim&gt; ls = a.lasts();
- !   const Loc&lt;Dim&gt; lens = a.lengths();
-     long size = 1;
- !   for (int d = 0; d &lt; Dim; ++d) {
-       size *= (ls[d] - fs[d] + 1).first();
-       // Check that lengths() and our computed lengths agree.
- ***************
- *** 30,38 ****
-     Pooma::initialize(argc,argv);
-   
- !   Array<3,int,Brick> a(3,4,5, ModelElement<int>(4));
-     PAssert(computeArraySize(a) == a.size());
- !   std::cout << "The array's size is " << a.size() << ".\n";
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 31,40 ----
-     Pooma::initialize(argc,argv);
-   
- !   Array&lt;3,int,Brick&gt; a(3,4,5, ModelElement&lt;int&gt;(4));
-     PAssert(computeArraySize(a) == a.size());
- !   std::cout &openopen; "The array's size is " &openopen; a.size() &openopen; ".\n";
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/dynamicarray-annotated.patch
===================================================================
RCS file: dynamicarray-annotated.patch
diff -N dynamicarray-annotated.patch
*** /tmp/cvskK1Xwm	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,80 ****
- *** dynamicarray.cpp	Mon Jan 21 17:29:38 2002
- --- dynamicarray-annotated.cpp	Tue Jan 22 07:06:15 2002
- ***************
- *** 1,5 ****
-   #include "Pooma/Pooma.h"
- ! #include "Pooma/DynamicArrays.h"
- ! #include <iostream>
-   
-   // Demonstrate using DynamicArrays.
- --- 1,6 ----
- + <programlisting id="dynamicarray-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
- ! #include "Pooma/DynamicArrays.h"  <co id="arrays-dynamic_arrays-example-header"></co>
- ! #include &lt;iostream&gt;
-   
-   // Demonstrate using DynamicArrays.
- ***************
- *** 9,38 ****
-     Pooma::initialize(argc,argv);
-   
- !   // Create a DynamicArray with one element.
- !   DynamicArray<> d0(1);
- !   DynamicArray<double> d01(1);
- !   DynamicArray<double, Dynamic> d02(1);
-   
- !   // Add five more elements.
-     d0.create(5);
-     // Store values in the array.
- !   for (int i = d0.domain().first(); i <= d0.domain().last(); ++i)
- !     d0(i) = i;
-   
- !   // Delete every other element.
- !   d0.destroy(Range<1>(d0.domain().first(),d0.domain().last(),2), BackFill());
-   
-     // Print the resulting array.
- !   std::cout << d0 << std::endl;
-   
-     // Use the iterator form of 'destroy.'
- !   DynamicArray<> d1(6);
-     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
-       d1(i) = i;
- !   int killList[] = { 0, 2, 4 };
-     d1.destroy(killList, killList+3);
- !   std::cout << d1 << std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- --- 10,40 ----
-     Pooma::initialize(argc,argv);
-   
- !   // Create a DynamicArray with one element.  <co id="arrays-dynamic_arrays-example-identical_declarations"></co>
- !   DynamicArray&lt;&gt; d0(1);
- !   DynamicArray&lt;double&gt; d01(1);
- !   DynamicArray&lt;double, Dynamic&gt; d02(1);
-   
- !   // Add five more elements.  <co id="arrays-dynamic_arrays-example-extension"></co>
-     d0.create(5);
-     // Store values in the array.
- !   for (int i = d0.domain().first(); i &lt;= d0.domain().last(); ++i)
- !     d0(i) = i;  <co id="arrays-dynamic_arrays-example-access"></co>
-   
- !   // Delete every other element.  <co id="arrays-dynamic_arrays-example-destroy_range"></co>
- !   d0.destroy(Range&lt;1&gt;(d0.domain().first(),d0.domain().last(),2), BackFill());
-   
-     // Print the resulting array.
- !   std::cout &openopen; d0 &openopen; std::endl;
-   
-     // Use the iterator form of 'destroy.'
- !   DynamicArray<&gt; d1(6);
-     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
-       d1(i) = i;
- !   int killList[] = { 0, 2, 4 };  <co id="arrays-dynamic_arrays-example-destroy_iterators"></co>
-     d1.destroy(killList, killList+3);
- !   std::cout &openopen; d1 &openopen; std::endl;
-   
-     Pooma::finalize();
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/initialize-finalize-annotated.patch
===================================================================
RCS file: initialize-finalize-annotated.patch
diff -N initialize-finalize-annotated.patch
*** /tmp/cvs9Bbo4s	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,20 ****
- *** initialize-finalize.cpp	Thu Jan 24 11:14:13 2002
- --- initialize-finalize-annotated.cpp	Thu Jan 24 11:14:17 2002
- ***************
- *** 1,4 ****
-   #include "Pooma/Pooma.h"
- ! #include <iostream>
-   
-   int main(int argc, char *argv[])
- --- 1,5 ----
- + <programlisting id="initialize-finalize-program" linenumbering="numbered" format="linespecific">
-   #include "Pooma/Pooma.h"
- ! #include &lt;iostream&gt;
-   
-   int main(int argc, char *argv[])
- ***************
- *** 11,12 ****
- --- 12,14 ----
-     return 0;
-   }
- + </programlisting>
--- 0 ----
Index: examples/Templates/pairs-templated-annotated.patch
===================================================================
RCS file: pairs-templated-annotated.patch
diff -N pairs-templated-annotated.patch
*** /tmp/cvsAVPLxz	Thu Jan 31 14:52:13 2002
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,37 ****
- *** pairs-templated.cpp	Mon Jan  7 16:11:56 2002
- --- pairs-templated-annotated.cpp	Wed Jan 23 12:33:13 2002
- ***************
- *** 1,15 ****
-   // Declare a template class storing a pair of values with the same type.
- ! template <typename T>
-   struct pair {
- !   pair(const int& left, const int& right)
-       : left_(left), right_(right) {}
-   
- !   T left_;
-     T right_;
-   };
-   
- ! // Define a class storing a pair of integers.
- ! pair<int> pair1;
-   
- ! // Define a class storing a pair of doubles;
- ! pair<double> pair2;
- --- 1,17 ----
- + <programlisting id="template_programming-template_use-templated_pair_program" linenumbering="numbered" format="linespecific">
-   // Declare a template class storing a pair of values with the same type.
- ! template &lt;typename T&gt;  // <co id="template_programming-template_use-templated_pair_program-template_declaration"></co>
-   struct pair {
- !   pair(const T&amp; left, const T&amp; right)  // <co id="template_programming-template_use-templated_pair_program-constructor"></co>
-       : left_(left), right_(right) {}
-   
- !   T left_;  // <co id="template_programming-template_use-templated_pair_program-members"></co>
-     T right_;
-   };
-   
- ! // Use a class storing a pair of integers. <co id="template_programming-template_use-templated_pair_program-use"></co>
- ! pair&lt;int&gt; pair1;
-   
- ! // Use a class storing a pair of doubles;
- ! pair&lt;double&gt; pair2;
- ! </programlisting>
--- 0 ----

From oldham at mail.codesourcery.com  Thu Jan 31 22:25:50 2002
From: oldham at mail.codesourcery.com (Jeffrey)
Date: Thu, 31 Jan 2002 14:25:50 -0800
Subject: Manual Patch: Programs
Message-ID: <20020131142550.A29745@vaio.codesourcery.com>

The files containing the DocBook annotations for programs included in
the POOMA manual got mangled.  Hopefully, the attached changes ensured
every file appears exactly once.

Sorry,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
? programs-2002Jan31.patch
Index: Makefile
===================================================================
RCS file: Makefile
diff -N Makefile
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Makefile	Thu Jan 31 15:19:46 2002
***************
*** 0 ****
--- 1,15 ----
+ ### Oldham, Jeffrey D.
+ ### 2001Nov27
+ ### Pooma
+ ###
+ ### Produce Annotated Source Code
+ 
+ ## These rules combine executable code, which can be compiled and run,
+ ## with DocBook annotations used in the manual to explain the code.
+ 
+ all: array-copy-annotated.cpp dynamicarray-annotated.cpp \
+      initialize-finalize-annotated.cpp \
+      pairs-templated-annotated.cpp pairs-untemplated-annotated.cpp
+ 
+ %-annotated.cpp: %-annotated.patch %.cpp
+ 	patch -o $@ < $<
Index: array-copy-annotated.patch
===================================================================
RCS file: array-copy-annotated.patch
diff -N array-copy-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- array-copy-annotated.patch	Thu Jan 31 15:19:46 2002
***************
*** 0 ****
--- 1,78 ----
+ *** array-copy.cpp	Thu Jan 24 11:12:23 2002
+ --- array-copy-annotated.cpp	Thu Jan 31 09:22:57 2002
+ ***************
+ *** 1,8 ****
+   #include "Pooma/Pooma.h"
+   #include "Pooma/Arrays.h"
+ ! #include <iostream>
+   
+   // Changes the Array value at index (0,0).
+ ! void changeValue(Array<2,int,Brick>& z)
+   { z(0,0) = 6; }
+   
+ --- 1,9 ----
+ + <programlisting id="array-copy-program" linenumbering="numbered" format="linespecific">
+   #include "Pooma/Pooma.h"
+   #include "Pooma/Arrays.h"
+ ! #include &lt;iostream&gt;
+   
+   // Changes the Array value at index (0,0).
+ ! void changeValue(Array&lt;2,int,Brick&gt;&amp; z)
+   { z(0,0) = 6; }
+   
+ ***************
+ *** 11,35 ****
+     Pooma::initialize(argc,argv);
+   
+ !   Array<2,int,Brick> a(3,4, ModelElement<int>(4));
+ !   std::cout << "Initial value:\n";
+ !   std::cout << "a: " << a(0,0) << std::endl;
+   
+     // Array copies share the same underlying values.
+   
+ !   // Explicit initialization uses reference semantics so changing the
+ !   // copy's value at (0,0) also changes the original's value.
+ !   Array<2,int,Brick> b(a);
+     b(0,0) = 5;
+ !   std::cout << "After explicit initialization.\n";
+ !   std::cout << "a: " << a(0,0) << std::endl;
+ !   std::cout << "b: " << b(0,0) << std::endl;
+ ! 
+ !   // Initialization of function arguments also uses reference semantics.
+ !   std::cout << "After function call:\n";
+     changeValue(a);
+ !   std::cout << "a: " << a(0,0) << std::endl;
+ !   std::cout << "b: " << b(0,0) << std::endl;
+   
+     Pooma::finalize();
+     return 0;
+   }
+ --- 12,39 ----
+     Pooma::initialize(argc,argv);
+   
+ !   Array&lt;2,int,Brick&gt; a(3,4, ModelElement&lt;int&gt;(4));
+ !   std::cout &openopen; "Initial value:\n";
+ !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
+   
+     // Array copies share the same underlying values.
+   
+ !   // Explicit initialization uses reference semantics
+ !   // so changing the copy's value at (0,0) also
+ !   // changes the original's value.
+ !   Array&lt;2,int,Brick&gt; b(a);
+     b(0,0) = 5;
+ !   std::cout &openopen; "After explicit initialization.\n";
+ !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
+ !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
+ ! 
+ !   // Initialization of function arguments also uses
+ !   // reference semantics.
+ !   std::cout &openopen; "After function call:\n";
+     changeValue(a);
+ !   std::cout &openopen; "a: " &openopen; a(0,0) &openopen; std::endl;
+ !   std::cout &openopen; "b: " &openopen; b(0,0) &openopen; std::endl;
+   
+     Pooma::finalize();
+     return 0;
+   }
+ + </programlisting>
Index: array-size-annotated.patch
===================================================================
RCS file: array-size-annotated.patch
diff -N array-size-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- array-size-annotated.patch	Thu Jan 31 15:19:46 2002
***************
*** 0 ****
--- 1,80 ----
+ *** array-size.cpp	Tue Jan 15 13:30:53 2002
+ --- array-size-annotated.cpp	Thu Jan 31 09:24:16 2002
+ ***************
+ *** 1,25 ****
+   #include "Pooma/Pooma.h"
+   #include "Pooma/Arrays.h"
+ ! #include <iostream>
+   
+   // Print an Array's Size
+   
+ ! // This program illustrates using the Array member functions.
+ ! // computeArraySize's computation is redundant because Array's size()
+ ! // function computes the same value, but it illustrates using Array
+   // member functions.
+   
+ ! template <int Dim, typename Type, typename EngineTag>
+   inline
+ ! long computeArraySize(const Array<Dim,Type,EngineTag>& a)
+   {
+ !   const Loc<Dim> fs = a.firsts();
+ !   const Loc<Dim> ls = a.lasts();
+ !   const Loc<Dim> lens = a.lengths();
+     long size = 1;
+ !   for (int d = 0; d < Dim; ++d) {
+ !     size *= lens[d].first();
+       // Check that lengths() and our computed lengths agree.
+ !     PAssert((ls[d] - fs[d] + 1).first() == a.length(d));
+     }
+     return size;
+ --- 1,27 ----
+ + <programlisting id="array-size-program" linenumbering="numbered" format="linespecific">
+   #include "Pooma/Pooma.h"
+   #include "Pooma/Arrays.h"
+ ! #include &lt;iostream&gt;
+   
+   // Print an Array's Size
+   
+ ! // This program illustrates using the Array member
+ ! // functions.  computeArraySize's computation is
+ ! // redundant because Array's size() function computes
+ ! // the same value, but it illustrates using Array
+   // member functions.
+   
+ ! template &lt;int Dim,typename Type,typename EngineTag&gt;  <co id="arrays-arrays_use-members-example-template_parameters"></co>
+   inline
+ ! long computeArraySize(const Array&lt;Dim,Type,EngineTag&gt;&amp; a)
+   {
+ !   const Loc&lt;Dim&gt; fs = a.firsts();  <co id="arrays-arrays_use-members-example-function_call"></co>
+ !   const Loc&lt;Dim&gt; ls = a.lasts();
+ !   const Loc&lt;Dim&gt; lens = a.lengths();
+     long size = 1;
+ !   for (int d = 0; d &lt; Dim; ++d) {
+ !     size *= lens[d].first();  <co id="arrays-arrays_use-members-example-loc_use"></co>
+       // Check that lengths() and our computed lengths agree.
+ !     PAssert((ls[d]-fs[d]+1).first()==a.length(d));  <co id="arrays-arrays_use-members-example-check_length"></co>
+     }
+     return size;
+ ***************
+ *** 30,38 ****
+     Pooma::initialize(argc,argv);
+   
+ !   Array<3,int,Brick> a(3,4,5, ModelElement<int>(4));
+ !   PAssert(computeArraySize(a) == a.size());
+ !   std::cout << "The array's size is " << a.size() << ".\n";
+   
+     Pooma::finalize();
+     return 0;
+   }
+ --- 32,42 ----
+     Pooma::initialize(argc,argv);
+   
+ !   Array&lt;3,int,Brick&gt; a(3,4,5, ModelElement&lt;int&gt;(4));
+ !   PAssert(computeArraySize(a) == a.size());  <co id="arrays-arrays_use-members-example-compare_size"></co>
+ !   std::cout &openopen;
+ !     "The array's size is " &openopen; a.size() &openopen; ".\n";
+   
+     Pooma::finalize();
+     return 0;
+   }
+ + </programlisting>
Index: dynamicarray-annotated.patch
===================================================================
RCS file: dynamicarray-annotated.patch
diff -N dynamicarray-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- dynamicarray-annotated.patch	Thu Jan 31 15:19:46 2002
***************
*** 0 ****
--- 1,80 ----
+ *** dynamicarray.cpp	Mon Jan 21 17:29:38 2002
+ --- dynamicarray-annotated.cpp	Tue Jan 22 07:06:15 2002
+ ***************
+ *** 1,5 ****
+   #include "Pooma/Pooma.h"
+ ! #include "Pooma/DynamicArrays.h"
+ ! #include <iostream>
+   
+   // Demonstrate using DynamicArrays.
+ --- 1,6 ----
+ + <programlisting id="dynamicarray-program" linenumbering="numbered" format="linespecific">
+   #include "Pooma/Pooma.h"
+ ! #include "Pooma/DynamicArrays.h"  <co id="arrays-dynamic_arrays-example-header"></co>
+ ! #include &lt;iostream&gt;
+   
+   // Demonstrate using DynamicArrays.
+ ***************
+ *** 9,38 ****
+     Pooma::initialize(argc,argv);
+   
+ !   // Create a DynamicArray with one element.
+ !   DynamicArray<> d0(1);
+ !   DynamicArray<double> d01(1);
+ !   DynamicArray<double, Dynamic> d02(1);
+   
+ !   // Add five more elements.
+     d0.create(5);
+     // Store values in the array.
+ !   for (int i = d0.domain().first(); i <= d0.domain().last(); ++i)
+ !     d0(i) = i;
+   
+ !   // Delete every other element.
+ !   d0.destroy(Range<1>(d0.domain().first(),d0.domain().last(),2), BackFill());
+   
+     // Print the resulting array.
+ !   std::cout << d0 << std::endl;
+   
+     // Use the iterator form of 'destroy.'
+ !   DynamicArray<> d1(6);
+     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
+       d1(i) = i;
+ !   int killList[] = { 0, 2, 4 };
+     d1.destroy(killList, killList+3);
+ !   std::cout << d1 << std::endl;
+   
+     Pooma::finalize();
+     return 0;
+   }
+ --- 10,40 ----
+     Pooma::initialize(argc,argv);
+   
+ !   // Create a DynamicArray with one element.  <co id="arrays-dynamic_arrays-example-identical_declarations"></co>
+ !   DynamicArray&lt;&gt; d0(1);
+ !   DynamicArray&lt;double&gt; d01(1);
+ !   DynamicArray&lt;double, Dynamic&gt; d02(1);
+   
+ !   // Add five more elements.  <co id="arrays-dynamic_arrays-example-extension"></co>
+     d0.create(5);
+     // Store values in the array.
+ !   for (int i = d0.domain().first(); i &lt;= d0.domain().last(); ++i)
+ !     d0(i) = i;  <co id="arrays-dynamic_arrays-example-access"></co>
+   
+ !   // Delete every other element.  <co id="arrays-dynamic_arrays-example-destroy_range"></co>
+ !   d0.destroy(Range&lt;1&gt;(d0.domain().first(),d0.domain().last(),2), BackFill());
+   
+     // Print the resulting array.
+ !   std::cout &openopen; d0 &openopen; std::endl;
+   
+     // Use the iterator form of 'destroy.'
+ !   DynamicArray<&gt; d1(6);
+     for (int i = d1.domain().first(); i <= d1.domain().last(); ++i)
+       d1(i) = i;
+ !   int killList[] = { 0, 2, 4 };  <co id="arrays-dynamic_arrays-example-destroy_iterators"></co>
+     d1.destroy(killList, killList+3);
+ !   std::cout &openopen; d1 &openopen; std::endl;
+   
+     Pooma::finalize();
+     return 0;
+   }
+ + </programlisting>
Index: initialize-finalize-annotated.patch
===================================================================
RCS file: initialize-finalize-annotated.patch
diff -N initialize-finalize-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- initialize-finalize-annotated.patch	Thu Jan 31 15:19:46 2002
***************
*** 0 ****
--- 1,20 ----
+ *** initialize-finalize.cpp	Thu Jan 24 11:14:13 2002
+ --- initialize-finalize-annotated.cpp	Thu Jan 24 11:14:17 2002
+ ***************
+ *** 1,4 ****
+   #include "Pooma/Pooma.h"
+ ! #include <iostream>
+   
+   int main(int argc, char *argv[])
+ --- 1,5 ----
+ + <programlisting id="initialize-finalize-program" linenumbering="numbered" format="linespecific">
+   #include "Pooma/Pooma.h"
+ ! #include &lt;iostream&gt;
+   
+   int main(int argc, char *argv[])
+ ***************
+ *** 11,12 ****
+ --- 12,14 ----
+     return 0;
+   }
+ + </programlisting>
Index: pairs-templated-annotated.patch
===================================================================
RCS file: pairs-templated-annotated.patch
diff -N pairs-templated-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- pairs-templated-annotated.patch	Thu Jan 31 15:19:46 2002
***************
*** 0 ****
--- 1,38 ----
+ *** pairs-templated.cpp	Mon Jan  7 16:11:56 2002
+ --- pairs-templated-annotated.cpp	Thu Jan 31 08:44:35 2002
+ ***************
+ *** 1,15 ****
+ ! // Declare a template class storing a pair of values with the same type.
+ ! template <typename T>
+   struct pair {
+ !   pair(const int& left, const int& right)
+       : left_(left), right_(right) {}
+   
+ !   T left_;
+     T right_;
+   };
+   
+ ! // Define a class storing a pair of integers.
+ ! pair<int> pair1;
+   
+ ! // Define a class storing a pair of doubles;
+ ! pair<double> pair2;
+ --- 1,18 ----
+ ! <programlisting id="template_programming-template_use-templated_pair_program" linenumbering="numbered" format="linespecific">
+ ! // Declare a template class storing a pair of values
+ ! // with the same type.
+ ! template &lt;typename T&gt;  // <co id="template_programming-template_use-templated_pair_program-template_declaration"></co>
+   struct pair {
+ !   pair(const T&amp; left, const T&amp; right)  // <co id="template_programming-template_use-templated_pair_program-constructor"></co>
+       : left_(left), right_(right) {}
+   
+ !   T left_;  // <co id="template_programming-template_use-templated_pair_program-members"></co>
+     T right_;
+   };
+   
+ ! // Use a class storing a pair of integers. <co id="template_programming-template_use-templated_pair_program-use"></co>
+ ! pair&lt;int&gt; pair1;
+   
+ ! // Use a class storing a pair of doubles;
+ ! pair&lt;double&gt; pair2;
+ ! </programlisting>
Index: pairs-untemplated-annotated.patch
===================================================================
RCS file: pairs-untemplated-annotated.patch
diff -N pairs-untemplated-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- pairs-untemplated-annotated.patch	Thu Jan 31 15:19:46 2002
***************
*** 0 ****
--- 1,35 ----
+ *** pairs-untemplated.cpp	Wed Dec 26 13:48:10 2001
+ --- pairs-untemplated-annotated.cpp	Wed Dec 26 14:02:58 2001
+ ***************
+ *** 1,5 ****
+   // Declare a class storing a pair of integers.
+   struct pairOfInts {
+ !   pairOfInts(const int& left, const int& right)
+       : left_(left), right_(right) {}
+   
+ --- 1,6 ----
+ + <programlisting id="template_programming-template_use-untemplated_pair_program" linenumbering="numbered" format="linespecific">
+   // Declare a class storing a pair of integers.
+   struct pairOfInts {
+ !   pairOfInts(const int&amp; left, const int&amp; right)
+       : left_(left), right_(right) {}
+   
+ ***************
+ *** 10,14 ****
+   // Declare a class storing a pair of doubles.
+   struct pairOfDoubles {
+ !   pairOfDoubles(const double& left, const double& right)
+       : left_(left), right_(right) {}
+   
+ --- 11,15 ----
+   // Declare a class storing a pair of doubles.
+   struct pairOfDoubles {
+ !   pairOfDoubles(const double&amp; left, const double&amp; right)
+       : left_(left), right_(right) {}
+   
+ ***************
+ *** 16,17 ****
+ --- 17,19 ----
+     double right_;
+   };
+ + </programlisting>
-------------- next part --------------
Index: Doof2d-Array-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Array-distributed-annotated.patch
diff -N Doof2d-Array-distributed-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Array-distributed-annotated.patch	Thu Jan 31 15:14:50 2002
***************
*** 0 ****
--- 1,251 ----
+ *** Doof2d-Array-distributed.cpp	Mon Jan 28 20:35:07 2002
+ --- Doof2d-Array-distributed-annotated.cpp	Thu Jan 31 09:12:19 2002
+ ***************
+ *** 1,6 ****
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+ ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
+   
+ ! // Doof2d: POOMA Arrays, stencil, multiple processor implementation
+   
+   // Define the stencil class performing the computation.
+ --- 1,10 ----
+ ! <programlisting id="tutorial-array_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+ ! #include "Pooma/Arrays.h"
+ !     // has POOMA's Array declarations
+   
+ ! // Doof2d: POOMA Arrays, stencil, multiple
+ ! // processor implementation
+   
+   // Define the stencil class performing the computation.
+ ***************
+ *** 11,26 ****
+     DoofNinePt() : weight(1.0/9.0) {}
+   
+ !   // This stencil operator is applied to each interior domain position
+ !   // (i,j).  The "C" template parameter permits use of this stencil
+     // operator with both Arrays and Fields.
+ !   template <class C>
+     inline
+     typename C::Element_t
+ !   operator()(const C& x, int i, int j) const
+ !   {
+ !     return ( weight *
+ !              ( x.read(i+1,j+1) + x.read(i+1,j  ) + x.read(i+1,j-1) +
+ !                x.read(i  ,j+1) + x.read(i  ,j  ) + x.read(i  ,j-1) +
+ !                x.read(i-1,j+1) + x.read(i-1,j  ) + x.read(i-1,j-1) ) );
+     }
+   
+ --- 15,31 ----
+     DoofNinePt() : weight(1.0/9.0) {}
+   
+ !   // This stencil operator is applied to each interior
+ !   // domain position (i,j).  The "C" template
+ !   // parameter permits use of this stencil
+     // operator with both Arrays and Fields.
+ !   template &lt;class C&gt;
+     inline
+     typename C::Element_t
+ !   operator()(const C& x, int i, int j) const {
+ !     return
+ !       weight *
+ !       (x.read(i+1,j+1)+x.read(i+1,j)+x.read(i+1,j-1) +
+ !        x.read(i  ,j+1)+x.read(i  ,j)+x.read(i  ,j-1) +
+ !        x.read(i-1,j+1)+x.read(i-1,j)+x.read(i-1,j-1));
+     }
+   
+ ***************
+ *** 39,52 ****
+     Pooma::initialize(argc,argv);
+   
+ !   // Since multiple copies of this program may simultaneously run, we
+ !   // cannot use standard input and output.  Instead we use command-line
+ !   // arguments, which are replicated, for input, and we use an Inform
+ !   // stream for output.
+     Inform output;
+   
+ !   // Read the program input from the command-line arguments.
+     if (argc != 4) {
+       // Incorrect number of command-line arguments.
+ !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
+       return EXIT_FAILURE;
+     }
+ --- 44,63 ----
+     Pooma::initialize(argc,argv);
+   
+ !   // Since multiple copies of this program may simul-
+ !   // taneously run, we cannot use standard input and
+ !   // output.  Instead we use command-line arguments,
+ !   // which are replicated, for input, and we use an
+ !   // Inform stream for output.  <co id="tutorial-array_distributed-doof2d-io"></co>
+     Inform output;
+   
+ !   // Read the program input from the command-line
+ !   // arguments.
+     if (argc != 4) {
+       // Incorrect number of command-line arguments.
+ !     output &openopen;
+ !       argv[0] &openopen;
+ !       ": number-of-processors number-of-averagings"
+ !       &openopen; " number-of-values"
+ !       &openopen; std::endl;
+       return EXIT_FAILURE;
+     }
+ ***************
+ *** 55,112 ****
+     // Determine the number of processors.
+     long nuProcessors;
+ !   nuProcessors = strtol(argv[1], &tail, 0);
+   
+     // Determine the number of averagings.
+     long nuAveragings, nuIterations;
+ !   nuAveragings = strtol(argv[2], &tail, 0);
+ !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along one dimension of
+ !   // the grid.
+     long n;
+ !   n = strtol(argv[3], &tail, 0);
+ !   // The dimension must be a multiple of the number of processors
+ !   // since we are using a UniformGridLayout.
+ !   n = ((n+nuProcessors-1) / nuProcessors) * nuProcessors;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval<1> I(1,n-2);
+ !   Interval<2> interiorDomain(I,I);
+   
+     // Create the distributed arrays.
+ !   // Partition the arrays' domains uniformly, i.e., each patch has the
+ !   // same size.  The first parameter tells how many patches for each
+ !   // dimension.  Guard layers optimize communication between patches.
+ !   // Internal guards surround each patch.  External guards surround
+ !   // the entire array domain.
+ !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
+ ! 				    GuardLayers<2>(1),  // internal
+ ! 				    GuardLayers<2>(0)); // external
+ !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
+ ! 
+ !   // The Array template parameters indicate 2 dimensions and a 'double'
+ !   // value type.  MultiPatch indicates multiple computation patches,
+ !   // i.e., distributed computation.  The UniformTag indicates the
+ !   // patches should have the same size.  Each patch has Brick type.
+ !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > a(layout);
+ !   Array<2, double, MultiPatch<UniformTag, Remote<Brick> > > b(layout);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+   
+     // Create the stencil performing the computation.
+ !   Stencil<DoofNinePt> stencil;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+ !     // Read from b.  Write to a.
+       a(interiorDomain) = stencil(b, interiorDomain);
+   
+ --- 66,137 ----
+     // Determine the number of processors.
+     long nuProcessors;
+ !   nuProcessors = strtol(argv[1], &amp;tail, 0);
+   
+     // Determine the number of averagings.
+     long nuAveragings, nuIterations;
+ !   nuAveragings = strtol(argv[2], &amp;tail, 0);
+ !   nuIterations = (nuAveragings+1)/2;
+ !     // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along 
+ !   // one dimension of the grid.
+     long n;
+ !   n = strtol(argv[3], &amp;tail, 0);
+ !   // The dimension must be a multiple of the number 
+ !   // of processors since we are using a
+ !   // UniformGridLayout.
+ !   n=((n+nuProcessors-1)/nuProcessors)*nuProcessors;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1)
+ !   // for computation.
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;2&gt; interiorDomain(I,I);
+   
+     // Create the distributed arrays.
+ ! 
+ !   // Partition the arrays' domains uniformly, i.e.,
+ !   // each patch has the same size.  The first para-
+ !   // meter tells how many patches for each dimension.
+ !   // Guard layers optimize communication between
+ !   // patches.  Internal guards surround each patch.
+ !   // External guards surround the entire array
+ !   // domain.  <co id="tutorial-array_distributed-doof2d-layout"></co>
+ !   UniformGridPartition&lt;2&gt; 
+ !     partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
+ ! 	     GuardLayers&lt;2&gt;(1),  // internal
+ ! 	     GuardLayers&lt;2&gt;(0)); // external
+ !   UniformGridLayout&lt;2&gt; layout(vertDomain, partition,
+ ! 				    DistributedTag());
+ ! 
+ !   // The Array template parameters indicate 2 dims
+ !   // and a 'double' value type. MultiPatch indicates
+ !   // multiple computation patches, i.e, distributed
+ !   // computation.  The UniformTag indicates the
+ !   // patches should have the same size.  Each patch
+ !   // has Brick type.  <co id="tutorial-array_distributed-doof2d-remote"></co>
+ !   Array&lt;2, double, MultiPatch&lt;UniformTag,
+ ! 	   Remote&lt;Brick&gt; &gt; &gt; a(layout);
+ !   Array&lt;2, double, MultiPatch&lt;UniformTag,
+ !            Remote&lt;Brick&gt; &gt; &gt; b(layout);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the
+ !   // central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes
+ !   // before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+   
+     // Create the stencil performing the computation.
+ !   Stencil&lt;DoofNinePt&gt; stencil;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+ !     // Read from b.  Write to a.  <co id="tutorial-array_distributed-doof2d-first_write"></co>
+       a(interiorDomain) = stencil(b, interiorDomain);
+   
+ ***************
+ *** 116,121 ****
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+     // The arrays are automatically deallocated.
+ --- 141,149 ----
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();
+ !     // Ensure all computation has finished.
+ !   output &openopen;
+ !     (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
+ !     &openopen; std::endl;
+   
+     // The arrays are automatically deallocated.
+ ***************
+ *** 125,126 ****
+ --- 153,155 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: Doof2d-Array-element-annotated.patch
===================================================================
RCS file: Doof2d-Array-element-annotated.patch
diff -N Doof2d-Array-element-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Array-element-annotated.patch	Thu Jan 31 15:14:50 2002
***************
*** 0 ****
--- 1,149 ----
+ *** Doof2d-Array-element.cpp	Wed Jan 23 19:18:17 2002
+ --- Doof2d-Array-element-annotated.cpp	Thu Jan 31 08:55:57 2002
+ ***************
+ *** 1,5 ****
+ ! #include <iostream>		// has std::cout, ...
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+ ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
+   
+   // Doof2d: POOMA Arrays, element-wise implementation
+ --- 1,7 ----
+ ! <programlisting id="tutorial-array_elementwise-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+ ! #include "Pooma/Arrays.h"
+ !     // has POOMA's Array declarations  <co id="tutorial-array_elementwise-doof2d-header"></co>
+   
+   // Doof2d: POOMA Arrays, element-wise implementation
+ ***************
+ *** 7,37 ****
+   int main(int argc, char *argv[])
+   {
+ !   // Prepare the POOMA library for execution.
+     Pooma::initialize(argc,argv);
+     
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout << "Please enter the number of averagings: ";
+ !   std::cin >> nuAveragings;
+ !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along one dimension of
+ !   // the grid.
+     long n;
+ !   std::cout << "Please enter the array size: ";
+ !   std::cin >> n;
+   
+ !   // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+ ! 
+ !   // Create the arrays.
+ !   // The Array template parameters indicate 2 dimensions, a 'double' value
+     // type, and ordinary 'Brick' storage.
+ !   Array<2, double, Brick> a(vertDomain);
+ !   Array<2, double, Brick> b(vertDomain);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.
+     for (int j = 1; j < n-1; j++)
+       for (int i = 1; i < n-1; i++)
+ --- 9,42 ----
+   int main(int argc, char *argv[])
+   {
+ !   // Prepare the POOMA library for execution.  <co id="tutorial-array_elementwise-doof2d-pooma_initialize"></co>
+     Pooma::initialize(argc,argv);
+     
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout &openopen; "Please enter the number of averagings: ";
+ !   std::cin &closeclose; nuAveragings;
+ !   nuIterations = (nuAveragings+1)/2;
+ !     // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along
+ !   // one dimension of the grid.
+     long n;
+ !   std::cout &openopen; "Please enter the array size: ";
+ !   std::cin &closeclose; n;
+   
+ !   // Specify the arrays' domains [0,n) x [0,n).  <co id="tutorial-array_elementwise-doof2d-domain"></co>
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+ ! 
+ !   // Create the arrays.  <co id="tutorial-array_elementwise-doof2d-array_creation"></co>
+ !   // The Array template parameters indicate
+ !   // 2 dimensions, a 'double' value
+     // type, and ordinary 'Brick' storage.
+ !   Array&lt;2, double, Brick&gt; a(vertDomain);
+ !   Array&lt;2, double, Brick&gt; b(vertDomain);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the
+ !   // central value.  <co id="tutorial-array_elementwise-doof2d-initialization"></co>
+     for (int j = 1; j < n-1; j++)
+       for (int i = 1; i < n-1; i++)
+ ***************
+ *** 43,51 ****
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+       // Read from b.  Write to a.
+ !     for (int j = 1; j < n-1; j++)
+ !       for (int i = 1; i < n-1; i++)
+ !         a(i,j) = weight *
+             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
+              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
+ --- 48,56 ----
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+       // Read from b.  Write to a.
+ !     for (int j = 1; j &lt; n-1; j++)
+ !       for (int i = 1; i &lt; n-1; i++)
+ !         a(i,j) = weight *  <co id="tutorial-array_elementwise-doof2d-first_write"></co>
+             (b(i+1,j+1) + b(i+1,j  ) + b(i+1,j-1) +
+              b(i  ,j+1) + b(i  ,j  ) + b(i  ,j-1) +
+ ***************
+ *** 53,58 ****
+   
+       // Read from a.  Write to b.
+ !     for (int j = 1; j < n-1; j++)
+ !       for (int i = 1; i < n-1; i++)
+           b(i,j) = weight *
+             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
+ --- 58,63 ----
+   
+       // Read from a.  Write to b.
+ !     for (int j = 1; j &lt; n-1; j++)
+ !       for (int i = 1; i &lt; n-1; i++)
+           b(i,j) = weight *
+             (a(i+1,j+1) + a(i+1,j  ) + a(i+1,j-1) +
+ ***************
+ *** 62,71 ****
+   
+     // Print out the final central value.
+ !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+ !   // The arrays are automatically deallocated.
+   
+ !   // Tell the POOMA library execution has finished.
+     Pooma::finalize();
+     return EXIT_SUCCESS;
+   }
+ --- 67,81 ----
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();
+ !     // Ensure all computation has finished.
+ !   std::cout &openopen;
+ !      (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
+ !      &openopen; std::endl;
+   
+ !   // The arrays are automatically deallocated.  <co id="tutorial-array_elementwise-doof2d-deallocation"></co>
+   
+ !   // Tell the POOMA library execution finished.  <co id="tutorial-array_elementwise-doof2d-pooma_finish"></co>
+     Pooma::finalize();
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: Doof2d-Array-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Array-parallel-annotated.patch
diff -N Doof2d-Array-parallel-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Array-parallel-annotated.patch	Thu Jan 31 15:14:50 2002
***************
*** 0 ****
--- 1,128 ----
+ *** Doof2d-Array-parallel.cpp	Wed Jan 23 19:18:32 2002
+ --- Doof2d-Array-parallel-annotated.cpp	Mon Jan 28 20:41:18 2002
+ ***************
+ *** 1,5 ****
+ ! #include <iostream>		// has std::cout, ...
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+ ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
+   
+   // Doof2d: POOMA Arrays, data-parallel implementation
+ --- 1,7 ----
+ ! <programlisting id="tutorial-array_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+ ! #include "Pooma/Arrays.h"
+ !     // has POOMA's Array declarations
+   
+   // Doof2d: POOMA Arrays, data-parallel implementation
+ ***************
+ *** 12,43 ****
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout << "Please enter the number of averagings: ";
+ !   std::cin >> nuAveragings;
+ !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along one dimension of
+ !   // the grid.
+     long n;
+ !   std::cout << "Please enter the array size: ";
+ !   std::cin >> n;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval<1> I(1,n-2);
+ !   Interval<1> J(1,n-2);
+   
+     // Create the arrays.
+ !   // The Array template parameters indicate 2 dimensions, a 'double' value
+     // type, and ordinary 'Brick' storage.
+ !   Array<2, double, Brick> a(vertDomain);
+ !   Array<2, double, Brick> b(vertDomain);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+ --- 14,50 ----
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout &openopen; "Please enter the number of averagings: ";
+ !   std::cin &closeclose; nuAveragings;
+ !   nuIterations = (nuAveragings+1)/2;
+ !     // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along one
+ !   // dimension of the grid.
+     long n;
+ !   std::cout &openopen; "Please enter the array size: ";
+ !   std::cin &closeclose; n;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) 
+ !   // for computation.  <co id="tutorial-array_parallel-doof2d-innerdomain"></co>
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;1&gt; J(1,n-2);
+   
+     // Create the arrays.
+ !   // The Array template parameters indicate 2 dimensions,
+ !   //  a 'double' value
+     // type, and ordinary 'Brick' storage.
+ !   Array&lt;2, double, Brick&gt; a(vertDomain);
+ !   Array&lt;2, double, Brick&gt; b(vertDomain);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the
+ !   // central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes
+ !   // before accessing a value.  <co id="tutorial-array_parallel-doof2d-blockAndEvaluate"></co>
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+ ***************
+ *** 47,52 ****
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+ !     // Read from b.  Write to a.
+       a(I,J) = weight *
+         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+ --- 54,59 ----
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+ !     // Read from b.  Write to a.  <co id="tutorial-array_parallel-doof2d-first_write"></co>
+       a(I,J) = weight *
+         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+ ***************
+ *** 62,67 ****
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+     // The arrays are automatically deallocated.
+ --- 69,77 ----
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();
+ !     // Ensure all computation has finished.
+ !   std::cout &openopen;
+ !     (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
+ !     &openopen; std::endl;
+   
+     // The arrays are automatically deallocated.
+ ***************
+ *** 71,72 ****
+ --- 81,83 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: Doof2d-Array-stencil-annotated.patch
===================================================================
RCS file: Doof2d-Array-stencil-annotated.patch
diff -N Doof2d-Array-stencil-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Array-stencil-annotated.patch	Thu Jan 31 15:14:50 2002
***************
*** 0 ****
--- 1,181 ----
+ *** Doof2d-Array-stencil.cpp	Wed Jan 23 19:18:49 2002
+ --- Doof2d-Array-stencil-annotated.cpp	Thu Jan 31 09:11:12 2002
+ ***************
+ *** 1,9 ****
+ ! #include <iostream>		// has std::cout, ...
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+ ! #include "Pooma/Arrays.h"	// has POOMA's Array declarations
+   
+   // Doof2d: POOMA Arrays, stencil implementation
+   
+ ! // Define the stencil class performing the computation.
+   class DoofNinePt
+   {
+ --- 1,11 ----
+ ! <programlisting id="tutorial-array_stencil-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+ ! #include "Pooma/Arrays.h"
+ !    // has POOMA's Array declarations
+   
+   // Doof2d: POOMA Arrays, stencil implementation
+   
+ ! // Define a stencil class performing computation.  <co id="tutorial-array_stencil-doof2d-stencil"></co>
+   class DoofNinePt
+   {
+ ***************
+ *** 12,30 ****
+     DoofNinePt() : weight(1.0/9.0) {}
+   
+ !   // This stencil operator is applied to each interior domain position
+ !   // (i,j).  The "C" template parameter permits use of this stencil
+ !   // operator with both Arrays and Fields.
+ !   template <class C>
+     inline
+     typename C::Element_t
+ !   operator()(const C& c, int i, int j) const
+ !   {
+ !     return ( weight *
+ !              ( c.read(i+1,j+1) + c.read(i+1,j  ) + c.read(i+1,j-1) +
+ !                c.read(i  ,j+1) + c.read(i  ,j  ) + c.read(i  ,j-1) +
+ !                c.read(i-1,j+1) + c.read(i-1,j  ) + c.read(i-1,j-1) ) );
+     }
+   
+ !   inline int lowerExtent(int) const { return 1; }
+     inline int upperExtent(int) const { return 1; }
+   
+ --- 14,33 ----
+     DoofNinePt() : weight(1.0/9.0) {}
+   
+ !   // This stencil operator is applied to each
+ !   // interior domain position (i,j).  The "C"
+ !   // template parameter permits use of this
+ !   // stencil operator with both Arrays &amp; Fields.  <co id="tutorial-array_stencil-doof2d-stencil_operator"></co>
+ !   template &lt;class C&gt;
+     inline
+     typename C::Element_t
+ !   operator()(const C& c, int i, int j) const {
+ !     return
+ !       weight *
+ !       (c.read(i+1,j+1)+c.read(i+1,j)+c.read(i+1,j-1)+
+ !        c.read(i  ,j+1)+c.read(i  ,j)+c.read(i  ,j-1)+
+ !        c.read(i-1,j+1)+c.read(i-1,j)+c.read(i-1,j-1));
+     }
+   
+ !   inline int lowerExtent(int) const { return 1; }  <co id="tutorial-array_stencil-doof2d-stencil_extent"></co>
+     inline int upperExtent(int) const { return 1; }
+   
+ ***************
+ *** 42,82 ****
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout << "Please enter the number of averagings: ";
+ !   std::cin >> nuAveragings;
+ !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along one dimension of
+ !   // the grid.
+     long n;
+ !   std::cout << "Please enter the array size: ";
+ !   std::cin >> n;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval<1> I(1,n-2);
+ !   Interval<2> interiorDomain(I,I);
+   
+     // Create the arrays.
+ !   // The Array template parameters indicate 2 dimensions, a 'double' value
+     // type, and ordinary 'Brick' storage.
+ !   Array<2, double, Brick> a(vertDomain);
+ !   Array<2, double, Brick> b(vertDomain);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+   
+ !   // Create the stencil performing the computation.
+ !   Stencil<DoofNinePt> stencil;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+ !     // Read from b.  Write to a.
+       a(interiorDomain) = stencil(b, interiorDomain);
+   
+ --- 45,90 ----
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout &openopen; "Please enter the number of averagings: ";
+ !   std::cin &closeclose; nuAveragings;
+ !   nuIterations = (nuAveragings+1)/2;
+ !     // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along one
+ !   // dimension of the grid.
+     long n;
+ !   std::cout &openopen; "Please enter the array size: ";
+ !   std::cin &closeclose; n;
+   
+     // Specify the arrays' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) for
+ !   // computation.
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;2&gt; interiorDomain(I,I);
+   
+     // Create the arrays.
+ !   // The Array template parameters indicate
+ !   // 2 dimensions, a 'double' value
+     // type, and ordinary 'Brick' storage.
+ !   Array&lt;2, double, Brick&gt; a(vertDomain);
+ !   Array&lt;2, double, Brick&gt; b(vertDomain);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the
+ !   // central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes
+ !   // before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+   
+ !   // Create a stencil performing the computation.  <co id="tutorial-array_stencil-doof2d-stencil_creation"></co>
+ !   Stencil&lt;DoofNinePt&gt; stencil;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+ !     // Read from b.  Write to a.  <co id="tutorial-array_stencil-doof2d-first_write"></co>
+       a(interiorDomain) = stencil(b, interiorDomain);
+   
+ ***************
+ *** 86,91 ****
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+     // The arrays are automatically deallocated.
+ --- 94,102 ----
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate(); 
+ !     // Ensure all computation has finished.
+ !   std::cout &openopen;
+ !     (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
+ !     &openopen; std::endl;
+   
+     // The arrays are automatically deallocated.
+ ***************
+ *** 95,96 ****
+ --- 106,108 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: Doof2d-C-element-annotated.patch
===================================================================
RCS file: Doof2d-C-element-annotated.patch
diff -N Doof2d-C-element-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-C-element-annotated.patch	Thu Jan 31 15:14:50 2002
***************
*** 0 ****
--- 1,154 ----
+ *** Doof2d-C-element.cpp	Thu Jan 31 08:46:50 2002
+ --- Doof2d-C-element-annotated.cpp	Thu Jan 31 08:47:14 2002
+ ***************
+ *** 1,4 ****
+ ! #include <iostream>		// has std::cout, ...
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+   
+   // Doof2d: C-like, element-wise implementation
+ --- 1,5 ----
+ ! <programlisting id="tutorial-hand_coded-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+   
+   // Doof2d: C-like, element-wise implementation
+ ***************
+ *** 6,30 ****
+   int main()
+   {
+ !   // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout << "Please enter the number of averagings: ";
+ !   std::cin >> nuAveragings;
+ !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ !   // Use two-dimensional grids of values.
+     double **a;
+     double **b;
+   
+ !   // Ask the user for the number n of values along one dimension of
+ !   // the grid.
+     long n;
+ !   std::cout << "Please enter the array size: ";
+ !   std::cin >> n;
+   
+ !   // Allocate the arrays.
+     typedef double* doublePtr;
+     a = new doublePtr[n];
+     b = new doublePtr[n];
+ !   for (int i = 0; i < n; i++) {
+       a[i] = new double[n];
+       b[i] = new double[n];
+ --- 7,32 ----
+   int main()
+   {
+ !   // Ask the user for the number of averagings.  <co id="tutorial-hand_coded-doof2d-nuaveragings"></co>
+     long nuAveragings, nuIterations;
+ !   std::cout &openopen; "Please enter the number of averagings: ";
+ !   std::cin &closeclose; nuAveragings;
+ !   nuIterations = (nuAveragings+1)/2;
+ !     // Each iteration performs two averagings.
+   
+ !   // Use two-dimensional grids of values.  <co id="tutorial-hand_coded-doof2d-array_storage"></co>
+     double **a;
+     double **b;
+   
+ !   // Ask the user for the number n of values along one 
+ !   // dimension of the grid.  <co id="tutorial-hand_coded-doof2d-grid_size"></co>
+     long n;
+ !   std::cout &openopen; "Please enter the array size: ";
+ !   std::cin &closeclose; n;
+   
+ !   // Allocate the arrays.  <co id="tutorial-hand_coded-doof2d-allocation"></co>
+     typedef double* doublePtr;
+     a = new doublePtr[n];
+     b = new doublePtr[n];
+ !   for (int i = 0; i &lt; n; i++) {
+       a[i] = new double[n];
+       b[i] = new double[n];
+ ***************
+ *** 32,49 ****
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.
+ !   for (int j = 0; j < n; j++)
+ !     for (int i = 0; i < n; i++)
+         a[i][j] = b[i][j] = 0.0;
+     b[n/2][n/2] = 1000.0;
+   
+ !   // Average using this weight.
+     const double weight = 1.0/9.0;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+ !     // Read from b.  Write to a.
+ !     for (int j = 1; j < n-1; j++)
+ !       for (int i = 1; i < n-1; i++)
+           a[i][j] = weight *
+             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
+ --- 34,52 ----
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the
+ !   // central value.  <co id="tutorial-hand_coded-doof2d-initialization"></co>
+ !   for (int j = 0; j &lt; n; j++)
+ !     for (int i = 0; i &lt; n; i++)
+         a[i][j] = b[i][j] = 0.0;
+     b[n/2][n/2] = 1000.0;
+   
+ !   // Average using this weight.  <co id="tutorial-hand_coded-doof2d-constants"></co>
+     const double weight = 1.0/9.0;
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+ !     // Read from b.  Write to a.  <co id="tutorial-hand_coded-doof2d-first_write"></co>
+ !     for (int j = 1; j &lt; n-1; j++)
+ !       for (int i = 1; i &lt; n-1; i++)
+           a[i][j] = weight *
+             (b[i+1][j+1] + b[i+1][j  ] + b[i+1][j-1] +
+ ***************
+ *** 51,57 ****
+              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
+   
+ !     // Read from a.  Write to b.
+ !     for (int j = 1; j < n-1; j++)
+ !       for (int i = 1; i < n-1; i++)
+           b[i][j] = weight *
+             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
+ --- 54,60 ----
+              b[i-1][j+1] + b[i-1][j  ] + b[i-1][j-1]);
+   
+ !     // Read from a.  Write to b.  <co id="tutorial-hand_coded-doof2d-second_write"></co>
+ !     for (int j = 1; j &lt; n-1; j++)
+ !       for (int i = 1; i &lt; n-1; i++)
+           b[i][j] = weight *
+             (a[i+1][j+1] + a[i+1][j  ] + a[i+1][j-1] +
+ ***************
+ *** 60,68 ****
+     }
+   
+ !   // Print out the final central value.
+ !   std::cout << (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2]) << std::endl;
+   
+ !   // Deallocate the arrays.
+ !   for (int i = 0; i < n; i++) {
+       delete [] a[i];
+       delete [] b[i];
+ --- 63,73 ----
+     }
+   
+ !   // Print out the final central value.  <co id="tutorial-hand_coded-doof2d-answer"></co>
+ !   std::cout &openopen;
+ !     (nuAveragings % 2 ? a[n/2][n/2] : b[n/2][n/2])
+ !     &openopen; std::endl;
+   
+ !   // Deallocate the arrays.  <co id="tutorial-hand_coded-doof2d-deallocation"></co>
+ !   for (int i = 0; i &lt; n; i++) {
+       delete [] a[i];
+       delete [] b[i];
+ ***************
+ *** 73,74 ****
+ --- 78,80 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: Doof2d-Field-distributed-annotated.patch
===================================================================
RCS file: Doof2d-Field-distributed-annotated.patch
diff -N Doof2d-Field-distributed-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Field-distributed-annotated.patch	Thu Jan 31 15:14:50 2002
***************
*** 0 ****
--- 1,219 ----
+ *** Doof2d-Field-distributed.cpp	Wed Jan 23 19:20:15 2002
+ --- Doof2d-Field-distributed-annotated.cpp	Wed Jan 30 16:40:27 2002
+ ***************
+ *** 1,6 ****
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+ ! #include "Pooma/Fields.h"	// has POOMA's Field declarations
+   
+ ! // Doof2d: POOMA Fields, data-parallel, multiple processor implementation
+   
+   int main(int argc, char *argv[])
+ --- 1,9 ----
+ ! <programlisting id="tutorial-field_distributed-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+ ! #include "Pooma/Fields.h"
+ !     // has POOMA's Field declarations
+   
+ ! // Doof2d: POOMA Fields, data-parallel, multiple
+ ! // processor implementation
+   
+   int main(int argc, char *argv[])
+ ***************
+ *** 9,16 ****
+     Pooma::initialize(argc,argv);
+     
+ !   // Since multiple copies of this program may simultaneously run, we
+ !   // canot use standard input and output.  Instead we use command-line
+ !   // arguments, which are replicated, for input, and we use an Inform
+ !   // stream for output.
+     Inform output;
+   
+ --- 12,20 ----
+     Pooma::initialize(argc,argv);
+     
+ !   // Since multiple copies of this program may
+ !   // simultaneously run, we canot use standard input
+ !   // and output.  Instead we use command-line
+ !   // arguments, which are replicated, for input, and we
+ !   // use an Inform stream for output.  <co id="tutorial-field_distributed-doof2d-io"></co>
+     Inform output;
+   
+ ***************
+ *** 18,22 ****
+     if (argc != 4) {
+       // Incorrect number of command-line arguments.
+ !     output << argv[0] << ": number-of-processors number-of-averagings number-of-values" << std::endl;
+       return EXIT_FAILURE;
+     }
+ --- 22,29 ----
+     if (argc != 4) {
+       // Incorrect number of command-line arguments.
+ !     output &openopen; argv[0] &openopen;
+ !       ": number-of-processors number-of-averagings"
+ !       &openopen; " number-of-values"
+ !       &openopen; std::endl;
+       return EXIT_FAILURE;
+     }
+ ***************
+ *** 25,79 ****
+     // Determine the number of processors.
+     long nuProcessors;
+ !   nuProcessors = strtol(argv[1], &tail, 0);
+   
+     // Determine the number of averagings.
+     long nuAveragings, nuIterations;
+ !   nuAveragings = strtol(argv[2], &tail, 0);
+ !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along one dimension of
+ !   // the grid.
+     long n;
+ !   n = strtol(argv[3], &tail, 0);
+ !   // The dimension must be a multiple of the number of processors
+ !   // since we are using a UniformGridLayout.
+     n = ((n+nuProcessors-1) / nuProcessors) * nuProcessors;
+   
+     // Specify the fields' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval<1> I(1,n-2);
+ !   Interval<1> J(1,n-2);
+ ! 
+ !   // Partition the fields' domains uniformly, i.e., each patch has the
+ !   // same size.  The first parameter tells how many patches for each
+ !   // dimension.  Guard layers optimize communication between patches.
+ !   // Internal guards surround each patch.  External guards surround
+ !   // the entire field domain.
+ !   UniformGridPartition<2> partition(Loc<2>(nuProcessors, nuProcessors),
+ ! 				    GuardLayers<2>(1),  // internal
+ ! 				    GuardLayers<2>(0)); // external
+ !   UniformGridLayout<2> layout(vertDomain, partition, DistributedTag());
+ ! 
+ !   // Specify the fields' mesh, i.e., its spatial extent, and its
+ !   // centering type.
+ !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
+ !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
+ ! 
+ !   // The Field template parameters indicate a mesh and a 'double'
+ !   // value type.  MultiPatch indicates multiple computation patches,
+ !   // i.e., distributed computation.  The UniformTag indicates the
+ !   // patches should have the same size.  Each patch has Brick type.
+ !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
+ !     Remote<Brick> > > a(cell, layout, mesh);
+ !   Field<UniformRectilinearMesh<2>, double, MultiPatch<UniformTag,
+ !     Remote<Brick> > > b(cell, layout, mesh);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+ --- 32,99 ----
+     // Determine the number of processors.
+     long nuProcessors;
+ !   nuProcessors = strtol(argv[1], &amp;tail, 0);
+   
+     // Determine the number of averagings.
+     long nuAveragings, nuIterations;
+ !   nuAveragings = strtol(argv[2], &amp;tail, 0);
+ !   nuIterations = (nuAveragings+1)/2;
+ !     // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along
+ !   // one dimension of the grid.
+     long n;
+ !   n = strtol(argv[3], &amp;tail, 0);
+ !   // The dimension must be a multiple of the number of
+ !   // processors since we are using a UniformGridLayout.
+     n = ((n+nuProcessors-1) / nuProcessors) * nuProcessors;
+   
+     // Specify the fields' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) for
+ !   // computation.
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;1&gt; J(1,n-2);
+ ! 
+ !   // Partition the fields' domains uniformly, i.e.,
+ !   // each patch has the same size.  The first parameter
+ !   // tells how many patches for each dimension.  Guard
+ !   // layers optimize communication between patches.
+ !   // Internal guards surround each patch.  External
+ !   // guards surround the entire field domain.  <co id="tutorial-field_distributed-doof2d-layout"></co>
+ !   UniformGridPartition&lt;2&gt;
+ !     partition(Loc&lt;2&gt;(nuProcessors, nuProcessors),
+ ! 	     GuardLayers&lt;2&gt;(1),  // internal
+ ! 	     GuardLayers&lt;2&gt;(0)); // external
+ !   UniformGridLayout&lt;2&gt;
+ !     layout(vertDomain, partition, DistributedTag());
+ ! 
+ !   // Specify the fields' mesh, i.e., its spatial
+ !   // extent, and its centering type.  <co id="tutorial-field_distributed-doof2d-mesh"></co>
+ !   UniformRectilinearMesh&lt;2&gt;
+ !     mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
+ !   Centering&lt;2&gt; cell =
+ !     canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
+ ! 
+ !   // The Field template parameters indicate a mesh and
+ !   // a 'double' value type.  MultiPatch indicates
+ !   // multiple computation patches, i.e., distributed
+ !   // computation.  The UniformTag indicates the patches
+ !   // should have the same size.  Each patch has Brick
+ !   // type.  <co id="tutorial-field_distributed-doof2d-remote"></co>
+ !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double,
+ !            MultiPatch&lt;UniformTag, Remote&lt;Brick&closecloseclose;
+ !     a(cell, layout, mesh);
+ !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double,
+ !     MultiPatch&lt;UniformTag, Remote&lt;Brick&closecloseclose;
+ !     b(cell, layout, mesh);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the
+ !   // central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes
+ !   // before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+ ***************
+ *** 83,87 ****
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+       // Read from b.  Write to a.
+       a(I,J) = weight *
+ --- 103,107 ----
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+       // Read from b.  Write to a.
+       a(I,J) = weight *
+ ***************
+ *** 98,103 ****
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   output << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+     // The fields are automatically deallocated.
+ --- 118,126 ----
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();
+ !     // Ensure all computation has finished.
+ !   output &openopen;
+ !     (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
+ !     &openopen; std::endl;
+   
+     // The fields are automatically deallocated.
+ ***************
+ *** 107,108 ****
+ --- 130,132 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: Doof2d-Field-parallel-annotated.patch
===================================================================
RCS file: Doof2d-Field-parallel-annotated.patch
diff -N Doof2d-Field-parallel-annotated.patch
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d-Field-parallel-annotated.patch	Thu Jan 31 15:14:50 2002
***************
*** 0 ****
--- 1,144 ----
+ *** Doof2d-Field-parallel.cpp	Wed Jan 23 19:20:33 2002
+ --- Doof2d-Field-parallel-annotated.cpp	Thu Jan 31 09:07:32 2002
+ ***************
+ *** 1,5 ****
+ ! #include <iostream>		// has std::cout, ...
+ ! #include <stdlib.h>		// has EXIT_SUCCESS
+ ! #include "Pooma/Fields.h"	// has POOMA's Field declarations
+   
+   // Doof2d: POOMA Fields, data-parallel implementation
+ --- 1,7 ----
+ ! <programlisting id="tutorial-field_parallel-doof2d-program" linenumbering="numbered" format="linespecific">
+ ! #include &lt;iostream&gt;		// has std::cout, ...
+ ! #include &lt;stdlib.h&gt;		// has EXIT_SUCCESS
+ ! #include "Pooma/Fields.h"
+ !    // has POOMA's Field declarations  <co id="tutorial-field_parallel-doof2d-header"></co>
+   
+   // Doof2d: POOMA Fields, data-parallel implementation
+ ***************
+ *** 12,49 ****
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout << "Please enter the number of averagings: ";
+ !   std::cin >> nuAveragings;
+ !   nuIterations = (nuAveragings+1)/2; // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along one dimension of
+ !   // the grid.
+     long n;
+ !   std::cout << "Please enter the field size: ";
+ !   std::cin >> n;
+   
+     // Specify the fields' domains [0,n) x [0,n).
+ !   Interval<1> N(0, n-1);
+ !   Interval<2> vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) for computation.
+ !   Interval<1> I(1,n-2);
+ !   Interval<1> J(1,n-2);
+ ! 
+ !   // Specify the fields' mesh, i.e., its spatial extent, and its
+ !   // centering type.
+ !   DomainLayout<2> layout(vertDomain);
+ !   UniformRectilinearMesh<2> mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
+ !   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
+   
+     // Create the fields.
+ !   // The Field template parameters indicate a mesh, a 'double' value
+ !   // type, and ordinary 'Brick' storage.
+ !   Field<UniformRectilinearMesh<2>, double, Brick> a(cell, layout, mesh);
+ !   Field<UniformRectilinearMesh<2>, double, Brick> b(cell, layout, mesh);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+ --- 14,60 ----
+     // Ask the user for the number of averagings.
+     long nuAveragings, nuIterations;
+ !   std::cout&openopen;"Please enter the number of averagings: ";
+ !   std::cin &closeclose; nuAveragings;
+ !   nuIterations = (nuAveragings+1)/2;
+ !     // Each iteration performs two averagings.
+   
+ !   // Ask the user for the number n of values along
+ !   // one dimension of the grid.
+     long n;
+ !   std::cout &openopen; "Please enter the field size: ";
+ !   std::cin &closeclose; n;
+   
+     // Specify the fields' domains [0,n) x [0,n).
+ !   Interval&lt;1&gt; N(0, n-1);
+ !   Interval&lt;2&gt; vertDomain(N, N);
+   
+ !   // Set up interior domains [1,n-1) x [1,n-1) for
+ !   // computation.
+ !   Interval&lt;1&gt; I(1,n-2);
+ !   Interval&lt;1&gt; J(1,n-2);
+ ! 
+ !   // Specify the fields' mesh, i.e., its spatial
+ !   //  extent, and its centering type.  <co id="tutorial-field_parallel-doof2d-mesh"></co>
+ !   DomainLayout&lt;2&gt; layout(vertDomain);
+ !   UniformRectilinearMesh&lt;2&gt;
+ !     mesh(layout, Vector&lt;2&gt;(0.0), Vector&lt;2&gt;(1.0, 1.0));
+ !   Centering&lt;2&gt; cell =
+ !     canonicalCentering&lt;2&gt;(CellType, Continuous, AllDim);
+   
+     // Create the fields.
+ !   // The Field template parameters indicate a mesh, a
+ !   // 'double' value type, and ordinary 'Brick'
+ !   // storage. <co id="tutorial-field_parallel-doof2d-field_creation"></co>
+ !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt;
+ !     a(cell, layout, mesh);
+ !   Field&lt;UniformRectilinearMesh&lt;2&gt;, double, Brick&gt;
+ !     b(cell, layout, mesh);
+   
+     // Set up the initial conditions.
+ !   // All grid values should be zero except for the
+ !   // central value.
+     a = b = 0.0;
+ !   // Ensure all data-parallel computation finishes
+ !   // before accessing a value.
+     Pooma::blockAndEvaluate();
+     b(n/2,n/2) = 1000.0;
+ ***************
+ *** 53,58 ****
+   
+     // Perform the simulation.
+ !   for (int k = 0; k < nuIterations; ++k) {
+ !     // Read from b.  Write to a.
+       a(I,J) = weight *
+         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+ --- 64,69 ----
+   
+     // Perform the simulation.
+ !   for (int k = 0; k &lt; nuIterations; ++k) {
+ !     // Read from b.  Write to a.  <co id="tutorial-field_parallel-doof2d-first_write"></co>
+       a(I,J) = weight *
+         (b(I+1,J+1) + b(I+1,J  ) + b(I+1,J-1) +
+ ***************
+ *** 68,73 ****
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();	// Ensure all computation has finished.
+ !   std::cout << (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2)) << std::endl;
+   
+     // The fields are automatically deallocated.
+ --- 79,87 ----
+   
+     // Print out the final central value.
+ !   Pooma::blockAndEvaluate();
+ !     // Ensure all computation has finished.
+ !   std::cout &openopen;
+ !     (nuAveragings % 2 ? a(n/2,n/2) : b(n/2,n/2))
+ !     &openopen; std::endl;
+   
+     // The fields are automatically deallocated.
+ ***************
+ *** 77,78 ****
+ --- 91,93 ----
+     return EXIT_SUCCESS;
+   }
+ + </programlisting>
Index: Makefile
===================================================================
RCS file: Makefile
diff -N Makefile
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Makefile	Thu Jan 31 15:14:50 2002
***************
*** 0 ****
--- 1,16 ----
+ ### Oldham, Jeffrey D.
+ ### 2001Nov27
+ ### Pooma
+ ###
+ ### Produce Annotated Source Code for the POOMA Manual
+ 
+ ## These rules combine executable code, which can be compiled and run,
+ ## with DocBook annotations used in the manual to explain the code.
+ 
+ all: Doof2d-C-element-annotated.cpp Doof2d-Array-element-annotated.cpp \
+      Doof2d-Array-parallel-annotated.cpp Doof2d-Array-stencil-annotated.cpp \
+      Doof2d-Array-distributed-annotated.cpp \
+      Doof2d-Field-parallel-annotated.cpp Doof2d-Field-distributed-annotated.cpp
+ 
+ %-annotated.cpp: %-annotated.patch %.cpp
+ 	patch -o $@ < $<

From oldham at codesourcery.com  Thu Jan 31 22:57:00 2002
From: oldham at codesourcery.com (Jeffrey D . Oldham)
Date: Thu, 31 Jan 2002 14:57:00 -0800
Subject: Manual Patch: Example Code 1 of x
Message-ID: <20020131145700.A29944@vaio.codesourcery.com>

This is the first of x changes to the example code written for the
manual.

2002-Jan-31  Jeffrey D. Oldham  <oldham at codesourcery.com>

	* Doof2d/Doof2d-Array-distributed.cpp (main): Fix typo in comment.
	* Doof2d/Doof2d-C-element.cpp (main): Shorten comment.
	* Sequential/pairs-templated.cpp: New file.
	* Sequential/pairs-untemplated.cpp: Likewise.

Applied to	mainline

Thanks,
Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
Index: Doof2d/Doof2d-Array-distributed.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/Manual/Doof2d/Doof2d-Array-distributed.cpp,v
retrieving revision 1.3
diff -c -p -r1.3 Doof2d-Array-distributed.cpp
*** Doof2d/Doof2d-Array-distributed.cpp	2002/01/25 03:45:54	1.3
--- Doof2d/Doof2d-Array-distributed.cpp	2002/01/31 22:49:54
*************** int main(int argc, char *argv[])
*** 39,45 ****
    Pooma::initialize(argc,argv);
  
    // Since multiple copies of this program may simultaneously run, we
!   // canot use standard input and output.  Instead we use command-line
    // arguments, which are replicated, for input, and we use an Inform
    // stream for output.
    Inform output;
--- 39,45 ----
    Pooma::initialize(argc,argv);
  
    // Since multiple copies of this program may simultaneously run, we
!   // cannot use standard input and output.  Instead we use command-line
    // arguments, which are replicated, for input, and we use an Inform
    // stream for output.
    Inform output;
Index: Doof2d/Doof2d-C-element.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/Manual/Doof2d/Doof2d-C-element.cpp,v
retrieving revision 1.3
diff -c -p -r1.3 Doof2d-C-element.cpp
*** Doof2d/Doof2d-C-element.cpp	2002/01/25 03:45:54	1.3
--- Doof2d/Doof2d-C-element.cpp	2002/01/31 22:49:54
*************** int main()
*** 37,43 ****
        a[i][j] = b[i][j] = 0.0;
    b[n/2][n/2] = 1000.0;
  
!   // In the average, weight elements with this value.
    const double weight = 1.0/9.0;
  
    // Perform the simulation.
--- 37,43 ----
        a[i][j] = b[i][j] = 0.0;
    b[n/2][n/2] = 1000.0;
  
!   // Average using this weight.
    const double weight = 1.0/9.0;
  
    // Perform the simulation.
Index: Sequential/pairs-templated.cpp
===================================================================
RCS file: pairs-templated.cpp
diff -N pairs-templated.cpp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- pairs-templated.cpp	Thu Jan 31 15:49:54 2002
***************
*** 0 ****
--- 1,15 ----
+ // Declare a template class storing a pair of values with the same type.
+ template <typename T>
+ struct pair {
+   pair(const int& left, const int& right)
+     : left_(left), right_(right) {}
+ 
+   T left_;
+   T right_;
+ };
+ 
+ // Define a class storing a pair of integers.
+ pair<int> pair1;
+ 
+ // Define a class storing a pair of doubles;
+ pair<double> pair2;
Index: Sequential/pairs-untemplated.cpp
===================================================================
RCS file: pairs-untemplated.cpp
diff -N pairs-untemplated.cpp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- pairs-untemplated.cpp	Thu Jan 31 15:49:54 2002
***************
*** 0 ****
--- 1,17 ----
+ // Declare a class storing a pair of integers.
+ struct pairOfInts {
+   pairOfInts(const int& left, const int& right)
+     : left_(left), right_(right) {}
+ 
+   int left_;
+   int right_;
+ };
+ 
+ // Declare a class storing a pair of doubles.
+ struct pairOfDoubles {
+   pairOfDoubles(const double& left, const double& right)
+     : left_(left), right_(right) {}
+ 
+   double left_;
+   double right_;
+ };

