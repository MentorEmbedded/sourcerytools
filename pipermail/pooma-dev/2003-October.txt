From rguenth at tat.physik.uni-tuebingen.de  Wed Oct  1 17:57:34 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Wed, 1 Oct 2003 19:57:34 +0200 (CEST)
Subject: [pooma-dev] Evaluator/ReductionEvaluator.h question
In-Reply-To: <200302220832.26893.leopardi@bigpond.net.au>
References: <70410000.1045853856@warlock.codesourcery.com>
 <200302220832.26893.leopardi@bigpond.net.au>
Message-ID: <Pine.LNX.4.58.0310011953000.608@goofy>

Hi!

I just stumbeled over the strange ReductionEvaluator initialization code
again. I'm currently OpenMPizing the POOMA evaluator loops and cant come
up with an idea to parallelize the current reduction loops due to this
initialization. For those not remembering, in the reduction
evaluators we initialize the result with the first array element and in
turn skip the operation on the same element, but continue with the second
one. Of course this wont work for parallel OpenMP reduction where we
rather need a operation neutral element.

Or can anyone think of a valid way to OpenMPize the following loop?

    T answer(localExpr.read(0));
    for (int i0 = 1; i0 < e0; ++i0)
      op(answer, localExpr.read(i0));

Thanks for any hints,

Richard.


From rguenth at tat.physik.uni-tuebingen.de  Wed Oct  1 16:46:51 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Wed, 1 Oct 2003 18:46:51 +0200 (CEST)
Subject: cheetah/smarts on CodeSourcery download site
Message-ID: <Pine.LNX.4.58.0310011827210.608@goofy>

Hi!

It appears cheetah 1.0.1 is still advertised from CodeSourcery's download
site. I use cheetah 1.1.4 since over a year now without problems, so maybe
we can advertise this version for r2 now. Also cheetah was hosted at
ACL/LANL like PETE was, so maintainance ceased to exist now? In this case
I put the official 1.1.4 release on

http://www.tat.physik.uni-tuebingen.de/~rguenth/pooma/cheetah-1.1.4.tgz

if the CodeSourcery guys are going to set up a repository for this, I have
some local fixes to that version.

The same is true for smarts, but at least the CodeSourcery version is
current. Does anyone know if any of these projects continue outside of
ACL/LANL?

Thanks,

Richard.


From rguenth at tat.physik.uni-tuebingen.de  Sun Oct  5 14:54:42 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Sun, 5 Oct 2003 16:54:42 +0200 (CEST)
Subject: [PATCH] Reference documentation
Message-ID: <Pine.LNX.4.58.0310051646040.1118@goofy>

Hi!

I'd like to continue to build up reference documentation creation
infrastructure. This second step adds grouping following the pooma
source directory structure to the generated doxygen pages. Also some of
the head pages of the groups will feature an introduction like overview.

Tested by making the reference documentation using doxygen 1.3.2 and
spellchecking the group descriptions using ispell.

Thanks,
Richard.


2003Oct05  Richard Guenther <richard.guenther at uni-tuebingen.de>

	* docs/reference/Makefile: fix clean rule.
	docs/reference/array.doxygen: new file.
	docs/reference/field.doxygen: new file.
	docs/reference/particles.doxygen: new file.
	docs/reference/tulip.doxygen: new file.
	docs/reference/connect.doxygen: new file.
	docs/reference/internal.doxygen: new file.
	docs/reference/partition.doxygen: new file.
	docs/reference/unused.doxygen: new file.
	docs/reference/databrowser.doxygen: new file.
	docs/reference/io.doxygen: new file.
	docs/reference/pete.doxygen: new file.
	docs/reference/utility.doxygen: new file.
	docs/reference/domain.doxygen: new file.
	docs/reference/layout.doxygen: new file.
	docs/reference/pooma.doxygen: new file.
	docs/reference/engine.doxygen: new file.
	docs/reference/main.doxygen: new file.
	docs/reference/threads.doxygen: new file.
	docs/reference/evaluator.doxygen: new file.
	docs/reference/objects.doxygen: new file.
	docs/reference/tiny.doxygen: new file.

Index: Makefile
===================================================================
RCS file: /home/pooma/Repository/r2/docs/reference/Makefile,v
retrieving revision 1.1
diff -u -u -r1.1 Makefile
--- Makefile	6 Feb 2003 22:14:11 -0000	1.1
+++ Makefile	5 Oct 2003 14:32:33 -0000
@@ -1,13 +1,13 @@
-.PHONY: reference clean default
+.PHONY: html clean default

 default:
 	@echo "Valid targets are:"
 	@echo " html      - generate reference manual from source using doxygen"
 	@echo " clean     - remove files generated from doxygen"

-html:
+html: clean
 	doxygen doxygen.conf

 clean:
-	rm -Rf reference
+	rm -Rf html

--- reference/array.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/array.doxygen	2003-02-09 00:03:24.000000000 +0100
@@ -0,0 +1,5 @@
+/**
+ * @defgroup Array Arrays
+ * @ingroup Objects
+ *
+ */
diff -urN reference/connect.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/connect.doxygen
--- reference/connect.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/connect.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,32 @@
+/**
+ * @defgroup Connect
+ * @ingroup Utilities
+ * Classes/Files for managing connections to external agents such as
+ * visualization tools.
+ *
+ * Support for using the PAWS library is available. PAWS provides a
+ * mechanism for sharing multidimensional array and simple scalar
+ * variables between separate parallel programs.
+ *
+ * Support for using the Lux library for run-time visualization is
+ * available.
+ *
+ */
+
+/**
+ * @defgroup Lux
+ * @ingroup Connect
+ *
+ * Support for using the Lux library for run-time visualization.
+ *
+ */
+
+/**
+ * @defgroup Paws
+ * @ingroup Connect
+ *
+ * Support for using the PAWS library. PAWS provides a
+ * mechanism for sharing multidimensional array and simple scalar
+ * variables between separate parallel programs.
+ *
+ */
diff -urN reference/databrowser.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/databrowser.doxygen
--- reference/databrowser.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/databrowser.doxygen	2003-02-09 00:03:32.000000000 +0100
@@ -0,0 +1,5 @@
+/**
+ * @defgroup DataBrowser
+ * @ingroup Utilities
+ *
+ */
diff -urN reference/domain.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/domain.doxygen
--- reference/domain.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/domain.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,41 @@
+/**
+ * @defgroup Domain Domain Objects and Modifiers
+ * @ingroup Structuring
+ * These are classes which handle specifying a domain and modifying it.
+ *
+ * The types of domains can be divided into two classes, namely integer
+ * domains and continuous domains.
+ *
+ * Integer domains include
+ * - int
+ * - Loc<Dim>
+ * - Interval<Dim>
+ * - Range<Dim>
+ * - Grid<Dim>
+ *
+ * The only continuous domain class is Region<Dim>. There are a few special
+ * domain classes, namely NullDomain, AllDomain and ErrorDomain.
+ *
+ * All domain classes come with their corresponding traits class
+ * DomainTraits<class> which is used to manage operations on domains
+ * such as
+ * - splitting domains with the split function
+ * - querying if domains overlap using the touches function
+ * - querying the intersection of two domains using the intersect function
+ * - growing/shrinking Interval<Dim> using the shrinkRight, growRight,
+ *   shrinkLeft and growLeft functions
+ * - finding the equivalent subset for a domain from a given transformation
+ *   using the equivSubset function
+ * - remove the overlap between two Interval<Dim> and return a vector of the
+ *   resulting domain using the DomainRemoveOverlap function
+ * - querying if one domain contains another using the contains function
+ *
+ * Domains can be modified by arithmetic operations and new domains can
+ * be constructed using the helper classes in NewDomain.h and the LeftDomain
+ * and RightDomain wildcard classes.
+ *
+ * You can iterate through domains by FIXME.
+ *
+ * Some domains can be sliced FIXME.
+ *
+ */
diff -urN reference/engine.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/engine.doxygen
--- reference/engine.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/engine.doxygen	2003-10-05 16:33:03.000000000 +0200
@@ -0,0 +1,52 @@
+/**
+ * @defgroup Engine Engines
+ * @ingroup Objects
+ *
+ * Engine related classes/files.
+ *
+ * Engines provide the storage for Arrays and Fields and handle
+ * domain decomposition, taking sub-views and accessing components
+ * transparently by providing a common interface to their users.
+ *
+ * Engine are usually defined recursively. Engines categorize into
+ * engines allocating storage for data, engines that provide access
+ * to computed data and engines providing modified access to other
+ * engines.
+ *
+ * For the first category, the storage engines, the following are
+ * available:
+ *  - Engine < Dim, T, Brick >
+ *  - Engine < Dim, T, CompressibleBrick >
+ *  - Engine < Dim, T, Dynamic >
+ *  - Engine < Dim, T, ConstantFunction >
+ *
+ * For the second category, the computation engines, the following
+ * are available:
+ *  - Engine < Dim, T, IndexFunction < Functor > >
+ *  - Engine < Dim, T, StencilEngine < Function, Expression > >
+ *  - Engine < Dim, T, UserFunctionEngine < UserFunction, Expression > >
+ *  - Engine < Dim, T, ExpressionTag < Expr > >
+ *
+ * For the second category the most important engine types include:
+ *  - Engine < Dim, T, Remote < Tag > >
+ *  - Engine < Dim, T, MultiPatch < LayoutTag, PatchTag > >
+ *  - Engine < Dim, T, CompFwd < Eng, N > >
+ *  - Engine < Dim, T, IndirectionTag < A1, A2 > >
+ *  - Engines of the category
+ *    Engine < Dim, T, ViewEngineType >, where
+ *    ViewEngineType is one of
+ *    BrickView,
+ *    MultiPatchView<LayoutTag, PatchTag, Dim>,
+ *    DynamicView
+ *    and ViewEngine<OriginalDim, ViewedEngineTag>
+ *
+ * Views of Engines can be constructed by using the NewEngine<> traits
+ * class which takes the to be viewed engine type and the subsetting
+ * domain type as template parameters. NewEngine<> then defines the type
+ * of the ViewEngine as Type_t typedef member.
+ *
+ * FIXME: Introduce NewEngineEngine<>, NewEngineDomain<> and
+ * newEngineEngine() and newEngineDomain() with their concepts.
+ */
+
+
diff -urN reference/evaluator.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/evaluator.doxygen
--- reference/evaluator.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/evaluator.doxygen	2003-10-05 16:33:49.000000000 +0200
@@ -0,0 +1,29 @@
+/**
+ * @defgroup Evaluator
+ * @ingroup Objects
+ *
+ * The evaluators present different ways to operate on Arrays and Fields.
+ *
+ * This includes Fortran-like manual looping over the patches of the
+ * data using the PatchFunction<> mechanism which supports multiple
+ * input data but only one output. (PatchFunction.h, PatchKernel.h)
+ *
+ * Another way to operate is using the ScalarCode<> facility which
+ * presents something like a n-argument stencil operation with some
+ * of the arguments being the output. (ScalarCode.h, ScalarCodeInfo.h,
+ * MultiArgKernel.h, MultiArgEvaluator.h)
+ *
+ * Evaluating a functor at a whole domain is done using the LoopApplyEvaluator.
+ * (LoopApply.h)
+ *
+ * The most simple way is to use POOMA expressions who are evaluated
+ * via ExpressioKernel objects. (ExpressionKernel.h)
+ *
+ * The internal evaluator objects are templated on the patch type which
+ * gets constructed from the expression node types using the
+ * EvaluatorCombine<> traits class and produce the tags
+ * RemoteMultiPatchEvaluatorTag, MultiPatchEvaluatorTag, RemoteSinglePatchEvaluatorTag
+ * and SinglePatchEvaluatorTag. The MainEvaluatorTag specialized class is
+ * the root of any evaluation.
+ *
+ */
diff -urN reference/field.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/field.doxygen
--- reference/field.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/field.doxygen	2003-02-09 00:06:50.000000000 +0100
@@ -0,0 +1,54 @@
+/**
+ * @defgroup Field Fields
+ * @ingroup Objects
+ *
+ * Field related classes/files. Important classes include Field, FieldEngine
+ * Centering and CanonicalCentering.
+ *
+ */
+
+/**
+ * @defgroup Mesh Field Meshes
+ * @ingroup Field
+ *
+ * Meshes provide a way to attach coordinate information to the
+ * vertices of a grid. You can choose between different mesh types
+ * which constrain positions in a different way. All available meshes
+ * are rectilinear, i.e. are constructed as outer product of spacing
+ * vectors.
+ *
+ * To query a mesh for its positions or similar properties use the
+ * functions positions(), outwardNormals(), coordinateNormals(), cellVolumes(),
+ * faceAreas() and edgeLengths().
+ *
+ * Predefined mesh types are:
+ *  - UniformRectilinearMesh which defines a uniformly spaced rectilinear mesh,
+ *  - RectilinearMesh which defines a arbitrarily spaced rectilinear mesh,
+ *  - NoMesh which defines a mesh without a mesh.
+ *
+ * Meshes are completed by one of Cartesian, Cylindrical or Spherical
+ * coordinate system classes. Complete types for mesh can be constructed
+ * using the MeshTraits traits class and the appropriate tag classes for
+ * the mesh type and the coordinate system type.
+ *
+ */
+
+/**
+ * @defgroup DiffOps
+ * @ingroup Field
+ *
+ */
+
+/**
+ * @defgroup Relations Field Relations
+ * @ingroup Field
+ *
+ * Relations are FIXME.
+ *
+ * Usable predefined relations include boundary conditions of which
+ * the following are available:
+ *  - ConstantFaceBC
+ *  - PeriodicFaceBC
+ *  - PosReflectFaceBC
+ *
+ */
diff -urN reference/internal.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/internal.doxygen
--- reference/internal.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/internal.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,7 @@
+/**
+ * @defgroup Internal Internal classes/files
+ *
+ * Not of interest to the pooma user, but maybe
+ * to the pooma developer.
+ *
+ */
diff -urN reference/io.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/io.doxygen
--- reference/io.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/io.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,11 @@
+/**
+ * @defgroup IO
+ * @ingroup Utilities
+ *
+ * IO related classes/files.
+ *
+ * IO is currently supported to the DiscField format as
+ * designed for %Pooma r1 by Bill Humphrey only. FileSetReader
+ * and FileSetWriter are the classes you are looking for.
+ *
+ */
diff -urN reference/layout.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/layout.doxygen
--- reference/layout.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/layout.doxygen	2003-10-05 16:35:33.000000000 +0200
@@ -0,0 +1,39 @@
+/**
+ * @defgroup Layout Layouts - Laying out Domains
+ * @ingroup Structuring
+ *
+ * A layout combines domain information and guard cell (both internal
+ * and external) information and maps the domain to a specified partition.
+ * So related topics are the \ref Domain and \ref Partition groups.
+ *
+ * All layouts operate with domains based on Interval<Dim>, i.e. a
+ * continuous integer domain. This domain gets distributed/tiled in a
+ * different way for different layout classes, namely
+ * - DomainLayout does not tile/distribute the domain, hence it is applicable
+ *   for local computation only
+ * - GridLayout tiles/distributes the Dim-dimensional domain by constructing
+ *   a (possibly) non-uniform rectilinear grid of subdomains (GridTag)
+ * - UniformGridLayout tiles/distributes the domain using a uniform rectilinear
+ *   grid of subdomains (UniformTag)
+ * - SparseTileLayout tiles/distributes the domain using non-overlapping
+ *   subdomains that need not cover the whole domain (SparseTileTag)
+ * - DynamicLayout tiles/distributes the domain using a grid partition and
+ *   handles dynamic domains such as coming from DynamicArray (DynamicTag)
+ *
+ * For actually using any of the above layout on a MultiPatch engine you need
+ * to specify appropriate grid tags which are one of those specified above
+ * amongst the layout classes.
+ *
+ * Specifying the actual tiling is done by several constructors dealing with
+ * the most important tiling types. The generic way to specify tiling is to
+ * use a partitioner, see \ref Partition for reference.
+ *
+ * Mapping the domain to the tiling can be done in two different ways,
+ * namely distributed and replicated which is specified using an instance
+ * of the DistributedTag and ReplicatedTag classes to the layout constructors.
+ * Distributed means the domain is distributed over the tiling, replicated
+ * means the entire domain is replicated over the tiling. Note that remote
+ * engines do not make sense in conjunction with replicated layouts, and this
+ * will trigger a runtime error.
+ *
+ */
diff -urN reference/main.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/main.doxygen
--- reference/main.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/main.doxygen	2003-10-05 16:36:23.000000000 +0200
@@ -0,0 +1,25 @@
+/** @mainpage
+ *
+ * %Pooma reference documentation.
+ *
+ * Doxygenifized by Richard Guenther <rguenth at tat.physik.uni-tuebingen.de>
+ *
+ * Most useful is the Modules section where files and their classes
+ * are sorted by topic. Those include modules for handling the data
+ *  - \ref Array
+ *  - \ref Field
+ *  - \ref Particles
+ *
+ * and modules for specifying and organizing the problem space
+ *  - \ref Domain
+ *  - \ref Mesh
+ *  - \ref Layout
+ *  - \ref Engine
+ *
+ * Other documentation can be found beyond
+ * <A HREF="../../index.html">here</A>.
+ *
+ * %Pooma is hosted at <A HREF="http://www.codesourcery.com/pooma/pooma">CodeSourcery</A>.
+ *
+ */
+
diff -urN reference/objects.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/objects.doxygen
--- reference/objects.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/objects.doxygen	2003-10-05 16:37:16.000000000 +0200
@@ -0,0 +1,18 @@
+/**
+ * @defgroup Objects Data object and container classes
+ * Objects for storing data and for doing computation with.
+ *
+ * Note that for complex objects like Fields and Arrays placed inside
+ * structures the compiler will generate default copy constructors and
+ * assignment operators that usually violate the principle of least
+ * surprise in that they will invoke the objects assignment operator
+ * which will cause a PETE expression to be evaluated and this may
+ * lead to cryptic compiler error messages for for example IndexFunction
+ * engine objects. To work around this you need to explicitly provide
+ * copy constructors and assignment operators that use obj.initialize()
+ * instead of an assignment. This will catch you if you are using
+ * IndexFunction like objects, such as Stencils and FieldStencils. For
+ * writable objects be prepared to get assertion failures because of
+ * uninitialized objects created by a default constructors are later
+ * initialized by default copy/assignment.
+ */
diff -urN reference/particles.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/particles.doxygen
--- reference/particles.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/particles.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,7 @@
+/**
+ * @defgroup Particles Particles (partly pre-r2)
+ * @ingroup Objects
+ *
+ * Particles files/classes.
+ *
+ */
diff -urN reference/partition.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/partition.doxygen
--- reference/partition.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/partition.doxygen	2003-10-05 16:38:10.000000000 +0200
@@ -0,0 +1,18 @@
+/**
+ * @defgroup Partition Partitioning Domains
+ * @ingroup Structuring
+ *
+ * These files deal with domain partitioning and mapping the partition
+ * to computation nodes. The following partitioners are available:
+ * - GridPartition
+ * - UniformGridPartition
+ * - TilePartition
+ *
+ * You usually don't need to interact with the mappers, which are
+ * LocalMapper, ContextMapper, BisectionMapper, ContiguousMapper,
+ * DistributedMapper and UniformMapper. They deal with mapping patches
+ * to nodes, where LocalMapper is used for ReplicatedTag tagged layouts
+ * and the others, derived from the base ContextMapper, for DistributedTag
+ * tagged layouts.
+ *
+ */
diff -urN reference/pete.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/pete.doxygen
--- reference/pete.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/pete.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,7 @@
+/**
+ * @defgroup PETE
+ * @ingroup Internal
+ *
+ * The PETE portable expression template engine.
+ *
+ */
diff -urN reference/pooma.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/pooma.doxygen
--- reference/pooma.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/pooma.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,6 @@
+/**
+ * @defgroup Pooma Pooma Headers
+ *
+ * Pooma.
+ *
+ */
diff -urN reference/threads.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/threads.doxygen
--- reference/threads.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/threads.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,11 @@
+/**
+ * @defgroup Threads
+ * @ingroup Internal
+ *
+ */
+
+/**
+ * @defgroup IterateSchedulers
+ * @ingroup Threads
+ *
+ */
diff -urN reference/tiny.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/tiny.doxygen
--- reference/tiny.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/tiny.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,9 @@
+/**
+ * @defgroup Tiny Primitive objects (Vector, Matrix, Tensor)
+ * @ingroup Objects
+ *
+ * Tiny classes - Vector, TinyMatrix and Tensor. These can be used as
+ * data types apart from builtin scalar types for Array and Field
+ * containers.
+ *
+ */
diff -urN reference/tulip.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/tulip.doxygen
--- reference/tulip.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/tulip.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,7 @@
+/**
+ * @defgroup Tulip
+ * @ingroup Internal
+ *
+ * Classes for interacting with the Cheetah messaging library.
+ *
+ */
diff -urN reference/unused.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/unused.doxygen
--- reference/unused.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/unused.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,23 @@
+/**
+ * @defgroup Unused Unused Classes/Files (pre-r2)
+ * @ingroup Internal
+ *
+ * Those include the whole CoordinateSystem/ directory.
+ *
+ */
+
+/**
+ * @defgroup CoordinateSystems Coordinate-system classes
+ * @ingroup Unused
+ *
+ * Note that support for different coordinate systems is currently not
+ * implemented. This means the current \ref Field and \ref Mesh implementations
+ * work on a %Cartesian grid only. The current implementations stem from pre-r2
+ * times.
+ *
+ * In principle here would be the implementations of the following
+ * coordinate systems:
+ * - Cartesian
+ * - Cylindrical with the 2d subsets Polar and RhoZ and the 1d subset Rho
+ * - Spherical
+ */
diff -urN reference/utility.doxygen /home/richard/src/pooma/cvs/r2/docs/reference/utility.doxygen
--- reference/utility.doxygen	1970-01-01 01:00:00.000000000 +0100
+++ /home/richard/src/pooma/cvs/r2/docs/reference/utility.doxygen	2003-02-06 22:30:56.000000000 +0100
@@ -0,0 +1,7 @@
+/**
+ * @defgroup Utilities Utility Classes
+ *
+ * Random files/classes with useful stuff for either the backend or
+ * the user.
+ *
+ */


From rguenth at tat.physik.uni-tuebingen.de  Sun Oct  5 15:16:05 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Sun, 5 Oct 2003 17:16:05 +0200 (CEST)
Subject: [PATCH] Convert Domain/ documentation to doxygen recognizable format
Message-ID: <Pine.LNX.4.58.0310051709390.1118@goofy>

Hi!

This patch (as an example) converts the inline documentation of the
Domain/ sources to a doxygen recognizable format.  I didnt bother to clean
this up for now (you will notice different "styles" of doxygen markup)
until we can agree on the principle of this patch.  Also I'll be glad to
write up a README on the preferred documentation markup once we have
decided on one.  I for myself prefer java-doc like (///) for methods and
doxygen like (/** */) for files/classes, as they tend to stick out some
more and structure the source.

Any comments? Does anyone think this is useful work?

Thanks,
Richard.


A ChangeLog would read

	* .../Domain/*.h: convert comments to doxygen recognizable style.

The patch is just a diff of my -doc repository against cvs head (Domain/
parts).


diff -ur cvs/r2/src/Domain/AllDomain.h pooma-doc/r2/src/Domain/AllDomain.h
--- cvs/r2/src/Domain/AllDomain.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/AllDomain.h	2003-10-05 17:03:45.000000000 +0200
@@ -38,7 +38,8 @@
 //////////////////////////////////////////////////////////////////////

 //-----------------------------------------------------------------------------
-// Overview:
+/** @file
+ *  @ingroup Domain
 //
 // AllDomain is one of the domain wildcards, which are used when constructing
 // other domains using specific combination rules.  AllDomain means to use
@@ -46,7 +47,7 @@
 // domain.  It is also used when constructing new domains with no other
 // arguments to mean that the domain should not be initialized, which can
 // save considerable time in some circumstances.
-//
+*/
 //-----------------------------------------------------------------------------

 //-----------------------------------------------------------------------------
@@ -67,7 +68,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of AllDomain:
+/**
 //
 // AllDomain is a special domain class which is used as a 'wildcard'.
 // Wildcards are useful when constructing new domains based on some other
@@ -86,7 +87,7 @@
 // dimensions should not be initialized, which can be helpful to avoid
 // extra unneeded work when the domain will be filled with new values very
 // soon.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -171,7 +172,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainTraits<AllDomain<Dim>> provides traits information about AllDomain,
 // which is one of the domain wildcards.  It has a quite stripped-down
@@ -180,7 +181,7 @@
 // dimension and the type of the wildcard, and an enum indicating that it is
 // a wildcard.  Also, getDomain returns a 1D element of the N-dimensional
 // list of wildcards.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
Only in cvs/r2/src/Domain: CVS
diff -ur cvs/r2/src/Domain/CombineDomainOpt.h pooma-doc/r2/src/Domain/CombineDomainOpt.h
--- cvs/r2/src/Domain/CombineDomainOpt.h	2000-03-07 14:16:33.000000000 +0100
+++ pooma-doc/r2/src/Domain/CombineDomainOpt.h	2003-01-16 20:46:35.000000000 +0100
@@ -36,9 +36,14 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-//
+/** @file
+ * @ingroup Domain
+ * @brief
+ * CombineDomainOpt is a class that can be used to optimize the operation
+ * NewDomainN<>::combineSlice(domain, s1, s2, ...).
+ */
+
+/**
 // CombineDomainOpt is a class that can be used to optimize the operation
 // NewDomainN<>::combineSlice(domain, s1, s2, ...).
 //
@@ -60,6 +65,7 @@
 //                );
 //
 // If s is single-valued, the array a is never used.
+*/
 //-----------------------------------------------------------------------------

 //-----------------------------------------------------------------------------
@@ -69,10 +75,12 @@
 template<class NewDomain, bool sv>
 struct CombineDomainOpt;

+/**
 // Single valued specialization.
 // Since Locs can construct themselves from other Locs and
 // integers, we just use the constructors.  Another option is
 // return Loc<dim>(s1, s2, ...).
+*/

 template<class NewDomain>
 struct CombineDomainOpt<NewDomain, true>
@@ -143,8 +151,10 @@
   }
 };

+/**
 // Multi-valued version.  This one calls combineSlice to create
 // the final domain.
+*/

 template<class NewDomain>
 struct CombineDomainOpt<NewDomain, false>
diff -ur cvs/r2/src/Domain/Contains.h pooma-doc/r2/src/Domain/Contains.h
--- cvs/r2/src/Domain/Contains.h	2003-05-20 22:08:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/Contains.h	2003-10-05 17:07:48.000000000 +0200
@@ -39,15 +39,18 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// bool contains(domain,domain) is a global function which determines if
-// the points in the second domain are all points which are in the first
-// domain.  If there is even just one point in the second not in the first,
-// then this returns false.  Note that the order is important: if
-// contains(a,b) is true, then the only way that contains(b,a) can be true is
-// if a == b.  The order for the query is: is b contained within a?
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * bool contains(domain,domain) is a global function which determines if
+ * the points in the second domain are all points which are in the first
+ * domain.
+ *
+ * If there is even just one point in the second not in the first,
+ * then this returns false.  Note that the order is important: if
+ * contains(a,b) is true, then the only way that contains(b,a) can be true is
+ * if a == b.  The order for the query is: is b contained within a?
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -68,7 +71,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of ContainsDomainSingle:
+/**
 //
 // ContainsDomainSingle<T1,T2,bool strided>::contains(a,b) compares two
 // domains a and b of type T1 and T2, and returns true if a contains b.
@@ -85,13 +88,13 @@
 //                    found in a.  The striding of a may lead to it not
 //                    referring to points in b.  Only do this calculation when
 //                    absolutely necessary.
-//
+*/
 //-----------------------------------------------------------------------------

-//
+/**
 // The default (unit-stride) version of ContainsDomainSingle, which assumes
 // that both arguments to 'contains' are 1D domains with unit stride
-//
+*/

 template<class T1, class T2, bool strided>
 struct ContainsDomainSingle {
@@ -100,10 +103,10 @@
   }
 };

-//
+/**
 // The non-unit-stride version of ContainsDomainSingle, which does extra
 // work for the case where a and b do not have unit stride.
-//
+*/

 template<class T1, class T2>
 struct ContainsDomainSingle<T1,T2,true> {
@@ -143,7 +146,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of ContainsDomain:
+/**
 //
 // ContainsDomain implements a basic template meta-program to
 // compare each dimension separately of the multidimensional domains for
@@ -152,7 +155,7 @@
 // or not.  A general version of ContainsDomain is defined, to compare the
 // domains in the 'Dim' dimension, and then a specialization is provided
 // for Dim==1 that stops the metaprogram recursion.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T1, class T2, int Dim>
@@ -198,7 +201,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of contains:
+/**
 //
 // bool contains(domain1, domain2) is one of the domain calculus routines
 // used to analyze domains to determine their relative characteristics.  It
@@ -208,7 +211,7 @@
 // The implementation of contains is deferred to the ContainsDomain
 // struct, which performs the contains comparison for each dimension and and's
 // the results together.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T1, class T2>
diff -ur cvs/r2/src/Domain/Domain.h pooma-doc/r2/src/Domain/Domain.h
--- cvs/r2/src/Domain/Domain.h	2003-01-23 22:29:49.000000000 +0100
+++ pooma-doc/r2/src/Domain/Domain.h	2003-01-31 18:26:30.000000000 +0100
@@ -37,7 +37,8 @@
 //////////////////////////////////////////////////////////////////////

 //-----------------------------------------------------------------------------
-// Overview:
+/** @file
+ *  @ingroup Domain
 // Domain is a base class for all domain objects, but one which can be
 // specialized for N-dimensional (N>1), and 1-dimensional domain objects.
 // The first template parameter is a dimension, which is used
@@ -50,6 +51,7 @@
 // which are common to all Domain objects, regardless of whether they are
 // 1-D or N-D domains, are collected into the DomainBase class which is a
 // base class for Domain.
+*/
 //-----------------------------------------------------------------------------

 //-----------------------------------------------------------------------------
@@ -71,7 +73,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // Domain<Dim,DT> provides the bulk of the public interface for all domain
 // objects. The first template parameter is a dimension that
@@ -102,13 +104,13 @@
 // on what the dimension is.
 //
 // Domain<N,DT> defines the following operations for domain objects:
-//   operator[]
-//   operator+=, -=, *=, /=
-//   operator++, operator-- : just like using += stride(), -= stride()
+//   - operator[]
+//   - operator+=, -=, *=, /=
+//   - operator++, operator-- : just like using += stride(), -= stride()
 //     for each dimension
-//   int size()
-//   bool empty()
-//   operator <, == (other comparisons defined in DomainBase.h)
+//   - int size()
+//   - bool empty()
+//   - operator <, == (other comparisons defined in DomainBase.h)
 //
 // Note that if some operation is not defined for a particular type of
 // domain (e.g., *=, which is not legal for Loc or Interval objects), the
@@ -119,70 +121,67 @@
 //
 // Domain<1,DT> defines, in addition to the Domain<N,DT> methods, these
 // extra interface functions for just 1D domains:
-//   int first(), last(),           stride(), min(), max()
-//   long length()
+//   - int first(), last(), stride(), min(), max()
+//   - long length()
 //
 // The actual data for the domain (such as what the endpoints are) is
 // kept in DomainBase.  The DomainTraits class defines what the type
 // of the storage should be.  By putting that storage in the base class,
 // we avoid the 'empty base class' penalty of many compilers.  The storage
 // object is named domain_m.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim, class DT>
 class Domain : public DomainBase<DT>
 {
-  // convenience typedef
+  /// convenience typedef
   typedef DomainBase<DT>                 Base_t;

 public:
   //
-  // Typedefs obtained from the DomainBase and DomainTraits.
+  /// Typedefs obtained from the DomainBase and DomainTraits.
   //

   typedef typename DT::Size_t            Size_t;
   typedef typename Base_t::Domain_t      Domain_t;
   typedef typename DT::OneDomain_t       OneDomain_t;

-  // Iterator typedefs.  An N-dimensional iterator is a forward
-  // iterator, it works only with operator++ (it does not have operator--).
+  /// Iterator typedefs.  An N-dimensional iterator is a forward
+  /// iterator, it works only with operator++ (it does not have operator--).

   typedef typename Base_t::const_iterator const_iterator;
   typedef typename Base_t::iterator       iterator;

-  // Block iterator typedefs.  All domains use the DomainBlockIterator
-  // class to iterate through blocks defined by the domain points.  A
-  // block iterator is a forward iterator, it works only with operator++.
+  /// Block iterator typedefs.  All domains use the DomainBlockIterator
+  /// class to iterate through blocks defined by the domain points.  A
+  /// block iterator is a forward iterator, it works only with operator++.

   typedef typename Base_t::const_blockIterator const_blockIterator;
   typedef typename Base_t::blockIterator       blockIterator;


-  //
-  // Constructors.  Domain has a default constructor, which only
-  // makes sure for now that the Dim parameter is consistent with the
-  // DT parameter.  The storage object is kept and initialized in DomainBase.
-  //
+  /**
+   * Constructors.  Domain has a default constructor, which only
+   * makes sure for now that the Dim parameter is consistent with the
+   * DT parameter.  The storage object is kept and initialized in DomainBase.
+   */

   inline
   Domain() {
     CTAssert(DT::dimensions == Dim && Dim > 0);
   }

-  //
-  // If an Pooma::NoInit object is given in the constructor, we skip
-  // initialization of our array of 1D domains.
-  //
+  /**
+   * If an Pooma::NoInit object is given in the constructor, we skip
+   * initialization of our array of 1D domains.
+   */

   inline Domain(const Pooma::NoInit &d) : Base_t(d) {
     CTAssert(DT::dimensions == Dim && Dim > 0);
   }

-  //
-  // Destructor.  Here, nothing to do
-  //
-
+  /** Destructor.  Here, nothing to do. */
   inline
   ~Domain() { }

@@ -190,14 +189,18 @@
   // Domain accessors.
   //

-  // return the Nth element of this domain, using []
+  /// return the Nth element of this domain, using []
   inline
   const OneDomain_t &operator[](int d) const { return this->domain_m[d]; }
+
+  /// return the Nth element of this domain, using []
   inline
   OneDomain_t &operator[](int d) { return this->domain_m[d]; }

+  /**
   // return the total size of the domain, which is the product
   // of all the lengths of the 1D domains
+  */
   inline
   Size_t size() const {
     Size_t sz = this->domain_m[0].size();
@@ -206,8 +209,8 @@
     return sz;
   }

-  // return if this domain is empty, which reports whether any of the
-  // N 1-dimensional domains are empty.
+  /** return if this domain is empty, which reports whether any of the
+   * N 1-dimensional domains are empty. */
   inline
   bool empty() const {
     for (int i = 0; i < Dim; i++)
@@ -216,14 +219,14 @@
     return false;
   }

-  // return whether this domain has been initialized.  This is the
-  // same as saying it is not empty.
+  /** return whether this domain has been initialized.  This is the
+   * same as saying it is not empty. */
   inline
   bool initialized() const { return (!empty()); }

-  //
-  // Comparison operators ==, !=, <, >, <=, >=
-  //
+
+  /// @name Comparison operators ==, !=, <, >, <=, >=
+  //@{

   template<class T>
   bool operator==(const T &d2) const {
@@ -279,14 +282,17 @@
     return true;
   }

-  //
-  // Arithmetic accumulation operators.  These are only allowed to
-  // occur with domain objects which are single-valued and have the
-  // right number of dimensions (basically, Loc's and scalar's).
-  //
-  // All return a reference to this object, but cast down to the
-  // derived type (e.g., Loc<N> instead of Domain<DomainTraits<Loc<N>>>
-  //
+  //@}
+
+  /// @name Arithmetic accumulation operators
+  /// These are only allowed to
+  /// occur with domain objects which are single-valued and have the
+  /// right number of dimensions (basically, Loc's and scalar's).
+  ///
+  /// All return a reference to this object, but cast down to the
+  /// derived type (e.g., Loc<N> instead of Domain<DomainTraits<Loc<N>>>
+
+  //@{

   template<class T>
   Domain_t &operator+=(const T &d2)
@@ -331,11 +337,13 @@
     return this->unwrap();
   }

+  //@}
+
 private:
-  // make the copy constructor and operator= private and undefined
-  // so that they will not be generated and so it will be an error if
-  // the user tries to use them.  The classes derived from Domain should
-  // provide all the constructors and operator='s needed.
+  /** make the copy constructor and operator= private and undefined
+   * so that they will not be generated and so it will be an error if
+   * the user tries to use them.  The classes derived from Domain should
+   * provide all the constructors and operator='s needed. */
   Domain(const Domain<Dim,DT> &);
   void operator=(const Domain<Dim,DT> &);
 };
@@ -343,7 +351,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description: SetDomainFunctor
+/**
 //
 // SetDomainFunctor is a simple wrapper around the setDomain method in
 // the DomainTraits class.  It is templated on the DomainTraits type,
@@ -357,7 +365,7 @@
 // setWildcardDomain method is available which takes an extra user-supplied
 // reference domain.  This reference domain is used by the wildcard to
 // calculate what the true domain should be.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class DT, class ST, class T, class UT, bool wildcard>
@@ -387,13 +395,13 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // The 1D-specialized version of Domain, which acts much like the ND version
 // but also provides a number of new or redefined interface functions:
 //   int first(), last(), stride(), min(), max()
 //   long length()
-//
+*/
 //-----------------------------------------------------------------------------

 template<class DT>
diff -ur cvs/r2/src/Domain/DomainArithOpsTraits.h pooma-doc/r2/src/Domain/DomainArithOpsTraits.h
--- cvs/r2/src/Domain/DomainArithOpsTraits.h	2001-06-28 21:08:10.000000000 +0200
+++ pooma-doc/r2/src/Domain/DomainArithOpsTraits.h	2003-01-16 20:46:35.000000000 +0100
@@ -37,33 +37,30 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainArithOpsTraits is intended to be used to select the return type of
-// arithmetic operations between domains and pseudo-domains comprising the following
-// list:
-
-// Loc<1> Loc<N> Interval<N> Range<N> IndirectionList<int> Grid<N>
-
-// Valid combinations are
-
-// Loc<1> +-*/ Loc<1>               => Loc<1>
-// Loc<1> +-*/ Loc<N>               => Loc<N>
-// Loc<1> +-*/ Interval<N>          => Interval<N>
-// Loc<1> +-*/ Range<N>             => Range<N>
-// Loc<1> +-*/ IndirectionList<int> => IndirectionList<int>
-// Loc<1> +-*/ Grid<N>              => Grid<N>
-
-// Loc<N> +-*/ Loc<N>               => Loc<N>
-// Loc<N> +-*/ Interval<N>          => Interval<N>
-// Loc<N> +-*/ Range<N>             => Range<N>
-// Loc<N> +-*/ Grid<N>              => Grid<N>
-
-
-
-
-
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainArithOpsTraits is intended to be used to select the return type of
+ * arithmetic operations between domains and pseudo-domains.
+ *
+ * DomainArithOpsTraits comprises the following list:
+ *
+ * Loc<1> Loc<N> Interval<N> Range<N> IndirectionList<int> Grid<N>
+ *
+ * Valid combinations are
+ *
+ * Loc<1> + - * / Loc<1>               => Loc<1>
+ * Loc<1> + - * / Loc<N>               => Loc<N>
+ * Loc<1> + - * / Interval<N>          => Interval<N>
+ * Loc<1> + - * / Range<N>             => Range<N>
+ * Loc<1> + - * / IndirectionList<int> => IndirectionList<int>
+ * Loc<1> + - * / Grid<N>              => Grid<N>
+ *
+ * Loc<N> + - * / Loc<N>               => Loc<N>
+ * Loc<N> + - * / Interval<N>          => Interval<N>
+ * Loc<N> + - * / Range<N>             => Range<N>
+ * Loc<N> + - * / Grid<N>              => Grid<N>
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
diff -ur cvs/r2/src/Domain/DomainBase.h pooma-doc/r2/src/Domain/DomainBase.h
--- cvs/r2/src/Domain/DomainBase.h	2001-04-13 04:12:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/DomainBase.h	2003-01-16 20:46:35.000000000 +0100
@@ -36,17 +36,20 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainBase is a common base class for all domain objects.  The template
-// parameter T should be a traits class that describes all the
-// characteristics of the domain object, and the dimension of the object.
-// This base class provides a collection of all the functionality that is
-// common to all DomainBase-derived objects, regardless of whether they are
-// specialized to a specific number of dimensions or not.  For example, both
-// Domain<N, DomainTraits<Loc<N>>> and Domain<1, DomainTraits<Loc<N>>>
-// use DomainBase as a base class.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainBase is a common base class for all domain objects.
+ *
+ * The template
+ * parameter T should be a traits class that describes all the
+ * characteristics of the domain object, and the dimension of the object.
+ * This base class provides a collection of all the functionality that is
+ * common to all DomainBase-derived objects, regardless of whether they are
+ * specialized to a specific number of dimensions or not.  For example, both
+ * Domain<N, DomainTraits<Loc<N>>> and Domain<1, DomainTraits<Loc<N>>>
+ * use DomainBase as a base class.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -70,7 +73,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainBase<DT> is the common base class for all Domain<Dim, DT> objects,
 // regardless of the value of Dim.  Since Domain<Dim,DT> is defined for
@@ -124,7 +127,7 @@
 // the format for printing a domain is  "[" followed by first():last():stride()
 // for each dimension, followed by "]".  For example, a 2D Range with the
 // same sequence 1 ... 9 step 2 would be  "[1:9:2,1:9:2]"
-//
+*/
 //-----------------------------------------------------------------------------

 template<class DT>
diff -ur cvs/r2/src/Domain/DomainBlockIterator.h pooma-doc/r2/src/Domain/DomainBlockIterator.h
--- cvs/r2/src/Domain/DomainBlockIterator.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/DomainBlockIterator.h	2003-10-05 17:03:45.000000000 +0200
@@ -34,12 +34,12 @@
 //   DomainBlockIterator<Dom>
 //-----------------------------------------------------------------------------

-//-----------------------------------------------------------------------------
-// Overview:
-//
-//   DomainBlockIterator<Dom> - Iterates through domain data (of type Dom),
-//     and returns block domains (Interval or Region)
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ *   DomainBlockIterator<Dom> - Iterates through domain data (of type Dom),
+ *   and returns block domains (Interval or Region)
+ */

 //-----------------------------------------------------------------------------
 // Includes:
@@ -50,8 +50,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
-// DomainBlockIterator<Dom>
+/**
 //
 // A simple iterator class to iterate through all of the points
 // in a given domain of type Dom.  This iterator returns Interval or
@@ -75,7 +74,7 @@
 //
 // This is an input-iterator, in the STL sense.  It only defines deref,
 // ->, and ++ operators.
-//
+*/
 //-----------------------------------------------------------------------------


diff -ur cvs/r2/src/Domain/DomainCalculus.h pooma-doc/r2/src/Domain/DomainCalculus.h
--- cvs/r2/src/Domain/DomainCalculus.h	2000-03-07 14:16:34.000000000 +0100
+++ pooma-doc/r2/src/Domain/DomainCalculus.h	2003-01-16 20:46:35.000000000 +0100
@@ -37,12 +37,13 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// This file defines the prototypes for routines used in the domain
-// calculus computations.  These routines are not part of the main user
-// API, they are mainly for the domain calculus implementation.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * This file defines the prototypes for routines used in the domain
+ * calculus computations.  These routines are not part of the main user
+ * API, they are mainly for the domain calculus implementation.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -56,17 +57,20 @@
 // Forward Declarations:
 //-----------------------------------------------------------------------------

+/**
 // findLeftCommonEndpoint is used by the domain calculus routines to
 // find the leftmost common endpoint for two domains defined by
 // [a0:a1:s] and [b0:b1:t].  If an endpoint is possible, this returns
 // true and the endpoint in the final argument.  If one is not possible,
 // due to incompatible striding, this returns false and leaves the final
 // argument unchanged.
+*/

 extern
 bool findLeftCommonEndpoint(int a0, int a1, int s, int b0, int b1, int t,
                             int &endpoint);

+/**
 // findIntersectionEndpoints is used by the domain calculus routines to
 // find the endpoints and stride of an intersection domain given
 // two other strided domains defined by [a0:a1:s] and [b0:b1:t].  If
@@ -75,6 +79,7 @@
 // is possible, due to incompatible striding, this returns false and
 // leaves the final arguments unchanged.  Note that if a domain is returned,
 // it will always be true that i0 <= i1, is > 0.
+*/

 extern
 bool findIntersectionEndpoints(int a0, int a1, int s, int b0, int b1, int t,
diff -ur cvs/r2/src/Domain/DomainIterator.h pooma-doc/r2/src/Domain/DomainIterator.h
--- cvs/r2/src/Domain/DomainIterator.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/DomainIterator.h	2003-10-05 17:03:45.000000000 +0200
@@ -34,11 +34,11 @@
 //   DomainIterator<Dom>
 //-----------------------------------------------------------------------------

-//-----------------------------------------------------------------------------
-// Overview:
-//
-//   DomainIterator<Dom> - Iterates through domain data (of type Dom)
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ *   DomainIterator<Dom> - Iterates through domain data (of type Dom)
+ */

 //-----------------------------------------------------------------------------
 // Includes:
@@ -52,7 +52,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 // DomainIterator<Dom>
 //
 // A simple iterator class to iterate through all of the points
@@ -61,7 +61,7 @@
 //
 // This is an input-iterator, in the STL sense.  It only defines deref,
 // ->, and ++ operators.
-//
+*/
 //-----------------------------------------------------------------------------


diff -ur cvs/r2/src/Domain/DomainMap.h pooma-doc/r2/src/Domain/DomainMap.h
--- cvs/r2/src/Domain/DomainMap.h	2001-04-13 04:12:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/DomainMap.h	2003-01-16 20:46:35.000000000 +0100
@@ -34,16 +34,17 @@
 // DomainMap<Domain,Data>
 //-----------------------------------------------------------------------------

-//-----------------------------------------------------------------------------
-// DomainMap Overview:
-//
-// DomainMap<Domain,Data> stores a list of N domains (of type Domain), each
-// with an associated piece of data (of type Data).  The domains are stored
-// in a tree-like structure which makes it efficient to find all subdomains
-// which touch a given domain.  Using a tree, the touch operation can be done
-// in O(log(N)) time instead of O(N), since the domains are sorted.
-//
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainMap<Domain,Data> stores a list of N domains (of type Domain), each
+ * with an associated piece of data (of type Data).
+ *
+ * The domains are stored
+ * in a tree-like structure which makes it efficient to find all subdomains
+ * which touch a given domain.  Using a tree, the touch operation can be done
+ * in O(log(N)) time instead of O(N), since the domains are sorted.
+ */

 //-----------------------------------------------------------------------------
 // Include Files
@@ -61,7 +62,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainMap<Domain,Data> is templated on the type of domains it is storing,
 // and the Data type it stores for each Domain.  The purpose of DomainMap
@@ -128,7 +129,7 @@
 // a begin/end pair which can be used to iterate through all subdomains which
 // touch the domain given to the 'touch' method.  touch_iterator has
 // forward-iterator semantics, and dereferencing returns a Value_t pair.
-//
+*/
 //-----------------------------------------------------------------------------

 ///////////////////////////////////////////////////////////////////////////////
@@ -136,12 +137,13 @@


 //-----------------------------------------------------------------------------
-// DomainMapNode Overview:
+/**
 //
 // DomainMapNode is a node in a tree, where each Node has a list of domains
 // and a left and right branch.  This class is pooled since it will be
 // created and deleted often.  It contains methods for finding the left
 // and right nodes in its leaves.
+*/
 //-----------------------------------------------------------------------------

 template<class Dom, class T>
@@ -299,13 +301,14 @@


 //-----------------------------------------------------------------------------
-// DomainMapIterator Overview:
+/**
 //
 // An iterator for a DomainMap.  This has forward-iterator semantics.  It
 // is initially given a starting node and location in that node's list of
 // elements; it will iterate through the elements in the node, and then move
 // on to the next node until there are no nodes left.  When it reaches the
 // end, it sets node pointer to 0.
+*/
 //-----------------------------------------------------------------------------

 template<class Dom, class T>
@@ -380,7 +383,7 @@


 //-----------------------------------------------------------------------------
-// DomainMapConstIterator Overview:
+/**
 //
 // An iterator for a DomainMap.  This has forward-iterator semantics.  It
 // is initially given a starting node and location in that node's list of
@@ -390,6 +393,7 @@
 //
 // This is the const version of the iterator, so that the deref operator
 // returns a copy of instead of a reference to the data.
+*/
 //-----------------------------------------------------------------------------

 template<class Dom, class T>
@@ -464,12 +468,13 @@


 //-----------------------------------------------------------------------------
-// DomainMapTouchIterator Overview:
+/**
 //
 // The touch iterator for a DomainMap.  This has forward-iterator semantics.
 // This is similar to the regular DomainMapIterator, except that it only
 // returns domains which touch a given domain.  There is no const version
 // of this class.
+*/
 //-----------------------------------------------------------------------------

 template<class Dom, class T>
@@ -550,8 +555,10 @@


 //-----------------------------------------------------------------------------
+/**
 // The final class we need to define, DomainMap.  This uses the
 // Node and Iterator classes defined previously.
+*/
 //-----------------------------------------------------------------------------

 template<class Dom, class T>
@@ -765,10 +772,10 @@


 //-----------------------------------------------------------------------------
-//
+/**
 // A specialization of the Inform traits used to say that DomainMap has
 // a print method.
-//
+*/
 //-----------------------------------------------------------------------------

 template <class Dom, class T>
diff -ur cvs/r2/src/Domain/DomainRemoveOverlap.h pooma-doc/r2/src/Domain/DomainRemoveOverlap.h
--- cvs/r2/src/Domain/DomainRemoveOverlap.h	2001-03-29 02:41:21.000000000 +0200
+++ pooma-doc/r2/src/Domain/DomainRemoveOverlap.h	2003-01-16 20:46:35.000000000 +0100
@@ -34,6 +34,12 @@
 #include <iostream>
 #include <iterator>

+/** @file
+ * @ingroup Domain
+ * @brief
+ * TBD.
+ */
+
 template <int Dim>
 std::vector<Interval<Dim> >
 DomainRemoveOverlap(const Interval<Dim> & s,const Interval<Dim> &r)
diff -ur cvs/r2/src/Domain/DomainTraits.Grid.h pooma-doc/r2/src/Domain/DomainTraits.Grid.h
--- cvs/r2/src/Domain/DomainTraits.Grid.h	2003-05-20 21:30:30.000000000 +0200
+++ pooma-doc/r2/src/Domain/DomainTraits.Grid.h	2003-10-05 17:07:48.000000000 +0200
@@ -37,14 +37,17 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainTraits<Grid<N>> is a specialization of the general DomainTraits
-// class, for the case of Grid domain objects.  It defines the general
-// behavior of Grid, including its typedef and static data
-// characteristics, how to store data for a Grid, etc.  It is used by the
-// Domain base class of Grid to implement most of the public interface.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainTraits<Grid<N>> is a specialization of the general DomainTraits
+ * class, for the case of Grid domain objects.
+ *
+ * It defines the general
+ * behavior of Grid, including its typedef and static data
+ * characteristics, how to store data for a Grid, etc.  It is used by the
+ * Domain base class of Grid to implement most of the public interface.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -75,7 +78,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainTraits<Grid<Dim>> stores the characteristics and much of the
 // implementation details for Grid domain objects.  A Grid represents
@@ -93,13 +96,15 @@
 // for a domain object is only available for 1D versions of that domain
 // object, the Grid<1> specialization defines more interface functions than
 // the Grid<Dim> case.
-//
+*/
 //-----------------------------------------------------------------------------

 //-----------------------------------------------------------------------------
+/**
 // DomainTraits<Grid<Dim>>:
 // The specialization of DomainTraits for Grid, for dimensions greater than
 // one.
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -154,8 +159,10 @@


 //-----------------------------------------------------------------------------
+/**
 // DomainTraits<Grid<1>>:
 // The specialization of DomainTraits for Grid, for dimension == 1.
+*/
 //-----------------------------------------------------------------------------

 template<>
@@ -357,12 +364,12 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainChangeDim<T, int> is used to convert from a domain of one dimension
 // to another dimension (the second template parameter).
 // For Grid<Dim1>, it changes from Dim1 to Dim2.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim1, int Dim2>
Only in cvs/r2/src/Domain: DomainTraits.Grid.h.orig
diff -ur cvs/r2/src/Domain/DomainTraits.Interval.h pooma-doc/r2/src/Domain/DomainTraits.Interval.h
--- cvs/r2/src/Domain/DomainTraits.Interval.h	2003-05-20 21:30:30.000000000 +0200
+++ pooma-doc/r2/src/Domain/DomainTraits.Interval.h	2003-10-05 17:07:48.000000000 +0200
@@ -37,14 +37,17 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainTraits<Interval<N>> is a specialization of the general DomainTraits
-// class, for the case of Interval domain objects.  It defines the general
-// behavior of Interval, including its typedef and static data
-// characteristics, how to store data for a Interval, etc.  It is used by the
-// Domain base class of Interval to implement most of the public interface.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainTraits<Interval<N>> is a specialization of the general DomainTraits
+ * class, for the case of Interval domain objects.
+ *
+ * It defines the general
+ * behavior of Interval, including its typedef and static data
+ * characteristics, how to store data for a Interval, etc.  It is used by the
+ * Domain base class of Interval to implement most of the public interface.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -72,7 +75,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainTraits<Interval<Dim>> stores the characteristics and much of the
 // implementation details for Interval domain objects.  An Interval represents
@@ -87,13 +90,15 @@
 // for a domain object is only available for 1D versions of that domain
 // object, the Interval<1> specialization defines more interface functions than
 // the Interval<Dim> case.
-//
+*/
 //-----------------------------------------------------------------------------

 //-----------------------------------------------------------------------------
+/**
 // DomainTraits<Interval<Dim>>:
 // The specialization of DomainTraits for Interval, for dimensions greater than
 // one.
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -152,8 +157,10 @@


 //-----------------------------------------------------------------------------
+/**
 // DomainTraits<Interval<1>>:
 // The specialization of DomainTraits for Interval, for dimension == 1.
+*/
 //-----------------------------------------------------------------------------

 template<>
@@ -342,12 +349,12 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainChangeDim<T, int> is used to convert from a domain of one dimension
 // to another dimension (the second template parameter).
 // For Interval<Dim1>, it changes from Dim1 to Dim2.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim1, int Dim2>
Only in cvs/r2/src/Domain: DomainTraits.Interval.h.orig
diff -ur cvs/r2/src/Domain/DomainTraits.Loc.h pooma-doc/r2/src/Domain/DomainTraits.Loc.h
--- cvs/r2/src/Domain/DomainTraits.Loc.h	2003-05-20 21:30:30.000000000 +0200
+++ pooma-doc/r2/src/Domain/DomainTraits.Loc.h	2003-10-05 17:07:48.000000000 +0200
@@ -37,14 +37,31 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainTraits<Loc<N>> is a specialization of the general DomainTraits
-// class, for the case of Loc domain objects.  It defines the general
-// behavior of Loc, including its typedef and static data characteristics,
-// how to store data for a Loc, etc.  It is used by the Domain base class
-// of Loc to implement most of the public interface.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainTraits<Loc<N>> is a specialization of the general DomainTraits
+ * class, for the case of Loc domain objects.
+ *
+ * It defines the general
+ * behavior of Loc, including its typedef and static data characteristics,
+ * how to store data for a Loc, etc.  It is used by the Domain base class
+ * of Loc to implement most of the public interface.
+ *
+// DomainTraits<Loc<Dim>> stores the characteristics and much of the
+// implementation details for Loc domain objects.  A Loc acts like a
+// single integer point in N-dimensional space, so it is a single-valued,
+// unit-stride domain.
+//
+// A general version of DomainTraits<Loc<Dim>> is defined here, which
+// only includes the basic information to make Loc<Dim> look like an
+// array of Loc<1> objects.  DomainTraits<Loc<1>> is a more specific
+// specialization which provides most of the necessary interface information
+// for items which need to know about Loc.  Since most of the interface
+// for a domain object is only available for 1D versions of that domain
+// object, the Loc<1> specialization defines more interface functions than
+// the Loc<Dim> case.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -69,29 +86,11 @@


 //-----------------------------------------------------------------------------
-//
-// Full Description:
-//
-// DomainTraits<Loc<Dim>> stores the characteristics and much of the
-// implementation details for Loc domain objects.  A Loc acts like a
-// single integer point in N-dimensional space, so it is a single-valued,
-// unit-stride domain.
-//
-// A general version of DomainTraits<Loc<Dim>> is defined here, which
-// only includes the basic information to make Loc<Dim> look like an
-// array of Loc<1> objects.  DomainTraits<Loc<1>> is a more specific
-// specialization which provides most of the necessary interface information
-// for items which need to know about Loc.  Since most of the interface
-// for a domain object is only available for 1D versions of that domain
-// object, the Loc<1> specialization defines more interface functions than
-// the Loc<Dim> case.
-//
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
+/**
 // DomainTraits<Loc<Dim>>:
 // The specialization of DomainTraits for Loc, for dimensions greater than
 // one.
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -217,8 +216,10 @@


 //-----------------------------------------------------------------------------
+/**
 // DomainTraits<Loc<1>>:
 // The specialization of DomainTraits for Loc, for dimension == 1.
+*/
 //-----------------------------------------------------------------------------

 template<>
@@ -405,12 +406,12 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainChangeDim<T, int> is used to convert from a domain of one dimension
 // to another dimension (the second template parameter).
 // For Loc<Dim1>, it changes from Dim1 to Dim2.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim1, int Dim2>
Only in cvs/r2/src/Domain: DomainTraits.Loc.h.orig
diff -ur cvs/r2/src/Domain/DomainTraits.Range.h pooma-doc/r2/src/Domain/DomainTraits.Range.h
--- cvs/r2/src/Domain/DomainTraits.Range.h	2003-05-20 21:30:30.000000000 +0200
+++ pooma-doc/r2/src/Domain/DomainTraits.Range.h	2003-10-05 17:07:48.000000000 +0200
@@ -37,14 +37,17 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainTraits<Range<N>> is a specialization of the general DomainTraits
-// class, for the case of Range domain objects.  It defines the general
-// behavior of Range, including its typedef and static data
-// characteristics, how to store data for a Range, etc.  It is used by the
-// Domain base class of Range to implement most of the public interface.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainTraits<Range<N>> is a specialization of the general DomainTraits
+ * class, for the case of Range domain objects.
+ *
+ * It defines the general
+ * behavior of Range, including its typedef and static data
+ * characteristics, how to store data for a Range, etc.  It is used by the
+ * Domain base class of Range to implement most of the public interface.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -72,7 +75,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainTraits<Range<Dim>> stores the characteristics and much of the
 // implementation details for Range domain objects.  A Range represents
@@ -86,13 +89,15 @@
 // for a domain object is only available for 1D versions of that domain
 // object, the Range<1> specialization defines more interface functions than
 // the Range<Dim> case.
-//
+*/
 //-----------------------------------------------------------------------------

 //-----------------------------------------------------------------------------
+/**
 // DomainTraits<Range<Dim>>:
 // The specialization of DomainTraits for Range, for dimensions greater than
 // one.
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -353,12 +358,12 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainChangeDim<T, int> is used to convert from a domain of one dimension
 // to another dimension (the second template parameter).
 // For Range<Dim1>, it changes from Dim1 to Dim2.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim1, int Dim2>
Only in cvs/r2/src/Domain: DomainTraits.Range.h.orig
diff -ur cvs/r2/src/Domain/DomainTraits.Region.h pooma-doc/r2/src/Domain/DomainTraits.Region.h
--- cvs/r2/src/Domain/DomainTraits.Region.h	2003-05-20 21:30:30.000000000 +0200
+++ pooma-doc/r2/src/Domain/DomainTraits.Region.h	2003-10-05 17:07:48.000000000 +0200
@@ -37,14 +37,17 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainTraits<Region<N,T>> is a specialization of the general DomainTraits
-// class, for the case of Region domain objects.  It defines the general
-// behavior of Region, including its typedef and static data
-// characteristics, how to store data for a Region, etc.  It is used by the
-// Domain base class of Region to implement most of the public interface.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainTraits<Region<N,T>> is a specialization of the general DomainTraits
+ * class, for the case of Region domain objects.
+ *
+ * It defines the general
+ * behavior of Region, including its typedef and static data
+ * characteristics, how to store data for a Region, etc.  It is used by the
+ * Domain base class of Region to implement most of the public interface.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -69,7 +72,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainTraits<Region<Dim,T>> stores the characteristics and much of the
 // implementation details for Region domain objects.  A Region represents
@@ -86,12 +89,14 @@
 // for a domain object is only available for 1D versions of that domain
 // object, the Region<1,T> specialization defines more interface functions than
 // the Region<Dim,T> case.
-//
+*/
 //-----------------------------------------------------------------------------

 //-----------------------------------------------------------------------------
+/**
 // DomainTraits<Region<Dim,T>>:
 // The traits for an N-dimensional Region domain.
+*/
 //-----------------------------------------------------------------------------

 template<int Dim, class T>
@@ -145,8 +150,10 @@


 //-----------------------------------------------------------------------------
+/**
 // DomainTraits<Region<Dim,T>>:
 // The traits for an 1-dimensional Region domain.
+*/
 //-----------------------------------------------------------------------------

 template<class T>
@@ -363,8 +370,10 @@


 //-----------------------------------------------------------------------------
+/**
 // DomainTraits<Region<1,POOMA_DEFAULT_POSITION_TYPE>>:
 // The traits for an 1-dimensional Region of type POOMA_DEFAULT_POSITION_TYPE.
+*/
 //-----------------------------------------------------------------------------

 template<>
@@ -579,12 +588,12 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainChangeDim<T, int> is used to convert from a domain of one dimension
 // to another dimension (the second template parameter).
 // For Region<Dim1>, it changes from Dim1 to Dim2.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim1, int Dim2, class T>
diff -ur cvs/r2/src/Domain/DomainTraits.SliceInterval.h pooma-doc/r2/src/Domain/DomainTraits.SliceInterval.h
--- cvs/r2/src/Domain/DomainTraits.SliceInterval.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/DomainTraits.SliceInterval.h	2003-10-05 17:03:45.000000000 +0200
@@ -36,15 +36,17 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainTraits<SliceInterval<Dim,SliceDim>> is a specialization of the
-// general DomainTraits class, for the case of SliceInterval domain objects.
-// It defines the general behavior of SliceInterval, including its typedef
-// and static data characteristics, how to store data for a SliceInterval, etc.
-// It is used by the SliceDomain base class of SliceInterval to implement most
-// of the public interface.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainTraits<SliceInterval<Dim,SliceDim>> is a specialization of the
+ * general DomainTraits class, for the case of SliceInterval domain objects.
+ *
+ * It defines the general behavior of SliceInterval, including its typedef
+ * and static data characteristics, how to store data for a SliceInterval, etc.
+ * It is used by the SliceDomain base class of SliceInterval to implement most
+ * of the public interface.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -67,7 +69,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainTraits<SliceInterval<Dim,SliceDim>> stores the characteristics and
 // much of the implementation details for SliceInterval domain objects.
@@ -91,7 +93,7 @@
 //
 // static OneDomain_t &getDomain(Domain_t &d, int n);
 // static OneDomain_t &getSliceDomain(Domain_t &d, int n);
-//
+*/
 //-----------------------------------------------------------------------------

 template<int TotalDim, int SliceDim>
diff -ur cvs/r2/src/Domain/DomainTraits.SliceRange.h pooma-doc/r2/src/Domain/DomainTraits.SliceRange.h
--- cvs/r2/src/Domain/DomainTraits.SliceRange.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/DomainTraits.SliceRange.h	2003-10-05 17:03:45.000000000 +0200
@@ -36,15 +36,17 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainTraits<SliceRange<Dim,SliceDim>> is a specialization of the
-// general DomainTraits class, for the case of SliceRange domain objects.
-// It defines the general behavior of SliceRange, including its typedef
-// and static data characteristics, how to store data for a SliceRange, etc.
-// It is used by the SliceDomain base class of SliceRange to implement most
-// of the public interface.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainTraits<SliceRange<Dim,SliceDim>> is a specialization of the
+ * general DomainTraits class, for the case of SliceRange domain objects.
+ *
+ * It defines the general behavior of SliceRange, including its typedef
+ * and static data characteristics, how to store data for a SliceRange, etc.
+ * It is used by the SliceDomain base class of SliceRange to implement most
+ * of the public interface.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -67,7 +69,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainTraits<SliceRange<Dim,SliceDim>> stores the characteristics and
 // much of the implementation details for SliceRange domain objects.
@@ -91,7 +93,7 @@
 //
 // static OneDomain_t &getDomain(Domain_t &d, int n);
 // static OneDomain_t &getSliceDomain(Domain_t &d, int n);
-//
+*/
 //-----------------------------------------------------------------------------

 template<int TotalDim, int SliceDim>
diff -ur cvs/r2/src/Domain/DomainTraits.h pooma-doc/r2/src/Domain/DomainTraits.h
--- cvs/r2/src/Domain/DomainTraits.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/DomainTraits.h	2003-10-05 17:03:45.000000000 +0200
@@ -39,19 +39,22 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainTraits is a traits class for domain objects.  This traits class
-// is used to specialize the Domain and DomainBase base classes for all
-// domain objects to do the proper action for that domain type, and to store
-// the proper information.
-//
-// DomainChangeDim is a simple struct used to convert a domain of type T
-// with a certain number of dimensions Dim1, to the same general type of
-// domain but with a different number of dimensions Dim2.  It defines two
-// typedefs 'OldType_t' and 'NewType_t' with the type of domain with Dim1
-// and Dim2, respectively.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainTraits is a traits class for domain objects. Includes DomainChangeDim.
+ *
+ * This traits class
+ * is used to specialize the Domain and DomainBase base classes for all
+ * domain objects to do the proper action for that domain type, and to store
+ * the proper information.
+ *
+ * DomainChangeDim is a simple struct used to convert a domain of type T
+ * with a certain number of dimensions Dim1, to the same general type of
+ * domain but with a different number of dimensions Dim2.  It defines two
+ * typedefs 'OldType_t' and 'NewType_t' with the type of domain with Dim1
+ * and Dim2, respectively.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -90,7 +93,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of DomainTraits<T>:
+/**
 //
 // DomainTraits<T> is a traits class which provides all the specific
 // information and functionality to specialize how a given domain object
@@ -211,7 +214,7 @@
 //        ==> change the domain to the values in newdom, which should be
 //            a domain object with the proper interface, or an integer.
 //
-//      static void setDomain(Storage_t &dom, /** necessary args **/)
+//      static void setDomain(Storage_t &dom, ** necessary args **)
 //        ==> change the domain to the values from a specialized list of
 //            information, which is domain-type specific.  For example, for
 //            Range, this takes three extra args: first, last, stride
@@ -291,10 +294,11 @@
 //      If you need to provide special traits for
 //      any other scalars, then have the specialization of DomainTraits
 //      inherit from DomainTraitsScalar.
-//
+*/
 //-----------------------------------------------------------------------------

 //-----------------------------------------------------------------------------
+/**
 // DomainTraitsDomain<DomT, T, Dim> can act as a base class for the partially-
 // specialized versions of DomainTraits for domain-like classes, that is,
 // classes which are derived from Domain.  It it templated on the types to
@@ -303,6 +307,7 @@
 // domain and dimensions, while the 1-D version also provided implementations
 // of the static get* methods (such as getFirst, getMin, etc).  Just inherit
 // from DomainTraitsDomain if you're defining traits for a new Domain subclass.
+*/
 //-----------------------------------------------------------------------------

 // N-dimensional version of DomainTraitsDomain
@@ -323,7 +328,9 @@
   static bool      getIgnorable(const Domain_t &, int)   { return false; }
 };

+/**
 // 1-dimensional specialized version of DomainTraitsDomain
+*/
 template<class DomT, class T>
 struct DomainTraitsDomain<DomT, T, 1>
 {
@@ -366,6 +373,7 @@


 //-----------------------------------------------------------------------------
+/**
 // DomainTraitsScalar<DomT, T, NewDom1T> can act as a base class for partially
 // specialized versions of DomainTraits for non-domain classes and types,
 // such as the basic scalar types. It it templated on the types to use for
@@ -379,6 +387,7 @@
 //   for a scalar, the stride and length are always 1 and integers
 //   for a scalar, getEmpty() is always false
 //   for a scalar, getLoop() always returns 0 as an integer
+*/
 //-----------------------------------------------------------------------------

 template<class DomT, class T, class NewDom1T>
@@ -437,10 +446,10 @@


 //-----------------------------------------------------------------------------
-//
+/**
 // So now, finally, we can define the default version of DomainTraits<T>
 // which just inherits from DomainTraitsScalar<T, T, T>
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T>
@@ -470,7 +479,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of DomainChangeDim<T,Dim>:
+/**
 //
 // DomainChangeDim is a struct which is templated on a domain of type T,
 // which has some original number of dimensions oldDim, and a new number
@@ -487,7 +496,7 @@
 // We define here the basic form of the struct, but empty.  Specialized
 // domain types such define a partially specialized version of this struct
 // with the above typedefs and static data relevant to that domain type.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T, int Dim>
@@ -502,7 +511,9 @@
 };


+/**
 // global function templates for invoking DomainTraits::setDomain()
+*/

 template <class Dom, class Storage, class T1, class T2>
 inline void
diff -ur cvs/r2/src/Domain/DomainTraits.int.h pooma-doc/r2/src/Domain/DomainTraits.int.h
--- cvs/r2/src/Domain/DomainTraits.int.h	2001-04-13 04:12:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/DomainTraits.int.h	2003-01-16 20:46:35.000000000 +0100
@@ -36,19 +36,22 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// DomainTraits<int> is a specialization of the general DomainTraits
-// class, for the case of integers.  Integers can often be used in
-// combination with other domain types, and the traits class defines how
-// they interact with those other domains.  Generally, an int gets promoted
-// to a Loc or Interval, based on the context, but in some cases the
-// int is used directly.
-//
-// This also defines the same kind of traits for long, char and short.
-// Both are treated just as if they were int's for Domain purposes.  The
-// same is true for the unsigned versions of these integral types.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * DomainTraits<int> is a specialization of the general DomainTraits
+ * class, for the case of integers.
+ *
+ * Integers can often be used in
+ * combination with other domain types, and the traits class defines how
+ * they interact with those other domains.  Generally, an int gets promoted
+ * to a Loc or Interval, based on the context, but in some cases the
+ * int is used directly.
+ *
+ * This also defines the same kind of traits for long, char and short.
+ * Both are treated just as if they were int's for Domain purposes.  The
+ * same is true for the unsigned versions of these integral types.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -71,7 +74,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainTraits<int> stores the characteristics of integers when they are
 // used to specify domains in expressions and object constructors.  An int
@@ -87,6 +90,7 @@
 // Identical traits are defined for long, char and short.  Both integral types
 // are treated just as if they were ints; they get converted to Interval
 // or Loc objects in almost all cases.  The same is true to unsigned versions.
+*/
 //-----------------------------------------------------------------------------

 template<>
diff -ur cvs/r2/src/Domain/EquivSubset.h pooma-doc/r2/src/Domain/EquivSubset.h
--- cvs/r2/src/Domain/EquivSubset.h	2003-05-20 22:08:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/EquivSubset.h	2003-10-05 17:07:48.000000000 +0200
@@ -39,17 +39,20 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// domain4 equivSubset(domain1,domain2,domain3) is a global function
-// which finds the 'equivalent subset' for domain3 given a linear relationship
-// between domain1 and domain2.  For example, given the relationship
-//    I --> 2I - 1
-// and a domain  3J, then the equivalent subset is
-//    3J --> 2(3J) - 1 = 6J - 1
-// The returned domain type is the most general type which could hold
-// the data in the domains 1, 2 and 3.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * domain4 equivSubset(domain1,domain2,domain3) is a global function
+ * which finds the 'equivalent subset' for domain3 given a linear relationship
+ * between domain1 and domain2.
+ *
+ * For example, given the relationship
+ *    I --> 2I - 1
+ * and a domain  3J, then the equivalent subset is
+ *    3J --> 2(3J) - 1 = 6J - 1
+ * The returned domain type is the most general type which could hold
+ * the data in the domains 1, 2 and 3.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -71,7 +74,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of EquivSubsetDomainSingle:
+/**
 //
 // EquivSubsetDomainSingle<T1,T2,T3,T4,int Dim,bool strided>::equiv(a,b,c,d)
 // finds the equivalent subset for c given the relationship between a and b,
@@ -80,16 +83,16 @@
 // to the following two cases:
 //   strided == false: all the domains have unit stride.
 //   strided == true: one or more domains have non-unit stride.
-//
+*/
 //-----------------------------------------------------------------------------

-//
+/**
 // The default (unit-stride) version of EquivSubsetDomainSingle, which assumes
 // that all arguments to 'equiv' are domains with unit stride.  The fourth
 // argument, the returned equivalent subset domain, is assumed to have been
 // set equal to the third domain beforehand.  It will be offset and
 // scaled in the same way that the second is from the first.
-//
+*/

 template<class T1, class T2, class T3, int Dim, bool strided>
 struct EquivSubsetDomainSingle {
@@ -100,7 +103,7 @@
   }
 };

-//
+/**
 // The non-unit-stride version of EquivSubsetDomainSingle, which does extra
 // work for the case where a, b, or c do not have unit stride.  The fourth
 // argument, the returned equivalent subset domain, is assumed to have been
@@ -117,7 +120,7 @@
 //      using the first point in the domains a and b.
 //   2. Apply the linear transformation to the third domain to get the fourth:
 //         d = m c + k
-//
+*/

 template<class T1, class T2, class T3, int Dim>
 struct EquivSubsetDomainSingle<T1,T2,T3,Dim,true> {
@@ -142,7 +145,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of EquivSubsetDomain:
+/**
 //
 // EquivSubsetDomain implements a basic template meta-program to find the
 // equiv subset of each dimension separately of the multidimensional domains.
@@ -156,7 +159,7 @@
 // c --> d in the same way that a --> b, we can set things here so that we
 // first set d == c, and then modify d accordingly.  So, this struct assumes
 // that d == c already, and does not need to have c provided in another var.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T1, class T2, class T3, int Dim>
@@ -200,7 +203,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of equivSubset:
+/**
 //
 // domain4 equivSubset(domain1,domain2,domain3) is a global function
 // which finds the 'equivalent subset' for domain3 given a linear relationship
@@ -216,15 +219,17 @@
 // The implementation of equivSubset is deferred to the EquivSubsetDomain
 // struct, which performs the intersection for each dimension and and's
 // the results together.
-//
+*/
 //-----------------------------------------------------------------------------

+/**
 // first, a simple struct used to figure out the return type when examining
 // types T1,T2,T3.  It defines a typedef 'Type_t' for what the return type is.
 // Note that we use the 'DomainChangeDim' mechanism after we find out the
 // type when combining T1,T2,T3, since the combined type will have a
 // dimension of dim(T1) + dim(T2) + dim(T3), and we want the dim to be
 // the same as T1.
+*/
 template<class T1, class T2, class T3>
 struct EquivSubsetReturnType {
   typedef typename NewDomain3<T1,T2,T3>::Type_t Combine_t;
@@ -232,7 +237,9 @@
     DomainChangeDim<Combine_t,DomainTraits<T1>::dimensions>::NewType_t Type_t;
 };

+/**
 // now, finally, the intersect method
+*/
 template<class T1, class T2, class T3>
 inline typename EquivSubsetReturnType<T1,T2,T3>::Type_t
 equivSubset(const T1 &a, const T2 &b, const T3 &c)
diff -ur cvs/r2/src/Domain/Grid.h pooma-doc/r2/src/Domain/Grid.h
--- cvs/r2/src/Domain/Grid.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/Grid.h	2003-10-05 17:03:45.000000000 +0200
@@ -36,18 +36,21 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// Grid is a general type of integer domain, which refers to a set of points
-// a0, a1, ... aN for each dimension.  The points can be any ascending or
-// descending sequence, there is no fixed stride.  This is basically a set
-// of Dim IndirectionList<int>'s, one for each dimension; the total domain
-// is the tensor product of these lists.  Grid<Dim> is basically an array
-// of Grid<1> objects.
-//
-// Grid defers most of its implementation to the Domain<DomainTraits<Grid>>
-// base class.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * Grid is a general type of integer domain, which refers to a set of points
+ * a0, a1, ... aN for each dimension.
+ *
+ * The points can be any ascending or
+ * descending sequence, there is no fixed stride.  This is basically a set
+ * of Dim IndirectionList<int>'s, one for each dimension; the total domain
+ * is the tensor product of these lists.  Grid<Dim> is basically an array
+ * of Grid<1> objects.
+ *
+ * Grid defers most of its implementation to the Domain<DomainTraits<Grid>>
+ * base class.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -71,7 +74,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of Grid:
+/**
 //
 // Grid<N> is a domain representing a set of N numeric sequences, one
 // for each dimension N.  The sequences are lists of ascending or descending
@@ -159,7 +162,7 @@
 // after the general case that has different constructors.
 //
 // Grid inherits much of its activity from Domain<DomainTraits<Grid>>
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -306,7 +309,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of Grid<1>:
+/*
 //
 // Grid<1> is a 1D specialization of Grid<N>; for the 1D case,
 // there are only a restricted set of constructors available.
@@ -318,7 +321,7 @@
 //   Grid<1> a(m,n,s) - sets the Grid to the sequence [m ... n], stride s
 //   Grid<1> a(Domain d) : a Grid copied from d, which must be a
 //     1D domain object.
-//
+*/
 //-----------------------------------------------------------------------------

 template<>
diff -ur cvs/r2/src/Domain/IndirectionList.h pooma-doc/r2/src/Domain/IndirectionList.h
--- cvs/r2/src/Domain/IndirectionList.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/IndirectionList.h	2003-10-05 17:03:45.000000000 +0200
@@ -36,14 +36,16 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-//
-// IndirectionList<T> is a class that takes any object with an
-// Array-like interface and stores the information as a list of elements
-// of type T.  It is meant to store lists of indices for indirection-list
-// operations.  T can be an int, or multidimensional items like Loc<Dim>.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * IndirectionList<T> is a class that takes any object with an
+ * Array-like interface and stores the information as a list of elements
+ * of type T.
+ *
+ * It is meant to store lists of indices for indirection-list
+ * operations.  T can be an int, or multidimensional items like Loc<Dim>.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -64,7 +66,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of IndirectionList:
+/**
 //
 // IndirectionList is a domain representing a N dimension set of integer
 // sequences.  It is always a 1D list, but can store data of multiple
@@ -121,7 +123,7 @@
 //   int min(), int max() - min or max of the endpoints.
 //   IndirectionList::iterator begin() and end() - return iterators for
 //   the 1D domain.  These act like (at least) forward iterators.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T>
diff -ur cvs/r2/src/Domain/IndirectionListIterator.h pooma-doc/r2/src/Domain/IndirectionListIterator.h
--- cvs/r2/src/Domain/IndirectionListIterator.h	2001-04-13 04:12:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/IndirectionListIterator.h	2003-01-16 20:46:35.000000000 +0100
@@ -34,11 +34,11 @@
 //   IndirectionListIterator
 //-----------------------------------------------------------------------------

-//-----------------------------------------------------------------------------
-// Overview:
-//
-//   IndirectionListIterator - Iterates through IndirectionList<T> elements.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * IndirectionListIterator - Iterates through IndirectionList<T> elements.
+ */

 //-----------------------------------------------------------------------------
 // Includes:
@@ -58,12 +58,11 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
-// IndirectionListIterator
+/**
 //
 // A random access iterator class that iterates through all of the elements
 // of an IndirectionList<T>, returning T's when dereferenced.
-//
+*/
 //-----------------------------------------------------------------------------

 template <class T>
diff -ur cvs/r2/src/Domain/Intersect.h pooma-doc/r2/src/Domain/Intersect.h
--- cvs/r2/src/Domain/Intersect.h	2003-05-20 22:08:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/Intersect.h	2003-10-05 17:07:48.000000000 +0200
@@ -39,16 +39,20 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// domain3 intersect(domain1,domain2) is a global function which determines if
-// two domains intersect with each other, and if so, what their
-// intersection is.  By 'intersect', we mean the set of points which are
-// found in BOTH domains, expressed as a new domain.  If they have no
-// points in common, this returns an empty domain.  The type of domain
-// returned is the most general domain type which can store the information
-// from domain1 and domain2.
-//-----------------------------------------------------------------------------
+
+/** @file
+ * @ingroup Domain
+ * @brief
+ * domain3 intersect(domain1,domain2) is a global function which determines if
+ * two domains intersect with each other, and if so, what their
+ * intersection is.
+ *
+ * By 'intersect', we mean the set of points which are
+ * found in BOTH domains, expressed as a new domain.  If they have no
+ * points in common, this returns an empty domain.  The type of domain
+ * returned is the most general domain type which can store the information
+ * from domain1 and domain2.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -71,7 +75,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of IntersectDomainSingle:
+/**
 //
 // IntersectDomainSingle<T1,T2,T3,int Dim,bool strided>::intersect(a,b,c)
 // finds the intersection of two domains a and b of type T1 and T2, and
@@ -89,13 +93,13 @@
 //                    they will not have any points in common due to the
 //                    striding.  We only do this long calculation when
 //                    absolutely necessary.
-//
+*/
 //-----------------------------------------------------------------------------

-//
+/**
 // The default (unit-stride) version of IntersectDomainSingle, which assumes
 // that both arguments to 'intersect' are 1D domains with unit stride
-//
+*/

 template<class T1, class T2, class T3, int Dim, bool strided>
 struct IntersectDomainSingle {
@@ -126,10 +130,10 @@
   }
 };

-//
+/**
 // The non-unit-stride version of IntersectDomainSingle, which does extra
 // work for the case where a or b do not have unit stride.
-//
+*/

 template<class T1, class T2, class T3, int Dim>
 struct IntersectDomainSingle<T1,T2,T3,Dim,true> {
@@ -180,7 +184,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of IntersectDomain:
+/**
 //
 // IntersectDomain implements a basic template meta-program to
 // intersect each dimension separately of the multidimensional domains.
@@ -189,7 +193,7 @@
 // or not.  A general version of IntersectDomain is defined, to intersect the
 // domains in the 'Dim' dimension, and then a specialization is provided
 // for Dim==1 that stops the metaprogram recursion.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T1, class T2, class T3, int Dim>
@@ -235,7 +239,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of intersect:
+/**
 //
 // domain3 intersect(domain1,domain2) is a global function which determines if
 // two domains intersect with each other, and if so, what their
@@ -250,14 +254,16 @@
 // The implementation of intersect is deferred to the IntersectDomain
 // struct, which performs the intersection for each dimension and and's
 // the results together.
-//
+*/
 //-----------------------------------------------------------------------------

+/**
 // first, a simple struct used to figure out the return type when intersecting
 // types T1 and T2.  It defines a typedef 'Type_t' for what the return type is.
 // Note that we use the 'DomainChangeDim' mechanism after we find out the
 // type when combining T1 and T2, since the combined type will have a
 // dimension of dim(T1) + dim(T2), and we want the dim to be the same as T1.
+*/
 template<class T1, class T2>
 struct IntersectReturnType {
   typedef typename NewDomain2<T1,T2>::Type_t Combine_t;
@@ -265,7 +271,9 @@
     DomainChangeDim<Combine_t,DomainTraits<T1>::dimensions>::NewType_t Type_t;
 };

+/**
 // now, finally, the intersect method
+*/
 template<class T1, class T2>
 inline typename IntersectReturnType<T1,T2>::Type_t
 intersect(const T1 &a, const T2 &b)
diff -ur cvs/r2/src/Domain/Interval.h pooma-doc/r2/src/Domain/Interval.h
--- cvs/r2/src/Domain/Interval.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/Interval.h	2003-10-05 17:03:45.000000000 +0200
@@ -36,15 +36,17 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// Interval is a very simple type of domain, which refers to a set of points
-// a, a+1, a+2, ..., b.  It has a hard-coded stride of 1.  Interval<N>
-// is basically an array of Interval<1> objects.
-//
-// Interval defers most of its implementation to the
-// Domain<DomainTraits<Interval>> base class.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * Interval is a very simple type of domain, which refers to a set of points
+ * a, a+1, a+2, ..., b.
+ *
+ * It has a hard-coded stride of 1.  Interval<N>
+ * is basically an array of Interval<1> objects.
+ * Interval defers most of its implementation to the
+ * Domain<DomainTraits<Interval>> base class.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -66,7 +68,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of Interval:
+/**
 //
 // Interval<N> is a domain representing a set of N numeric sequences, one
 // for each dimension N.  The sequences have endpoints [a,b], and a
@@ -141,7 +143,7 @@
 //
 // For the special case of Interval<1>, there is a specialization given
 // after the general case that has different constructors (listed above).
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -276,7 +278,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of Interval<1>:
+/**
 //
 // Interval<1> is a 1D specialization of Interval<N>; for the 1D case,
 // there are only a restricted set of constructors available.
@@ -287,7 +289,7 @@
 //   Interval<1> a(m,n) - sets the Interval to the sequence [m ... n]
 //   Interval<1> a(Domain d) - an Interval copied from d, which must be a
 //     1D domain object.
-//
+*/
 //-----------------------------------------------------------------------------

 template<>
diff -ur cvs/r2/src/Domain/IntervalIterator.h pooma-doc/r2/src/Domain/IntervalIterator.h
--- cvs/r2/src/Domain/IntervalIterator.h	2001-04-13 04:12:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/IntervalIterator.h	2003-01-16 20:46:35.000000000 +0100
@@ -34,11 +34,11 @@
 //   IntervalIterator
 //-----------------------------------------------------------------------------

-//-----------------------------------------------------------------------------
-// Overview:
-//
-//   IntervalIterator - Iterates through Interval<1> points.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ *   IntervalIterator - Iterates through Interval<1> points.
+ */

 //-----------------------------------------------------------------------------
 // Includes:
@@ -58,12 +58,11 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
-// IntervalIterator
+/**
 //
 // A random access iterator class that iterates through all of the points
 // of an Interval<1>, returning ints when dereferenced.
-//
+*/
 //-----------------------------------------------------------------------------

 class IntervalIterator
diff -ur cvs/r2/src/Domain/IteratorPairDomain.h pooma-doc/r2/src/Domain/IteratorPairDomain.h
--- cvs/r2/src/Domain/IteratorPairDomain.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/IteratorPairDomain.h	2003-10-05 17:03:45.000000000 +0200
@@ -77,18 +77,20 @@

 namespace Pooma {

-//-----------------------------------------------------------------------------
-// Overview:
-//
-// IteratorPairDomain<Iter> wraps a pair of iterators and provides a
-// subset of services provided by other 1D domains, and in particular by
-// IndirectionList.  It is meant to be used in places where
-// IndirectionList might be used, but it should be cheaper since it is
-// just storing a pair of iterators.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * IteratorPairDomain<Iter> wraps a pair of iterators and provides a
+ * subset of services provided by other 1D domains, and in particular by
+ * IndirectionList.
+ *
+ * It is meant to be used in places where
+ * IndirectionList might be used, but it should be cheaper since it is
+ * just storing a pair of iterators.
+ */

 //-----------------------------------------------------------------------------
-// Full Description of IteratorPairDomain:
+/**
 //
 // Like IndirectionList<T>, IteratorPairDomain<T_Iter> provides access
 // to an arbitrary sequence of T values. Rather than storing these in
@@ -161,6 +163,7 @@
 //   Iter end()         - iterator to the end of the sequence.
 //   Element_t max()    - returns the largest element (assumes operator<())
 //   Element_t min()    - returns the smallest element (assumes operator<())
+*/
 //-----------------------------------------------------------------------------

 template <class Iter>
Only in cvs/r2/src/Domain: LINUXgcc
Only in cvs/r2/src/Domain: LINUXgcc295
Only in cvs/r2/src/Domain: LINUXgcc32
Only in cvs/r2/src/Domain: LINUXgcc32g
diff -ur cvs/r2/src/Domain/LeftDomain.h pooma-doc/r2/src/Domain/LeftDomain.h
--- cvs/r2/src/Domain/LeftDomain.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/LeftDomain.h	2003-10-05 17:03:45.000000000 +0200
@@ -37,18 +37,19 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-//
-// LeftDomain is one of the domain wildcards, which are used when constructing
-// other domains using specific combination rules.  LeftDomain means to use
-// the starting endpoint of the domain of a second 'reference' domain, with
-// a new user-provided right endpoint, when constructing a new
-// domain.  It is also used when constructing new domains with no other
-// arguments to mean that the domain should not be initialized, which can
-// save considerable time in some circumstances.
-//
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * LeftDomain is one of the domain wildcards, which are used when constructing
+ * other domains using specific combination rules.
+ *
+ * LeftDomain means to use
+ * the starting endpoint of the domain of a second 'reference' domain, with
+ * a new user-provided right endpoint, when constructing a new
+ * domain.  It is also used when constructing new domains with no other
+ * arguments to mean that the domain should not be initialized, which can
+ * save considerable time in some circumstances.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -69,7 +70,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of LeftDomain:
+/**
 //
 // LeftDomain is a special domain class which is used as a 'wildcard'.
 // Wildcards are useful when constructing new domains based on some other
@@ -89,7 +90,7 @@
 // dimensions should not be initialized, which can be helpful to avoid
 // extra unneeded work when the domain will be filled with new values very
 // soon.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -223,7 +224,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainTraits<LeftDomain<Dim>> provides traits information about LeftDomain,
 // which is one of the domain wildcards.  It has a quite stripped-down
@@ -232,7 +233,7 @@
 // dimension and the type of the wildcard, and an enum indicating that it is
 // a wildcard.  Also, getDomain returns a 1D element of the N-dimensional
 // list of wildcards.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
diff -ur cvs/r2/src/Domain/Loc.h pooma-doc/r2/src/Domain/Loc.h
--- cvs/r2/src/Domain/Loc.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/Loc.h	2003-10-05 17:03:45.000000000 +0200
@@ -36,15 +36,16 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// Loc<N> is a very simple type of domain, which refers to just one point.
-// It acts very much like an N-dimensional vector of integers.  It can be
-// used to refer to a single point along a sequence of points in a domain.
-//
-// Loc defers most of its implementation to the Domain<DomainTraits<Loc>>
-// base class.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * Loc<N> is a very simple type of domain, which refers to just one point.
+ *
+ * It acts very much like an N-dimensional vector of integers.  It can be
+ * used to refer to a single point along a sequence of points in a domain.
+ * Loc defers most of its implementation to the Domain<DomainTraits<Loc>>
+ * base class.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -68,7 +69,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of Loc:
+/**
 //
 // Loc<N> is a domain representing a single N-dimensional point.  It has
 // a stride of one, endpoints which are the same, and a single element.
@@ -137,16 +138,18 @@
 // only contains Loc<N> constructors, destructor, and operator= methods.
 // All other interface methods are in Domain, or in DomainBase (from
 // which Domain inherits).
-//
+*/
 //-----------------------------------------------------------------------------

 //-----------------------------------------------------------------------------
+/**
 // fillLocStorage descriptions:
 //   fillLocStorage is a function (actually a set of overloaded functions)
 // that copies data from a given domain into a Loc.  It will modify the
 // second argument (the loc) starting at the index given by the first
 // argument.  The first argument will be incremented by the number of
 // dimensions filled in to the Loc.  This is defines for 1 ... 7 arguments.
+*/
 //-----------------------------------------------------------------------------

 template<int Dim, class T1>
@@ -222,12 +225,14 @@


 //-----------------------------------------------------------------------------
+/**
 // Full description of CopyLocStorage:
 //   CopyLocStorage is a simple struct with one static member 'copy' that
 // copies data out of a given single domain into the given Loc.  If the
 // data is greater than 1D, only the dimensions of the given domain are copied.
 // If the data is 1D, then the value of the domain is copied into all 'Dim'
 // dimensions of the Loc.  So there is a 1D specialization of CopyLocStorage.
+*/
 //-----------------------------------------------------------------------------

 template<int Dim, class T, int DimT, bool wildcard>
@@ -271,7 +276,9 @@
 };

 //-----------------------------------------------------------------------------
+/**
 // N-Dimensional Loc class declaration and definition
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -464,7 +471,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of Loc<1>:
+/**
 //
 // Loc<1> is a 1D specialization of Loc<N>; for the 1D case,
 // there are only a restricted set of constructors available.
@@ -472,7 +479,7 @@
 // are defined:
 //   Loc<1> a() - default constructor, which creates a Loc<1> set to zero.
 //   Loc<1> a(n) - sets the Loc<1> to the point n
-//
+*/
 //-----------------------------------------------------------------------------

 template<>
diff -ur cvs/r2/src/Domain/NewDomain.h pooma-doc/r2/src/Domain/NewDomain.h
--- cvs/r2/src/Domain/NewDomain.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/NewDomain.h	2003-10-05 17:03:45.000000000 +0200
@@ -36,20 +36,23 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// A set of simple structs which tell how to combine different Domain
-// objects together.  They are named NewDomain1 ... NewDomain7, are
-// templated on from 1 ... 7 different domain types, and provide the
-// following interface:
-//   NewDomain2<T1,T2>::Type_t newdom; // resulting type when Domains combined
-//   NewDomain2<T1,T2>::SliceType_t slicedom; // type for 'sliced' Dom's
-//   newdom = NewDomain2<T1,T2>::combine(a,b); // combine a & b, return combo
-//   NewDomain2<T1,T2>::fill(newdom, a, b); // combine a & b into newdom
-//   slicedom = NewDomain2<T1,T2>::combineSlice(a,b); // 'slice' a & b
-//   NewDomain2<T1,T2>::fillSlice(slicedom, a, b); // 'slice' into slicedom
-// similarly for NewDomain1, and NewDomain3 ... NewDomain7
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * A set of simple structs which tell how to combine different Domain
+ * objects together.
+ *
+ * They are named NewDomain1 ... NewDomain7, are
+ * templated on from 1 ... 7 different domain types, and provide the
+ * following interface:
+ *   NewDomain2<T1,T2>::Type_t newdom; // resulting type when Domains combined
+ *   NewDomain2<T1,T2>::SliceType_t slicedom; // type for 'sliced' Dom's
+ *   newdom = NewDomain2<T1,T2>::combine(a,b); // combine a & b, return combo
+ *   NewDomain2<T1,T2>::fill(newdom, a, b); // combine a & b into newdom
+ *   slicedom = NewDomain2<T1,T2>::combineSlice(a,b); // 'slice' a & b
+ *   NewDomain2<T1,T2>::fillSlice(slicedom, a, b); // 'slice' into slicedom
+ * similarly for NewDomain1, and NewDomain3 ... NewDomain7
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -81,7 +84,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of CombineDomain:
+/**
 //
 // CombineDomain is a utility class used only by the 'fill*' methods
 // of NewDomain2 ... NewDomain7.  It is templated on the following params:
@@ -118,6 +121,7 @@
 //          and copies or modifies it based on the type of wildcard.
 //          if this is false, the CT domain is not a wildcard, and the user-
 //          supplied reference domain is ignored.
+*/
 //-----------------------------------------------------------------------------

 //
@@ -140,7 +144,7 @@
 };


-//
+/**
 // the general version of CombineSliceDomainWC ... this class is used
 // by CombineSliceDomain to set up slice domain objects.  It is similar
 // to CombineDomain except that it will on occasion fill in a separate
@@ -148,7 +152,7 @@
 // reference domain which is used by the wildcard to determine the correct
 // domain.  If no slicing is being done, and no wildcard is used, this
 // just fills in the reduced 'slice domain'.
-//
+*/

 template<class RT, class UT, class CT, int DS, int SliceDS,
          bool incl, bool wc>
@@ -165,8 +169,10 @@
   }
 };

+/**
 // specialization of CombineSliceDomainWC in which we fill in slice
 // domain values and full domain values, but without using wildcards
+*/
 template<class RT, class UT, class CT, int DS, int SliceDS>
 struct CombineSliceDomainWC<RT,UT,CT,DS,SliceDS,true,false> {
   enum { DRT = DomainTraits<RT>::dimensions };
@@ -185,8 +191,10 @@
   }
 };

+/**
 // specialization of CombineSliceDomainWC in which we only fill in total
 // domain values, using wildcards
+*/
 template<class RT, class UT, class CT, int DS, int SliceDS>
 struct CombineSliceDomainWC<RT,UT,CT,DS,SliceDS,false,true> {
   enum { DRT = DomainTraits<RT>::dimensions };
@@ -204,8 +212,10 @@
   }
 };

+/**
 // specialization of CombineSliceDomainWC in which we fill in slice
 // domain values and full domain values, using wildcards
+*/
 template<class RT, class UT, class CT, int DS, int SliceDS>
 struct CombineSliceDomainWC<RT,UT,CT,DS,SliceDS,true,true> {
   enum { DRT = DomainTraits<RT>::dimensions };
@@ -228,7 +238,7 @@
   }
 };

-//
+/**
 // the general version of CombineSliceDomain ... by default, it just
 // does the same thing as CombineDomain, except, for domains which store
 // a slice, it will fill in a second 'total' domain with the extra info
@@ -239,7 +249,7 @@
 // reference domain.  To get all this done, CombineSliceDomain defers to
 // a separate CombineSliceDomainWC struct which has an extra boolean
 // template param 'wildcard' indicating whether to use wildcard set routines.
-//
+*/

 template<class RT, class UT, class CT, int DS, int SliceDS, bool incl>
 struct CombineSliceDomain {
@@ -252,7 +262,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of NewDomain1 ... NewDomain7:
+/**
 //
 // NewDomain2 ... NewDomain7 are simple helper structs which are used to
 // combine Domain objects of different types together (when possible).
@@ -358,15 +368,17 @@
 // So, to use NewDomainN objects, first determine what kind of combining
 // rules you need in your particular context, and then use the relevant
 // set of typedef and combine/fill methods from the list above.
-//
+*/
 //-----------------------------------------------------------------------------


 //-----------------------------------------------------------------------------
+/**
 // A simple base class for all specialized NewDomain2 objects, defining
 // the functions which all have in common.  This is most easily done through
 // a base class, since we need to define several different specializations
 // of NewDomain2.
+*/
 //-----------------------------------------------------------------------------

 template<class T1, class T2, class TCombine, class TSCombine>
@@ -429,11 +441,13 @@


 //-----------------------------------------------------------------------------
+/**
 // The general version of NewDomain2.  The allowed versions of NewDomain2
 // are given as partial specializations of this general case.  The general
 // case assumes T1 and T2 are single-valued domains for which DomainTraits
 // exist, that combine together to form Interval's (or Loc's for slice
 // combine rules).
+*/
 //-----------------------------------------------------------------------------

 // first, create a simple struct used to add two dimensions together at
@@ -458,7 +472,7 @@
 // Specific versions of NewDomain2, for all the allowed combinations.
 //-----------------------------------------------------------------------------

-//
+/**
 // macros for use in defining NewDomain2.  The first sets up the
 // combination of a domain with itself and with an int or Loc.  The second
 // sets up the combination of a domain with another domain of a different
@@ -479,7 +493,7 @@
 //      slice dimension
 //   3. Combining a slice domain with any other non-slice domain increases
 //      both the total dimension and the slice dimension
-//
+*/

 #define POOMA_NEWDOMAIN_SAME_SCALAR(DOM,SLICEDOM,S)			   \
 template <int D>							   \
diff -ur cvs/r2/src/Domain/NullDomain.h pooma-doc/r2/src/Domain/NullDomain.h
--- cvs/r2/src/Domain/NullDomain.h	2000-06-21 02:12:33.000000000 +0200
+++ pooma-doc/r2/src/Domain/NullDomain.h	2003-01-16 20:46:35.000000000 +0100
@@ -37,11 +37,18 @@
 #ifndef POOMA_DOMAIN_NULLDOMAIN_H
 #define POOMA_DOMAIN_NULLDOMAIN_H

-//-----------------------------------------------------------------------------
-// NullDomain and ErrorDomain are special "domains". ErrorDomains result when
-// someone tries an incorrect domain calculation. NullDomain means a domain
-// with nothing in it.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * NullDomain and ErrorDomain special domains.
+ */
+
+//@{
+
+/** NullDomain and ErrorDomain are special "domains". ErrorDomains result when
+ * someone tries an incorrect domain calculation. NullDomain means a domain
+ * with nothing in it.
+ */

 struct ErrorDomain
 {
@@ -55,7 +62,10 @@
   NullDomain(const NullDomain&) {}
 };

-// The null-domain is contained by every domain.
+//@}
+
+/** The null-domain is contained by every domain.
+ */

 template<class D>
 bool contains(const NullDomain &, const D &)
diff -ur cvs/r2/src/Domain/Range.h pooma-doc/r2/src/Domain/Range.h
--- cvs/r2/src/Domain/Range.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/Range.h	2003-10-05 17:03:45.000000000 +0200
@@ -36,15 +36,17 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// Range is a general type of integer domain, which refers to a set of points
-// a, a+s, a+2s, ..., b.  It has a run-time specified stride value s.  It
-// is basically an array of Range<1> objects.
-//
-// Range defers most of its implementation to the Domain<DomainTraits<Range>>
-// base class.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * Range is a general type of integer domain, which refers to a set of points
+ * a, a+s, a+2s, ..., b.
+ *
+ * It has a run-time specified stride value s.  It
+ * is basically an array of Range<1> objects.
+ * Range defers most of its implementation to the Domain<DomainTraits<Range>>
+ * base class.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -72,7 +74,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of Range:
+/**
 //
 // Range<N> is a domain representing a set of N numeric sequences, one
 // for each dimension N.  The sequences have endpoints [a,b], with a stride
@@ -154,7 +156,7 @@
 // after the general case that has different constructors.
 //
 // Range inherits much of its activity from Domain<DomainTraits<Range>>
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -294,7 +296,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of Range<1>:
+/**
 //
 // Range<1> is a 1D specialization of Range<N>; for the 1D case,
 // there are only a restricted set of constructors available.
@@ -306,7 +308,7 @@
 //   Range<1> a(m,n,s) - sets the Range to the sequence [m ... n], stride s
 //   Range<1> a(Domain d) : a Range copied from d, which must be a
 //     1D domain object.
-//
+*/
 //-----------------------------------------------------------------------------

 template<>
diff -ur cvs/r2/src/Domain/RangeIterator.h pooma-doc/r2/src/Domain/RangeIterator.h
--- cvs/r2/src/Domain/RangeIterator.h	2001-04-13 04:12:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/RangeIterator.h	2003-01-16 20:46:35.000000000 +0100
@@ -34,11 +34,11 @@
 //   RangeIterator
 //-----------------------------------------------------------------------------

-//-----------------------------------------------------------------------------
-// Overview:
-//
-//   RangeIterator - Iterates through Range<1> points.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ *   RangeIterator - Iterates through Range<1> points.
+ */

 //-----------------------------------------------------------------------------
 // Includes:
@@ -58,12 +58,11 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
-// RangeIterator
+/**
 //
 // A random access iterator class that iterates through all of the points
 // of an Range<1>, returning ints when dereferenced.
-//
+*/
 //-----------------------------------------------------------------------------

 class RangeIterator
diff -ur cvs/r2/src/Domain/Region.h pooma-doc/r2/src/Domain/Region.h
--- cvs/r2/src/Domain/Region.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/Region.h	2003-10-05 17:03:45.000000000 +0200
@@ -33,23 +33,25 @@
 #ifndef POOMA_DOMAIN_REGION_H
 #define POOMA_DOMAIN_REGION_H

-//-----------------------------------------------------------------------------
-// Overview:
-// Region is a general type of continuous domain, which refers to all points
-// between two endpoints a and b.
-// It is basically an array of Region<1> objects.
-// It is templated on the number of dimensions, and the data type used to
-// store the values (generally double or float, but possibly any other type).
-// The macro POOMA_DEFAULT_POSITION_TYPE defines the type for a default
-// parameter value for the floating point type; if this macro is not defined,
-// double is used.  So you can construct a Region<N>, and there will be a
-// default type T = double used.  The user can override what the default
-// type should be by defining POOMA_DEFAULT_POSITION_TYPE when their
-// application is built.
-//
-// Region defers most of its implementation to the Domain<DomainTraits<Region>>
-// base class.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * Region is a general type of continuous domain, which refers to all points
+ * between two endpoints a and b.
+ *
+ * It is basically an array of Region<1> objects.
+ * It is templated on the number of dimensions, and the data type used to
+ * store the values (generally double or float, but possibly any other type).
+ * The macro POOMA_DEFAULT_POSITION_TYPE defines the type for a default
+ * parameter value for the floating point type; if this macro is not defined,
+ * double is used.  So you can construct a Region<N>, and there will be a
+ * default type T = double used.  The user can override what the default
+ * type should be by defining POOMA_DEFAULT_POSITION_TYPE when their
+ * application is built.
+ *
+ * Region defers most of its implementation to the Domain<DomainTraits<Region>>
+ * base class.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -70,7 +72,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of Region:
+/**
 //
 // Region<N,T> is a domain representing a set of N continuous 1D regions, one
 // for each dimension N.  The regions have endpoints [a,b], and Region refers
@@ -162,7 +164,7 @@
 // after the general case that has different constructors.
 //
 // Region inherits much of its activity from Domain<DomainTraits<Region>>
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim, class T = POOMA_DEFAULT_POSITION_TYPE>
@@ -297,7 +299,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of Region<1>:
+/**
 //
 // Region<1> is a 1D specialization of Region<N>; for the 1D case,
 // there are only a restricted set of constructors available.
@@ -314,7 +316,7 @@
 // parameters (WHY???? Because The Standards Committee Is Evil), there
 // is a version of the 1D specialization of Region for general type T, and
 // a further specialization to 1D and type POOMA_DEFAULT_POSITION_TYPE.
-//
+*/
 //-----------------------------------------------------------------------------

 // specialization for 1D Region of type T
diff -ur cvs/r2/src/Domain/RightDomain.h pooma-doc/r2/src/Domain/RightDomain.h
--- cvs/r2/src/Domain/RightDomain.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/RightDomain.h	2003-10-05 17:03:45.000000000 +0200
@@ -37,18 +37,19 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-//
-// RightDomain is one of the domain wildcards, which are used when constructing
-// other domains using specific combination rules.  RightDomain means to use
-// the ending endpoint of the domain of a second 'reference' domain, with
-// a new user-provided left endpoint, when constructing a new
-// domain.  It is also used when constructing new domains with no other
-// arguments to mean that the domain should not be initialized, which can
-// save considerable time in some circumstances.
-//
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * RightDomain is one of the domain wildcards, which are used when constructing
+ * other domains using specific combination rules.
+ *
+ * RightDomain means to use
+ * the ending endpoint of the domain of a second 'reference' domain, with
+ * a new user-provided left endpoint, when constructing a new
+ * domain.  It is also used when constructing new domains with no other
+ * arguments to mean that the domain should not be initialized, which can
+ * save considerable time in some circumstances.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -69,7 +70,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of RightDomain:
+/**
 //
 // RightDomain is a special domain class which is used as a 'wildcard'.
 // Wildcards are useful when constructing new domains based on some other
@@ -89,7 +90,7 @@
 // dimensions should not be initialized, which can be helpful to avoid
 // extra unneeded work when the domain will be filled with new values very
 // soon.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
@@ -223,7 +224,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // DomainTraits<RightDomain<Dim>> provides traits info about RightDomain,
 // which is one of the domain wildcards.  It has a quite stripped-down
@@ -232,7 +233,7 @@
 // dimension and the type of the wildcard, and an enum indicating that it is
 // a wildcard.  Also, getDomain returns a 1D element of the N-dimensional
 // list of wildcards.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim>
Only in pooma-doc/r2/src/Domain: SCCS
diff -ur cvs/r2/src/Domain/Shrink.h pooma-doc/r2/src/Domain/Shrink.h
--- cvs/r2/src/Domain/Shrink.h	2000-07-25 03:08:39.000000000 +0200
+++ pooma-doc/r2/src/Domain/Shrink.h	2003-01-16 20:46:35.000000000 +0100
@@ -37,12 +37,15 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-//
-// shrinkRight(Interval<Dim>,Loc<Dim>) returns an Interval<Dim> which is
-// Loc<Dim> shorter in each direction.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * Interval<Dim> shrinking and growing on either side by int or Loc<Dim>.
+ *
+ * Examples:
+ * - shrinkRight(Interval<1>(0, 4), 1) == Interval<1>(0, 3)
+ * - growLeft(Interval<1>(0, 4), 1) == Interval<1>(-1, 4)
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -59,12 +62,8 @@
 // Forward Declarations:
 //-----------------------------------------------------------------------------

-//-----------------------------------------------------------------------------
-//
-// Full Description:
-//
-//-----------------------------------------------------------------------------

+/// Deprecated. Use shrinkRight().
 template<int Dim>
 Interval<Dim> &
 shrinkRightInPlace(Interval<Dim> &dom, const Loc<Dim> &s)
@@ -78,6 +77,7 @@
   return dom;
 }

+/// Deprecated. Use shrinkRight().
 template<int Dim>
 Interval<Dim> &
 shrinkRightInPlace(Interval<Dim> &dom, int s)
@@ -91,6 +91,7 @@
   return dom;
 }

+/// Deprecated. Use growRight().
 template<int Dim>
 Interval<Dim> &
 growRightInPlace(Interval<Dim> &dom, const Loc<Dim> &s)
@@ -104,6 +105,7 @@
   return dom;
 }

+/// Deprecated. Use growRight().
 template<int Dim>
 Interval<Dim> &
 growRightInPlace(Interval<Dim> &dom, int s)
@@ -117,6 +119,7 @@
   return dom;
 }

+/// Shrinks the Interval dom from the right by s[i] in direction i.
 template<int Dim>
 inline Interval<Dim>
 shrinkRight(const Interval<Dim> &dom, const Loc<Dim> &s)
@@ -125,6 +128,7 @@
   return shrinkRightInPlace(ret, s);
 }

+/// Shrinks the Interval dom from the right by s in every direction.
 template<int Dim>
 inline Interval<Dim>
 shrinkRight(const Interval<Dim> &dom, int s)
@@ -133,6 +137,7 @@
   return shrinkRightInPlace(ret, s);
 }

+/// Grows the Interval dom to the right by s[i] in direction i.
 template<int Dim>
 inline Interval<Dim>
 growRight(const Interval<Dim> &dom, const Loc<Dim> &s)
@@ -141,6 +146,7 @@
   return growRightInPlace(ret, s);
 }

+/// Grows the Interval dom to the right by s in every direction.
 template<int Dim>
 inline Interval<Dim>
 growRight(const Interval<Dim> &dom, int s)
diff -ur cvs/r2/src/Domain/SliceDomain.h pooma-doc/r2/src/Domain/SliceDomain.h
--- cvs/r2/src/Domain/SliceDomain.h	2001-04-13 04:12:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/SliceDomain.h	2003-01-16 20:46:35.000000000 +0100
@@ -36,21 +36,24 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// SliceDomain is a base class for all sliced domain objects.  A sliced
-// domain stores two pieces of information:
-//   1. A "total domain" of dimension TotalDim
-//   2. A "slice domain" of dimension SliceDim, with SliceDim < TotalDim.
-// SliceDomain stores both domains, and provides accessors to get references
-// to them.  It does not have the full interface as regular domains, you
-// must get a reference to the relevant domain (total or slice) and then
-// use that as normal.  Unlike the regular Domain class, SliceDomain does
-// not have or need any 1D specializations, or any base class.
-// SliceDomain is templated on the DomainTraits<> class providing the
-// traits for the SliceDomain derived class.  It does not have a Dim
-// template parameter as Domain does.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * SliceDomain is a base class for all sliced domain objects.
+ *
+ * A sliced
+ * domain stores two pieces of information:
+ *   1. A "total domain" of dimension TotalDim
+ *   2. A "slice domain" of dimension SliceDim, with SliceDim < TotalDim.
+ * SliceDomain stores both domains, and provides accessors to get references
+ * to them.  It does not have the full interface as regular domains, you
+ * must get a reference to the relevant domain (total or slice) and then
+ * use that as normal.  Unlike the regular Domain class, SliceDomain does
+ * not have or need any 1D specializations, or any base class.
+ * SliceDomain is templated on the DomainTraits<> class providing the
+ * traits for the SliceDomain derived class.  It does not have a Dim
+ * template parameter as Domain does.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -74,7 +77,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description:
+/**
 //
 // SliceDomain<DT> provides the bulk of the public interface for all
 // sliced domain objects.  The template parameter should be DomainTraits<DT>,
@@ -112,7 +115,7 @@
 //        SliceDomain_t &sliceDomain();
 //  const TotalDomain_t &totalDomain() const;
 //        TotalDomain_t &totalDomain();
-//
+*/
 //-----------------------------------------------------------------------------

 template<class DT>
diff -ur cvs/r2/src/Domain/SliceInterval.h pooma-doc/r2/src/Domain/SliceInterval.h
--- cvs/r2/src/Domain/SliceInterval.h	2001-04-13 04:12:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/SliceInterval.h	2003-01-16 20:46:35.000000000 +0100
@@ -36,22 +36,22 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-//
-// Slice domain objects are domains which have N dimensions worth of 1D
-// domain data, but really represent the result of taking an M-dimensional
-// slice (M < N) of another N dimensional domain.
-//
-// SliceInterval<N,M> is is basically an array of N Interval<1> objects,
-// but it also knows that only M of these are full domains, and that N-M
-// domains are actually referring to single points.  You can retrieve all
-// N 1D domains as a normal Interval<N> object, or the smaller slice domain
-// as an Interval<M> object.
-//
-// SliceInterval defers most of its implementation to the
-// SliceDomain<DomainTraits<SliceInterval>> base class.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * Slice domain objects are domains which have N dimensions worth of 1D
+ * domain data, but really represent the result of taking an M-dimensional
+ * slice (M < N) of another N dimensional domain.
+ *
+ * SliceInterval<N,M> is is basically an array of N Interval<1> objects,
+ * but it also knows that only M of these are full domains, and that N-M
+ * domains are actually referring to single points.  You can retrieve all
+ * N 1D domains as a normal Interval<N> object, or the smaller slice domain
+ * as an Interval<M> object.
+ *
+ * SliceInterval defers most of its implementation to the
+ * SliceDomain<DomainTraits<SliceInterval>> base class.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -73,7 +73,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of SliceInterval:
+/**
 //
 // SliceInterval<N,M> is a special form of domain object which stores a
 // total domain and a slice domain, both as Interval<N> or <M> objects.
@@ -101,7 +101,7 @@
 // retrieve a reference to the relevant domain, and then use that domain
 // as normal.  getTotalDomain() returns an Interval<N> ref, while
 // getSliceDomain() returns an Interval<M> ref.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim, int SliceDim>
diff -ur cvs/r2/src/Domain/SliceRange.h pooma-doc/r2/src/Domain/SliceRange.h
--- cvs/r2/src/Domain/SliceRange.h	2001-04-13 04:12:59.000000000 +0200
+++ pooma-doc/r2/src/Domain/SliceRange.h	2003-01-16 20:46:35.000000000 +0100
@@ -36,22 +36,22 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-//
-// Slice domain objects are domains which have N dimensions worth of 1D
-// domain data, but really represent the result of taking an M-dimensional
-// slice (M < N) of another N dimensional domain.
-//
-// SliceRange<N,M> is is basically an array of N Range<1> objects,
-// but it also knows that only M of these are full domains, and that N-M
-// domains are actually referring to single points.  You can retrieve all
-// N 1D domains as a normal Range<N> object, or the smaller slice domain
-// as a Range<M> object.
-//
-// SliceRange defers most of its implementation to the
-// SliceDomain<DomainTraits<SliceRange>> base class.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * Slice domain objects are domains which have N dimensions worth of 1D
+ * domain data, but really represent the result of taking an M-dimensional
+ * slice (M < N) of another N dimensional domain.
+ *
+ * SliceRange<N,M> is is basically an array of N Range<1> objects,
+ * but it also knows that only M of these are full domains, and that N-M
+ * domains are actually referring to single points.  You can retrieve all
+ * N 1D domains as a normal Range<N> object, or the smaller slice domain
+ * as a Range<M> object.
+ *
+ * SliceRange defers most of its implementation to the
+ * SliceDomain<DomainTraits<SliceRange>> base class.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -72,7 +72,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of SliceRange:
+/**
 //
 // SliceRange<N,M> is a special form of domain object which stores a
 // total domain and a slice domain, both as Range<N> or <M> objects.
@@ -100,7 +100,7 @@
 // retrieve a reference to the relevant domain, and then use that domain
 // as normal.  getTotalDomain() returns a Range<N> ref, while
 // getSliceDomain() returns a Range<M> ref.
-//
+*/
 //-----------------------------------------------------------------------------

 template<int Dim, int SliceDim>
diff -ur cvs/r2/src/Domain/Split.h pooma-doc/r2/src/Domain/Split.h
--- cvs/r2/src/Domain/Split.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/Split.h	2003-10-05 17:03:45.000000000 +0200
@@ -39,14 +39,16 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// void split(domain,domain,domain) is a global function which splits the
-// first argument into two separate domains, roughly in the moddle.  If
-// the first argument has zero length, this does nothing.  If the first
-// argument has a length of one, the second argument is a copy of the
-// first, and the second is set to be empty.
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * void split(domain,domain,domain) is a global function which splits the
+ * first argument into two separate domains, roughly in the moddle.
+ *
+ * If the first argument has zero length, this does nothing.  If the first
+ * argument has a length of one, the second argument is a copy of the
+ * first, and the second is set to be empty.
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -67,19 +69,19 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of SplitDomainSingle:
+/**
 //
 // SplitDomainSingle<T,Dim,bool strided>::split(a,b,c) splits just the
 // Dim dimension of the first argument into the second and third argument.
 // It is specialized on the third parameter indicating whether the
 // domain has unit stride or not, and whether the type is int or not.
-//
+*/
 //-----------------------------------------------------------------------------

-//
+/**
 // The default (unit-stride) version of SplitDomainSingle, which assumes
 // that the domains have unit stride.
-//
+*/

 template<class T, int Dim, bool strided>
 struct SplitDomainSingle {
@@ -130,9 +132,9 @@
   static void split(const T &a, T &b, T &c) { split(a, Dim-1, b, c); }
 };

-//
+/**
 // The non-unit-stride version of SplitDomainSingle.
-//
+*/

 template<class T, int Dim>
 struct SplitDomainSingle<T,Dim,true> {
@@ -185,10 +187,10 @@
   static void split(const T &a, T &b, T &c) { split(a, Dim-1, b, c); }
 };

-//
+/**
 // Special version of SplitDomainSingle for int's, which must be
 // handled uniquely.
-//
+*/

 template<int Dim, bool strided>
 struct SplitDomainSingle<int,Dim,strided> {
@@ -210,7 +212,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of SplitDomain:
+/**
 //
 // SplitDomain implements a basic template meta-program to split
 // each dimension separately of the multidimensional domain.
@@ -219,7 +221,7 @@
 // A general version of SplitDomain is defined, to split the
 // domain in the 'Dim' dimension, and then a specialization is provided
 // for Dim==1 that stops the metaprogram recursion.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T, int Dim>
@@ -276,7 +278,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of split:
+/**
 //
 // void split(domain,domain,domain) is a global function which splits the
 // first argument into two separate domains, roughly in the middle.  If
@@ -284,13 +286,9 @@
 // argument has a length of one, the second argument is a copy of the
 // first, and the second is set to be empty.
 //
-// void split(domain,axis,domain,domain) is a global function which splits
-// the first argument into two separate domains just along the Nth axis instead
-// of along all axes.  Otherwise it is the same as the other global split.
-//
 // The implementation of split is deferred to the SplitDomain
 // struct, which performs the split for each dimension.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T>
@@ -299,6 +297,9 @@
   SplitDomain<T,DomainTraits<T>::dimensions>::split(a, b, c);
 }

+/// void split(domain,axis,domain,domain) is a global function which splits
+/// the first argument into two separate domains just along the Nth axis instead
+/// of along all axes.  Otherwise it is the same as the other global split.

 template<class T>
 inline void split(const T &a, int axis, T &b, T &c)
@@ -306,6 +307,10 @@
   SplitDomain<T,DomainTraits<T>::dimensions>::split(a, axis, b, c);
 }

+/// void split(domain,axis,leftLength,domain,domain) is a global function which
+/// splits the first argument into two separate domains just along the Nth axis
+/// with specified size of the left part of the domain.
+/// Otherwise it is the same as the other global split.

 template<class T>
 inline void split(const T &a, int axis, int leftLength, T &b, T &c)
diff -ur cvs/r2/src/Domain/Touches.h pooma-doc/r2/src/Domain/Touches.h
--- cvs/r2/src/Domain/Touches.h	2003-03-18 21:11:44.000000000 +0100
+++ pooma-doc/r2/src/Domain/Touches.h	2003-10-05 17:03:45.000000000 +0200
@@ -39,21 +39,24 @@

 //////////////////////////////////////////////////////////////////////

-//-----------------------------------------------------------------------------
-// Overview:
-// bool touches(domain,domain) is a global function which determines if
-// two domains d1 and d2 overlap in any way.  'Overlap' means that there is
-// at least one point which resides in both domains.  If this is the case,
-// it returns true, otherwise false.
-//
-// touches uses a partially-specialized struct 'TouchesDomain' to do the work;
-// TouchesDomain implements a template metaprogram to check that each dimension
-// touches and and's the results together.  TouchesDomain, in turn, uses
-// TouchesDomainSingle to perform the touches calculation for two 1D domains,
-// with specialization for the case where one or both of the domains have
-// unit stride, and for the case where neither have unit stride (which is
-// a much more complicated computation).
-//-----------------------------------------------------------------------------
+/** @file
+ * @ingroup Domain
+ * @brief
+ * bool touches(domain,domain) is a global function which determines if
+ * two domains d1 and d2 overlap in any way.
+ *
+ * 'Overlap' means that there is
+ * at least one point which resides in both domains.  If this is the case,
+ * it returns true, otherwise false.
+ *
+ * touches uses a partially-specialized struct 'TouchesDomain' to do the work;
+ * TouchesDomain implements a template metaprogram to check that each dimension
+ * touches and and's the results together.  TouchesDomain, in turn, uses
+ * TouchesDomainSingle to perform the touches calculation for two 1D domains,
+ * with specialization for the case where one or both of the domains have
+ * unit stride, and for the case where neither have unit stride (which is
+ * a much more complicated computation).
+ */

 //-----------------------------------------------------------------------------
 // Typedefs:
@@ -74,7 +77,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of TouchesDomainSingle:
+/**
 //
 // TouchesDomainSingle<T1,T2,bool strided>::touches(a,b) compares two
 // domains a and b of type T1 and T2, and returns true if they touch.
@@ -90,13 +93,13 @@
 //                    they will not have any points in common due to the
 //                    striding.  We only do this long calculation when
 //                    absolutely necessary.
-//
+*/
 //-----------------------------------------------------------------------------

-//
+/**
 // The default (unit-stride) version of TouchesDomainSingle, which assumes
 // that both arguments to 'touches' are 1D domains with unit stride
-//
+*/

 template<class T1, class T2, bool strided>
 struct TouchesDomainSingle {
@@ -105,10 +108,10 @@
   }
 };

-//
+/**
 // The non-unit-stride version of TouchesDomainSingle, which does extra
 // work for the case where a and b do not have unit stride.
-//
+*/

 template<class T1, class T2>
 struct TouchesDomainSingle<T1,T2,true> {
@@ -138,7 +141,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of TouchesDomain:
+/**
 //
 // TouchesDomain implements a basic template meta-program to
 // compare each dimension separately of the multidimensional domains for
@@ -147,7 +150,7 @@
 // or not.  A general version of TouchesDomain is defined, to compare the
 // domains in the 'Dim' dimension, and then a specialization is provided
 // for Dim==1 that stops the metaprogram recursion.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T1, class T2, int Dim>
@@ -193,7 +196,7 @@

 //-----------------------------------------------------------------------------
 //
-// Full Description of touches:
+/**
 //
 // bool touches(domain1, domain2) is one of the domain calculus routines
 // used to analyze domains to determine their relative characteristics.  It
@@ -207,7 +210,7 @@
 // The implementation of touches is deferred to the TouchesDomain
 // struct, which performs the touches comparison for each dimension and and's
 // the results together.
-//
+*/
 //-----------------------------------------------------------------------------

 template<class T1, class T2, int Dim1, int Dim2>
Only in cvs/r2/src/Domain/tests: CVS
Only in cvs/r2/src/Domain/tests: LINUXgcc
Only in cvs/r2/src/Domain/tests: LINUXgcc295
Only in cvs/r2/src/Domain/tests: LINUXgcc32
Only in cvs/r2/src/Domain/tests: LINUXgcc32g
Only in pooma-doc/r2/src/Domain/tests: SCCS


From rguenth at tat.physik.uni-tuebingen.de  Mon Oct 13 14:30:44 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Mon, 13 Oct 2003 16:30:44 +0200 (CEST)
Subject: [PATCH] Canonicalize evaluators wrt constness
Message-ID: <Pine.LNX.4.44.0310131626450.898-100000@bellatrix.tat.physik.uni-tuebingen.de>

Hi!

The following patch makes all evaluators honour the same constness
assumptions. Namely applying a functor doesnt change it (ok, because
evaluation order undefined) and such all the wrapping stuff not, too.

Regtested on x86, ok?

Richard.


2003Oct13  Richard Guenther <richard.guenther at uni-tuebingen.de>

	* src/Evaluator/ScalarCode.h: mark methods/arguments const
	where possible.
	src/Evaluator/LoopApply.h: likewise.

diff -Nru a/r2/src/Evaluator/LoopApply.h b/r2/src/Evaluator/LoopApply.h
--- a/r2/src/Evaluator/LoopApply.h	Mon Oct 13 16:22:58 2003
+++ b/r2/src/Evaluator/LoopApply.h	Mon Oct 13 16:22:58 2003
@@ -89,13 +89,14 @@
   // of the domain.

   template<class Op, class Dom>
-  inline static void evaluate(Op &op, const Dom &domain)
+  inline static
+  void evaluate(const Op &op, const Dom &domain)
   {
     evaluate(op, domain, WrappedInt<Dom::dimensions>());
   }

   template<class Op, class Domain>
-  inline static void evaluate(Op &op, const Domain &domain, WrappedInt<1>)
+  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<1>)
   {
     CTAssert(Domain::unitStride);
     int f0 = domain[0].first();
@@ -106,7 +107,7 @@
   }

   template<class Op, class Domain>
-  inline static void evaluate(Op &op, const Domain &domain, WrappedInt<2>)
+  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<2>)
   {
     CTAssert(Domain::unitStride);
     int f0 = domain[0].first();
@@ -120,7 +121,7 @@
   }

   template<class Op, class Domain>
-  inline static void evaluate(Op &op, const Domain &domain, WrappedInt<3>)
+  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<3>)
   {
     CTAssert(Domain::unitStride);
     int f0 = domain[0].first();
@@ -137,7 +138,7 @@
   }

   template<class Op, class Domain>
-  inline static void evaluate(Op &op, const Domain &domain, WrappedInt<4>)
+  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<4>)
   {
     CTAssert(Domain::unitStride);
     int f0 = domain[0].first();
@@ -157,7 +158,7 @@
   }

   template<class Op, class Domain>
-  inline static void evaluate(Op &op, const Domain &domain, WrappedInt<5>)
+  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<5>)
   {
     CTAssert(Domain::unitStride);
     int f0 = domain[0].first();
@@ -180,7 +181,7 @@
   }

   template<class Op, class Domain>
-  inline static void evaluate(Op &op, const Domain &domain, WrappedInt<6>)
+  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<6>)
   {
     CTAssert(Domain::unitStride);
     int f0 = domain[0].first();
@@ -206,7 +207,7 @@
   }

   template<class Op, class Domain>
-  inline static void evaluate(Op &op, const Domain &domain, WrappedInt<7>)
+  inline static void evaluate(const Op &op, const Domain &domain, WrappedInt<7>)
   {
     CTAssert(Domain::unitStride);
     int f0 = domain[0].first();
diff -Nru a/r2/src/Evaluator/ScalarCode.h b/r2/src/Evaluator/ScalarCode.h
--- a/r2/src/Evaluator/ScalarCode.h	Mon Oct 13 16:22:58 2003
+++ b/r2/src/Evaluator/ScalarCode.h	Mon Oct 13 16:22:58 2003
@@ -96,266 +96,266 @@
 template<class A1, class Function>
 struct ApplyMultiArgLoc<MultiArg1<A1>, Function>
 {
-  ApplyMultiArgLoc(MultiArg1<A1> &multiArg, Function &function)
+  ApplyMultiArgLoc(const MultiArg1<A1> &multiArg, const Function &function)
     : multiArg_m(multiArg), function_m(function)
   {
   }

-  void operator()(int i0)
+  void operator()(int i0) const
   {
     function_m(multiArg_m.a1_m, Loc<1>(i0));
   }

-  void operator()(int i0, int i1)
+  void operator()(int i0, int i1) const
   {
     function_m(multiArg_m.a1_m, Loc<2>(i0, i1));
   }

-  void operator()(int i0, int i1, int i2)
+  void operator()(int i0, int i1, int i2) const
   {
     function_m(multiArg_m.a1_m, Loc<3>(i0, i1, i2));
   }

-  void operator()(int i0, int i1, int i2, int i3)
+  void operator()(int i0, int i1, int i2, int i3) const
   {
     function_m(multiArg_m.a1_m, Loc<4>(i0, i1, i2, i3));
   }

-  MultiArg1<A1> &multiArg_m;
-  Function &function_m;
+  const MultiArg1<A1> &multiArg_m;
+  const Function &function_m;
 };

 template<class A1, class A2, class Function>
 struct ApplyMultiArgLoc<MultiArg2<A1, A2>, Function>
 {
-  ApplyMultiArgLoc(MultiArg2<A1, A2> &multiArg,Function &function)
+  ApplyMultiArgLoc(const MultiArg2<A1, A2> &multiArg,const Function &function)
     : multiArg_m(multiArg), function_m(function)
   {
   }

-  void operator()(int i0)
+  void operator()(int i0) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, Loc<1>(i0));
   }

-  void operator()(int i0, int i1)
+  void operator()(int i0, int i1) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, Loc<2>(i0, i1));
   }

-  void operator()(int i0, int i1, int i2)
+  void operator()(int i0, int i1, int i2) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, Loc<3>(i0, i1, i2));
   }

-  void operator()(int i0, int i1, int i2, int i3)
+  void operator()(int i0, int i1, int i2, int i3) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, Loc<4>(i0, i1, i2, i3));
   }

-  MultiArg2<A1, A2> &multiArg_m;
-  Function &function_m;
+  const MultiArg2<A1, A2> &multiArg_m;
+  const Function &function_m;
 };

 template<class A1, class A2, class A3, class Function>
 struct ApplyMultiArgLoc<MultiArg3<A1, A2, A3>, Function>
 {
-  ApplyMultiArgLoc(MultiArg3<A1, A2, A3> &multiArg,
-		   Function &function)
+  ApplyMultiArgLoc(const MultiArg3<A1, A2, A3> &multiArg,
+		   const Function &function)
     : multiArg_m(multiArg), function_m(function)
   {
   }

-  void operator()(int i0)
+  void operator()(int i0) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
 	       Loc<1>(i0));
   }

-  void operator()(int i0, int i1)
+  void operator()(int i0, int i1) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
 	       Loc<2>(i0, i1));
   }

-  void operator()(int i0, int i1, int i2)
+  void operator()(int i0, int i1, int i2) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
 	       Loc<3>(i0, i1, i2));
   }

-  void operator()(int i0, int i1, int i2, int i3)
+  void operator()(int i0, int i1, int i2, int i3) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
 	       Loc<4>(i0, i1, i2, i3));
   }

-  MultiArg3<A1, A2, A3> &multiArg_m;
-  Function &function_m;
+  const MultiArg3<A1, A2, A3> &multiArg_m;
+  const Function &function_m;
 };

 template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class Function>
 struct ApplyMultiArgLoc<MultiArg7<A1, A2, A3, A4, A5, A6, A7>, Function>
 {
-  ApplyMultiArgLoc(MultiArg7<A1, A2, A3, A4, A5, A6, A7> &multiArg,
-		   Function &function)
+  ApplyMultiArgLoc(const MultiArg7<A1, A2, A3, A4, A5, A6, A7> &multiArg,
+		   const Function &function)
     : multiArg_m(multiArg), function_m(function)
   {
   }

-  void operator()(int i0)
+  void operator()(int i0) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
                multiArg_m.a7_m, Loc<1>(i0));
   }

-  void operator()(int i0, int i1)
+  void operator()(int i0, int i1) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
                multiArg_m.a7_m, Loc<2>(i0, i1));
   }

-  void operator()(int i0, int i1, int i2)
+  void operator()(int i0, int i1, int i2) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
                multiArg_m.a7_m, Loc<3>(i0, i1, i2));
   }

-  void operator()(int i0, int i1, int i2, int i3)
+  void operator()(int i0, int i1, int i2, int i3) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
                multiArg_m.a7_m, Loc<4>(i0, i1, i2, i3));
   }

-  MultiArg7<A1, A2, A3, A4, A5, A6, A7> &multiArg_m;
-  Function &function_m;
+  const MultiArg7<A1, A2, A3, A4, A5, A6, A7> &multiArg_m;
+  const Function &function_m;
 };

 template<class A1, class A2, class A3, class A4, class A5, class A6, class Function>
 struct ApplyMultiArgLoc<MultiArg6<A1, A2, A3, A4, A5, A6>, Function>
 {
-  ApplyMultiArgLoc(MultiArg6<A1, A2, A3, A4, A5, A6> &multiArg,
-		   Function &function)
+  ApplyMultiArgLoc(const MultiArg6<A1, A2, A3, A4, A5, A6> &multiArg,
+		   const Function &function)
     : multiArg_m(multiArg), function_m(function)
   {
   }

-  void operator()(int i0)
+  void operator()(int i0) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
                Loc<1>(i0));
   }

-  void operator()(int i0, int i1)
+  void operator()(int i0, int i1) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
                 Loc<2>(i0, i1));
   }

-  void operator()(int i0, int i1, int i2)
+  void operator()(int i0, int i1, int i2) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
                Loc<3>(i0, i1, i2));
   }

-  void operator()(int i0, int i1, int i2, int i3)
+  void operator()(int i0, int i1, int i2, int i3) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m, multiArg_m.a6_m,
                Loc<4>(i0, i1, i2, i3));
   }

-  MultiArg6<A1, A2, A3, A4, A5, A6> &multiArg_m;
-  Function &function_m;
+  const MultiArg6<A1, A2, A3, A4, A5, A6> &multiArg_m;
+  const Function &function_m;
 };

 template<class A1, class A2, class A3, class A4, class Function>
 struct ApplyMultiArgLoc<MultiArg4<A1, A2, A3, A4>, Function>
 {
-  ApplyMultiArgLoc(MultiArg4<A1, A2, A3, A4> &multiArg,
-		   Function &function)
+  ApplyMultiArgLoc(const MultiArg4<A1, A2, A3, A4> &multiArg,
+		   const Function &function)
     : multiArg_m(multiArg), function_m(function)
   {
   }

-  void operator()(int i0)
+  void operator()(int i0) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m,
                Loc<1>(i0));
   }

-  void operator()(int i0, int i1)
+  void operator()(int i0, int i1) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m,
                 Loc<2>(i0, i1));
   }

-  void operator()(int i0, int i1, int i2)
+  void operator()(int i0, int i1, int i2) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m,
                Loc<3>(i0, i1, i2));
   }

-  void operator()(int i0, int i1, int i2, int i3)
+  void operator()(int i0, int i1, int i2, int i3) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m,
                Loc<4>(i0, i1, i2, i3));
   }

-  MultiArg4<A1, A2, A3, A4> &multiArg_m;
-  Function &function_m;
+  const MultiArg4<A1, A2, A3, A4> &multiArg_m;
+  const Function &function_m;
 };

 template<class A1, class A2, class A3, class A4, class A5, class Function>
 struct ApplyMultiArgLoc<MultiArg5<A1, A2, A3, A4, A5>, Function>
 {
-  ApplyMultiArgLoc(MultiArg5<A1, A2, A3, A4, A5> &multiArg,
-		   Function &function)
+  ApplyMultiArgLoc(const MultiArg5<A1, A2, A3, A4, A5> &multiArg,
+		   const Function &function)
     : multiArg_m(multiArg), function_m(function)
   {
   }

-  void operator()(int i0)
+  void operator()(int i0) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m,
                Loc<1>(i0));
   }

-  void operator()(int i0, int i1)
+  void operator()(int i0, int i1) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m,
                 Loc<2>(i0, i1));
   }

-  void operator()(int i0, int i1, int i2)
+  void operator()(int i0, int i1, int i2) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m,
                Loc<3>(i0, i1, i2));
   }

-  void operator()(int i0, int i1, int i2, int i3)
+  void operator()(int i0, int i1, int i2, int i3) const
   {
     function_m(multiArg_m.a1_m, multiArg_m.a2_m, multiArg_m.a3_m,
                multiArg_m.a4_m, multiArg_m.a5_m,
                Loc<4>(i0, i1, i2, i3));
   }

-  MultiArg5<A1, A2, A3, A4, A5> &multiArg_m;
-  Function &function_m;
+  const MultiArg5<A1, A2, A3, A4, A5> &multiArg_m;
+  const Function &function_m;
 };

 template<class Function, int Dim>
@@ -371,7 +371,7 @@
   }

   template<class MultiArg>
-  void operator()(MultiArg &multiArg)
+  void operator()(MultiArg &multiArg) const
   {
     ApplyMultiArgLoc<MultiArg, Function> op(multiArg, function_m);
     LoopApplyEvaluator::evaluate(op, domain_m);
@@ -394,7 +394,7 @@
   }

   template<class F1>
-  void operator()(const F1 &f1)
+  void operator()(const F1 &f1) const
   {
     enum { dimensions = F1::dimensions };
     MultiArg1<F1> multiArg(f1);
@@ -408,7 +408,7 @@
   }

   template<class F1, class F2>
-  void operator()(const F1 &f1, const F2 &f2)
+  void operator()(const F1 &f1, const F2 &f2) const
   {
     enum { dimensions = F1::dimensions };
     MultiArg2<F1, F2> multiArg(f1, f2);
@@ -422,7 +422,7 @@
   }

   template<class F1, class F2, class F3>
-  void operator()(const F1 &f1, const F2 &f2, const F3 &f3)
+  void operator()(const F1 &f1, const F2 &f2, const F3 &f3) const
   {
     enum { dimensions = F1::dimensions };
     MultiArg3<F1, F2, F3> multiArg(f1, f2, f3);
@@ -436,7 +436,7 @@
   }

   template<class F1, class F2, class F3, class F4>
-  void operator()(const F1 &f1, const F2 &f2, const F3 &f3, const F4 &f4)
+  void operator()(const F1 &f1, const F2 &f2, const F3 &f3, const F4 &f4) const
   {
     enum { dimensions = F1::dimensions };
     MultiArg4<F1, F2, F3, F4> multiArg(f1, f2, f3, f4);
@@ -451,7 +451,7 @@

   template<class F1, class F2, class F3, class F4, class F5>
   void operator()(const F1 &f1, const F2 &f2, const F3 &f3, const F4 &f4,
-		  const F5 &f5)
+		  const F5 &f5) const
   {
     enum { dimensions = F1::dimensions };
     MultiArg5<F1, F2, F3, F4, F5> multiArg(f1, f2, f3, f4, f5);
@@ -466,7 +466,7 @@

   template<class F1, class F2, class F3, class F4, class F5, class F6>
   void operator()(const F1 &f1, const F2 &f2, const F3 &f3, const F4 &f4,
-		  const F5 &f5, const F6 &f6)
+		  const F5 &f5, const F6 &f6) const
   {
     enum { dimensions = F1::dimensions };
     MultiArg6<F1, F2, F3, F4, F5, F6> multiArg(f1, f2, f3, f4, f5, f6);
@@ -481,7 +481,7 @@

   template<class F1, class F2, class F3, class F4, class F5, class F6, class F7>
   void operator()(const F1 &f1, const F2 &f2, const F3 &f3, const F4 &f4,
-		  const F5 &f5, const F6 &f6, const F7 &f7)
+		  const F5 &f5, const F6 &f6, const F7 &f7) const
   {
     enum { dimensions = F1::dimensions };
     MultiArg7<F1, F2, F3, F4, F5, F6, F7> multiArg(f1, f2, f3, f4, f5, f6, f7);



From rguenth at tat.physik.uni-tuebingen.de  Tue Oct 14 15:11:17 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Tue, 14 Oct 2003 17:11:17 +0200 (CEST)
Subject: [PATCH] Fix breakage from previous patch
Message-ID: <Pine.LNX.4.44.0310141709390.898-100000@bellatrix.tat.physik.uni-tuebingen.de>

Hi!

This patch fixes the breakage caused by constifying the evaluators.

Tested and will commit as obvious.

Richard.


2003Oct14  Richard Guenther <richard.guenther at uni-tuebingen.de>

        * src/Field/tests/ScalarCode.cpp: mark operator() in ScalarCode
        functor const, mark reduction variable mutable.
        src/Functions/PackUnpack.h: mark operator()s in stencil functors
        const, mark reduction variable mutable.

Index: Field/tests/ScalarCode.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Field/tests/ScalarCode.cpp,v
retrieving revision 1.1
diff -u -u -r1.1 ScalarCode.cpp
--- Field/tests/ScalarCode.cpp	30 Aug 2001 01:15:18 -0000	1.1
+++ Field/tests/ScalarCode.cpp	14 Oct 2003 15:07:37 -0000
@@ -193,7 +193,7 @@

   template<class F1, class F2>
   inline
-  void operator()(F1 &f1, const F2 &f2, const Loc<Dim> &loc)
+  void operator()(F1 &f1, const F2 &f2, const Loc<Dim> &loc) const
   {
     int i;
     store_m = 0.0;
@@ -204,7 +204,7 @@
     f1(loc) = factor_m * store_m;
   }

-  double store_m;
+  mutable double store_m;
   Loc<Dim> off_m[Dim];
   double factor_m;
 };
Index: Functions/PackUnpack.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Functions/PackUnpack.h,v
retrieving revision 1.3
diff -u -u -r1.3 PackUnpack.h
--- Functions/PackUnpack.h	1 Oct 2001 16:55:21 -0000	1.3
+++ Functions/PackUnpack.h	14 Oct 2003 15:07:37 -0000
@@ -100,32 +100,32 @@
   {
   }

-  void operator()(int i0)
+  void operator()(int i0) const
   {
     *block_m = field_m.read(i0);
     ++block_m;
   }

-  void operator()(int i0, int i1)
+  void operator()(int i0, int i1) const
   {
     *block_m = field_m.read(i0, i1);
     ++block_m;
   }

-  void operator()(int i0, int i1, int i2)
+  void operator()(int i0, int i1, int i2) const
   {
     *block_m = field_m.read(i0, i1, i2);
     ++block_m;
   }

-  void operator()(int i0, int i1, int i2, int i3)
+  void operator()(int i0, int i1, int i2, int i3) const
   {
     *block_m = field_m.read(i0, i1, i2, i3);
     ++block_m;
   }

   InputField field_m;
-  RefCountedBlockPtr<Element_t> block_m;
+  mutable RefCountedBlockPtr<Element_t> block_m;
 };

 template<class InputField>
@@ -175,32 +175,32 @@
   {
   }

-  void operator()(int i0)
+  void operator()(int i0) const
   {
     field_m(i0) = *block_m;
     ++block_m;
   }

-  void operator()(int i0, int i1)
+  void operator()(int i0, int i1) const
   {
     field_m(i0, i1) = *block_m;
     ++block_m;
   }

-  void operator()(int i0, int i1, int i2)
+  void operator()(int i0, int i1, int i2) const
   {
     field_m(i0, i1, i2) = *block_m;
     ++block_m;
   }

-  void operator()(int i0, int i1, int i2, int i3)
+  void operator()(int i0, int i1, int i2, int i3) const
   {
     field_m(i0, i1, i2, i3) = *block_m;
     ++block_m;
   }

   InputField field_m;
-  RefCountedBlockPtr<Element_t> block_m;
+  mutable RefCountedBlockPtr<Element_t> block_m;
 };

 template<class InputField, class T>



From oldham at codesourcery.com  Tue Oct 14 17:48:45 2003
From: oldham at codesourcery.com (Jeffrey D. Oldham)
Date: Tue, 14 Oct 2003 10:48:45 -0700
Subject: [pooma-dev] cheetah/smarts on CodeSourcery download site
In-Reply-To: <Pine.LNX.4.58.0310011827210.608@goofy>
References: <Pine.LNX.4.58.0310011827210.608@goofy>
Message-ID: <3F8C36FD.3070703@codesourcery.com>

Richard Guenther wrote:
> Hi!
> 
> It appears cheetah 1.0.1 is still advertised from CodeSourcery's download
> site. I use cheetah 1.1.4 since over a year now without problems, so maybe
> we can advertise this version for r2 now. Also cheetah was hosted at
> ACL/LANL like PETE was, so maintainance ceased to exist now? In this case
> I put the official 1.1.4 release on
> 
> http://www.tat.physik.uni-tuebingen.de/~rguenth/pooma/cheetah-1.1.4.tgz
> 
> if the CodeSourcery guys are going to set up a repository for this, I have
> some local fixes to that version.
>
> Richard.

Cheetah 1.1.4 is now available from the POOMA download page 
http://www.codesourcery.com/pooma/pooma_download .

CodeSourcery does not have the Cheetah CVS repository, and it doe snot 
appear to be undergoing active development so we decided not to host 
such a repository at the present time.

Thanks to Richard Guenther for his suggestion and help.

Jeffrey D. Oldham
oldham at codesourcery.com



From rguenth at tat.physik.uni-tuebingen.de  Thu Oct 16 18:13:18 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Thu, 16 Oct 2003 20:13:18 +0200 (CEST)
Subject: [PATCH] make domains in viewing operator of MultiArg const
Message-ID: <Pine.LNX.4.58.0310162011260.486@goofy>

Hi!

The following patch marks the domains used to take a view of a MultiArg
object const.

Ok? (tested only in my local trees)

Richard.


2003Oct16  Richard Guenther <richard.guenther at uni-tuebingen.de>

	* src/Functions/MultiArg.h: mark domain argument in viewing
	operators const.


===== MultiArg.h 1.2 vs edited =====
--- 1.2/r2/src/Functions/MultiArg.h	Thu May 16 12:01:16 2002
+++ edited/MultiArg.h	Thu Oct 16 18:56:35 2003
@@ -218,7 +218,7 @@

   template<class Dom>
   typename View1<MultiArg1<A1>, Dom>::Type_t
-  operator()(Dom &dom) const
+  operator()(const Dom &dom) const
   {
     typedef typename View1<MultiArg1<A1>, Dom>::Type_t Ret_t;
     return Ret_t(a1_m(dom));
@@ -239,7 +239,7 @@

   template<class Dom>
   typename View1<MultiArg2<A1, A2>, Dom>::Type_t
-  operator()(Dom &dom) const
+  operator()(const Dom &dom) const
   {
     typedef typename View1<MultiArg2<A1, A2>, Dom>::Type_t Ret_t;
     return Ret_t(a1_m(dom), a2_m(dom));
@@ -261,7 +261,7 @@

   template<class Dom>
   typename View1<MultiArg3<A1, A2, A3>, Dom>::Type_t
-  operator()(Dom &dom) const
+  operator()(const Dom &dom) const
   {
     typedef typename View1<MultiArg3<A1, A2, A3>, Dom>::Type_t Ret_t;
     return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom));
@@ -284,7 +284,7 @@

   template<class Dom>
   typename View1<MultiArg4<A1, A2, A3, A4>, Dom>::Type_t
-  operator()(Dom &dom) const
+  operator()(const Dom &dom) const
   {
     typedef typename View1<MultiArg4<A1, A2, A3, A4>, Dom>::Type_t Ret_t;
     return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom), a4_m(dom));
@@ -308,7 +308,7 @@

   template<class Dom>
   typename View1<MultiArg5<A1, A2, A3, A4, A5>, Dom>::Type_t
-  operator()(Dom &dom) const
+  operator()(const Dom &dom) const
   {
     typedef typename View1<MultiArg5<A1, A2, A3, A4, A5>, Dom>::Type_t Ret_t;
     return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom), a4_m(dom), a5_m(dom));
@@ -333,7 +333,7 @@

   template<class Dom>
   typename View1<MultiArg6<A1, A2, A3, A4, A5, A6>, Dom>::Type_t
-  operator()(Dom &dom) const
+  operator()(const Dom &dom) const
   {
     typedef typename View1<MultiArg6<A1, A2, A3, A4, A5, A6>, Dom>::Type_t Ret_t;
     return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom), a4_m(dom), a5_m(dom), a6_m(dom));
@@ -359,7 +359,7 @@

   template<class Dom>
   typename View1<MultiArg7<A1, A2, A3, A4, A5, A6, A7>, Dom>::Type_t
-  operator()(Dom &dom) const
+  operator()(const Dom &dom) const
   {
     typedef typename View1<MultiArg7<A1, A2, A3, A4, A5, A6, A7>, Dom>::Type_t Ret_t;
     return Ret_t(a1_m(dom), a2_m(dom), a3_m(dom), a4_m(dom), a5_m(dom), a6_m(dom), a7_m(dom));


From rguenth at tat.physik.uni-tuebingen.de  Sun Oct 26 14:45:15 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Sun, 26 Oct 2003 15:45:15 +0100 (CET)
Subject: Reference documentation work merged.
Message-ID: <Pine.LNX.4.58.0310261540500.619@goofy>

Hi!

The work on doxygenifizing the pooma sources and thus enabling generating
of reference documentation by doxygen is now merged into the official
POOMA CVS repository.  The reference documentation can be generated by
issuing

make html

from inside the docs/reference directory.  You need the doxygen tool for
generating.  Doxygen is available for most linux distributions and from

http://www.stack.nl/~dimitri/doxygen/

You also need the dot tool that comes with the graphviz package (on
Debian).  Otherwise you need to disable generation of the diagrams.


Richard.


From rguenth at tat.physik.uni-tuebingen.de  Sun Oct 26 20:34:22 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Sun, 26 Oct 2003 21:34:22 +0100 (CET)
Subject: [PATCH] Reduction cleanup (2nd try)
Message-ID: <Pine.LNX.4.58.0310262126380.619@goofy>

Hi!

The following patch cleans up the reduction evaluator by introducing
a ReductionTraits<Op, T> class to specify a neutral element for the
reduction operation. This enables "trivial" OpenMP parallelization for
reductions (patch to come). It also simplifies the loop structure of
the reductions and thus exposes more optimization abilities to the
compiler. This second approach does not inhibit use of arbitrary complex
types, but only requires appropriate specialization of the
ReductionTraits. In question is only the default specialization for
OpBitwiseOrAssign and OpBitwiseAndAssign which constructs from 0ULL and
~0ULL - any better ideas?

Reductions tested on ppc, full test tomorrow.

Ok?

Richard.


2003Oct26  Richard Guenther <richard.guenther at uni-tuebingen.de>

	* src/Evaluator/ReductionEvaluator.h: simplify reduction loops
	by introducing ReductionTraits<Op, T> class.

===== ReductionEvaluator.h 1.1 vs edited =====
--- 1.1/r2/src/Evaluator/ReductionEvaluator.h	Mon May 13 17:47:34 2002
+++ edited/ReductionEvaluator.h	Sun Oct 26 21:22:58 2003
@@ -63,6 +63,58 @@
 template<class KernelTag>
 struct ReductionEvaluator;

+/**
+ * Traits class defining neutral element for type T under
+ * operation Op.  Needs to be specialized for Op and possibly T.
+ */
+
+template<class Op, class T>
+struct ReductionTraits {
+};
+
+template<class T>
+struct ReductionTraits<OpAddAssign, T> {
+  static inline T neutral() { return static_cast<T>(0); }
+};
+
+template<class T>
+struct ReductionTraits<OpMultiplyAssign, T> {
+  static inline T neutral() { return static_cast<T>(1); }
+};
+
+template<class T>
+struct ReductionTraits<FnMinAssign, T> {
+  static inline T neutral() { return std::numeric_limits<T>::max(); }
+};
+
+template<class T>
+struct ReductionTraits<FnMaxAssign, T> {
+  static inline T neutral() { return std::numeric_limits<T>::min(); }
+};
+
+template<class T>
+struct ReductionTraits<FnOrAssign, T> {
+  static inline T neutral() { return static_cast<T>(false); }
+};
+
+template<class T>
+struct ReductionTraits<FnAndAssign, T> {
+  static inline T neutral() { return static_cast<T>(true); }
+};
+
+template<class T>
+struct ReductionTraits<OpBitwiseOrAssign, T> {
+  static inline T neutral() { return static_cast<T>(0ULL); }
+};
+
+template<class T>
+struct ReductionTraits<OpBitwiseAndAssign, T> {
+  static inline T neutral() { return static_cast<T>(~0ULL); }
+};
+
+
+
+
 //-----------------------------------------------------------------------------
 // The point of this class is to input an expression with the
 // 'evaluate' member function and reduce it by looping over the
@@ -127,8 +179,8 @@
     Expr localExpr(e);
     int e0 = domain[0].length();

-    T answer(localExpr.read(0));
-    for (int i0 = 1; i0 < e0; ++i0)
+    T answer = ReductionTraits<Op, T>::neutral();
+    for (int i0 = 0; i0 < e0; ++i0)
       op(answer, localExpr.read(i0));

     ret = answer;
@@ -145,22 +197,10 @@
     int e0 = domain[0].length();
     int e1 = domain[1].length();

-    int i00;
-    bool firstLoop = true;
-
-    T answer(localExpr.read(0, 0));
+    T answer = ReductionTraits<Op, T>::neutral();
     for (int i1 = 0; i1 < e1; ++i1)
-      {
-        if (firstLoop)
-          {
-            firstLoop = false;
-            i00 = 1;
-          }
-        else
-          i00 = 0;
-        for (int i0 = i00; i0 < e0; ++i0)
-          op(answer, localExpr.read(i0, i1));
-      }
+      for (int i0 = 0; i0 < e0; ++i0)
+	op(answer, localExpr.read(i0, i1));

     ret = answer;
   }
@@ -177,24 +217,12 @@
     int e0 = domain[0].length();
     int e1 = domain[1].length();
     int e2 = domain[2].length();
-
-    int i00;
-    bool firstLoop = true;

-    T answer(localExpr.read(0, 0, 0));
+    T answer = ReductionTraits<Op, T>::neutral();
     for (int i2 = 0; i2 < e2; ++i2)
       for (int i1 = 0; i1 < e1; ++i1)
-        {
-          if (firstLoop)
-            {
-              firstLoop = false;
-              i00 = 1;
-            }
-          else
-            i00 = 0;
-          for (int i0 = i00; i0 < e0; ++i0)
-            op(answer, localExpr.read(i0, i1, i2));
-        }
+	for (int i0 = 0; i0 < e0; ++i0)
+	  op(answer, localExpr.read(i0, i1, i2));

     ret = answer;
   }
@@ -213,25 +241,13 @@
     int e1 = domain[1].length();
     int e2 = domain[2].length();
     int e3 = domain[3].length();
-
-    int i00;
-    bool firstLoop = true;

-    T answer(localExpr.read(0, 0, 0, 0));
+    T answer = ReductionTraits<Op, T>::neutral();
     for (int i3 = 0; i3 < e3; ++i3)
       for (int i2 = 0; i2 < e2; ++i2)
         for (int i1 = 0; i1 < e1; ++i1)
-          {
-            if (firstLoop)
-              {
-                firstLoop = false;
-                i00 = 1;
-              }
-            else
-              i00 = 0;
-            for (int i0 = i00; i0 < e0; ++i0)
-              op(answer, localExpr.read(i0, i1, i2, i3));
-          }
+	  for (int i0 = 0; i0 < e0; ++i0)
+	    op(answer, localExpr.read(i0, i1, i2, i3));

     ret = answer;
   }
@@ -252,26 +268,14 @@
     int e2 = domain[2].length();
     int e3 = domain[3].length();
     int e4 = domain[4].length();
-
-    int i00;
-    bool firstLoop = true;

-    T answer(localExpr.read(0, 0, 0, 0, 0));
+    T answer = ReductionTraits<Op, T>::neutral();
     for (int i4 = 0; i4 < e4; ++i4)
       for (int i3 = 0; i3 < e3; ++i3)
         for (int i2 = 0; i2 < e2; ++i2)
           for (int i1 = 0; i1 < e1; ++i1)
-            {
-              if (firstLoop)
-                {
-                  firstLoop = false;
-                  i00 = 1;
-                }
-              else
-                i00 = 0;
-              for (int i0 = i00; i0 < e0; ++i0)
-                op(answer, localExpr.read(i0, i1, i2, i3, i4));
-            }
+	    for (int i0 = 0; i0 < e0; ++i0)
+	      op(answer, localExpr.read(i0, i1, i2, i3, i4));

     ret = answer;
   }
@@ -294,27 +298,15 @@
     int e3 = domain[3].length();
     int e4 = domain[4].length();
     int e5 = domain[5].length();
-
-    int i00;
-    bool firstLoop = true;

-    T answer(localExpr.read(0, 0, 0, 0, 0, 0));
+    T answer = ReductionTraits<Op, T>::neutral();
     for (int i5 = 0; i5 < e5; ++i5)
       for (int i4 = 0; i4 < e4; ++i4)
         for (int i3 = 0; i3 < e3; ++i3)
           for (int i2 = 0; i2 < e2; ++i2)
             for (int i1 = 0; i1 < e1; ++i1)
-              {
-                if (firstLoop)
-                  {
-                    firstLoop = false;
-                    i00 = 1;
-                  }
-                else
-                  i00 = 0;
-                for (int i0 = i00; i0 < e0; ++i0)
-                  op(answer, localExpr.read(i0, i1, i2, i3, i4, i5));
-              }
+	      for (int i0 = 0; i0 < e0; ++i0)
+		op(answer, localExpr.read(i0, i1, i2, i3, i4, i5));

     ret = answer;
   }
@@ -339,28 +331,16 @@
     int e4 = domain[4].length();
     int e5 = domain[5].length();
     int e6 = domain[6].length();
-
-    int i00;
-    bool firstLoop = true;

-    T answer(localExpr.read(0, 0, 0, 0, 0, 0, 0));
+    T answer = ReductionTraits<Op, T>::neutral();
     for (int i6 = 0; i6 < e6; ++i6)
       for (int i5 = 0; i5 < e5; ++i5)
         for (int i4 = 0; i4 < e4; ++i4)
           for (int i3 = 0; i3 < e3; ++i3)
             for (int i2 = 0; i2 < e2; ++i2)
               for (int i1 = 0; i1 < e1; ++i1)
-                {
-                  if (firstLoop)
-                    {
-                      firstLoop = false;
-                      i00 = 1;
-                    }
-                  else
-                    i00 = 0;
-                  for (int i0 = i00; i0 < e0; ++i0)
-                    op(answer, localExpr.read(i0, i1, i2, i3, i4, i5, i6));
-                }
+		for (int i0 = 0; i0 < e0; ++i0)
+		  op(answer, localExpr.read(i0, i1, i2, i3, i4, i5, i6));

     ret = answer;
   }


From rguenth at tat.physik.uni-tuebingen.de  Mon Oct 27 12:50:19 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Mon, 27 Oct 2003 13:50:19 +0100 (CET)
Subject: [pooma-dev] [PATCH] Reduction cleanup (2nd try)
In-Reply-To: <Pine.LNX.4.58.0310262126380.619@goofy>
Message-ID: <Pine.LNX.4.44.0310271347200.1646-100000@bellatrix.tat.physik.uni-tuebingen.de>

On Sun, 26 Oct 2003, Richard Guenther wrote:

> Hi!
>
> The following patch cleans up the reduction evaluator by introducing
> a ReductionTraits<Op, T> class to specify a neutral element for the
> reduction operation. This enables "trivial" OpenMP parallelization for
> reductions (patch to come). It also simplifies the loop structure of
> the reductions and thus exposes more optimization abilities to the
> compiler. This second approach does not inhibit use of arbitrary complex
> types, but only requires appropriate specialization of the
> ReductionTraits. In question is only the default specialization for
> OpBitwiseOrAssign and OpBitwiseAndAssign which constructs from 0ULL and
> ~0ULL - any better ideas?
>
> Reductions tested on ppc, full test tomorrow.

Tested on ia32 with no regressions.

There are no measurable performance improvements (just checked
benchmarks/Solver/Krylov which is the only bench doing reductions), but
the generated code "looks" better (one comparison less in the outer
loop in case of 2d reduction). Also there is a slight decrease in code
size.

Richard.

--
Richard Guenther <richard dot guenther at uni-tuebingen dot de>
WWW: http://www.tat.physik.uni-tuebingen.de/~rguenth/



From tarjeik at chemcon.no  Tue Oct 28 16:49:45 2003
From: tarjeik at chemcon.no (Tarjei Knapstad)
Date: 28 Oct 2003 17:49:45 +0100
Subject: Some POOMA questions
Message-ID: <1067359786.23997.159.camel@cc-intern01>

Hi!

(I hope I'm not posting this to the wrong forum, if so please redirect
me.)

I'm currently in the process of evaluating POOMA for use in our software
and I have some questions:

1. Is POOMA suitable for use as a linear algebra package? Or should I be
looking elsewhere, like the Blitz++ library, and do the parallelization
myself? I've done some minor experimentation using Array<2> as a basic
matrix of doubles, but I haven't yet been able to find any functionality
for doing basic stuff like computing a matrix product, Hadamar product
etc. Am I not looking in the right place? I'll also need basic matrix
decompositions like LDU, QR and LDU which brings me to:

2. How hard is it to implement new algorithms for the POOMA containers?
Even though I'm very confident with template code (including expression
templates), I must say that at this point the POOMA code has me more or
less baffled.

3. Is there any work being done to bring SMARTS up to speed? For
parallell execution I'd like to try running on a MOSIX cluster, using
SMARTS to do the threading, but the current SMARTS in CVS fails to
compile the same way it did when I tried it briefly last year (there's
some conflict with pthreads)

4. About licensing: While POOMA is currently free for commercial use,
are there any plans to make it a commercial package down the road? Not
that we mind paying for software, but I'm a bit reluctant to start using
something which may suddenly end up becoming an expensive vendor
lock-in. Also, does/will CodeSourcery offer commercial support for
POOMA, something like you currently offer for gcc?

Thanks in advance,
--
Tarjei Knapstad



From rguenth at tat.physik.uni-tuebingen.de  Tue Oct 28 17:21:01 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Tue, 28 Oct 2003 18:21:01 +0100 (CET)
Subject: [pooma-dev] Some POOMA questions
In-Reply-To: <1067359786.23997.159.camel@cc-intern01>
Message-ID: <Pine.LNX.4.44.0310281814100.1646-100000@bellatrix.tat.physik.uni-tuebingen.de>

On 28 Oct 2003, Tarjei Knapstad wrote:

> Hi!
>
> (I hope I'm not posting this to the wrong forum, if so please redirect
> me.)
>
> I'm currently in the process of evaluating POOMA for use in our software
> and I have some questions:
>
> 1. Is POOMA suitable for use as a linear algebra package? Or should I be

I would look elsewhere, f.i. at the PETSc library for this sort of use.
I'm at the moment looking at using PETSc for solving of (ono-)linear
systems while doing explicit stuff in POOMA. Stay tuned for some adaptor
classes.

> looking elsewhere, like the Blitz++ library, and do the parallelization
> myself? I've done some minor experimentation using Array<2> as a basic
> matrix of doubles, but I haven't yet been able to find any functionality
> for doing basic stuff like computing a matrix product, Hadamar product
> etc. Am I not looking in the right place? I'll also need basic matrix
> decompositions like LDU, QR and LDU which brings me to:
>
> 2. How hard is it to implement new algorithms for the POOMA containers?
> Even though I'm very confident with template code (including expression
> templates), I must say that at this point the POOMA code has me more or
> less baffled.

Well - its easy to implement them, but probably a lot harder to get them
working at acceptable speed. Also doing f.i. vector x matrix with Array<1>
and Array<2> is not supported by any data-parallel operation I know of.

> 3. Is there any work being done to bring SMARTS up to speed? For
> parallell execution I'd like to try running on a MOSIX cluster, using
> SMARTS to do the threading, but the current SMARTS in CVS fails to
> compile the same way it did when I tried it briefly last year (there's
> some conflict with pthreads)

Still the same - I have some work on OpenMP support in my queue (but need
to finalize reduction support) that will perhaps make SMARTS unnecessary.
I myself use cheetah for MPI parallelization on a workstation cluster.

> 4. About licensing: While POOMA is currently free for commercial use,
> are there any plans to make it a commercial package down the road? Not
> that we mind paying for software, but I'm a bit reluctant to start using
> something which may suddenly end up becoming an expensive vendor
> lock-in.

At least all "old" versions would stay open, and I suspect in the above
case I would start a fork for further open POOMA development. It would be
interesting to know if the future ongoing work (which was announced here a
few weeks ago) is done in public or closed as contract work.

> Also, does/will CodeSourcery offer commercial support for
> POOMA, something like you currently offer for gcc?

They state that from their website, so... - but I dont know.

Hope this clarifies something,

 Richard.

--
Richard Guenther <richard dot guenther at uni-tuebingen dot de>
WWW: http://www.tat.physik.uni-tuebingen.de/~rguenth/



From jcrotinger at proximation.com  Tue Oct 28 18:22:01 2003
From: jcrotinger at proximation.com (James Crotinger)
Date: Tue, 28 Oct 2003 11:22:01 -0700
Subject: [pooma-dev] Some POOMA questions
Message-ID: <F871BB04B0EA224A821A5274C31DF315129727@proxim-sf001.santafe.proximation.com>

Hi Targei,

The existing POOMA data structures aren't really set up for parallel linear
algebra - they were designed with data-parallel type of operations. Most
parallel solver systems require special data structures, especially the
sparse packages. There have been discussions over the years of building
Engines that mapped to existing parallel data-structures for things like
sparse linear algebra, but I don't believe that there have been any concrete
developments in this direction. If you don't need parallel, then the
BrickEngine is a Fortran-storage-order engine that maps N-D array to a
contiguous chunk of memory, so the underlying raw pointer could be passed to
an external dense linear algebra package. 

You'd have to be more explicit on question 2. If the algorithms are
data-parallel, then they're easy to write.

With respect to SMARTS, I don't believe it is being developed at Los Alamos,
so I doubt there will be further changes unless they're done by this
community, and so far there hasn't appeared to be a lot of interest in this.
In my opinion, SMARTS doesn't make a lot of sense unless you have quite a
few processors sharing memory, and that isn't the configuration that most
folks are using these days. A fast MPI or other low-level message passing
layer is probably better if the nodes only have a small number of
processors.

With respect to commercialization, this seems unlikely. Some of us were
approached by a company toward the end of our Los Alamos tenure about doing
this but it really doesn't seem like a business that one could make much
money at. If there was market demand for a commercial effort, I suspect it
would be more along the lines of consulting to develop new capabilities
either built into POOMA, in which case they'd be open-source, or built on
top of POOMA. 

	Jim


-----Original Message-----
From: Tarjei Knapstad [mailto:tarjeik at chemcon.no] 
Sent: Tuesday, October 28, 2003 9:50 AM
To: Pooma-dev
Subject: [pooma-dev] Some POOMA questions

Hi!

(I hope I'm not posting this to the wrong forum, if so please redirect
me.)

I'm currently in the process of evaluating POOMA for use in our software
and I have some questions:

1. Is POOMA suitable for use as a linear algebra package? Or should I be
looking elsewhere, like the Blitz++ library, and do the parallelization
myself? I've done some minor experimentation using Array<2> as a basic
matrix of doubles, but I haven't yet been able to find any functionality
for doing basic stuff like computing a matrix product, Hadamar product
etc. Am I not looking in the right place? I'll also need basic matrix
decompositions like LDU, QR and LDU which brings me to:

2. How hard is it to implement new algorithms for the POOMA containers?
Even though I'm very confident with template code (including expression
templates), I must say that at this point the POOMA code has me more or
less baffled.

3. Is there any work being done to bring SMARTS up to speed? For
parallell execution I'd like to try running on a MOSIX cluster, using
SMARTS to do the threading, but the current SMARTS in CVS fails to
compile the same way it did when I tried it briefly last year (there's
some conflict with pthreads)

4. About licensing: While POOMA is currently free for commercial use,
are there any plans to make it a commercial package down the road? Not
that we mind paying for software, but I'm a bit reluctant to start using
something which may suddenly end up becoming an expensive vendor
lock-in. Also, does/will CodeSourcery offer commercial support for
POOMA, something like you currently offer for gcc?

Thanks in advance,
--
Tarjei Knapstad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/pooma-dev/attachments/20031028/81faf3b0/attachment.html>

From jcrotinger at proximation.com  Tue Oct 28 18:31:00 2003
From: jcrotinger at proximation.com (James Crotinger)
Date: Tue, 28 Oct 2003 11:31:00 -0700
Subject: [pooma-dev] Some POOMA questions
Message-ID: <F871BB04B0EA224A821A5274C31DF315129728@proxim-sf001.santafe.proximation.com>


> Well - its easy to implement them, but probably a lot harder to get them
> working at acceptable speed. Also doing f.i. vector x matrix with Array<1>
> and Array<2> is not supported by any data-parallel operation I know of.

Exactly - unless the matrix is sparse, the last thing you generally want to
do on massively parallel machine is a matrix-vector product. 


>> 3. Is there any work being done to bring SMARTS up to speed? For
>> parallell execution I'd like to try running on a MOSIX cluster, using
>> SMARTS to do the threading, but the current SMARTS in CVS fails to
>> compile the same way it did when I tried it briefly last year (there's
>> some conflict with pthreads)

> Still the same - I have some work on OpenMP support in my queue (but need
> to finalize reduction support) that will perhaps make SMARTS unnecessary.
> I myself use cheetah for MPI parallelization on a workstation cluster.

The real advantage of SMARTS was its data-flow ability, which is not
something OpenMP will recover (unless OpenMP has some magic that it didn't
have when I last looked). That said, SMARTS is pretty complex and its
light-weight threads are very machine-dependent -- it was still pre-beta
software on anything except the SGIs when the development ended. I think it
would make a great research project, but I wouldn't push it as part of
production POOMA. 

	Jim

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/pooma-dev/attachments/20031028/62fd377e/attachment.html>

From oldham at codesourcery.com  Tue Oct 28 21:22:47 2003
From: oldham at codesourcery.com (Jeffrey D. Oldham)
Date: Tue, 28 Oct 2003 13:22:47 -0800
Subject: [pooma-dev] Some POOMA questions
In-Reply-To: <1067359786.23997.159.camel@cc-intern01>
References: <1067359786.23997.159.camel@cc-intern01>
Message-ID: <3F9EDE27.2070400@codesourcery.com>

Tarjei Knapstad wrote:
> 4. About licensing: While POOMA is currently free for commercial use,
> are there any plans to make it a commercial package down the road? Not
> that we mind paying for software, but I'm a bit reluctant to start using
> something which may suddenly end up becoming an expensive vendor
> lock-in. Also, does/will CodeSourcery offer commercial support for
> POOMA, something like you currently offer for gcc?

The source code is currently available and will be for the foreseeable 
future.  CodeSourcery is available for POOMA development work, but I 
suggest that you first investigate open-source VSIPL++ 
(www.hpec-si.org), which is being actively funded and developed by the 
US Department of Defense.  It will have support for parallel linear 
algebra work.

Jeffrey D. Oldham
oldham at codesourcery.com



From rguenth at tat.physik.uni-tuebingen.de  Wed Oct 29 08:19:38 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Wed, 29 Oct 2003 09:19:38 +0100 (CET)
Subject: [pooma-dev] Some POOMA questions
In-Reply-To: <F871BB04B0EA224A821A5274C31DF315129728@proxim-sf001.santafe.proximation.com>
Message-ID: <Pine.LNX.4.44.0310290918300.1646-100000@bellatrix.tat.physik.uni-tuebingen.de>

On Tue, 28 Oct 2003, James Crotinger wrote:

> >> 3. Is there any work being done to bring SMARTS up to speed? For
> >> parallell execution I'd like to try running on a MOSIX cluster, using
> >> SMARTS to do the threading, but the current SMARTS in CVS fails to
> >> compile the same way it did when I tried it briefly last year (there's
> >> some conflict with pthreads)
>
> > Still the same - I have some work on OpenMP support in my queue (but need
> > to finalize reduction support) that will perhaps make SMARTS unnecessary.
> > I myself use cheetah for MPI parallelization on a workstation cluster.
>
> The real advantage of SMARTS was its data-flow ability, which is not
> something OpenMP will recover (unless OpenMP has some magic that it didn't
> have when I last looked). That said, SMARTS is pretty complex and its
> light-weight threads are very machine-dependent -- it was still pre-beta
> software on anything except the SGIs when the development ended. I think it
> would make a great research project, but I wouldn't push it as part of
> production POOMA.

That was my impression, too. I do that OpenMP work basically to allow easy
scaling to 2-8 processor machines and maybe allow hybrid OpenMP/MPI
parallelization (dropping cheetah in favor of "native" MPI support is next
on my todo).

Richard.

--
Richard Guenther <richard dot guenther at uni-tuebingen dot de>
WWW: http://www.tat.physik.uni-tuebingen.de/~rguenth/



From rguenth at tat.physik.uni-tuebingen.de  Wed Oct 29 11:29:19 2003
From: rguenth at tat.physik.uni-tuebingen.de (Richard Guenther)
Date: Wed, 29 Oct 2003 12:29:19 +0100 (CET)
Subject: [pooma-dev] Some POOMA questions
In-Reply-To: <3F9EDE27.2070400@codesourcery.com>
Message-ID: <Pine.LNX.4.44.0310291227300.1646-100000@bellatrix.tat.physik.uni-tuebingen.de>

On Tue, 28 Oct 2003, Jeffrey D. Oldham wrote:

> Tarjei Knapstad wrote:
> > 4. About licensing: While POOMA is currently free for commercial use,
> > are there any plans to make it a commercial package down the road? Not
> > that we mind paying for software, but I'm a bit reluctant to start using
> > something which may suddenly end up becoming an expensive vendor
> > lock-in. Also, does/will CodeSourcery offer commercial support for
> > POOMA, something like you currently offer for gcc?
>
> The source code is currently available and will be for the foreseeable
> future.  CodeSourcery is available for POOMA development work, but I
> suggest that you first investigate open-source VSIPL++
> (www.hpec-si.org), which is being actively funded and developed by the
> US Department of Defense.  It will have support for parallel linear
> algebra work.

This seems to be closed development? At least this site requires passwords
for downloads. Also from the available presentations it seems to be
still in prototype state?

Richard.

--
Richard Guenther <richard dot guenther at uni-tuebingen dot de>
WWW: http://www.tat.physik.uni-tuebingen.de/~rguenth/



From tarjeik at chemcon.no  Wed Oct 29 11:48:01 2003
From: tarjeik at chemcon.no (Tarjei Knapstad)
Date: 29 Oct 2003 12:48:01 +0100
Subject: [pooma-dev] Some POOMA questions
In-Reply-To: 	<Pine.LNX.4.44.0310281814100.1646-100000@bellatrix.tat.physik.uni-tuebingen.
	 de>
References: 	<Pine.LNX.4.44.0310281814100.1646-100000@bellatrix.tat.physik.uni-tuebingen.
	 de>
Message-ID: <1067428084.23997.224.camel@cc-intern01>

<snip>

Richard, James, Jeffrey,

Thanks a lot for your responses! Seems like POOMA was a bit of barking
up the wrong tree for us then.

I had a look at PETSc today, but I thought it was very messy, so
currently I'm down to evaluating Blitz++ and possibly MTL (it seems to
be a dead project), and implement parallelism through MPI myself where
needed.

As for VSIPL++ I can't seem to access much information at the site (and
I just read Richard is having the same problem).

Thanks again,
--
Tarjei Knapstad



From jcrotinger at proximation.com  Wed Oct 29 15:35:56 2003
From: jcrotinger at proximation.com (James Crotinger)
Date: Wed, 29 Oct 2003 08:35:56 -0700
Subject: [pooma-dev] Some POOMA questions
Message-ID: <F871BB04B0EA224A821A5274C31DF31512972F@proxim-sf001.santafe.proximation.com>

I think you just have to send email to get an account on the VSIPL++ site.

PETSc is a bit messy, which is why I always thought it would be nice to wrap
the underlying data structures in an Engine and then use the POOMA
interface. 

If you really want to do parallel linear algebra, you should probably find
someone's existing software and adapt it - unless writing parallel solvers
is your Ph.D. topic. 

	Jim


-----Original Message-----
From: Tarjei Knapstad [mailto:tarjeik at chemcon.no] 
Sent: Wednesday, October 29, 2003 4:48 AM
To: Pooma-dev
Subject: Re: [pooma-dev] Some POOMA questions

<snip>

Richard, James, Jeffrey,

Thanks a lot for your responses! Seems like POOMA was a bit of barking
up the wrong tree for us then.

I had a look at PETSc today, but I thought it was very messy, so
currently I'm down to evaluating Blitz++ and possibly MTL (it seems to
be a dead project), and implement parallelism through MPI myself where
needed.

As for VSIPL++ I can't seem to access much information at the site (and
I just read Richard is having the same problem).

Thanks again,
--
Tarjei Knapstad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/pooma-dev/attachments/20031029/1937acd7/attachment.html>

From oldham at codesourcery.com  Wed Oct 29 16:53:43 2003
From: oldham at codesourcery.com (Jeffrey D. Oldham)
Date: Wed, 29 Oct 2003 08:53:43 -0800
Subject: [pooma-dev] Some POOMA questions
In-Reply-To: <F871BB04B0EA224A821A5274C31DF31512972F@proxim-sf001.santafe.proximation.com>
References: <F871BB04B0EA224A821A5274C31DF31512972F@proxim-sf001.santafe.proximation.com>
Message-ID: <3F9FF097.50203@codesourcery.com>

James Crotinger wrote:
> I think you just have to send email to get an account on the VSIPL++ site.

That is my belief as well.

VSIPL++ is undergoing development so executable code will probably be 
available in about a year.  The serial and parallel specificiation is 
fairly stable, but the open-source reference implementation is still 
being coded.  Additional financial resources may speed development.

Jeffrey D. Oldham
oldham at codesourcery.com



From Lawrence.Daniels at aspentech.com  Fri Oct 31 14:57:50 2003
From: Lawrence.Daniels at aspentech.com (Daniels, Lawrence)
Date: Fri, 31 Oct 2003 14:57:50 -0000
Subject: POOMA
Message-ID: <AA05E428CF672D48B044F2B55723C6A719DEDE@harmail1.corp.aspentech.com>

Hi,

 

I would like to be able to compile and use POOMA..  I am interested in its
possible application to high performance numerical methods.

 

I have tried to build version 2.3 by importing  the VS 6.0 dsw file into
.NET and compiling. I get one error:

 

d:\pooma-2.3.0\src\Tiny\TensorElements.h(115) : error C2027: use of
undefined type 'Unwritable'

        d:\pooma-2.3.0\src\Tiny\TensorElements.h(54) : see declaration of
'Unwritable'

        d:\pooma-2.3.0\src\Tiny\TensorElements.h(116) : see reference to
class template instantiation 'TensorEngineElem<D,T,E,I,J,0>' being compiled

 

This was the only compiler error.

 

I haven't tried version 2.4 yet as I am not sure where to start and there
are no IDE files to work from. Also some of the documentation does not seem
to be up to date as it still refers to the IDE files and version 2.3.

 

I would be grateful for any help and advice you might be able to offer.

 

Kind regards

 

Lawrence Daniels

 

 

___________________________________________________________________

Lawrence Daniels lawrence.daniels at aspentech.com
<mailto:lawrence.daniels at aspentech.com> 

Harwell R&D Operations Manager
Senior Development Manager
Fluid Dynamics & Maths Solvers Development

Hyprotech UK Ltd.
Gemini Building
Fermi Avenue
Harwell Business Centre 
Didcot     
Oxfordshire
OX11 0QR
UK
 Tel:+44 1235 448252
 Fax:+44 1235 448230

www.hyprotech.com
____________________________________________________________________

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/pooma-dev/attachments/20031031/332356ce/attachment.html>

From oldham at codesourcery.com  Fri Oct 31 16:16:17 2003
From: oldham at codesourcery.com (Jeffrey D. Oldham)
Date: Fri, 31 Oct 2003 08:16:17 -0800
Subject: [pooma-dev] POOMA
In-Reply-To: <AA05E428CF672D48B044F2B55723C6A719DEDE@harmail1.corp.aspentech.com>
References: <AA05E428CF672D48B044F2B55723C6A719DEDE@harmail1.corp.aspentech.com>
Message-ID: <3FA28AD1.4080709@codesourcery.com>

Daniels, Lawrence wrote:
> Hi,
> 
>  
> 
> I would like to be able to compile and use POOMA..  I am interested in 
> its possible application to high performance numerical methods.
> 
>  
> 
> I have tried to build version 2.3 by importing  the VS 6.0 dsw file into 
> .NET and compiling. I get one error:
> 
>  
> 
> d:\pooma-2.3.0\src\Tiny\TensorElements.h(115) : error C2027: use of 
> undefined type 'Unwritable'
> 
>         d:\pooma-2.3.0\src\Tiny\TensorElements.h(54) : see declaration 
> of 'Unwritable'
> 
>         d:\pooma-2.3.0\src\Tiny\TensorElements.h(116) : see reference to 
> class template instantiation 'TensorEngineElem<D,T,E,I,J,0>' being compiled
> 
>  
> 
> This was the only compiler error.
> 
> I haven't tried version 2.4 yet as I am not sure where to start and 
> there are no IDE files to work from. Also some of the documentation does 
> not seem to be up to date as it still refers to the IDE files and 
> version 2.3.
> 
> I would be grateful for any help and advice you might be able to offer.

Thank you for your interest in POOMA.

I attach the latest version of TensorElements.h, which was last revised 
2001Apr20 with this comment:

Moved definitions of helper classes Unwritable and Writable
above definition of class TensorElem, since TensorElem uses
objects of these types in member functions that are written
as in-class definitions.

Thus, I conjecture it will solve the difficulty you experienced.

Jeffrey D. Oldham
oldham at codesourcery.com
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: TensorElements.h
URL: <http://sourcerytools.com/pipermail/pooma-dev/attachments/20031031/02071a5d/attachment.h>

