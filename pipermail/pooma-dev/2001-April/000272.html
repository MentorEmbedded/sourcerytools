<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Metrowerks and template member functions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Metrowerks%20and%20template%20member%20functions&In-Reply-To=%3Cv04220800b70577fa26eb%40%5B10.0.1.13%5D%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000273.html">
   <LINK REL="Next"  HREF="000274.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Metrowerks and template member functions</H1>
    <B>John Hall</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Metrowerks%20and%20template%20member%20functions&In-Reply-To=%3Cv04220800b70577fa26eb%40%5B10.0.1.13%5D%3E"
       TITLE="Metrowerks and template member functions">johnharveyhall at qwest.net
       </A><BR>
    <I>Fri Apr 20 05:22:31 UTC 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000273.html">FW: gcc/stl question
</A></li>
        <LI>Next message: <A HREF="000274.html">[pooma-dev] Metrowerks and template member functions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#272">[ date ]</a>
              <a href="thread.html#272">[ thread ]</a>
              <a href="subject.html#272">[ subject ]</a>
              <a href="author.html#272">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Pooma gang:
Apparently, Metrowerks has a problem with template member functions 
of partially specialized classes inheriting from a partially 
specialized base class being defined external to the class 
declaration. As a result, some code checked in last week caused 
Interval.h, Range.h and Grid.h to stop compiling. Here are versions 
that compile under Metrowerks and should be identical in 
functionality.

Could someone look these over and if they are OK check them in?
John Hall
-------------- next part --------------
// -*- C++ -*-
// ACL:license
// ----------------------------------------------------------------------
// This software and ancillary information (herein called &quot;SOFTWARE&quot;)
// called POOMA (Parallel Object-Oriented Methods and Applications) is
// made available under the terms described here.  The SOFTWARE has been
// approved for release with associated LA-CC Number LA-CC-98-65.
//
// Unless otherwise indicated, this SOFTWARE has been authored by an
// employee or employees of the University of California, operator of the
// Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
// the U.S. Department of Energy.  The U.S. Government has rights to use,
// reproduce, and distribute this SOFTWARE. The public may copy, distribute,
// prepare derivative works and publicly display this SOFTWARE without
// charge, provided that this Notice and any statement of authorship are
// reproduced on all copies.  Neither the Government nor the University
// makes any warranty, express or implied, or assumes any liability or
// responsibility for the use of this SOFTWARE.
//
// If SOFTWARE is modified to produce derivative works, such modified
// SOFTWARE should be clearly marked, so as not to confuse it with the
// version available from LANL.
//
// For more information about POOMA, send e-mail to <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">pooma at acl.lanl.gov</A>,
// or visit the POOMA web page at <A HREF="http://www.acl.lanl.gov/pooma/.">http://www.acl.lanl.gov/pooma/.</A>
// ----------------------------------------------------------------------
// ACL:license

#ifndef POOMA_DOMAIN_GRID_H
#define POOMA_DOMAIN_GRID_H

//-----------------------------------------------------------------------------
// Class:
// Grid&lt;int Dim&gt;
//-----------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Overview:
// Grid is a general type of integer domain, which refers to a set of points
// a0, a1, ... aN for each dimension.  The points can be any ascending or
// descending sequence, there is no fixed stride.  This is basically a set
// of Dim IndirectionList&lt;int&gt;'s, one for each dimension; the total domain
// is the tensor product of these lists.  Grid&lt;Dim&gt; is basically an array
// of Grid&lt;1&gt; objects.
//
// Grid defers most of its implementation to the Domain&lt;DomainTraits&lt;Grid&gt;&gt;
// base class.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typedefs:
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Includes:
//-----------------------------------------------------------------------------

#include &quot;Domain/Domain.h&quot;
#include &quot;Domain/DomainTraits.Grid.h&quot;
#include &quot;Domain/NewDomain.h&quot;
#include &quot;Domain/Loc.h&quot;        // needed for use of operator&lt;&lt;
#include &lt;iosfwd&gt;


//-----------------------------------------------------------------------------
// Forward Declarations:
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//
// Full Description of Grid:
//
// Grid&lt;N&gt; is a domain representing a set of N numeric sequences, one
// for each dimension N.  The sequences are lists of ascending or descending
// numbers, but without any fixed stride - the list for each dimension is
// an IndirectionList&lt;int&gt;.  It does not have any concept of loop variables,
// however, like Index does, so it cannot be used in any kind of tensor-like
// expression.
//
// You can construct a Grid object using other domain objects.
// The constructors accept up to 7 domain objects of various types.
// Domain types are, for example, Loc, Grid, Interval. int may also be used
// in the constructor for Grid; it acts like a Loc&lt;1&gt; object
// in that context.  The domain arguments for the Grid
// constructors are combined together to form a single domain object with
// a dimension equal to the sum of the arguments dimensions; for example,
// if you try to create a Grid&lt;3&gt; from a Loc&lt;2&gt; and an Interval&lt;1&gt;, e.g.
//   Grid&lt;3&gt; a(Loc&lt;2&gt;(1,2), Interval&lt;1&gt;(3,5));
// the Loc&lt;2&gt; and Interval arguments are combined into a (2+1=3) dimensional
// domain object, used to initialize the Grid&lt;3&gt;.  The number of dimensions
// for the arguments must be &lt;= number of dimensions of the newly constructed
// Grid.
//
// Grid, unlike other domain objects, can also be constructed with
// IndirectionList objects.  IndirectionList's look like 1D domain objects
// to the constructor of Grid, so multiple lists can be used.  Grid's can
// also be used in this same way to construct other Grid's.
//
// For Grid&lt;1&gt;, the list of constructors includes the following:
//   Grid&lt;1&gt; a() - default constructor, which creates an EMPTY Grid
//   Grid&lt;1&gt; a(n) - sets the Grid to the sequence [0 ... (n-1)], stride 1
//   Grid&lt;1&gt; a(m,n) - sets the Grid to the sequence [m ... n], stride 1 or -1
//   Grid&lt;1&gt; a(m,n,s) - sets the Grid to the sequence [m ... n], stride s
//
// The default Grid&lt;1&gt; constructor initializes the Grid to be empty,
// that is, to have a length() of zero.  In that case, the endpoints are
// undefined, as is any operation involving the Grid.
//
// In addition to the constructors, Grid has the following public
// interface, similar to all domain objects.  There are two classes of
// interface methods, one class which includes methods which any Grid&lt;N&gt;
// object has, regardless of dimensions, the other class which includes extra
// interface methods that are available for just Grid&lt;1&gt; objects.
//
// Grid&lt;N&gt; interface:
// -------------------
//   long size() - return the 'volume' of the domain, which is the product
//      of the lenghts of the N 1D Grids
//   bool empty() - return if any of the Grid&lt;1&gt; objects have length == 0
//   Grid&lt;1&gt; operator[](int N) - return the Nth Grid&lt;1&gt; in a
//      multidimensional Grid&lt;M&gt;.  For Grid&lt;1&gt; objects, this just
//      returns the object back.
//   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare a Grid&lt;N&gt; to
//      another domain object.  The compared domains must have the same
//      number of dimensions.
//   arithmetic accumulation operators +=, -=, *=, /= : add or substract in a
//      given domain.  The added domain must have the same number of
//      dimensions, or a dimension of 1 (in which case, the same value
//      is used for all dimensions), and be known to be single-valued (which
//      is true for Loc and int's).  Note that for Grid, *= and /= ARE
//      allowed, since Grid can have its stride changed at run time.  *=
//      and /= result in scaling of the endpoints and stride, which leaves
//      the length (and size) the same.  += and -= shift the beginning
//      endpoints by the given values, also leaving the length and size the
//      same.  Negation of a Grid negates the endpoints and stride.
//   binary arithmethic operators +, -, *, / : for + and -, adding a Grid
//      to another Loc or int returns a new Grid.  For * and /, scaling
//      by a Loc or int also returns a Grid object, since the stride may
//      change.
//   increment/decrement operator ++, -- : only prefix versions of ++ and --
//      are provided; they act just like += 1 and -= 1 operations.
//
// Grid&lt;1&gt; interface:
// -------------------
//   all of the methods for Grid&lt;N&gt; are also available for Grid&lt;1&gt;. Plus:
//   int length() - number of elements (including endpoints) of the domain.
//     for a non-unit-stride Grid, the length refers to the number of
//     strided points (including the endpoints), NOT the difference between
//     the first and last endpoint.  That is, length = (end-beg)/stride + 1,
//     NOT (end-beg) + 1.
//   int first() - the beginning endpoint.
//   int last() - the ending endpoint.
//   int min(), int max() - min or max of the endpoints.
//   Interval&lt;1&gt;::iterator begin() and end() - return iterators for the 1D
//      domain.  These act like (at least) bidirectional iterators.
//
// For the special case of Grid&lt;1&gt;, there is a specialization given
// after the general case that has different constructors.
//
// Grid inherits much of its activity from Domain&lt;DomainTraits&lt;Grid&gt;&gt;
//
//-----------------------------------------------------------------------------

template&lt;int Dim&gt;
class Grid : public Domain&lt;Dim, DomainTraits&lt;Grid&lt;Dim&gt; &gt; &gt;
{
   // convenience typedefs
   typedef DomainTraits&lt; Grid&lt;Dim&gt; &gt;             DT_t;
   typedef Domain&lt;Dim, DT_t&gt;                     Base_t;

public:
   // Typedefs from parent class and DomainTraits

   typedef typename Base_t::iterator             iterator;
   typedef typename Base_t::const_iterator       const_iterator;
   typedef typename Base_t::blockIterator        blockIterator;
   typedef typename Base_t::const_blockIterator  const_blockIterator;

   typedef typename DT_t::Element_t            Element_t;
   typedef typename DT_t::Domain_t             Domain_t;
   typedef typename DT_t::OneDomain_t          OneDomain_t;
   typedef typename DT_t::BlockDomain_t        BlockDomain_t;
   typedef typename DT_t::AskDomain_t          AskDomain_t;
   typedef typename DT_t::AddResult_t          AddResult_t;
   typedef typename DT_t::MultResult_t         MultResult_t;
   typedef typename DT_t::Storage_t            Storage_t;

   // duplicate static data from traits class

   static const bool domain          = DT_t::domain;
   static const int  dimensions      = DT_t::dimensions;
   static const int  sliceDimensions = DT_t::sliceDimensions;
   static const bool loopAware       = DT_t::loopAware;
   static const bool singleValued    = DT_t::singleValued;
   static const bool unitStride      = DT_t::unitStride;
   static const bool wildcard        = DT_t::wildcard;

   //
   // Constructors.
   //

   // default constructor : initialize to an empty domain
   Grid() { }

   // copy constructor
   Grid(const Grid&lt;Dim&gt; &amp;a) {
     NewDomain1&lt;Grid&lt;Dim&gt; &gt;::fill(*this, a);
   }

   // templated constructors, taking from 1 to 7 different domain objects
   // (or integers).
   template&lt;class T1&gt;
   explicit Grid(const T1 &amp;a) {
     NewDomain1&lt;T1&gt;::fill(*this, a);
   }

   template&lt;class T1, class T2&gt;
   Grid(const T1 &amp;a, const T2 &amp;b) {
     NewDomain2&lt;T1,T2&gt;::fill(*this, a, b);
   }

   template&lt;class T1, class T2, class T3&gt;
   Grid(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c) {
     NewDomain3&lt;T1,T2,T3&gt;::fill(*this, a, b, c);
   }

   template&lt;class T1, class T2, class T3, class T4&gt;
   Grid(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d) {
     NewDomain4&lt;T1,T2,T3,T4&gt;::fill(*this, a, b, c, d);
   }

   template&lt;class T1, class T2, class T3, class T4, class T5&gt;
   Grid(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d, const T5 &amp;e) {
     NewDomain5&lt;T1,T2,T3,T4,T5&gt;::fill(*this, a, b, c, d, e);
   }

   template&lt;class T1, class T2, class T3, class T4, class T5,
            class T6&gt;
   Grid(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d, const T5 &amp;e,
        const T6 &amp;f) {
     NewDomain6&lt;T1,T2,T3,T4,T5,T6&gt;::fill(*this, a, b, c, d, e, f);
   }

   template&lt;class T1, class T2, class T3, class T4, class T5,
            class T6, class T7&gt;
   Grid(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d, const T5 &amp;e,
        const T6 &amp;f, const T7 &amp;g) {
     NewDomain7&lt;T1,T2,T3,T4,T5,T6,T7&gt;::fill(*this, a, b, c, d, e, f, g);
   }

   //
   // Destructor.  For this class there is nothing to do.
   //

   ~Grid() {
     for (int i=0;i&lt;Dim;++i)
       operator[](i).~OneDomain_t();
   }

   //
   // operator=, templated to allow assignment from other domain objects
   // this uses the same mechanism as the constructors to fill in to this
   // object the data from the given object.  If the new object has too
   // few dimensions, this will only change the first M dimensions of this
   // object, where M is the number of dimensions for newdom
   //

   template&lt;class T&gt;
   Grid&lt;Dim&gt; &amp;operator=(const T &amp;newdom) {
     return NewDomain1&lt;T&gt;::fill(*this, newdom);
   }

   Grid&lt;Dim&gt; &amp;operator=(const Grid&lt;Dim&gt; &amp;newdom) {
     return NewDomain1&lt;Grid&lt;Dim&gt; &gt;::fill(*this, newdom);
   }

   //
   // I/O/
   //

   // print a Grid&lt;N&gt; to a stream, in the format
   //   &quot;[&quot; value1,value2,...,valueN &quot;]&quot;

   template&lt;class Out&gt;
   void print(Out &amp;o) const {
     iterator p    = begin();
     iterator pend = end();
     o &lt;&lt; &quot;[&quot;;
     while (p != pend)
       {
	o &lt;&lt; *p;
	++p;
	if (p != pend)
	  o &lt;&lt; &quot;,&quot;;
       }
     o &lt;&lt; &quot;]&quot;;
   }

protected:

private:

};


//-----------------------------------------------------------------------------
//
// Full Description of Grid&lt;1&gt;:
//
// Grid&lt;1&gt; is a 1D specialization of Grid&lt;N&gt;; for the 1D case,
// there are only a restricted set of constructors available.
// For the special case of Grid&lt;1&gt;, the following constructors
// are defined:
//   Grid&lt;1&gt; a() - default constructor, which creates an EMPTY Grid
//   Grid&lt;1&gt; a(n) - sets the Grid to the sequence [0 ... (n-1)], stride 1
//   Grid&lt;1&gt; a(m,n) - sets the Grid to the sequence [m ... n], stride 1 or -1
//   Grid&lt;1&gt; a(m,n,s) - sets the Grid to the sequence [m ... n], stride s
//   Grid&lt;1&gt; a(Domain d) : a Grid copied from d, which must be a
//     1D domain object.
//
//-----------------------------------------------------------------------------

template&lt;&gt;
class Grid&lt;1&gt; : public Domain&lt;1, DomainTraits&lt;Grid&lt;1&gt; &gt; &gt;
{
   // convenience typedef
   typedef DomainTraits&lt; Grid&lt;1&gt; &gt;  DT_t;

public:
   // typedefs from DomainTraits

   typedef DT_t::Element_t            Element_t;
   typedef DT_t::Domain_t             Domain_t;
   typedef DT_t::OneDomain_t          OneDomain_t;
   typedef DT_t::BlockDomain_t        BlockDomain_t;
   typedef DT_t::AskDomain_t          AskDomain_t;
   typedef DT_t::AddResult_t          AddResult_t;
   typedef DT_t::MultResult_t         MultResult_t;
   typedef DT_t::Storage_t            Storage_t;

   // duplicate static data from traits class

   static const bool domain          = DT_t::domain;
   static const int  dimensions      = DT_t::dimensions;
   static const int  sliceDimensions = DT_t::sliceDimensions;
   static const bool loopAware       = DT_t::loopAware;
   static const bool singleValued    = DT_t::singleValued;
   static const bool unitStride      = DT_t::unitStride;
   static const bool wildcard        = DT_t::wildcard;

   //
   // Constructors.
   //

   // default constructor
   Grid() { }

   // copy constructor
   Grid(const Grid&lt;1&gt; &amp;a) {
     NewDomain1&lt;Grid&lt;1&gt; &gt;::fill(*this, a);
   }

   // general argument constructor, to copy from a different domain type
   template&lt;class T1&gt;
   explicit Grid(const T1 &amp;a) {
     NewDomain1&lt;T1&gt;::fill(*this, a);
   }

   // initialize from a single scalar.  must specialize to all scalars.
   Grid(char a) {
     PAssert(a != 0);
     DomainTraits&lt;Grid&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Grid(unsigned char a) {
     PAssert(a != 0);
     DomainTraits&lt;Grid&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Grid(short a) {
     PAssert(a != 0);
     short s = (a &lt; 0 ? -1 : 1);
     DomainTraits&lt;Grid&lt;1&gt; &gt;::setDomain(domain_m, 0, a - s);
   }
   Grid(unsigned short a) {
     PAssert(a != 0);
     DomainTraits&lt;Grid&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Grid(int a) {
     PAssert(a != 0);
     int s = (a &lt; 0 ? -1 : 1);
     DomainTraits&lt;Grid&lt;1&gt; &gt;::setDomain(domain_m, 0, a - s);
   }
   Grid(unsigned int a) {
     PAssert(a != 0);
     DomainTraits&lt;Grid&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Grid(long a) {
     PAssert(a != 0);
     long s = (a &lt; 0 ? -1 : 1);
     DomainTraits&lt;Grid&lt;1&gt; &gt;::setDomain(domain_m, 0, a - s);
   }
   Grid(unsigned long a) {
     PAssert(a != 0);
     DomainTraits&lt;Grid&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }

   // initialize from a set of endpoints: sets range to [m ..n].
   // domain_m is the domain information storage kept in the base class.
   template&lt;class T1, class T2&gt;
   Grid(const T1 &amp;m, const T2 &amp;n) {
     DomainTraits&lt;Grid&lt;1&gt; &gt;::setDomain(domain_m, m, n);
   }

   // initialize from a set of endpoints and with a given stride.
   // domain_m is the domain information storage kept in the base class.
   template&lt;class T1, class T2, class T3&gt;
   Grid(const T1 &amp;m, const T2 &amp;n, const T3 &amp;s) {
     DomainTraits&lt;Grid&lt;1&gt; &gt;::setDomain(domain_m, m, n, s);
   }

   //
   // Destructor.  For this class there is nothing to do.
   //

   ~Grid() { }

   //
   // operator=, templated to allow assignment from other domain objects
   // this uses the same mechanism as the constructors to fill in to this
   // object the data from the given object.  If the new object has too
   // few dimensions, this will only change the first M dimensions of this
   // object, where M is the number of dimensions for newdom
   //

   template&lt;class T&gt;
   Grid&lt;1&gt; &amp;operator=(const T &amp;newdom) {
     return NewDomain1&lt;T&gt;::fill(*this, newdom);
   }

   Grid&lt;1&gt; &amp;operator=(const Grid&lt;1&gt; &amp;newdom) {
     return NewDomain1&lt;Grid&lt;1&gt; &gt;::fill(*this, newdom);
   }

   //
   // A special function used to initialize one Grid from another.  For
   // this, we need non-modifiable access to the storage.
   //

   const Storage_t &amp;storage() const { return domain_m; }

   //
   // I/O/
   //

   // print a Grid&lt;N&gt; to a stream, in the format
   //   &quot;[&quot; value1,value2,...,valueN &quot;]&quot;

   template&lt;class Out&gt;
   void print(Out &amp;o) const {
     iterator p    = begin();
     iterator pend = end();
     o &lt;&lt; &quot;[&quot;;
     while (p != pend)
       {
	o &lt;&lt; *p;
	++p;
	if (p != pend)
	  o &lt;&lt; &quot;,&quot;;
       }
     o &lt;&lt; &quot;]&quot;;
   }
};

//////////////////////////////////////////////////////////////////////
//
// print a Grid&lt;N&gt; to a stream, in the format
//   &quot;[&quot; value1,value2,...,valueN &quot;]&quot;
//
//////////////////////////////////////////////////////////////////////

template&lt;int Dim&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream &amp;o, const Grid&lt;Dim&gt; &amp;grid)
{
   grid.print(o);
   return o;
}

//////////////////////////////////////////////////////////////////////
//
// Specialization of the CHEETAH Serialize class for Grid&lt;1&gt;.
//
//////////////////////////////////////////////////////////////////////

#if POOMA_CHEETAH

#include &quot;Cheetah/Cheetah.h&quot;

namespace Cheetah {

template&lt;&gt;
class Serialize&lt;CHEETAH, Grid&lt;1&gt; &gt;
{
public:

   typedef Grid&lt;1&gt;                    Grid_t;
   typedef Grid_t::Element_t          Element_t;
   typedef IndirectionList&lt;Element_t&gt; List_t;

   static inline long
   size(const Grid_t &amp;a)
   {
     return sizeof(int) + a.length() * sizeof(Element_t);
   }

   static inline int
   pack(const Grid_t &amp;a, char *buffer)
   {
     *reinterpret_cast&lt;int *&gt;(buffer) = a.length();

     long length = a.length() * sizeof(Element_t);

     memcpy(buffer + sizeof(int), &amp;a.storage()(0), length);

     return sizeof(int) + length;
   }

   static inline int
   unpack(Grid_t* &amp;a, char *buffer)
   {
     int length = *reinterpret_cast&lt;int *&gt;(buffer);

     List_t list(length);

     length *= sizeof(Element_t);

     memcpy(&amp;list(0), buffer + sizeof(int), length);

     a = new Grid_t(list);

     return sizeof(int) + length;
   }

   static inline void
   cleanup(Grid_t* a)
   {
     delete a;
   }
};

} // namespace Cheetah

#endif     // POOMA_CHEETAH

#endif     // POOMA_DOMAIN_GRID_H

// ACL:rcsinfo
// ----------------------------------------------------------------------
// $RCSfile: Grid.h,v $   $Author: cummings $
// $Revision: 1.11 $   $Date: 2001/04/13 02:12:59 $
// ----------------------------------------------------------------------
// ACL:rcsinfo
-------------- next part --------------
// -*- C++ -*-
// ACL:license
// ----------------------------------------------------------------------
// This software and ancillary information (herein called &quot;SOFTWARE&quot;)
// called POOMA (Parallel Object-Oriented Methods and Applications) is
// made available under the terms described here.  The SOFTWARE has been
// approved for release with associated LA-CC Number LA-CC-98-65.
//
// Unless otherwise indicated, this SOFTWARE has been authored by an
// employee or employees of the University of California, operator of the
// Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
// the U.S. Department of Energy.  The U.S. Government has rights to use,
// reproduce, and distribute this SOFTWARE. The public may copy, distribute,
// prepare derivative works and publicly display this SOFTWARE without
// charge, provided that this Notice and any statement of authorship are
// reproduced on all copies.  Neither the Government nor the University
// makes any warranty, express or implied, or assumes any liability or
// responsibility for the use of this SOFTWARE.
//
// If SOFTWARE is modified to produce derivative works, such modified
// SOFTWARE should be clearly marked, so as not to confuse it with the
// version available from LANL.
//
// For more information about POOMA, send e-mail to <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">pooma at acl.lanl.gov</A>,
// or visit the POOMA web page at <A HREF="http://www.acl.lanl.gov/pooma/.">http://www.acl.lanl.gov/pooma/.</A>
// ----------------------------------------------------------------------
// ACL:license

#ifndef POOMA_DOMAIN_INTERVAL_H
#define POOMA_DOMAIN_INTERVAL_H

//-----------------------------------------------------------------------------
// Class:
// Interval&lt;int&gt;
//-----------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Overview:
// Interval is a very simple type of domain, which refers to a set of points
// a, a+1, a+2, ..., b.  It has a hard-coded stride of 1.  Interval&lt;N&gt;
// is basically an array of Interval&lt;1&gt; objects.
//
// Interval defers most of its implementation to the
// Domain&lt;DomainTraits&lt;Interval&gt;&gt; base class.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typedefs:
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Includes:
//-----------------------------------------------------------------------------

#include &quot;Domain/Domain.h&quot;
#include &quot;Domain/DomainTraits.Interval.h&quot;
#include &quot;Domain/NewDomain.h&quot;
#include &quot;Utilities/NoInit.h&quot;
#include &quot;Utilities/PAssert.h&quot;

//-----------------------------------------------------------------------------
// Forward Declarations:
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Full Description of Interval:
//
// Interval&lt;N&gt; is a domain representing a set of N numeric sequences, one
// for each dimension N.  The sequences have endpoints [a,b], and a
// hard-coded stride of +1. It does not have any concept of loop variables,
// however, like Index does, so it cannot be used in any kind of tensor-like
// expression.
//
// You can construct an Interval object using other domain objects.
// The constructors accept up to 7 domain objects of various types.
// Domain types are, for example, Loc, Range, Interval. int may also be used
// in the constructor for Interval; it acts like a Loc&lt;1&gt; object
// in that context.  The domain arguments for the Interval
// constructors are combined together to form a single domain object with
// a dimension equal to the sum of the arguments dimensions; for example,
// if you try to create an Interval&lt;3&gt; from a Loc&lt;2&gt; and an Interval&lt;1&gt;, e.g.
//   Interval&lt;3&gt; a(Loc&lt;2&gt;(1,2), Interval&lt;1&gt;(3,5));
// the Loc&lt;2&gt; and Interval arguments are combined into a (2+1=3) dimensional
// domain object, used to initialize the Interval&lt;3&gt;.  The number of dimensions
// for the arguments must be &lt;= number of dimensions of the newly constructed
// Interval.
//
// For Interval&lt;1&gt;, the list of constructors is limited to just the following:
//   Interval&lt;1&gt; a() - default constructor, which creates an EMPTY Interval
//   Interval&lt;1&gt; a(n) - sets the Interval to the sequence [0 ... (n-1)]
//   Interval&lt;1&gt; a(m,n) - sets the Interval to the sequence [m ... n]
//
// The default Interval&lt;1&gt; constructor initializes the Interval to be empty,
// that is, to have a length() of zero.  In that case, the endpoints are
// undefined, as is any operation involving the Interval.
//
// In addition to the constructors, Interval has the following public
// interface, similar to all domain objects.  There are two classes of
// interface methods, one class which includes methods which any Interval&lt;N&gt;
// object has, regardless of dimensions, the other class which includes extra
// interface methods that are available for just Interval&lt;1&gt; objects.
//
// Interval&lt;N&gt; interface:
// ----------------------
//   long size() - return the 'volume' of the domain, which is the product
//      of the lenghts of the N 1D Intervals
//   bool empty() - return if any of the Interval&lt;1&gt; objects have length == 0
//   Interval&lt;1&gt; operator[](int N) - return the Nth Interval&lt;1&gt; in a
//      multidimensional Interval&lt;M&gt;.  For Interval&lt;1&gt; objects, this just
//      returns the object back.
//   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare an Interval &lt;N&gt; to
//      another domain object.  The compared domains must have the same
//      number of dimensions.
//   arithmetic accumulation operators +=, -= : add or substract in a
//      given domain.  The added domain must have the same number of
//      dimensions, or a dimension of 1 (in which case, the same value
//      is used for all dimensions), and be known to be single-valued (which
//      is true for Loc and int's).  Note that for Interval, *= and /= are NOT
//      allowed, since these operators would change the stride and that is
//      not allowed for Interval (it has a hard-coded stride of 1).
//      The negation operator (operator-) is also NOT allowed for Interval.
//   binary arithmethic operators +, -, *, / : for + and -, adding an Interval
//      to another Loc or int returns a new Interval.  For * and /, scaling
//      by a Loc or int returns a Range object, since the stride may
//      change.
//   increment/decrement operator ++, -- : only prefix versions of ++ and --
//      are provided; they act just like += 1 and -= 1 operations.
//
// Interval&lt;1&gt; interface:
// ----------------------
//   all of the methods for Interval&lt;N&gt; are also available for Interval&lt;1&gt;.
//   int length() - number of elements (including endpoints) of the domain.
//   int first() - the beginning endpoint.
//   int last() - the ending endpoint.
//   int min(), int max() - min or max of the endpoints.
//   Interval&lt;1&gt;::iterator begin() and end() - return iterators for the 1D
//      domain.  These act like (at least) bidirectional iterators.
//
// Interval inherits much of its activity from Domain&lt;DomainTraits&lt;Interval&gt;&gt;.
//
// For the special case of Interval&lt;1&gt;, there is a specialization given
// after the general case that has different constructors (listed above).
//
//-----------------------------------------------------------------------------

template&lt;int Dim&gt;
class Interval : public Domain&lt;Dim, DomainTraits&lt;Interval&lt;Dim&gt; &gt; &gt;
{
   // convenience typedefs
   typedef DomainTraits&lt; Interval&lt;Dim&gt; &gt;         DT_t;
   typedef Domain&lt;Dim, DT_t&gt;                     Base_t;

public:
   // Typedefs from parent class and DoaminTraits

   typedef typename Base_t::iterator             iterator;
   typedef typename Base_t::const_iterator       const_iterator;
   typedef typename Base_t::blockIterator        blockIterator;
   typedef typename Base_t::const_blockIterator  const_blockIterator;

   typedef typename DT_t::Element_t            Element_t;
   typedef typename DT_t::Domain_t             Domain_t;
   typedef typename DT_t::OneDomain_t          OneDomain_t;
   typedef typename DT_t::BlockDomain_t        BlockDomain_t;
   typedef typename DT_t::AskDomain_t          AskDomain_t;
   typedef typename DT_t::AddResult_t          AddResult_t;
   typedef typename DT_t::MultResult_t         MultResult_t;
   typedef typename DT_t::Storage_t            Storage_t;

   // duplicate static data from traits class

   static const bool domain          = DT_t::domain;
   static const int  dimensions      = DT_t::dimensions;
   static const int  sliceDimensions = DT_t::sliceDimensions;
   static const bool loopAware       = DT_t::loopAware;
   static const bool singleValued    = DT_t::singleValued;
   static const bool unitStride      = DT_t::unitStride;
   static const bool wildcard        = DT_t::wildcard;

   //
   // Constructors.
   //

   // default constructor : initialize to an empty domain
   Interval() { }

   // copy constructor
   Interval(const Interval&lt;Dim&gt; &amp;a)
     : Domain&lt;Dim, DomainTraits&lt;Interval&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain1&lt;Interval&lt;Dim&gt; &gt;::fill(*this, a);
   }

   // Uninitialized constructor
   Interval(const Pooma::NoInit &amp;a)
     : Domain&lt;Dim, DomainTraits&lt;Interval&lt;Dim&gt; &gt; &gt;(a)
   { }

   // templated constructors, taking from 1 to 7 different domain objects
   // (or integers).
   template&lt;class T1&gt;
   explicit Interval(const T1 &amp;a)
     : Domain&lt;Dim, DomainTraits&lt;Interval&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain1&lt;T1&gt;::fill(*this, a);
   }

   template&lt;class T1, class T2&gt;
   Interval(const T1 &amp;a, const T2 &amp;b)
     : Domain&lt;Dim, DomainTraits&lt;Interval&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain2&lt;T1,T2&gt;::fill(*this, a, b);
   }

   template&lt;class T1, class T2, class T3&gt;
   Interval(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)
     : Domain&lt;Dim, DomainTraits&lt;Interval&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain3&lt;T1,T2,T3&gt;::fill(*this, a, b, c);
   }

   template&lt;class T1, class T2, class T3, class T4&gt;
   Interval(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d)
     : Domain&lt;Dim, DomainTraits&lt;Interval&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain4&lt;T1,T2,T3,T4&gt;::fill(*this, a, b, c, d);
   }

   template&lt;class T1, class T2, class T3, class T4, class T5&gt;
   Interval(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d, const T5 &amp;e)
     : Domain&lt;Dim, DomainTraits&lt;Interval&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain5&lt;T1,T2,T3,T4,T5&gt;::fill(*this, a, b, c, d, e);
   }

   template&lt;class T1, class T2, class T3, class T4, class T5,
            class T6&gt;
   Interval(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d, const T5 &amp;e,
       const T6 &amp;f)
     : Domain&lt;Dim, DomainTraits&lt;Interval&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain6&lt;T1,T2,T3,T4,T5,T6&gt;::fill(*this, a, b, c, d, e, f);
   }

   template&lt;class T1, class T2, class T3, class T4, class T5,
            class T6, class T7&gt;
   Interval(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d, const T5 &amp;e,
       const T6 &amp;f, const T7 &amp;g)
     : Domain&lt;Dim, DomainTraits&lt;Interval&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain7&lt;T1,T2,T3,T4,T5,T6,T7&gt;::fill(*this, a, b, c, d, e, f, g);
   }

   //
   // Destructor.  For this class there is nothing to do.
   //

   ~Interval() { }

   //
   // operator=, templated to allow assignment from other domain objects
   // this uses the same mechanism as the constructors to fill in to this
   // object the data from the given object.  If the new object has too
   // few dimensions, this will only change the first M dimensions of this
   // object, where M is the number of dimensions for newdom
   //

   template&lt;class T&gt;
   Interval&lt;Dim&gt; &amp;operator=(const T &amp;newdom) {
     return NewDomain1&lt;T&gt;::fill(*this, newdom);
   }

   Interval&lt;Dim&gt; &amp;operator=(const Interval&lt;Dim&gt; &amp;newdom) {
     return NewDomain1&lt;Interval&lt;Dim&gt; &gt;::fill(*this, newdom);
   }

protected:

private:

};


//-----------------------------------------------------------------------------
//
// Full Description of Interval&lt;1&gt;:
//
// Interval&lt;1&gt; is a 1D specialization of Interval&lt;N&gt;; for the 1D case,
// there are only a restricted set of constructors available.
// For the special case of Interval&lt;1&gt;, the following constructors
// are defined:
//   Interval&lt;1&gt; a() - default constructor, which creates an EMPTY Interval
//   Interval&lt;1&gt; a(n) - sets the Interval to the sequence [0 ... (n-1)]
//   Interval&lt;1&gt; a(m,n) - sets the Interval to the sequence [m ... n]
//   Interval&lt;1&gt; a(Domain d) - an Interval copied from d, which must be a
//     1D domain object.
//
//-----------------------------------------------------------------------------

template&lt;&gt;
class Interval&lt;1&gt; : public Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;
{
   // convenience typedef
   typedef DomainTraits&lt; Interval&lt;1&gt; &gt;  DT_t;

public:
   // typedefs from DomainTraits

   typedef DT_t::Element_t            Element_t;
   typedef DT_t::Domain_t             Domain_t;
   typedef DT_t::OneDomain_t          OneDomain_t;
   typedef DT_t::BlockDomain_t        BlockDomain_t;
   typedef DT_t::AskDomain_t          AskDomain_t;
   typedef DT_t::AddResult_t          AddResult_t;
   typedef DT_t::MultResult_t         MultResult_t;
   typedef DT_t::Storage_t            Storage_t;

   // duplicate static data from traits class

   static const bool domain          = DT_t::domain;
   static const int  dimensions      = DT_t::dimensions;
   static const int  sliceDimensions = DT_t::sliceDimensions;
   static const bool loopAware       = DT_t::loopAware;
   static const bool singleValued    = DT_t::singleValued;
   static const bool unitStride      = DT_t::unitStride;
   static const bool wildcard        = DT_t::wildcard;

   //
   // Constructors.
   //

   // default constructor
   Interval() { }

   // copy constructor
   Interval(const Interval&lt;1&gt; &amp;a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain1&lt;Interval&lt;1&gt; &gt;::fill(*this, a);
   }

   // Uninitialized constructor
   Interval(const Pooma::NoInit &amp;a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(a)
   { }

   // general argument constructor, to copy from a different domain type
   template&lt;class T1&gt;
   explicit Interval(const T1 &amp;a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain1&lt;T1&gt;::fill(*this, a);
   }

   // initialize from a single scalar.  must specialize to all scalars.
   Interval(char a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     DomainTraits&lt;Interval&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Interval(unsigned char a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     DomainTraits&lt;Interval&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Interval(short a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     DomainTraits&lt;Interval&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Interval(unsigned short a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     DomainTraits&lt;Interval&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Interval(int a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     DomainTraits&lt;Interval&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Interval(unsigned int a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     DomainTraits&lt;Interval&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Interval(long a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     DomainTraits&lt;Interval&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Interval(unsigned long a)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     DomainTraits&lt;Interval&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }

   // initialize from a set of endpoints: sets interval to [m ..n].  Must
   // have m &lt;= n.
   template&lt;class T1, class T2&gt;
   Interval(const T1 &amp;m, const T2 &amp;n)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit() ) {
         DomainTraits&lt;Interval&lt;1&gt; &gt;::setDomain(domain_m, m, n);
   }


   // initialize from three integers: if the stride is not 1,
   // it is an error.
   template&lt;class T1, class T2, class T3&gt;
   Interval(const T1 &amp;m, const T2 &amp;n, const T3 &amp;s)
     : Domain&lt;1, DomainTraits&lt;Interval&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
         PAssert(s == 1);
         DomainTraits&lt;Interval&lt;1&gt; &gt;::setDomain(domain_m, m, n);
   }

   //
   // Destructor.  For this class there is nothing to do.
   //

   ~Interval() { }

   //
   // operator=, templated to allow assignment from other domain objects
   // this uses the same mechanism as the constructors to fill in to this
   // object the data from the given object.  If the new object has too
   // few dimensions, this will only change the first M dimensions of this
   // object, where M is the number of dimensions for newdom
   //

   template&lt;class T&gt;
   Interval&lt;1&gt; &amp;operator=(const T &amp;newdom) {
     return NewDomain1&lt;T&gt;::fill(*this, newdom);
   }

   Interval&lt;1&gt; &amp;operator=(const Interval&lt;1&gt; &amp;newdom) {
     return NewDomain1&lt;Interval&lt;1&gt; &gt;::fill(*this, newdom);
   }

};

//////////////////////////////////////////////////////////////////////

#endif     // POOMA_DOMAIN_INTERVAL_H

// ACL:rcsinfo
// ----------------------------------------------------------------------
// $RCSfile: Interval.h,v $   $Author: cummings $
// $Revision: 1.17 $   $Date: 2001/04/13 02:12:59 $
// ----------------------------------------------------------------------
// ACL:rcsinfo
-------------- next part --------------
// -*- C++ -*-
// ACL:license
// ----------------------------------------------------------------------
// This software and ancillary information (herein called &quot;SOFTWARE&quot;)
// called POOMA (Parallel Object-Oriented Methods and Applications) is
// made available under the terms described here.  The SOFTWARE has been
// approved for release with associated LA-CC Number LA-CC-98-65.
//
// Unless otherwise indicated, this SOFTWARE has been authored by an
// employee or employees of the University of California, operator of the
// Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
// the U.S. Department of Energy.  The U.S. Government has rights to use,
// reproduce, and distribute this SOFTWARE. The public may copy, distribute,
// prepare derivative works and publicly display this SOFTWARE without
// charge, provided that this Notice and any statement of authorship are
// reproduced on all copies.  Neither the Government nor the University
// makes any warranty, express or implied, or assumes any liability or
// responsibility for the use of this SOFTWARE.
//
// If SOFTWARE is modified to produce derivative works, such modified
// SOFTWARE should be clearly marked, so as not to confuse it with the
// version available from LANL.
//
// For more information about POOMA, send e-mail to <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">pooma at acl.lanl.gov</A>,
// or visit the POOMA web page at <A HREF="http://www.acl.lanl.gov/pooma/.">http://www.acl.lanl.gov/pooma/.</A>
// ----------------------------------------------------------------------
// ACL:license

#ifndef POOMA_DOMAIN_RANGE_H
#define POOMA_DOMAIN_RANGE_H

//-----------------------------------------------------------------------------
// Class:
// Range&lt;int&gt;
//-----------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Overview:
// Range is a general type of integer domain, which refers to a set of points
// a, a+s, a+2s, ..., b.  It has a run-time specified stride value s.  It
// is basically an array of Range&lt;1&gt; objects.
//
// Range defers most of its implementation to the Domain&lt;DomainTraits&lt;Range&gt;&gt;
// base class.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typedefs:
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Includes:
//-----------------------------------------------------------------------------

#include &quot;Domain/Domain.h&quot;
#include &quot;Domain/DomainTraits.Range.h&quot;
#include &quot;Domain/NewDomain.h&quot;
#include &quot;Utilities/NoInit.h&quot;
#include &quot;Utilities/PAssert.h&quot;

//-----------------------------------------------------------------------------
// Forward Declarations:
//-----------------------------------------------------------------------------

template &lt;int Dim&gt; class Range;

template&lt;int Dim&gt;
inline
void fillRangeScalar(Range&lt;Dim&gt; &amp;r, const int &amp;a);

//-----------------------------------------------------------------------------
//
// Full Description of Range:
//
// Range&lt;N&gt; is a domain representing a set of N numeric sequences, one
// for each dimension N.  The sequences have endpoints [a,b], with a stride
// s. It does not have any concept of loop variables,
// however, like Index does, so it cannot be used in any kind of tensor-like
// expression.
//
// You can construct a Range object using other domain objects.
// The constructors accept up to 7 domain objects of various types.
// Domain types are, for example, Loc, Range, Interval. int may also be used
// in the constructor for Range; it acts like a Loc&lt;1&gt; object
// in that context.  The domain arguments for the Range
// constructors are combined together to form a single domain object with
// a dimension equal to the sum of the arguments dimensions; for example,
// if you try to create a Range&lt;3&gt; from a Loc&lt;2&gt; and an Interval&lt;1&gt;, e.g.
//   Range&lt;3&gt; a(Loc&lt;2&gt;(1,2), Interval&lt;1&gt;(3,5));
// the Loc&lt;2&gt; and Interval arguments are combined into a (2+1=3) dimensional
// domain object, used to initialize the Range&lt;3&gt;.  The number of dimensions
// for the arguments must be &lt;= number of dimensions of the newly constructed
// Range.
//
// For Range&lt;1&gt;, the list of constructors is limited to just the following:
//   Range&lt;1&gt; a() - default constructor, which creates an EMPTY Range
//   Range&lt;1&gt; a(n) - sets the Range to the sequence [0 ... (n-1)], stride 1
//   Range&lt;1&gt; a(m,n) - sets the Range to the sequence [m ... n], stride 1 or -1
//   Range&lt;1&gt; a(m,n,s) - sets the Range to the sequence [m ... n], stride s
//
// The default Range&lt;1&gt; constructor initializes the Range to be empty,
// that is, to have a length() of zero.  In that case, the endpoints are
// undefined, as is any operation involving the Range.
//
// In addition to the constructors, Range has the following public
// interface, similar to all domain objects.  There are two classes of
// interface methods, one class which includes methods which any Range&lt;N&gt;
// object has, regardless of dimensions, the other class which includes extra
// interface methods that are available for just Range&lt;1&gt; objects.
//
// Range&lt;N&gt; interface:
// -------------------
//   long size() - return the 'volume' of the domain, which is the product
//      of the lenghts of the N 1D Ranges
//   bool empty() - return if any of the Range&lt;1&gt; objects have length == 0
//   Range&lt;1&gt; operator[](int N) - return the Nth Range&lt;1&gt; in a
//      multidimensional Range&lt;M&gt;.  For Range&lt;1&gt; objects, this just
//      returns the object back.
//   comparison operators: &lt;, &gt;, !=, ==, &lt;=, &gt;= : compare a Range&lt;N&gt; to
//      another domain object.  The compared domains must have the same
//      number of dimensions.
//   arithmetic accumulation operators +=, -=, *=, /= : add or substract in a
//      given domain.  The added domain must have the same number of
//      dimensions, or a dimension of 1 (in which case, the same value
//      is used for all dimensions), and be known to be single-valued (which
//      is true for Loc and int's).  Note that for Range, *= and /= ARE
//      allowed, since Range can have its stride changed at run time.  *=
//      and /= result in scaling of the endpoints and stride, which leaves
//      the length (and size) the same.  += and -= shift the beginning
//      endpoints by the given values, also leaving the length and size the
//      same.  Negation of a Range negates the endpoints and stride.
//   binary arithmethic operators +, -, *, / : for + and -, adding a Range
//      to another Loc or int returns a new Range.  For * and /, scaling
//      by a Loc or int also returns a Range object, since the stride may
//      change.
//   increment/decrement operator ++, -- : only prefix versions of ++ and --
//      are provided; they act just like += 1 and -= 1 operations.
//
// Range&lt;1&gt; interface:
// -------------------
//   all of the methods for Range&lt;N&gt; are also available for Range&lt;1&gt;. Plus:
//   long length() - number of elements (including endpoints) of the domain.
//     for a non-unit-stride Range, the length refers to the number of
//     strided points (including the endpoints), NOT the difference between
//     the first and last endpoint.  That is, length = (end-beg)/stride + 1,
//     NOT (end-beg) + 1.
//   int first() - the beginning endpoint.
//   int last() - the ending endpoint.
//   int min(), int max() - min or max of the endpoints.
//   Interval&lt;1&gt;::iterator begin() and end() - return iterators for the 1D
//      domain.  These act like (at least) bidirectional iterators.
//
// For the special case of Range&lt;1&gt;, there is a specialization given
// after the general case that has different constructors.
//
// Range inherits much of its activity from Domain&lt;DomainTraits&lt;Range&gt;&gt;
//
//-----------------------------------------------------------------------------

template&lt;int Dim&gt;
class Range : public Domain&lt;Dim, DomainTraits&lt;Range&lt;Dim&gt; &gt; &gt;
{
   // convenience typedefs
   typedef DomainTraits&lt; Range&lt;Dim&gt; &gt;            DT_t;
   typedef Domain&lt;Dim, DT_t&gt;                     Base_t;

public:
   // Typedefs from parent class and DomainTraits

   typedef typename Base_t::iterator             iterator;
   typedef typename Base_t::const_iterator       const_iterator;
   typedef typename Base_t::blockIterator        blockIterator;
   typedef typename Base_t::const_blockIterator  const_blockIterator;

   typedef typename DT_t::Element_t            Element_t;
   typedef typename DT_t::Domain_t             Domain_t;
   typedef typename DT_t::OneDomain_t          OneDomain_t;
   typedef typename DT_t::BlockDomain_t        BlockDomain_t;
   typedef typename DT_t::AskDomain_t          AskDomain_t;
   typedef typename DT_t::AddResult_t          AddResult_t;
   typedef typename DT_t::MultResult_t         MultResult_t;
   typedef typename DT_t::Storage_t            Storage_t;

   // duplicate static data from traits class

   static const bool domain          = DT_t::domain;
   static const int  dimensions      = DT_t::dimensions;
   static const int  sliceDimensions = DT_t::sliceDimensions;
   static const bool loopAware       = DT_t::loopAware;
   static const bool singleValued    = DT_t::singleValued;
   static const bool unitStride      = DT_t::unitStride;
   static const bool wildcard        = DT_t::wildcard;

   //
   // Constructors.
   //

   // default constructor : initialize to an empty domain
   Range() { }

   // copy constructor
   Range(const Range&lt;Dim&gt; &amp;a)
     : Domain&lt;Dim, DomainTraits&lt;Range&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain1&lt;Range&lt;Dim&gt; &gt;::fill(*this, a);
   }

   // Uninitialized constructor
   Range(const Pooma::NoInit &amp;a)
     : Domain&lt;Dim, DomainTraits&lt;Range&lt;Dim&gt; &gt; &gt;(a)
   { }

   // templated constructors, taking from 1 to 7 different domain objects
   // (or integers).
   template&lt;class T1&gt;
   explicit Range(const T1 &amp;a)
     : Domain&lt;Dim, DomainTraits&lt;Range&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain1&lt;T1&gt;::fill(*this, a);
   }

   template&lt;class T1, class T2&gt;
   Range(const T1 &amp;a, const T2 &amp;b)
     : Domain&lt;Dim, DomainTraits&lt;Range&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain2&lt;T1,T2&gt;::fill(*this, a, b);
   }

   template&lt;class T1, class T2, class T3&gt;
   Range(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)
     : Domain&lt;Dim, DomainTraits&lt;Range&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain3&lt;T1,T2,T3&gt;::fill(*this, a, b, c);
   }

   template&lt;class T1, class T2, class T3, class T4&gt;
   Range(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d)
     : Domain&lt;Dim, DomainTraits&lt;Range&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain4&lt;T1,T2,T3,T4&gt;::fill(*this, a, b, c, d);
   }

   template&lt;class T1, class T2, class T3, class T4, class T5&gt;
   Range(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d, const T5 &amp;e)
     : Domain&lt;Dim, DomainTraits&lt;Range&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain5&lt;T1,T2,T3,T4,T5&gt;::fill(*this, a, b, c, d, e);
   }

   template&lt;class T1, class T2, class T3, class T4, class T5,
            class T6&gt;
   Range(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d, const T5 &amp;e,
	const T6 &amp;f)
     : Domain&lt;Dim, DomainTraits&lt;Range&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain6&lt;T1,T2,T3,T4,T5,T6&gt;::fill(*this, a, b, c, d, e, f);
   }

   template&lt;class T1, class T2, class T3, class T4, class T5,
            class T6, class T7&gt;
   Range(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c, const T4 &amp;d, const T5 &amp;e,
	const T6 &amp;f, const T7 &amp;g)
     : Domain&lt;Dim, DomainTraits&lt;Range&lt;Dim&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain7&lt;T1,T2,T3,T4,T5,T6,T7&gt;::fill(*this, a, b, c, d, e, f, g);
   }

   //
   // Destructor.  For this class there is nothing to do.
   //

   ~Range() { }

   //
   // operator=, templated to allow assignment from other domain objects
   // this uses the same mechanism as the constructors to fill in to this
   // object the data from the given object.  If the new object has too
   // few dimensions, this will only change the first M dimensions of this
   // object, where M is the number of dimensions for newdom
   //

   template&lt;class T&gt;
   Range&lt;Dim&gt; &amp;operator=(const T &amp;newdom) {
     return NewDomain1&lt;T&gt;::fill(*this, newdom);
   }

   Range&lt;Dim&gt; &amp;operator=(const Range&lt;Dim&gt; &amp;newdom) {
     return NewDomain1&lt;Range&lt;Dim&gt; &gt;::fill(*this, newdom);
   }

   Range&lt;Dim&gt; &amp;operator=(const int a) {
     fillRangeScalar(*this,a);
     return *this;
   }

protected:

private:

};


//-----------------------------------------------------------------------------
//
// Full Description of Range&lt;1&gt;:
//
// Range&lt;1&gt; is a 1D specialization of Range&lt;N&gt;; for the 1D case,
// there are only a restricted set of constructors available.
// For the special case of Range&lt;1&gt;, the following constructors
// are defined:
//   Range&lt;1&gt; a() - default constructor, which creates an EMPTY Range
//   Range&lt;1&gt; a(n) - sets the Range to the sequence [0 ... (n-1)], stride 1
//   Range&lt;1&gt; a(m,n) - sets the Range to the sequence [m ... n], stride 1 or -1
//   Range&lt;1&gt; a(m,n,s) - sets the Range to the sequence [m ... n], stride s
//   Range&lt;1&gt; a(Domain d) : a Range copied from d, which must be a
//     1D domain object.
//
//-----------------------------------------------------------------------------

template&lt;&gt;
class Range&lt;1&gt; : public Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;
{
   // convenience typedef
   typedef DomainTraits&lt; Range&lt;1&gt; &gt;  DT_t;

public:
   // typedefs from DomainTraits

   typedef DT_t::Element_t            Element_t;
   typedef DT_t::Domain_t             Domain_t;
   typedef DT_t::OneDomain_t          OneDomain_t;
   typedef DT_t::BlockDomain_t        BlockDomain_t;
   typedef DT_t::AskDomain_t          AskDomain_t;
   typedef DT_t::AddResult_t          AddResult_t;
   typedef DT_t::MultResult_t         MultResult_t;
   typedef DT_t::Storage_t            Storage_t;

   // duplicate static data from traits class

   static const bool domain          = DT_t::domain;
   static const int  dimensions      = DT_t::dimensions;
   static const int  sliceDimensions = DT_t::sliceDimensions;
   static const bool loopAware       = DT_t::loopAware;
   static const bool singleValued    = DT_t::singleValued;
   static const bool unitStride      = DT_t::unitStride;
   static const bool wildcard        = DT_t::wildcard;

   //
   // Constructors.
   //

   // default constructor
   Range() { }

   // copy constructor
   Range(const Range&lt;1&gt; &amp;a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain1&lt;Range&lt;1&gt; &gt;::fill(*this, a);
   }

   // Uninitialized constructor
   Range(const Pooma::NoInit &amp;a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(a)
   { }

   // general argument constructor, to copy from a different domain type
   template&lt;class T1&gt;
   explicit Range(const T1 &amp;a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     NewDomain1&lt;T1&gt;::fill(*this, a);
   }

   // initialize from a single scalar.  must specialize to all scalars.
   Range(char a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     PAssert(a != 0);
     DomainTraits&lt;Range&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Range(unsigned char a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     PAssert(a != 0);
     DomainTraits&lt;Range&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Range(short a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     PAssert(a != 0);
     short s = (a &lt; 0 ? -1 : 1);
     DomainTraits&lt;Range&lt;1&gt; &gt;::setDomain(domain_m, 0, a - s);
   }
   Range(unsigned short a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     PAssert(a != 0);
     DomainTraits&lt;Range&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Range(int a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     PAssert(a != 0);
     int s = (a &lt; 0 ? -1 : 1);
     DomainTraits&lt;Range&lt;1&gt; &gt;::setDomain(domain_m, 0, a - s);
   }
   Range(unsigned int a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     PAssert(a != 0);
     DomainTraits&lt;Range&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }
   Range(long a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     PAssert(a != 0);
     long s = (a &lt; 0 ? -1 : 1);
     DomainTraits&lt;Range&lt;1&gt; &gt;::setDomain(domain_m, 0, a - s);
   }
   Range(unsigned long a)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
     PAssert(a != 0);
     DomainTraits&lt;Range&lt;1&gt; &gt;::setDomain(domain_m, 0, a - 1);
   }

   // initialize from a set of endpoints: sets range to [m ..n].
   // domain_m is the domain information storage kept in the base class.
   template&lt;class T1, class T2&gt;
   Range(const T1 &amp;m, const T2 &amp;n)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
         DomainTraits&lt;Range&lt;1&gt; &gt;::setDomain(domain_m, m, n);
   }

   // initialize from a set of endpoints and with a given stride.
   // domain_m is the domain information storage kept in the base class.
   template&lt;class T1, class T2, class T3&gt;
   Range(const T1 &amp;m, const T2 &amp;n, const T3 &amp;s)
     : Domain&lt;1, DomainTraits&lt;Range&lt;1&gt; &gt; &gt;(Pooma::NoInit()) {
         DomainTraits&lt;Range&lt;1&gt; &gt;::setDomain(domain_m, m, n, s);
   }

   //
   // Destructor.  For this class there is nothing to do.
   //

   ~Range() { }

   //
   // operator=, templated to allow assignment from other domain objects
   // this uses the same mechanism as the constructors to fill in to this
   // object the data from the given object.  If the new object has too
   // few dimensions, this will only change the first M dimensions of this
   // object, where M is the number of dimensions for newdom
   //

   template&lt;class T&gt;
   Range&lt;1&gt; &amp;operator=(const T &amp;newdom) {
     return NewDomain1&lt;T&gt;::fill(*this, newdom);
   }

   Range&lt;1&gt; &amp;operator=(const Range&lt;1&gt; &amp;newdom) {
     return NewDomain1&lt;Range&lt;1&gt; &gt;::fill(*this, newdom);
   }

};

template&lt;int Dim&gt;
inline
void fillRangeScalar(Range&lt;Dim&gt; &amp;r, const int &amp;a)
{
   for (int i=0; i &lt; Dim; ++i)
     r[i]=Range&lt;1&gt;(a);
}

//////////////////////////////////////////////////////////////////////

#endif     // POOMA_DOMAIN_RANGE_H

// ACL:rcsinfo
// ----------------------------------------------------------------------
// $RCSfile: Range.h,v $   $Author: cummings $
// $Revision: 1.18 $   $Date: 2001/04/13 02:12:59 $
// ----------------------------------------------------------------------
// ACL:rcsinfo
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000273.html">FW: gcc/stl question
</A></li>
	<LI>Next message: <A HREF="000274.html">[pooma-dev] Metrowerks and template member functions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#272">[ date ]</a>
              <a href="thread.html#272">[ thread ]</a>
              <a href="subject.html#272">[ subject ]</a>
              <a href="author.html#272">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
