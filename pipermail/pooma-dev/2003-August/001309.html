<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] Move big methods ool inside Partition/
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20%5BPATCH%5D%20Move%20big%20methods%20ool%20inside%20Partition/&In-Reply-To=%3CPine.LNX.4.44.0308042046000.584-100000%40goofy%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="001310.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] Move big methods ool inside Partition/</H1>
    <B>Richard Guenther</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20%5BPATCH%5D%20Move%20big%20methods%20ool%20inside%20Partition/&In-Reply-To=%3CPine.LNX.4.44.0308042046000.584-100000%40goofy%3E"
       TITLE="[PATCH] Move big methods ool inside Partition/">rguenth at tat.physik.uni-tuebingen.de
       </A><BR>
    <I>Mon Aug  4 18:50:21 UTC 2003</I>
    <P><UL>
        
        <LI>Next message: <A HREF="001310.html">[PATCH] Kill use of POOMA_NO_RESTRICT
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1309">[ date ]</a>
              <a href="thread.html#1309">[ thread ]</a>
              <a href="subject.html#1309">[ subject ]</a>
              <a href="author.html#1309">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
The following patch moves big methods out of line for classes
inside Partition/.  There is no gain in inlining these methods
and compile time improves with these not declared inline.  It
also makes the class structures easier to read.

Tested by compiling and Layout and Paritition tests on ppc-linux.

Ok?

Richard.


2003Aug04  Richard Guenther &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">richard.guenther at uni-tuebingen.de</A>&gt;

	* src/Partition/BisectionMapper.h: move big methods out of line.
	src/Partition/ContextMapper.h: likewise.
	src/Partition/ContiguousMapper.h: likewise.
	src/Partition/DistributedMapper.h: likewise.
	src/Partition/GridPartition.h: likewise.
	src/Partition/SpatialPartition.h: likewise.
	src/Partition/TilePartition.h: likewise.
	src/Partition/UniformGridPartition.h: likewise.

Index: src/Partition/BisectionMapper.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/BisectionMapper.h,v
retrieving revision 1.6
diff -u -u -r1.6 BisectionMapper.h
--- src/Partition/BisectionMapper.h	23 Jan 2003 21:29:50 -0000	1.6
+++ src/Partition/BisectionMapper.h	4 Aug 2003 18:43:56 -0000
@@ -69,115 +69,119 @@

   //

-  void map(const List_t &amp; templist) const
-  {
-    int ncontexts = Pooma::contexts();
-    int npatch = 1;
-    for (int i =0;i&lt;Dim; ++i)
-      npatch*=blocks_m[i].first();
-
-    std::list&lt;Domain_t&gt; bvec;
-
-    Domain_t allb;
-    for (int i = 0; i&lt;Dim; ++i)
-      allb[i]=Interval&lt;1&gt;(0,blocks_m[i].first()-1);
-    bvec.push_back(allb);
-
-    while ( bvec.size() &lt; ncontexts )
-      {
-	int s = 0;
-	typename std::list&lt;Domain_t&gt;::iterator bstart = bvec.begin();
-	typename std::list&lt;Domain_t&gt;::iterator bend = bvec.end();
-	typename std::list&lt;Domain_t&gt;::iterator bpatch;
-	// find the largest patch.
-	for ( ; bstart != bend ; ++bstart)
-	  {
-	    if (s &lt; (*bstart).size() )
-	      {
-		bpatch = bstart;
-		s = (*bstart).size();
-	      }
-	  }
-	// now find the largest dimension on the largest patch
-	int d = 0;
-	int sd = 0;
-	for (int i = 0; i&lt;Dim; ++i)
-	  {
-	    if ( sd &lt; (*bpatch)[i].size() )
-	      {
-		d = i;
-		sd = (*bpatch)[i].size();
-	      }
-	  }
-	Domain_t hi(*bpatch),lo(*bpatch);
-	int lopoint = hi[d].first();
-	int hipoint = hi[d].last();
-	int mid     = lopoint + ( (hipoint - lopoint)/2);
-
-	if (lopoint&lt;=mid)
-	  lo[d] = Interval&lt;1&gt;(lopoint,mid);
-	else
-	  lo[d] = Interval&lt;1&gt;(lopoint,lopoint);
-	if ( hipoint&gt;=mid+1)
-	  hi[d] = Interval&lt;1&gt;(mid+1,hipoint);
-	else
-	  hi[d] = Interval&lt;1&gt;(hipoint,hipoint);
-	bvec.erase(bpatch++);
-	bvec.insert(bpatch,lo);
-	bvec.insert(bpatch,hi);
-      }
-    // now step through the intervals, using their elements as indexes into
-    // all_m;
-    int strides[Dim];
-    strides[0] = 1;
-    for ( int i=1; i&lt;Dim; ++i)
-      strides[i] = strides[i-1]*blocks_m[i-1].first();
-
-    typename std::list&lt;Domain_t&gt;::iterator start = bvec.begin();
-    typename std::list&lt;Domain_t&gt;::iterator end = bvec.end();
-    int pcontext = 0;
-    for ( ; start != end ; ++start)
-      {
-	int idx[Dim],mi[Dim],mx[Dim];
-	for ( int  i = 0 ; i &lt; Dim ; ++i)
-	  {
-	    idx[i] = mi[i] = (*start)[i].first();
-	    mx[i]  = (*start)[i].last();
-	  }
-
-	while ( idx[Dim-1] &lt;= mx[Dim-1] )
-	  {
-	    int allIdx = 0;
-	    for ( int i = 0 ; i &lt; Dim ; ++i)
-	      allIdx += idx[i]*strides[i];
-	    (*templist[allIdx]).context() = pcontext;
-	    ++idx[0];
-	    for ( int i = 0 ; i &lt; Dim ; ++i)
-	      {
-		if ( idx[i] &gt; mx[i] )
-		  {
-		    if ( i!=(Dim-1) )
-		      {
-			++idx[i+1];
-			idx[i]=mi[i];
-		      }
-		    else
-		      ++idx[i];
-		  }
-		else
-		  break;
-	      }
-	  }
-	++pcontext;
-      }
-    // set the affinity and local ID values
-    this-&gt;setAffinity(templist);
-  }
+  void map(const List_t &amp; templist) const;

   // Memeber Data
   Loc&lt;Dim&gt; blocks_m;

 };
+
+template &lt;int Dim&gt;
+void BisectionMapper&lt;Dim&gt;::map(const List_t &amp; templist) const
+{
+  int ncontexts = Pooma::contexts();
+  int npatch = 1;
+  for (int i =0;i&lt;Dim; ++i)
+    npatch*=blocks_m[i].first();
+
+  std::list&lt;Domain_t&gt; bvec;
+
+  Domain_t allb;
+  for (int i = 0; i&lt;Dim; ++i)
+    allb[i]=Interval&lt;1&gt;(0,blocks_m[i].first()-1);
+  bvec.push_back(allb);
+
+  while ( bvec.size() &lt; ncontexts )
+    {
+      int s = 0;
+      typename std::list&lt;Domain_t&gt;::iterator bstart = bvec.begin();
+      typename std::list&lt;Domain_t&gt;::iterator bend = bvec.end();
+      typename std::list&lt;Domain_t&gt;::iterator bpatch;
+      // find the largest patch.
+      for ( ; bstart != bend ; ++bstart)
+	{
+	  if (s &lt; (*bstart).size() )
+	    {
+	      bpatch = bstart;
+	      s = (*bstart).size();
+	    }
+	}
+      // now find the largest dimension on the largest patch
+      int d = 0;
+      int sd = 0;
+      for (int i = 0; i&lt;Dim; ++i)
+	{
+	  if ( sd &lt; (*bpatch)[i].size() )
+	    {
+	      d = i;
+	      sd = (*bpatch)[i].size();
+	    }
+	}
+      Domain_t hi(*bpatch),lo(*bpatch);
+      int lopoint = hi[d].first();
+      int hipoint = hi[d].last();
+      int mid     = lopoint + ( (hipoint - lopoint)/2);
+
+      if (lopoint&lt;=mid)
+	lo[d] = Interval&lt;1&gt;(lopoint,mid);
+      else
+	lo[d] = Interval&lt;1&gt;(lopoint,lopoint);
+      if ( hipoint&gt;=mid+1)
+	hi[d] = Interval&lt;1&gt;(mid+1,hipoint);
+      else
+	hi[d] = Interval&lt;1&gt;(hipoint,hipoint);
+      bvec.erase(bpatch++);
+      bvec.insert(bpatch,lo);
+      bvec.insert(bpatch,hi);
+    }
+  // now step through the intervals, using their elements as indexes into
+  // all_m;
+  int strides[Dim];
+  strides[0] = 1;
+  for ( int i=1; i&lt;Dim; ++i)
+    strides[i] = strides[i-1]*blocks_m[i-1].first();
+
+  typename std::list&lt;Domain_t&gt;::iterator start = bvec.begin();
+  typename std::list&lt;Domain_t&gt;::iterator end = bvec.end();
+  int pcontext = 0;
+  for ( ; start != end ; ++start)
+    {
+      int idx[Dim],mi[Dim],mx[Dim];
+      for ( int  i = 0 ; i &lt; Dim ; ++i)
+	{
+	  idx[i] = mi[i] = (*start)[i].first();
+	  mx[i]  = (*start)[i].last();
+	}
+
+      while ( idx[Dim-1] &lt;= mx[Dim-1] )
+	{
+	  int allIdx = 0;
+	  for ( int i = 0 ; i &lt; Dim ; ++i)
+	    allIdx += idx[i]*strides[i];
+	  (*templist[allIdx]).context() = pcontext;
+	  ++idx[0];
+	  for ( int i = 0 ; i &lt; Dim ; ++i)
+	    {
+	      if ( idx[i] &gt; mx[i] )
+		{
+		  if ( i!=(Dim-1) )
+		    {
+		      ++idx[i+1];
+		      idx[i]=mi[i];
+		    }
+		  else
+		    ++idx[i];
+		}
+	      else
+		break;
+	    }
+	}
+      ++pcontext;
+    }
+  // set the affinity and local ID values
+  this-&gt;setAffinity(templist);
+}
+

 #endif   // POOMA_BISECTIONMAPPER_H

Index: src/Partition/ContextMapper.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/ContextMapper.h,v
retrieving revision 1.21
diff -u -u -r1.21 ContextMapper.h
--- src/Partition/ContextMapper.h	1 Jul 2002 22:25:53 -0000	1.21
+++ src/Partition/ContextMapper.h	4 Aug 2003 18:43:57 -0000
@@ -83,36 +83,39 @@
   virtual ~ContextMapper(){};

   virtual void map(const List_t &amp; templist) const = 0;
-

- void setAffinity(const List_t &amp; templist) const
-  {
-    int affinityMax = Smarts::concurrency();
-    int idMax = 0;
-
-    typename List_t::const_iterator start = templist.begin();
-    typename List_t::const_iterator end = templist.end();
+  void setAffinity(const List_t &amp; templist) const;

-    for ( ; start != end ; ++start)
-      if((*start)-&gt;context()==Pooma::context())
-	{
-	  (*start)-&gt;localID()=idMax;
-	  ++idMax;
-	}
-
-    start = templist.begin();
-    for ( ; start != end ; ++start)
-      {
-	if((*start)-&gt;context()==Pooma::context())
-	  (*start)-&gt;affinity() = static_cast&lt;int&gt;( affinityMax *
-                                 ( (*start)-&gt;localID() /
-                                 static_cast&lt;double&gt;(idMax) ) );
+};
+
+template&lt;int Dim&gt;
+void ContextMapper&lt;Dim&gt;::setAffinity(const List_t &amp; templist) const
+{
+  int affinityMax = Smarts::concurrency();
+  int idMax = 0;
+
+  typename List_t::const_iterator start = templist.begin();
+  typename List_t::const_iterator end = templist.end();
+
+  for ( ; start != end ; ++start)
+    if((*start)-&gt;context()==Pooma::context())
+      {
+	(*start)-&gt;localID()=idMax;
+	++idMax;
       }

-    return;
-  }
+  start = templist.begin();
+  for ( ; start != end ; ++start)
+    {
+      if((*start)-&gt;context()==Pooma::context())
+	(*start)-&gt;affinity() = static_cast&lt;int&gt;
+	  ( affinityMax * ( (*start)-&gt;localID()
+			    / static_cast&lt;double&gt;(idMax) ) );
+    }
+
+  return;
+}

-};

 template&lt;int Dim&gt;
 class LocalMapper
@@ -133,22 +136,23 @@
   LocalMapper()
   {}

-  void map(const List_t &amp; templist) const
-  {
-    int idMax = templist.size();
-    int naff = Smarts::concurrency();
-    for (int i = 0; i&lt; templist.size(); ++i)
-      {
-	templist[i]-&gt;context() = -1;
-	templist[i]-&gt;localID() = i;
-	templist[i]-&gt;affinity() = static_cast&lt;int&gt;( ( naff * ( i /
-                                  static_cast&lt;double&gt;(idMax) ) ) );
-      }
-  }
-
-
+  void map(const List_t &amp; templist) const;

 };
+
+template&lt;int Dim&gt;
+void LocalMapper&lt;Dim&gt;::map(const List_t &amp; templist) const
+{
+  int idMax = templist.size();
+  int naff = Smarts::concurrency();
+  for (int i = 0; i&lt; templist.size(); ++i)
+    {
+      templist[i]-&gt;context() = -1;
+      templist[i]-&gt;localID() = i;
+      templist[i]-&gt;affinity() = static_cast&lt;int&gt;( ( naff * ( i /
+				static_cast&lt;double&gt;(idMax) ) ) );
+    }
+}


 #endif     // POOMA_CONTEXTMAPPER_H
Index: src/Partition/ContiguousMapper.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/ContiguousMapper.h,v
retrieving revision 1.3
diff -u -u -r1.3 ContiguousMapper.h
--- src/Partition/ContiguousMapper.h	12 Jun 2000 21:57:57 -0000	1.3
+++ src/Partition/ContiguousMapper.h	4 Aug 2003 18:43:57 -0000
@@ -32,98 +32,103 @@
   {
   }

-  void map(const List_t &amp; templist) const
-  {
-    int idx[Dim];
-    for (int i = 0;i&lt;Dim;++i)
-      idx[i]=0;
-    int strides[Dim];
-    strides[Dim-1] = 1;
-    for ( int i=Dim-2; i&gt;=0; --i)
-      strides[i] = strides[i+1]*blocks_m[i+1].last();
-
-    int npatch = 1;
-    for (int i=0; i&lt;Dim; ++i)
-      npatch *= blocks_m[i].first();
-
-    int ncontexts = Pooma::contexts();
-    int npc = npatch/ncontexts;
-
-    int remainder = npatch - (npc*ncontexts);
-
-    int pcontext = 0;
-    int c = 0;
-    int patchdone = 0;
-    int patchleft = npatch;
-
-    int incriment[Dim];
-    for (int i =0 ; i&lt;Dim; ++i) incriment[i] = 1;
-    while ( true  )
-      {
-	int allIdx = 0;
-	for ( int i = 0 ; i &lt; Dim ; ++i)
-	  allIdx += idx[i]*strides[i];
-	(*templist[allIdx]).context() = pcontext;
-
-	++c;
-	++patchdone;
-	--patchleft;
-
-	if(c &gt;= npc )
-	  {
-	    // if we are at the end of a context, and there are still
-	    // remainder patches left over, extend the number of
-	    // patches per context by one, if we are not at an edge
-	    // in the first dimension. However, if we have extra
-	    // patches left over, and are in danger of running out
-	    // of contexts to add patches to, add them now.
-
-	    if (c == npc &amp;&amp; remainder &gt;0 &amp;&amp;
-		((idx[0]-1 &gt;= 0 &amp;&amp; idx[0]+1&lt;=(blocks_m[0].first()-1)) ||
-		 (patchleft - ((npc+1)*(ncontexts-(pcontext+1))) &gt;=0 )) )
-	      --remainder;
-	    else
-	      {
-		c = 0;
-		++pcontext;
-	      }
-	  }
-
-	bool t = true;
-	for ( int i = 0 ; i &lt; Dim ; ++i)
-	  {
-	    t = t &amp;&amp; (
-		      idx[i] == (blocks_m[i]-1) &amp;&amp; incriment[i] == 1
-		      ||
-		      idx[i] == 0 &amp;&amp; incriment[i] == -1);
-	  }
-	if (t) break;
-
-	idx[0] += incriment[0];
-	for ( int i = 0 ; i &lt; Dim ; ++i)
-	  {
-	    if ( idx[i] &gt; blocks_m[i].last()-1)
-	      {
-		idx[i+1]+=incriment[i+1];
-		idx[i]=blocks_m[i].last()-1;
-		incriment[i] *= -1;
-	      }
-	    else if (idx[i]&lt;0)
-	      {
-		idx[i+1]+=incriment[i+1];
-		idx[i]=0;
-		incriment[i] *= -1;
-	      }
-	    else
-	      break;
-	  }
-      }
+  void map(const List_t &amp; templist) const;

-    ContextMapper&lt;Dim&gt;::setAffinity(templist);
-
-  }
   // Member Data
   Loc&lt;Dim&gt; blocks_m;
 };
+
+template&lt;int Dim&gt;
+void ContiguousMapper&lt;Dim&gt;::map(const List_t &amp; templist) const
+{
+  int idx[Dim];
+  for (int i = 0;i&lt;Dim;++i)
+    idx[i]=0;
+  int strides[Dim];
+  strides[Dim-1] = 1;
+  for ( int i=Dim-2; i&gt;=0; --i)
+    strides[i] = strides[i+1]*blocks_m[i+1].last();
+
+  int npatch = 1;
+  for (int i=0; i&lt;Dim; ++i)
+    npatch *= blocks_m[i].first();
+
+  int ncontexts = Pooma::contexts();
+  int npc = npatch/ncontexts;
+
+  int remainder = npatch - (npc*ncontexts);
+
+  int pcontext = 0;
+  int c = 0;
+  int patchdone = 0;
+  int patchleft = npatch;
+
+  int incriment[Dim];
+  for (int i =0 ; i&lt;Dim; ++i) incriment[i] = 1;
+  while ( true  )
+    {
+      int allIdx = 0;
+      for ( int i = 0 ; i &lt; Dim ; ++i)
+	allIdx += idx[i]*strides[i];
+      (*templist[allIdx]).context() = pcontext;
+
+      ++c;
+      ++patchdone;
+      --patchleft;
+
+      if(c &gt;= npc )
+	{
+	  // if we are at the end of a context, and there are still
+	  // remainder patches left over, extend the number of
+	  // patches per context by one, if we are not at an edge
+	  // in the first dimension. However, if we have extra
+	  // patches left over, and are in danger of running out
+	  // of contexts to add patches to, add them now.
+
+	  if (c == npc &amp;&amp; remainder &gt;0 &amp;&amp;
+	      ((idx[0]-1 &gt;= 0 &amp;&amp; idx[0]+1&lt;=(blocks_m[0].first()-1)) ||
+	       (patchleft - ((npc+1)*(ncontexts-(pcontext+1))) &gt;=0 )) )
+	    --remainder;
+	  else
+	    {
+	      c = 0;
+	      ++pcontext;
+	    }
+	}
+
+      bool t = true;
+      for ( int i = 0 ; i &lt; Dim ; ++i)
+	{
+	  t = t &amp;&amp; (
+		    idx[i] == (blocks_m[i]-1) &amp;&amp; incriment[i] == 1
+		    ||
+		    idx[i] == 0 &amp;&amp; incriment[i] == -1);
+	}
+      if (t)
+	break;
+
+      idx[0] += incriment[0];
+      for ( int i = 0 ; i &lt; Dim ; ++i)
+	{
+	  if ( idx[i] &gt; blocks_m[i].last()-1)
+	    {
+	      idx[i+1]+=incriment[i+1];
+	      idx[i]=blocks_m[i].last()-1;
+	      incriment[i] *= -1;
+	    }
+	  else if (idx[i]&lt;0)
+	    {
+	      idx[i+1]+=incriment[i+1];
+	      idx[i]=0;
+	      incriment[i] *= -1;
+	    }
+	  else
+	    break;
+	}
+    }
+
+  ContextMapper&lt;Dim&gt;::setAffinity(templist);
+}
+

 #endif
Index: src/Partition/DistributedMapper.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/DistributedMapper.h,v
retrieving revision 1.8
diff -u -u -r1.8 DistributedMapper.h
--- src/Partition/DistributedMapper.h	3 Dec 2001 19:38:34 -0000	1.8
+++ src/Partition/DistributedMapper.h	4 Aug 2003 18:43:58 -0000
@@ -59,34 +59,7 @@
   }


-  void map(const List_t &amp; templist) const
-  {
-    int ncontexts = Pooma::contexts();
-    int npc = templist.size()/ncontexts;
-    // If there are more contexts than patches, assign one
-    // patch per context for as many patches as there are.
-    if(ncontexts&gt; templist.size())
-      {
-	// we should probably alert the user here!!
-	npc = 1;
-	ncontexts = templist.size();
-      }
-
-    if (Dim == 1)
-      {
-	// work around, since UniformMapper is 1-dim
-	uniformMap(blocks_m,templist,WrappedInt&lt;Dim&gt;());
-      }
-    else if(npc&lt;3)
-      {
-	ContiguousMapper&lt;Dim&gt;(blocks_m).map(templist);
-      }
-    else
-      {
-	BisectionMapper&lt;Dim&gt;(blocks_m).map(templist);
-      }
-    return;
-  }
+  void map(const List_t &amp; templist) const;

   void uniformMap(const Loc&lt;1&gt; &amp;blocks,
 		  const List_t &amp;templist,
@@ -109,6 +82,37 @@
   Loc&lt;Dim&gt; blocks_m;

 };
+
+template&lt;int Dim&gt;
+void DistributedMapper&lt;Dim&gt;::map(const List_t &amp; templist) const
+{
+  int ncontexts = Pooma::contexts();
+  int npc = templist.size()/ncontexts;
+  // If there are more contexts than patches, assign one
+  // patch per context for as many patches as there are.
+  if(ncontexts&gt; templist.size())
+    {
+      // we should probably alert the user here!!
+      npc = 1;
+      ncontexts = templist.size();
+    }
+
+  if (Dim == 1)
+    {
+      // work around, since UniformMapper is 1-dim
+      uniformMap(blocks_m,templist,WrappedInt&lt;Dim&gt;());
+    }
+  else if(npc&lt;3)
+    {
+      ContiguousMapper&lt;Dim&gt;(blocks_m).map(templist);
+    }
+  else
+    {
+      BisectionMapper&lt;Dim&gt;(blocks_m).map(templist);
+    }
+  return;
+}
+

 #endif

Index: src/Partition/GridPartition.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/GridPartition.h,v
retrieving revision 1.29
diff -u -u -r1.29 GridPartition.h
--- src/Partition/GridPartition.h	3 Dec 2001 19:38:34 -0000	1.29
+++ src/Partition/GridPartition.h	4 Aug 2003 18:43:58 -0000
@@ -356,111 +356,7 @@
   template&lt;class D&gt;
   int partition(const D &amp;domain,
 		List_t &amp; all,
-		const ContextMapper&lt;Dim&gt; &amp;cmapper ) const
-  {
-    typedef typename DomainTraits&lt;Domain_t&gt;::Element_t Element_t;
-
-    // Make sure we have the right dimensionality.
-
-    CTAssert(Dim == DomainTraits&lt;D&gt;::dimensions);
-    CTAssert(Dim == DomainTraits&lt;Domain_t&gt;::dimensions);
-
-    Grid&lt;Dim&gt; tgrid = grid();
-
-    // if an empty domain was passed, we make empty patches
-    if (domain.empty())
-      {
-	int np = 1;
-	for (int i=0;i&lt;Dim;++i)
-	  np*=blocks()[i].first();
-
-	int start=0;
-	Domain_t o;
-	Domain_t a;
-	while (start&lt;np)
-	  {
-	    int gid = all.size();
-	    int lid = -1;
-	    Value_t *node = new Value_t(o, a, -1, gid, lid);
-	    all.push_back(node);
-	    ++start;
-	  }
-	cmapper.map(all);
-	return maxSize();
-      }
-
-
-    if (tgrid.empty()&amp;&amp;!domain.empty() )
-      {
-	tgrid = makeRGrid(domain,blocks_m);
-      }
-
-    typename Grid&lt;Dim&gt;::blockIterator start = tgrid.beginBlock();
-    typename Grid&lt;Dim&gt;::blockIterator end = tgrid.endBlock();
-
-    while (start!=end)
-      {
-	Loc&lt;Dim&gt; idx = start.point();
-	Domain_t o = Pooma::NoInit();
-	o = * start;
-	Domain_t a = Pooma::NoInit();
-	a = * start;
-
-	// Calculate the guard cell specification for this domain.
-
-	if (hasInternalGuards()||hasExternalGuards())
-	  {
-	    for (int i=0;i&lt;Dim;i++)
-	      {
-		if (idx[i]==0)
-		  {
-		    if (hasExternalGuards())
-		      {
-			o[i]=Interval&lt;1&gt;(o[i].first()-externalGuards().lower(i),
-					 o[i].last());
-			a[i]=Interval&lt;1&gt;(a[i].first()-externalGuards().lower(i),
-					 a[i].last());
-		      }
-		    if (hasInternalGuards() &amp;&amp; idx[i]!=(blocks()[i].first()-1))
-		      a[i]=Interval&lt;1&gt;(a[i].first(),
-				       a[i].last()+internalGuards().upper(i));
-		  }
-		if (idx[i]==blocks()[i].first()-1)
-		  {
-		    if (hasExternalGuards())
-		      {
-			o[i]=Interval&lt;1&gt;(o[i].first(),
-					 o[i].last()+externalGuards().upper(i));
-			a[i]=Interval&lt;1&gt;(a[i].first(),
-					 a[i].last()+externalGuards().upper(i));
-		      }
-		    if (hasInternalGuards()&amp;&amp;(idx[i]!=0))
-		      a[i]=Interval&lt;1&gt;(a[i].first()-internalGuards().lower(i),
-				       a[i].last());
-		  }
-		if (idx[i]!=0&amp;&amp;
-		   idx[i]!=(blocks()[i].first()-1)&amp;&amp;
-		   hasInternalGuards()) // it's a fully internal patch
-		  a[i]=Interval&lt;1&gt;(o[i].first()-internalGuards().lower(i),
-				   o[i].last()+internalGuards().upper(i));
-
-	      }
-	  }
-
-	// Add the domain to the layout.
-	int gid = all.size();
-	int lid = -1;
-	Value_t *node = new Value_t(o, a, -1, gid, lid);
-	all.push_back(node);
-
-	// Increment our counters and iterators.
-
-	++start;
-      }
-
-    cmapper.map(all);
-    return maxSize();
-  }
+		const ContextMapper&lt;Dim&gt; &amp;cmapper ) const;

   template&lt;class D&gt;
   int partition(const D &amp;domain,
@@ -470,38 +366,7 @@
   }

   template&lt;class Out&gt;
-  void print(Out &amp;o) const
-  {
-    int i;
-    o &lt;&lt; &quot;GridPartition&lt;&quot; &lt;&lt; Dim &lt;&lt; &quot;&gt;:&quot; &lt;&lt; std::endl;
-    o &lt;&lt; &quot;  blocks_m = &quot; &lt;&lt; blocks_m &lt;&lt; std::endl;
-    o &lt;&lt; &quot;  hasInternalGuards_m  hasExternalGuards_m = &quot;;
-    o &lt;&lt; hasInternalGuards_m&lt;&lt; &quot; &quot;&lt;&lt;hasExternalGuards_m&lt;&lt; std::endl;
-    o &lt;&lt; &quot;  internalGuards_m:&quot; &lt;&lt; std::endl;
-    o &lt;&lt; &quot;      upper       &quot;;
-    for (i=0; i &lt; Dim; ++i)
-      o &lt;&lt; internalGuards_m.upper(i) &lt;&lt; &quot; &quot;;
-    o &lt;&lt; std::endl;
-    o &lt;&lt; &quot;      lower       &quot;;
-    for (i=0; i &lt; Dim; ++i)
-      o &lt;&lt; internalGuards_m.lower(i) &lt;&lt; &quot; &quot;;
-    o &lt;&lt; std::endl;
-    o &lt;&lt; &quot;  externalGuards_m:&quot; &lt;&lt; std::endl;
-    o &lt;&lt; &quot;      upper       &quot;;
-    for (i=0; i &lt; Dim; ++i)
-      o &lt;&lt; externalGuards_m.upper(i) &lt;&lt; &quot; &quot;;
-    o &lt;&lt; std::endl;
-    o &lt;&lt; &quot;      lower       &quot;;
-    for (i=0; i &lt; Dim; ++i)
-      o &lt;&lt; externalGuards_m.lower(i) &lt;&lt; &quot; &quot;;
-    o &lt;&lt; std::endl;
-    o &lt;&lt; &quot;  num_m = &quot; &lt;&lt; num_m &lt;&lt; std::endl;
-    o &lt;&lt; &quot;  grid_m = &quot;;
-    if (grid_m.empty() )
-      o &lt;&lt; &quot;(empty)&quot; &lt;&lt; std::endl;
-    else
-      o &lt;&lt; grid_m &lt;&lt; std::endl;
-  }
+  void print(Out &amp;o) const;

 private:

@@ -534,6 +399,151 @@
   Grid&lt;Dim&gt; grid_m;
 };

+
+template&lt;int Dim&gt;
+template&lt;class D&gt;
+int GridPartition&lt;Dim&gt;::partition(const D &amp;domain,
+				  List_t &amp; all,
+				  const ContextMapper&lt;Dim&gt; &amp;cmapper ) const
+{
+  typedef typename DomainTraits&lt;Domain_t&gt;::Element_t Element_t;
+
+  // Make sure we have the right dimensionality.
+
+  CTAssert(Dim == DomainTraits&lt;D&gt;::dimensions);
+  CTAssert(Dim == DomainTraits&lt;Domain_t&gt;::dimensions);
+
+  Grid&lt;Dim&gt; tgrid = grid();
+
+  // if an empty domain was passed, we make empty patches
+  if (domain.empty())
+    {
+      int np = 1;
+      for (int i=0;i&lt;Dim;++i)
+	np*=blocks()[i].first();
+
+      int start=0;
+      Domain_t o;
+      Domain_t a;
+      while (start&lt;np)
+	{
+	  int gid = all.size();
+	  int lid = -1;
+	  Value_t *node = new Value_t(o, a, -1, gid, lid);
+	  all.push_back(node);
+	  ++start;
+	}
+      cmapper.map(all);
+      return maxSize();
+    }
+
+
+  if (tgrid.empty()&amp;&amp;!domain.empty() )
+    {
+      tgrid = makeRGrid(domain,blocks_m);
+    }
+
+  typename Grid&lt;Dim&gt;::blockIterator start = tgrid.beginBlock();
+  typename Grid&lt;Dim&gt;::blockIterator end = tgrid.endBlock();
+
+  while (start!=end)
+    {
+      Loc&lt;Dim&gt; idx = start.point();
+      Domain_t o = Pooma::NoInit();
+      o = * start;
+      Domain_t a = Pooma::NoInit();
+      a = * start;
+
+      // Calculate the guard cell specification for this domain.
+
+      if (hasInternalGuards()||hasExternalGuards())
+	{
+	  for (int i=0;i&lt;Dim;i++)
+	    {
+	      if (idx[i]==0)
+		{
+		  if (hasExternalGuards())
+		    {
+		      o[i]=Interval&lt;1&gt;(o[i].first()-externalGuards().lower(i),
+				       o[i].last());
+		      a[i]=Interval&lt;1&gt;(a[i].first()-externalGuards().lower(i),
+				       a[i].last());
+		    }
+		  if (hasInternalGuards() &amp;&amp; idx[i]!=(blocks()[i].first()-1))
+		    a[i]=Interval&lt;1&gt;(a[i].first(),
+				     a[i].last()+internalGuards().upper(i));
+		}
+	      if (idx[i]==blocks()[i].first()-1)
+		{
+		  if (hasExternalGuards())
+		    {
+		      o[i]=Interval&lt;1&gt;(o[i].first(),
+				       o[i].last()+externalGuards().upper(i));
+		      a[i]=Interval&lt;1&gt;(a[i].first(),
+				       a[i].last()+externalGuards().upper(i));
+		    }
+		  if (hasInternalGuards()&amp;&amp;(idx[i]!=0))
+		    a[i]=Interval&lt;1&gt;(a[i].first()-internalGuards().lower(i),
+				     a[i].last());
+		}
+	      if (idx[i]!=0&amp;&amp;
+		  idx[i]!=(blocks()[i].first()-1)&amp;&amp;
+		  hasInternalGuards()) // it's a fully internal patch
+		a[i]=Interval&lt;1&gt;(o[i].first()-internalGuards().lower(i),
+				 o[i].last()+internalGuards().upper(i));
+
+	    }
+	}
+
+      // Add the domain to the layout.
+      int gid = all.size();
+      int lid = -1;
+      Value_t *node = new Value_t(o, a, -1, gid, lid);
+      all.push_back(node);
+
+      // Increment our counters and iterators.
+
+      ++start;
+    }
+
+  cmapper.map(all);
+  return maxSize();
+}
+
+template&lt;int Dim&gt;
+template&lt;class Out&gt;
+void GridPartition&lt;Dim&gt;::print(Out &amp;o) const
+{
+  int i;
+  o &lt;&lt; &quot;GridPartition&lt;&quot; &lt;&lt; Dim &lt;&lt; &quot;&gt;:&quot; &lt;&lt; std::endl;
+  o &lt;&lt; &quot;  blocks_m = &quot; &lt;&lt; blocks_m &lt;&lt; std::endl;
+  o &lt;&lt; &quot;  hasInternalGuards_m  hasExternalGuards_m = &quot;;
+  o &lt;&lt; hasInternalGuards_m&lt;&lt; &quot; &quot;&lt;&lt;hasExternalGuards_m&lt;&lt; std::endl;
+  o &lt;&lt; &quot;  internalGuards_m:&quot; &lt;&lt; std::endl;
+  o &lt;&lt; &quot;      upper       &quot;;
+  for (i=0; i &lt; Dim; ++i)
+    o &lt;&lt; internalGuards_m.upper(i) &lt;&lt; &quot; &quot;;
+  o &lt;&lt; std::endl;
+  o &lt;&lt; &quot;      lower       &quot;;
+  for (i=0; i &lt; Dim; ++i)
+    o &lt;&lt; internalGuards_m.lower(i) &lt;&lt; &quot; &quot;;
+  o &lt;&lt; std::endl;
+  o &lt;&lt; &quot;  externalGuards_m:&quot; &lt;&lt; std::endl;
+  o &lt;&lt; &quot;      upper       &quot;;
+  for (i=0; i &lt; Dim; ++i)
+    o &lt;&lt; externalGuards_m.upper(i) &lt;&lt; &quot; &quot;;
+  o &lt;&lt; std::endl;
+  o &lt;&lt; &quot;      lower       &quot;;
+  for (i=0; i &lt; Dim; ++i)
+    o &lt;&lt; externalGuards_m.lower(i) &lt;&lt; &quot; &quot;;
+  o &lt;&lt; std::endl;
+  o &lt;&lt; &quot;  num_m = &quot; &lt;&lt; num_m &lt;&lt; std::endl;
+  o &lt;&lt; &quot;  grid_m = &quot;;
+  if (grid_m.empty() )
+    o &lt;&lt; &quot;(empty)&quot; &lt;&lt; std::endl;
+  else
+    o &lt;&lt; grid_m &lt;&lt; std::endl;
+}


 //-----------------------------------------------------------------------------
Index: src/Partition/SpatialPartition.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/SpatialPartition.h,v
retrieving revision 1.13
diff -u -u -r1.13 SpatialPartition.h
--- src/Partition/SpatialPartition.h	9 Jun 2000 00:35:16 -0000	1.13
+++ src/Partition/SpatialPartition.h	4 Aug 2003 18:43:59 -0000
@@ -275,60 +275,10 @@
   // Partition methods
   //============================================================

-
-
   template&lt;class D,class Dom&gt;
   int partition(const D &amp;domain,
 		std::vector&lt; Node&lt;Dom&gt; *&gt; &amp; all,
-		const ContextMapper&lt;1&gt; &amp; cmapper ) const
-    {
-
-      // Make sure we have the right dimensionality between the provided
-      // domain and the layout's domain.  We do NOT need to have the
-      // dimensionality match between the provided layout and reference
-      // layout, however.
-
-      CTAssert(DomainTraits&lt;D&gt;::dimensions ==
-	       DomainTraits&lt;Dom&gt;::dimensions);
-
-      // For now, this will only work with a 1D provided layout.
-
-      CTAssert(DomainTraits&lt;D&gt;::dimensions == 1);
-
-      // The provided domain must actually be empty for this to work,
-      // since we generate empty domains.
-
-      PAssert(domain.empty());
-
-      // Loop through the patches in the reference domain now.  For each one,
-      // just add in an empty domain, assigned to the same context
-      // as the current node that we're iterating over.
-
-      typename RefLayout_t::const_iterator refpatch,
-                                           endref = reference().endGlobal();
-
-      for (refpatch=reference().beginGlobal(); refpatch != endref; ++refpatch)
-	{
-	  Node&lt;Dom&gt; *node = new Node&lt;Dom&gt;(Dom(),
-					  Dom(),
-					  refpatch-&gt;context(),
-					  refpatch-&gt;globalID(),
-					  refpatch-&gt;localID());
-	  all.push_back(node);
-	}
-
-      // This call to the mapper for the case of DefaultSPMapper
-      // is a no-op, and could be commented out. The above loop
-      // does both the partitioning and the mapping. The structure
-      // of the DefaultSPmapper is maintained for this special case
-      // even though it's redundant.
-
-      cmapper.map(all);
-
-      // Return the number of domains we added in.
-
-      return maxSize();
-    }
+		const ContextMapper&lt;1&gt; &amp; cmapper ) const;

   template&lt;class D,class Dom&gt;
   int partition(const D &amp; domain,
@@ -342,12 +292,7 @@
   //============================================================

   template&lt;class Out&gt;
-  void print(Out &amp;o) const
-    {
-      o &lt;&lt; &quot;SpatialPartitioner:\n&quot;;
-      o &lt;&lt; &quot;  reference layout = &quot; &lt;&lt; reference() &lt;&lt; &quot;\n&quot;;
-      o &lt;&lt; &quot;  maximum patches = &quot; &lt;&lt; maxSize() &lt;&lt; &quot;\n&quot;;
-    }
+  void print(Out &amp;o) const;

 private:
   // The reference layout
@@ -358,6 +303,68 @@

   SpatialPartition();
 };
+
+template&lt;class ReferenceLayout&gt;
+template&lt;class D,class Dom&gt;
+int SpatialPartition&lt;ReferenceLayout&gt;::partition(const D &amp;domain,
+						 std::vector&lt; Node&lt;Dom&gt; *&gt; &amp; all,
+						 const ContextMapper&lt;1&gt; &amp; cmapper) const
+{
+  // Make sure we have the right dimensionality between the provided
+  // domain and the layout's domain.  We do NOT need to have the
+  // dimensionality match between the provided layout and reference
+  // layout, however.
+
+  CTAssert(DomainTraits&lt;D&gt;::dimensions ==
+	   DomainTraits&lt;Dom&gt;::dimensions);
+
+  // For now, this will only work with a 1D provided layout.
+
+  CTAssert(DomainTraits&lt;D&gt;::dimensions == 1);
+
+  // The provided domain must actually be empty for this to work,
+  // since we generate empty domains.
+
+  PAssert(domain.empty());
+
+  // Loop through the patches in the reference domain now.  For each one,
+  // just add in an empty domain, assigned to the same context
+  // as the current node that we're iterating over.
+
+  typename RefLayout_t::const_iterator refpatch,
+    endref = reference().endGlobal();
+
+  for (refpatch=reference().beginGlobal(); refpatch != endref; ++refpatch)
+    {
+      Node&lt;Dom&gt; *node = new Node&lt;Dom&gt;(Dom(),
+				      Dom(),
+				      refpatch-&gt;context(),
+				      refpatch-&gt;globalID(),
+				      refpatch-&gt;localID());
+      all.push_back(node);
+    }
+
+  // This call to the mapper for the case of DefaultSPMapper
+  // is a no-op, and could be commented out. The above loop
+  // does both the partitioning and the mapping. The structure
+  // of the DefaultSPmapper is maintained for this special case
+  // even though it's redundant.
+
+  cmapper.map(all);
+
+  // Return the number of domains we added in.
+
+  return maxSize();
+}
+
+template&lt;class ReferenceLayout&gt;
+template&lt;class Out&gt;
+void SpatialPartition&lt;ReferenceLayout&gt;::print(Out &amp;o) const
+{
+  o &lt;&lt; &quot;SpatialPartitioner:\n&quot;;
+  o &lt;&lt; &quot;  reference layout = &quot; &lt;&lt; reference() &lt;&lt; &quot;\n&quot;;
+  o &lt;&lt; &quot;  maximum patches = &quot; &lt;&lt; maxSize() &lt;&lt; &quot;\n&quot;;
+}


 //-----------------------------------------------------------------------------
Index: src/Partition/TilePartition.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/TilePartition.h,v
retrieving revision 1.12
diff -u -u -r1.12 TilePartition.h
--- src/Partition/TilePartition.h	23 Jan 2003 20:04:39 -0000	1.12
+++ src/Partition/TilePartition.h	4 Aug 2003 18:44:01 -0000
@@ -83,55 +83,58 @@
   {
   }

-  void map(const List_t &amp; templist) const
-  {
-    int ncontexts = Pooma::contexts();
-    int npc = templist.size()/ncontexts;
-    if (templist.size()%ncontexts!=0) ++npc;
-
-    typename List_t::const_iterator start = templist.begin();
-    typename List_t::const_iterator end = templist.end();
-    int c = 0;
-    int p = 0;
-    for ( ; start!=end ; ++start)
-      {
-	(*start)-&gt;context() = p;
-	if(p == Pooma::context())
-	  (*start)-&gt;localID() = c;
-
-	++c;
-	if (c &gt; npc)
-	  {
-	    ++p;
-	    c = 0;
-	  }
-      }
-
-    int affinityMax = Smarts::concurrency();
-    int idMax = 0;
-
-    start = templist.begin();
-    for ( ; start != end ; ++start)
-      if((*start)-&gt;context()==Pooma::context())
-	{
-	  (*start)-&gt;localID()=idMax;
-	  ++idMax;
-	}
-     start = templist.begin();
-     for ( ; start != end ; ++start)
-       {
-	 if((*start)-&gt;context()==Pooma::context())
-	   (*start)-&gt;affinity() = static_cast&lt;int&gt;( affinityMax *
-				  ( (*start)-&gt;localID() /
-				  static_cast&lt;double&gt;(idMax) ) );
-       }
-  }
+  void map(const List_t &amp; templist) const;

   // member data
 private:

 };

+template&lt;int Dim&gt;
+void DefaultTPmapper&lt;Dim&gt;::map(const List_t &amp; templist) const
+{
+  int ncontexts = Pooma::contexts();
+  int npc = templist.size()/ncontexts;
+  if (templist.size()%ncontexts!=0) ++npc;
+
+  typename List_t::const_iterator start = templist.begin();
+  typename List_t::const_iterator end = templist.end();
+  int c = 0;
+  int p = 0;
+  for ( ; start!=end ; ++start)
+    {
+      (*start)-&gt;context() = p;
+      if(p == Pooma::context())
+	(*start)-&gt;localID() = c;
+
+      ++c;
+      if (c &gt; npc)
+	{
+	  ++p;
+	  c = 0;
+	}
+    }
+
+  int affinityMax = Smarts::concurrency();
+  int idMax = 0;
+
+  start = templist.begin();
+  for ( ; start != end ; ++start)
+    if((*start)-&gt;context()==Pooma::context())
+      {
+	(*start)-&gt;localID()=idMax;
+	++idMax;
+      }
+  start = templist.begin();
+  for ( ; start != end ; ++start)
+    {
+      if((*start)-&gt;context()==Pooma::context())
+	(*start)-&gt;affinity() = static_cast&lt;int&gt;( affinityMax *
+						 ( (*start)-&gt;localID() /
+			       static_cast&lt;double&gt;(idMax) ) );
+    }
+}
+


 //-----------------------------------------------------------------------------
@@ -319,78 +322,7 @@
   //============================================================

   template&lt;class D&gt;
-  int partition(const D &amp;bbox,List_t &amp;all,const ContextMapper&lt;Dim&gt; &amp;cmapper) const
-  {
-    typedef typename DomainTraits&lt;Domain_t&gt;::Element_t Element_t;
-
-    // Make sure we have the right dimensionality.
-
-    CTAssert(Dim == DomainTraits&lt;Domain_t&gt;::dimensions);
-
-    typename PatchList_t::const_iterator start = tile_m.begin();
-    typename PatchList_t::const_iterator end = tile_m.end();
-
-    while (start!=end)
-      {
-	Domain_t o = Pooma::NoInit();
-	o = * start;
-	Domain_t oo = o;
-	Domain_t a = Pooma::NoInit();
-	a = * start;
-
-	if (hasInternalGuards()||hasExternalGuards())
-	  {
-	    for (int i=0;i&lt;Dim;i++)
-	      {
-		if (oo[i].first() == bbox[i].first())
-		  {
-		    if (hasExternalGuards())
-		      {
-			o[i]=Interval&lt;1&gt;(o[i].first()-externalGuards().lower(i),
-					 o[i].last());
-			a[i]=Interval&lt;1&gt;(a[i].first()-externalGuards().lower(i),
-					 a[i].last());
-		      }
-		    if (hasInternalGuards() &amp;&amp; oo[i].last() != bbox[i].last() )
-		      a[i]=Interval&lt;1&gt;(a[i].first(),
-				       a[i].last()+internalGuards().upper(i));
-		  }
-		if (oo[i].last()== bbox[i].last())
-		  {
-		    if (hasExternalGuards())
-		      {
-			o[i]=Interval&lt;1&gt;(o[i].first(),
-					 o[i].last()+externalGuards().upper(i));
-			a[i]=Interval&lt;1&gt;(a[i].first(),
-					 a[i].last()+externalGuards().upper(i));
-		      }
-		    if (hasInternalGuards()&amp;&amp;(oo[i].first() != bbox[i].first()))
-		      a[i]=Interval&lt;1&gt;(a[i].first()-internalGuards().lower(i),
-				       a[i].last());
-		  }
-		if (oo[i].first()!=bbox[i].first() &amp;&amp;
-		    oo[i].last() != bbox[i].last() &amp;&amp;
-		   hasInternalGuards()) // it's a fully internal patch
-		  a[i]=Interval&lt;1&gt;(o[i].first()-internalGuards().lower(i),
-				   o[i].last()+internalGuards().upper(i));
-
-	      }
-	  }
-
-	// Add the domain to the layout.
-
-	Value_t * node = new Value_t(o,a,-1,all.size(),-1);
-	all.push_back(node);
-
-	// Increment our counters and iterators.
-
-	++start;
-      }
-
-    cmapper.map(all);
-
-    return all.size();
-  }
+  int partition(const D &amp;bbox,List_t &amp;all,const ContextMapper&lt;Dim&gt; &amp;cmapper) const;

   template&lt;class D&gt;
   int partition(const D &amp;bbox,List_t &amp;all) const
@@ -399,32 +331,7 @@
   }

   template&lt;class Out&gt;
-  void print(Out &amp;o) const
-  {
-    int i;
-    o &lt;&lt; &quot;TilePartition&lt;&quot; &lt;&lt; Dim &lt;&lt; &quot;&gt;:&quot; &lt;&lt; std::endl;
-    o &lt;&lt; &quot;  hasInternalGuards_m  hasExternalGuards_m = &quot;;
-    o &lt;&lt; hasInternalGuards_m&lt;&lt; &quot; &quot;&lt;&lt;hasExternalGuards_m&lt;&lt; std::endl;
-    o &lt;&lt; &quot;  internalGuards_m:&quot; &lt;&lt; std::endl;
-    o &lt;&lt; &quot;      upper       &quot;;
-    for (i=0; i &lt; Dim; ++i)
-      o &lt;&lt; internalGuards_m.upper(i) &lt;&lt; &quot; &quot;;
-    o &lt;&lt; std::endl;
-    o &lt;&lt; &quot;      lower       &quot;;
-    for (i=0; i &lt; Dim; ++i)
-      o &lt;&lt; internalGuards_m.lower(i) &lt;&lt; &quot; &quot;;
-    o &lt;&lt; std::endl;
-    o &lt;&lt; &quot;  externalGuards_m:&quot; &lt;&lt; std::endl;
-    o &lt;&lt; &quot;      upper       &quot;;
-    for (i=0; i &lt; Dim; ++i)
-      o &lt;&lt; externalGuards_m.upper(i) &lt;&lt; &quot; &quot;;
-    o &lt;&lt; std::endl;
-    o &lt;&lt; &quot;      lower       &quot;;
-    for (i=0; i &lt; Dim; ++i)
-      o &lt;&lt; externalGuards_m.lower(i) &lt;&lt; &quot; &quot;;
-    o &lt;&lt; std::endl;
-    o &lt;&lt; &quot;  num_m = &quot; &lt;&lt; num_m &lt;&lt; std::endl;
-  }
+  void print(Out &amp;o) const;

 private:

@@ -454,6 +361,110 @@

 };

+template&lt;int Dim&gt;
+template&lt;class D&gt;
+int TilePartition&lt;Dim&gt;::partition(const D &amp;bbox, List_t &amp;all,
+				  const ContextMapper&lt;Dim&gt; &amp;cmapper) const
+{
+  typedef typename DomainTraits&lt;Domain_t&gt;::Element_t Element_t;
+
+  // Make sure we have the right dimensionality.
+
+  CTAssert(Dim == DomainTraits&lt;Domain_t&gt;::dimensions);
+
+  typename PatchList_t::const_iterator start = tile_m.begin();
+  typename PatchList_t::const_iterator end = tile_m.end();
+
+  while (start!=end)
+    {
+      Domain_t o = Pooma::NoInit();
+      o = * start;
+      Domain_t oo = o;
+      Domain_t a = Pooma::NoInit();
+      a = * start;
+
+      if (hasInternalGuards()||hasExternalGuards())
+	{
+	  for (int i=0;i&lt;Dim;i++)
+	    {
+	      if (oo[i].first() == bbox[i].first())
+		{
+		  if (hasExternalGuards())
+		    {
+		      o[i]=Interval&lt;1&gt;(o[i].first()-externalGuards().lower(i),
+				       o[i].last());
+		      a[i]=Interval&lt;1&gt;(a[i].first()-externalGuards().lower(i),
+				       a[i].last());
+		    }
+		  if (hasInternalGuards() &amp;&amp; oo[i].last() != bbox[i].last() )
+		    a[i]=Interval&lt;1&gt;(a[i].first(),
+				     a[i].last()+internalGuards().upper(i));
+		}
+	      if (oo[i].last()== bbox[i].last())
+		{
+		  if (hasExternalGuards())
+		    {
+		      o[i]=Interval&lt;1&gt;(o[i].first(),
+				       o[i].last()+externalGuards().upper(i));
+		      a[i]=Interval&lt;1&gt;(a[i].first(),
+				       a[i].last()+externalGuards().upper(i));
+		    }
+		  if (hasInternalGuards()&amp;&amp;(oo[i].first() != bbox[i].first()))
+		    a[i]=Interval&lt;1&gt;(a[i].first()-internalGuards().lower(i),
+				     a[i].last());
+		}
+	      if (oo[i].first()!=bbox[i].first() &amp;&amp;
+		  oo[i].last() != bbox[i].last() &amp;&amp;
+		  hasInternalGuards()) // it's a fully internal patch
+		a[i]=Interval&lt;1&gt;(o[i].first()-internalGuards().lower(i),
+				 o[i].last()+internalGuards().upper(i));
+
+	    }
+	}
+
+      // Add the domain to the layout.
+
+      Value_t * node = new Value_t(o,a,-1,all.size(),-1);
+      all.push_back(node);
+
+      // Increment our counters and iterators.
+
+      ++start;
+    }
+
+  cmapper.map(all);
+
+  return all.size();
+}
+
+template&lt;int Dim&gt;
+template&lt;class Out&gt;
+void TilePartition&lt;Dim&gt;::print(Out &amp;o) const
+{
+  int i;
+  o &lt;&lt; &quot;TilePartition&lt;&quot; &lt;&lt; Dim &lt;&lt; &quot;&gt;:&quot; &lt;&lt; std::endl;
+  o &lt;&lt; &quot;  hasInternalGuards_m  hasExternalGuards_m = &quot;;
+  o &lt;&lt; hasInternalGuards_m&lt;&lt; &quot; &quot;&lt;&lt;hasExternalGuards_m&lt;&lt; std::endl;
+  o &lt;&lt; &quot;  internalGuards_m:&quot; &lt;&lt; std::endl;
+  o &lt;&lt; &quot;      upper       &quot;;
+  for (i=0; i &lt; Dim; ++i)
+    o &lt;&lt; internalGuards_m.upper(i) &lt;&lt; &quot; &quot;;
+  o &lt;&lt; std::endl;
+  o &lt;&lt; &quot;      lower       &quot;;
+  for (i=0; i &lt; Dim; ++i)
+    o &lt;&lt; internalGuards_m.lower(i) &lt;&lt; &quot; &quot;;
+  o &lt;&lt; std::endl;
+  o &lt;&lt; &quot;  externalGuards_m:&quot; &lt;&lt; std::endl;
+  o &lt;&lt; &quot;      upper       &quot;;
+  for (i=0; i &lt; Dim; ++i)
+    o &lt;&lt; externalGuards_m.upper(i) &lt;&lt; &quot; &quot;;
+  o &lt;&lt; std::endl;
+  o &lt;&lt; &quot;      lower       &quot;;
+  for (i=0; i &lt; Dim; ++i)
+    o &lt;&lt; externalGuards_m.lower(i) &lt;&lt; &quot; &quot;;
+  o &lt;&lt; std::endl;
+  o &lt;&lt; &quot;  num_m = &quot; &lt;&lt; num_m &lt;&lt; std::endl;
+}


 //-----------------------------------------------------------------------------
Index: src/Partition/UniformGridPartition.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/UniformGridPartition.h,v
retrieving revision 1.28
diff -u -u -r1.28 UniformGridPartition.h
--- src/Partition/UniformGridPartition.h	11 Dec 2001 20:43:30 -0000	1.28
+++ src/Partition/UniformGridPartition.h	4 Aug 2003 18:44:01 -0000
@@ -286,140 +286,10 @@
   // 'layoutData.addDomainList(List_t &amp;templist)'.  Return the
   // total number of subdomains added.

-
   template&lt;class D&gt;
   int partition(const D &amp;domain,
 		List_t &amp; all,
-		const ContextMapper&lt;Dim&gt;&amp; cmapper) const
-  {
-
-    // The type info for domain we should be creating for the layout.
-
-    typedef typename DomainTraits&lt;Domain_t&gt;::Element_t Element_t;
-
-    // Make sure we have the right dimensionality.
-
-    CTAssert(Dim == DomainTraits&lt;D&gt;::dimensions);
-    CTAssert(Dim == DomainTraits&lt;Domain_t&gt;::dimensions);
-
-    // This will only work with UnitStride domains
-
-    CTAssert(DomainTraits&lt;D&gt;::unitStride == 1);
-    CTAssert(DomainTraits&lt;Domain_t&gt;::unitStride == 1);
-
-    // make sure the list is empty
-
-    PAssert(all.size() == 0);
-
-    // Cache the origin of the domain and make sure the domain is
-    // properly sized. Also, build a domain corresponding to the
-    // number of blocks in each direction for iterating over below.
-
-    Element_t origin[Dim];
-    Element_t sizes[Dim];
-    Interval&lt;Dim&gt; bdomain = Pooma::NoInit(); // dummy initializer
-
-    int i;
-
-    for (i = 0; i &lt; Dim; ++i)
-      {
-	if (!domain.empty())
-	  {
-	    int gcwidth =
-	      (internalGuards_m.lower(i) &gt; internalGuards_m.upper(i)) ?
-	      internalGuards_m.lower(i) : internalGuards_m.upper(i);
-
-	    PInsist((domain[i].length() % blocks()[i].first()) == 0,
-		    &quot;All the blocks in a grid must be the same size.&quot;);
-
-	    origin[i]  = domain[i].first();
-	    sizes[i]   = domain[i].length() / blocks()[i].first();
-
-	    PInsist(sizes[i] &gt;= gcwidth,
-		    &quot;Block sizes too small for guard layer specification.&quot;);
-	  }
-	bdomain[i] = Interval&lt;1&gt;(blocks()[i].first());
-      }
-
-    // Loop over all the blocks, creating new domains.
-
-    typename Interval&lt;Dim&gt;::const_iterator it = bdomain.begin();
-    while (it != bdomain.end())
-      {
-	// Start with an initially empty domain and empty guard cells.
-
-	Domain_t owned;
-	GuardLayers&lt;Dim&gt; iguards(0);
-	GuardLayers&lt;Dim&gt; eguards(0);
-
-	// Calculate the subdomain, if the global domain is not empty.
-	// If it is, we just use the empty domain.
-
-	if (!domain.empty())
-	  {
-	    Loc&lt;Dim&gt; pos = *it;
-	    for (i = 0; i &lt; Dim; ++i)
-	      {
-		int position = pos[i].first();
-		Element_t a = origin[i] + sizes[i]*position;
-		Element_t b = a + sizes[i] - 1;
-		typedef typename
-		  DomainTraits&lt;Domain_t&gt;::OneDomain_t OneDomain_t;
-		owned[i] = OneDomain_t(a, b);
-	      }
-
-	    // Calculate the internal and external guard layer specifications
-	    // for this domain.
-
-	    if (hasGuards_m)
-	      {
-		iguards = internalGuards_m;
-
-		// Check if we're at an edge, and, if so, use the
-		// external specification for that edge.
-
-		for (int d = 0; d &lt; Dim; ++d)
-		  {
-		    int position = pos[d].first();
-		    if ( position == bdomain[d].first() )
-		      {
-			eguards.lower(d) = externalGuards_m.lower(d);
-			iguards.lower(d) = 0;
-		      }
-		    if ( position == bdomain[d].last() )
-		      {
-			eguards.upper(d) = externalGuards_m.upper(d);
-			iguards.upper(d) = 0;
-		      }
-		  }
-	      }
-	  }
-	typename Value_t::ID_t gid = all.size();
-	typename Value_t::ID_t lid = (-1);
-
-	// Create a new Node object to store the subdomain data.
-
-	GuardLayers&lt;Dim&gt;::addGuardLayers(owned,eguards);
-
-	Domain_t allocated = owned;
-
-	GuardLayers&lt;Dim&gt;::addGuardLayers(allocated,iguards);
-
-	Value_t *node = new Value_t(owned, allocated, -1, gid, lid);
-
-	all.push_back(node);
-
-	// Increment our counters and iterators.
-
-	++it;
-      }
-
-    cmapper.map(all);
-
-    // At the end, return # of domains created.
-
-    return num_m;
-  }
+		const ContextMapper&lt;Dim&gt;&amp; cmapper) const;

   template&lt;class D&gt;
   int partition(const D &amp;domain, List_t &amp; list) const
@@ -470,6 +340,141 @@
 //============================================================
 // UniformGridPartition inline method definitions
 //============================================================
+
+template&lt;int Dim&gt;
+template&lt;class D&gt;
+int UniformGridPartition&lt;Dim&gt;::partition(const D &amp;domain,
+					 List_t &amp; all,
+					 const ContextMapper&lt;Dim&gt;&amp; cmapper) const
+{
+  // The type info for domain we should be creating for the layout.
+
+  typedef typename DomainTraits&lt;Domain_t&gt;::Element_t Element_t;
+
+  // Make sure we have the right dimensionality.
+
+  CTAssert(Dim == DomainTraits&lt;D&gt;::dimensions);
+  CTAssert(Dim == DomainTraits&lt;Domain_t&gt;::dimensions);
+
+  // This will only work with UnitStride domains
+
+  CTAssert(DomainTraits&lt;D&gt;::unitStride == 1);
+  CTAssert(DomainTraits&lt;Domain_t&gt;::unitStride == 1);
+
+  // make sure the list is empty
+
+  PAssert(all.size() == 0);
+
+  // Cache the origin of the domain and make sure the domain is
+  // properly sized. Also, build a domain corresponding to the
+  // number of blocks in each direction for iterating over below.
+
+  Element_t origin[Dim];
+  Element_t sizes[Dim];
+  Interval&lt;Dim&gt; bdomain = Pooma::NoInit(); // dummy initializer
+
+  int i;
+
+  for (i = 0; i &lt; Dim; ++i)
+    {
+      if (!domain.empty())
+	{
+	  int gcwidth =
+	    (internalGuards_m.lower(i) &gt; internalGuards_m.upper(i)) ?
+	    internalGuards_m.lower(i) : internalGuards_m.upper(i);
+
+	  PInsist((domain[i].length() % blocks()[i].first()) == 0,
+		  &quot;All the blocks in a grid must be the same size.&quot;);
+
+	  origin[i]  = domain[i].first();
+	  sizes[i]   = domain[i].length() / blocks()[i].first();
+
+	  PInsist(sizes[i] &gt;= gcwidth,
+		  &quot;Block sizes too small for guard layer specification.&quot;);
+	}
+      bdomain[i] = Interval&lt;1&gt;(blocks()[i].first());
+    }
+
+  // Loop over all the blocks, creating new domains.
+
+  typename Interval&lt;Dim&gt;::const_iterator it = bdomain.begin();
+  while (it != bdomain.end())
+    {
+      // Start with an initially empty domain and empty guard cells.
+
+      Domain_t owned;
+      GuardLayers&lt;Dim&gt; iguards(0);
+      GuardLayers&lt;Dim&gt; eguards(0);
+
+      // Calculate the subdomain, if the global domain is not empty.
+      // If it is, we just use the empty domain.
+
+      if (!domain.empty())
+	{
+	  Loc&lt;Dim&gt; pos = *it;
+	  for (i = 0; i &lt; Dim; ++i)
+	    {
+	      int position = pos[i].first();
+	      Element_t a = origin[i] + sizes[i]*position;
+	      Element_t b = a + sizes[i] - 1;
+	      typedef typename
+		DomainTraits&lt;Domain_t&gt;::OneDomain_t OneDomain_t;
+	      owned[i] = OneDomain_t(a, b);
+	    }
+
+	  // Calculate the internal and external guard layer specifications
+	  // for this domain.
+
+	  if (hasGuards_m)
+	    {
+	      iguards = internalGuards_m;
+
+	      // Check if we're at an edge, and, if so, use the
+	      // external specification for that edge.
+
+	      for (int d = 0; d &lt; Dim; ++d)
+		{
+		  int position = pos[d].first();
+		  if ( position == bdomain[d].first() )
+		    {
+		      eguards.lower(d) = externalGuards_m.lower(d);
+		      iguards.lower(d) = 0;
+		    }
+		  if ( position == bdomain[d].last() )
+		    {
+		      eguards.upper(d) = externalGuards_m.upper(d);
+		      iguards.upper(d) = 0;
+		    }
+		}
+	    }
+	}
+      typename Value_t::ID_t gid = all.size();
+      typename Value_t::ID_t lid = (-1);
+
+      // Create a new Node object to store the subdomain data.
+
+      GuardLayers&lt;Dim&gt;::addGuardLayers(owned,eguards);
+
+      Domain_t allocated = owned;
+
+      GuardLayers&lt;Dim&gt;::addGuardLayers(allocated,iguards);
+
+      Value_t *node = new Value_t(owned, allocated, -1, gid, lid);
+
+      all.push_back(node);
+
+      // Increment our counters and iterators.
+
+      ++it;
+    }
+
+  cmapper.map(all);
+
+  // At the end, return # of domains created.
+
+  return num_m;
+}
+

 //-----------------------------------------------------------------------------
 //




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="001310.html">[PATCH] Kill use of POOMA_NO_RESTRICT
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1309">[ date ]</a>
              <a href="thread.html#1309">[ thread ]</a>
              <a href="subject.html#1309">[ subject ]</a>
              <a href="author.html#1309">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
