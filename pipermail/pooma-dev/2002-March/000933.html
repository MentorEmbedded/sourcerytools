<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Manual Patch: Fix Typos and Some Indexing
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%20Patch%3A%20Fix%20Typos%20and%20Some%20Indexing&In-Reply-To=%3C20020315151211.A8082%40vaio.codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000931.html">
   <LINK REL="Next"  HREF="000934.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Manual Patch: Fix Typos and Some Indexing</H1>
    <B>Jeffrey D. Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%20Patch%3A%20Fix%20Typos%20and%20Some%20Indexing&In-Reply-To=%3C20020315151211.A8082%40vaio.codesourcery.com%3E"
       TITLE="Manual Patch: Fix Typos and Some Indexing">oldham at codesourcery.com
       </A><BR>
    <I>Fri Mar 15 23:12:11 UTC 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="000931.html">[pooma-dev] MakeOwnCopy problem
</A></li>
        <LI>Next message: <A HREF="000934.html">Patch: R2.4 Slides
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#933">[ date ]</a>
              <a href="thread.html#933">[ thread ]</a>
              <a href="subject.html#933">[ subject ]</a>
              <a href="author.html#933">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2002-Mar-15  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

	Minor manual formatting changes.

	* starting.xml: s/the the/the/.  Change formatting of comment.
	* template.xml: Merge indexterms and text to avoid unwanted spaces
	in output.
	* tutorial.xml: Fix typos.
	* figures/distributed-101.png: Changes reflecting distributed.mp.
	* figures/distributed.mp: Avoid ligature problem.

Approved by me!
Applied to mainline

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: starting.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/starting.xml,v
retrieving revision 1.2
diff -c -p -r1.2 starting.xml
*** starting.xml	2002/03/04 23:48:09	1.2
--- starting.xml	2002/03/15 23:07:20
***************
*** 80,95 ****
     &lt;para&gt;&pooma; is open-source software, freely available via the
     Internet or perhaps packaged with this &book;.  &lt;ulink
     url=&quot;<A HREF="http://www.codesourcery.com/">http://www.codesourcery.com/</A>&quot;&gt;CodeSourcery, LLC,&lt;/ulink&gt;
!    currently hosts the &poomatoolkit; source code.  Download the the
     &pooma; source code &lt;filename
     path=&quot;<A HREF="http://www.codesourcery.com/pooma/downloads_folder/">http://www.codesourcery.com/pooma/downloads_folder/</A>&quot;&gt;&poomasourcefile;&lt;/filename&gt;
     from the &pooma; download page (&poomadownloadpage;) available off
     the &pooma; home page (&poomahomepage;).  The &lt;quote&gt;tgz&lt;/quote&gt;
     indicates this is a compressed tar archive file.  For a UNIX
     operating system, one can extract the source files using the
!    command &lt;command&gt;tar xzvf &poomasourcefile;&lt;/command&gt;.
! &lt;!-- FIXME: Make source code available for Windows and Mac users.
!    Describe how to unpack the files. --&gt;&lt;/para&gt;
  
     &lt;!-- FIXME: Add a dangerous bend section describing how to download
     sources from CVS. --&gt;
--- 80,95 ----
     &lt;para&gt;&pooma; is open-source software, freely available via the
     Internet or perhaps packaged with this &book;.  &lt;ulink
     url=&quot;<A HREF="http://www.codesourcery.com/">http://www.codesourcery.com/</A>&quot;&gt;CodeSourcery, LLC,&lt;/ulink&gt;
!    currently hosts the &poomatoolkit; source code.  Download the
     &pooma; source code &lt;filename
     path=&quot;<A HREF="http://www.codesourcery.com/pooma/downloads_folder/">http://www.codesourcery.com/pooma/downloads_folder/</A>&quot;&gt;&poomasourcefile;&lt;/filename&gt;
     from the &pooma; download page (&poomadownloadpage;) available off
     the &pooma; home page (&poomahomepage;).  The &lt;quote&gt;tgz&lt;/quote&gt;
     indicates this is a compressed tar archive file.  For a UNIX
     operating system, one can extract the source files using the
!    command &lt;command&gt;tar xzvf &poomasourcefile;&lt;/command&gt;.  &lt;!-- FIXME:
!    Make source code available for Windows and Mac users.  Describe how
!    to unpack the files. --&gt;&lt;/para&gt;
  
     &lt;!-- FIXME: Add a dangerous bend section describing how to download
     sources from CVS. --&gt;
Index: template.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/template.xml,v
retrieving revision 1.8
diff -c -p -r1.8 template.xml
*** template.xml	2002/03/04 23:48:09	1.8
--- template.xml	2002/03/15 23:07:21
***************
*** 22,39 ****
        compiler, not when a program runs.&lt;/para&gt;
       &lt;/listitem&gt;
       &lt;listitem&gt;
!       &lt;para id=&quot;template_programming-introduction-main_uses-type_polymorphism&quot;&gt;Templates permit declaring families of classes using a
!       single declaration.  For example, the &array;
!       &lt;indexterm&gt;
!        &lt;primary&gt;&array;&lt;/primary&gt;
!       &lt;/indexterm&gt;
!       &lt;indexterm zone=&quot;template_programming-introduction-main_uses-type_polymorphism&quot;&gt;
!        &lt;primary&gt;type polymorphism&lt;/primary&gt;
!       &lt;/indexterm&gt;
!       template
!       declaration permits using &array;s with many different value
!       types, e.g., arrays of integers, arrays of floating point
!       numbers, and arrays of arrays.&lt;/para&gt;
      &lt;/listitem&gt;
     &lt;/itemizedlist&gt;
     For those interested in the implementation of &pooma;, we close the
--- 22,37 ----
        compiler, not when a program runs.&lt;/para&gt;
       &lt;/listitem&gt;
       &lt;listitem&gt;
!       &lt;para
!       id=&quot;template_programming-introduction-main_uses-type_polymorphism&quot;&gt;Templates
!       permit declaring families of classes using a single declaration.
!       For example, the
!       &array;&lt;indexterm&gt;&lt;primary&gt;&array;&lt;/primary&gt;&lt;/indexterm&gt;&lt;indexterm
!       zone=&quot;template_programming-introduction-main_uses-type_polymorphism&quot;&gt;&lt;primary&gt;type
!       polymorphism&lt;/primary&gt;&lt;/indexterm&gt;template declaration permits
!       using &array;s with many different value types, e.g., arrays of
!       integers, arrays of floating point numbers, and arrays of
!       arrays.&lt;/para&gt;
      &lt;/listitem&gt;
     &lt;/itemizedlist&gt;
     For those interested in the implementation of &pooma;, we close the
***************
*** 61,99 ****
      program's interesting computation occurred when it was executed.
      When writing the program, the programmer, at &lt;glossterm
      linkend=&quot;glossary-programming_time&quot;&gt;&lt;firstterm&gt;programming
!     time&lt;/firstterm&gt;&lt;/glossterm&gt;,
!     &lt;indexterm&gt;
!      &lt;primary&gt;programming time&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     would specify which statements and expressions will occur and
!     which types to use.  At &lt;glossterm
      linkend=&quot;glossary-compile_time&quot;&gt;&lt;firstterm&gt;compile
      time&lt;/firstterm&gt;&lt;/glossterm&gt;, the compiler would convert the
      program's source code into an executable program.  Even though the
      compiler uses the types to produce the executable, no interesting
      computation would occur.  At &lt;glossterm
      linkend=&quot;glossary-run_time&quot;&gt;&lt;firstterm&gt;run
!     time&lt;/firstterm&gt;&lt;/glossterm&gt;,
!     &lt;indexterm&gt;
!      &lt;primary&gt;run time&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     the resulting executable program
!     would actually perform the operations.&lt;/para&gt;
  
      &lt;para&gt;The introduction of templates permits interesting
      computation to occur while the compiler produces the executable.
!     Most interesting is template instantiation,
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;instantiation&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     which produces a type
!     at compile time.  For example, the &array; &lt;quote&gt;type&lt;/quote&gt;
!     definition requires template parameters &lt;varname&gt;Dim&lt;/varname&gt;,
!     &lt;varname&gt;T&lt;/varname&gt;, and &lt;varname&gt;EngineTag&lt;/varname&gt;, specifying
!     its dimension, the type of its values, and its &engine; type.  To
!     use this, a programmer specifies values for the template
!     parameters:
      &lt;literal&gt;&lt;type&gt;Array&lt;2,double,Brick&gt;&lt;/type&gt;&lt;/literal&gt;
      specifies a dimension of 2, a value type of &double;, and the
      &brick; &engine; type.  At compile time, the compiler creates a
--- 59,87 ----
      program's interesting computation occurred when it was executed.
      When writing the program, the programmer, at &lt;glossterm
      linkend=&quot;glossary-programming_time&quot;&gt;&lt;firstterm&gt;programming
!     time&lt;/firstterm&gt;&lt;/glossterm&gt;,&lt;indexterm&gt;&lt;primary&gt;programming
!     time&lt;/primary&gt;&lt;/indexterm&gt; would specify which statements and
!     expressions will occur and which types to use.  At &lt;glossterm
      linkend=&quot;glossary-compile_time&quot;&gt;&lt;firstterm&gt;compile
      time&lt;/firstterm&gt;&lt;/glossterm&gt;, the compiler would convert the
      program's source code into an executable program.  Even though the
      compiler uses the types to produce the executable, no interesting
      computation would occur.  At &lt;glossterm
      linkend=&quot;glossary-run_time&quot;&gt;&lt;firstterm&gt;run
!     time&lt;/firstterm&gt;&lt;/glossterm&gt;,&lt;indexterm&gt;&lt;primary&gt;run
!     time&lt;/primary&gt;&lt;/indexterm&gt; the resulting executable program would
!     actually perform the operations.&lt;/para&gt;
  
      &lt;para&gt;The introduction of templates permits interesting
      computation to occur while the compiler produces the executable.
!     Most interesting is template
!     instantiation,&lt;indexterm&gt;&lt;primary&gt;template&lt;/primary&gt;&lt;secondary&gt;instantiation&lt;/secondary&gt;&lt;/indexterm&gt;
!     which produces a type at compile time.  For example, the &array;
!     &lt;quote&gt;type&lt;/quote&gt; definition requires template parameters
!     &lt;varname&gt;Dim&lt;/varname&gt;, &lt;varname&gt;T&lt;/varname&gt;, and
!     &lt;varname&gt;EngineTag&lt;/varname&gt;, specifying its dimension, the type
!     of its values, and its &engine; type.  To use this, a programmer
!     specifies values for the template parameters:
      &lt;literal&gt;&lt;type&gt;Array&lt;2,double,Brick&gt;&lt;/type&gt;&lt;/literal&gt;
      specifies a dimension of 2, a value type of &double;, and the
      &brick; &engine; type.  At compile time, the compiler creates a
***************
*** 110,135 ****
      computable.  Unfortunately, syntax for compile-time computation is
      more difficult than for run-time computation.  Also current
      compilers are not as efficient as code executed by hardware.
!     Run-time &cc; constructs are Turing-complete
!     &lt;indexterm&gt;
!      &lt;primary&gt;Turing complete&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     so using templates is
!     unnecessary.  Thus, we can shift computation to the time which
!     best trades off the ease of expressing syntax with the speed of
!     computation by programmer, compiler, or computer chip.  For
!     example, &pooma; uses expression template technology
!     &lt;indexterm&gt;
!      &lt;primary&gt;expression templates&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     to speed
!     run-time execution of data-parallel statements.  The &pooma;
!     developers decided to shift some of the computation from run-time
!     to compile-time using template computations.  The resulting
!     run-time code runs more quickly, but compiling the code takes
!     longer.  Also, programming time for the &pooma; developers
!     increased significantly, but, most users, who are usually most
!     concerned about decreasing run times, benefited.&lt;/para&gt;
     &lt;/section&gt;
  
  
--- 98,118 ----
      computable.  Unfortunately, syntax for compile-time computation is
      more difficult than for run-time computation.  Also current
      compilers are not as efficient as code executed by hardware.
!     Run-time &cc; constructs are
!     Turing-complete&lt;indexterm&gt;&lt;primary&gt;Turing
!     complete&lt;/primary&gt;&lt;/indexterm&gt; so using templates is unnecessary.
!     Thus, we can shift computation to the time which best trades off
!     the ease of expressing syntax with the speed of computation by
!     programmer, compiler, or computer chip.  For example, &pooma; uses
!     expression template technology&lt;indexterm&gt;&lt;primary&gt;expression
!     templates&lt;/primary&gt;&lt;/indexterm&gt; to speed run-time execution of
!     data-parallel statements.  The &pooma; developers decided to shift
!     some of the computation from run-time to compile-time using
!     template computations.  The resulting run-time code runs more
!     quickly, but compiling the code takes longer.  Also, programming
!     time for the &pooma; developers increased significantly, but, most
!     users, who are usually most concerned about decreasing run times,
!     benefited.&lt;/para&gt;
     &lt;/section&gt;
  
  
***************
*** 145,169 ****
         parameters, both of which are used in this book.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
!        &lt;para&gt;template instantiation,
!        &lt;indexterm&gt;
! 	&lt;primary&gt;template&lt;/primary&gt;
! 	&lt;secondary&gt;instantiation&lt;/secondary&gt;
!        &lt;/indexterm&gt;
         i.e., specifying a particular type by specifying values for
         template parameters.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
!        &lt;para&gt;nested type names,
!        &lt;indexterm&gt;
! 	&lt;primary&gt;nested type&lt;/primary&gt;
! 	&lt;see&gt;type, nested.&lt;/see&gt;
!        &lt;/indexterm&gt;
!        &lt;indexterm&gt;
! 	&lt;primary&gt;type&lt;/primary&gt;
! 	&lt;secondary&gt;nested&lt;/secondary&gt;
!        &lt;/indexterm&gt;
!        which are types specified within a class definition.&lt;/para&gt;
        &lt;/listitem&gt;
       &lt;/itemizedlist&gt;
      We discuss each of these below.&lt;/para&gt;
--- 128,143 ----
         parameters, both of which are used in this book.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
!        &lt;para&gt;template
!        instantiation,&lt;indexterm&gt;&lt;primary&gt;template&lt;/primary&gt;&lt;secondary&gt;instantiation&lt;/secondary&gt;&lt;/indexterm&gt;
         i.e., specifying a particular type by specifying values for
         template parameters.&lt;/para&gt;
        &lt;/listitem&gt;
        &lt;listitem&gt;
!        &lt;para&gt;nested type names, &lt;indexterm&gt;&lt;primary&gt;nested
! 	type&lt;/primary&gt;&lt;see&gt;type,
! 	nested.&lt;/see&gt;&lt;/indexterm&gt;&lt;indexterm&gt;&lt;primary&gt;type&lt;/primary&gt;&lt;secondary&gt;nested&lt;/secondary&gt;&lt;/indexterm&gt;
! 	which are types specified within a class definition.&lt;/para&gt;
        &lt;/listitem&gt;
       &lt;/itemizedlist&gt;
      We discuss each of these below.&lt;/para&gt;
***************
*** 231,241 ****
      follow the class name surrounded by angle
      brackets&nbsp;(&lt;literal&gt;&lt;&gt;&lt;/literal&gt;).  For example,
      &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; &lt;glossterm
!     linkend=&quot;glossary-template_instantiation&quot;&gt;&lt;firstterm&gt;instantiates&lt;/firstterm&gt;&lt;/glossterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;instantiation&lt;/secondary&gt;
!     &lt;/indexterm&gt;
      the &lt;classname&gt;pair&lt;/classname&gt; template class definition with
      &lt;varname&gt;T&lt;/varname&gt; equal to &int;.  That is, the compiler
      creates a definition for &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; by copying
--- 205,211 ----
      follow the class name surrounded by angle
      brackets&nbsp;(&lt;literal&gt;&lt;&gt;&lt;/literal&gt;).  For example,
      &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; &lt;glossterm
!     linkend=&quot;glossary-template_instantiation&quot;&gt;&lt;firstterm&gt;instantiates&lt;/firstterm&gt;&lt;/glossterm&gt;&lt;indexterm&gt;&lt;primary&gt;template&lt;/primary&gt;&lt;secondary&gt;instantiation&lt;/secondary&gt;&lt;/indexterm&gt;
      the &lt;classname&gt;pair&lt;/classname&gt; template class definition with
      &lt;varname&gt;T&lt;/varname&gt; equal to &int;.  That is, the compiler
      creates a definition for &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; by copying
***************
*** 246,261 ****
      The result is a definition exactly the same as
      &lt;classname&gt;pairOfInts&lt;/classname&gt;.&lt;/para&gt;
  
!     &lt;para&gt;As we mentioned above, template instantiation
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;instantiation&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     is analogous to function application.
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;application&lt;/secondary&gt;
!     &lt;/indexterm&gt;
      A template class is analogous to a function; it is a function from
      types and constants to classes.  The analogy between compile-time
      and run-time programming constructs can be extended.  &lt;xref
--- 216,225 ----
      The result is a definition exactly the same as
      &lt;classname&gt;pairOfInts&lt;/classname&gt;.&lt;/para&gt;
  
!     &lt;para&gt;As we mentioned above, template
!     instantiation&lt;indexterm&gt;&lt;primary&gt;template&lt;/primary&gt;&lt;secondary&gt;instantiation&lt;/secondary&gt;&lt;/indexterm&gt;
!     is analogous to function
!     application.&lt;indexterm&gt;&lt;primary&gt;function&lt;/primary&gt;&lt;secondary&gt;application&lt;/secondary&gt;&lt;/indexterm&gt;
      A template class is analogous to a function; it is a function from
      types and constants to classes.  The analogy between compile-time
      and run-time programming constructs can be extended.  &lt;xref
***************
*** 263,278 ****
      lists these correspondences.  For example, at run time, values
      consist of things such as integers, floating point numbers,
      pointers, functions, and objects.  Programs compute by operating
!     on these values.  The compile-time values
!     &lt;indexterm&gt;
!      &lt;primary&gt;compile time&lt;/primary&gt;
!      &lt;secondary&gt;value&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     include types, and
!     compile-time operations use these types.  For both run-time and
!     compile-time programming, &cc; defines default sets of values that
!     all conforming compilers must support.  For example,
!     &lt;literal&gt;3&lt;/literal&gt; and &lt;literal&gt;6.022e+23&lt;/literal&gt; are
      run-time values that any &cc; compiler must accept.  It must also
      accept the &int;, &bool;, and &lt;type&gt;int*&lt;/type&gt; types.&lt;/para&gt;
  
--- 227,239 ----
      lists these correspondences.  For example, at run time, values
      consist of things such as integers, floating point numbers,
      pointers, functions, and objects.  Programs compute by operating
!     on these values.  The compile-time
!     values&lt;indexterm&gt;&lt;primary&gt;compile
!     time&lt;/primary&gt;&lt;secondary&gt;value&lt;/secondary&gt;&lt;/indexterm&gt; include
!     types, and compile-time operations use these types.  For both
!     run-time and compile-time programming, &cc; defines default sets
!     of values that all conforming compilers must support.  For
!     example, &lt;literal&gt;3&lt;/literal&gt; and &lt;literal&gt;6.022e+23&lt;/literal&gt; are
      run-time values that any &cc; compiler must accept.  It must also
      accept the &int;, &bool;, and &lt;type&gt;int*&lt;/type&gt; types.&lt;/para&gt;
  
***************
*** 313,341 ****
  	 &lt;entry&gt;template argument, e.g., &lt;quote&gt;any type&lt;/quote&gt;&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;packaging repeated operations&lt;/entry&gt;
! 	 &lt;entry&gt;A function
!          &lt;indexterm&gt;
!           &lt;primary&gt;function&lt;/primary&gt;
!          &lt;/indexterm&gt;
!          generalizes a particular operation applied to different
!          values.  The function parameters are placeholders for
!          particular values.&lt;/entry&gt;
!          &lt;entry&gt;A template class generalizes a particular class
!          definition using different types.  The template parameters
!          are placeholders for particular values.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;application
!          &lt;indexterm&gt;
!           &lt;primary&gt;function&lt;/primary&gt;
!           &lt;secondary&gt;application&lt;/secondary&gt;
!          &lt;/indexterm&gt;
!          &lt;indexterm&gt;
!           &lt;primary&gt;application&lt;/primary&gt;
!           &lt;see&gt;function, application.&lt;/see&gt;
!          &lt;/indexterm&gt;
!          &lt;/entry&gt;
  	 &lt;entry&gt;Use a function by appending function arguments
  	surrounded by parentheses.&lt;/entry&gt;
  	 &lt;entry&gt;Use a template class by appending template arguments
--- 274,290 ----
  	 &lt;entry&gt;template argument, e.g., &lt;quote&gt;any type&lt;/quote&gt;&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;packaging repeated operations&lt;/entry&gt; &lt;entry&gt;A
! 	 function&lt;indexterm&gt;&lt;primary&gt;function&lt;/primary&gt;&lt;/indexterm&gt;
! 	 generalizes a particular operation applied to different
! 	 values.  The function parameters are placeholders for
! 	 particular values.&lt;/entry&gt; &lt;entry&gt;A template class
! 	 generalizes a particular class definition using different
! 	 types.  The template parameters are placeholders for
! 	 particular values.&lt;/entry&gt;
  	&lt;/row&gt;
  	&lt;row&gt;
! 	 &lt;entry&gt;application &lt;indexterm&gt;&lt;primary&gt;function&lt;/primary&gt;&lt;secondary&gt;application&lt;/secondary&gt;&lt;/indexterm&gt;&lt;indexterm&gt;&lt;primary&gt;application&lt;/primary&gt;&lt;see&gt;function, application.&lt;/see&gt;&lt;/indexterm&gt;&lt;/entry&gt;
  	 &lt;entry&gt;Use a function by appending function arguments
  	surrounded by parentheses.&lt;/entry&gt;
  	 &lt;entry&gt;Use a template class by appending template arguments
*************** maxOut(0, 3);
*** 467,492 ****
      and the latter stores named values, nested type names are values,
      i.e., types, stored within class definitions.  For example, the
      template class &array; has an nested type name for the type of its
!     domain:
! &lt;programlisting&gt;
  typedef typename Engine_t::Domain_t Domain_t;
! &lt;/programlisting&gt; This &lt;literal&gt;typedef&lt;/literal&gt;,
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;literal&gt;typedef&lt;/literal&gt;&lt;/primary&gt;
!      &lt;see&gt;type, definition.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;type&lt;/primary&gt;
!      &lt;secondary&gt;definition&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     i.e., type
!     definition, defines the type &lt;type&gt;Domain_t&lt;/type&gt; as equivalent
!     to &lt;type&gt;Engine_t::Domain_t&lt;/type&gt;.  The
!     &lt;literal&gt;::&lt;/literal&gt;&nbsp;operator
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;literal&gt;::&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     selects the &lt;type&gt;Domain_t&lt;/type&gt; nested type from inside the
      &lt;type&gt;Engine_t&lt;/type&gt; type.  This illustrates how to access
      &array;'s &lt;type&gt;Domain_t&lt;/type&gt; when not within &array;'s scope:
      &lt;type&gt;Array&lt;Dim, T, EngineTag&gt;::Domain_t&lt;/type&gt;.  The
--- 416,429 ----
      and the latter stores named values, nested type names are values,
      i.e., types, stored within class definitions.  For example, the
      template class &array; has an nested type name for the type of its
!     domain:&lt;programlisting&gt;
  typedef typename Engine_t::Domain_t Domain_t;
! &lt;/programlisting&gt; This
!     &lt;literal&gt;typedef&lt;/literal&gt;,&lt;indexterm&gt;&lt;primary&gt;&lt;literal&gt;typedef&lt;/literal&gt;&lt;/primary&gt;&lt;see&gt;type,
!     definition.&lt;/see&gt;&lt;/indexterm&gt;&lt;indexterm&gt;&lt;primary&gt;type&lt;/primary&gt;&lt;secondary&gt;definition&lt;/secondary&gt;&lt;/indexterm&gt;
!     i.e., type definition, defines the type &lt;type&gt;Domain_t&lt;/type&gt; as
!     equivalent to &lt;type&gt;Engine_t::Domain_t&lt;/type&gt;.  The
!     &lt;literal&gt;::&lt;/literal&gt;&nbsp;operator&lt;indexterm&gt;&lt;primary&gt;&lt;literal&gt;::&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;&lt;/indexterm&gt; selects the &lt;type&gt;Domain_t&lt;/type&gt; nested type from inside the
      &lt;type&gt;Engine_t&lt;/type&gt; type.  This illustrates how to access
      &array;'s &lt;type&gt;Domain_t&lt;/type&gt; when not within &array;'s scope:
      &lt;type&gt;Array&lt;Dim, T, EngineTag&gt;::Domain_t&lt;/type&gt;.  The
*************** typedef typename Engine_t::Domain_t Doma
*** 554,596 ****
  	operations on code.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;values stored in a collection&lt;/entry&gt;
! 	&lt;entry&gt;An object stores values.&lt;/entry&gt;
! 	&lt;entry&gt;A &lt;glossterm linkend=&quot;glossary-traits_class&quot;&gt;traits
! 	class&lt;/glossterm&gt;
!         &lt;indexterm&gt;
!          &lt;primary&gt;traits class&lt;/primary&gt;
!         &lt;/indexterm&gt;
!         &lt;indexterm&gt;
!          &lt;primary&gt;class&lt;/primary&gt;
!          &lt;secondary&gt;traits&lt;/secondary&gt;
!          &lt;see&gt;traits class&lt;/see&gt;
!         &lt;/indexterm&gt;
!         contains values describing a type.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;extracting values from collections&lt;/entry&gt;
! 	&lt;entry&gt;An object's named values are extracted using the
! 	&lt;literal&gt;.&lt;/literal&gt;&nbsp;operator.
!         &lt;indexterm&gt;
!          &lt;primary&gt;&lt;literal&gt;.&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;
!         &lt;/indexterm&gt;
!         &lt;/entry&gt;
  	&lt;entry&gt;A class's nested types and classes are extracted using
! 	the &lt;literal&gt;::&lt;/literal&gt;&nbsp;operator.
!         &lt;indexterm&gt;
!          &lt;primary&gt;&lt;literal&gt;::&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;
!         &lt;/indexterm&gt;
!         &lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;control flow
!         &lt;indexterm&gt;
!          &lt;primary&gt;control flow&lt;/primary&gt;
!         &lt;/indexterm&gt;
!         to choose among operations&lt;/entry&gt;
! 	&lt;entry&gt;&lt;literal&gt;if&lt;/literal&gt;, &lt;literal&gt;while&lt;/literal&gt;, &lt;literal&gt;goto&lt;/literal&gt;, &hellip;&lt;/entry&gt;
! 	&lt;entry&gt;template class specializations with pattern matching&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
--- 491,518 ----
  	operations on code.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;values stored in a collection&lt;/entry&gt; &lt;entry&gt;An object
! 	stores values.&lt;/entry&gt; &lt;entry&gt;A &lt;glossterm
! 	linkend=&quot;glossary-traits_class&quot;&gt;traits
! 	class&lt;/glossterm&gt;&lt;indexterm&gt;&lt;primary&gt;traits
! 	class&lt;/primary&gt;&lt;/indexterm&gt;&lt;indexterm&gt;&lt;primary&gt;class&lt;/primary&gt;&lt;secondary&gt;traits&lt;/secondary&gt;&lt;see&gt;traits
! 	class&lt;/see&gt;&lt;/indexterm&gt; contains values describing a
! 	type.&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;extracting values from collections&lt;/entry&gt; &lt;entry&gt;An
! 	object's named values are extracted using the
! 	&lt;literal&gt;.&lt;/literal&gt;&nbsp;operator.&lt;indexterm&gt;&lt;primary&gt;&lt;literal&gt;.&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;&lt;/indexterm&gt;&lt;/entry&gt;
  	&lt;entry&gt;A class's nested types and classes are extracted using
! 	the
! 	&lt;literal&gt;::&lt;/literal&gt;&nbsp;operator.&lt;indexterm&gt;&lt;primary&gt;&lt;literal&gt;::&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;&lt;/indexterm&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row&gt;
! 	&lt;entry&gt;control flow&lt;indexterm&gt;&lt;primary&gt;control
! 	flow&lt;/primary&gt;&lt;/indexterm&gt; to choose among operations&lt;/entry&gt;
! 	&lt;entry&gt;&lt;literal&gt;if&lt;/literal&gt;, &lt;literal&gt;while&lt;/literal&gt;,
! 	&lt;literal&gt;goto&lt;/literal&gt;, &hellip;&lt;/entry&gt; &lt;entry&gt;template
! 	class specializations with pattern matching&lt;/entry&gt;
         &lt;/row&gt;
        &lt;/tbody&gt;
       &lt;/tgroup&gt;
*************** enum { dimensionPlusRank = dimensions + 
*** 654,701 ****
       &lt;/listitem&gt;
      &lt;/itemizedlist&gt;
      The use of non-integral constant values such as floating-point
!     numbers at compile time is restricted.
!     &lt;indexterm class=&quot;endofrange&quot;
! 	       startref=&quot;template_programming-pooma_implementation-index-enumeration&quot;&gt;
!     &lt;/indexterm&gt;
!     &lt;/para&gt;
! 
!     &lt;para&gt;Other compile-time values include pointers
!     &lt;indexterm&gt;
!      &lt;primary&gt;pointer&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     to objects and
!     functions, references
!     &lt;indexterm&gt;
!      &lt;primary&gt;reference&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     to objects and functions, and executable
!     code.  For example, a pointer to a function
!     &lt;indexterm&gt;
!      &lt;primary&gt;pointer&lt;/primary&gt;
!      &lt;secondary&gt;function&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;function pointer&lt;/primary&gt;
!      &lt;see&gt;pointer, function.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     sometimes is passed to
!     a template function to perform a specific task.  Even though
!     executable code
!     &lt;indexterm&gt;
!      &lt;primary&gt;executable code&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     cannot be directly represented in a program, it is
!     a compile-time value which the compiler uses.  A simple example is
!     a class that is created by template instantiation,
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;instantiation&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     e.g., &lt;type&gt;pair&lt;int&gt;&lt;/type&gt;.  Conceptually, the &int; template
!     argument is substituted throughout the &lt;type&gt;pair&lt;/type&gt; template
!     class to produce a class definition.  Although neither the
!     programmer nor the user sees this class definition, it is
      represented inside the compiler, which can use and manipulate the
      code.&lt;/para&gt;
      &lt;indexterm class=&quot;endofrange&quot;
--- 576,603 ----
       &lt;/listitem&gt;
      &lt;/itemizedlist&gt;
      The use of non-integral constant values such as floating-point
!     numbers at compile time is restricted.&lt;indexterm
!     class=&quot;endofrange&quot;
!     startref=&quot;template_programming-pooma_implementation-index-enumeration&quot;&gt;&lt;/indexterm&gt;&lt;/para&gt;
! 
!     &lt;para&gt;Other compile-time values include
!     pointers&lt;indexterm&gt;&lt;primary&gt;pointer&lt;/primary&gt;&lt;/indexterm&gt; to
!     objects and functions,
!     references&lt;indexterm&gt;&lt;primary&gt;reference&lt;/primary&gt;&lt;/indexterm&gt; to
!     objects and functions, and executable code.  For example, a
!     pointer to a
!     function&lt;indexterm&gt;&lt;primary&gt;pointer&lt;/primary&gt;&lt;secondary&gt;function&lt;/secondary&gt;&lt;/indexterm&gt;&lt;indexterm&gt;&lt;primary&gt;function
!     pointer&lt;/primary&gt;&lt;see&gt;pointer, function.&lt;/see&gt;&lt;/indexterm&gt;
!     sometimes is passed to a template function to perform a specific
!     task.  Even though executable code&lt;indexterm&gt;&lt;primary&gt;executable
!     code&lt;/primary&gt;&lt;/indexterm&gt; cannot be directly represented in a
!     program, it is a compile-time value which the compiler uses.  A
!     simple example is a class that is created by template
!     instantiation,&lt;indexterm&gt;&lt;primary&gt;template&lt;/primary&gt;&lt;secondary&gt;instantiation&lt;/secondary&gt;&lt;/indexterm&gt;
!     e.g., &lt;type&gt;pair&lt;int&gt;&lt;/type&gt;.  Conceptually, the &int;
!     template argument is substituted throughout the &lt;type&gt;pair&lt;/type&gt;
!     template class to produce a class definition.  Although neither
!     the programmer nor the user sees this class definition, it is
      represented inside the compiler, which can use and manipulate the
      code.&lt;/para&gt;
      &lt;indexterm class=&quot;endofrange&quot;
*************** enum { dimensionPlusRank = dimensions + 
*** 703,723 ****
      &lt;/indexterm&gt;
  
      &lt;para id=&quot;template_programming-pooma_implementation-optimization&quot;&gt;
!     Through template programming, the compiler's optimizer
!     &lt;indexterm&gt;
!      &lt;primary&gt;optimizer&lt;/primary&gt;
!      &lt;see&gt;compiler, optimizer.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;optimization&lt;/primary&gt;
!      &lt;see&gt;compiler, optimizer.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm zone=&quot;template_programming-pooma_implementation-optimization&quot;&gt;
!      &lt;primary&gt;compiler&lt;/primary&gt;
!      &lt;secondary&gt;optimizer&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     can
!     transform complicated code into much simpler code.  In &lt;xref
      linkend=&quot;data_parallel-implementation&quot;&gt;&lt;/xref&gt;, we describe the
      complicated template code used to implement efficiently
      data-parallel operations.  Although the template code is
--- 605,616 ----
      &lt;/indexterm&gt;
  
      &lt;para id=&quot;template_programming-pooma_implementation-optimization&quot;&gt;
!     Through template programming, the compiler's
!     optimizer&lt;indexterm&gt;&lt;primary&gt;optimizer&lt;/primary&gt;&lt;see&gt;compiler,
!     optimizer.&lt;/see&gt;&lt;/indexterm&gt;&lt;indexterm&gt;&lt;primary&gt;optimization&lt;/primary&gt;&lt;see&gt;compiler,
!     optimizer.&lt;/see&gt;&lt;/indexterm&gt;&lt;indexterm
!     zone=&quot;template_programming-pooma_implementation-optimization&quot;&gt;&lt;primary&gt;compiler&lt;/primary&gt;&lt;secondary&gt;optimizer&lt;/secondary&gt;&lt;/indexterm&gt;
!     can transform complicated code into much simpler code.  In &lt;xref
      linkend=&quot;data_parallel-implementation&quot;&gt;&lt;/xref&gt;, we describe the
      complicated template code used to implement efficiently
      data-parallel operations.  Although the template code is
*************** struct usuallySimpleClass&lt;false&gt; {
*** 757,827 ****
      compilers that translate &cc; code into &c; code may permit
      inspecting the resulting code.  For example, using the
      &lt;option&gt;&dashdash;keep_gen_c&lt;/option&gt; command-line option with the
!     &lt;application class=&quot;software&quot;&gt;KAI &cc; compiler&lt;/application&gt;
!     &lt;!-- FIXME: Reference or link? --&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;compiler&lt;/primary&gt;
!      &lt;secondary&gt;KAI&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;application class=&quot;software&quot;&gt;KAI &cc; compiler&lt;/application&gt;&lt;/primary&gt;
!      &lt;see&gt;compiler, KAI.&lt;/see&gt;
!     &lt;/indexterm&gt;
!     creates a file
!     containing the intermediate code.  Unfortunately,
!     reading and understanding the code is frequently difficult.&lt;/para&gt;
  
      &lt;para&gt;Each category&lt;firstterm&gt;&lt;/firstterm&gt; of values supports a
      distinct set of operations.  For example, the run-time category of
!     integer values supports combination using &lt;literal&gt;+&lt;/literal&gt;
!     and &lt;literal&gt;-&lt;/literal&gt; and comparison using
!     &lt;literal&gt;&gt;&lt;/literal&gt; and &lt;literal&gt;==&lt;/literal&gt;.  At run
!     time, the category of strings can be compared using
!     &lt;literal&gt;==&lt;/literal&gt; and characters can be extracted using
!     subscripts with the &lt;literal&gt;[]&lt;/literal&gt; operator.  Compile-time
!     operations are more limited.  Types may be declared and used.  The
!     &lt;literal&gt;sizeof&lt;/literal&gt; operator yields the number of
!     bytes to represent an object of the specified type.  Enumerations,
!     constant integers, &lt;literal&gt;sizeof&lt;/literal&gt; expressions,
!     and simple arithmetic and comparison operators such as
!     &lt;literal&gt;+&lt;/literal&gt; and &lt;literal&gt;==&lt;/literal&gt; can form
      constant expressions that can be used at compile time.  These
      values can initialize enumerations and integer constants and be
      used as template arguments.  At compile time, pointers and
      references to objects and functions can be used as template
      arguments, while the category of executable code supports no
!     operations.  (The compiler's optimizer
!     &lt;indexterm&gt;
!      &lt;primary&gt;compiler&lt;/primary&gt;
!      &lt;secondary&gt;optimizer&lt;/secondary&gt;
!     &lt;/indexterm&gt;
      may simplify it, though.)&lt;/para&gt;
  
      &lt;para id=&quot;template_programming-pooma_implementation-traits_class&quot;&gt;
      &lt;indexterm zone=&quot;template_programming-pooma_implementation-traits_class&quot;&gt;
       &lt;primary&gt;traits class&lt;/primary&gt;
-     &lt;/indexterm&gt;
-     At run time, an object
-     &lt;indexterm&gt;
-      &lt;primary&gt;object&lt;/primary&gt;
      &lt;/indexterm&gt;
!     can store multiple values, each
!     having its own name.  For example, a &lt;type&gt;pair&lt;int&gt;&lt;/type&gt;
!     object&nbsp;&lt;varname&gt;p&lt;/varname&gt; stores two &int;s named
!     &lt;literal&gt;left_&lt;/literal&gt; and
      &lt;literal&gt;right_&lt;/literal&gt;.  The &lt;literal&gt;.&lt;/literal&gt;
!     operator
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;literal&gt;.&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;
!     &lt;/indexterm&gt;
      extracts a named member from an object:
!     &lt;literal&gt;p.left_&lt;/literal&gt;.  At compile time, a class can
!     store multiple values, each having its own name.  These are
!     sometimes called &lt;glossterm
      linkend=&quot;glossary-traits_class&quot;&gt;&lt;firstterm&gt;traits
      classes&lt;/firstterm&gt;&lt;/glossterm&gt;.  For example, implementing
!     data-parallel operations requiring storing a tree of types.
!     The &lt;type&gt;ExpressionTraits&lt;BinaryNode&lt;Op, Left,
      Right&closeclose;&lt;/type&gt; traits class stores the types of a binary
      node representing the operation of &lt;varname&gt;Op&lt;/varname&gt; on left
      and right children.  Its definition
--- 650,704 ----
      compilers that translate &cc; code into &c; code may permit
      inspecting the resulting code.  For example, using the
      &lt;option&gt;&dashdash;keep_gen_c&lt;/option&gt; command-line option with the
!     &lt;application class=&quot;software&quot;&gt;KAI &cc;
!     compiler&lt;/application&gt;&lt;indexterm&gt;&lt;primary&gt;compiler&lt;/primary&gt;&lt;secondary&gt;KAI&lt;/secondary&gt;&lt;/indexterm&gt;&lt;indexterm&gt;&lt;primary&gt;&lt;application
!     class=&quot;software&quot;&gt;KAI &cc;
!     compiler&lt;/application&gt;&lt;/primary&gt;&lt;see&gt;compiler,
!     KAI.&lt;/see&gt;&lt;/indexterm&gt; creates a file containing the intermediate
!     code.  Unfortunately, reading and understanding the code is
!     frequently difficult.&lt;/para&gt;
  
      &lt;para&gt;Each category&lt;firstterm&gt;&lt;/firstterm&gt; of values supports a
      distinct set of operations.  For example, the run-time category of
!     integer values supports combination using &lt;literal&gt;+&lt;/literal&gt; and
!     &lt;literal&gt;-&lt;/literal&gt; and comparison using &lt;literal&gt;&gt;&lt;/literal&gt;
!     and &lt;literal&gt;==&lt;/literal&gt;.  At run time, the category of strings
!     can be compared using &lt;literal&gt;==&lt;/literal&gt; and characters can be
!     extracted using subscripts with the &lt;literal&gt;[]&lt;/literal&gt;
!     operator.  Compile-time operations are more limited.  Types may be
!     declared and used.  The &lt;literal&gt;sizeof&lt;/literal&gt; operator yields
!     the number of bytes to represent an object of the specified type.
!     Enumerations, constant integers, &lt;literal&gt;sizeof&lt;/literal&gt;
!     expressions, and simple arithmetic and comparison operators such
!     as &lt;literal&gt;+&lt;/literal&gt; and &lt;literal&gt;==&lt;/literal&gt; can form
      constant expressions that can be used at compile time.  These
      values can initialize enumerations and integer constants and be
      used as template arguments.  At compile time, pointers and
      references to objects and functions can be used as template
      arguments, while the category of executable code supports no
!     operations.  (The compiler's
!     optimizer&lt;indexterm&gt;&lt;primary&gt;compiler&lt;/primary&gt;&lt;secondary&gt;optimizer&lt;/secondary&gt;&lt;/indexterm&gt;
      may simplify it, though.)&lt;/para&gt;
  
      &lt;para id=&quot;template_programming-pooma_implementation-traits_class&quot;&gt;
      &lt;indexterm zone=&quot;template_programming-pooma_implementation-traits_class&quot;&gt;
       &lt;primary&gt;traits class&lt;/primary&gt;
      &lt;/indexterm&gt;
!     At run time, an
!     object&lt;indexterm&gt;&lt;primary&gt;object&lt;/primary&gt;&lt;/indexterm&gt; can store
!     multiple values, each having its own name.  For example, a
!     &lt;type&gt;pair&lt;int&gt;&lt;/type&gt; object&nbsp;&lt;varname&gt;p&lt;/varname&gt;
!     stores two &int;s named &lt;literal&gt;left_&lt;/literal&gt; and
      &lt;literal&gt;right_&lt;/literal&gt;.  The &lt;literal&gt;.&lt;/literal&gt;
!     operator&lt;indexterm&gt;&lt;primary&gt;&lt;literal&gt;.&lt;/literal&gt;&nbsp;operator&lt;/primary&gt;&lt;/indexterm&gt;
      extracts a named member from an object:
!     &lt;literal&gt;p.left_&lt;/literal&gt;.  At compile time, a class can store
!     multiple values, each having its own name.  These are sometimes
!     called &lt;glossterm
      linkend=&quot;glossary-traits_class&quot;&gt;&lt;firstterm&gt;traits
      classes&lt;/firstterm&gt;&lt;/glossterm&gt;.  For example, implementing
!     data-parallel operations requiring storing a tree of types.  The
!     &lt;type&gt;ExpressionTraits&lt;BinaryNode&lt;Op, Left,
      Right&closeclose;&lt;/type&gt; traits class stores the types of a binary
      node representing the operation of &lt;varname&gt;Op&lt;/varname&gt; on left
      and right children.  Its definition
*************** struct ExpressionTraits&lt;BinaryNode&amp;lt
*** 869,889 ****
      &lt;/indexterm&gt;
      Control flow determines which code is used.  At run time,
      control-flow statements such as &lt;literal&gt;if&lt;/literal&gt;,
!     &lt;literal&gt;while&lt;/literal&gt;, and
!     &lt;literal&gt;goto&lt;/literal&gt; determine which statements to
!     execute.  Template programming uses two mechanisms: template class
!     specializations and pattern matching.  These are similar to
!     control flow in functional programming languages.  A &lt;glossterm
      linkend=&quot;glossary-traits_class&quot;&gt;&lt;firstterm&gt;template class
      specialization&lt;/firstterm&gt;&lt;/glossterm&gt; is a class definition
      specific to one or more template arguments.  For example, the
!     implementation for data-parallel operations
!     &lt;indexterm&gt;
!      &lt;primary&gt;data-parallel operation&lt;/primary&gt;
!     &lt;/indexterm&gt;
!     uses the templated &lt;type&gt;CreateLeaf&lt;/type&gt;.  The default
!     definition works for any template
!     argument&nbsp;&lt;varname&gt;T&lt;/varname&gt;:
  &lt;programlisting&gt;
  template&lt;class T&gt;
  struct CreateLeaf
--- 746,764 ----
      &lt;/indexterm&gt;
      Control flow determines which code is used.  At run time,
      control-flow statements such as &lt;literal&gt;if&lt;/literal&gt;,
!     &lt;literal&gt;while&lt;/literal&gt;, and &lt;literal&gt;goto&lt;/literal&gt; determine
!     which statements to execute.  Template programming uses two
!     mechanisms: template class specializations and pattern matching.
!     These are similar to control flow in functional programming
!     languages.  A &lt;glossterm
      linkend=&quot;glossary-traits_class&quot;&gt;&lt;firstterm&gt;template class
      specialization&lt;/firstterm&gt;&lt;/glossterm&gt; is a class definition
      specific to one or more template arguments.  For example, the
!     implementation for data-parallel
!     operations&lt;indexterm&gt;&lt;primary&gt;data-parallel
!     operation&lt;/primary&gt;&lt;/indexterm&gt; uses the templated
!     &lt;type&gt;CreateLeaf&lt;/type&gt;.  The default definition works for any
!     template argument&nbsp;&lt;varname&gt;T&lt;/varname&gt;:
  &lt;programlisting&gt;
  template&lt;class T&gt;
  struct CreateLeaf
*************** struct CreateLeaf&lt;Expression&lt;T&amp;clo
*** 932,944 ****
  
      &lt;para&gt;Control flow using template specializations and pattern
      matching is similar to &lt;literal&gt;switch&lt;/literal&gt;
!     statements.
!     &lt;indexterm&gt;
!      &lt;primary&gt;&lt;literal&gt;switch&lt;/literal&gt;&lt;/primary&gt;
!     &lt;/indexterm&gt;
      A &lt;literal&gt;switch&lt;/literal&gt; statement has a
      condition and one or more pairs of case labels and associated
!     code.  The code associated with the the case label whose value
      matches the condition is executed.  If no case label matches the
      condition, the default code, if present, is used.  In template
      programming, instantiating a template, e.g.,
--- 807,816 ----
  
      &lt;para&gt;Control flow using template specializations and pattern
      matching is similar to &lt;literal&gt;switch&lt;/literal&gt;
!     statements.&lt;indexterm&gt;&lt;primary&gt;&lt;literal&gt;switch&lt;/literal&gt;&lt;/primary&gt;&lt;/indexterm&gt;
      A &lt;literal&gt;switch&lt;/literal&gt; statement has a
      condition and one or more pairs of case labels and associated
!     code.  The code associated with the case label whose value
      matches the condition is executed.  If no case label matches the
      condition, the default code, if present, is used.  In template
      programming, instantiating a template, e.g.,
*************** CreateLeaf&lt;Expression&lt;int&amp;closeclo
*** 956,964 ****
      default label since it matches any arguments.  If no set of
      template parameters match (which is impossible for our example) or
      if more than one set are best matches, the code is
!     incorrect.
!     &lt;indexterm class=&quot;endofrange&quot; startref=&quot;template_programming-pooma_implementation-index-control_flow&quot;&gt;
!     &lt;/indexterm&gt;&lt;/para&gt;
  
      &lt;para&gt;
      &lt;indexterm class=&quot;startofrange&quot; id=&quot;template_programming-pooma_implementation-function_template&quot;&gt;
--- 828,834 ----
      default label since it matches any arguments.  If no set of
      template parameters match (which is impossible for our example) or
      if more than one set are best matches, the code is
!     incorrect.&lt;indexterm class=&quot;endofrange&quot; startref=&quot;template_programming-pooma_implementation-index-control_flow&quot;&gt;&lt;/indexterm&gt;&lt;/para&gt;
  
      &lt;para&gt;
      &lt;indexterm class=&quot;startofrange&quot; id=&quot;template_programming-pooma_implementation-function_template&quot;&gt;
*************** void f(const T&amp; t) { &hellip; }
*** 983,1008 ****
      functions equivalent to &lt;function&gt;f(const int&amp;amp)&lt;/function&gt;,
      &lt;function&gt;f(const bool&amp;amp)&lt;/function&gt;, &lt;function&gt;f(const
      int*&amp;amp)&lt;/function&gt;, &hellip;.  Using a templated class
!     definition with a static member function,
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;static member&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;static member function&lt;/primary&gt;
!      &lt;see&gt;function, static member&lt;/see&gt;
!     &lt;/indexterm&gt;
!     we can define an equivalent function:
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;static member&lt;/secondary&gt;
!      &lt;tertiary&gt;equivalence with function template&lt;/tertiary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;function&lt;/secondary&gt;
!      &lt;tertiary&gt;equivalence with static member function&lt;/tertiary&gt;
!     &lt;/indexterm&gt;
  &lt;programlisting&gt;
  template &lt;typename T&gt;
  class F {
--- 853,859 ----
      functions equivalent to &lt;function&gt;f(const int&amp;amp)&lt;/function&gt;,
      &lt;function&gt;f(const bool&amp;amp)&lt;/function&gt;, &lt;function&gt;f(const
      int*&amp;amp)&lt;/function&gt;, &hellip;.  Using a templated class
!     definition with a static member function,&lt;indexterm&gt;&lt;primary&gt;function&lt;/primary&gt;&lt;secondary&gt;static member&lt;/secondary&gt;&lt;/indexterm&gt;&lt;indexterm&gt;&lt;primary&gt;static member function&lt;/primary&gt;&lt;see&gt;function, static member&lt;/see&gt;&lt;/indexterm&gt; we can define an equivalent function:&lt;indexterm&gt;&lt;primary&gt;function&lt;/primary&gt;&lt;secondary&gt;static member&lt;/secondary&gt;&lt;tertiary&gt;equivalence with function template&lt;/tertiary&gt;&lt;/indexterm&gt;&lt;indexterm&gt;&lt;primary&gt;template&lt;/primary&gt;&lt;secondary&gt;function&lt;/secondary&gt;&lt;tertiary&gt;equivalence with static member function&lt;/tertiary&gt;&lt;/indexterm&gt;
  &lt;programlisting&gt;
  template &lt;typename T&gt;
  class F {
*************** operator+(const Array&lt;D1,T1,E1&gt; &amp; 
*** 1036,1079 ****
      possible to write expressions such as &lt;literal&gt;a1 +
      a2&lt;/literal&gt;.  Member functions can also be templated.  This
      permits, for example, overloading of assignment operators defined
!     within templated classes.
!     &lt;indexterm class=&quot;endofrange&quot; startref=&quot;template_programming-pooma_implementation-function_template&quot;&gt;
!     &lt;/indexterm&gt;
!     &lt;/para&gt;
  
!     &lt;para&gt;Function objects
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;object&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     are frequently useful in run-time code.
      They consist of a function plus some additional storage and are
      usually implemented as structures with data members and a function
!     call operator.
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;call operator&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     Analogous classes can be used at compile time.
!     Using the transformation
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;static member&lt;/secondary&gt;
!      &lt;tertiary&gt;equivalence with function template&lt;/tertiary&gt;
!     &lt;/indexterm&gt;
!     &lt;indexterm&gt;
!      &lt;primary&gt;template&lt;/primary&gt;
!      &lt;secondary&gt;function&lt;/secondary&gt;
!      &lt;tertiary&gt;equivalence with static member function&lt;/tertiary&gt;
!     &lt;/indexterm&gt;
!     introduced in the previous paragraph, we
      see that any function can be transformed into a class containing a
!     static member function.
!     &lt;indexterm&gt;
!      &lt;primary&gt;function&lt;/primary&gt;
!      &lt;secondary&gt;static member&lt;/secondary&gt;
!     &lt;/indexterm&gt;
!     Internal type definitions, enumerations,
      and static constant values can be added to the class.  The static
      member function can use these values during its computation.  The
      &lt;type&gt;CreateLeaf&lt;/type&gt; structure, introduced above, illustrates this.
--- 887,901 ----
      possible to write expressions such as &lt;literal&gt;a1 +
      a2&lt;/literal&gt;.  Member functions can also be templated.  This
      permits, for example, overloading of assignment operators defined
!     within templated classes.&lt;indexterm class=&quot;endofrange&quot; startref=&quot;template_programming-pooma_implementation-function_template&quot;&gt;&lt;/indexterm&gt;&lt;/para&gt;
  
!     &lt;para&gt;Function objects&lt;indexterm&gt;&lt;primary&gt;function&lt;/primary&gt;&lt;secondary&gt;object&lt;/secondary&gt;&lt;/indexterm&gt; are frequently useful in run-time code.
      They consist of a function plus some additional storage and are
      usually implemented as structures with data members and a function
!     call operator.&lt;indexterm&gt;&lt;primary&gt;function&lt;/primary&gt;&lt;secondary&gt;call operator&lt;/secondary&gt;&lt;/indexterm&gt; Analogous classes can be used at compile time.
!     Using the transformation&lt;indexterm&gt;&lt;primary&gt;function&lt;/primary&gt;&lt;secondary&gt;static member&lt;/secondary&gt;&lt;tertiary&gt;equivalence with function template&lt;/tertiary&gt;&lt;/indexterm&gt;&lt;indexterm&gt;&lt;primary&gt;template&lt;/primary&gt;&lt;secondary&gt;function&lt;/secondary&gt;&lt;tertiary&gt;equivalence with static member function&lt;/tertiary&gt;&lt;/indexterm&gt; introduced in the previous paragraph, we
      see that any function can be transformed into a class containing a
!     static member function.&lt;indexterm&gt;&lt;primary&gt;function&lt;/primary&gt;&lt;secondary&gt;static member&lt;/secondary&gt;&lt;/indexterm&gt; Internal type definitions, enumerations,
      and static constant values can be added to the class.  The static
      member function can use these values during its computation.  The
      &lt;type&gt;CreateLeaf&lt;/type&gt; structure, introduced above, illustrates this.
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.12
diff -c -p -r1.12 tutorial.xml
*** tutorial.xml	2002/02/27 03:51:53	1.12
--- tutorial.xml	2002/03/15 23:07:22
***************
*** 690,696 ****
    each context.  Regardless, the containers' domains are now
    distributed among the contexts so the program can run.  When a patch
    needs data from another patch, the &poomatoolkit; sends messages to
!   the desired patch uses the message-passing library.  All such
    communication is automatically performed by the &toolkit; with no
    need for programmer or user input.&lt;/para&gt;
  
--- 690,696 ----
    each context.  Regardless, the containers' domains are now
    distributed among the contexts so the program can run.  When a patch
    needs data from another patch, the &poomatoolkit; sends messages to
!   the designated patch uses the message-passing library.  All such
    communication is automatically performed by the &toolkit; with no
    need for programmer or user input.&lt;/para&gt;
  
*************** MultiPatch&lt;UniformTag, Remote&lt;Bric
*** 737,743 ****
  &lt;/programlisting&gt; or
  &lt;programlisting&gt;
  MultiPatch&lt;UniformTag, Remote&lt;CompressibleBrick&closeclose;
! &lt;/programlisting&gt; or &engine;s.&lt;/para&gt;
  
    &lt;para&gt;The computations for a distributed implementation are exactly
    the same as for a sequential implementation.  The &poomatoolkit; and
--- 737,743 ----
  &lt;/programlisting&gt; or
  &lt;programlisting&gt;
  MultiPatch&lt;UniformTag, Remote&lt;CompressibleBrick&closeclose;
! &lt;/programlisting&gt; &engine;s.&lt;/para&gt;
  
    &lt;para&gt;The computations for a distributed implementation are exactly
    the same as for a sequential implementation.  The &poomatoolkit; and
Index: figures/distributed-101.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/distributed-101.png,v
retrieving revision 1.2
diff -c -p -r1.2 distributed-101.png
Binary files /tmp/cvsQn19cB and distributed-101.png differ
Index: figures/distributed.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/distributed.mp,v
retrieving revision 1.4
diff -c -p -r1.4 distributed.mp
*** figures/distributed.mp	2002/01/31 21:29:58	1.4
--- figures/distributed.mp	2002/03/15 23:07:23
*************** beginfig(101)
*** 184,190 ****
    foo = thelabel.bot(btex \begin{tabular}{c} Each context has memory and\\ processors to execute a program. \end{tabular} etex, c[1].s);
    unfill bbox foo;
    draw foo;
!   label.top(btex Computer Configuration etex, configurationBoundary.n);
  
    %% Draw the Computer Computation structures.
    for t = 0 upto 5:
--- 184,190 ----
    foo = thelabel.bot(btex \begin{tabular}{c} Each context has memory and\\ processors to execute a program. \end{tabular} etex, c[1].s);
    unfill bbox foo;
    draw foo;
!   label.top(btex Computer Con\avoidfi guration etex, configurationBoundary.n);
  
    %% Draw the Computer Computation structures.
    for t = 0 upto 5:
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000931.html">[pooma-dev] MakeOwnCopy problem
</A></li>
	<LI>Next message: <A HREF="000934.html">Patch: R2.4 Slides
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#933">[ date ]</a>
              <a href="thread.html#933">[ thread ]</a>
              <a href="subject.html#933">[ subject ]</a>
              <a href="author.html#933">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
