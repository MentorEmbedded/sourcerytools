<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Patch: More UML Class Diagrams
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Patch%3A%20More%20UML%20Class%20Diagrams&In-Reply-To=%3C20020304160049.A10244%40vaio.codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000923.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Patch: More UML Class Diagrams</H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Patch%3A%20More%20UML%20Class%20Diagrams&In-Reply-To=%3C20020304160049.A10244%40vaio.codesourcery.com%3E"
       TITLE="Patch: More UML Class Diagrams">oldham at codesourcery.com
       </A><BR>
    <I>Tue Mar  5 00:00:49 UTC 2002</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000923.html">Manual Patch: Automate Figure Creation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#922">[ date ]</a>
              <a href="thread.html#922">[ thread ]</a>
              <a href="subject.html#922">[ subject ]</a>
              <a href="author.html#922">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2002-Mar-04  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

This patch mainly finishes adding UML class diagrams to the manual.
	
	* Makefile (XMLSOURCES): Add uml.xml.
	* code.xml: Minor wordsmithing.
	* pooma.xml: Revised revision history.  Move UML class diagram
	code to separate file.
	* preface.xml: Minor wordsmithing.
	* starting.xml: Likewise.
	* template.xml: Remove extra space.
	* uml.xml: New file containing UML class diagrams.
	* figures/Makefile (UML_DIAGRAMS): Add nams of UML class diagrams.
	  Add rules for creating UML class diagrams.
	* figures/array-uml-1.png: New file containing a UML class diagram.
	* figures/array-uml-2.png: Likewise.
	* figures/array-uml-3.png: Likewise.
	* figures/array-uml.mp: Expand list of member functions.
	* figures/distributed-uml-10.png: New file containing a UML class
	diagram.
	* figures/distributed-uml-11.png: Likewise.
	* figures/distributed-uml-20.png: Likewise.
	* figures/distributed-uml-21.png: Likewise.
	* figures/distributed-uml-22.png: Likewise.
	* figures/distributed-uml-23.png: Likewise.
	* figures/distributed-uml-24.png: Likewise.
	* figures/distributed-uml-3.png: Likewise.
	* figures/distributed-uml-30.png: Likewise.
	* figures/distributed-uml-4.png: Likewise.
	* figures/distributed-uml-5.png: Likewise.
	* figures/distributed-uml.mp: New file describing class diagrams
	related to distributed computing.
	* figures/domain-uml-1.png: New file containing a UML class diagram.
	* figures/domain-uml.mp: Minor tweaking.
	* figures/engine-uml-1.png: New file containing a UML class diagram.
	* figures/engine-uml.mp: Rearrange layout of fig(1).
	* figures/explanation-uml-1.png: New file containing a UML class
	diagram.
	* figures/explanation-uml.mp: Slight revisions.
	* figures/field-uml-1.png: New file containing a UML class diagram.
	* figures/field-uml-10.png: Likewise.
	* figures/field-uml-11.png: Likewise.
	* figures/field-uml-2.png: Likewise.
	* figures/field-uml-3.png: Likewise.
	* figures/field-uml.mp: New file describing class diagrams for
	fields.
	* figures/introduction.mp: Remove extraneous comments.
	* figures/macros.ltx (\tilder): New command.
	* figures/math-objs-uml-1.png: New file containing a UML class diagram.
	* figures/math-objs-uml-10.png: Likewise.
	* figures/math-objs-uml-11.png: Likewise.
	* figures/math-objs-uml-2.png: Likewise.
	* figures/math-objs-uml-3.png: Likewise.
	* figures/math-objs-uml-4.png: Likewise.
	* figures/math-objs-uml.mp: New file describing class diagrams for
	vectors, tensors, and matrices.
	* figures/uml.mp (discriminatorLength): New value.

Applied to	mainline.

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: Makefile
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/Makefile,v
retrieving revision 1.8
diff -c -p -r1.8 Makefile
*** Makefile	2002/02/27 03:51:53	1.8
--- Makefile	2002/03/04 22:50:50
*************** MANUALNAME= pooma
*** 17,23 ****
  XMLSOURCES= $(MANUALNAME).xml preface.xml starting.xml \
  	    introduction.xml tutorial.xml \
              concepts.xml arrays.xml data-parallel.xml glossary.xml \
!             bibliography.xml template.xml code.xml
  
  # Create all versions of the manual.
  all: $(MANUALNAME).ps $(MANUALNAME).pdf $(MANUALNAME).html
--- 17,23 ----
  XMLSOURCES= $(MANUALNAME).xml preface.xml starting.xml \
  	    introduction.xml tutorial.xml \
              concepts.xml arrays.xml data-parallel.xml glossary.xml \
!             bibliography.xml template.xml code.xml uml.xml
  
  # Create all versions of the manual.
  all: $(MANUALNAME).ps $(MANUALNAME).pdf $(MANUALNAME).html
Index: code.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/code.xml,v
retrieving revision 1.1
diff -c -p -r1.1 code.xml
*** code.xml	2002/02/27 03:51:53	1.1
--- code.xml	2002/03/04 22:50:52
***************
*** 534,540 ****
  
      &lt;para&gt;Indentation follows the &lt;application class=&quot;software&quot;&gt;GNU
      Emacs&lt;/application&gt;'s &cc; mode guidelines.  Most increases in
!     indentation levels starts two characters to the right.&lt;/para&gt;
  
      &lt;para&gt;Most brackets, e.g., in function definitions, occur on
      separate lines.  Exceptions are for very short functions.&lt;/para&gt;
--- 534,540 ----
  
      &lt;para&gt;Indentation follows the &lt;application class=&quot;software&quot;&gt;GNU
      Emacs&lt;/application&gt;'s &cc; mode guidelines.  Most increases in
!     indentation levels start two characters to the right.&lt;/para&gt;
  
      &lt;para&gt;Most brackets, e.g., in function definitions, occur on
      separate lines.  Exceptions are for very short functions.&lt;/para&gt;
***************
*** 604,610 ****
     &lt;section id=&quot;sources-conventions-globals&quot;&gt;
      &lt;title&gt;Global Variables&lt;/title&gt;
  
!     &lt;para&gt;Global variables are avoided whenever possible.&lt;/para&gt;
     &lt;/section&gt;
  
  
--- 604,614 ----
     &lt;section id=&quot;sources-conventions-globals&quot;&gt;
      &lt;title&gt;Global Variables&lt;/title&gt;
  
!     &lt;para&gt;Global variables are avoided whenever possible.  Where
!     necessary, their names are the concatenation of capitalized words
!     such that the first word is not capitalized and a suffix of
!     &lt;filename class=&quot;libraryfile&quot;&gt;_g&lt;/filename&gt; is appended, e.g.,
!     &lt;literal&gt;veryFewGlobalVariables_g&lt;/literal&gt;.&lt;/para&gt;
     &lt;/section&gt;
  
  
***************
*** 804,810 ****
     &lt;section id=&quot;sources-conventions-errors&quot;&gt;
      &lt;title&gt;Errors and Exceptions&lt;/title&gt;
  
!     &lt;para&gt;&pooma; code uses very few exception since not all &cc;
      compilers adequately support exceptions.  Thus, all uses must also
      have corresponding code not using exceptions.  See, e.g.,
      &lt;literal&gt;POOMA_EXCEPTIONS&lt;/literal&gt; in the code.&lt;/para&gt;
--- 808,814 ----
     &lt;section id=&quot;sources-conventions-errors&quot;&gt;
      &lt;title&gt;Errors and Exceptions&lt;/title&gt;
  
!     &lt;para&gt;&pooma; code uses very few exceptions since not all &cc;
      compilers adequately support exceptions.  Thus, all uses must also
      have corresponding code not using exceptions.  See, e.g.,
      &lt;literal&gt;POOMA_EXCEPTIONS&lt;/literal&gt; in the code.&lt;/para&gt;
Index: pooma.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/pooma.xml,v
retrieving revision 1.4
diff -c -p -r1.4 pooma.xml
*** pooma.xml	2002/02/27 03:51:53	1.4
--- pooma.xml	2002/03/04 22:50:55
***************
*** 95,100 ****
--- 95,102 ----
    &lt;!-- The C++ boolean type. --&gt;
  &lt;!ENTITY brick &quot;&lt;type&gt;Brick&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;Brick&quot; engine type. --&gt;
+ &lt;!ENTITY centering &quot;&lt;type&gt;Centering&lt;/type&gt;&quot;&gt;
+   &lt;!-- The centering type. --&gt;
  &lt;!ENTITY char &quot;&lt;type&gt;char&lt;/type&gt;&quot;&gt;
    &lt;!-- The C char type. --&gt;
  &lt;!ENTITY complex &quot;&lt;type&gt;complex&lt;/type&gt;&quot;&gt;
***************
*** 148,153 ****
--- 150,157 ----
    &lt;!-- The &quot;Loc&lt;1&gt;&quot; one-dimensional domain type. --&gt;
  &lt;!ENTITY matrix &quot;&lt;type&gt;TinyMatrix&lt;/type&gt;&quot;&gt;
    &lt;!-- The Pooma matrix type. --&gt;
+ &lt;!ENTITY mesh &quot;&lt;type&gt;Mesh&lt;/type&gt;&quot;&gt;
+   &lt;!-- The &quot;Mesh&quot; type. --&gt;
  &lt;!ENTITY multipatch &quot;&lt;type&gt;MultiPatch&lt;/type&gt;&quot;&gt;
    &lt;!-- The &quot;MultiPatch&quot; engine without template parameters. --&gt;
  &lt;!ENTITY options &quot;&lt;type&gt;Options&lt;/type&gt;&quot;&gt;
***************
*** 251,256 ****
--- 255,262 ----
    &lt;!-- template programming appendix --&gt;
  &lt;!ENTITY tutorial-chapter SYSTEM &quot;tutorial.xml&quot;&gt;
    &lt;!-- Doof2d tutorial programs chapter --&gt;
+ &lt;!ENTITY uml-appendix SYSTEM &quot;uml.xml&quot;&gt;
+   &lt;!-- appendix of UML class diagrams --&gt;
  
  &lt;!-- External File Entities --&gt;
  &lt;!-- Doof2d Programs --&gt;
***************
*** 304,311 ****
    &lt;/legalnotice&gt;
    &lt;revhistory&gt;
     &lt;revision&gt;
      &lt;revnumber&gt;1.00&lt;/revnumber&gt;
!     &lt;date&gt;2002 Jan 31&lt;/date&gt;
      &lt;authorinitials&gt;jdo&lt;/authorinitials&gt;
      &lt;revremark&gt;First publication.&lt;/revremark&gt;
     &lt;/revision&gt;
--- 310,325 ----
    &lt;/legalnotice&gt;
    &lt;revhistory&gt;
     &lt;revision&gt;
+     &lt;revnumber&gt;1.01&lt;/revnumber&gt;
+     &lt;date&gt;2002 Mar&nbsp;01&lt;/date&gt;
+     &lt;authorinitials&gt;jdo&lt;/authorinitials&gt;
+     &lt;revremark&gt;Added UML class diagrams, revised compilation
+     directions, and added a description of the source code
+     structure.&lt;/revremark&gt;
+    &lt;/revision&gt;
+    &lt;revision&gt;
      &lt;revnumber&gt;1.00&lt;/revnumber&gt;
!     &lt;date&gt;2002 Jan&nbsp;31&lt;/date&gt;
      &lt;authorinitials&gt;jdo&lt;/authorinitials&gt;
      &lt;revremark&gt;First publication.&lt;/revremark&gt;
     &lt;/revision&gt;
*************** a(I,J) = (1.0/9.0) *
*** 1002,1009 ****
       architecture-specific initialization.  The function always
       returns &true;.&lt;/para&gt;
  
- HERE
- 
       &lt;para&gt;&lt;function&gt;initialize&lt;/function&gt;'s alternative form
       assumes the &pooma;-specific and architecture-specific
       command-line arguments have already been removed from
--- 1016,1021 ----
*************** UNFINISHED&lt;/para&gt;
*** 3680,3915 ****
   &amp;template-appendix;
  
   &amp;code-appendix;
- 
- 
-  &lt;appendix id=&quot;uml&quot;&gt;
-   &lt;title&gt;&uml; Class Diagrams&lt;/title&gt;
- 
-   &lt;para&gt;In this chapter, we present Unified Modeling Language (&uml;)
-   class diagrams.  These are created at the
-   &lt;firstterm&gt;specification&lt;/firstterm&gt; level, which indicates the
-   software interface, not its implementation.  Readers interested in
-   the implementation are encouraged to read the corresponding source
-   code.  More extensive explanations of these classes appear in the
-   main chapters of this &book;.&lt;/para&gt;
- 
-   &lt;figure float=&quot;1&quot; id=&quot;uml-explanation&quot;&gt;
-    &lt;title&gt;Explanation of &uml; Class Diagrams&lt;/title&gt;
-    &lt;mediaobject&gt;
-     &lt;imageobject&gt;
-      &lt;imagedata fileref=&quot;figures/explanation-uml.1&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
-     &lt;/imageobject&gt;
-     &lt;imageobject&gt;
-      &lt;imagedata fileref=&quot;figures/explanation-uml-1.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
-     &lt;/imageobject&gt;
-     &lt;textobject&gt;
-      &lt;phrase&gt;An Explanation of UML Class Diagrams&lt;/phrase&gt;
-     &lt;/textobject&gt;
-    &lt;/mediaobject&gt;
-   &lt;/figure&gt;
- 
-   &lt;para&gt;&lt;xref linkend=&quot;uml-explanation&quot;&gt;&lt;/xref&gt; illustrates a typical
-   &uml; class diagram.  The diagram has three classes:
-   &lt;type&gt;Classname1&lt;/type&gt;, &lt;type&gt;Classname2&lt;/type&gt;, and
-   &lt;type&gt;Classname2&lt;1&gt;&lt;/type&gt;.  Most classes are represented by
-   three-part boxes.  The top part lists the class's name.  The middle
-   part lists public data members, if any.  Few &pooma; classes have
-   public data members so this section is frequently empty.  The bottom
-   part lists public member functions, if any.
-   &lt;type&gt;Classname2&lt;1&gt;&lt;/type&gt; has only one part, not three.  Its
-   three-part box appears in another diagram, presumably because there
-   is not enough room in this one.  Both &lt;type&gt;Classname1&lt;/type&gt; and
-   &lt;type&gt;Classname2&lt;/type&gt; have template parameters, each named
-   &lt;type&gt;T&lt;/type&gt;.  These occur in dashed boxes at the upper-right
-   corner of the class boxes.  Files implementing a class are listed at
-   the lower, right corner of the class's box; this is not standard UML
-   notation.&lt;/para&gt;
- 
-   &lt;para&gt;Lines connect classes.  The solid arrow with large triangular
-   arrowhead indicates that &lt;type&gt;Classname2&lt;/type&gt; is a subtype of
-   &lt;type&gt;Classname1&lt;/type&gt;.  Since this diagram represents the
-   specification level, subtyping does not necessarily correspond to
-   &cc; type inheritance.  Also, subtype class boxes need only list
-   members not available in the supertype.  For this case,
-   &lt;type&gt;Classname2&lt;/type&gt; has no new members not provided by
-   &lt;type&gt;Classname1&lt;/type&gt;.  A dashed arrow indicates a class formed by
-   a template instantiation.  The class name indicates which template
-   parameters are bound.  For example, &lt;type&gt;Classname2&lt;1&gt;&lt;/type&gt;
-   instantiates &lt;type&gt;Classname2&lt;/type&gt; with &lt;type&gt;T&lt;/type&gt; equal
-   to&nbsp;1.&lt;/para&gt;
- 
-   &lt;para&gt;These diagrams omit a lot of details.  Private and protected
-   data members are not listed.  Compile-time types and values are not
-   listed.  No indication is given of the actual implementation.&lt;/para&gt;
- 
- 
-   &lt;section id=&quot;uml-arrays&quot;&gt;
-    &lt;title&gt;&array;s&lt;/title&gt;
- 
-    &lt;figure float=&quot;1&quot; id=&quot;uml-array_dynamicarray&quot;&gt;
-     &lt;title&gt;Relationship Between &array; and &dynamicarray;s&lt;/title&gt;
-     &lt;mediaobject&gt;
-      &lt;imageobject&gt;
-       &lt;imagedata fileref=&quot;figures/array-uml.1&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
-      &lt;/imageobject&gt;
-      &lt;imageobject&gt;
-       &lt;imagedata fileref=&quot;figures/array-uml-1.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
-      &lt;/imageobject&gt;
-      &lt;textobject&gt;
-       &lt;phrase&gt;&dynamicarray;s are subtypes of &array;s&lt;/phrase&gt;
-      &lt;/textobject&gt;
-     &lt;/mediaobject&gt;
-    &lt;/figure&gt;
-    
-    &lt;para&gt;Both &array;s and &dynamicarray;s have so many member
-    functions that their class boxes appear in separate diagrams.
-    &lt;xref linkend=&quot;uml-array_dynamicarray&quot;&gt;&lt;/xref&gt; indicates that
-    &dynamicarray;s are subtypes of &array;s.  Both have value type and
-    engine tag template parameters but &dynamicarray;'s dimension must
-    be one.&lt;/para&gt;
- 
-    &lt;figure float=&quot;1&quot; id=&quot;uml-array&quot;&gt;
-     &lt;title&gt;&array; Diagram&lt;/title&gt;
-     &lt;mediaobject&gt;
-      &lt;imageobject&gt;
-       &lt;imagedata fileref=&quot;figures/array-uml.2&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
-      &lt;/imageobject&gt;
-      &lt;imageobject&gt;
-       &lt;imagedata fileref=&quot;figures/array-uml-2.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
-      &lt;/imageobject&gt;
-      &lt;textobject&gt;
-       &lt;phrase&gt;&array; Class Diagram&lt;/phrase&gt;
-      &lt;/textobject&gt;
-     &lt;/mediaobject&gt;
-    &lt;/figure&gt;
- 
-    &lt;figure float=&quot;1&quot; id=&quot;uml-dynamicarray&quot;&gt;
-     &lt;title&gt;&dynamicarray; Diagram&lt;/title&gt;
-     &lt;mediaobject&gt;
-      &lt;imageobject&gt;
-       &lt;imagedata fileref=&quot;figures/array-uml.3&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
-      &lt;/imageobject&gt;
-      &lt;imageobject&gt;
-       &lt;imagedata fileref=&quot;figures/array-uml-3.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
-      &lt;/imageobject&gt;
-      &lt;textobject&gt;
-       &lt;phrase&gt;&dynamicarray; Class Diagram&lt;/phrase&gt;
-      &lt;/textobject&gt;
-     &lt;/mediaobject&gt;
-    &lt;/figure&gt;
-   &lt;/section&gt;
  
! 
!   &lt;section id=&quot;uml-domains&quot;&gt;
!    &lt;title&gt;&domain;s&lt;/title&gt;
! 
!    &lt;para&gt;&domain;s and its subtypes are shown in &lt;xref
!    linkend=&quot;uml-domains_figure&quot;&gt;&lt;/xref&gt;.  All classes are instantiated
!    from or subtypes of &domain;.  As mentioned in &lt;xref
!    linkend=&quot;arrays-domains&quot;&gt;&lt;/xref&gt;, the &lt;type&gt;Domain&lt;1&gt;&lt;/type&gt;
!    template instantiation has additional member functions.  It uses
!    the &lt;type&gt;Domain&lt;1&gt;::iterator&lt;/type&gt;.  The four &domain;
!    subtypes appear in the bottom half of the figure.  Each requires
!    the same template parameter as &domain;.  Each of these has a
!    template instantiation for the one-dimensional case.  We omit
!    listing their additional member functions since these are the same
!    as for &lt;type&gt;Domain&lt;1&gt;&lt;/type&gt;.&lt;/para&gt;
! 
!    &lt;figure float=&quot;1&quot; id=&quot;uml-domains_figure&quot;&gt;
!     &lt;title&gt;&domain;s&lt;/title&gt;
!     &lt;mediaobject&gt;
!      &lt;imageobject&gt;
!       &lt;imagedata fileref=&quot;figures/domain-uml.1&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!      &lt;/imageobject&gt;
!      &lt;imageobject&gt;
!       &lt;imagedata fileref=&quot;figures/domain-uml-1.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!      &lt;/imageobject&gt;
!      &lt;textobject&gt;
!       &lt;phrase&gt;&domain;s&lt;/phrase&gt;
!      &lt;/textobject&gt;
!     &lt;/mediaobject&gt;
!    &lt;/figure&gt;
!    
!   &lt;/section&gt;
! 
! 
!   &lt;section id=&quot;uml-engines&quot;&gt;
!    &lt;title&gt;&engine;s&lt;/title&gt;
! 
!    &lt;para&gt;&engine;s and its subtypes are shown in &lt;xref
!    linkend=&quot;uml-engines-figure&quot;&gt;&lt;/xref&gt;.  Five subtypes of &engine;s
!    are shown.  Details appear in subsequent diagrams.  The
!    &lt;type&gt;Engine&lt;/type&gt; class box shows no members because it has no
!    members.  Only subtypes have members.  More explanation of these
!    classes can be found in &lt;xref linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.  The
!    implementation files in &lt;xref
!    linkend=&quot;uml-engines-brick_figure&quot;&gt;&lt;/xref&gt; use the
!    &lt;literal&gt;[1-7]&lt;/literal&gt; regular expression to indicate 1, 2,
!    &hellip;, or&nbsp;7.&lt;/para&gt;
! 
!    &lt;figure float=&quot;1&quot; id=&quot;uml-engines-figure&quot;&gt;
!     &lt;title&gt;&engine;s&lt;/title&gt;
!     &lt;mediaobject&gt;
!      &lt;imageobject&gt;
!       &lt;imagedata fileref=&quot;figures/engine-uml.1&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!      &lt;/imageobject&gt;
!      &lt;imageobject&gt;
!       &lt;imagedata fileref=&quot;figures/engine-uml-1.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!      &lt;/imageobject&gt;
!      &lt;textobject&gt;
!       &lt;phrase&gt;Relationships among &engine;s&lt;/phrase&gt;
!      &lt;/textobject&gt;
!     &lt;/mediaobject&gt;
!    &lt;/figure&gt;
! 
!    &lt;figure float=&quot;1&quot; id=&quot;uml-engines-brick_figure&quot;&gt;
!     &lt;title&gt;&brick; and &compressiblebrick; &engine;s&lt;/title&gt;
!     &lt;mediaobject&gt;
!      &lt;imageobject&gt;
!       &lt;imagedata fileref=&quot;figures/engine-uml.2&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!      &lt;/imageobject&gt;
!      &lt;imageobject&gt;
!       &lt;imagedata fileref=&quot;figures/engine-uml-2.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!      &lt;/imageobject&gt;
!      &lt;textobject&gt;
!       &lt;phrase&gt;&brick; and &compressiblebrick; &engine;s&lt;/phrase&gt;
!      &lt;/textobject&gt;
!     &lt;/mediaobject&gt;
!    &lt;/figure&gt;
! 
!    &lt;figure float=&quot;1&quot; id=&quot;uml-engines-dynamic_figure&quot;&gt;
!     &lt;title&gt;&dynamic; and &multipatch; &engine;s&lt;/title&gt;
!     &lt;mediaobject&gt;
!      &lt;imageobject&gt;
!       &lt;imagedata fileref=&quot;figures/engine-uml.3&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!      &lt;/imageobject&gt;
!      &lt;imageobject&gt;
!       &lt;imagedata fileref=&quot;figures/engine-uml-3.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!      &lt;/imageobject&gt;
!      &lt;textobject&gt;
!       &lt;phrase&gt;&dynamic; and &multipatch; &engine;s&lt;/phrase&gt;
!      &lt;/textobject&gt;
!     &lt;/mediaobject&gt;
!    &lt;/figure&gt;
! 
!    &lt;figure float=&quot;1&quot; id=&quot;uml-engines-remote_figure&quot;&gt;
!     &lt;title&gt;&remote; &engine;s&lt;/title&gt;
!     &lt;mediaobject&gt;
!      &lt;imageobject&gt;
!       &lt;imagedata fileref=&quot;figures/engine-uml.4&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!      &lt;/imageobject&gt;
!      &lt;imageobject&gt;
!       &lt;imagedata fileref=&quot;figures/engine-uml-4.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!      &lt;/imageobject&gt;
!      &lt;textobject&gt;
!       &lt;phrase&gt;&remote; &engine;s&lt;/phrase&gt;
!      &lt;/textobject&gt;
!     &lt;/mediaobject&gt;
!    &lt;/figure&gt;
!    
!   &lt;/section&gt;
!    
!  &lt;/appendix&gt;
  
  
  &lt;![%unfinished;[
--- 3692,3699 ----
   &amp;template-appendix;
  
   &amp;code-appendix;
  
!  &amp;uml-appendix;
  
  
  &lt;![%unfinished;[
Index: preface.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/preface.xml,v
retrieving revision 1.1
diff -c -p -r1.1 preface.xml
*** preface.xml	2002/02/27 03:51:53	1.1
--- preface.xml	2002/03/04 22:50:55
***************
*** 30,36 ****
    Readers will need to be familiar with &cc;, the language in which
    &pooma; programs are written.  Classes, objects, function objects,
    template classes, and template functions will all be used.  Appendix
!   &lt;!-- FIXME: Add appendix reference --&gt; FIXME contains a short
    introduction to template programming.  Readers needing more
    background material might want to read Koenig and Moo's
    &lt;emphasis&gt;Accelerated &cc;&lt;/emphasis&gt;, Stanley Lippman's
--- 30,36 ----
    Readers will need to be familiar with &cc;, the language in which
    &pooma; programs are written.  Classes, objects, function objects,
    template classes, and template functions will all be used.  Appendix
!   &lt;xref linkend=&quot;template_programming&quot;&gt;&lt;/xref&gt; contains a short
    introduction to template programming.  Readers needing more
    background material might want to read Koenig and Moo's
    &lt;emphasis&gt;Accelerated &cc;&lt;/emphasis&gt;, Stanley Lippman's
***************
*** 375,381 ****
  
    &lt;!-- We cheat and abuse an epigraph here. --&gt;
    &lt;epigraph&gt;
!    &lt;attribution&gt;Jeffrey&nbsp;D. Oldham, 2002&nbsp;February&lt;/attribution&gt;
     &lt;para&gt;&lt;/para&gt;
    &lt;/epigraph&gt;
  
--- 375,381 ----
  
    &lt;!-- We cheat and abuse an epigraph here. --&gt;
    &lt;epigraph&gt;
!    &lt;attribution&gt;Jeffrey&nbsp;D. Oldham, 2002&nbsp;March&lt;/attribution&gt;
     &lt;para&gt;&lt;/para&gt;
    &lt;/epigraph&gt;
  
Index: starting.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/starting.xml,v
retrieving revision 1.1
diff -c -p -r1.1 starting.xml
*** starting.xml	2002/02/27 03:51:53	1.1
--- starting.xml	2002/03/04 22:50:55
***************
*** 5,11 ****
    for use, and then compile a &lt;quote&gt;Hello, &pooma;&lt;/quote&gt;
    program.  Impatient readers will find the first section helpful.
    Those desiring more details will find this section provides a useful
!   overview of the chapter.&lt;/para&gt;
  
  
    &lt;section id=&quot;initial-quick_start&quot;&gt;
--- 5,11 ----
    for use, and then compile a &lt;quote&gt;Hello, &pooma;&lt;/quote&gt;
    program.  Impatient readers will find the first section helpful.
    Those desiring more details will find this section provides a useful
!   overview of the chapter although it can be skipped.&lt;/para&gt;
  
  
    &lt;section id=&quot;initial-quick_start&quot;&gt;
***************
*** 39,45 ****
        indicates the operating system and compiler.  Permitted choices
        are the names of files in the &lt;filename
        class=&quot;directory&quot;&gt;config/arch/&lt;/filename&gt; subdirectory omitting
!       the &lt;filename class=&quot;libraryfile&quot;&gt;.conf&lt;/filename&gt; suffix.&lt;/para&gt;
       &lt;/listitem&gt;
      &lt;/varlistentry&gt;
      &lt;varlistentry&gt;
--- 39,45 ----
        indicates the operating system and compiler.  Permitted choices
        are the names of files in the &lt;filename
        class=&quot;directory&quot;&gt;config/arch/&lt;/filename&gt; subdirectory omitting
!       the &lt;filename class=&quot;libraryfile&quot;&gt;.conf&lt;/filename&gt; suffixes.&lt;/para&gt;
       &lt;/listitem&gt;
      &lt;/varlistentry&gt;
      &lt;varlistentry&gt;
***************
*** 60,69 ****
        program available at &lt;filename
        class=&quot;libraryfile&quot;&gt;examples/Manual/Sequential/initialize-finalize.cpp&lt;/filename&gt;:&lt;programlisting&gt;
  &initialspace;export POOMAHOME=/home/oldham/pooma/pooma1
! &initialspace;g++ -I${POOMAHOME}/src -I${POOMAHOME}/lib/${POOMASUITE} initialize-finalize.cpp -o initialize-finalize -L${POOMAHOME}/lib/${POOMASUITE} -lpooma-gcc
  &lt;/programlisting&gt;
!       The environment variable indicates the location of the &toolkit;
!       header files and the library.&lt;/para&gt;
       &lt;/listitem&gt;
      &lt;/varlistentry&gt;
     &lt;/variablelist&gt;
--- 60,73 ----
        program available at &lt;filename
        class=&quot;libraryfile&quot;&gt;examples/Manual/Sequential/initialize-finalize.cpp&lt;/filename&gt;:&lt;programlisting&gt;
  &initialspace;export POOMAHOME=/home/oldham/pooma/pooma1
! &initialspace;g++ -I${POOMAHOME}/src \
! &initialspace;-I${POOMAHOME}/lib/${POOMASUITE} \
! &initialspace;initialize-finalize.cpp \
! &initialspace;-o initialize-finalize \
! &initialspace;-L${POOMAHOME}/lib/${POOMASUITE} -lpooma-gcc
  &lt;/programlisting&gt;
!       The &lt;envar&gt;POOMAHOME&lt;/envar&gt; environment variable indicates the
!       location of the &toolkit; header files and the library.&lt;/para&gt;
       &lt;/listitem&gt;
      &lt;/varlistentry&gt;
     &lt;/variablelist&gt;
***************
*** 113,121 ****
     operating system with &kcc;.&lt;/para&gt;
  
     &lt;para&gt;To configure the source code, use a command
!    like&lt;programlisting&gt; &initialspace;./configure &dashdash;arch
!    LINUXgcc &dashdash;opt &dashdash;suite LINUXgcc-opt
!    &lt;/programlisting&gt; The architecture argument to the
     &lt;command&gt;&dashdash;arch&lt;/command&gt; option is the name of the
     corresponding configuration file, omitting its &lt;filename
     class=&quot;libraryfile&quot;&gt;.conf&lt;/filename&gt; suffix.  The
--- 117,125 ----
     operating system with &kcc;.&lt;/para&gt;
  
     &lt;para&gt;To configure the source code, use a command
!    like&lt;programlisting&gt;
! &initialspace;./configure &dashdash;arch LINUXgcc &dashdash;opt &dashdash;suite LINUXgcc-opt
! &lt;/programlisting&gt; The architecture argument to the
     &lt;command&gt;&dashdash;arch&lt;/command&gt; option is the name of the
     corresponding configuration file, omitting its &lt;filename
     class=&quot;libraryfile&quot;&gt;.conf&lt;/filename&gt; suffix.  The
***************
*** 137,152 ****
     need to be compiled.  Specify the desired suite by setting the
     &lt;envar&gt;POOMASUITE&lt;/envar&gt; environment variable to the appropriate
     value.  For example, if using the &lt;application&gt;bash&lt;/application&gt;
!    shell, use&lt;programlisting&gt; &initialspace;export
!    POOMASUITE=&lt;replaceable&gt;suiteName&lt;/replaceable&gt; &lt;/programlisting&gt;
!    substituting the suite name's &lt;replaceable&gt;suiteName&lt;/replaceable&gt;.
     If using the &lt;application&gt;csh&lt;/application&gt; shell,
!    use&lt;programlisting&gt; &initialspace;setenv POOMASUITE
!    &lt;replaceable&gt;suiteName&lt;/replaceable&gt; &lt;/programlisting&gt; In the
     previous paragraph, the suite name is
     &lt;literal&gt;LINUXgcc-opt&lt;/literal&gt; so we would issue the
!    statement&lt;programlisting&gt; &initialspace;setenv POOMASUITE
!    LINUXgcc-opt &lt;/programlisting&gt;&lt;/para&gt;
  
     &lt;para&gt;Issuing the &lt;command&gt;make&lt;/command&gt; command compiles the
     &pooma; source code files to create the &pooma; library.  The
--- 141,158 ----
     need to be compiled.  Specify the desired suite by setting the
     &lt;envar&gt;POOMASUITE&lt;/envar&gt; environment variable to the appropriate
     value.  For example, if using the &lt;application&gt;bash&lt;/application&gt;
!    shell, use&lt;programlisting&gt;
! &initialspace;export POOMASUITE=&lt;replaceable&gt;suiteName&lt;/replaceable&gt;
! &lt;/programlisting&gt; substituting the suite name's &lt;replaceable&gt;suiteName&lt;/replaceable&gt;.
     If using the &lt;application&gt;csh&lt;/application&gt; shell,
!    use&lt;programlisting&gt;
! &initialspace;setenv POOMASUITE &lt;replaceable&gt;suiteName&lt;/replaceable&gt;
! &lt;/programlisting&gt; In the
     previous paragraph, the suite name is
     &lt;literal&gt;LINUXgcc-opt&lt;/literal&gt; so we would issue the
!    statement&lt;programlisting&gt;
! &initialspace;setenv POOMASUITE LINUXgcc-opt
! &lt;/programlisting&gt;&lt;/para&gt;
  
     &lt;para&gt;Issuing the &lt;command&gt;make&lt;/command&gt; command compiles the
     &pooma; source code files to create the &pooma; library.  The
***************
*** 158,164 ****
     class=&quot;libraryfile&quot;&gt;lib/LINUXgcc-opt/libpooma-gcc.a&lt;/filename&gt;.  If
     it fails, the makefiles will print a line indicating which file
     failed to compile.  Reading the corresponding &lt;filename
!    class=&quot;libraryfile&quot;&gt;.info&lt;/filename&gt; may indicate what
     failed.&lt;/para&gt;
  
     &lt;para&gt;The same &pooma; source code can support multiple suites as
--- 164,170 ----
     class=&quot;libraryfile&quot;&gt;lib/LINUXgcc-opt/libpooma-gcc.a&lt;/filename&gt;.  If
     it fails, the makefiles will print a line indicating which file
     failed to compile.  Reading the corresponding &lt;filename
!    class=&quot;libraryfile&quot;&gt;.info&lt;/filename&gt; file may indicate what
     failed.&lt;/para&gt;
  
     &lt;para&gt;The same &pooma; source code can support multiple suites as
***************
*** 188,195 ****
      &lt;para&gt;The configuration script supports many more command-line
      options than the two used above, but few &pooma; users need use
      them except those using distributed &pooma;, which are described
!     below.  &lt;command&gt;/configure -h&lt;/command&gt; yields a complete list.
!     We describe also describe them here.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
             orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;initial-compile-configuration_options-table&quot;&gt;
--- 194,201 ----
      &lt;para&gt;The configuration script supports many more command-line
      options than the two used above, but few &pooma; users need use
      them except those using distributed &pooma;, which are described
!     below.  &lt;command&gt;./configure -h&lt;/command&gt; yields a complete list.
!     We also describe them here.&lt;/para&gt;
  
      &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
             orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;initial-compile-configuration_options-table&quot;&gt;
***************
*** 220,226 ****
  	 The environment variable &lt;envar&gt;POOMASUITE&lt;/envar&gt;'s value
  	 should equal &lt;replaceable&gt;suite&lt;/replaceable&gt; when compiling
  	 the library.  &lt;replaceable&gt;suite&lt;/replaceable&gt; can be any
! 	 string that an serve as a filename.  If this option is
  	 omitted, the &lt;literal&gt;&dashdash;arch&lt;/literal&gt; architecture
  	 is used.&lt;/entry&gt;
  	&lt;/row&gt;
--- 226,232 ----
  	 The environment variable &lt;envar&gt;POOMASUITE&lt;/envar&gt;'s value
  	 should equal &lt;replaceable&gt;suite&lt;/replaceable&gt; when compiling
  	 the library.  &lt;replaceable&gt;suite&lt;/replaceable&gt; can be any
! 	 string that can serve as a filename.  If this option is
  	 omitted, the &lt;literal&gt;&dashdash;arch&lt;/literal&gt; architecture
  	 is used.&lt;/entry&gt;
  	&lt;/row&gt;
***************
*** 427,434 ****
         &lt;row&gt;
  	&lt;entry&gt;&lt;literal&gt;&dashdash;messaging&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;enables creation of distributed &pooma; executables by
! 	enabling use of the &cheetah; communications package.  See
! 	&lt;!-- FIXME: add reference to the distributed configuration
  	section. --&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
--- 433,439 ----
         &lt;row&gt;
  	&lt;entry&gt;&lt;literal&gt;&dashdash;messaging&lt;/literal&gt;&lt;/entry&gt;
  	&lt;entry&gt;enables creation of distributed &pooma; executables by
! 	enabling use of the &cheetah; communications package.  &lt;!-- FIXME: &quot;See&quot; add reference to the distributed configuration
  	section. --&gt;&lt;/entry&gt;
         &lt;/row&gt;
         &lt;row rowsep=&quot;1&quot;&gt;
***************
*** 474,479 ****
--- 479,498 ----
     program that initializes and de-initializes the &pooma;
     library.&lt;/para&gt;
  
+    &lt;para&gt;The simplest &pooma; program is available at &lt;filename
+    class=&quot;libraryfile&quot;&gt;examples/Manual/Sequential/initialize-finalize.cpp&lt;/filename&gt;.
+    It is annotated in &lt;xref
+    linkend=&quot;initial-compile_programs-hello_pooma&quot;&gt;&lt;/xref&gt;.  Before its
+    use, the &poomatoolkit; must be initialized by a call to
+    &lt;function&gt;initialize&lt;/function&gt;.  This usually occurs in the
+    &lt;function&gt;main&lt;/function&gt; function.  After its use, the
+    &poomatoolkit; should be shut down using a call to
+    &lt;function&gt;finalize&lt;/function&gt;.  This also usually occurs in the
+    &lt;function&gt;main&lt;/function&gt; function.  Both of these functions are
+    declared in &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Pooma.h&lt;/filename&gt;.
+    This header file (or another &pooma; header file including it)
+    occurs in every &pooma; program.&lt;/para&gt;
+ 
     &lt;example id=&quot;initial-compile_programs-hello_pooma&quot;&gt;
      &lt;title&gt;A &lt;quote&gt;Hello, &pooma;&lt;/quote&gt; Program&lt;/title&gt;
  
***************
*** 495,514 ****
      &lt;/calloutlist&gt;
     &lt;/example&gt;
  
-    &lt;para&gt;The simplest &pooma; program is available at &lt;filename
-    class=&quot;libraryfile&quot;&gt;examples/Manual/Sequential/initialize-finalize.cpp&lt;/filename&gt;.
-    It is annotated in &lt;xref
-    linkend=&quot;initial-compile_programs-hello_pooma&quot;&gt;&lt;/xref&gt;.  Before its
-    use, the &poomatoolkit; must be initialized by a call to
-    &lt;function&gt;initialize&lt;/function&gt;.  This usually occurs in the
-    &lt;function&gt;main&lt;/function&gt; function.  After its use, the
-    &poomatoolkit; should be shut down using a call to
-    &lt;function&gt;finalize&lt;/function&gt;.  This also usually occurs in the
-    &lt;function&gt;main&lt;/function&gt; function.  Both of these functions are
-    declared in &lt;filename class=&quot;headerfile&quot;&gt;Pooma/Pooma.h&lt;/filename&gt;.
-    This header file or another &pooma; header file including it occurs
-    in every &pooma; program.&lt;/para&gt;
- 
     &lt;para&gt;Compiling this program requires including &pooma; header
     files and library.  Let us assume that the environment variable
     &lt;envar&gt;POOMAHOME&lt;/envar&gt; describes the location of the &pooma;
--- 514,519 ----
***************
*** 516,522 ****
  &initialspace;export POOMAHOME=/home/user/pooma
  &lt;/programlisting&gt;  We illustrate how to compile the program using the
     &gpp; compiler:&lt;programlisting&gt;
! &initialspace;g++ -I${POOMAHOME}/src -I${POOMAHOME}/lib/LINUXgcc initialize-finalize.cpp -o initialize-finalize -L${POOMAHOME}/lib/${POOMASUITE} -lpooma-gcc
  &lt;/programlisting&gt;  We explain the five command-line options:
      &lt;variablelist&gt;
       &lt;varlistentry&gt;
--- 521,529 ----
  &initialspace;export POOMAHOME=/home/user/pooma
  &lt;/programlisting&gt;  We illustrate how to compile the program using the
     &gpp; compiler:&lt;programlisting&gt;
! &initialspace;g++ -I${POOMAHOME}/src -I${POOMAHOME}/lib/LINUXgcc \
! &initialspace;initialize-finalize.cpp -o initialize-finalize \
! &initialspace;-L${POOMAHOME}/lib/${POOMASUITE} -lpooma-gcc
  &lt;/programlisting&gt;  We explain the five command-line options:
      &lt;variablelist&gt;
       &lt;varlistentry&gt;
***************
*** 587,593 ****
      &lt;bridgehead id=&quot;initial-compile_programs-initialize-specifications&quot; renderas=&quot;sect4&quot;&gt;Prototypes&lt;/bridgehead&gt;
  
  &lt;programlisting&gt;
! &initialspace;#include &quot;Pooma/Pooma.h&quot;  // or &quot;Pooma/Arrays.h&quot; or &quot;Pooma/Fields.h&quot; or &hellip;
  &lt;/programlisting&gt;
  
      &lt;funcsynopsis&gt;
--- 594,601 ----
      &lt;bridgehead id=&quot;initial-compile_programs-initialize-specifications&quot; renderas=&quot;sect4&quot;&gt;Prototypes&lt;/bridgehead&gt;
  
  &lt;programlisting&gt;
! &initialspace;#include &quot;Pooma/Pooma.h&quot;
! &initialspace;// or &quot;Pooma/Arrays.h&quot; or &quot;Pooma/Fields.h&quot; or &hellip;
  &lt;/programlisting&gt;
  
      &lt;funcsynopsis&gt;
***************
*** 870,877 ****
        &lt;/variablelist&gt;
          For example, the &author; uses
  &lt;programlisting&gt;
! ./configure &dashdash;arch LINUXGCC &dashdash;shmem &dashdash;nompi
! &dashdash;noex &dashdash;static &dashdash;prefix ${HOME}/pooma/cheetah-1.0
  &dashdash;opt
  &lt;/programlisting&gt;  The
          &lt;command&gt;&dashdash;arch LINUXGCC&lt;/command&gt; indicates use of
--- 878,885 ----
        &lt;/variablelist&gt;
          For example, the &author; uses
  &lt;programlisting&gt;
! ./configure &dashdash;arch LINUXGCC &dashdash;shmem &dashdash;nompi \
! &dashdash;noex &dashdash;static &dashdash;prefix ${HOME}/pooma/cheetah-1.0 \
  &dashdash;opt
  &lt;/programlisting&gt;  The
          &lt;command&gt;&dashdash;arch LINUXGCC&lt;/command&gt; indicates use of
***************
*** 921,927 ****
          installed &cheetah; library.  For
          example,
  &lt;programlisting&gt;
! declare -x CHEETAHDIR=${HOME}/pooma/cheetah-1.0
  &lt;/programlisting&gt; specifies the
          installation directory used in the previous section.  If using
          the &lt;application&gt;csh&lt;/application&gt; shell, use &lt;command&gt;setenv 
--- 929,935 ----
          installed &cheetah; library.  For
          example,
  &lt;programlisting&gt;
! export CHEETAHDIR=${HOME}/pooma/cheetah-1.0
  &lt;/programlisting&gt; specifies the
          installation directory used in the previous section.  If using
          the &lt;application&gt;csh&lt;/application&gt; shell, use &lt;command&gt;setenv 
Index: template.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/template.xml,v
retrieving revision 1.7
diff -c -p -r1.7 template.xml
*** template.xml	2002/02/27 03:51:53	1.7
--- template.xml	2002/03/04 22:50:56
*************** struct usuallySimpleClass&lt;false&gt; {
*** 829,835 ****
  template&lt;class Op, class Left, class Right&gt;
  struct ExpressionTraits&lt;BinaryNode&lt;Op, Left, Right&closeclose;
  {
!   typedef typename ExpressionTraits&lt;Left&gt;::Type_t  Left_t;
    typedef typename ExpressionTraits&lt;Right&gt;::Type_t Right_t;
    typedef typename
      CombineExpressionTraits&lt;Left_t, Right_t&gt;::Type_t Type_t;
--- 829,835 ----
  template&lt;class Op, class Left, class Right&gt;
  struct ExpressionTraits&lt;BinaryNode&lt;Op, Left, Right&closeclose;
  {
!   typedef typename ExpressionTraits&lt;Left&gt;::Type_t Left_t;
    typedef typename ExpressionTraits&lt;Right&gt;::Type_t Right_t;
    typedef typename
      CombineExpressionTraits&lt;Left_t, Right_t&gt;::Type_t Type_t;
Index: uml.xml
===================================================================
RCS file: uml.xml
diff -N uml.xml
*** /dev/null	Fri Mar 23 21:37:44 2001
--- uml.xml	Mon Mar  4 15:50:57 2002
***************
*** 0 ****
--- 1,736 ----
+  &lt;appendix id=&quot;uml&quot;&gt;
+   &lt;title&gt;&uml; Class Diagrams&lt;/title&gt;
+ 
+   &lt;para&gt;In this chapter, we present Unified Modeling Language (&uml;)
+   class diagrams for several &pooma; classes.  These diagrams are
+   created at the &lt;firstterm&gt;specification&lt;/firstterm&gt; level, which
+   indicates the software interface, not its implementation.  &lt;xref
+   linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
+   provides a top-level overview of the relationships between classes.
+   Readers interested in the implementation are encouraged to read the
+   corresponding source code.  More extensive explanations of these
+   classes appear in the main chapters of this &book;.&lt;/para&gt;
+ 
+   &lt;figure float=&quot;1&quot; id=&quot;uml-explanation&quot;&gt;
+    &lt;title&gt;Explanation of &uml; Class Diagrams&lt;/title&gt;
+    &lt;mediaobject&gt;
+     &lt;imageobject&gt;
+      &lt;imagedata fileref=&quot;figures/explanation-uml.1&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+     &lt;/imageobject&gt;
+     &lt;imageobject&gt;
+      &lt;imagedata fileref=&quot;figures/explanation-uml-1.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+     &lt;/imageobject&gt;
+     &lt;textobject&gt;
+      &lt;phrase&gt;An Explanation of UML Class Diagrams&lt;/phrase&gt;
+     &lt;/textobject&gt;
+    &lt;/mediaobject&gt;
+   &lt;/figure&gt;
+ 
+   &lt;para&gt;&lt;xref linkend=&quot;uml-explanation&quot;&gt;&lt;/xref&gt; illustrates a typical
+   &uml; class diagram.  The diagram has three classes:
+   &lt;type&gt;Classname1&lt;/type&gt;, &lt;type&gt;Classname2&lt;/type&gt;, and
+   &lt;type&gt;Classname2&lt;1&gt;&lt;/type&gt;.  Most classes are represented by
+   three-part boxes.  The top part lists the class's name.  The middle
+   part lists public data members, if any.  Few &pooma; classes have
+   public data members so this section is frequently empty.  The bottom
+   part lists public member functions, if any.  &lt;quote&gt;Free parameter
+   types&lt;/quote&gt; indicate templated parameters.
+   &lt;type&gt;Classname2&lt;1&gt;&lt;/type&gt; has only one part, not three.  Its
+   three-part box appears in another diagram, presumably because there
+   is not enough room in this one.  Both &lt;type&gt;Classname1&lt;/type&gt; and
+   &lt;type&gt;Classname2&lt;/type&gt; have template parameters, each named
+   &lt;type&gt;T&lt;/type&gt;.  These occur in dashed boxes at the upper-right
+   corner of the class boxes.  Files implementing a class are listed at
+   the lower, right corner of the class's box.  These implementation
+   files may be different from the header files to include in one's
+   program to use these classes.&lt;/para&gt;
+ 
+   &lt;para&gt;Lines connect classes.  The solid arrow with large triangular
+   arrowhead indicates that &lt;type&gt;Classname2&lt;/type&gt; is a subtype of
+   &lt;type&gt;Classname1&lt;/type&gt;.  Since this diagram represents the
+   specification level, subtyping does not necessarily correspond to
+   &cc; type inheritance.  Also, subtype class boxes need only list
+   members not available in the supertype.  For this case,
+   &lt;type&gt;Classname2&lt;/type&gt; has one new member not provided by
+   &lt;type&gt;Classname1&lt;/type&gt;.  A dashed arrow indicates a class formed by
+   a template instantiation.  The class name indicates which template
+   parameters are bound.  For example, &lt;type&gt;Classname2&lt;1&gt;&lt;/type&gt;
+   instantiates &lt;type&gt;Classname2&lt;/type&gt; with &lt;type&gt;T&lt;/type&gt; equal
+   to&nbsp;1.&lt;/para&gt;
+ 
+   &lt;para&gt;Some of the functions require many, similar function
+   arguments.  We introduce regular expression notation to reduce the
+   length of the function prototype.  For example,&lt;programlisting&gt;
+ void foo(const X[1-3]&amp;)
+ &lt;/programlisting&gt; abbreviates &lt;programlisting&gt;
+ void foo(const X1&amp;, const X2&amp;, const X3&amp;)
+ &lt;/programlisting&gt;  &lt;literal&gt;X[1-3]&lt;/literal&gt; abbreviates
+   &lt;literal&gt;X1&lt;/literal&gt;, X2&lt;literal&gt;&lt;/literal&gt;, &lt;literal&gt;X3&lt;/literal&gt;.
+   We assume this distributes over &lt;literal&gt;const &amp;,&lt;/literal&gt; to
+   yield &cc; code.&lt;/para&gt;
+ 
+   &lt;para&gt;These diagrams omit a lot of details.  Private and protected
+   data members are not listed.  Compile-time types and values are not
+   listed.  No indication is given of the actual implementation.  Some
+   template arguments of parameters have been suppressed.&lt;/para&gt;
+ 
+ 
+   &lt;section id=&quot;uml-arrays&quot;&gt;
+    &lt;title&gt;&array;s&lt;/title&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-array_dynamicarray&quot;&gt;
+     &lt;title&gt;Relationship Between &array; and &dynamicarray;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/array-uml.1&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/array-uml-1.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&dynamicarray;s are subtypes of &array;s&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+    
+    &lt;para&gt;Both &array;s and &dynamicarray;s have so many member
+    functions that their class boxes appear in separate diagrams.
+    &lt;xref linkend=&quot;uml-array_dynamicarray&quot;&gt;&lt;/xref&gt; indicates that
+    &dynamicarray;s are subtypes of &array;s.  Both have value type and
+    engine tag template parameters but &dynamicarray;'s dimension must
+    be one.&lt;/para&gt;
+ 
+    &lt;para&gt;Implementation files are located within the &lt;filename
+    class=&quot;directory&quot;&gt;src/Array&lt;/filename&gt; directory.&lt;/para&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-array&quot;&gt;
+     &lt;title&gt;&array; Diagram&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/array-uml.2&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/array-uml-2.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&array; Class Diagram&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-dynamicarray&quot;&gt;
+     &lt;title&gt;&dynamicarray; Diagram&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/array-uml.3&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/array-uml-3.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&dynamicarray; Class Diagram&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+   &lt;/section&gt;
+ 
+ 
+   &lt;section id=&quot;uml-fields&quot;&gt;
+    &lt;title&gt;&field;s, &mesh;es, and &centering;s&lt;/title&gt;
+ 
+    &lt;para&gt;A &field; has a mesh and a centering.  It is implemented in
+    &lt;filename class=&quot;headerfile&quot;&gt;src/Field/Field.h&lt;/filename&gt;.&lt;/para&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-fields-field&quot;&gt;
+     &lt;title&gt;&field;&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/field-uml.10&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/field-uml-10.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;A &field; is like an &array; but having spatial
+       extent.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+ 
+    &lt;section id=&quot;uml-fields-meshes&quot;&gt;
+     &lt;title&gt;&mesh;es&lt;/title&gt;
+ 
+     &lt;para&gt;A mesh specifies a &field;'s spatial extent.  A &mesh; class
+     only exists conceptually, but &lt;type&gt;NoMesh&lt;/type&gt; and
+     &lt;type&gt;UniformRectilinearMesh&lt;/type&gt; are defined within the
+     &lt;filename class=&quot;directory&quot;&gt;src/Field/Mesh&lt;/filename&gt;
+     directory.&lt;/para&gt;
+ 
+     &lt;figure float=&quot;1&quot; id=&quot;uml-fields-meshes-overview&quot;&gt;
+      &lt;title&gt;&mesh;es&lt;/title&gt;
+      &lt;mediaobject&gt;
+       &lt;imageobject&gt;
+        &lt;imagedata fileref=&quot;figures/field-uml.3&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+       &lt;/imageobject&gt;
+       &lt;imageobject&gt;
+        &lt;imagedata fileref=&quot;figures/field-uml-3.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+       &lt;/imageobject&gt;
+       &lt;textobject&gt;
+        &lt;phrase&gt;The abstract &lt;type&gt;Mesh&lt;/type&gt; class is realized by
+       &lt;type&gt;NoMesh&lt;/type&gt; and &lt;type&gt;UniformRectilinearMesh&lt;/type&gt;.&lt;/phrase&gt;
+       &lt;/textobject&gt;
+      &lt;/mediaobject&gt;
+     &lt;/figure&gt;
+ 
+     &lt;figure float=&quot;1&quot; id=&quot;uml-fields-meshes-nomesh&quot;&gt;
+      &lt;title&gt;&lt;type&gt;NoMesh&lt;/type&gt;&lt;/title&gt;
+      &lt;mediaobject&gt;
+       &lt;imageobject&gt;
+        &lt;imagedata fileref=&quot;figures/field-uml.1&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+       &lt;/imageobject&gt;
+       &lt;imageobject&gt;
+        &lt;imagedata fileref=&quot;figures/field-uml-1.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+       &lt;/imageobject&gt;
+       &lt;textobject&gt;
+        &lt;phrase&gt;If a &field; has a &lt;type&gt;NoMesh&lt;/type&gt; mesh, it has no
+       spatial extent.&lt;/phrase&gt;
+       &lt;/textobject&gt;
+      &lt;/mediaobject&gt;
+     &lt;/figure&gt;
+ 
+     &lt;para&gt;In the following figure, we abbreviate
+     &lt;type&gt;UniformRectilinearMesh&lt;/type&gt; with
+     &lt;quote&gt;URM&lt;/quote&gt;.&lt;/para&gt;
+ 
+     &lt;figure float=&quot;1&quot; id=&quot;uml-fields-meshes-urm&quot;&gt;
+      &lt;title&gt;&lt;type&gt;UniformRectilinearMesh&lt;/type&gt;&lt;/title&gt;
+      &lt;mediaobject&gt;
+       &lt;imageobject&gt;
+        &lt;imagedata fileref=&quot;figures/field-uml.2&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+       &lt;/imageobject&gt;
+       &lt;imageobject&gt;
+        &lt;imagedata fileref=&quot;figures/field-uml-2.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+       &lt;/imageobject&gt;
+       &lt;textobject&gt;
+        &lt;phrase&gt;The &lt;type&gt;UniformRectilinearMesh&lt;/type&gt; is the most
+       common &field; mesh.&lt;/phrase&gt;
+       &lt;/textobject&gt;
+      &lt;/mediaobject&gt;
+     &lt;/figure&gt;
+    &lt;/section&gt;&lt;!-- meshes --&gt;
+ 
+ 
+    &lt;section id=&quot;uml-fields-centerings&quot;&gt;
+     &lt;title&gt;&centering;s&lt;/title&gt;
+ 
+     &lt;para&gt;A &centering; specifies the location of values within a
+     cell.  &lt;type&gt;CanonicalCentering&lt;/type&gt; is a helper class returning
+     common centerings.  Both are implemented within the &lt;filename
+     class=&quot;directory&quot;&gt;src/Field&lt;/filename&gt; subdirectory.&lt;/para&gt;
+ 
+     &lt;figure float=&quot;1&quot; id=&quot;uml-fields-centerings-figure&quot;&gt;
+      &lt;title&gt;Centering Classes&lt;/title&gt;
+      &lt;mediaobject&gt;
+       &lt;imageobject&gt;
+        &lt;imagedata fileref=&quot;figures/field-uml.11&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+       &lt;/imageobject&gt;
+       &lt;imageobject&gt;
+        &lt;imagedata fileref=&quot;figures/field-uml-11.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+       &lt;/imageobject&gt;
+       &lt;textobject&gt;
+        &lt;phrase&gt;&lt;type&gt;CanonicalCentering&lt;/type&gt; returns commonly-used &centering;s.&lt;/phrase&gt;
+       &lt;/textobject&gt;
+      &lt;/mediaobject&gt;
+     &lt;/figure&gt;
+    &lt;/section&gt;&lt;!-- centering --&gt;
+ 
+   &lt;/section&gt;
+ 
+ 
+   &lt;section id=&quot;uml-math_objects&quot;&gt;
+    &lt;title&gt;&vector;s, &matrix;s, &tensor;s&lt;/title&gt;
+ 
+    &lt;para&gt;In this section, we present &uml; class diagrams for the
+    mathematical objects of &vector;s, &matrix;s, and &tensor;s.  All
+    these classes have similar interfaces and relationships.  For
+    example, &vector; requires a &lt;type&gt;VectorEngine&lt;/type&gt;, which has
+    no public interface.  The only template specialization is
+    &lt;type&gt;VectorEngine&lt;D,T,Full&gt;&lt;/type&gt;.  &matrix;s are similar.
+    Tensors have four different engines, supporting the tensor
+    specializations of &lt;literal&gt;Antisymmetric&lt;/literal&gt;,
+    &lt;literal&gt;Symmetric&lt;/literal&gt;, and
+    &lt;literal&gt;Diagonal&lt;/literal&gt;.&lt;/para&gt;
+ 
+    &lt;para&gt;All of the source files are located in the &lt;filename
+    class=&quot;directory&quot;&gt;src/Tiny&lt;/filename&gt; subdirectory.&lt;/para&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-math_objects-vector&quot;&gt;
+     &lt;title&gt;&vector;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml.1&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml-1.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&vector;s require &lt;type&gt;VectorEngine&lt;/type&gt;s.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-math_objects-matrix&quot;&gt;
+     &lt;title&gt;&matrix;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml.10&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml-10.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&matrix;s require &lt;type&gt;TinyMatrixEngine&lt;/type&gt;s,
+       appearing in the next diagram.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-math_objects-matrixengine&quot;&gt;
+     &lt;title&gt;&lt;type&gt;TinyMatrixEngine&lt;/type&gt;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml.11&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml-11.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&lt;type&gt;TinyMatrixEngine&lt;/type&gt;s power &matrix;s.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-math_objects-tensor&quot;&gt;
+     &lt;title&gt;&tensor;s and &lt;type&gt;TensorEngine&lt;/type&gt;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml.2&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml-2.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&tensor;s require &lt;type&gt;TensorEngine&lt;/type&gt;s.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-math_objects-tensor-full&quot;&gt;
+     &lt;title&gt;&lt;literal&gt;Full&lt;/literal&gt; and &lt;literal&gt;Diagonal&lt;/literal&gt; &lt;type&gt;TensorEngine&lt;/type&gt;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml.3&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml-3.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&lt;literal&gt;Full&lt;/literal&gt; &engine;s are the default
+       &tensor; &engine;s.  Diagonal &tensor;s use its special &engine;.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-math_objects-tensor-symmetric&quot;&gt;
+     &lt;title&gt;&lt;literal&gt;Antisymmetric&lt;/literal&gt; and &lt;literal&gt;Symmetric&lt;/literal&gt; &lt;type&gt;TensorEngine&lt;/type&gt;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml.4&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/math-objs-uml-4.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;More &lt;type&gt;TensorEngine&lt;/type&gt; specializations.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+   &lt;/section&gt;
+ 
+ 
+   &lt;section id=&quot;uml-domains&quot;&gt;
+    &lt;title&gt;&domain;s&lt;/title&gt;
+ 
+    &lt;para&gt;&domain;s and its subtypes are shown in &lt;xref
+    linkend=&quot;uml-domains_figure&quot;&gt;&lt;/xref&gt;.  All classes are instantiated
+    from or subtypes of &domain;.  As mentioned in &lt;xref
+    linkend=&quot;arrays-domains&quot;&gt;&lt;/xref&gt;, the &lt;type&gt;Domain&lt;1&gt;&lt;/type&gt;
+    template instantiation has additional member functions.  It uses
+    the &lt;type&gt;Domain&lt;1&gt;::iterator&lt;/type&gt;.  The four &domain;
+    subtypes appear in the bottom half of the figure.  Each requires
+    the same template parameter as &domain;.  Each of these has a
+    template instantiation for the one-dimensional case.  We omit
+    listing their additional member functions since these are the same
+    as for &lt;type&gt;Domain&lt;1&gt;&lt;/type&gt;.&lt;/para&gt;
+ 
+    &lt;para&gt;Implementation files are located within the &lt;filename
+    class=&quot;directory&quot;&gt;src/Domain&lt;/filename&gt; directory.&lt;/para&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-domains_figure&quot;&gt;
+     &lt;title&gt;&domain;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/domain-uml.1&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/domain-uml-1.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&domain;s&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+    
+   &lt;/section&gt;
+ 
+ 
+   &lt;section id=&quot;uml-engines&quot;&gt;
+    &lt;title&gt;&engine;s&lt;/title&gt;
+ 
+    &lt;para&gt;&engine;s and its subtypes are shown in &lt;xref
+    linkend=&quot;uml-engines-figure&quot;&gt;&lt;/xref&gt;.  Five subtypes of &engine;s
+    are shown.  Details appear in subsequent diagrams.  The
+    &lt;type&gt;Engine&lt;/type&gt; class box shows no members because it has no
+    members.  Only subtypes have members.  More explanation of these
+    classes can be found in &lt;xref linkend=&quot;engines&quot;&gt;&lt;/xref&gt;.  The
+    implementation files in &lt;xref
+    linkend=&quot;uml-engines-brick_figure&quot;&gt;&lt;/xref&gt; use the
+    &lt;literal&gt;[1-7]&lt;/literal&gt; regular expression to indicate 1, 2,
+    &hellip;, or&nbsp;7.&lt;/para&gt;
+ 
+    &lt;para&gt;Implementation files are located within the &lt;filename
+    class=&quot;directory&quot;&gt;src/Engine&lt;/filename&gt; directory.&lt;/para&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-engines-figure&quot;&gt;
+     &lt;title&gt;&engine;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/engine-uml.1&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/engine-uml-1.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;Relationships among &engine;s&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-engines-brick_figure&quot;&gt;
+     &lt;title&gt;&brick; and &compressiblebrick; &engine;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/engine-uml.2&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/engine-uml-2.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&brick; and &compressiblebrick; &engine;s&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-engines-dynamic_figure&quot;&gt;
+     &lt;title&gt;&dynamic; and &multipatch; &engine;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/engine-uml.3&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/engine-uml-3.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&dynamic; and &multipatch; &engine;s&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-engines-remote_figure&quot;&gt;
+     &lt;title&gt;&remote; &engine;s&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/engine-uml.4&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/engine-uml-4.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&remote; &engine;s&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+    
+   &lt;/section&gt;
+ 
+ 
+   &lt;section id=&quot;uml-distributed&quot;&gt;
+    &lt;title&gt;Distributed Computation&lt;/title&gt;
+ 
+    &lt;para&gt;In this section, we present &uml; class diagrams for the
+    classes used when declaring distributed computation.  We use
+    abbreviations in parameter lists:&lt;/para&gt;
+ 
+    &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	  orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;uml-distributed-abbreviation_table&quot;&gt;
+     &lt;title&gt;Abbreviations&lt;/title&gt;
+     
+     &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+      &lt;thead&gt;
+       &lt;row&gt;
+        &lt;entry&gt;abbreviation&lt;/entry&gt;
+        &lt;entry&gt;meaning&lt;/entry&gt;
+       &lt;/row&gt;
+      &lt;/thead&gt;
+      &lt;tbody valign=&quot;top&quot;&gt;
+       &lt;row&gt;
+        &lt;entry&gt;CM&lt;/entry&gt;
+        &lt;entry&gt;&lt;type&gt;ContextMapper&lt;/type&gt;&lt;/entry&gt;
+       &lt;/row&gt;
+       &lt;row&gt;
+        &lt;entry&gt;DT&lt;/entry&gt;
+        &lt;entry&gt;&lt;type&gt;DistributedTag&lt;/type&gt;&lt;/entry&gt;
+       &lt;/row&gt;
+       &lt;row&gt;
+        &lt;entry&gt;GL&lt;/entry&gt;
+        &lt;entry&gt;&lt;type&gt;GuardLayers&lt;/type&gt;&lt;/entry&gt;
+       &lt;/row&gt;
+       &lt;row&gt;
+        &lt;entry&gt;Iv&lt;/entry&gt;
+        &lt;entry&gt;&lt;type&gt;Interval&lt;/type&gt;&lt;/entry&gt;
+       &lt;/row&gt;
+       &lt;row&gt;
+        &lt;entry&gt;List_t&lt;/entry&gt;
+        &lt;entry&gt;&lt;type&gt;std::vector&lt;/type&gt; of pointers to &lt;type&gt;Node&lt;/type&gt;s of
+    &domain;s&lt;/entry&gt;
+       &lt;/row&gt;
+       &lt;row&gt;
+        &lt;entry&gt;PatchList_t&lt;/entry&gt;
+        &lt;entry&gt;&lt;type&gt;std::vector&lt;/type&gt; of &lt;type&gt;Interval&lt;Dim&gt;&lt;/type&gt;s&lt;/entry&gt;
+       &lt;/row&gt;
+       &lt;row&gt;
+        &lt;entry&gt;RT&lt;/entry&gt;
+        &lt;entry&gt;&lt;type&gt;ReplicatedTag&lt;/type&gt;&lt;/entry&gt;
+       &lt;/row&gt;
+       &lt;row&gt;
+        &lt;entry&gt;SpTlLa&lt;/entry&gt;
+        &lt;entry&gt;&lt;type&gt;SparseTileLayout&lt;/type&gt;&lt;/entry&gt;
+       &lt;/row&gt;
+      &lt;/tbody&gt;
+     &lt;/tgroup&gt;
+    &lt;/table&gt;
+ 
+    &lt;para&gt;Partitions specify how a domain will be split into patches,
+    or pieces.  &lt;xref linkend=&quot;uml-distributed-partition&quot;&gt;&lt;/xref&gt;
+    introduces the abstract &lt;quote&gt;Partition&lt;/quote&gt; class.  The class
+    exists only conceptually, not appearing in any source code.
+    Instead four classes, appearing in subsequent diagrams, realize it.
+    Even though users rarely use any of their member functions, the
+    diagrams list them.  All files are relative to the &lt;filename
+    class=&quot;directory&quot;&gt;src/Partition&lt;/filename&gt; subdirectory.&lt;/para&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-partition&quot;&gt;
+     &lt;title&gt;Partitions&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.5&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-5.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;Four classes realize the abstract Partition class.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-partition-grid&quot;&gt;
+     &lt;title&gt;Grid Partitions&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.4&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-4.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;Two partition classes use grids.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-partition-other&quot;&gt;
+     &lt;title&gt;Other Partitions&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.3&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-3.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&lt;type&gt;SpatialPartition&lt;/type&gt; and
+       &lt;type&gt;TilePartition&lt;/type&gt; realize the abstract Partition
+       class.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;para&gt;Guard layers surround domains and patches to ease programming
+    and decrease communication.  We list more member functions than
+    most users require.  All files are relative to the &lt;filename
+    class=&quot;directory&quot;&gt;src/Layout&lt;/filename&gt; subdirectory.&lt;/para&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-guard_layers&quot;&gt;
+     &lt;title&gt;Guard Layers&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.30&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-30.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&lt;type&gt;GuardLayers&lt;/type&gt; surround patches.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;para&gt;A layout maps a domain index to processors and memory used to
+    compute the associated value.  There is no base class so we just
+    present the class diagrams.  We list only member functions related
+    to construction, destruction, and printing since those are the
+    functions that almost all users use.  All files are relative to the
+    &lt;filename class=&quot;directory&quot;&gt;src/Layout&lt;/filename&gt;
+    subdirectory.&lt;/para&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-layout-domainlayout&quot;&gt;
+     &lt;title&gt;&lt;type&gt;DomainLayout&lt;/type&gt;&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.22&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-22.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&lt;type&gt;DomainLayout&lt;/type&gt;&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-layout-dynamiclayout&quot;&gt;
+     &lt;title&gt;&lt;type&gt;DynamicLayout&lt;/type&gt;&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.23&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-23.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&lt;type&gt;DynamicLayout&lt;/type&gt;&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-layout-gridlayout&quot;&gt;
+     &lt;title&gt;&lt;type&gt;GridLayout&lt;/type&gt;&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.24&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-24.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&lt;type&gt;GridLayout&lt;/type&gt;&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-layout-uniformgridlayout&quot;&gt;
+     &lt;title&gt;&lt;type&gt;UniformGridLayout&lt;/type&gt;&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.20&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-20.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&lt;type&gt;UniformGridLayout&lt;/type&gt;&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-layout-sparsetilelayout&quot;&gt;
+     &lt;title&gt;&lt;type&gt;SparseTileLayout&lt;/type&gt;&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.21&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-21.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;&lt;type&gt;SparseTileLayout&lt;/type&gt;&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+ 
+    &lt;para&gt;Context mappers map domain patches to contexts.  Effectively,
+    they map pieces of a domain to processors.  Even though users
+    rarely use any of their member functions, the diagrams list them.
+    The type &lt;type&gt;List_t&lt;/type&gt; abbreviates an
+    &lt;type&gt;std::vector&lt;/type&gt; of pointers to &lt;type&gt;Node&lt;/type&gt;s of
+    &domain;s.  &lt;type&gt;GL&lt;/type&gt; abbreviates &lt;type&gt;GuardLayers&lt;/type&gt;.
+    All files are relative to the &lt;filename
+    class=&quot;directory&quot;&gt;src/Partition&lt;/filename&gt; subdirectory.&lt;/para&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-mapper-overview&quot;&gt;
+     &lt;title&gt;Relationships Among Context Mappers&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.10&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-10.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;Five different mappers inherit from the base
+       &lt;type&gt;ContextMapper&lt;/type&gt;.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;uml-distributed-mapper-details&quot;&gt;
+     &lt;title&gt;Context Mappers&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml.11&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;imageobject&gt;
+       &lt;imagedata fileref=&quot;figures/distributed-uml-11.png&quot; format=&quot;PNG&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+       &lt;phrase&gt;Details of the five different mappers inheriting from
+       the base &lt;type&gt;ContextMapper&lt;/type&gt;.&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+   &lt;/section&gt;
+  &lt;/appendix&gt;
Index: figures/Makefile
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/Makefile,v
retrieving revision 1.3
diff -c -p -r1.3 Makefile
*** figures/Makefile	2002/02/27 03:51:53	1.3
--- figures/Makefile	2002/03/04 22:50:57
*************** RESULTS= $(SOURCES:%.mp=mproof-%.ps)
*** 37,45 ****
  TREE_SOURCES= $(SOURCES) Makefile macros.ltx
  
  # UML class diagrams that occur in the appendix containing these.
! UML_DIAGRAMS= explanation-uml-1.png array-uml.1 array-uml.2 array-uml.3 \
! 	      domain-uml.1 engine-uml.1 engine-uml.2 engine-uml.3 \
! 	      engine-uml.4
  
  # Create all the EPS and PNG files.  The 'mproof-all' target creates
  # the EPS files.  This should happen before trying to create the PNG
--- 37,58 ----
  TREE_SOURCES= $(SOURCES) Makefile macros.ltx
  
  # UML class diagrams that occur in the appendix containing these.
! UML_DIAGRAMS= explanation-uml-1.png \
! 	      array-uml-1.png array-uml-2.png array-uml-3.png \
! 	      distributed-uml-5.png distributed-uml-4.png \
! 	      distributed-uml-3.png distributed-uml-30.png \
! 	      distributed-uml-22.png distributed-uml-23.png \
! 	      distributed-uml-24.png distributed-uml-20.png \
! 	      distributed-uml-21.png distributed-uml-10.png \
! 	      distributed-uml-11.png \
! 	      domain-uml-1.png \
! 	      engine-uml-1.png engine-uml-2.png engine-uml-3.png \
! 	      engine-uml-4.png \
! 	      field-uml-10.png field-uml-3.png field-uml-1.png \
! 	      field-uml-2.png field-uml-11.png \
! 	      math-objs-uml-1.png math-objs-uml-10.png \
! 	      math-objs-uml-11.png math-objs-uml-2.png math-objs-uml-3.png \
! 	      math-objs-uml-4.png
  
  # Create all the EPS and PNG files.  The 'mproof-all' target creates
  # the EPS files.  This should happen before trying to create the PNG
*************** introduction-%.png: introduction.%
*** 72,82 ****
--- 85,101 ----
  	$(EPSTOPNG) -p -o $@ $^
  array-uml-%.png: array-uml.%
  	$(EPSTOPNG) -p -o $@ $^
+ distributed-uml-%.png: distributed-uml.%
+ 	$(EPSTOPNG) -p -o $@ $^
  domain-uml-%.png: domain-uml.%
  	$(EPSTOPNG) -p -o $@ $^
  engine-uml-%.png: engine-uml.%
  	$(EPSTOPNG) -p -o $@ $^
  explanation-uml-%.png: explanation-uml.%
+ 	$(EPSTOPNG) -p -o $@ $^
+ field-uml-%.png: field-uml.%
+ 	$(EPSTOPNG) -p -o $@ $^
+ math-objs-uml-%.png: math-objs-uml.%
  	$(EPSTOPNG) -p -o $@ $^
  
  clean:
Index: figures/array-uml-1.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/array-uml-1.png,v
retrieving revision 1.1
diff -c -p -r1.1 array-uml-1.png
Binary files /tmp/cvsgrf0Om and array-uml-1.png differ
Index: figures/array-uml-2.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/array-uml-2.png,v
retrieving revision 1.1
diff -c -p -r1.1 array-uml-2.png
Binary files /tmp/cvszpurUR and array-uml-2.png differ
Index: figures/array-uml-3.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/array-uml-3.png,v
retrieving revision 1.1
diff -c -p -r1.1 array-uml-3.png
Binary files /tmp/cvsGHuyWm and array-uml-3.png differ
Index: figures/array-uml.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/array-uml.mp,v
retrieving revision 1.1
diff -c -p -r1.1 array-uml.mp
*** figures/array-uml.mp	2002/02/27 03:51:54	1.1
--- figures/array-uml.mp	2002/03/04 22:50:58
*************** beginfig(1)
*** 34,47 ****
      btex
      \begin{lists}
      Array() \\
-     Array(Domain \ldots) \\
-     Array(Domain \ldots, ModelElement&lt;T&gt;) \\
      Array(Array) \\
      Array(Array, Domain) \\
!     initialize(Domain \ldots) \\
!     initialize(Domain \ldots, ModelElement&lt;T&gt;) \\
!     read(\ldots) \\
!     operator()(\ldots) \\
      domain() \\
      physicalDomain() \\
      totalDomain() \\
--- 34,85 ----
      btex
      \begin{lists}
      Array() \\
      Array(Array) \\
      Array(Array, Domain) \\
!     Array(const Domain\&amp;) \\
!     Array(const Domain[1-2]\&amp;) \\
!     Array(const Domain[1-3]\&amp;) \\
!     Array(const Domain[1-4]\&amp;) \\
!     Array(const Domain[1-5]\&amp;) \\
!     Array(const Domain[1-6]\&amp;) \\
!     Array(const Domain[1-7]\&amp;) \\
!     Array(const Domain\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-2]\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-3]\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-4]\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-5]\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-6]\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-7]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain\&amp;) \\
!     void initialize(const Domain[1-2]\&amp;) \\
!     void initialize(const Domain[1-3]\&amp;) \\
!     void initialize(const Domain[1-4]\&amp;) \\
!     void initialize(const Domain[1-5]\&amp;) \\
!     void initialize(const Domain[1-6]\&amp;) \\
!     void initialize(const Domain[1-7]\&amp;) \\
!     void initialize(const Domain\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-2]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-3]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-4]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-5]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-6]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-7]\&amp;, ModelElement&lt;T&gt;) \\
!     read() \\
!     read(const X1\&amp;) \\
!     read(const X[1-2]\&amp;) \\
!     read(const X[1-3]\&amp;) \\
!     read(const X[1-4]\&amp;) \\
!     read(const X[1-5]\&amp;) \\
!     read(const X[1-6]\&amp;) \\
!     read(const X[1-7]\&amp;) \\
!     operator()() \\
!     operator()(const X1\&amp;) \\
!     operator()(const X[1-2]\&amp;) \\
!     operator()(const X[1-3]\&amp;) \\
!     operator()(const X[1-4]\&amp;) \\
!     operator()(const X[1-5]\&amp;) \\
!     operator()(const X[1-6]\&amp;) \\
!     operator()(const X[1-7]\&amp;) \\
      domain() \\
      physicalDomain() \\
      totalDomain() \\
*************** beginfig(1)
*** 54,65 ****
      size() \\
      layout() \\
      engine() \\
!     operator&lt;&lt;
      \end{lists} etex);
    boxit.array[3](
      btex
      \begin{lists}
!     dim D \\
      value type T \\
      engine tag Tag
      \end{lists} etex);
--- 92,103 ----
      size() \\
      layout() \\
      engine() \\
!     operator&lt;&lt;()
      \end{lists} etex);
    boxit.array[3](
      btex
      \begin{lists}
!     dimension D \\
      value type T \\
      engine tag Tag
      \end{lists} etex);
*************** beginfig(1)
*** 80,89 ****
      DynamicArray(Domain, ModelElement&lt;T&gt;) \\
      DynamicArray(DynamicArray) \\
      DynamicArray(DynamicArray, Domain) \\
!     initialize(Domain \ldots) \\
!     initialize(Domain \ldots, ModelElement&lt;T&gt;) \\
!     read(\ldots) \\
!     operator()(\ldots) \\
      domain() \\
      physicalDomain() \\
      totalDomain() \\
--- 118,153 ----
      DynamicArray(Domain, ModelElement&lt;T&gt;) \\
      DynamicArray(DynamicArray) \\
      DynamicArray(DynamicArray, Domain) \\
!     void initialize(const Domain\&amp;) \\
!     void initialize(const Domain[1-2]\&amp;) \\
!     void initialize(const Domain[1-3]\&amp;) \\
!     void initialize(const Domain[1-4]\&amp;) \\
!     void initialize(const Domain[1-5]\&amp;) \\
!     void initialize(const Domain[1-6]\&amp;) \\
!     void initialize(const Domain[1-7]\&amp;) \\
!     void initialize(const Domain\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-2]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-3]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-4]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-5]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-6]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-7]\&amp;, ModelElement&lt;T&gt;) \\
!     read() \\
!     read(const X1\&amp;) \\
!     read(const X[1-2]\&amp;) \\
!     read(const X[1-3]\&amp;) \\
!     read(const X[1-4]\&amp;) \\
!     read(const X[1-5]\&amp;) \\
!     read(const X[1-6]\&amp;) \\
!     read(const X[1-7]\&amp;) \\
!     operator()() \\
!     operator()(const X1\&amp;) \\
!     operator()(const X[1-2]\&amp;) \\
!     operator()(const X[1-3]\&amp;) \\
!     operator()(const X[1-4]\&amp;) \\
!     operator()(const X[1-5]\&amp;) \\
!     operator()(const X[1-6]\&amp;) \\
!     operator()(const X[1-7]\&amp;) \\
      domain() \\
      physicalDomain() \\
      totalDomain() \\
*************** beginfig(1)
*** 96,102 ****
      size() \\
      layout() \\
      engine() \\
!     operator&lt;&lt; \\
      array() \\
      arrayAll() \\
      create(CreateSize\t) \\
--- 160,166 ----
      size() \\
      layout() \\
      engine() \\
!     operator&lt;&lt;() \\
      array() \\
      arrayAll() \\
      create(CreateSize\t) \\
*************** beginfig(1)
*** 147,153 ****
  
    % Draw arrows between classes.
    drawDiscriminator(array[0].s, 0);
!   z0 = array[0].s - (0,discriminatorScale);
    draw z0 -- dynamicarray[0].n;
  endfig;
  
--- 211,217 ----
  
    % Draw arrows between classes.
    drawDiscriminator(array[0].s, 0);
!   z0 = array[0].s - (0,discriminatorLength);
    draw z0 -- dynamicarray[0].n;
  endfig;
  
*************** beginfig(2)
*** 162,193 ****
      btex
      \begin{lists}
      Array() \\
-     Array(Domain \ldots) \\
-     Array(Domain \ldots, ModelElement&lt;T&gt;) \\
      Array(Array) \\
      Array(Array, Domain) \\
!     initialize(Domain \ldots) \\
!     initialize(Domain \ldots, ModelElement&lt;T&gt;) \\
!     read(\ldots) \\
!     operator()(\ldots) \\
      domain() \\
      physicalDomain() \\
      totalDomain() \\
!     first(int) \\
!     last(int) \\
      length(int) \\
!     firsts() \\
!     lasts() \\
      lengths() \\
      size() \\
      layout() \\
      engine() \\
!     operator&lt;&lt;
      \end{lists} etex);
    boxit.array[3](
      btex
      \begin{lists}
!     dim D \\
      value type T \\
      engine tag Tag
      \end{lists} etex);
--- 226,285 ----
      btex
      \begin{lists}
      Array() \\
      Array(Array) \\
      Array(Array, Domain) \\
!     Array(const Domain\&amp;) \\
!     Array(const Domain[1-2]\&amp;) \\
!     Array(const Domain[1-3]\&amp;) \\
!     Array(const Domain[1-4]\&amp;) \\
!     Array(const Domain[1-5]\&amp;) \\
!     Array(const Domain[1-6]\&amp;) \\
!     Array(const Domain[1-7]\&amp;) \\
!     Array(const Domain\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-2]\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-3]\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-4]\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-5]\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-6]\&amp;, ModelElement&lt;T&gt;) \\
!     Array(const Domain[1-7]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain\&amp;) \\
!     void initialize(const Domain[1-2]\&amp;) \\
!     void initialize(const Domain[1-3]\&amp;) \\
!     void initialize(const Domain[1-4]\&amp;) \\
!     void initialize(const Domain[1-5]\&amp;) \\
!     void initialize(const Domain[1-6]\&amp;) \\
!     void initialize(const Domain[1-7]\&amp;) \\
!     void initialize(const Domain\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-2]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-3]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-4]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-5]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-6]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-7]\&amp;, ModelElement&lt;T&gt;) \\
!     read();			operator()() \\
!     read(const X1\&amp;);		operator()(const X1\&amp;) \\
!     read(const X[1-2]\&amp;);	operator()(const X[1-2]\&amp;) \\
!     read(const X[1-3]\&amp;);	operator()(const X[1-3]\&amp;) \\
!     read(const X[1-4]\&amp;);	operator()(const X[1-4]\&amp;) \\
!     read(const X[1-5]\&amp;);	operator()(const X[1-5]\&amp;) \\
!     read(const X[1-6]\&amp;);	operator()(const X[1-6]\&amp;) \\
!     read(const X[1-7]\&amp;);	operator()(const X[1-7]\&amp;) \\
      domain() \\
      physicalDomain() \\
      totalDomain() \\
!     first(int); last(int) \\
      length(int) \\
!     firsts(); lasts() \\
      lengths() \\
      size() \\
      layout() \\
      engine() \\
!     operator&lt;&lt;()
      \end{lists} etex);
    boxit.array[3](
      btex
      \begin{lists}
!     dimension D \\
      value type T \\
      engine tag Tag
      \end{lists} etex);
*************** beginfig(3)
*** 256,278 ****
      DynamicArray(Domain, ModelElement&lt;T&gt;) \\
      DynamicArray(DynamicArray) \\
      DynamicArray(DynamicArray, Domain) \\
!     initialize(Domain \ldots) \\
!     initialize(Domain \ldots, ModelElement&lt;T&gt;) \\
!     read(\ldots) \\
!     operator()(\ldots) \\
      domain() \\
      physicalDomain() \\
      totalDomain() \\
!     first(int) \\
!     last(int) \\
      length(int) \\
!     firsts() \\
!     lasts() \\
      lengths() \\
      size() \\
      layout() \\
      engine() \\
!     operator&lt;&lt; \\
      array() \\
      arrayAll() \\
      create(CreateSize\t) \\
--- 348,386 ----
      DynamicArray(Domain, ModelElement&lt;T&gt;) \\
      DynamicArray(DynamicArray) \\
      DynamicArray(DynamicArray, Domain) \\
!     void initialize(const Domain\&amp;) \\
!     void initialize(const Domain[1-2]\&amp;) \\
!     void initialize(const Domain[1-3]\&amp;) \\
!     void initialize(const Domain[1-4]\&amp;) \\
!     void initialize(const Domain[1-5]\&amp;) \\
!     void initialize(const Domain[1-6]\&amp;) \\
!     void initialize(const Domain[1-7]\&amp;) \\
!     void initialize(const Domain\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-2]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-3]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-4]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-5]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-6]\&amp;, ModelElement&lt;T&gt;) \\
!     void initialize(const Domain[1-7]\&amp;, ModelElement&lt;T&gt;) \\
!     read();			operator()() \\
!     read(const X1\&amp;);		operator()(const X1\&amp;) \\
!     read(const X[1-2]\&amp;);	operator()(const X[1-2]\&amp;) \\
!     read(const X[1-3]\&amp;);	operator()(const X[1-3]\&amp;) \\
!     read(const X[1-4]\&amp;);	operator()(const X[1-4]\&amp;) \\
!     read(const X[1-5]\&amp;);	operator()(const X[1-5]\&amp;) \\
!     read(const X[1-6]\&amp;);	operator()(const X[1-6]\&amp;) \\
!     read(const X[1-7]\&amp;);	operator()(const X[1-7]\&amp;) \\
      domain() \\
      physicalDomain() \\
      totalDomain() \\
!     first(int); last(int) \\
      length(int) \\
!     firsts(); lasts() \\
      lengths() \\
      size() \\
      layout() \\
      engine() \\
!     operator&lt;&lt;() \\
      array() \\
      arrayAll() \\
      create(CreateSize\t) \\
Index: figures/data-parallel.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/data-parallel.mp,v
retrieving revision 1.3
diff -c -p -r1.3 data-parallel.mp
*** figures/data-parallel.mp	2002/01/31 21:29:58	1.3
--- figures/data-parallel.mp	2002/03/04 22:51:00
*************** beginfig(101)
*** 59,68 ****
    endfor
  
    %% Label the node's types.
- % TMP  label.rt(btex \type{OpAddAssign} etex, b0.e);
- % TMP  label.rt(btex \type{Expression} etex, 0.5[b0.c,b2.c]);
    label.top(btex \type{Expression} etex, b2.n);
- % TMP  label.lft(btex \type{Ar} etex, b1.w);
    label.rt(btex \type{BinaryNode&lt;OpAdd,} etex, b2.e);
    label.lft(btex \type{UnaryNode&lt;OpMinus,} etex, b3.w);
    label.lft(btex \type{Ar} etex, b4.w);
--- 59,65 ----
Index: figures/distributed-uml-10.png
===================================================================
RCS file: distributed-uml-10.png
diff -N distributed-uml-10.png
Binary files /dev/null and distributed-uml-10.png differ
Index: figures/distributed-uml-11.png
===================================================================
RCS file: distributed-uml-11.png
diff -N distributed-uml-11.png
Binary files /dev/null and distributed-uml-11.png differ
Index: figures/distributed-uml-20.png
===================================================================
RCS file: distributed-uml-20.png
diff -N distributed-uml-20.png
Binary files /dev/null and distributed-uml-20.png differ
Index: figures/distributed-uml-21.png
===================================================================
RCS file: distributed-uml-21.png
diff -N distributed-uml-21.png
Binary files /dev/null and distributed-uml-21.png differ
Index: figures/distributed-uml-22.png
===================================================================
RCS file: distributed-uml-22.png
diff -N distributed-uml-22.png
Binary files /dev/null and distributed-uml-22.png differ
Index: figures/distributed-uml-23.png
===================================================================
RCS file: distributed-uml-23.png
diff -N distributed-uml-23.png
Binary files /dev/null and distributed-uml-23.png differ
Index: figures/distributed-uml-24.png
===================================================================
RCS file: distributed-uml-24.png
diff -N distributed-uml-24.png
Binary files /dev/null and distributed-uml-24.png differ
Index: figures/distributed-uml-3.png
===================================================================
RCS file: distributed-uml-3.png
diff -N distributed-uml-3.png
Binary files /dev/null and distributed-uml-3.png differ
Index: figures/distributed-uml-30.png
===================================================================
RCS file: distributed-uml-30.png
diff -N distributed-uml-30.png
Binary files /dev/null and distributed-uml-30.png differ
Index: figures/distributed-uml-4.png
===================================================================
RCS file: distributed-uml-4.png
diff -N distributed-uml-4.png
Binary files /dev/null and distributed-uml-4.png differ
Index: figures/distributed-uml-5.png
===================================================================
RCS file: distributed-uml-5.png
diff -N distributed-uml-5.png
Binary files /dev/null and distributed-uml-5.png differ
Index: figures/distributed-uml.mp
===================================================================
RCS file: distributed-uml.mp
diff -N distributed-uml.mp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- distributed-uml.mp	Mon Mar  4 15:51:05 2002
***************
*** 0 ****
--- 1,1138 ----
+ %% Oldham, Jeffrey D.
+ %% 2002Feb28
+ %% POOMA
+ 
+ %% UML Diagrams of Classes for Distributed Computation
+ 
+ 
+ %% Assumes TEX=latex.
+ 
+ %% Ensure fonts are included in the output.
+ prologues := 2;			% &gt;= 2 for PostScript
+ 
+ input boxes;
+ input box-macros;
+ input uml;
+ 
+ verbatimtex
+ \documentclass[10pt]{article}
+ \usepackage{amsmath}
+ \input{macros.ltx}
+ \usepackage{times}
+ \usepackage{mathptm}
+ \newlength{\cnw}	% Required to use \classnameWidth and \emptyBox
+ \begin{document}
+ etex
+ 
+ 
+ %% Draw the SpatialPartition box.
+ beginfig(3)
+   %% Create the boxes.
+   % SpatialPartition
+   boxit.sPartition[0](btex \classname{SpatialPartition} etex);
+   boxit.sPartition[1](btex etex);
+   boxit.sPartition[2](
+     btex
+     \begin{lists}
+     SpatialPartition(const RefLayout\&amp;) \\
+     SpatialPartition(const SpatialPartition\&amp;) \\
+     \tilder SpatialPartition() \\
+     SpatialPartition\&amp; operator=(const SpatialPartition\&amp;) \\
+     Loc&lt;1&gt; blocks() \\
+     int context() \\
+     bool hasCustomEdgeGuards()\\
+     const RefLayout\&amp; reference() \\
+     void print(Out\&amp;)
+     \end{lists} etex);
+   boxit.sPartition[3](
+     btex
+     \begin{lists}
+     RefLayout
+     \end{lists} etex);
+   boxit.sPartition[4](
+     btex \begin{files}
+     SpatialPartition.h
+     \end{files} etex);
+ 
+   % TilePartition
+   boxit.tPartition[0](btex \classname{TilePartition} etex);
+   boxit.tPartition[1](btex etex);
+   boxit.tPartition[2](
+     btex
+     \begin{lists}
+     TilePartition() \\
+     TilePartition(const PatchList\_t\&amp;) \\
+     TilePartition(const PatchList\_t\&amp;, const GL&lt;Dim&gt;\&amp;) \\
+     TilePartition(const PatchList\_t\&amp;, const GL&lt;Dim&gt;\&amp;, const GL&lt;Dim&gt;\&amp;) \\
+     TilePartition(const TilePartition\&amp;) \\
+     \tilder TilePartition() \\
+     TilePartition\&amp; operator=(const TilePartition\&amp;) \\
+     PatchList\_t tileList() \\
+     bool hasCustomEdgeGuards()\\
+     void print(Out\&amp;)
+     \end{lists} etex);
+   boxit.tPartition[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.tPartition[4](
+     btex \begin{files}
+     TilePartition.h
+     \end{files} etex);
+   
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=sPartition, tPartition:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=sPartition, tPartition:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=sPartition, tPartition:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   sPartition[0].c = origin;
+   sPartition[2].sw - tPartition[0].nw = (0,2yUnit);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=sPartition, tPartition:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=sPartition, tPartition:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=sPartition, tPartition:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw the GridPartition box.
+ beginfig(4)
+   %% Create the boxes.
+   % GridPartition
+   boxit.gPartition[0](btex \classname{GridPartition} etex);
+   boxit.gPartition[1](btex etex);
+   boxit.gPartition[2](
+     btex
+     \begin{lists}
+     GridPartition() \\
+     GridPartition(const Grid\&amp;) \\
+     GridPartition(const Grid\&amp;, const GuardLayers\&amp;) \\
+     GridPartition(const Grid\&amp;, const GuardLayers\&amp;, const GuardLayers\&amp;) \\
+     GridPartition(const Loc\&amp;) \\
+     GridPartition(const Loc\&amp;, const GuardLayers\&amp;) \\
+     GridPartition(const Loc\&amp;, const GuardLayers\&amp;, const GuardLayers\&amp;) \\
+     GridPartition(const GridPartition\&amp;) \\
+     GridPartition(const UniformGridPartition\&amp;) \\
+     \tilder GridPartition() \\
+     GridPartition\&amp; operator=(const GridPartition\&amp;) \\
+     const Loc\&amp; blocks() \\
+     bool hasCustomEdgeGuards()\\
+     const Grid\&amp; grid() \\
+     void print(Out\&amp;);
+     \end{lists} etex);
+   boxit.gPartition[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.gPartition[4](
+     btex \begin{files}
+     GridPartition.h
+     \end{files} etex);
+ 
+   % UniformGridPartition
+   boxit.ugPartition[0](btex \classname{UniformGridPartition} etex);
+   boxit.ugPartition[1](btex etex);
+   boxit.ugPartition[2](
+     btex
+     \begin{lists}
+     UniformGridPartition() \\
+     UniformGridPartition(const GL\&amp;) \\
+     UniformGridPartition(const Loc\&amp;) \\
+     UniformGridPartition(const Loc\&amp;, const GL\&amp;) \\
+     UniformGridPartition(const Loc\&amp;, const GL\&amp;, const GL\&amp;) \\
+     UniformGridPartition(const UniformGridPartition\&amp;) \\
+     \tilder UniformGridPartition() \\
+     UniformGridPartition\&amp; operator=(const UniformGridPartition\&amp;) \\
+     const Loc\&amp; blocks() \\
+     \end{lists} etex);
+   boxit.ugPartition[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.ugPartition[4](
+     btex \begin{files}
+     UniformGridPartition.h
+     \end{files} etex);
+   
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=gPartition, ugPartition:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=gPartition, ugPartition:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=gPartition, ugPartition:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   gPartition[0].c = origin;
+   gPartition[2].sw - ugPartition[0].nw = (0,2yUnit);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=gPartition, ugPartition:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=gPartition, ugPartition:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=gPartition, ugPartition:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw an abstract Partition box and related classes.
+ beginfig(5)
+   %% Create the boxes.
+   % Partition
+   boxit.partition[0](btex \classname{\emph{Partition}} etex);
+   boxit.partition[1](btex etex);
+   boxit.partition[2](
+     btex
+     \begin{lists}
+     Partition() \\
+     Partition(const Partition\&amp;) \\
+     \tilder Partition() \\
+     Partition\&amp; operator=(const Partition\&amp;) \\
+     int maxSize() \\
+     bool hasGuards()\\
+     bool hasInternalGuards() \\
+     bool hasExternalGuards() \\
+     const GuardLayers\&amp; internalGuards() \\
+     const GuardLayers\&amp; externalGuards() \\
+     int partition(const Dom\&amp;, List\_t\&amp;, const ContextMapper\&amp;) \\
+     int partition(const Dom\&amp;, List\_t\&amp;)
+     \end{lists} etex);
+   boxit.partition[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.ugPartition[0](btex \classname{UniformGridPartition} etex);
+   boxit.ugPartition[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.tPartition[0](btex \classname{TilePartition} etex);
+   boxit.tPartition[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.sPartition[0](btex \classname{SpatialPartition} etex);
+   boxit.sPartition[3](
+     btex
+     \begin{lists}
+     RefLayout
+     \end{lists} etex);
+   boxit.gPartition[0](btex \classname{GridPartition} etex);
+   boxit.gPartition[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=partition:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=gPartition, sPartition, tPartition, ugPartition:
+     fixsize($[0]);
+   endfor
+   forsuffixes $=partition, gPartition, sPartition, tPartition, ugPartition:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+ 
+   % Position the UML classes.
+   partition[0].c = origin;
+   gPartition[0].sw - sPartition[0].nw =
+   sPartition[0].sw - tPartition[0].nw =
+   tPartition[0].sw - ugPartition[0].nw = (0, yUnit);
+   partition[2].sw - gPartition[0].nw = (0,yUnit);
+ 
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=partition:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   forsuffixes $=gPartition, sPartition, tPartition, ugPartition:
+     for t = 0 upto 0:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=partition, gPartition, sPartition, tPartition, ugPartition:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+ 
+   %% Draw the realization lines.
+   z0 = 0.7[partition[2].sw,partition[2].se];
+   drawDiscriminator(z0, 0);
+   forsuffixes $=gPartition, sPartition, tPartition, ugPartition:
+     draw $[0].e -- (x0,ypart($[0].e)) dashed evenly;
+   endfor
+   draw (x0,ypart(ugPartition[0].e)) -- (z0 - (0,discriminatorLength)) dashed evenly;
+ 
+ endfig;
+ 
+ 
+ %% Draw the ContextMapper box.
+ beginfig(10)
+   %% Create the boxes.
+   % Partition
+   boxit.cMapper[0](btex \classname{ContextMapper} etex);
+   boxit.cMapper[1](btex etex);
+   boxit.cMapper[2](
+     btex
+     \begin{lists}
+     ContextMapper() \\
+     void setAffinity(const List\_t\&amp;)
+     \end{lists} etex);
+   boxit.cMapper[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.cMapper[4](
+     btex \begin{files}
+     ContextMapper.h
+     \end{files} etex);
+   boxit.lMapper[0](btex \classname{LocalMapper} etex);
+   boxit.lMapper[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.dMapper[0](btex \classname{DistributedMapper} etex);
+   boxit.dMapper[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.contMapper[0](btex \classname{ContiguousMapper} etex);
+   boxit.contMapper[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.biMapper[0](btex \classname{BisectionMapper} etex);
+   boxit.biMapper[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.unifMapper[0](btex \classname{UniformMapper} etex);
+ 
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=cMapper:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   samewidth(lMapper[0], dMapper[0], contMapper[0], biMapper[0], unifMapper[0]);
+   forsuffixes $=lMapper, dMapper, contMapper, biMapper, unifMapper:
+     fixsize($[0]);
+   endfor
+   forsuffixes $=cMapper, lMapper, dMapper, contMapper, biMapper:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=cMapper:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   cMapper[0].c = origin;
+   cMapper[2].ne - 0.5[lMapper[0].w,unifMapper[0].w] = (-2xUnit,0);
+   lMapper[0].sw - dMapper[0].nw =
+   dMapper[0].sw - contMapper[0].nw =
+   contMapper[0].sw - biMapper[0].nw =
+   biMapper[0].sw - unifMapper[0].nw = (0,yUnit);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=cMapper:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   forsuffixes $=lMapper, dMapper, contMapper, biMapper, unifMapper:
+     for t = 0 upto 0:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=cMapper, lMapper, dMapper, contMapper, biMapper:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=cMapper:
+     drawunboxed($[4]);
+   endfor
+ 
+   % Draw lines between classes.
+   drawDiscriminator(cMapper[1].e, 90);
+   x0 = xpart(0.5[cMapper[1].e,contMapper[0].w]);
+   y0 = ypart(cMapper[1].e);
+   draw (cMapper[1].e + (discriminatorLength,0)) -- z0;
+   forsuffixes $=lMapper, dMapper, contMapper, biMapper, unifMapper:
+     draw (x0,ypart($[0].w)) -- $[0].w;
+   endfor
+   label.top(btex \texttt{&lt;1&gt;} etex, 0.5[(x0,ypart(unifMapper[0].w)),unifMapper[0].w]);
+   draw (x0,ypart(lMapper[0].w)) -- (x0,ypart(unifMapper[0].w));
+   
+ endfig;
+ 
+ 
+ %% Draw the LocalMapper box.
+ beginfig(11)
+   %% Create the boxes.
+   % LocalMapper
+   boxit.lMapper[0](btex \classname{LocalMapper} etex);
+   boxit.lMapper[1](btex etex);
+   boxit.lMapper[2](
+     btex
+     \begin{lists}
+     LocalMapper() \\
+     LocalMapper(const Partitioner\&amp;) \\
+     void map(const List\_t\&amp;)
+     \end{lists} etex);
+   boxit.lMapper[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.lMapper[4](
+     btex \begin{files}
+     ContextMapper.h
+     \end{files} etex);
+   % DistributedMapper
+   boxit.dMapper[0](btex \classname{DistributedMapper} etex);
+   boxit.dMapper[1](btex etex);
+   boxit.dMapper[2](
+     btex
+     \begin{lists}
+     DistributedMapper(const Partitioner\&amp;) \\
+     void map(const List\_t\&amp;)
+     \end{lists} etex);
+   boxit.dMapper[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.dMapper[4](
+     btex \begin{files}
+     DistributedMapper.h
+     \end{files} etex);
+   % ContiguousMapper
+   boxit.contMapper[0](btex \classname{ContiguousMapper} etex);
+   boxit.contMapper[1](btex etex);
+   boxit.contMapper[2](
+     btex
+     \begin{lists}
+     ContiguousMapper(const Partitioner\&amp;) \\
+     ContiguousMapper(const Partitioner\&amp;, const Loc\&amp;) \\
+     void map(const List\_t\&amp;)
+     \end{lists} etex);
+   boxit.contMapper[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.contMapper[4](
+     btex \begin{files}
+     ContiguousMapper.h
+     \end{files} etex);
+   % BisectionMapper
+   boxit.biMapper[0](btex \classname{BisectionMapper} etex);
+   boxit.biMapper[1](btex etex);
+   boxit.biMapper[2](
+     btex
+     \begin{lists}
+     BisectionMapper(const Loc\&amp;) \\
+     BisectionMapper(const Partitioner\&amp;) \\
+     BisectionMapper(const Partitioner\&amp;, const Loc\&amp;) \\
+     void map(const List\_t\&amp;)
+     \end{lists} etex);
+   boxit.biMapper[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.biMapper[4](
+     btex \begin{files}
+     BisectionMapper.h
+     \end{files} etex);
+   % UniformMapper
+   boxit.unifMapper[0](btex \classname{UniformMapper} etex);
+   boxit.unifMapper[1](btex etex);
+   boxit.unifMapper[2](
+     btex
+     \begin{lists}
+     UniformMapper(const Loc&lt;1&gt;\&amp;) \\
+     UniformMapper(const Partitioner\&amp;) \\
+     UniformMapper(int) \\
+     \tilder UniformMapper() \\
+     void map(const List\_t\&amp;)
+     \end{lists} etex);
+   boxit.unifMapper[3](btex etex);
+   boxit.unifMapper[4](
+     btex \begin{files}
+     UniformMapper.h
+     \end{files} etex);
+   
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=lMapper, dMapper, contMapper, biMapper, unifMapper:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=lMapper, dMapper, contMapper, biMapper, unifMapper:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=lMapper, dMapper, contMapper, biMapper, unifMapper:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   lMapper[0].c = origin;
+   lMapper[2].sw - dMapper[0].nw =
+   dMapper[2].sw - contMapper[0].nw =
+   contMapper[2].sw - biMapper[0].nw =
+   biMapper[2].sw - unifMapper[0].nw =
+   (0,1.5yUnit);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=lMapper, dMapper, contMapper, biMapper, unifMapper:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=lMapper, dMapper, contMapper, biMapper:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=lMapper, dMapper, contMapper, biMapper, unifMapper:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw the UniformGridLayout class.
+ %% Abbreviate: GL = GuardLayers, RT = ReplicatedTag, DT = DistributedTag
+ beginfig(20)
+   %% Create the boxes.
+   % UniformGridLayout
+   boxit.UGL[0](btex \classname{UniformGridLayout} etex);
+   boxit.UGL[1](btex etex);
+   boxit.UGL[2](
+     btex
+     \begin{lists}
+     UniformGridLayout() \\
+     UniformGridLayout(const Interval\&amp;, const DT\&amp;) \\
+     UniformGridLayout(const Interval\&amp;, const GL\&amp;, const DT\&amp;) \\
+     UniformGridLayout(const Interval\&amp;, const Loc\&amp;, const DT\&amp;) \\
+     UniformGridLayout(const Interval\&amp;, const Loc\&amp;, const GL\&amp;, const DT\&amp;) \\
+     UniformGridLayout(const Iv\&amp;,const Loc\&amp;,const GL\&amp;,const GL\&amp;,const DT\&amp;) \\
+     UniformGridLayout(const Interval\&amp;, const RT\&amp;) \\
+     UniformGridLayout(const Interval\&amp;, const GL\&amp;, const RT\&amp;) \\
+     UniformGridLayout(const Interval\&amp;, const Loc\&amp;, const RT\&amp;) \\
+     UniformGridLayout(const Interval\&amp;, const Loc\&amp;, const GL\&amp;, const RT\&amp;) \\
+     UniformGridLayout(const Iv\&amp;,const Loc\&amp;,const GL\&amp;,const GL\&amp;,const RT\&amp;) \\
+     UniformGridLayout(const Interval\&amp;, const Partitioner\&amp;, const CM\&amp;) \\
+     UniformGridLayout(const Interval\&amp;, const Partitioner\&amp;, const DT\&amp;) \\
+     UniformGridLayout(const Interval\&amp;, const Partitioner\&amp;, const RT\&amp;) \\
+     UniformGridLayout(const UniformGridLayout\&amp;) \\
+     UniformGridLayout\&amp; operator=(const UniformGridLayout\&amp;) \\
+     \tilder UniformGridLayout() \\
+     void initialize(const Interval\&amp;, const DT\&amp;) \\
+     void initialize(const Interval\&amp;, const GL\&amp;, const DT\&amp;) \\
+     void initialize(const Interval\&amp;, const Loc\&amp;, const DT\&amp;) \\
+     void initialize(const Interval\&amp;, const Loc\&amp;, const GL\&amp;, const DT\&amp;) \\
+     void initialize(const Iv\&amp;,const Loc\&amp;,const GL\&amp;,const GL\&amp;,const DT\&amp;) \\
+     void initialize(const Interval\&amp;, const RT\&amp;) \\
+     void initialize(const Interval\&amp;, const GL\&amp;, const RT\&amp;) \\
+     void initialize(const Interval\&amp;, const Loc\&amp;, const RT\&amp;) \\
+     void initialize(const Interval\&amp;, const Loc\&amp;, const GL\&amp;, const RT\&amp;) \\
+     void initialize(const Iv\&amp;,const Loc\&amp;,const GL\&amp;,const GL\&amp;,const RT\&amp;) \\
+     void initialize(const Interval\&amp;, const Partitioner\&amp;, const CM\&amp;) \\
+     void initialize(const Interval\&amp;, const Partitioner\&amp;, const DT\&amp;) \\
+     void initialize(const Interval\&amp;, const Partitioner\&amp;, const RT\&amp;) \\
+     void initialize(const UniformGridLayout\&amp;) \\
+     void initialize(const Iv\&amp;,const List\_t\&amp;,const Loc\&amp;,bool,bool,\\
+       const GL\&amp;,const GL\&amp;) \\
+     void notify(Interval\&amp;, const ObserverEvent\&amp;) \\
+     void print(Ostream\&amp;)
+     \end{lists} etex);
+   boxit.UGL[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.UGL[4](
+     btex \begin{files}
+     UniformGridLayout.h
+     \end{files} etex);
+   
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=UGL:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=UGL:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=UGL:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   UGL[0].c = origin;
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=UGL:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=UGL:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=UGL:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw the SparseTileLayout class.
+ %% Abbreviate: GL = GuardLayers, RT = ReplicatedTag, DT = DistributedTag
+ beginfig(21)
+   %% Create the boxes.
+   % SparseTileLayout
+   boxit.STL[0](btex \classname{SparseTileLayout} etex);
+   boxit.STL[1](btex etex);
+   boxit.STL[2](
+     btex
+     \begin{lists}
+     SparseTileLayout() \\
+     SparseTileLayout(const Interval\&amp;) \\
+     SparseTileLayout(const Interval\&amp;, const GL\&amp;) \\
+     SparseTileLayout(const Interval\&amp;, const GL\&amp;, const GL\&amp;) \\
+     SparseTileLayout(Interval\&amp;, const PatchList\_t\&amp;, const RT\&amp;) \\
+     SparseTileLayout(const Iv\&amp;, const GL\&amp;, const PatchList\_t\&amp;, const RT\&amp;) \\
+     SpTlLa(const Iv\&amp;, const GL\&amp;, const GL\&amp;, const PatchList\_t\&amp;, const RT\&amp;) \\
+     SparseTileLayout(const Interval\&amp;, const Partitioner\&amp;, const RT\&amp;) \\
+     SparseTileLayout(Interval\&amp;, const PatchList\_t\&amp;, const DT\&amp;) \\
+     SparseTileLayout(const Iv\&amp;, const GL\&amp;, const PatchList\_t\&amp;, const DT\&amp;) \\
+     SpTlLa(const Iv\&amp;, const GL\&amp;, const GL\&amp;, const PatchList\_t\&amp;, const DT\&amp;) \\
+     SparseTileLayout(const Interval\&amp;, const Partitioner\&amp;, const DT\&amp;) \\
+     SparseTileLayout(const Interval\&amp;, const Partitioner\&amp;, const CM\&amp;) \\
+     SparseTileLayout(const SparseTileLayout\&amp;) \\
+     SparseTileLayout\&amp; operator=(const SparseTileLayout\&amp;) \\
+     \tilder SparseTileLayout() \\
+     void initialize(const Interval\&amp;) \\
+     void initialize(const Interval\&amp;, const GL\&amp;) \\
+     void initialize(const Interval\&amp;, const GL\&amp;, const PatchList\_t\&amp;) \\
+     void initialize(const Interval\&amp;, const Partitioner\&amp;) \\
+     BorderFillIterator\_t beginBorderFillList() \\
+     BorderFillIterator\_t endBorderFillList() \\
+     void notify(Interval\&amp;, const ObserverEvent\&amp;) \\
+     void print(Ostream\&amp;)
+     \end{lists} etex);
+   boxit.STL[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.STL[4](
+     btex \begin{files}
+     SparseTileLayout.h
+     \end{files} etex);
+   
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=STL:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=STL:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=STL:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   STL[0].c = origin;
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=STL:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=STL:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=STL:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw the DomainLayout class.
+ %% Abbreviate: GL = GuardLayers
+ beginfig(22)
+   %% Create the boxes.
+   % DomainLayout
+   boxit.DL[0](btex \classname{DomainLayout} etex);
+   boxit.DL[1](btex etex);
+   boxit.DL[2](
+     btex
+     \begin{lists}
+     DomainLayout() \\
+     DomainLayout(const Interval\&amp;) \\
+     DomainLayout(const Interval\&amp;, const GL\&amp;) \\
+     DomainLayout(const Interval\&amp;, const Node&lt;Interval&gt;\&amp;) \\
+     DomainLayout(const DomainLayout\&amp;) \\
+     \tilder DomainLayout() \\
+     void initialize(const Interval\&amp;) \\
+     void initialize(const Interval\&amp;, const GL\&amp;) \\
+     void initialize(const DomainLayout\&amp;) \\
+     \end{lists} etex);
+   boxit.DL[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.DL[4](
+     btex \begin{files}
+     DomainLayout.h
+     \end{files} etex);
+   
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=DL:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=DL:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=DL:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   DL[0].c = origin;
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=DL:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=DL:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=DL:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw the DynamicLayout class.
+ %% Abbreviate: GL = GuardLayers
+ beginfig(23)
+   %% Create the boxes.
+   % DynamicLayout
+   boxit.DyL[0](btex \classname{DynamicLayout} etex);
+   boxit.DyL[1](btex etex);
+   boxit.DyL[2](
+     btex
+     \begin{lists}
+     DynamicLayout() \\
+     DynamicLayout(const Interval&lt;1&gt;\&amp;) \\
+     DynamicLayout(const Interval&lt;1&gt;\&amp;, int) \\
+     DynamicLayout(const Grid&lt;1&gt;\&amp;) \\
+     DynamicLayout(const Interval&lt;1&gt;\&amp;, const Partitioner\&amp;) \\
+     DynamicLayout(const Interval&lt;1&gt;\&amp;, const Partitioner\&amp;, const CM&lt;1&gt;\&amp;) \\
+     DynamicLayout(const DynamicLayout\&amp;) \\
+     DynamicLayout\&amp; operator=(const DynamicLayout\&amp;) \\
+     \tilder DynamicLayout() \\
+     void initialize(const Interval&lt;1&gt;\&amp;) \\
+     void initialize(const Interval&lt;1&gt;\&amp;, const Grid&lt;1&gt;\&amp;) \\
+     void initialize(const Grid&lt;1&gt;\&amp;) \\
+     void initialize(const Interval&lt;1&gt;\&amp;, const Partitioner\&amp;) \\
+     void initialize(const Interval&lt;1&gt;\&amp;, const Partitioner\&amp;, const CM&lt;1&gt;\&amp;) \\
+     void initialize(const Interval&lt;1&gt;\&amp;, const List\_t\&amp;) \\
+     void print(Ostream\&amp;)
+     \end{lists} etex);
+   boxit.DyL[4](
+     btex \begin{files}
+     DynamicLayout.h
+     \end{files} etex);
+   
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=DyL:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=DyL:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   DyL[0].c = origin;
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=DyL:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=DyL:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw the GridLayout class.
+ %% Abbreviate: GL = GuardLayers
+ beginfig(24)
+   %% Create the boxes.
+   % GridLayout
+   boxit.GrL[0](btex \classname{GridLayout} etex);
+   boxit.GrL[1](btex etex);
+   boxit.GrL[2](
+     btex
+     \begin{lists}
+     GridLayout() \\
+     GridLayout(const Interval\&amp;, const DT\&amp;) \\
+     GridLayout(const Interval\&amp;, const GL\&amp;, const DT\&amp;) \\
+     GridLayout(const Interval\&amp;, const Loc\&amp;, const DT\&amp;) \\
+     GridLayout(const Interval\&amp;, const Loc\&amp;, const GL\&amp;, const DT\&amp;) \\
+     GridLayout(const Iv\&amp;, const Loc\&amp;, const GL\&amp;, const GL\&amp;, const DT\&amp;) \\
+     GridLayout(const Interval\&amp;, const Partitioner\&amp;, const DT\&amp;) \\
+     GridLayout(const Grid\&amp;, const DT\&amp;) \\
+     GridLayout(const Grid\&amp;, const GL\&amp;, const DT\&amp;) \\
+     GridLayout(const Grid\&amp;, const GL\&amp;, const GL\&amp;, const DT\&amp;) \\
+     GridLayout(const Interval\&amp;, const RT\&amp;) \\
+     GridLayout(const Interval\&amp;, const GL\&amp;, const RT\&amp;) \\
+     GridLayout(const Interval\&amp;, const Loc\&amp;, const RT\&amp;) \\
+     GridLayout(const Interval\&amp;, const Loc\&amp;, const GL\&amp;, const RT\&amp;) \\
+     GridLayout(const Iv\&amp;, const Loc\&amp;, const GL\&amp;, const GL\&amp;, const RT\&amp;) \\
+     GridLayout(const Interval\&amp;, const Partitioner\&amp;, const RT\&amp;) \\
+     GridLayout(const Grid\&amp;, const RT\&amp;) \\
+     GridLayout(const Grid\&amp;, const GL\&amp;, const RT\&amp;) \\
+     GridLayout(const Grid\&amp;, const GL\&amp;, const GL\&amp;, const RT\&amp;) \\
+     GridLayout(const Interval\&amp;, const Partitioner\&amp;, const ContextMapper\&amp;) \\
+     GridLayout(const GridLayout\&amp;) \\
+     GridLayout\&amp; operator=(const GridLayout\&amp;) \\
+     \tilder GridLayout() \\
+     void initialize(const Interval\&amp;, const DT\&amp;) \\
+     void initialize(const Interval\&amp;, const GL\&amp;, const DT\&amp;) \\
+     void initialize(const Interval\&amp;, const Loc\&amp;, const DT\&amp;) \\
+     void initialize(const Interval\&amp;, const Loc\&amp;, const GL\&amp;, const DT\&amp;) \\
+     void initialize(const Iv\&amp;,const Loc\&amp;,const GL\&amp;,const GL\&amp;,const DT\&amp;) \\
+     void initialize(const Interval\&amp;, const Partitioner\&amp;, const DT\&amp;) \\
+     void initialize(const Grid\&amp;, const DT\&amp;) \\
+     void initialize(const Grid\&amp;, const GL\&amp;, const DT\&amp;) \\
+     void initialize(const Grid\&amp;, const GL\&amp;, const GL\&amp;, const DT\&amp;) \\
+     void initialize(const Interval\&amp;, const RT\&amp;) \\
+     void initialize(const Interval\&amp;, const GL\&amp;, const RT\&amp;) \\
+     void initialize(const Interval\&amp;, const Loc\&amp;, const RT\&amp;) \\
+     void initialize(const Interval\&amp;, const Loc\&amp;, const GL\&amp;, const RT\&amp;) \\
+     void initialize(const Iv\&amp;,const Loc\&amp;,const GL\&amp;,const GL\&amp;,const RT\&amp;) \\
+     void initialize(const Interval\&amp;, const Partitioner\&amp;, const RT\&amp;) \\
+     void initialize(const Grid\&amp;, const RT\&amp;) \\
+     void initialize(const Grid\&amp;, const GL\&amp;, const RT\&amp;) \\
+     void initialize(const Grid\&amp;, const GL\&amp;, const GL\&amp;, const RT\&amp;) \\
+     void initialize(const Interval\&amp;, const Partitioner\&amp;, const CM\&amp;) \\
+     void initialize(const Iv\&amp;,const List\_t\&amp;,const Loc\&amp;,bool,bool,\\
+       const GL\&amp;,const GL\&amp;) \\
+     void print(Ostream\&amp;)
+     \end{lists} etex);
+   boxit.GrL[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.GrL[4](
+     btex \begin{files}
+     GridLayout.h
+     \end{files} etex);
+   
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=GrL:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=GrL:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=GrL:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   GrL[0].c = origin;
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=GrL:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=GrL:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=GrL:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw the GuardLayers class.
+ %% Abbreviate: GL = GuardLayers
+ beginfig(30)
+   %% Create the boxes.
+   % GuardLayers
+   boxit.GL[0](btex \classname{GuardLayers} etex);
+   boxit.GL[1](btex etex);
+   boxit.GL[2](
+     btex
+     \begin{lists}
+     GuardLayers() \\
+     GuardLayers(int) \\
+     GuardLayers(int, int) \\
+     GuardLayers(const Loc\&amp;, const Loc\&amp;) \\
+     void initialize(const Loc\&amp;, const Loc\&amp;) \\
+     void initialize(const GuardLayers\&amp;) \\
+     int lower(int) \\
+     int upper(int) \\
+     int\&amp; lower(int) \\
+     int\&amp; upper(int) \\
+     bool operator==(const GuardLayers\&amp;) \\
+     bool operator==(int) \\
+     bool operator!=(const GuardLayers\&amp;) \\
+     bool operator!=(int) \\
+     GuardLayers operator-(const GuardLayers\&amp;) \\
+     GuardLayers operator-(int) \\
+     static void addGuardLayers(Interval\&amp;, const GuardLayers\&amp;) \\
+     Interval addGuardLayersToDomain(const Interval\&amp;) \\
+     void print(Ostream\&amp;)
+     \end{lists} etex);
+   boxit.GL[3](
+     btex
+     \begin{lists}
+     dim D
+     \end{lists} etex);
+   boxit.GL[4](
+     btex \begin{files}
+     GuardLayers.h
+     \end{files} etex);
+   
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=GL:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=GL:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=GL:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   GL[0].c = origin;
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=GL:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=GL:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=GL:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ bye
Index: figures/domain-uml-1.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/domain-uml-1.png,v
retrieving revision 1.1
diff -c -p -r1.1 domain-uml-1.png
Binary files /tmp/cvshUnqvW and domain-uml-1.png differ
Index: figures/domain-uml.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/domain-uml.mp,v
retrieving revision 1.1
diff -c -p -r1.1 domain-uml.mp
*** figures/domain-uml.mp	2002/02/27 03:51:54	1.1
--- figures/domain-uml.mp	2002/03/04 22:51:06
*************** beginfig(1)
*** 145,151 ****
    boxit.grid[4](
      btex \begin{files}
      Grid.h \\
!     DomainTraits.Grid.h
      \end{files} etex);
    
    % Grid&lt;1&gt;
--- 145,152 ----
    boxit.grid[4](
      btex \begin{files}
      Grid.h \\
!     Domain-\\
!     Traits.Grid.h
      \end{files} etex);
    
    % Grid&lt;1&gt;
*************** beginfig(1)
*** 222,228 ****
      draw $[0].n -- ($[0].n+(0,foo));
    endfor
    draw loc[0].n+(0,foo) -- grid[0].n+(0,foo);
!   z0 = domain[2].s - (0,discriminatorScale);
    draw z0 -- (x0, ypart(loc[0].n+(0,foo)));
      
  endfig;
--- 223,229 ----
      draw $[0].n -- ($[0].n+(0,foo));
    endfor
    draw loc[0].n+(0,foo) -- grid[0].n+(0,foo);
!   z0 = domain[2].s - (0,discriminatorLength);
    draw z0 -- (x0, ypart(loc[0].n+(0,foo)));
      
  endfig;
Index: figures/engine-uml-1.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/engine-uml-1.png,v
retrieving revision 1.1
diff -c -p -r1.1 engine-uml-1.png
Binary files /tmp/cvs5QiAX4 and engine-uml-1.png differ
Index: figures/engine-uml.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/engine-uml.mp,v
retrieving revision 1.1
diff -c -p -r1.1 engine-uml.mp
*** figures/engine-uml.mp	2002/02/27 03:51:54	1.1
--- figures/engine-uml.mp	2002/03/04 22:51:09
*************** beginfig(1)
*** 72,78 ****
    taggedEngineTemplates =
    btex \begin{lists}
      dim D \\
!     val type T
      \end{lists} etex;
      
    boxit.brick[3](taggedEngineTemplates);
--- 72,78 ----
    taggedEngineTemplates =
    btex \begin{lists}
      dim D \\
!     value type T
      \end{lists} etex;
      
    boxit.brick[3](taggedEngineTemplates);
*************** beginfig(1)
*** 120,126 ****
      \end{lists} etex);
    boxit.dynamic[3](
      btex \begin{lists}
!     val type T
      \end{lists} etex);
    boxit.dynamic[4](
      btex \begin{files}
--- 120,126 ----
      \end{lists} etex);
    boxit.dynamic[3](
      btex \begin{lists}
!     value type T
      \end{lists} etex);
    boxit.dynamic[4](
      btex \begin{files}
*************** beginfig(1)
*** 147,155 ****
    boxit.multipatch[3](
      btex \begin{lists}
      dim D \\
!     val type T \\
!     layout LT \\
!     patch PT
      \end{lists} etex);
    boxit.multipatch[4](
      btex \begin{files}
--- 147,155 ----
    boxit.multipatch[3](
      btex \begin{lists}
      dim D \\
!     value type T \\
!     layout tag LT \\
!     patch tag PT
      \end{lists} etex);
    boxit.multipatch[4](
      btex \begin{files}
*************** beginfig(1)
*** 238,260 ****
    endfor
  
    % Position the UML classes.
!   engine[0].c = origin;
!   xpart(brick[0].w) = xpart(dynamic[0].w);
!   xpart(compressiblebrick[3].e) = xpart(multipatch[3].e);
!   ypart(brick[0].n - compressiblebrick[0].n) = 0;
!   ypart(dynamic[0].n - multipatch[0].n) = 0;
!   ypart(compressiblebrick[0].s - multipatch[3].n) = 
!   ypart(remote[0].s - remotedynamic[3].n) =
!   ypart(dynamic[0].s - remote[3].n) = yUnit;
!   numeric leftColumn;
!   leftColumn = max(xpart(brick[3].e),xpart(dynamic[3].e));
!   numeric rightColumn;
!   rightColumn = min(xpart(compressiblebrick[0].w),xpart(multipatch[0].w));
!   rightColumn - leftColumn = xUnit;
!   xpart(remote[0].n) = xpart(remotedynamic[0].n) = 0.5[leftColumn,rightColumn];
!   xpart(engine[2].s) = 0.5[leftColumn,rightColumn];
!   ypart(engine[2].s) = yUnit + max(ypart(brick[3].n),ypart(compressiblebrick[3].n));
!   
    %% Draw the boxes.
    % Draw the UML class boxes.
    forsuffixes $=engine:
--- 238,260 ----
    endfor
  
    % Position the UML classes.
!   numeric vertSep; vertSep = 0.4yUnit;
!   xpart(brick[0].sw - compressiblebrick[0].nw) = 0;
!   ypart(brick[0].sw - compressiblebrick[3].nw) = vertSep;
!   xpart(compressiblebrick[0].sw - dynamic[0].nw) = 0;
!   ypart(compressiblebrick[0].sw - dynamic[3].nw) = vertSep;
!   xpart(dynamic[0].sw - multipatch[0].nw) = 0;
!   ypart(dynamic[0].sw - multipatch[3].nw) = vertSep;
!   xpart(multipatch[0].sw - remote[0].nw) = 0;
!   ypart(multipatch[0].sw - remote[3].nw) = vertSep;
!   xpart(remote[0].sw - remotedynamic[0].nw) = 0;
!   ypart(remote[0].sw - remotedynamic[3].nw) = vertSep;
!   y0 = ypart(brick[3].n);
!   x0 = xUnit + max(xpart(brick[3].e), xpart(compressiblebrick[3].e),
!     xpart(dynamic[3].e), xpart(multipatch[3].e),
!     xpart(remote[3].e), xpart(remotedynamic[3].e));
!   engine[2].se = z0;
! 
    %% Draw the boxes.
    % Draw the UML class boxes.
    forsuffixes $=engine:
*************** beginfig(1)
*** 279,295 ****
    endfor
  
    % Draw arrows between classes.
    drawarrow (xpart(remote[0].s), ypart(remotedynamic[0].n)) -- remote[0].s dashed evenly;
-   numeric middleColumn; middleColumn = 0.5[leftColumn,rightColumn];
-   drawarrow multipatch[0].w -- (middleColumn,ypart(multipatch[0].w)) dashed evenly;
-   drawarrow dynamic[0].e -- (middleColumn, ypart(dynamic[0].e)) dashed evenly;
-   drawarrow compressiblebrick[0].w -- (middleColumn,ypart(compressiblebrick[0].w)) dashed evenly;
-   drawarrow brick[0].e -- (middleColumn, ypart(brick[0].e)) dashed evenly;
-   draw compressiblebrick[0].w -- brick[0].e dashed evenly;
-   drawarrow (middleColumn,ypart(multipatch[0].w)) -- engine[2].s
-   dashed evenly;
-   draw remote[0].n .. (middleColumn,ypart(multipatch[0].w)) dashed evenly;
- 
  endfig;
  
  
--- 279,289 ----
    endfor
  
    % Draw arrows between classes.
+   forsuffixes $=brick, compressiblebrick, dynamic, multipatch, remote:
+     draw $[0].e -- (x0, ypart($[0].e)) dashed evenly;
+   endfor
+   drawarrow (x0, ypart(remote[0].e)) -- z0 dashed evenly;
    drawarrow (xpart(remote[0].s), ypart(remotedynamic[0].n)) -- remote[0].s dashed evenly;
  endfig;
  
  
Index: figures/explanation-uml-1.png
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/explanation-uml-1.png,v
retrieving revision 1.1
diff -c -p -r1.1 explanation-uml-1.png
Binary files /tmp/cvsxE8ome and explanation-uml-1.png differ
Index: figures/explanation-uml.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/explanation-uml.mp,v
retrieving revision 1.1
diff -c -p -r1.1 explanation-uml.mp
*** figures/explanation-uml.mp	2002/02/27 03:51:54	1.1
--- figures/explanation-uml.mp	2002/03/04 22:51:09
*************** beginfig(1)
*** 79,85 ****
    % Loc
    boxit.loc[0](btex \classname{Classname2} etex);
    boxit.loc[1](btex \emptyBox{Interval&lt;1&gt;} etex);
!   boxit.loc[2](btex etex);
    boxit.loc[3](
      btex \begin{lists}
      template parameter T
--- 79,88 ----
    % Loc
    boxit.loc[0](btex \classname{Classname2} etex);
    boxit.loc[1](btex \emptyBox{Interval&lt;1&gt;} etex);
!   boxit.loc[2](
!     btex \begin{lists}
!     void foo(const X[1-3]\&amp;)
!     \end{lists} etex);
    boxit.loc[3](
      btex \begin{lists}
      template parameter T
*************** beginfig(1)
*** 220,226 ****
    forsuffixes $=loc:
      draw $[0].n -- ($[0].n+(0,foo));
    endfor
!   z0 = domain[2].s - (0,discriminatorScale);
    draw z0 -- (x0, ypart(loc[0].n+(0,foo)));
  
    % Add explanatory labels.
--- 223,229 ----
    forsuffixes $=loc:
      draw $[0].n -- ($[0].n+(0,foo));
    endfor
!   z0 = domain[2].s - (0,discriminatorLength);
    draw z0 -- (x0, ypart(loc[0].n+(0,foo)));
  
    % Add explanatory labels.
*************** beginfig(1)
*** 228,237 ****
      domain[1].e);
    label.rt(btex Public member functions, if any, are listed here. etex,
      domain[2].e);
!   label.rt(btex This class adds no new public member functions. etex,
      loc[2].e);
!   label.lrt(btex Template parameters are listed in dashed boxes. etex,
!     0.4[loc[3].sw,loc[3].s]);
    label.rt(btex Files implementing the class etex, loc[4].e);
    label.rt(btex A dashed arrow indicates an instantiated class. etex,
      0.7[loc[2].s,locOne[0].n]);
--- 231,240 ----
      domain[1].e);
    label.rt(btex Public member functions, if any, are listed here. etex,
      domain[2].e);
!   label.rt(btex This class adds one new public member function. etex,
      loc[2].e);
!   label.lrt(btex Template parameters occur in dashed boxes. etex,
!     0.8[loc[3].sw,loc[3].s]);
    label.rt(btex Files implementing the class etex, loc[4].e);
    label.rt(btex A dashed arrow indicates an instantiated class. etex,
      0.7[loc[2].s,locOne[0].n]);
Index: figures/field-uml-1.png
===================================================================
RCS file: field-uml-1.png
diff -N field-uml-1.png
Binary files /dev/null and field-uml-1.png differ
Index: figures/field-uml-10.png
===================================================================
RCS file: field-uml-10.png
diff -N field-uml-10.png
Binary files /dev/null and field-uml-10.png differ
Index: figures/field-uml-11.png
===================================================================
RCS file: field-uml-11.png
diff -N field-uml-11.png
Binary files /dev/null and field-uml-11.png differ
Index: figures/field-uml-2.png
===================================================================
RCS file: field-uml-2.png
diff -N field-uml-2.png
Binary files /dev/null and field-uml-2.png differ
Index: figures/field-uml-3.png
===================================================================
RCS file: field-uml-3.png
diff -N field-uml-3.png
Binary files /dev/null and field-uml-3.png differ
Index: figures/field-uml.mp
===================================================================
RCS file: field-uml.mp
diff -N field-uml.mp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- field-uml.mp	Mon Mar  4 15:51:12 2002
***************
*** 0 ****
--- 1,570 ----
+ %% Oldham, Jeffrey D.
+ %% 2002Feb28
+ %% POOMA
+ 
+ %% UML Diagrams of Field Classes
+ 
+ 
+ %% Assumes TEX=latex.
+ 
+ %% Ensure fonts are included in the output.
+ prologues := 2;			% &gt;= 2 for PostScript
+ 
+ input boxes;
+ input box-macros;
+ input uml;
+ 
+ verbatimtex
+ \documentclass[10pt]{article}
+ \usepackage{amsmath}
+ \input{macros.ltx}
+ \usepackage{times}
+ \usepackage{mathptm}
+ \newlength{\cnw}	% Required to use \classnameWidth and \emptyBox
+ \begin{document}
+ etex
+ 
+ 
+ %% Draw the NoMesh box.
+ beginfig(1)
+   %% Create the boxes.
+   % NoMesh
+   boxit.nomesh[0](btex \classname{NoMesh} etex);
+   boxit.nomesh[1](btex etex);
+   boxit.nomesh[2](
+     btex
+     \begin{lists}
+     NoMesh() \\
+     NoMesh(const Layout\&amp;) \\
+     NoMesh(const NoMesh\&amp;) \\
+     NoMesh(const NoMesh\&amp;, const Interval\&amp;) \\
+     NoMesh(const NoMesh\&amp;, const INode\&amp;) \\
+     NoMesh(const NoMesh\&amp;, const FieldEnginePatch\&amp;) \\
+     NoMesh(const Mesh\&amp;, const Dom\&amp;) \\
+     NoMesh\&amp; operator=(const NoMesh\&amp;) \\
+     \tilder NoMesh() \\
+     Interval\&amp; physicalVertexDomain() \\
+     Interval\&amp; physicalCellDomain() \\
+     Interval\&amp; totalVertexDomain() \\
+     Interval\&amp; totalCellDomain()
+     \end{lists} etex);
+   boxit.nomesh[3](
+     btex
+     \begin{lists}
+     dimension D
+     \end{lists} etex);
+   boxit.nomesh[4](
+     btex \begin{files}
+     NoMesh.h
+     \end{files} etex);
+ 
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=nomesh:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=nomesh:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=nomesh:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   nomesh[0].c = origin;
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=nomesh:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=nomesh:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=nomesh:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw the UniformRectilinearMesh box.
+ beginfig(2)
+   %% Create the boxes.
+   % UniformRectilinearMesh
+   boxit.urm[0](btex \classname{UniformRectilinearMesh} etex);
+   boxit.urm[1](btex etex);
+   boxit.urm[2](
+     btex
+     \begin{lists}
+     UniformRectilinearMesh() \\
+     UniformRectilinearMesh(const Layout\&amp;) \\
+     UniformRectilinearMesh(const Layout\&amp;, const Vector\&amp;, const Vector\&amp;) \\
+     UniformRectilinearMesh(const UniformRectilinearMesh\&amp;) \\
+     UniformRectilinearMesh(const URM\&amp;, const Interval\&amp;) \\
+     UniformRectilinearMesh(const UniformRectilinearMesh\&amp;, const INode\&amp;) \\
+     UniformRectilinearMesh(const URM\&amp;, const FieldEnginePatch\&amp;) \\
+     UniformRectilinearMesh(const Mesh\&amp;, const Dom\&amp;) \\
+     UniformRectilinearMesh\&amp; operator=(const UniformRectilinearMesh\&amp;) \\
+     \tilder UniformRectilinearMesh() \\
+     const Interval\&amp; physicalVertexDomain() \\
+     const Interval\&amp; physicalCellDomain() \\
+     const Interval\&amp; totalVertexDomain() \\
+     const Interval\&amp; totalCellDomain() \\
+     const Vector\&amp; spacings() \\
+     const Vector\&amp; origin() \\
+     const Vector\&amp; cellContaining(const Vector\&amp;) \\
+     const Vector\&amp; vertexPosition(const Loc\&amp;) \\
+     void initializePositions(Engine\&amp;, const Centering\&amp;) \\
+     void initializeNormals(Engine\&amp;, const Centering\&amp;) \\
+     void initializeNormals(Engine\&amp;, const Centering\&amp;, bool) \\
+     void initializeCellVolumes(Engine\&amp;, const Centering\&amp;) \\
+     void initializeFaceAreas(Engine\&amp;, const Centering\&amp;) \\
+     void initializeEdgeLengths(Engine\&amp;, const Centering\&amp;)
+     \end{lists} etex);
+   boxit.urm[3](
+     btex
+     \begin{lists}
+     dim D \\
+     value T
+     \end{lists} etex);
+   boxit.urm[4](
+     btex \begin{files}
+     UniformRectilinearMesh.h
+     \end{files} etex);
+ 
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=urm:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=urm:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=urm:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   urm[0].c = origin;
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=urm:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=urm:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=urm:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw the conceptual Mesh box.
+ beginfig(3)
+   %% Create the boxes.
+   % Mesh
+   boxit.mesh[0](btex \classname{\emph{Mesh}} etex);
+   boxit.mesh[1](btex etex);
+   boxit.mesh[2](
+     btex
+     \begin{lists}
+     Mesh() \\
+     Mesh(const Layout\&amp;) \\
+     Mesh(const Mesh\&amp;) \\
+     Mesh(const Mesh\&amp;, const Dom\&amp;) \\
+     Mesh\&amp; operator=(const Mesh\&amp;) \\
+     \tilder Mesh() \\
+     Interval\&amp; physicalVertexDomain() \\
+     Interval\&amp; physicalCellDomain() \\
+     Interval\&amp; totalVertexDomain() \\
+     Interval\&amp; totalCellDomain()
+     \end{lists} etex);
+   boxit.mesh[3](
+     btex
+     \begin{lists}
+     dimension D
+     \end{lists} etex);
+   boxit.mesh[4](btex etex);
+ 
+   % NoMesh
+   boxit.nomesh[0](btex \classname{NoMesh} etex);
+   boxit.nomesh[1](btex etex);
+   boxit.nomesh[2](
+     btex
+     \begin{lists}
+     NoMesh() \\
+     NoMesh(const Layout\&amp;) \\
+     NoMesh(const NoMesh\&amp;) \\
+     NoMesh(const NoMesh\&amp;, const Interval\&amp;) \\
+     NoMesh(const NoMesh\&amp;, const INode\&amp;) \\
+     NoMesh(const NoMesh\&amp;, const FieldEnginePatch\&amp;) \\
+     NoMesh(const Mesh\&amp;, const Dom\&amp;) \\
+     NoMesh\&amp; operator=(const NoMesh\&amp;) \\
+     \tilder NoMesh() \\
+     Interval\&amp; physicalVertexDomain() \\
+     Interval\&amp; physicalCellDomain() \\
+     Interval\&amp; totalVertexDomain() \\
+     Interval\&amp; totalCellDomain()
+     \end{lists} etex);
+   boxit.nomesh[3](
+     btex
+     \begin{lists}
+     dimension D
+     \end{lists} etex);
+   boxit.nomesh[4](
+     btex \begin{files}
+     NoMesh.h
+     \end{files} etex);
+ 
+   % UniformRectilinearMesh
+   boxit.urm[0](btex \classname{UniformRectilinearMesh} etex);
+   boxit.urm[1](btex etex);
+   boxit.urm[2](
+     btex
+     \begin{lists}
+     UniformRectilinearMesh() \\
+     UniformRectilinearMesh(const Layout\&amp;) \\
+     UniformRectilinearMesh(const Layout\&amp;, const Vector\&amp;, const Vector\&amp;) \\
+     UniformRectilinearMesh(const UniformRectilinearMesh\&amp;) \\
+     UniformRectilinearMesh(const UniformRectilinearMesh\&amp;, const Interval\&amp;) \\
+     UniformRectilinearMesh(const UniformRectilinearMesh\&amp;, const INode\&amp;) \\
+     UniformRectilinearMesh(const UniformRectilinearMesh\&amp;, const FieldEnginePatch\&amp;) \\
+     UniformRectilinearMesh(const Mesh\&amp;, const Dom\&amp;) \\
+     UniformRectilinearMesh\&amp; operator=(const UniformRectilinearMesh\&amp;) \\
+     \tilder UniformRectilinearMesh() \\
+     const Interval\&amp; physicalVertexDomain() \\
+     const Interval\&amp; physicalCellDomain() \\
+     const Interval\&amp; totalVertexDomain() \\
+     const Interval\&amp; totalCellDomain() \\
+     const Vector\&amp; spacings() \\
+     const Vector\&amp; origin() \\
+     const Vector\&amp; cellContaining(const Vector\&amp;) \\
+     const Vector\&amp; vertexPosition(const Loc\&amp;) \\
+     void initializePositions(Engine\&amp;, const Centering\&amp;) \\
+     void initializeNormals(Engine\&amp;, const Centering\&amp;) \\
+     void initializeNormals(Engine\&amp;, const Centering\&amp;, bool) \\
+     void initializeCellVolumes(Engine\&amp;, const Centering\&amp;) \\
+     void initializeFaceAreas(Engine\&amp;, const Centering\&amp;) \\
+     void initializeEdgeLengths(Engine\&amp;, const Centering\&amp;)
+     \end{lists} etex);
+   boxit.urm[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.urm[4](
+     btex \begin{files}
+     UniformRectilinearMesh.h
+     \end{files} etex);
+ 
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=mesh:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=nomesh, urm:
+     fixsize($[0]);
+   endfor
+   forsuffixes $=mesh, nomesh, urm:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+ 
+   % Position the UML classes.
+   nomesh[0].sw - urm[0].nw = (0, yUnit);
+   mesh[2].s - nomesh[0].nw = (0,yUnit);
+ 
+ %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=mesh:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   forsuffixes $=nomesh, urm:
+     for t = 0 upto 0:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=mesh, nomesh, urm:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   %% Draw the realization lines.
+   z0 = 0.2[mesh[2].sw,mesh[2].se];
+   drawDiscriminator(z0, 0);
+   forsuffixes $=nomesh, urm:
+     draw $[0].w -- (x0,ypart($[0].w)) dashed evenly;
+   endfor
+   draw (x0,ypart(urm[0].w)) -- (z0 - (0,discriminatorLength)) dashed evenly;
+   
+ %% HERE  
+ 
+ endfig;
+ 
+ 
+ %% Draw the Field box.
+ beginfig(10)
+   %% Create the boxes.
+   % Field
+   boxit.field[0](btex \classname{Field} etex);
+   boxit.field[1](btex etex);
+   boxit.field[2](
+     btex
+     \begin{lists}
+     Field() \\
+     Field(const X\&amp;) \\
+     Field(const Centering\&amp;, const Layout\&amp;, const M\&amp;) \\
+     Field(int, const Centering\&amp;, const Layout\&amp;, const M\&amp;)\\
+     Field(const Centering\&amp;, const Layout\&amp;, const X1\&amp;, const X2\&amp;)\\
+     Field(const Centering\&amp;, const Layout\&amp;) \\
+     Field(int, const Centering\&amp;, const Layout\&amp;, const X1\&amp;, const X2\&amp;) \\
+     Field(const Field\&amp;) \\
+     void initialize(const Centering\&amp;, const Layout\&amp;, const M\&amp;) \\
+     void initialize(int, const Centering\&amp;, const Layout\&amp;, const M\&amp;)\\
+     void initialize(const Centering\&amp;, const Layout\&amp;) \\
+     void initialize(const Field\&amp;) \\
+     \tilder Field() \\
+     const Engine\&amp; engine() \\
+     Engine\&amp; engine() \\
+     const FieldEngine\&amp; fieldEngine() \\
+     FieldEngine\&amp; fieldEngine() \\
+     int numSubFields() \\
+     const Centering\&amp; centering() \\
+     const Centering centering(int) \\
+     int centeringSize() \\
+     int numMaterials() \\
+     const Domain physicalCellDomain() \\
+     Domain totalCellDomain() \\
+     Domain physicalDomain(int) \\
+     Domain totalDomain(int) \\
+     Domain physicalDomain() \\
+     Domain totalDomain() \\
+     Domain domain() \\
+     const Mesh\&amp; mesh() \\
+     Layout layout() \\
+     Field\&amp; operator=(const Field\&amp;) \\
+     const Field\&amp; operator=(const Field\&amp;) \\
+     const Field\&amp; operator=(const X\&amp;) \\
+     const Field\&amp; operator+=(const X\&amp;) \\
+     const Field\&amp; operator-=(const X\&amp;) \\
+     const Field\&amp; operator*=(const X\&amp;) \\
+     const Field\&amp; operator/=(const X\&amp;) \\
+     const Field\&amp; operator\%=(const X\&amp;) \\
+     const Field\&amp; operator|=(const X\&amp;) \\
+     const Field\&amp; operator\&amp;=(const X\&amp;) \\
+     const Field\&amp; operator\^=(const X\&amp;) \\
+     const Field\&amp; operator&lt;&lt;=(const X\&amp;) \\
+     const Field\&amp; operator&gt;&gt;=(const X\&amp;) \\
+     void addRelation(RelationListItem*) \\
+     void removeRelations() \\
+     void applyRelations() \\
+     void applyRelations(bool) \\
+     void setDirty() \\
+     void clearDirty()
+     \end{lists} etex);
+   boxit.field[3](
+     btex
+     \begin{lists}
+     mesh M \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.field[4](
+     btex \begin{files}
+     Field.h \\
+     PrintField.h
+     \end{files} etex);
+ 
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=field:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=field:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=field:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   field[0].c = origin;
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=field:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=field:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=field:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ %% Draw the Centering box.
+ beginfig(11)
+   %% Create the boxes.
+   % Centering
+   boxit.centering[0](btex \classname{Centering} etex);
+   boxit.centering[1](btex etex);
+   boxit.centering[2](
+     btex
+     \begin{lists}
+     Centering() \\
+     Centering(CenteringType) \\
+     Centering(CenteringType, ContinuityType) \\
+     Centering(CenteringType, ContinuityType,\\
+       const Orientations\&amp;, const Positions\&amp;) \\
+     \tilder Centering() \\
+     const CenteringType\&amp;centeringType() \\
+     bool discontinuous() \\
+     bool continuous() \\
+     const Orientations\&amp; orientations() \\
+     const Positions\&amp; positions() \\
+     const Orientation\&amp; orientation(int) \\
+     const Position\&amp; position(int) \\
+     int size() \\
+     void addValue(const Orientation\&amp;, const Position\&amp;) \\
+     \end{lists} etex);
+   boxit.centering[3](
+     btex
+     \begin{lists}
+     dimension D
+     \end{lists} etex);
+   boxit.centering[4](
+     btex \begin{files}
+     FieldCentering.h
+     \end{files} etex);
+ 
+   % CanonicalCentering
+   boxit.ccentering[0](btex \classname{CanonicalCentering} etex);
+   boxit.ccentering[1](btex etex);
+   boxit.ccentering[2](
+     btex
+     \begin{lists}
+     CanonicalCentering() \\
+     \tilder CanonicalCentering() \\
+     Centering operator()(const CenteringType, ContinuityType) \\
+     Centering operator()(const CenteringType, ContinuityType, int) \\
+     \end{lists} etex);
+   boxit.ccentering[3](
+     btex
+     \begin{lists}
+     dimension D
+     \end{lists} etex);
+   boxit.ccentering[4](
+     btex \begin{files}
+     FieldCentering.h
+     \end{files} etex);
+ 
+   %% Position the boxes.
+   % Position the template parameters.
+   forsuffixes $=centering, ccentering:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   forsuffixes $=centering, ccentering:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=centering, ccentering:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+ 
+   % Position the UML classes.
+   centering[0].c = origin;
+   centering[2].sw - ccentering[0].nw = (0,2yUnit);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=centering, ccentering:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=centering, ccentering:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the implementation files.
+   forsuffixes $=centering, ccentering:
+     drawunboxed($[4]);
+   endfor
+ endfig;
+ 
+ 
+ bye
Index: figures/introduction.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/introduction.mp,v
retrieving revision 1.5
diff -c -p -r1.5 introduction.mp
*** figures/introduction.mp	2002/01/31 21:29:58	1.5
--- figures/introduction.mp	2002/03/04 22:51:12
*************** beginfig(101)
*** 48,54 ****
    boxit.b8(btex etex);
    nuBoxes = 8;
    boxit.b9(btex \textsl{implementation} etex);
- %%TMP  sameWidthSameHeight(b3,b4,b5,b6,b7,b8);
    sameWidthSameHeight(b3,b6);
    sameWidthSameHeight(b4,b7);
    sameWidthSameHeight(b5,b8);
--- 48,53 ----
Index: figures/macros.ltx
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/macros.ltx,v
retrieving revision 1.5
diff -c -p -r1.5 macros.ltx
*** figures/macros.ltx	2002/02/27 03:51:54	1.5
--- figures/macros.ltx	2002/03/04 22:51:12
***************
*** 43,48 ****
--- 43,53 ----
  \newcommand{\avoidFi}{F\mbox{}i}%
  	% Avoid a problem with dvitomp and ligatures.
  
+ \newcommand{\tilder}{\ensuremath{\tilde{}}\,}%
+ 	% Produce a tilde.
+ 	% We use math mode to avoid the fact that ordinary times does
+ 	% not have a tilde.
+ 
  %% UML Macros.
  
  % Produce a class's name, presumbly at the top of a UML class box.
Index: figures/math-objs-uml-1.png
===================================================================
RCS file: math-objs-uml-1.png
diff -N math-objs-uml-1.png
Binary files /dev/null and math-objs-uml-1.png differ
Index: figures/math-objs-uml-10.png
===================================================================
RCS file: math-objs-uml-10.png
diff -N math-objs-uml-10.png
Binary files /dev/null and math-objs-uml-10.png differ
Index: figures/math-objs-uml-11.png
===================================================================
RCS file: math-objs-uml-11.png
diff -N math-objs-uml-11.png
Binary files /dev/null and math-objs-uml-11.png differ
Index: figures/math-objs-uml-2.png
===================================================================
RCS file: math-objs-uml-2.png
diff -N math-objs-uml-2.png
Binary files /dev/null and math-objs-uml-2.png differ
Index: figures/math-objs-uml-3.png
===================================================================
RCS file: math-objs-uml-3.png
diff -N math-objs-uml-3.png
Binary files /dev/null and math-objs-uml-3.png differ
Index: figures/math-objs-uml-4.png
===================================================================
RCS file: math-objs-uml-4.png
diff -N math-objs-uml-4.png
Binary files /dev/null and math-objs-uml-4.png differ
Index: figures/math-objs-uml.mp
===================================================================
RCS file: math-objs-uml.mp
diff -N math-objs-uml.mp
*** /dev/null	Fri Mar 23 21:37:44 2001
--- math-objs-uml.mp	Mon Mar  4 15:51:16 2002
***************
*** 0 ****
--- 1,1174 ----
+ %% Oldham, Jeffrey D.
+ %% 2002Feb27
+ %% POOMA
+ 
+ %% UML Diagrams for Vectors, Matrices, Tensors
+ 
+ 
+ %% Assumes TEX=latex.
+ 
+ %% Ensure fonts are included in the output.
+ prologues := 2;			% &gt;= 2 for PostScript
+ 
+ input boxes;
+ input box-macros;
+ input uml;
+ 
+ verbatimtex
+ \documentclass[10pt]{article}
+ \usepackage{amsmath}
+ \input{macros.ltx}
+ \usepackage{times}
+ \usepackage{mathptm}
+ \newlength{\cnw}	% Required to use \classnameWidth and \emptyBox
+ \begin{document}
+ etex
+ 
+ 
+ %% Vectors and their engines
+ beginfig(1)
+   %% Create the boxes.
+   % Vector
+   boxit.vector[0](btex \classname{Vector} etex);
+   boxit.vector[1](btex etex);
+   boxit.vector[2](
+     btex \begin{lists}
+     Vector() \\
+     Vector(const Vector\&amp;) \\
+     Vector(const X\&amp;) \\
+     Vector(const X1\&amp;,const X2\&amp;) \\
+     Vector(const X1\&amp;,const X2\&amp;,const X3\&amp;) \\
+     Vector(const X1\&amp;,const X2\&amp;,const X3\&amp;,const X4\&amp;) \\
+     \tilder Vector() \\
+     Vector\&amp; operator=(const Vector\&amp;) \\
+     Vector\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int) \\
+     const Engine\&amp; engine() \\
+     Engine\&amp; engine() \\
+     void print(Out\&amp;)
+     \end{lists} etex);
+   boxit.vector[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.vector[4](
+     btex \begin{files}
+     Vector.h
+     \end{files} etex);
+   
+   % VectorEngine
+   boxit.vectorEngine[0](btex \classname{VectorEngine} etex);
+   boxit.vectorEngine[1](btex etex);
+   boxit.vectorEngine[2](btex etex);
+   boxit.vectorEngine[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.vectorEngine[4](
+     btex \begin{files}
+     VectorEngine.h
+     \end{files} etex);
+   
+   % VectorEngine&lt;D,T,Full&gt;
+   boxit.vectorEngineFull[0](btex \classname{VectorEngine&lt;D,T,Full&gt;} etex);
+   boxit.vectorEngineFull[1](btex etex);
+   boxit.vectorEngineFull[2](
+     btex \begin{lists}
+     VectorEngine() \\
+     VectorEngine(const VectorEngine\&amp;) \\
+     VectorEngine(const X\&amp;) \\
+     VectorEngine(const X1\&amp;,const X2\&amp;) \\
+     VectorEngine(const X1\&amp;,const X2\&amp;,const X3\&amp;) \\
+     VectorEngine(const X1\&amp;,const X2\&amp;,const X3\&amp;,const X4\&amp;) \\
+     \tilder VectorEngine() \\
+     VectorEngine\&amp; operator=(const VectorEngine\&amp;) \\
+     VectorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.vectorEngineFull[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.vectorEngineFull[4](
+     btex \begin{files}
+     Vector.h
+     \end{files} etex);
+   
+   %% Position the boxes.
+   % Position the boxes within the UML class diagrams.
+   forsuffixes $=vector, vectorEngine, vectorEngineFull:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   % Position the template parameters.
+   forsuffixes $=vector, vectorEngine, vectorEngineFull:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=vector, vectorEngine, vectorEngineFull:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+   
+   % Position the UML classes.
+   vector[0].c = origin;
+   vector[2].s - vectorEngine[0].n = (0, 3yUnit);
+   vectorEngine[2].s - vectorEngineFull[0].n = (0, yUnit);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=vector, vectorEngine, vectorEngineFull:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=vector, vectorEngine, vectorEngineFull:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the file names.
+   forsuffixes $=vector, vectorEngine, vectorEngineFull:
+     drawunboxed($[4]);
+   endfor
+   
+   % Draw arrows between classes.
+ 
+   % Draw lines between classes.
+   drawDiscriminator(vectorEngine[2].s, 0);
+   draw vectorEngineFull[0].n -- (vectorEngine[2].s-(0,discriminatorLength));
+ 
+ endfig;
+ 
+ 
+ %% Tensors and their engines
+ beginfig(2)
+   %% Create the boxes.
+   % Tensor
+   boxit.tensor[0](btex \classname{Tensor} etex);
+   boxit.tensor[1](btex etex);
+   boxit.tensor[2](
+     btex \begin{lists}
+     Tensor() \\
+     Tensor(const Tensor\&amp;) \\
+     Tensor(const X1\&amp;) \\
+     Tensor(const X[1-2]\&amp;) \\
+     Tensor(const X[1-3]\&amp;) \\
+     Tensor(const X[1-4]\&amp;) \\
+     Tensor(const X[1-5]\&amp;) \\
+     Tensor(const X[1-6]\&amp;) \\
+     Tensor(const X[1-7]\&amp;) \\
+     Tensor(const X[1-8]\&amp;) \\
+     Tensor(const X[1-9]\&amp;) \\
+     \tilder Tensor() \\
+     Tensor\&amp; operator=(const Tensor\&amp;) \\
+     Tensor\&amp; operator=(const Tensor&lt;D,T1,Tag1&gt;\&amp;) \\
+     Tensor\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int) \\
+     const Engine\&amp; engine() \\
+     Engine\&amp; engine() \\
+     void print(Out\&amp;)
+     \end{lists} etex);
+   boxit.tensor[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.tensor[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+   
+   % TensorEngine
+   boxit.tensorEngine[0](btex \classname{TensorEngine} etex);
+   boxit.tensorEngine[1](btex etex);
+   boxit.tensorEngine[2](btex etex);
+   boxit.tensorEngine[3](
+     btex
+     \begin{lists}
+     dim D \\
+     value T \\
+     engine E
+     \end{lists} etex);
+   boxit.tensorEngine[4](
+     btex \begin{files}
+     TensorEngine.h
+     \end{files} etex);
+   
+   % TensorEngine&lt;D,T,Full&gt;
+   boxit.teFull[0](btex \classname{TensorEngine&lt;D,T,Full&gt;} etex);
+   boxit.teFull[1](btex etex);
+   boxit.teFull[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Full&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-4]\&amp;) \\
+     TensorEngine(const X[1-9]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teFull[3](
+     btex
+     \begin{lists}
+     dim D \\
+     value T
+     \end{lists} etex);
+   boxit.teFull[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+   
+   % TensorEngine&lt;D,T,Antisymmetric&gt;
+   boxit.teAntisymmetric[0](btex \classname{TensorEngine&lt;D,T,Antisymmetric&gt;} etex);
+   boxit.teAntisymmetric[1](btex etex);
+   boxit.teAntisymmetric[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Antisymmetric&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-3]\&amp;) \\
+     TensorEngine(const X[1-6]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teAntisymmetric[3](
+     btex
+     \begin{lists}
+     dim D \\
+     value T
+     \end{lists} etex);
+   boxit.teAntisymmetric[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+ 
+   % TensorEngine&lt;D,T,Symmetric&gt;
+   boxit.teSymmetric[0](btex \classname{TensorEngine&lt;D,T,Symmetric&gt;} etex);
+   boxit.teSymmetric[1](btex etex);
+   boxit.teSymmetric[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Symmetric&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-3]\&amp;) \\
+     TensorEngine(const X[1-6]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teSymmetric[3](
+     btex
+     \begin{lists}
+     dim D \\
+     value T
+     \end{lists} etex);
+   boxit.teSymmetric[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+ 
+   % TensorEngine&lt;D,T,Diagonal&gt;
+   boxit.teDiagonal[0](btex \classname{TensorEngine&lt;D,T,Diagonal&gt;} etex);
+   boxit.teDiagonal[1](btex etex);
+   boxit.teDiagonal[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Symmetric&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-2]\&amp;) \\
+     TensorEngine(const X[1-3]\&amp;) \\
+     TensorEngine(const X[1-4]\&amp;) \\
+     TensorEngine(const X[1-5]\&amp;) \\
+     TensorEngine(const X[1-6]\&amp;) \\
+     TensorEngine(const X[1-7]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teDiagonal[3](
+     btex
+     \begin{lists}
+     dim D \\
+     value T
+     \end{lists} etex);
+   boxit.teDiagonal[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+ 
+   %% Position the boxes.
+   % Position the boxes within the UML class diagrams.
+   forsuffixes $=tensor, tensorEngine:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   samewidth(teFull[0],teAntisymmetric[0],teSymmetric[0],teDiagonal[0]);
+   forsuffixes $=teFull,teAntisymmetric,teSymmetric,teDiagonal:
+     fixsize($[0]);
+   endfor
+   % Position the template parameters.
+   forsuffixes $=tensor, tensorEngine, teFull,teAntisymmetric,teSymmetric,teDiagonal:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=tensor, tensorEngine:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+   
+   % Position the UML classes.
+   tensor[0].c = origin;
+   tensor[2].sw - tensorEngine[0].nw = (0, 4yUnit);
+   teFull[0].s - teAntisymmetric[0].n =
+   teAntisymmetric[0].s - teSymmetric[0].n =
+   teSymmetric[0].s - teDiagonal[0].n = (0, 1.5yUnit);
+   tensorEngine[1].e - 0.5[teAntisymmetric[0].sw,teSymmetric[0].nw] = (-3xUnit,0);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=tensor, tensorEngine:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   forsuffixes $=teFull,teAntisymmetric,teSymmetric,teDiagonal:
+     for t = 0 upto 0:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=tensor, tensorEngine, teFull,teAntisymmetric,teSymmetric,teDiagonal:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the file names.
+   forsuffixes $=tensor, tensorEngine:
+     drawunboxed($[4]);
+   endfor
+   
+   % Draw arrows between classes.
+ 
+   % Draw lines between classes.
+   drawDiscriminator(tensorEngine[1].e, 90);
+   x0 = xpart(0.5[tensorEngine[3].e,teAntisymmetric[0].w]);
+   y0 = ypart(tensorEngine[1].e);
+   draw (tensorEngine[1].e + (discriminatorLength,0)) -- z0;
+   forsuffixes $=teFull,teAntisymmetric,teSymmetric,teDiagonal:
+     draw (x0,ypart($[0].w)) -- $[0].w;
+   endfor
+   draw (x0,ypart(teFull[0].w)) -- (x0,ypart(teDiagonal[0].w));
+ endfig;
+ 
+ 
+ %% TensorEngine&lt;...,Full&gt; and TensorEngine&lt;...,Diagonal&gt;
+ beginfig(3)
+   %% Create the boxes.
+   % Tensor
+   boxit.tensor[0](btex \classname{Tensor} etex);
+   boxit.tensor[1](btex etex);
+   boxit.tensor[2](
+     btex \begin{lists}
+     Tensor() \\
+     Tensor(const Tensor\&amp;) \\
+     Tensor(const X1\&amp;) \\
+     Tensor(const X[1-2]\&amp;) \\
+     Tensor(const X[1-3]\&amp;) \\
+     Tensor(const X[1-4]\&amp;) \\
+     Tensor(const X[1-5]\&amp;) \\
+     Tensor(const X[1-6]\&amp;) \\
+     Tensor(const X[1-7]\&amp;) \\
+     Tensor(const X[1-8]\&amp;) \\
+     Tensor(const X[1-9]\&amp;) \\
+     \tilder Tensor() \\
+     Tensor\&amp; operator=(const Tensor\&amp;) \\
+     Tensor\&amp; operator=(const Tensor&lt;D,T1,Tag1&gt;\&amp;) \\
+     Tensor\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int) \\
+     const Engine\&amp; engine() \\
+     Engine\&amp; engine() \\
+     void print(Out\&amp;)
+     \end{lists} etex);
+   boxit.tensor[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.tensor[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+   
+   % TensorEngine
+   boxit.tensorEngine[0](btex \classname{TensorEngine} etex);
+   boxit.tensorEngine[1](btex etex);
+   boxit.tensorEngine[2](btex etex);
+   boxit.tensorEngine[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.tensorEngine[4](
+     btex \begin{files}
+     TensorEngine.h
+     \end{files} etex);
+   
+   % TensorEngine&lt;D,T,Full&gt;
+   boxit.teFull[0](btex \classname{TensorEngine&lt;D,T,Full&gt;} etex);
+   boxit.teFull[1](btex etex);
+   boxit.teFull[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Full&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-4]\&amp;) \\
+     TensorEngine(const X[1-9]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teFull[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.teFull[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+   
+   % TensorEngine&lt;D,T,Antisymmetric&gt;
+   boxit.teAntisymmetric[0](btex \classname{TensorEngine&lt;D,T,Antisymmetric&gt;} etex);
+   boxit.teAntisymmetric[1](btex etex);
+   boxit.teAntisymmetric[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Antisymmetric&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-3]\&amp;) \\
+     TensorEngine(const X[1-6]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teAntisymmetric[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.teAntisymmetric[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+ 
+   % TensorEngine&lt;D,T,Symmetric&gt;
+   boxit.teSymmetric[0](btex \classname{TensorEngine&lt;D,T,Symmetric&gt;} etex);
+   boxit.teSymmetric[1](btex etex);
+   boxit.teSymmetric[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Symmetric&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-3]\&amp;) \\
+     TensorEngine(const X[1-6]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teSymmetric[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.teSymmetric[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+ 
+   % TensorEngine&lt;D,T,Diagonal&gt;
+   boxit.teDiagonal[0](btex \classname{TensorEngine&lt;D,T,Diagonal&gt;} etex);
+   boxit.teDiagonal[1](btex etex);
+   boxit.teDiagonal[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Symmetric&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-2]\&amp;) \\
+     TensorEngine(const X[1-3]\&amp;) \\
+     TensorEngine(const X[1-4]\&amp;) \\
+     TensorEngine(const X[1-5]\&amp;) \\
+     TensorEngine(const X[1-6]\&amp;) \\
+     TensorEngine(const X[1-7]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teDiagonal[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.teDiagonal[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+ 
+   %% Position the boxes.
+   % Position the boxes within the UML class diagrams.
+   forsuffixes $=teFull, teDiagonal:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   % Position the template parameters.
+   forsuffixes $=teFull, teDiagonal:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=teFull, teDiagonal:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+   
+   % Position the UML classes.
+   teFull[0].c = origin;
+   teFull[2].sw - teDiagonal[0].nw = (0, 2yUnit);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=teFull, teDiagonal:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=teFull, teDiagonal:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the file names.
+   forsuffixes $=teFull, teDiagonal:
+     drawunboxed($[4]);
+   endfor
+   
+   % Draw arrows between classes.
+ 
+   % Draw lines between classes.
+ endfig;
+ 
+ 
+ %% TensorEngine&lt;...,Antisymmetric&gt; and TensorEngine&lt;...,Symmetric&gt;
+ beginfig(4)
+   %% Create the boxes.
+   % Tensor
+   boxit.tensor[0](btex \classname{Tensor} etex);
+   boxit.tensor[1](btex etex);
+   boxit.tensor[2](
+     btex \begin{lists}
+     Tensor() \\
+     Tensor(const Tensor\&amp;) \\
+     Tensor(const X1\&amp;) \\
+     Tensor(const X[1-2]\&amp;) \\
+     Tensor(const X[1-3]\&amp;) \\
+     Tensor(const X[1-4]\&amp;) \\
+     Tensor(const X[1-5]\&amp;) \\
+     Tensor(const X[1-6]\&amp;) \\
+     Tensor(const X[1-7]\&amp;) \\
+     Tensor(const X[1-8]\&amp;) \\
+     Tensor(const X[1-9]\&amp;) \\
+     \tilder Tensor() \\
+     Tensor\&amp; operator=(const Tensor\&amp;) \\
+     Tensor\&amp; operator=(const Tensor&lt;D,T1,Tag1&gt;\&amp;) \\
+     Tensor\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int) \\
+     const Engine\&amp; engine() \\
+     Engine\&amp; engine() \\
+     void print(Out\&amp;)
+     \end{lists} etex);
+   boxit.tensor[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.tensor[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+   
+   % TensorEngine
+   boxit.tensorEngine[0](btex \classname{TensorEngine} etex);
+   boxit.tensorEngine[1](btex etex);
+   boxit.tensorEngine[2](btex etex);
+   boxit.tensorEngine[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.tensorEngine[4](
+     btex \begin{files}
+     TensorEngine.h
+     \end{files} etex);
+   
+   % TensorEngine&lt;D,T,Full&gt;
+   boxit.teFull[0](btex \classname{TensorEngine&lt;D,T,Full&gt;} etex);
+   boxit.teFull[1](btex etex);
+   boxit.teFull[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Full&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-4]\&amp;) \\
+     TensorEngine(const X[1-9]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teFull[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.teFull[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+   
+   % TensorEngine&lt;D,T,Antisymmetric&gt;
+   boxit.teAntisymmetric[0](btex \classname{TensorEngine&lt;D,T,Antisymmetric&gt;} etex);
+   boxit.teAntisymmetric[1](btex etex);
+   boxit.teAntisymmetric[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Antisymmetric&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-3]\&amp;) \\
+     TensorEngine(const X[1-6]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teAntisymmetric[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.teAntisymmetric[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+ 
+   % TensorEngine&lt;D,T,Symmetric&gt;
+   boxit.teSymmetric[0](btex \classname{TensorEngine&lt;D,T,Symmetric&gt;} etex);
+   boxit.teSymmetric[1](btex etex);
+   boxit.teSymmetric[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Symmetric&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-3]\&amp;) \\
+     TensorEngine(const X[1-6]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teSymmetric[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.teSymmetric[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+ 
+   % TensorEngine&lt;D,T,Diagonal&gt;
+   boxit.teDiagonal[0](btex \classname{TensorEngine&lt;D,T,Diagonal&gt;} etex);
+   boxit.teDiagonal[1](btex etex);
+   boxit.teDiagonal[2](
+     btex \begin{lists}
+     TensorEngine() \\
+     TensorEngine(const TensorEngine&lt;D,T,Symmetric&gt;\&amp;) \\
+     TensorEngine(const T\&amp;) \\
+     TensorEngine(const X\&amp;) \\
+     TensorEngine(const X[1-2]\&amp;) \\
+     TensorEngine(const X[1-3]\&amp;) \\
+     TensorEngine(const X[1-4]\&amp;) \\
+     TensorEngine(const X[1-5]\&amp;) \\
+     TensorEngine(const X[1-6]\&amp;) \\
+     TensorEngine(const X[1-7]\&amp;) \\
+     \tilder TensorEngine() \\
+     TensorEngine\&amp; operator=(const TensorEngine\&amp;) \\
+     TensorEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.teDiagonal[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.teDiagonal[4](
+     btex \begin{files}
+     Tensor.h
+     \end{files} etex);
+ 
+   %% Position the boxes.
+   % Position the boxes within the UML class diagrams.
+   forsuffixes $=teAntisymmetric, teSymmetric:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   % Position the template parameters.
+   forsuffixes $=teAntisymmetric, teSymmetric:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=teAntisymmetric, teSymmetric:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+   
+   % Position the UML classes.
+   teAntisymmetric[0].c = origin;
+   teAntisymmetric[2].sw - teSymmetric[0].nw = (0, 2yUnit);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=teAntisymmetric, teSymmetric:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=teAntisymmetric, teSymmetric:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the file names.
+   forsuffixes $=teAntisymmetric, teSymmetric:
+     drawunboxed($[4]);
+   endfor
+   
+   % Draw arrows between classes.
+ 
+   % Draw lines between classes.
+ endfig;
+ 
+ 
+ %% TinyMatrix
+ beginfig(10)
+   %% Create the boxes.
+   % Tensor
+   boxit.matrix[0](btex \classname{TinyMatrix} etex);
+   boxit.matrix[1](btex etex);
+   boxit.matrix[2](
+     btex \begin{lists}
+     TinyMatrix() \\
+     TinyMatrix(const TinyMatrix\&amp;) \\
+     TinyMatrix(const X1\&amp;) \\
+     TinyMatrix(const X[1-2]\&amp;) \\
+     TinyMatrix(const X[1-3]\&amp;) \\
+     TinyMatrix(const X[1-4]\&amp;) \\
+     TinyMatrix(const X[1-5]\&amp;) \\
+     TinyMatrix(const X[1-6]\&amp;) \\
+     TinyMatrix(const X[1-7]\&amp;) \\
+     TinyMatrix(const X[1-8]\&amp;) \\
+     TinyMatrix(const X[1-9]\&amp;) \\
+     \tilder TinyMatrix() \\
+     TinyMatrix\&amp; operator=(const TinyMatrix\&amp;) \\
+     TinyMatrix\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int) \\
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int) \\
+     const Engine\&amp; engine() \\
+     Engine\&amp; engine() \\
+     void print(Out\&amp;)
+     \end{lists} etex);
+   boxit.matrix[3](
+     btex
+     \begin{lists}
+     dimension D1 \\
+     dimension D2 \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.matrix[4](
+     btex \begin{files}
+     TinyMatrix.h
+     \end{files} etex);
+   
+   % MatrixEngine
+   boxit.matrixEngine[0](btex \classname{TinyMatrixEngine} etex);
+   boxit.matrixEngine[1](btex etex);
+   boxit.matrixEngine[2](btex etex);
+   boxit.matrixEngine[3](
+     btex
+     \begin{lists}
+     dimension D1 \\
+     dimension D2 \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.matrixEngine[4](
+     btex \begin{files}
+     TinyMatrixEngine.h
+     \end{files} etex);
+   
+   % TinyMatrixEngine&lt;D1,D2,T,Full&gt;
+   boxit.matrixEngineFull[0](btex \classname{TinyMatrixEngine&lt;D1,D2,T,Full&gt;} etex);
+   boxit.matrixEngineFull[1](btex etex);
+   boxit.matrixEngineFull[2](
+     btex \begin{lists}
+     TinyMatrixEngine() \\
+     TinyMatrixEngine(const TinyMatrixEngine&lt;D,T,Full&gt;\&amp;) \\
+     TinyMatrixEngine(const X\&amp;) \\
+     TinyMatrixEngine(const X[1-2]\&amp;) \\
+     TinyMatrixEngine(const X[1-3]\&amp;) \\
+     TinyMatrixEngine(const X[1-4]\&amp;) \\
+     TinyMatrixEngine(const X[1-5]\&amp;) \\
+     TinyMatrixEngine(const X[1-6]\&amp;) \\
+     TinyMatrixEngine(const X[1-7]\&amp;) \\
+     TinyMatrixEngine(const X[1-8]\&amp;) \\
+     TinyMatrixEngine(const X[1-9]\&amp;) \\
+     \tilder TinyMatrixEngine() \\
+     TinyMatrixEngine\&amp; operator=(const TinyMatrixEngine\&amp;) \\
+     TinyMatrixEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.matrixEngineFull[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.matrixEngineFull[4](
+     btex \begin{files}
+     TinyMatrix.h
+     \end{files} etex);
+ 
+   %% Position the boxes.
+   % Position the boxes within the UML class diagrams.
+   forsuffixes $=matrix, matrixEngine, matrixEngineFull:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   % Position the template parameters.
+   forsuffixes $=matrix, matrixEngine, matrixEngineFull:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=matrix, matrixEngine, matrixEngineFull:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+   
+   % Position the UML classes.
+   matrix[0].c = origin;
+   matrix[2].s - matrixEngine[0].n = (0, 3yUnit);
+   matrixEngine[2].s - matrixEngineFull[0].n = (0, yUnit);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=matrix:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=matrix:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the file names.
+   forsuffixes $=matrix:
+     drawunboxed($[4]);
+   endfor
+   
+   % Draw arrows between classes.
+ 
+   % Draw lines between classes.
+ endfig;
+ 
+ %% TinyMatrix
+ beginfig(11)
+   %% Create the boxes.
+   % Tensor
+   boxit.matrix[0](btex \classname{TinyMatrix} etex);
+   boxit.matrix[1](btex etex);
+   boxit.matrix[2](
+     btex \begin{lists}
+     TinyMatrix() \\
+     TinyMatrix(const TinyMatrix\&amp;) \\
+     TinyMatrix(const X1\&amp;) \\
+     TinyMatrix(const X[1-2]\&amp;) \\
+     TinyMatrix(const X[1-3]\&amp;) \\
+     TinyMatrix(const X[1-4]\&amp;) \\
+     TinyMatrix(const X[1-5]\&amp;) \\
+     TinyMatrix(const X[1-6]\&amp;) \\
+     TinyMatrix(const X[1-7]\&amp;) \\
+     TinyMatrix(const X[1-8]\&amp;) \\
+     TinyMatrix(const X[1-9]\&amp;) \\
+     \tilder TinyMatrix() \\
+     TinyMatrix\&amp; operator=(const TinyMatrix\&amp;) \\
+     TinyMatrix\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int) \\
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int) \\
+     const Engine\&amp; engine() \\
+     Engine\&amp; engine() \\
+     void print(Out\&amp;)
+     \end{lists} etex);
+   boxit.matrix[3](
+     btex
+     \begin{lists}
+     dimension D1 \\
+     dimension D2 \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.matrix[4](
+     btex \begin{files}
+     TinyMatrix.h
+     \end{files} etex);
+   
+   % MatrixEngine
+   boxit.matrixEngine[0](btex \classname{TinyMatrixEngine} etex);
+   boxit.matrixEngine[1](btex etex);
+   boxit.matrixEngine[2](btex etex);
+   boxit.matrixEngine[3](
+     btex
+     \begin{lists}
+     dimension D1 \\
+     dimension D2 \\
+     value type T \\
+     engine type E
+     \end{lists} etex);
+   boxit.matrixEngine[4](
+     btex \begin{files}
+     TinyMatrixEngine.h
+     \end{files} etex);
+   
+   % TinyMatrixEngine&lt;D1,D2,T,Full&gt;
+   boxit.matrixEngineFull[0](btex \classname{TinyMatrixEngine&lt;D1,D2,T,Full&gt;} etex);
+   boxit.matrixEngineFull[1](btex etex);
+   boxit.matrixEngineFull[2](
+     btex \begin{lists}
+     TinyMatrixEngine() \\
+     TinyMatrixEngine(const TinyMatrixEngine&lt;D,T,Full&gt;\&amp;) \\
+     TinyMatrixEngine(const X\&amp;) \\
+     TinyMatrixEngine(const X[1-2]\&amp;) \\
+     TinyMatrixEngine(const X[1-3]\&amp;) \\
+     TinyMatrixEngine(const X[1-4]\&amp;) \\
+     TinyMatrixEngine(const X[1-5]\&amp;) \\
+     TinyMatrixEngine(const X[1-6]\&amp;) \\
+     TinyMatrixEngine(const X[1-7]\&amp;) \\
+     TinyMatrixEngine(const X[1-8]\&amp;) \\
+     TinyMatrixEngine(const X[1-9]\&amp;) \\
+     \tilder TinyMatrixEngine() \\
+     TinyMatrixEngine\&amp; operator=(const TinyMatrixEngine\&amp;) \\
+     TinyMatrixEngine\&amp; operator=(const X\&amp;) \\
+     const T\&amp; operator()(int,int) \\
+     T\&amp; operator()(int,int)
+     const T\&amp; operator()(int) \\
+     T\&amp; operator()(int)
+     \end{lists} etex);
+   boxit.matrixEngineFull[3](
+     btex
+     \begin{lists}
+     dimension D \\
+     value type T
+     \end{lists} etex);
+   boxit.matrixEngineFull[4](
+     btex \begin{files}
+     TinyMatrix.h
+     \end{files} etex);
+ 
+   %% Position the boxes.
+   % Position the boxes within the UML class diagrams.
+   forsuffixes $=matrix, matrixEngine, matrixEngineFull:
+     samewidth($[0],$[1],$[2]);
+     for t = 0 upto 1:
+       $.[t].se = $[t+1].ne;
+       $.[t].sw = $[t+1].nw;
+     endfor
+     fixsize($[0],$[1],$[2]);
+   endfor
+   % Position the template parameters.
+   forsuffixes $=matrix, matrixEngine, matrixEngineFull:
+     fixsize($[3]);
+     $[0].ne - $[3].sw  =
+     (min(0.5 xpart($[3].ne - $[3].sw), $[0].dx),
+       min(0.5 ypart($[3].ne - $[3].sw), $[0].dy));
+   endfor
+   % Position the implementation files boxes.
+   forsuffixes $=matrix, matrixEngine, matrixEngineFull:
+     fixsize($[4]);
+     $[2].s = $[4].nw;
+   endfor
+   
+   % Position the UML classes.
+   matrix[0].c = origin;
+   matrix[2].s - matrixEngine[0].n = (0, 3yUnit);
+   matrixEngine[2].s - matrixEngineFull[0].n = (0, yUnit);
+   
+   %% Draw the boxes.
+   % Draw the UML class boxes.
+   forsuffixes $=matrixEngine, matrixEngineFull:
+     for t = 0 upto 2:
+       drawboxed($[t]);
+     endfor
+   endfor
+   % Draw the template parameters.
+   forsuffixes $=matrixEngine, matrixEngineFull:
+     unfill bpath($[3]);
+     drawunboxed($[3]);
+     draw bpath($[3]) dashed evenly;
+   endfor
+   % Draw the file names.
+   forsuffixes $=matrixEngine, matrixEngineFull:
+     drawunboxed($[4]);
+   endfor
+   
+   % Draw arrows between classes.
+ 
+   % Draw lines between classes.
+   draw matrixEngineFull[0].n -- (matrixEngine[2].s-(0,discriminatorLength));
+   drawDiscriminator(matrixEngine[2].s, 0);
+ 
+ endfig;
+ 
+ bye
Index: figures/uml.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/uml.mp,v
retrieving revision 1.1
diff -c -p -r1.1 uml.mp
*** figures/uml.mp	2002/02/27 03:51:54	1.1
--- figures/uml.mp	2002/03/04 22:51:16
*************** path discriminator;
*** 12,17 ****
--- 12,18 ----
  discriminator = origin -- ((1,0) rotated -120) -- ((1,0) rotated -60) -- cycle;
  
  numeric discriminatorScale; discriminatorScale = 0.5cm;
+ numeric discriminatorLength; discriminatorLength = discriminatorScale*sqrt(3)/2;
  
  % The location is the top of the triangle
  vardef drawDiscriminator(expr location, rotation) =
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000923.html">Manual Patch: Automate Figure Creation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#922">[ date ]</a>
              <a href="thread.html#922">[ thread ]</a>
              <a href="subject.html#922">[ subject ]</a>
              <a href="author.html#922">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
