<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Patch: Fix Typos and Add Missing Semicolons
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Patch%3A%20Fix%20Typos%20and%20Add%20Missing%20Semicolons&In-Reply-To=%3C20011203123943.A16508%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000865.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Patch: Fix Typos and Add Missing Semicolons</H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Patch%3A%20Fix%20Typos%20and%20Add%20Missing%20Semicolons&In-Reply-To=%3C20011203123943.A16508%40codesourcery.com%3E"
       TITLE="Patch: Fix Typos and Add Missing Semicolons">oldham at codesourcery.com
       </A><BR>
    <I>Mon Dec  3 20:39:43 UTC 2001</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000865.html">Patch: Preliminary Pooma Manual
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#864">[ date ]</a>
              <a href="thread.html#864">[ thread ]</a>
              <a href="subject.html#864">[ subject ]</a>
              <a href="author.html#864">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch fixes mainly typographical errors I found in the Pooma
source code.  Additionally, there are two more significant revisions:

1) Ended a statement with a semicolon in
   src/Tulip/CollectFromContexts.h.  I do not understand why this was
   not previously found.

2) Discovered a &quot;hidden&quot; paragraph in docs/Layout.html.*  Should this
   paragraph really be present?  Presumably, this documentation will
   soon disappear, but it would be nice to get it correct in case it
   does survives.

2001-11-29 Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

        * benchmarks/Doof2d/Doof2d.h: Fix typo in comment.
        (*::initializeStorage): Generalize comment to work for any container.
        * docs/Layout.html: Fix numerous typographical and speling errors.
        Add missing quotation mark which caused entire paragraph
        describing tags to not be displayed.
        * src/Engine/IndexFunctionEngine.h (Engine&lt;Dim, T,
        IndexFunction&lt;Functor&gt; &gt;): Fix typo in introductory comment.
        * src/Engine/NotifyEngineWrite.h: Refill comment.
        * src/Engine/UserFunction.h: Use correct article in comment.
        * src/Field/Mesh/UniformRectilinearMesh.h: End sentence with a
        period in comment.
        * src/Layout/UniformGridLayout.cpp
        (UniformGridLayoutData&lt;Dim&gt;::repartition): Fix typo in
        introductory comment.
        * src/Layout/UniformGridLayout.h (UniformGridLayout&lt;Dim&gt;): Remove
        extra comment characters.
        * src/Partition/DistributedMapper.h (DistributedMapper&lt;Dim&gt;::map):
        Capitalize beginning of sentence in comment.
        * src/Partition/GridPartition.h (GridPartition&lt;Dim&gt;): Add spaces
        between comment symbols and text.  Fix typos and spelling
        mistakes.
        * src/Partition/UniformGridPartition.h
        (UniformGridPartition&lt;Dim&gt;): Properly indent the code.
        * src/Tulip/CollectFromContexts.h (Serialize&lt;CHEETAH,
        CollectionValue&lt;T&gt; &gt;::size): Add missing semicolon at statement's
        end.
        * src/Utilities/Benchmark.h: Fix typo in introductory comment.
        * src/Utilities/Conform.h: Change word in introductory comment.
        * src/Utilities/ModelElement.h: Fix incorrect introductory comment.
        * src/Utilities/Statistics.h: Fix incorrect introductory comment.
        * src/Utilities/WrappedInt.h: Fix spelling mistake in introductory
        comment.

Tested on Linux with g++ 3.1 by compiling Pooma library and Doof2d benchmark
Approved by     Mark Mitchell
Applied to      mainline

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: benchmarks/Doof2d/Doof2d.h
===================================================================
RCS file: /home/pooma/Repository/r2/benchmarks/Doof2d/Doof2d.h,v
retrieving revision 1.3
diff -c -p -r1.3 Doof2d.h
*** benchmarks/Doof2d/Doof2d.h	2001/10/16 18:26:09	1.3
--- benchmarks/Doof2d/Doof2d.h	2001/11/30 04:21:07
***************
*** 28,34 ****
  
  //-----------------------------------------------------------------------------
  // Classes Doof2dCppTran, Doof2dP2, DoofNinePt, Doof2dOpt
! // Implementation Classes Doof2dStorage, Doof2dBase, 
  //-----------------------------------------------------------------------------
  
  #ifndef POOMA_BENCHMARKS_DOOF2D_H
--- 28,34 ----
  
  //-----------------------------------------------------------------------------
  // Classes Doof2dCppTran, Doof2dP2, DoofNinePt, Doof2dOpt
! // Implementation Classes Doof2dStorage, Doof2dBase
  //-----------------------------------------------------------------------------
  
  #ifndef POOMA_BENCHMARKS_DOOF2D_H
*************** public:
*** 119,125 ****
  
    void initializeStorage(int &amp;n, int np, int ng) 
    {
!     // Get new array domain, including &quot;guards&quot;.
      
      Interval&lt;1&gt; N(1, n);
      Interval&lt;2&gt; vertDomain(N, N);
--- 119,125 ----
  
    void initializeStorage(int &amp;n, int np, int ng) 
    {
!     // Create the domain, including &quot;guards&quot;.
      
      Interval&lt;1&gt; N(1, n);
      Interval&lt;2&gt; vertDomain(N, N);
*************** public:
*** 140,146 ****
  
    void initializeStorage(int &amp;n, int np, int ng) 
    {
!     // Get new array domain, including &quot;guards&quot;.
  
      Interval&lt;1&gt; N(1, n);
      Interval&lt;2&gt; vertDomain(N, N);
--- 140,146 ----
  
    void initializeStorage(int &amp;n, int np, int ng) 
    {
!     // Create the domain, including &quot;guards&quot;.
  
      Interval&lt;1&gt; N(1, n);
      Interval&lt;2&gt; vertDomain(N, N);
*************** public:
*** 169,175 ****
    {
      n = (n / np) * np;
      
!     // Get new array domain.
      
      Interval&lt;1&gt; N(1, n);
      Interval&lt;2&gt; newDomain(N, N);
--- 169,175 ----
    {
      n = (n / np) * np;
      
!     // Create the domain.
      
      Interval&lt;1&gt; N(1, n);
      Interval&lt;2&gt; newDomain(N, N);
*************** public:
*** 208,214 ****
    {
      n = (n / np) * np;
      
!     // Get new array domain.
      
      Interval&lt;1&gt; N(1, n);
      Interval&lt;2&gt; newDomain(N, N);
--- 208,214 ----
    {
      n = (n / np) * np;
      
!     // Create the domain.
      
      Interval&lt;1&gt; N(1, n);
      Interval&lt;2&gt; newDomain(N, N);
Index: docs/Layout.html
===================================================================
RCS file: /home/pooma/Repository/r2/docs/Layout.html,v
retrieving revision 1.1
diff -c -p -r1.1 Layout.html
*** docs/Layout.html	2001/03/19 16:11:13	1.1
--- docs/Layout.html	2001/11/30 04:22:44
*************** guard layer thicknesses. External guard 
*** 59,80 ****
  specified by the internal guard layer for those patches that make up the
  edges of the data object.
  &lt;p&gt;There are two types of GuardLayers used by a MultiPatchEngine based
! Pooma data object. These are internal guard Layers, and external guard
! layers. Each data patch that makes up POOMA data object has it's domain
! extended by the number of data elements specified by the GuardLayers object.&nbsp;
! Internal guard layers are layers of elements or cells added to the upper
  and/or lower end of the sub-domain of the PatchEngine.&nbsp; These cells
  are to be filled with the data values of the adjacent patches, in order
  to minimize cross context data dependency of execution of expressions for
  each PatchEngine. In general it is an error to specify a internal guard
  layer that is larger than the patch dimension. This is especially important
  to remember when dealing with SparseTileLayout and GridLayout.
! &lt;p&gt;External guard layers are on the edge of the entire data object. Used
  for external boundary conditions. In this diagram, the external guard layers
  are indicated by 'egl'. External guard layers data allocation exists only
  for those PatchEngines that are on the edges of the full domain of the
  Pooma data object. The data elements that make up the external guard layers
! are generaly used for external boundary conditions.
  &lt;p&gt;In this example, the GuardLayers specification is symmetric, and the
  size of the internal and external guard layers are both 2. In general,
  GuardLayers may be specified asymmetrically, for instance:
--- 59,80 ----
  specified by the internal guard layer for those patches that make up the
  edges of the data object.
  &lt;p&gt;There are two types of GuardLayers used by a MultiPatchEngine based
! Pooma data object. These are internal guard layers and external guard
! layers. Each data patch of a POOMA data object has its domain
! extended by the number of data elements specified by the GuardLayers object.
! &lt;p&gt;Internal guard layers are layers of elements or cells added to the upper
  and/or lower end of the sub-domain of the PatchEngine.&nbsp; These cells
  are to be filled with the data values of the adjacent patches, in order
  to minimize cross context data dependency of execution of expressions for
  each PatchEngine. In general it is an error to specify a internal guard
  layer that is larger than the patch dimension. This is especially important
  to remember when dealing with SparseTileLayout and GridLayout.
! &lt;p&gt;External guard layers are on the edge of the entire data object and are used
  for external boundary conditions. In this diagram, the external guard layers
  are indicated by 'egl'. External guard layers data allocation exists only
  for those PatchEngines that are on the edges of the full domain of the
  Pooma data object. The data elements that make up the external guard layers
! are generally used for external boundary conditions.
  &lt;p&gt;In this example, the GuardLayers specification is symmetric, and the
  size of the internal and external guard layers are both 2. In general,
  GuardLayers may be specified asymmetrically, for instance:
*************** regions for a UniformGridLayout with asy
*** 101,107 ****
  &lt;br&gt;Interval&lt;2&gt; dom(Interval&lt;1&gt;(0,14),Interval&lt;1&gt;(0,9));
  &lt;br&gt;UniformGridPartition&lt;2&gt;&nbsp; asypart(Loc&lt;2&gt;(3,2),igl,egl);
  &lt;br&gt;Array&lt;2,double,MultiPatchEngine&lt;UniformTag,CompressibleBrick&gt;
! &gt;&nbsp;&nbsp;&nbsp;&nbsp; Aarray(UniformGridLayout&lt;2&gt;(dom,asypart,ReplicatedTag());&lt;/blockquote&gt;
  &lt;img SRC=&quot;/users/luchini/bgraph/bordergraphrevision.gif&quot; ALT=&quot;2x3 patch asymetric guard cell&quot; NOSAVE height=398 width=550&gt;
  &lt;br&gt;&nbsp;
  &lt;h1&gt;
--- 101,107 ----
  &lt;br&gt;Interval&lt;2&gt; dom(Interval&lt;1&gt;(0,14),Interval&lt;1&gt;(0,9));
  &lt;br&gt;UniformGridPartition&lt;2&gt;&nbsp; asypart(Loc&lt;2&gt;(3,2),igl,egl);
  &lt;br&gt;Array&lt;2,double,MultiPatchEngine&lt;UniformTag,CompressibleBrick&gt;
! &gt;&nbsp;&nbsp;&nbsp;&nbsp; Array(UniformGridLayout&lt;2&gt;(dom,asypart,ReplicatedTag());&lt;/blockquote&gt;
  &lt;img SRC=&quot;/users/luchini/bgraph/bordergraphrevision.gif&quot; ALT=&quot;2x3 patch asymetric guard cell&quot; NOSAVE height=398 width=550&gt;
  &lt;br&gt;&nbsp;
  &lt;h1&gt;
*************** or overlap onto the data space of patche
*** 129,151 ****
  &lt;br&gt;&nbsp;
  &lt;p&gt;&lt;img SRC=&quot;grid.2stl.gif&quot; &gt;
  &lt;p&gt;&lt;b&gt;DynamicLayout&lt;/b&gt;
! &lt;br&gt;An inherently 1 dimensional Layout, that allows the patches to be resized.
  &lt;p&gt;&lt;img SRC=&quot;grid.2D.gif&quot; &gt;
  &lt;br&gt;&nbsp;
  &lt;p&gt;&lt;b&gt;DomainLayout&lt;Dim&gt;&lt;/b&gt;
  &lt;br&gt;A single patch domain defined by a single Interval.
  &lt;br&gt;&nbsp;
! &lt;h2&gt;
! &lt;a NAME=&quot;Ltags&gt;&lt;/a&gt;UniformGridLayout, GridLayout and SparseTileLayout&lt;/b&gt;&lt;/h2&gt;The UniformGridLayout, GridLayout, and SparseTileLayout all have a trailingtag argument on most of their constructors that specifies how the data is ContextMapper&lt;it&gt;ed&lt;/it&gt;. These tags are ReplicatedTag and DistributedTag.If ReplicatedTag is specified, then LocalMapper is used, while if DistributedTagis specified, the the DistributedMapper is used. All of the aforementioned layouts have the default constructor that doesn't require the use of the ReplicatedTag or DistributedTag, and the constructor of the form (Domain,Partitioner, ContextMapper), since it explicitly specifies a ContextMapper,doesn't require the use of the trailing tags.&lt;br&gt;?&lt;h2&gt;&lt;a NAME=&quot; Partitioners&quot;&gt;&lt;/a&gt;&lt;b&gt;Partitioners:&lt;/b&gt;&lt;/h2&gt;
  
  &lt;p&gt;&lt;br&gt;Layouts have Partitioners that are invoked to generate the
! &lt;br&gt;patch-subdomains, taking into account internal and external GuardLayers.
  &lt;p&gt;The currently available Partitioners are
  &lt;p&gt;&lt;b&gt;UniformGridPartitioner&lt;Dim&gt;&lt;/b&gt;
! &lt;br&gt;Used to generate patches for a UniformGirdLayout.
  &lt;br&gt;&nbsp;
! &lt;p&gt;&lt;b&gt;GirdPartitioner&lt;Dim&gt;&lt;/b&gt;
! &lt;br&gt;Used to generate patches for a GridLayout
  &lt;p&gt;&lt;b&gt;TilePartition&lt;Dim&gt;&lt;/b&gt;
  &lt;br&gt;Generates patches from a provided list of domains.
  &lt;p&gt;&lt;b&gt;SpatialPartition&lt;ReferenceLayout&gt;&lt;/b&gt;
--- 129,152 ----
  &lt;br&gt;&nbsp;
  &lt;p&gt;&lt;img SRC=&quot;grid.2stl.gif&quot; &gt;
  &lt;p&gt;&lt;b&gt;DynamicLayout&lt;/b&gt;
! &lt;br&gt;An inherently 1-dimensional Layout, that allows the patches to be resized.
  &lt;p&gt;&lt;img SRC=&quot;grid.2D.gif&quot; &gt;
  &lt;br&gt;&nbsp;
  &lt;p&gt;&lt;b&gt;DomainLayout&lt;Dim&gt;&lt;/b&gt;
  &lt;br&gt;A single patch domain defined by a single Interval.
  &lt;br&gt;&nbsp;
! &lt;h2&gt;&lt;a NAME=&quot;Ltags&quot;&gt;&lt;/a&gt;UniformGridLayout, GridLayout and SparseTileLayout&lt;/b&gt;&lt;/h2&gt;The UniformGridLayout, GridLayout, and SparseTileLayout all have a trailing tag argument on most of their constructors that specifies how the data is ContextMapper&lt;it&gt;ed&lt;/it&gt;. These tags are ReplicatedTag and DistributedTag. If ReplicatedTag is specified, then LocalMapper is used, while if DistributedTag is specified, then the DistributedMapper is used. All of the aforementioned layouts have the default constructor that doesn't require the use of the ReplicatedTag or DistributedTag.  A constructor having the form (Domain,Partitioner, ContextMapper) doesn't require the use of the trailing tags since it explicitly specifies a ContextMapper.&lt;br&gt;
! 
! &lt;h2&gt;&lt;a NAME=&quot; Partitioners&quot;&gt;&lt;/a&gt;&lt;b&gt;Partitioners:&lt;/b&gt;&lt;/h2&gt;
  
  &lt;p&gt;&lt;br&gt;Layouts have Partitioners that are invoked to generate the
! patch-subdomains, taking into account internal and external GuardLayers.
  &lt;p&gt;The currently available Partitioners are
  &lt;p&gt;&lt;b&gt;UniformGridPartitioner&lt;Dim&gt;&lt;/b&gt;
! &lt;br&gt;Used to generate patches for a UniformGridLayout.
  &lt;br&gt;&nbsp;
! &lt;p&gt;&lt;b&gt;GridPartitioner&lt;Dim&gt;&lt;/b&gt;
! &lt;br&gt;Used to generate patches for a GridLayout.
  &lt;p&gt;&lt;b&gt;TilePartition&lt;Dim&gt;&lt;/b&gt;
  &lt;br&gt;Generates patches from a provided list of domains.
  &lt;p&gt;&lt;b&gt;SpatialPartition&lt;ReferenceLayout&gt;&lt;/b&gt;
*************** contexts with an approximately minimum s
*** 181,189 ****
  &lt;br&gt;&nbsp;
  &lt;br&gt;&nbsp;
  &lt;p&gt;&lt;b&gt;ContiguousMapper&lt;/b&gt;
! &lt;br&gt;Assigns patches to a context in a modified Fortran storage order: as
  the index gets to an boundary, the lowest axis index decrements, rather
! than going from LowIndex = IndexMax to LowIndex = 0; See the figure for
  an illustration of this mapper.
  &lt;p&gt;&lt;img SRC=&quot;/am/mother/u0/luchini/cmapper/grid.2cmapper.gif&quot; ALT=&quot;contiguous mapper&quot; NOSAVE &gt;
  &lt;br&gt;&nbsp;
--- 182,190 ----
  &lt;br&gt;&nbsp;
  &lt;br&gt;&nbsp;
  &lt;p&gt;&lt;b&gt;ContiguousMapper&lt;/b&gt;
! &lt;br&gt;Assigns patches to a context in a modified Fortran storage order: As
  the index gets to an boundary, the lowest axis index decrements, rather
! than going from LowIndex = IndexMax to LowIndex = 0; see the figure for
  an illustration of this mapper.
  &lt;p&gt;&lt;img SRC=&quot;/am/mother/u0/luchini/cmapper/grid.2cmapper.gif&quot; ALT=&quot;contiguous mapper&quot; NOSAVE &gt;
  &lt;br&gt;&nbsp;
*************** patch engines must not be distributed.
*** 207,212 ****
  &lt;p&gt;Similarly, MultiPatchEngine may not be constructed with the PatchEngine
  tag specified as Remote&lt;PatchEngine&gt; if LocalMapper is specified in
  the Layout used to construct the MultiPatchEngine. Either of the aforementioned
! combinations will generate a Pinsist error inside MultiPatchEngine.
  &lt;/body&gt;
  &lt;/html&gt;
--- 208,213 ----
  &lt;p&gt;Similarly, MultiPatchEngine may not be constructed with the PatchEngine
  tag specified as Remote&lt;PatchEngine&gt; if LocalMapper is specified in
  the Layout used to construct the MultiPatchEngine. Either of the aforementioned
! combinations will generate a PInsist error inside MultiPatchEngine.
  &lt;/body&gt;
  &lt;/html&gt;
Index: src/Engine/IndexFunctionEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/IndexFunctionEngine.h,v
retrieving revision 1.23
diff -c -p -r1.23 IndexFunctionEngine.h
*** src/Engine/IndexFunctionEngine.h	2001/08/30 01:15:04	1.23
--- src/Engine/IndexFunctionEngine.h	2001/11/30 04:22:46
*************** struct IndexFunctionView
*** 87,93 ****
  // 
  // Typedefs for the tag, element types, domain and dimensions.
  // Operator() with integers to evaluate elements quickly.
! // Operator() with a doman to subset.
  // Accessor for the domain.
  //-----------------------------------------------------------------------------
  
--- 87,93 ----
  // 
  // Typedefs for the tag, element types, domain and dimensions.
  // Operator() with integers to evaluate elements quickly.
! // Operator() with a domain to subset.
  // Accessor for the domain.
  //-----------------------------------------------------------------------------
  
Index: src/Engine/NotifyEngineWrite.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/NotifyEngineWrite.h,v
retrieving revision 1.6
diff -c -p -r1.6 NotifyEngineWrite.h
*** src/Engine/NotifyEngineWrite.h	2000/05/10 05:07:37	1.6
--- src/Engine/NotifyEngineWrite.h	2001/11/30 04:22:46
***************
*** 42,49 ****
  //-----------------------------------------------------------------------------
  // Overview: 
  //
! // NotifyEngineWrite is a general wrapper class the is used to tell an engine
! // that we're going to write to it.
  //-----------------------------------------------------------------------------
  
  //-----------------------------------------------------------------------------
--- 42,49 ----
  //-----------------------------------------------------------------------------
  // Overview: 
  //
! // NotifyEngineWrite is a general wrapper class that is used to tell
! // an engine that we're going to write to it.
  //-----------------------------------------------------------------------------
  
  //-----------------------------------------------------------------------------
Index: src/Engine/UserFunction.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/UserFunction.h,v
retrieving revision 1.28
diff -c -p -r1.28 UserFunction.h
*** src/Engine/UserFunction.h	2001/09/14 22:37:57	1.28
--- src/Engine/UserFunction.h	2001/11/30 04:22:46
*************** template&lt;int D, class T, class E&gt; class 
*** 100,106 ****
  //     inherits from UserFunction below.
  //
  //   Expression: The type of the expression to which the function
! //      is being applied.  This should be a Array.
  //
  //-----------------------------------------------------------------------------
  
--- 100,106 ----
  //     inherits from UserFunction below.
  //
  //   Expression: The type of the expression to which the function
! //      is being applied.  This should be an Array.
  //
  //-----------------------------------------------------------------------------
  
Index: src/Field/Mesh/UniformRectilinearMesh.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Field/Mesh/UniformRectilinearMesh.h,v
retrieving revision 1.2
diff -c -p -r1.2 UniformRectilinearMesh.h
*** src/Field/Mesh/UniformRectilinearMesh.h	2001/09/20 22:07:32	1.2
--- src/Field/Mesh/UniformRectilinearMesh.h	2001/11/30 04:22:46
***************
*** 47,57 ****
  #include &quot;Field/FieldEngine/FieldEnginePatch.h&quot; // Used in ctors
  #include &quot;Field/Mesh/NoMesh.h&quot;                  // Base class
  #include &quot;Field/FieldCentering.h&quot;               // Centering&lt;Dim&gt; inline
! #include &quot;Tiny/Vector.h&quot;                           // Class member
  
  //-----------------------------------------------------------------------------
  // Holds the data for a uniform rectilinear mesh. That class has a ref-counted
! // instance of this class
  //-----------------------------------------------------------------------------
  
  template &lt;int Dim, class T&gt;
--- 47,57 ----
  #include &quot;Field/FieldEngine/FieldEnginePatch.h&quot; // Used in ctors
  #include &quot;Field/Mesh/NoMesh.h&quot;                  // Base class
  #include &quot;Field/FieldCentering.h&quot;               // Centering&lt;Dim&gt; inline
! #include &quot;Tiny/Vector.h&quot;                        // Class member
  
  //-----------------------------------------------------------------------------
  // Holds the data for a uniform rectilinear mesh. That class has a ref-counted
! // instance of this class.
  //-----------------------------------------------------------------------------
  
  template &lt;int Dim, class T&gt;
Index: src/Layout/UniformGridLayout.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Layout/UniformGridLayout.cpp,v
retrieving revision 1.36
diff -c -p -r1.36 UniformGridLayout.cpp
*** src/Layout/UniformGridLayout.cpp	2001/04/18 02:19:09	1.36
--- src/Layout/UniformGridLayout.cpp	2001/11/30 04:22:47
*************** void UniformGridLayoutData&lt;Dim&gt;::calcGCF
*** 435,441 ****
  // Repartition the layout using a new Partitioner scheme.  The initial
  // domain lists are cleared out, the partitioner is invoked, and then
  // all the observers are notified.  This can only be done with a
! // GridParition partitioner.
  //
  //-----------------------------------------------------------------------------
  
--- 435,441 ----
  // Repartition the layout using a new Partitioner scheme.  The initial
  // domain lists are cleared out, the partitioner is invoked, and then
  // all the observers are notified.  This can only be done with a
! // GridPartition partitioner.
  //
  //-----------------------------------------------------------------------------
  
Index: src/Layout/UniformGridLayout.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Layout/UniformGridLayout.h,v
retrieving revision 1.83
diff -c -p -r1.83 UniformGridLayout.h
*** src/Layout/UniformGridLayout.h	2001/06/05 18:42:12	1.83
--- src/Layout/UniformGridLayout.h	2001/11/30 04:22:47
*************** public:
*** 1030,1037 ****
    typedef UniformGridLayout&lt;Dim&gt;               This_t; // for convenience
    typedef Observable&lt;This_t&gt;                   Observable_t;
  
! //   // Iterator through nodes. Basically the same as the vector iterator
! //   // except it dereferences automatically.
    
    typedef DerefIterator&lt;Value_t&gt;               iterator;
    typedef ConstDerefIterator&lt;Value_t&gt;          const_iterator;
--- 1030,1037 ----
    typedef UniformGridLayout&lt;Dim&gt;               This_t; // for convenience
    typedef Observable&lt;This_t&gt;                   Observable_t;
  
!   // Iterator through nodes. Basically the same as the vector iterator
!   // except it dereferences automatically.
    
    typedef DerefIterator&lt;Value_t&gt;               iterator;
    typedef ConstDerefIterator&lt;Value_t&gt;          const_iterator;
Index: src/Partition/DistributedMapper.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/DistributedMapper.h,v
retrieving revision 1.7
diff -c -p -r1.7 DistributedMapper.h
*** src/Partition/DistributedMapper.h	2001/10/15 17:34:31	1.7
--- src/Partition/DistributedMapper.h	2001/11/30 04:22:48
*************** public:
*** 63,69 ****
    {
      int ncontexts = Pooma::contexts();
      int npc = templist.size()/ncontexts;
!     // if there are more contexts then patches, assign one
      // patch per context for as many patches as there are. 
      if(ncontexts&gt; templist.size())
        {
--- 63,69 ----
    {
      int ncontexts = Pooma::contexts();
      int npc = templist.size()/ncontexts;
!     // If there are more contexts than patches, assign one
      // patch per context for as many patches as there are. 
      if(ncontexts&gt; templist.size())
        {
Index: src/Partition/GridPartition.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/GridPartition.h,v
retrieving revision 1.28
diff -c -p -r1.28 GridPartition.h
*** src/Partition/GridPartition.h	2001/06/28 19:08:11	1.28
--- src/Partition/GridPartition.h	2001/11/30 04:22:48
*************** class UniformGridPartition;
*** 88,126 ****
  // sub-domain specifications along each axis, or any of the specifiers used
  // for the UniformGridPartition. 
  //
! // GridPartition inherets from UniformGridPartition
  //
  // A GridPartition object is constructed with the following information:
  //   GridPartition()
  //   Creates one partition, with no guard cells
  //
  //  GridPartition(const Loc&lt;Dim&gt; &amp;n, int p=-1)
! //Creates n[i] blocks along each i'th dimension
  //
  //  GridPartition(const Loc&lt;Dim&gt; &amp;n, 
  //                       const GuardLayers&lt;Dim&gt; &amp;gcs)
! //Same as above, with internal and external guard cell sizes set to gcs.
  // 
  //                       
  // GridPartition(const Loc&lt;Dim&gt; &amp;n, 
  //                       const GuardLayers&lt;Dim&gt; &amp;igcs,
  //                       const GuardLayers&lt;Dim&gt; &amp;egcs)
! //Same as above, with internal and external guard cell sizes specified 
! //independently.
  //
  //  GridPartition(const Grid&lt;Dim&gt; &amp;g)
! //Partitions according to the Grid object.
  //
  //  GridPartition(const Grid&lt;Dim&gt; &amp;g, 
  //                       const GuardLayers&lt;Dim&gt; &amp;gcs)
! //Same as above, with internal and external guard cell sizes set to gcs.
  // 
  //                       
  // GridPartition(const Grid&lt;Dim&gt; &amp;g, 
  //                       const GuardLayers&lt;Dim&gt; &amp;igcs,
  //                       const GuardLayers&lt;Dim&gt; &amp;egcs)
! //Same as above, with internal and external guard cell sizes specified 
! //independently.
  //-------------------------------------------------------------------------
  
  template&lt;int Dim&gt;
--- 88,126 ----
  // sub-domain specifications along each axis, or any of the specifiers used
  // for the UniformGridPartition. 
  //
! // GridPartition inherits from UniformGridPartition.
  //
  // A GridPartition object is constructed with the following information:
  //   GridPartition()
  //   Creates one partition, with no guard cells
  //
  //  GridPartition(const Loc&lt;Dim&gt; &amp;n, int p=-1)
! // Creates n[i] blocks along each i'th dimension
  //
  //  GridPartition(const Loc&lt;Dim&gt; &amp;n, 
  //                       const GuardLayers&lt;Dim&gt; &amp;gcs)
! // Same as above, with internal and external guard cell sizes set to gcs.
  // 
  //                       
  // GridPartition(const Loc&lt;Dim&gt; &amp;n, 
  //                       const GuardLayers&lt;Dim&gt; &amp;igcs,
  //                       const GuardLayers&lt;Dim&gt; &amp;egcs)
! // Same as above, with internal and external guard cell sizes specified 
! // independently.
  //
  //  GridPartition(const Grid&lt;Dim&gt; &amp;g)
! // Partitions according to the Grid object.
  //
  //  GridPartition(const Grid&lt;Dim&gt; &amp;g, 
  //                       const GuardLayers&lt;Dim&gt; &amp;gcs)
! // Same as above, with internal and external guard cell sizes set to gcs.
  // 
  //                       
  // GridPartition(const Grid&lt;Dim&gt; &amp;g, 
  //                       const GuardLayers&lt;Dim&gt; &amp;igcs,
  //                       const GuardLayers&lt;Dim&gt; &amp;egcs)
! // Same as above, with internal and external guard cell sizes specified 
! // independently.
  //-------------------------------------------------------------------------
  
  template&lt;int Dim&gt;
Index: src/Partition/UniformGridPartition.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Partition/UniformGridPartition.h,v
retrieving revision 1.26
diff -c -p -r1.26 UniformGridPartition.h
*** src/Partition/UniformGridPartition.h	2001/10/10 00:16:03	1.26
--- src/Partition/UniformGridPartition.h	2001/11/30 04:22:48
*************** public:
*** 256,468 ****
      return hasGuards_m; 
    }
  
! bool hasInternalGuards() const 
! { 
!   return hasGuards_m &amp;&amp; internalGuards_m != 0;
! }
  
! bool hasExternalGuards() const 
! { 
!   return hasGuards_m &amp;&amp; externalGuards_m != 0; 
! }
  
! const GuardLayers&lt;Dim&gt; &amp;internalGuards() const 
! { 
!   return internalGuards_m; 
! }
    
! const GuardLayers&lt;Dim&gt; &amp;externalGuards() const 
! { 
!   return externalGuards_m; 
! }
  
  
! //============================================================
! // Partition methods
! //============================================================
  
! // For the given global domain, partition it into subdomains and put
! // the results in the provided layout object by calling
! // 'layoutData.addDomainList(List_t &amp;templist)'.  Return the
! // total number of subdomains added.
    
    
! template&lt;class D&gt;
! int partition(const D &amp;domain, 
! 	      List_t &amp; all,
! 	      const ContextMapper&lt;Dim&gt;&amp; cmapper) const 
! {
    
!   // The type info for domain we should be creating for the layout.
  
!   typedef typename DomainTraits&lt;Domain_t&gt;::Element_t Element_t;
  
!   // Make sure we have the right dimensionality.
      
!   CTAssert(Dim == DomainTraits&lt;D&gt;::dimensions);
!   CTAssert(Dim == DomainTraits&lt;Domain_t&gt;::dimensions);
  
!   // This will only work with UnitStride domains
      
!   CTAssert(DomainTraits&lt;D&gt;::unitStride == 1);
!   CTAssert(DomainTraits&lt;Domain_t&gt;::unitStride == 1);
  
!   // make sure the list is empty
  
!   PAssert(all.size() == 0);
  
!   // Cache the origin of the domain and make sure the domain is
!   // properly sized. Also, build a domain corresponding to the
!   // number of blocks in each direction for iterating over below.
      
!   Element_t origin[Dim];
!   Element_t sizes[Dim];
!   Interval&lt;Dim&gt; bdomain = Pooma::NoInit(); // dummy initializer
         
!   int i;
  
!   for (i = 0; i &lt; Dim; ++i) 
!     {
!       if (!domain.empty())
! 	{
! 	  int gcwidth = 
! 	    (internalGuards_m.lower(i) &gt; internalGuards_m.upper(i)) ?
! 	    internalGuards_m.lower(i) : internalGuards_m.upper(i);
! 
! 	  PInsist((domain[i].length() % blocks()[i].first()) == 0,
! 		  &quot;All the blocks in a grid must be the same size.&quot;);
! 
! 	  origin[i]  = domain[i].first();
! 	  sizes[i]   = domain[i].length() / blocks()[i].first();
! 
! 	  PInsist(sizes[i] &gt;= gcwidth,
! 		  &quot;Block sizes too small for guard layer specification.&quot;);
! 	}
!       bdomain[i] = Interval&lt;1&gt;(blocks()[i].first());
!     }
! 
!   // Loop over all the blocks, creating new domains. 
! 
!   typename Interval&lt;Dim&gt;::const_iterator it = bdomain.begin();
!   while (it != bdomain.end()) 
!     {
!       // Start with an initially empty domain and empty guard cells.
  	
!       Domain_t owned;
!       GuardLayers&lt;Dim&gt; iguards(0);
!       GuardLayers&lt;Dim&gt; eguards(0);
! 
!       // Calculate the subdomain, if the global domain is not empty.
!       // If it is, we just sue the empty domain.
! 
!       if (!domain.empty())
! 	{
! 	  Loc&lt;Dim&gt; pos = *it;
! 	  for (i = 0; i &lt; Dim; ++i) 
! 	    {
! 	      int position = pos[i].first();
! 	      Element_t a = origin[i] + sizes[i]*position;
! 	      Element_t b = a + sizes[i] - 1;
! 	      typedef typename 
! 		DomainTraits&lt;Domain_t&gt;::OneDomain_t OneDomain_t;
! 	      owned[i] = OneDomain_t(a, b);
! 	    }
  
! 	  // Calculate the internal and external guard layer specifications
! 	  // for this domain.
          
! 	  if (hasGuards_m)
! 	    {
! 	      iguards = internalGuards_m;
              
! 	      // Check if we're at an edge, and if so use the
! 	      // external specfication for that edge.
                  
! 	      for (int d = 0; d &lt; Dim; ++d)
! 		{
! 		  int position = pos[d].first();
! 		  if ( position == bdomain[d].first() ) 
! 		    {
! 		      eguards.lower(d) = externalGuards_m.lower(d);
! 		      iguards.lower(d) = 0;
! 		    }
! 		  if ( position == bdomain[d].last() ) 
! 		    {
! 		      eguards.upper(d) = externalGuards_m.upper(d);
! 		      iguards.upper(d) = 0;
! 		    }
! 		}
! 	    }
! 	}
!       typename Value_t::ID_t gid = all.size();
!       typename Value_t::ID_t lid = (-1);
  
!       // Create a new Node object to store the subdomain data.
  	
!       GuardLayers&lt;Dim&gt;::addGuardLayers(owned,eguards);
  
!       Domain_t allocated = owned;
  
!       GuardLayers&lt;Dim&gt;::addGuardLayers(allocated,iguards);
  
!       Value_t *node = new Value_t(owned, allocated, -1, gid, lid);
  
!       all.push_back(node);
  
!       // Increment our counters and iterators.
        
!       ++it;
!     }
  
!   cmapper.map(all);
  
!   // At the end, return # of domains created.
      
!   return num_m;
! }
  
! template&lt;class D&gt;
! int partition(const D &amp;domain, List_t &amp; list) const 
! {
!   return partition(domain,list,DefaultMapper_t(*this));
! }
  
  protected:
  
! // The number of blocks along each dimension.
    
! Loc&lt;Dim&gt; blocks_m;
    
! // Do we have guard layers?
    
! bool hasGuards_m;
    
! // Are the external guards different from the internal?
    
! bool hasCustomEdgeGuards_m;
    
! // Specification of internal guard layers.
    
! GuardLayers&lt;Dim&gt; internalGuards_m;
    
! // Specification of external guard layers.
    
! GuardLayers&lt;Dim&gt; externalGuards_m;
  
! // The total number of blocks to create.
    
! int num_m;
    
! // Calculate num_m from blocks_m:
    
! void calcNum()
! {
!   num_m = blocks_m[0].first();
!   for (int d = 1; d &lt; Dim; ++d) 
!     {
!       num_m *= blocks_m[d].first();
!     }
! }
      
  };
  
--- 256,468 ----
      return hasGuards_m; 
    }
  
!   bool hasInternalGuards() const 
!   { 
!     return hasGuards_m &amp;&amp; internalGuards_m != 0;
!   }
  
!   bool hasExternalGuards() const 
!   { 
!     return hasGuards_m &amp;&amp; externalGuards_m != 0; 
!   }
  
!   const GuardLayers&lt;Dim&gt; &amp;internalGuards() const 
!   { 
!     return internalGuards_m; 
!   }
    
!   const GuardLayers&lt;Dim&gt; &amp;externalGuards() const 
!   { 
!     return externalGuards_m; 
!   }
  
  
!   //============================================================
!   // Partition methods
!   //============================================================
  
!   // For the given global domain, partition it into subdomains and put
!   // the results in the provided layout object by calling
!   // 'layoutData.addDomainList(List_t &amp;templist)'.  Return the
!   // total number of subdomains added.
    
    
!   template&lt;class D&gt;
!   int partition(const D &amp;domain, 
! 		List_t &amp; all,
! 		const ContextMapper&lt;Dim&gt;&amp; cmapper) const 
!   {
    
!     // The type info for domain we should be creating for the layout.
  
!     typedef typename DomainTraits&lt;Domain_t&gt;::Element_t Element_t;
  
!     // Make sure we have the right dimensionality.
      
!     CTAssert(Dim == DomainTraits&lt;D&gt;::dimensions);
!     CTAssert(Dim == DomainTraits&lt;Domain_t&gt;::dimensions);
  
!     // This will only work with UnitStride domains
      
!     CTAssert(DomainTraits&lt;D&gt;::unitStride == 1);
!     CTAssert(DomainTraits&lt;Domain_t&gt;::unitStride == 1);
  
!     // make sure the list is empty
  
!     PAssert(all.size() == 0);
  
!     // Cache the origin of the domain and make sure the domain is
!     // properly sized. Also, build a domain corresponding to the
!     // number of blocks in each direction for iterating over below.
      
!     Element_t origin[Dim];
!     Element_t sizes[Dim];
!     Interval&lt;Dim&gt; bdomain = Pooma::NoInit(); // dummy initializer
         
!     int i;
  
!     for (i = 0; i &lt; Dim; ++i) 
!       {
! 	if (!domain.empty())
! 	  {
! 	    int gcwidth = 
! 	      (internalGuards_m.lower(i) &gt; internalGuards_m.upper(i)) ?
! 	      internalGuards_m.lower(i) : internalGuards_m.upper(i);
! 
! 	    PInsist((domain[i].length() % blocks()[i].first()) == 0,
! 		    &quot;All the blocks in a grid must be the same size.&quot;);
! 
! 	    origin[i]  = domain[i].first();
! 	    sizes[i]   = domain[i].length() / blocks()[i].first();
! 
! 	    PInsist(sizes[i] &gt;= gcwidth,
! 		    &quot;Block sizes too small for guard layer specification.&quot;);
! 	  }
! 	bdomain[i] = Interval&lt;1&gt;(blocks()[i].first());
!       }
! 
!     // Loop over all the blocks, creating new domains. 
! 
!     typename Interval&lt;Dim&gt;::const_iterator it = bdomain.begin();
!     while (it != bdomain.end()) 
!       {
! 	// Start with an initially empty domain and empty guard cells.
  	
! 	Domain_t owned;
! 	GuardLayers&lt;Dim&gt; iguards(0);
! 	GuardLayers&lt;Dim&gt; eguards(0);
! 
! 	// Calculate the subdomain, if the global domain is not empty.
! 	// If it is, we just use the empty domain.
! 
! 	if (!domain.empty())
! 	  {
! 	    Loc&lt;Dim&gt; pos = *it;
! 	    for (i = 0; i &lt; Dim; ++i) 
! 	      {
! 		int position = pos[i].first();
! 		Element_t a = origin[i] + sizes[i]*position;
! 		Element_t b = a + sizes[i] - 1;
! 		typedef typename 
! 		  DomainTraits&lt;Domain_t&gt;::OneDomain_t OneDomain_t;
! 		owned[i] = OneDomain_t(a, b);
! 	      }
  
! 	    // Calculate the internal and external guard layer specifications
! 	    // for this domain.
          
! 	    if (hasGuards_m)
! 	      {
! 		iguards = internalGuards_m;
              
! 		// Check if we're at an edge, and if so use the
! 		// external specfication for that edge.
                  
! 		for (int d = 0; d &lt; Dim; ++d)
! 		  {
! 		    int position = pos[d].first();
! 		    if ( position == bdomain[d].first() ) 
! 		      {
! 			eguards.lower(d) = externalGuards_m.lower(d);
! 			iguards.lower(d) = 0;
! 		      }
! 		    if ( position == bdomain[d].last() ) 
! 		      {
! 			eguards.upper(d) = externalGuards_m.upper(d);
! 			iguards.upper(d) = 0;
! 		      }
! 		  }
! 	      }
! 	  }
! 	typename Value_t::ID_t gid = all.size();
! 	typename Value_t::ID_t lid = (-1);
  
! 	// Create a new Node object to store the subdomain data.
  	
! 	GuardLayers&lt;Dim&gt;::addGuardLayers(owned,eguards);
  
! 	Domain_t allocated = owned;
  
! 	GuardLayers&lt;Dim&gt;::addGuardLayers(allocated,iguards);
  
! 	Value_t *node = new Value_t(owned, allocated, -1, gid, lid);
  
! 	all.push_back(node);
  
! 	// Increment our counters and iterators.
        
! 	++it;
!       }
  
!     cmapper.map(all);
  
!     // At the end, return # of domains created.
      
!     return num_m;
!   }
  
!   template&lt;class D&gt;
!   int partition(const D &amp;domain, List_t &amp; list) const 
!   {
!     return partition(domain,list,DefaultMapper_t(*this));
!   }
  
  protected:
  
!   // The number of blocks along each dimension.
    
!   Loc&lt;Dim&gt; blocks_m;
    
!   // Do we have guard layers?
    
!   bool hasGuards_m;
    
!   // Are the external guards different from the internal?
    
!   bool hasCustomEdgeGuards_m;
    
!   // Specification of internal guard layers.
    
!   GuardLayers&lt;Dim&gt; internalGuards_m;
    
!   // Specification of external guard layers.
    
!   GuardLayers&lt;Dim&gt; externalGuards_m;
  
!   // The total number of blocks to create.
    
!   int num_m;
    
!   // Calculate num_m from blocks_m:
    
!   void calcNum()
!   {
!     num_m = blocks_m[0].first();
!     for (int d = 1; d &lt; Dim; ++d) 
!       {
! 	num_m *= blocks_m[d].first();
!       }
!   }
      
  };
  
Index: src/Tulip/CollectFromContexts.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Tulip/CollectFromContexts.h,v
retrieving revision 1.1
diff -c -p -r1.1 CollectFromContexts.h
*** src/Tulip/CollectFromContexts.h	2001/09/13 20:40:54	1.1
--- src/Tulip/CollectFromContexts.h	2001/11/30 04:22:48
*************** public:
*** 126,132 ****
    static inline int size(const CollectionValue&lt;T&gt; &amp;v)
    {
      int nBytes = Serialize&lt;CHEETAH, bool&gt;::size(v.valid());
!     nBytes += Serialize&lt;CHEETAH, int&gt;::size(v.context())
      if (v.valid())
        nBytes += Serialize&lt;CHEETAH, T&gt;::size(v.value());
  
--- 126,132 ----
    static inline int size(const CollectionValue&lt;T&gt; &amp;v)
    {
      int nBytes = Serialize&lt;CHEETAH, bool&gt;::size(v.valid());
!     nBytes += Serialize&lt;CHEETAH, int&gt;::size(v.context());
      if (v.valid())
        nBytes += Serialize&lt;CHEETAH, T&gt;::size(v.value());
  
Index: src/Utilities/Benchmark.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Utilities/Benchmark.h,v
retrieving revision 1.28
diff -c -p -r1.28 Benchmark.h
*** src/Utilities/Benchmark.h	2001/07/25 16:04:12	1.28
--- src/Utilities/Benchmark.h	2001/11/30 04:22:48
***************
*** 43,49 ****
  
  
  //-----------------------------------------------------------------------------
! // Implementaion provides a framework for implementing a benchmark in a
  // specific way. It is a virtual base class. Users must override almost
  // all of the member functions.
  //-----------------------------------------------------------------------------
--- 43,49 ----
  
  
  //-----------------------------------------------------------------------------
! // Implementation provides a framework for implementing a benchmark in a
  // specific way. It is a virtual base class. Users must override almost
  // all of the member functions.
  //-----------------------------------------------------------------------------
Index: src/Utilities/Conform.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Utilities/Conform.h,v
retrieving revision 1.2
diff -c -p -r1.2 Conform.h
*** src/Utilities/Conform.h	2000/03/07 13:18:23	1.2
--- src/Utilities/Conform.h	2001/11/30 04:22:48
***************
*** 28,34 ****
  //-----------------------------------------------------------------------------
  // Overview:
  // A tag for checking whether the terms in an expression have
! // conformant domains.
  //-----------------------------------------------------------------------------
  
  #ifndef POOMA_UTILITIES_CONFORM_H
--- 28,34 ----
  //-----------------------------------------------------------------------------
  // Overview:
  // A tag for checking whether the terms in an expression have
! // conforming domains.
  //-----------------------------------------------------------------------------
  
  #ifndef POOMA_UTILITIES_CONFORM_H
Index: src/Utilities/ModelElement.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Utilities/ModelElement.h,v
retrieving revision 1.2
diff -c -p -r1.2 ModelElement.h
*** src/Utilities/ModelElement.h	2000/03/07 13:18:25	1.2
--- src/Utilities/ModelElement.h	2001/11/30 04:22:48
***************
*** 37,43 ****
  //-----------------------------------------------------------------------------
  // Overview: 
  // 
! // ConstField : A read-only version of Field.
  //-----------------------------------------------------------------------------
  
  template&lt;class T&gt;
--- 37,44 ----
  //-----------------------------------------------------------------------------
  // Overview: 
  // 
! // ModelElement&lt;T&gt;
! //   A wrapper class used to differentiate overloaded functions.
  //-----------------------------------------------------------------------------
  
  template&lt;class T&gt;
Index: src/Utilities/Statistics.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Utilities/Statistics.h,v
retrieving revision 1.1
diff -c -p -r1.1 Statistics.h
*** src/Utilities/Statistics.h	2000/04/12 00:30:06	1.1
--- src/Utilities/Statistics.h	2001/11/30 04:22:48
***************
*** 31,38 ****
  
  //-----------------------------------------------------------------------------
  // Classes: 
! //   Implementation
! //   Benchmark
  //-----------------------------------------------------------------------------
  
  #include &lt;string&gt;
--- 31,38 ----
  
  //-----------------------------------------------------------------------------
  // Classes: 
! //   Statistics
! //   StatisticsData: helper class
  //-----------------------------------------------------------------------------
  
  #include &lt;string&gt;
Index: src/Utilities/WrappedInt.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Utilities/WrappedInt.h,v
retrieving revision 1.10
diff -c -p -r1.10 WrappedInt.h
*** src/Utilities/WrappedInt.h	2000/05/23 23:18:44	1.10
--- src/Utilities/WrappedInt.h	2001/11/30 04:22:48
***************
*** 40,46 ****
  // Helper class: WrappedInt&lt;int&gt; 
  //
  // A tag class templated on an integer.  This class is intended to be
! // used to let you specialize a funtion on a compile time number.
  //
  // For example, if you have an object of type T which you want to pass
  // to a subroutine foo, but you want to specialize that subroutine based on
--- 40,46 ----
  // Helper class: WrappedInt&lt;int&gt; 
  //
  // A tag class templated on an integer.  This class is intended to be
! // used to let you specialize a function on a compile time number.
  //
  // For example, if you have an object of type T which you want to pass
  // to a subroutine foo, but you want to specialize that subroutine based on
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000865.html">Patch: Preliminary Pooma Manual
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#864">[ date ]</a>
              <a href="thread.html#864">[ thread ]</a>
              <a href="subject.html#864">[ subject ]</a>
              <a href="author.html#864">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
