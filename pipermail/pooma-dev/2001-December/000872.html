<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Manual Patch: Finish Concepts Chapter
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%20Patch%3A%20Finish%20Concepts%20Chapter&In-Reply-To=%3C20011212210531.A13125%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000871.html">
   <LINK REL="Next"  HREF="000873.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Manual Patch: Finish Concepts Chapter</H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%20Patch%3A%20Finish%20Concepts%20Chapter&In-Reply-To=%3C20011212210531.A13125%40codesourcery.com%3E"
       TITLE="Manual Patch: Finish Concepts Chapter">oldham at codesourcery.com
       </A><BR>
    <I>Thu Dec 13 05:05:31 UTC 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000871.html">Patch: Fix Typos in Comments
</A></li>
        <LI>Next message: <A HREF="000873.html">Manual Patch: Some Concepts Changes 
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#872">[ date ]</a>
              <a href="thread.html#872">[ thread ]</a>
              <a href="subject.html#872">[ subject ]</a>
              <a href="author.html#872">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2001-Dec-12  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

	This patch mainly finishes the first draft of the Pooma concepts
	chapter.
	
	* concepts.xml: New file containing the chapter describing the
	Pooma concepts.  Some of this material was moved out of
	manual.xml.  The &quot;Computation Modes&quot; and &quot;Computation Environment&quot;
	material is new.
	* glossary.xml: Added entries corresponding to concepts added to
	concepts.xml.
	* manual.xml: Concepts chapter moved into concepts.xml.  Unused
	material moved to &quot;Writing Sequential Programs&quot; chapter.
	* figures/concepts.mp: Changed &quot;geometric value&quot; to &quot;spatial
	value&quot;.
	
Applied to	mainline.

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: concepts.xml
===================================================================
RCS file: concepts.xml
diff -N concepts.xml
*** /dev/null	Fri Mar 23 21:37:44 2001
--- concepts.xml	Wed Dec 12 21:02:05 2001
***************
*** 0 ****
--- 1,630 ----
+ &lt;chapter id=&quot;concepts&quot;&gt;
+  &lt;title&gt;Overview of &pooma; Concepts&lt;/title&gt;
+ 
+  &lt;para&gt;FIXME: How does multi-threaded computation fit into the
+  model?&lt;/para&gt;
+ 
+  &lt;para&gt;In the previous chapter, we presented several different
+  implementations of the &amp;doof2d; simulation program.  The
+  implementations illustrate the various containers, computation
+  modes, and computation environments that &pooma; supports.  In this
+  chapter, we describe the concepts associated with each of these
+  three categories.  Specific details needed by programmers are
+  deferred to later chapters.&lt;/para&gt;
+ 
+  &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+    orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-table&quot;&gt;
+    &lt;title&gt;&pooma; Implementation Concepts&lt;/title&gt;
+    &lt;tgroup cols=&quot;3&quot; align=&quot;center&quot;&gt;
+     &lt;thead&gt;
+      &lt;row&gt;
+       &lt;entry&gt;Container&lt;/entry&gt;
+ 	&lt;entry&gt;Computation Modes&lt;/entry&gt;
+ 	&lt;entry&gt;Computation Environment&lt;/entry&gt;
+      &lt;/row&gt;
+     &lt;/thead&gt;
+     &lt;tbody&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&array;&lt;/entry&gt;
+ 	&lt;entry&gt;element-wise&lt;/entry&gt;
+ 	&lt;entry&gt;sequential&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&dynamicarray;&lt;/entry&gt;
+ 	&lt;entry&gt;data-parallel&lt;/entry&gt;
+ 	&lt;entry&gt;distributed&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&field;&lt;/entry&gt;
+ 	&lt;entry&gt;stencil-based&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&tensor;&lt;/entry&gt;
+ 	&lt;entry&gt;relational&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&matrix;&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&vector;&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;&lt;/entry&gt;
+      &lt;/row&gt;
+     &lt;/tbody&gt;
+    &lt;/tgroup&gt;
+   &lt;/table&gt;
+ 
+  &lt;para&gt;The most important &pooma; concepts can be grouped into three
+  separate categories:
+  &lt;variablelist&gt;
+   &lt;varlistentry&gt;
+     &lt;term&gt;container&lt;/term&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;data structure holding one or more values and addressed
+      by indices&lt;/para&gt;
+     &lt;/listitem&gt;
+    &lt;/varlistentry&gt;
+    &lt;varlistentry&gt;
+     &lt;term&gt;computation modes&lt;/term&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;styles of expressing computations&lt;/para&gt;
+     &lt;/listitem&gt;
+    &lt;/varlistentry&gt;
+    &lt;varlistentry&gt;
+     &lt;term&gt;computation environment&lt;/term&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;description of resources for computing, e.g., single
+      processor or multi-processor&lt;/para&gt;
+     &lt;/listitem&gt;
+    &lt;/varlistentry&gt;
+   &lt;/variablelist&gt;
+   See &lt;xref linkend=&quot;concepts-table&quot;&gt;&lt;/xref&gt;.  Many &pooma; programs
+   select one possibility from each column.  For example, &lt;xref
+   linkend=&quot;tutorial-array_stencil-doof2d&quot;&gt;&lt;/xref&gt; used a &array;
+   container and stencils for sequential computation, while &lt;xref
+   linkend=&quot;tutorial-field_distributed-doof2d&quot;&gt;&lt;/xref&gt; used a &field;
+   container and data-parallel statements with distributed
+   computation.  A program may use multiple containers and various
+   computation modes, but the computation environment either has
+   distributed processors or not.&lt;/para&gt;
+ 
+  &lt;para&gt;In the rest of this chapter, we explore these three
+  categories.  First, we describe &pooma; containers, illustrating
+  the purposes of each, and explaining the concepts needed to declare
+  them.  Then, we describe the different computation modes and
+  finally distributed computation concepts.&lt;/para&gt;
+ 
+ 
+  &lt;section id=&quot;concepts-containers&quot;&gt;
+   &lt;title&gt;&pooma; Containers&lt;/title&gt;
+ 
+   &lt;para&gt;Most &pooma; programs use &lt;firstterm&gt;containers&lt;/firstterm&gt;
+   to store groups of values.  &pooma; containers are objects that
+   store other objects.  They control allocation and deallocation of
+   and access to these objects.  They are a generalization of &c;
+   arrays, but &pooma; containers are first-class objects so they can
+   be used directly in expressions.  They are similar to &cc;
+   containers such as &lt;type&gt;vector&lt;/type&gt;, &lt;type&gt;list&lt;/type&gt;, and
+   &lt;type&gt;stack&lt;/type&gt;.  See &lt;xref
+   linkend=&quot;concepts-containers-table&quot;&gt;&lt;/xref&gt; for a summary of the
+   containers.&lt;/para&gt;
+ 
+   &lt;para&gt;This chapter describes many concepts, not all of which are
+   needed to begin programming with the &pooma; Toolkit.  Below we
+   introduce the different categories of concepts.  After that, we
+   introduce the different &pooma;'s containers and describe how to
+   choose the appropriate one for a particular task.  &lt;xref
+   linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
+   indicates which concepts must be understood when declaring a
+   particular container.  All of these concepts are described in
+   &lt;xref
+   linkend=&quot;concepts-containers-sequential_declarations&quot;&gt;&lt;/xref&gt; and
+   &lt;xref
+   linkend=&quot;concepts-containers-distributed_declarations&quot;&gt;&lt;/xref&gt;.
+   Use this figure to decide which concepts in the former are
+   relevant.  Reading the latter section is necessary only if
+   computing using multiple processors.  The programs in the previous
+   chapter illustrate many of these concepts.&lt;/para&gt;
+ 
+   &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-table&quot;&gt;
+    &lt;title&gt;&pooma; Container Summary&lt;/title&gt;
+    &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+     &lt;tbody&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&lt;glossterm
+ 	linkend=&quot;glossary-array&quot;&gt;&array;&lt;/glossterm&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;container mapping indices to values and that may be
+ 	used in expressions&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&lt;glossterm
+ 	linkend=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/glossterm&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;one-dimensional &array; whose &lt;glossterm
+ 	linkend=&quot;glossary-domain&quot;&gt;domain&lt;/glossterm&gt; can be dynamically
+ 	resized&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&lt;glossterm linkend=&quot;glossary-field&quot;&gt;&field;&lt;/glossterm&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;container mapping indices to one or more values and
+ 	residing in multi-dimensional space&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&lt;glossterm
+ 	linkend=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossterm&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;multi-dimensional mathematical tensor&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&lt;glossterm
+ 	linkend=&quot;glossary-matrix&quot;&gt;&matrix;&lt;/glossterm&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;two-dimensional mathematical matrix&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;&lt;glossterm
+ 	linkend=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossterm&gt;&lt;/entry&gt;
+ 	&lt;entry&gt;multi-dimensional mathematical vector&lt;/entry&gt;
+      &lt;/row&gt;
+     &lt;/tbody&gt;
+    &lt;/tgroup&gt;
+   &lt;/table&gt;
+ 
+ &lt;!-- FIXME: Want firstterm around array. --&gt;
+ 
+   &lt;para&gt;A &pooma; &lt;glossterm
+   linkend=&quot;glossary-array&quot;&gt;array;&lt;/glossterm&gt;, generalizing a &c;
+   array, maps indices to values.  Given a index or position in an
+   &array;'s domain, it returns the associated value, either by
+   returning a stored value or by computing it.  The use of indices,
+   which are usually ordered tuples, permits constant-time access
+   although computing a particular value may require significant
+   time.  In addition to the functionality provided by &c; arrays,
+   the &array; class automatically handles memory allocation and
+   deallocation, supports a wider variety of assignments, and can be
+   used in expressions.  For example, the addition of two arrays can
+   be assigned to an array and the product of a scalar element and an
+   array is permissible.&lt;/para&gt;
+ 
+ &lt;!-- FIXME: Want firstterm around dynamicarray. --&gt;
+ 
+   &lt;para&gt;A &pooma; &lt;glossterm
+   linkend=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/glossterm&gt; extends
+   &array; capabilities to support a dynamically-changing domain but
+   is restricted to only one dimension.  When the &dynamicarray; is
+   resized, its values are preserved.&lt;/para&gt;
+ 
+ &lt;!-- FIXME: Want firstterm around field. --&gt;
+ 
+   &lt;para&gt;A &pooma; &lt;glossterm&gt;&field;&lt;/glossterm&gt; is an &array; with
+   spatial extent.  Each domain consists of &lt;glossterm
+   linkend=&quot;glossary-cell&quot;&gt;&lt;firstterm&gt;cell&lt;/firstterm&gt;&lt;/glossterm&gt;s
+   in one-, two-, or three-dimensional space.  Although indexed
+   similarly to &array;s, each cell may contain multiple values and
+   multiple materials.  A &field;'s &lt;glossterm
+   linkend=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossterm&gt; stores its spatial
+   characteristics and can map yield, e.g., a point contained in a
+   cell, the distance between two cells, and a cell's normals.  A
+   &field; should be used whenever geometric or spatial computations
+   are needed, multiple values per index are desired, or a
+   computation involves more than one material.&lt;/para&gt;
+ 
+ &lt;!-- FIXME: Want firstterm around tensor. --&gt;
+ 
+   &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossterm&gt;
+   implements a multi-dimensional mathematical tensor.  Since it is a
+   first-class type, it can be used in expressions such as
+   adding two &tensor;s.&lt;/para&gt;
+ 
+ &lt;!-- FIXME: Want firstterm around matrix. --&gt;
+ 
+   &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-matrix&quot;&gt;&matrix;&lt;/glossterm&gt;
+   implements a two-dimensional mathematical matrix.  Since it is a
+   first-class type, it can be used in expressions such as
+   multiplying matrices and assignments to matrices.&lt;/para&gt;
+ 
+ &lt;!-- FIXME: Want firstterm around vector. --&gt;
+ 
+   &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossterm&gt;
+   implements a multi-dimensional mathematical vector, which is an
+   ordered tuple of components.  Since it is a first-class type, it
+   can be used in expressions such as adding two &vector;s and
+   multiplying a &matrix; and a &vector;.&lt;/para&gt;
+ 
+   &lt;para&gt;The data of an &array;, &dynamicarray;, or &field; can be
+   viewed using more than one container by taking a view.  A
+   &lt;glossterm
+   linkend=&quot;glossary-view&quot;&gt;&lt;firstterm&gt;view&lt;/firstterm&gt;&lt;/glossterm&gt; of
+   an existing container&nbsp;&container; is a container whose domain
+   is a subset of&nbsp;&container;.  The subset can equal the
+   original domain.  A view acts like a reference in that changing
+   any of the view's values also changes the original container's and
+   vice versa.  While users sometimes explicitly create views, they
+   are perhaps more frequently created as temporaries in expressions.
+   For example, if &lt;varname&gt;A&lt;/varname&gt; is an &array; and
+   &lt;varname&gt;I&lt;/varname&gt; is a domain, &lt;statement&gt;A(I) -
+   A(I-1)&lt;/statement&gt; forms the difference between adjacent
+   values.&lt;/para&gt;
+ 
+ 
+   &lt;section id=&quot;concepts-containers-choosing&quot;&gt;
+    &lt;title&gt;Choosing a Container&lt;/title&gt;
+ 
+    &lt;para&gt;The two most commonly used &pooma; containers are &array;s
+    and &field;s.  &lt;xref
+    linkend=&quot;concepts-containers-choice_table&quot;&gt;&lt;/xref&gt; contains a
+    decision tree describing how to choose an appropriate
+    container.&lt;/para&gt;
+ 
+   &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
+ 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-choice_table&quot;&gt;
+    &lt;title&gt;Choosing a &pooma; Container&lt;/title&gt;
+    &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
+     &lt;tbody&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;If modeling mathematical entries,&lt;/entry&gt;
+ 	&lt;entry&gt;use a &vector;, &matrix;, or &tensor;.&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;If indices and values reside in multi-dimensional space
+ 	&space;,&lt;/entry&gt;
+ 	&lt;entry&gt;use a &field;.&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;If there are multiple values per index,&lt;/entry&gt;
+ 	&lt;entry&gt;use a &field;.&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;If there are multiple materials participating in the same computation,&lt;/entry&gt;
+ 	&lt;entry&gt;use a &field;.&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;If the domain's size dynamically changes and is one-dimensional,&lt;/entry&gt;
+ 	&lt;entry&gt;use a &dynamicarray;.&lt;/entry&gt;
+      &lt;/row&gt;
+      &lt;row&gt;
+ 	&lt;entry&gt;Otherwise&lt;/entry&gt;
+ 	&lt;entry&gt;use an &array;.&lt;/entry&gt;
+      &lt;/row&gt;
+     &lt;/tbody&gt;
+    &lt;/tgroup&gt;
+   &lt;/table&gt;
+ 
+   &lt;/section&gt;&lt;!-- choosing among containers --&gt;
+ 
+ 
+   &lt;section id=&quot;concepts-containers-sequential_declarations&quot;&gt;
+    &lt;title&gt;Declaring Sequential Containers&lt;/title&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;
+     &lt;title&gt;Concepts For Declaring Containers&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+ 	&lt;imagedata fileref=&quot;figures/concepts.111&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+ 	&lt;phrase&gt;concepts involved in declaring containers&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;para&gt;In the previous sections, we introduced the &pooma;
+    containers and described how to choose one appropriate for a
+    given task.  In this section, we describe the concepts involved
+    in declaring them.  Concepts specific to distributed computation
+    are described in the next section.&lt;/para&gt;
+ 
+    &lt;para&gt;&lt;xref
+    linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
+    illustrates the containers and the concepts involved in their
+    declarations.  The containers are listed in the top row.  Lines
+    connect these containers to the components necessary for their
+    declarations.  For example, an &array; declaration requires an
+    engine and a layout.  These, in turn, depend on other &pooma;
+    concepts.  Declarations necessary only for distributed, or
+    multiprocessor, computation are surrounded by dashed lines.  You
+    can use these dependences to indicate the concepts needed for a
+    particular container.&lt;/para&gt;
+ 
+    &lt;para&gt;An &lt;glossterm
+    linkend=&quot;glossary-engine&quot;&gt;&lt;firstterm&gt;engine&lt;/firstterm&gt;&lt;/glossterm&gt;
+    stores and, if necessary, computes a container's values.  A
+    container has one or more engines.  The separation of a container
+    and its storage permits optimizing a program's space
+    requirements.  For example, a container returning the same value
+    for all indices can use a constant engine, which need only store
+    one value for the entire domain.  A &compressiblebrick; engine
+    reduces its space requirements to a constant whenever all its
+    values are the same.  The separation also permits taking &lt;link
+    linkend=&quot;glossary-view&quot;&gt;view&lt;/link&gt;s of containers without
+    copying storage.&lt;/para&gt;
+ 
+    &lt;figure float=&quot;1&quot; id=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;
+     &lt;title&gt;&array; and &field; Mathematical and Computational Concepts&lt;/title&gt;
+     &lt;mediaobject&gt;
+      &lt;imageobject&gt;
+ 	&lt;imagedata fileref=&quot;figures/concepts.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
+      &lt;/imageobject&gt;
+      &lt;textobject&gt;
+ 	&lt;phrase&gt;maps from indices to values&lt;/phrase&gt;
+      &lt;/textobject&gt;
+     &lt;/mediaobject&gt;
+    &lt;/figure&gt;
+ 
+    &lt;para&gt;A &lt;glossterm
+    linkend=&quot;glossary-layout&quot;&gt;&lt;firstterm&gt;layout&lt;/firstterm&gt;&lt;/glossterm&gt;
+    maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; indices to the
+    processors and computer memory used by a container's engines.
+    See &lt;xref
+    linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
+    A computer computes a container's values using a processor and
+    memory.  The layout specifies the processor(s) and memory to use
+    for each particular index.  A container's layout for a
+    uniprocessor implementation consists of its domain, the
+    processor, and its memory.  For a multi-processor implementation,
+    the layout maps portions of the domain to (possibly different)
+    processors and memory.&lt;/para&gt;
+ 
+    &lt;para&gt;A &field;'s &lt;glossterm
+    linkend=&quot;glossary-mesh&quot;&gt;&lt;firstterm&gt;mesh&lt;/firstterm&gt;&lt;/glossterm&gt;
+    maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; indices to
+    spatial values in &space; such as distance between cells, edge
+    lengths, and normals to cells.  In other words, it provides a
+    &field;'s spatial extent.  See also &lt;xref
+    linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
+    Different mesh types may support different spatial
+    values.&lt;/para&gt;
+ 
+    &lt;para&gt;A mesh's &lt;glossterm
+    linkend=&quot;glossary-corner_position&quot;&gt;&lt;firstterm&gt;corner
+    position&lt;/firstterm&gt;&lt;/glossterm&gt; specifies the &lt;link
+    linkend=&quot;glossary-point&quot;&gt;point&lt;/link&gt; in &space; corresponding to
+    the lower, left corner of its &lt;link
+    linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt;.  Combining this, the
+    domain, and the cell size fully specifies the mesh's map from
+    indices to &space;.&lt;/para&gt;
+ 
+    &lt;para&gt;A mesh's &lt;glossterm
+    linkend=&quot;glossary-cell_size&quot;&gt;&lt;firstterm&gt;cell
+    size&lt;/firstterm&gt;&lt;/glossterm&gt; specifies the spatial dimensions of
+    a &field; &lt;link linkend=&quot;glossary-cell&quot;&gt;cell&lt;/link&gt;, e.g., its
+    width, height, and depth, in&nbsp;&space;.  Combining this, the
+    domain, and the corner position fully specifies the mesh's map
+    from indices to &space;.&lt;/para&gt;
+ 
+    &lt;para&gt;A &lt;glossterm
+    linkend=&quot;glossary-domain&quot;&gt;&lt;firstterm&gt;domain&lt;/firstterm&gt;&lt;/glossterm&gt;
+    is a set of points on which a container can define values.  An
+    &lt;glossterm
+    linkend=&quot;glossary-interval&quot;&gt;&lt;firstterm&gt;interval&lt;/firstterm&gt;&lt;/glossterm&gt;
+    consists of all integral points between two values.  It is
+    frequently represented using mathematical interval notation [a,b]
+    even though it contains only the integral points, e.g., a, a+1,
+    a+2, &hellip;, b.  The concept is generalized to multiple
+    dimensions by forming tensor product of intervals, i.e., all the
+    integral tuples in an &n;-dimensional space.  For example, the
+    two-dimensional containers in the previous chapter are defined on
+    a two-dimensional domain with the both dimensions' spanning the
+    interval [0,n).  A &lt;glossterm
+    linkend=&quot;glossary-stride&quot;&gt;&lt;firstterm&gt;stride&lt;/firstterm&gt;&lt;/glossterm&gt;
+    is a subset of an interval consisting of regularly-spaced
+    points.  A &lt;glossterm
+    linkend=&quot;glossary-range&quot;&gt;&lt;firstterm&gt;range&lt;/firstterm&gt;&lt;/glossterm&gt;
+    is a subset of an interval formed by the tensor product of strides.
+    A &lt;glossterm
+    linkend=&quot;glossary-region&quot;&gt;&lt;firstterm&gt;region&lt;/firstterm&gt;&lt;/glossterm&gt;
+    represents a continuous &n;-dimensional domain.&lt;/para&gt;
+   &lt;/section&gt;
+ 
+ 
+   &lt;section id=&quot;concepts-containers-distributed_declarations&quot;&gt;
+    &lt;title&gt;Declaring Distributed Containers&lt;/title&gt;
+ 
+    &lt;para&gt;In the previous section, we introduced the concepts
+    important when declaring containers for use on uniprocessor
+    computers.  When using multi-processor computers, we augment
+    these concepts with those for distributed computation.  Reading
+    this section is important only for running the same program on
+    multiple processors.  Many of these concepts were introduced in
+    &lt;xref linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt; and &lt;xref
+    linkend=&quot;tutorial-field_distributed&quot;&gt;&lt;/xref&gt;.  &lt;xref
+    linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
+    illustrates the &pooma; distributed computation model.  In this
+    section, we concentrate on the concepts necessary to declare a
+    distributed container.&lt;/para&gt;
+ 
+    &lt;para&gt;As we noted in &lt;xref
+    linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt;, a &pooma;
+    programmer must specify how each container's domain should be
+    distributed among the available processors and memory spaces.
+    Using this information, the Toolkit automatically distributes the
+    data among the available processors and handles any required
+    communication among them.  The three concepts necessary for
+    declaring distributed containers are a partition, a guard layer,
+    and a context mapper tag.&lt;/para&gt;
+ 
+    &lt;para&gt;A &lt;glossterm
+    linkend=&quot;glossary-partition&quot;&gt;&lt;firstterm&gt;partition&lt;/firstterm&gt;&lt;/glossterm&gt;
+    specified how to divide a container's domain into distributed
+    pieces.  For example, the partition illustrated in &lt;xref
+    linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
+    would divide a two-dimensional domain into three equally-sized
+    pieces along the x-dimension and two equally-sized pieces along
+    the y-dimension.  Partitions can be independent of the size of
+    container's domain.  The example partition will work on any
+    domain as long as the size of its x-dimension is a multiple of
+    three.  A domain is separated into disjoint &lt;link
+    linkend=&quot;glossary-patch&quot;&gt;patch&lt;/link&gt;es.&lt;/para&gt;
+ 
+    &lt;para&gt;A &lt;glossterm
+    linkend=&quot;glossary-guard_layer&quot;&gt;&lt;firstterm&gt;guard
+    layer&lt;/firstterm&gt;&lt;/glossterm&gt; is &lt;quote&gt;extra&lt;/quote&gt; domain
+    surrounding each patch.  This region has read-only values.  An
+    &lt;glossterm
+    linkend=&quot;glossary-external_guard_layer&quot;&gt;&lt;firstterm&gt;external guard
+    layer&lt;/firstterm&gt;&lt;/glossterm&gt; specifies values surrounding the
+    domain.  Its presence eases computation along the domain's edges
+    by permitting the same computations as for more internal
+    computations.  An &lt;glossterm
+    linkend=&quot;glossary-internal_guard_layer&quot;&gt;&lt;firstterm&gt;internal guard
+    layer&lt;/firstterm&gt;&lt;/glossterm&gt; duplicates values from adjacent
+    patches so communication with adjacent patches need not occur
+    during a patch's computation.  The use of guard layers is an
+    optimization; using external guard layers eases programming and
+    using internal guard layers reduces communication among
+    processors.  Their use is not required.&lt;/para&gt;
+ 
+    &lt;para&gt;A &lt;glossterm
+    linkend=&quot;glossary-context_mapper&quot;&gt;&lt;firstterm&gt;context
+    mapper&lt;/firstterm&gt;&lt;/glossterm&gt; indicates how a container's
+    patches are mapped to processors and shared memory.  For example,
+    the &distributedtag; indicates that the patches should be
+    distributed among the processors so each patch occurs once in the
+    entire computation.  The &replicatedtag; indicates that the
+    patches should be replicated among the processors so each
+    processing unit has its own copy of all the patches.  While it
+    could be wasteful to have different processors perform the same
+    computation, replicating a container can reduce possibly more
+    expensive communication costs.&lt;/para&gt;
+   &lt;/section&gt;
+  &lt;/section&gt;
+ 
+ 
+  &lt;section id=&quot;concepts-computation_modes&quot;&gt;
+   &lt;title&gt;Computation Modes&lt;/title&gt;
+ 
+   &lt;para&gt;&pooma; computations can be expressed using a variety of
+   modes.  Most of &pooma; computations involve &array; or &field;
+   containers, but how their values are accessed and the associated
+   algorithms using them varies.  Element-wise computation involves
+   explicitly accessing values.  A data-parallel computation uses
+   expressions to represent larger subsets of a container's values.
+   Stencil-based computations write a computation as repeatedly
+   applying a local computation to each element of an array.  A
+   relation among containers establishes a dependency between them so
+   the values of one container are updated whenever any other's
+   values change.  A program may use any or all of these styles,
+   described below.&lt;/para&gt;
+ 
+   &lt;para&gt;&lt;glossterm
+   linkend=&quot;glossary-element_wise&quot;&gt;&lt;firstterm&gt;Element-wise&lt;/firstterm&gt;&lt;/glossterm&gt;
+   computation accesses individual container values through explicit
+   notation.  For example, values in a two-dimensional
+   container&nbsp;&container; might be referenced as
+   &lt;statement&gt;&amp;container(3,4)&lt;/statement&gt; or
+   &lt;statement&gt;&amp;container(i,j+1)&lt;/statement&gt;.  This is the usual
+   notation for languages without objects such as &c;.&lt;/para&gt;
+ 
+   &lt;para&gt;&lt;glossterm
+   linkend=&quot;glossary-data_parallel&quot;&gt;&lt;firstterm&gt;Data-parallel&lt;/firstterm&gt;&lt;/glossterm&gt;
+   computation uses expressions to access subsets of a container's
+   values.  For example, in &lt;xref
+   linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;,
+   &lt;statement&gt;a(I,J)&lt;/statement&gt; represents the subset of &array;
+   &lt;varname&gt;a&lt;/varname&gt;'s values with coordinates in the domain
+   specified by the one-dimensional &interval;s &lt;varname&gt;I&lt;/varname&gt;
+   and &lt;varname&gt;J&lt;/varname&gt;.  Using data-parallel expressions
+   frequently eliminates the need for writing explicit loops in
+   code.&lt;/para&gt;
+ 
+   &lt;para&gt;A &lt;glossterm
+   linkend=&quot;glossary-stencil&quot;&gt;&lt;firstterm&gt;stencil&lt;/firstterm&gt;&lt;/glossterm&gt;
+   computes a container's value using neighboring data values.  Each
+   stencil consists of an indication of which neighboring values to
+   read and a function using those values.  For example, an averaging
+   stencil may access all neighbors, averaging them.  In &pooma;, we
+   represent a stencil using a function object having functions
+   indicating which neighboring values are used.  Stencil
+   computations are frequently used in solving partial differential
+   equations, image processing, and geometric modeling.&lt;/para&gt;
+ 
+   &lt;para&gt;A &lt;glossterm
+   linkend=&quot;glossary-relation&quot;&gt;&lt;firstterm&gt;relation&lt;/firstterm&gt;&lt;/glossterm&gt;
+   is a dependence among containers so the dependent container's
+   values are updated when its values are needed and any of its
+   related containers' values have changed.  A relation is specified
+   by a dependent container, independent containers, and a function
+   computing the dependent container's values using the independent
+   containers' values.  To avoid excess computation, the dependent
+   container's values are computed only when needed, e.g., for
+   printing or for computing the values of another dependent
+   container.  Thus, this computation is sometimes called &lt;quote&gt;lazy
+   evaluation&lt;/quote&gt;.&lt;/para&gt;
+  &lt;/section&gt;
+ 
+ 
+  &lt;section id=&quot;concepts-computation_environment&quot;&gt;
+   &lt;title&gt;Computation Environment&lt;/title&gt;
+ 
+   &lt;para&gt;A &pooma; program can execute on a wide variety of
+    computers.  The default &lt;glossterm
+    linkend=&quot;glossary-sequential&quot;&gt;&lt;firstterm&gt;sequential computing
+    environment&lt;/firstterm&gt;&lt;/glossterm&gt; consists of one processor and
+    associated memory, as found on a personal computer.  In contrast,
+    a &lt;glossterm
+    linkend=&quot;glossary-distributed&quot;&gt;&lt;firstterm&gt;distributed computing
+    environment&lt;/firstterm&gt;&lt;/glossterm&gt; may have multiple processors
+    and multiple distributed or shared memories.  For example, some
+    desktop computers have dual processors and shared memory, while a
+    large supercomputer may have thousands of processors, perhaps
+    with groups of eight sharing the same memory.&lt;/para&gt;
+ 
+   &lt;para&gt;Using distributed computation requires three things:
+    &lt;orderedlist&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;the programmer must declare how container domains will
+       be distributed,&lt;/para&gt;
+     &lt;/listitem&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;&pooma; must be configured to use a communications
+       library, and &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+ 		  &lt;para&gt;the &pooma; executable must be run using the
+ 	library.&lt;/para&gt;
+     &lt;/listitem&gt;
+    &lt;/orderedlist&gt;
+    All of these were illustrated in &lt;xref
+    linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt; and &lt;xref
+    linkend=&quot;tutorial-field_distributed&quot;&gt;&lt;/xref&gt;.  &lt;xref
+    linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
+    illustrates the &pooma; distributed computation model.  &lt;xref
+    linkend=&quot;concepts-containers-distributed_declarations&quot;&gt;&lt;/xref&gt;
+    described how to declare containers with distributed domains.
+    Detailed instructions how to configure &pooma; for distributed
+    computation appear in &lt;xref linkend=&quot;installation&quot;&gt;&lt;/xref&gt;.
+    Detailed instructions how to run distributed &pooma; executables
+    appear in &lt;xref linkend=&quot;parallel&quot;&gt;&lt;/xref&gt;.  Here we present
+    three concepts for distributed computation: patches, context, and
+    a communication library.&lt;/para&gt;
+ 
+   &lt;para&gt;A partition divides a container's domain into disjoint
+    &lt;glossterm
+    linkend=&quot;glossary-patch&quot;&gt;&lt;firstterm&gt;patch&lt;/firstterm&gt;&lt;/glossterm&gt;es.
+    For distributed computation, the patches are distributed among
+    various processors, which compute the associated values.  As
+    illustrated in &lt;xref
+    linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;,
+    each patch can be surrounded by guard layers.&lt;/para&gt;
+ 
+   &lt;para&gt;A &lt;glossterm
+    linkend=&quot;glossary-context&quot;&gt;&lt;firstterm&gt;context&lt;/firstterm&gt;&lt;/glossterm&gt;
+    is a collection of shared memory and processors that can execute
+    a program of a portion of a program.  It can have one or more
+    processors, but all these processors must access the same shared
+    memory.  Usually the computer and its operating system, not the
+    programmer, determine the available contexts.&lt;/para&gt;
+ 
+   &lt;para&gt;A &lt;glossterm
+    linkend=&quot;glossary-communication_library&quot;&gt;&lt;firstterm&gt;communication
+    library&lt;/firstterm&gt;&lt;/glossterm&gt; passes messages among contexts.
+    &pooma; uses the communication library to copy information among
+    contexts, all of which is hidden from both the programmer and the
+    user.  &pooma; works with the Message Passing Interface (&mpi;)
+    Communications Library (FIXME: xref linkend=&quot;mpi99&quot;, &lt;ulink
+    url=&quot;<A HREF="http://www-unix.mcs.anl.gov/mpi/">http://www-unix.mcs.anl.gov/mpi/</A>&quot;&gt;&lt;/ulink&gt;) and the &mm;
+    Shared Memory Library.&lt;/para&gt;
+   &lt;/section&gt;
+ &lt;/chapter&gt;
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.1
diff -c -p -r1.1 glossary.xml
*** glossary.xml	2001/12/11 20:36:13	1.1
--- glossary.xml	2001/12/13 04:02:05
***************
*** 72,77 ****
--- 72,86 ----
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
+   &lt;glossentry id=&quot;glossary-communication_library&quot;&gt;
+    &lt;glossterm&gt;communication library&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;software library passing information among contexts, usually
+     using messages.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-distributed&quot;&gt;distributed computing environment&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-computing_environment&quot;&gt;
     &lt;glossterm&gt;computing environment&lt;/glossterm&gt;
     &lt;glossdef&gt;
***************
*** 137,142 ****
--- 146,165 ----
   &lt;glossdiv id=&quot;glossary-d&quot;&gt;
    &lt;title&gt;D&lt;/title&gt;
  
+   &lt;glossentry id=&quot;glossary-data_parallel&quot;&gt;
+    &lt;glossterm&gt;data parallel&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;describes an expression representing a subset of a
+     container's values.  For example,
+     &lt;statement&gt;sin(&container;)&lt;/statement&gt; is an expression
+     indicating that the &lt;function&gt;sin&lt;/function&gt; is applied to each
+     value in container&nbsp;&container;.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-element_wise&quot;&gt;element wise&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-relation&quot;&gt;relation&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-stencil&quot;&gt;stencil&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-distributed&quot;&gt;
     &lt;glossterm&gt;distributed computing environment&lt;/glossterm&gt;
     &lt;glossdef&gt;
***************
*** 166,176 ****
     &lt;glossterm&gt;&dynamicarray;&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;a &pooma; container generalizing one-dimensional &lt;link
! 								  linkend=&quot;glossary-array&quot;&gt;&array;&lt;/link&gt;s by supporting domain
      resizing at run-time.  It maps indices to values in constant-time
      access, ignoring the time to compute the values if applicable.
      &dynamicarray;s are &lt;link
! 			       linkend=&quot;glossary-first_class&quot;&gt;first-class object&lt;/link&gt;s.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-array&quot;&gt;&array;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
--- 189,199 ----
     &lt;glossterm&gt;&dynamicarray;&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;a &pooma; container generalizing one-dimensional &lt;link
!     linkend=&quot;glossary-array&quot;&gt;&array;&lt;/link&gt;s by supporting domain
      resizing at run-time.  It maps indices to values in constant-time
      access, ignoring the time to compute the values if applicable.
      &dynamicarray;s are &lt;link
!     linkend=&quot;glossary-first_class&quot;&gt;first-class object&lt;/link&gt;s.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-array&quot;&gt;&array;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-field&quot;&gt;&field;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
***************
*** 180,195 ****
    &lt;glossdiv id=&quot;glossary-e&quot;&gt;
    &lt;title&gt;E&lt;/title&gt;
  
    &lt;glossentry id=&quot;glossary-engine&quot;&gt;
     &lt;glossterm&gt;engine&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;stores and, if necessary, computes a &lt;link
! 						      linkend=&quot;glossary-container&quot;&gt;container&lt;/link&gt;'s values.  These
!     can be specialized, e.g., to minimize storage when a domain has
!     few distinct values.  Separating a container and its storage also
!     permits &lt;link linkend=&quot;glossary-view&quot;&gt;views&lt;/link&gt; of a container.&lt;/para&gt;
!     &lt;glossseealso otherterm=&quot;glossary-container&quot;&gt;&engine;&lt;/glossseealso&gt;
!     &lt;glossseealso otherterm=&quot;glossary-view&quot;&gt;view of a container&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
--- 203,232 ----
    &lt;glossdiv id=&quot;glossary-e&quot;&gt;
    &lt;title&gt;E&lt;/title&gt;
  
+   &lt;glossentry id=&quot;glossary-element_wise&quot;&gt;
+    &lt;glossterm&gt;element wise&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;describes accesses to individual values within a container.
+     For example, &lt;statement&gt;&amp;container(i,j)&lt;/statement&gt; represents one
+     particular value in the container&nbsp;&container;.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-relation&quot;&gt;relation&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-stencil&quot;&gt;stencil&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
    &lt;glossentry id=&quot;glossary-engine&quot;&gt;
     &lt;glossterm&gt;engine&lt;/glossterm&gt;
     &lt;glossdef&gt;
      &lt;para&gt;stores and, if necessary, computes a &lt;link
!     linkend=&quot;glossary-container&quot;&gt;container&lt;/link&gt;'s values.  These can
!     be specialized, e.g., to minimize storage when a domain has few
!     distinct values.  Separating a container and its storage also
!     permits &lt;link linkend=&quot;glossary-view&quot;&gt;views&lt;/link&gt; of a
!     container.&lt;/para&gt; &lt;glossseealso
!     otherterm=&quot;glossary-container&quot;&gt;&engine;&lt;/glossseealso&gt;
!     &lt;glossseealso otherterm=&quot;glossary-view&quot;&gt;view of a
!     container&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
***************
*** 221,227 ****
      also supports geometric computations such as the distance between
      two &lt;link linkend=&quot;glossary-cell&quot;&gt;cell&lt;/link&gt;s and normals to a
      cell.  &field;s are &lt;link
! 			       linkend=&quot;glossary-first_class&quot;&gt;first-class object&lt;/link&gt;s.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-array&quot;&gt;&array;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
--- 258,264 ----
      also supports geometric computations such as the distance between
      two &lt;link linkend=&quot;glossary-cell&quot;&gt;cell&lt;/link&gt;s and normals to a
      cell.  &field;s are &lt;link
!     linkend=&quot;glossary-first_class&quot;&gt;first-class object&lt;/link&gt;s.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-array&quot;&gt;&array;&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
***************
*** 236,242 ****
      may be declared anywhere, stored in automatic variables, accessed
      anywhere, copied, and passed by both value and reference.
      &pooma; &lt;link linkend=&quot;glossary-array&quot;&gt;&array;&lt;/link&gt; and &lt;link
! 								     linkend=&quot;glossary-field&quot;&gt;&field;&lt;/link&gt; are first-class
      types.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
--- 273,279 ----
      may be declared anywhere, stored in automatic variables, accessed
      anywhere, copied, and passed by both value and reference.
      &pooma; &lt;link linkend=&quot;glossary-array&quot;&gt;&array;&lt;/link&gt; and &lt;link
!     linkend=&quot;glossary-field&quot;&gt;&field;&lt;/link&gt; are first-class
      types.&lt;/para&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
***************
*** 373,380 ****
    &lt;glossentry id=&quot;glossary-patch&quot;&gt;
     &lt;glossterm&gt;patch&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;
! ERE&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-partition&quot;&gt;partition&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-guard_layer&quot;&gt;guard layer&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
--- 410,418 ----
    &lt;glossentry id=&quot;glossary-patch&quot;&gt;
     &lt;glossterm&gt;patch&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;subset of a container's domain with values computed by a
!     particular context.  A partition splits a domain into patches.  It
!     may be surrounded by external and internal guard layers.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-partition&quot;&gt;partition&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-guard_layer&quot;&gt;guard layer&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-domain&quot;&gt;domain&lt;/glossseealso&gt;
*************** ERE&lt;/para&gt;
*** 417,422 ****
--- 455,475 ----
      &lt;glossseealso otherterm=&quot;glossary-interval&quot;&gt;interval&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
+ 
+   &lt;glossentry id=&quot;glossary-relation&quot;&gt;
+    &lt;glossterm&gt;relation&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;dependence between a dependent container and one or more
+     independent containers and an associated function.  If a dependent
+     container's values are needed and one or more of the independent
+     containers' values have changed, the dependent container's values
+     are computed using the function and the independent containers'
+     values.  Relations implement &lt;quote&gt;lazy evaluation&lt;/quote&gt;.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-element_wise&quot;&gt;element wise&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-stencil&quot;&gt;stencil&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
   &lt;/glossdiv&gt;
  
   &lt;glossdiv id=&quot;glossary-s&quot;&gt;
*************** ERE&lt;/para&gt;
*** 427,435 ****
     &lt;glossdef&gt;
      &lt;para&gt;a computing environment with one processor and associated
      memory.  Only one processor executes a program even if the
!     conmputer itself has multiple processors.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-computing_environment&quot;&gt;computing environment&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-distributed&quot;&gt;distributed computing environment&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
--- 480,503 ----
     &lt;glossdef&gt;
      &lt;para&gt;a computing environment with one processor and associated
      memory.  Only one processor executes a program even if the
!     computer itself has multiple processors.&lt;/para&gt;
      &lt;glossseealso otherterm=&quot;glossary-computing_environment&quot;&gt;computing environment&lt;/glossseealso&gt;
      &lt;glossseealso otherterm=&quot;glossary-distributed&quot;&gt;distributed computing environment&lt;/glossseealso&gt;
+    &lt;/glossdef&gt;
+   &lt;/glossentry&gt;
+ 
+   &lt;glossentry id=&quot;glossary-stencil&quot;&gt;
+    &lt;glossterm&gt;stencil&lt;/glossterm&gt;
+    &lt;glossdef&gt;
+     &lt;para&gt;set of values neighboring a container value and a function
+     using those values to compute it.  For example, the stencil in a
+     two-dimensional Conway game of life consists of a value's eight
+     neighbors and a function that sets the value to
+     &lt;quote&gt;live&lt;/quote&gt; if it is already live or it has exactly three
+     live neighbors.&lt;/para&gt;
+     &lt;glossseealso otherterm=&quot;glossary-data_parallel&quot;&gt;data parallel&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-element_wise&quot;&gt;element wise&lt;/glossseealso&gt;
+     &lt;glossseealso otherterm=&quot;glossary-relation&quot;&gt;relation&lt;/glossseealso&gt;
     &lt;/glossdef&gt;
    &lt;/glossentry&gt;
  
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.1
diff -c -p -r1.1 manual.xml
*** manual.xml	2001/12/11 20:36:13	1.1
--- manual.xml	2001/12/13 04:02:07
***************
*** 154,159 ****
--- 154,161 ----
    &lt;!-- Field data-parallel Doof2d implementation --&gt;
  &lt;!ENTITY doof2d-field-distributed SYSTEM &quot;./programs/Doof2d-Field-distributed-annotated.cpp&quot;&gt;
    &lt;!-- Field data-parallel distributed Doof2d implementation --&gt;
+ &lt;!ENTITY concepts-chapter SYSTEM &quot;concepts.xml&quot;&gt;
+   &lt;!-- Pooma concepts chapter --&gt;
  &lt;!ENTITY glossary-chapter SYSTEM &quot;glossary.xml&quot;&gt;
    &lt;!-- glossary --&gt;
  &lt;!ENTITY tutorial-chapter SYSTEM &quot;tutorial.xml&quot;&gt;
***************
*** 345,1008 ****
  
    &lt;/chapter&gt;
  
-   &amp;tutorial-chapter;
- 
- 
-   &lt;chapter id=&quot;concepts&quot;&gt;
-    &lt;title&gt;Overview of &pooma; Concepts&lt;/title&gt;
- 
-    &lt;para&gt;FIXME: How does multi-threaded computation fit into the
-    model?&lt;/para&gt;
- 
-    &lt;para&gt;In the previous chapter, we presented several different
-    implementations of the &amp;doof2d; simulation program.  The
-    implementations illustrate the various containers, computation
-    syntaxes, and computation environments that &pooma; supports.  In
-    this chapter, we describe the concepts associated with each of
-    these three categories.  Specific details needed by programmers are
-    deferred to later chapters.&lt;/para&gt;
  
!    &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
!      orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-table&quot;&gt;
!      &lt;title&gt;&pooma; Implementation Concepts&lt;/title&gt;
!      &lt;tgroup cols=&quot;3&quot; align=&quot;center&quot;&gt;
!       &lt;thead&gt;
!        &lt;row&gt;
!         &lt;entry&gt;Container&lt;/entry&gt;
! 	&lt;entry&gt;Computation Syntax&lt;/entry&gt;
! 	&lt;entry&gt;Computation Environment&lt;/entry&gt;
!        &lt;/row&gt;
!       &lt;/thead&gt;
!       &lt;tbody&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&array;&lt;/entry&gt;
! 	&lt;entry&gt;element-wise&lt;/entry&gt;
! 	&lt;entry&gt;sequential&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&dynamicarray;&lt;/entry&gt;
! 	&lt;entry&gt;data-parallel&lt;/entry&gt;
! 	&lt;entry&gt;distributed&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&field;&lt;/entry&gt;
! 	&lt;entry&gt;stencil-based&lt;/entry&gt;
! 	&lt;entry&gt;&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&tensor;&lt;/entry&gt;
! 	&lt;entry&gt;relational&lt;/entry&gt;
! 	&lt;entry&gt;&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&matrix;&lt;/entry&gt;
! 	&lt;entry&gt;&lt;/entry&gt;
! 	&lt;entry&gt;&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&vector;&lt;/entry&gt;
! 	&lt;entry&gt;&lt;/entry&gt;
! 	&lt;entry&gt;&lt;/entry&gt;
!        &lt;/row&gt;
!       &lt;/tbody&gt;
!      &lt;/tgroup&gt;
!     &lt;/table&gt;
! 
!    &lt;para&gt;The most important &pooma; concepts can be grouped into three
!    separate categories:
!    &lt;variablelist&gt;
!     &lt;varlistentry&gt;
!       &lt;term&gt;container&lt;/term&gt;
!       &lt;listitem&gt;
!        &lt;para&gt;data structure holding one or more values and addressed
!        by indices&lt;/para&gt;
!       &lt;/listitem&gt;
!      &lt;/varlistentry&gt;
!      &lt;varlistentry&gt;
!       &lt;term&gt;computation syntax&lt;/term&gt;
!       &lt;listitem&gt;
!        &lt;para&gt;styles of expressing computations&lt;/para&gt;
!       &lt;/listitem&gt;
!      &lt;/varlistentry&gt;
!      &lt;varlistentry&gt;
!       &lt;term&gt;computation environment&lt;/term&gt;
!       &lt;listitem&gt;
!        &lt;para&gt;description of resources for computing, e.g., single
!        processor or multi-processor&lt;/para&gt;
!       &lt;/listitem&gt;
!      &lt;/varlistentry&gt;
!     &lt;/variablelist&gt;
!     See &lt;xref linkend=&quot;concepts-table&quot;&gt;&lt;/xref&gt;.  Many &pooma; programs
!     select one possibility from each column.  For example, &lt;xref
!     linkend=&quot;tutorial-array_stencil-doof2d&quot;&gt;&lt;/xref&gt; used a &array;
!     container and stencils for sequential computation, while &lt;xref
!     linkend=&quot;tutorial-field_distributed-doof2d&quot;&gt;&lt;/xref&gt; used a &field;
!     container and data-parallel statements with distributed
!     computation.  A program may use multiple containers and various
!     computation syntax, but the computation environment either has
!     distributed processors or not.&lt;/para&gt;
! 
!    &lt;para&gt;In the rest of this chapter, we explore these three
!    categories.  First, we describe &pooma; containers, illustrating
!    the purposes of each, and explaining the concepts needed to declare
!    them.  Then, we describe the different computation syntaxes and
!    finally distributed computation concepts.&lt;/para&gt;
! 
! 
!    &lt;section id=&quot;concepts-containers&quot;&gt;
!     &lt;title&gt;&pooma; Containers&lt;/title&gt;
! 
!     &lt;para&gt;Most &pooma; programs use &lt;firstterm&gt;containers&lt;/firstterm&gt;
!     to store groups of values.  &pooma; containers are objects that
!     store other objects.  They control allocation and deallocation of
!     and access to these objects.  They are a generalization of &c;
!     arrays, but &pooma; containers are first-class objects so they can
!     be used directly in expressions.  They are similar to &cc;
!     containers such as &lt;type&gt;vector&lt;/type&gt;, &lt;type&gt;list&lt;/type&gt;, and
!     &lt;type&gt;stack&lt;/type&gt;.  See &lt;xref
!     linkend=&quot;concepts-containers-table&quot;&gt;&lt;/xref&gt; for a summary of the
!     containers.&lt;/para&gt;
! 
!     &lt;para&gt;This chapter describes many concepts, not all of which are
!     needed to begin programming with the &pooma; Toolkit.  Below we
!     introduce the different categories of concepts.  After that, we
!     introduce the different &pooma;'s containers and describe how to
!     choose the appropriate one for a particular task.  &lt;xref
!     linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
!     indicates which concepts must be understood when declaring a
!     particular container.  All of these concepts are described in
!     &lt;xref
!     linkend=&quot;concepts-containers-sequential_declarations&quot;&gt;&lt;/xref&gt; and
!     &lt;xref
!     linkend=&quot;concepts-containers-distributed_declarations&quot;&gt;&lt;/xref&gt;.
!     Use this figure to decide which concepts in the former are
!     relevant.  Reading the latter section is necessary only if
!     computing using multiple processors.  The programs in the previous
!     chapter illustrate many of these concepts.&lt;/para&gt;
! 
!     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-table&quot;&gt;
!      &lt;title&gt;&pooma; Container Summary&lt;/title&gt;
!      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!       &lt;tbody&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&lt;glossterm
! 	linkend=&quot;glossary-array&quot;&gt;&array;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;container mapping indices to values and that may be
! 	used in expressions&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&lt;glossterm
! 	linkend=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;one-dimensional &array; whose &lt;glossterm
! 	linkend=&quot;glossary-domain&quot;&gt;domain&lt;/glossterm&gt; can be dynamically
! 	resized&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&lt;glossterm linkend=&quot;glossary-field&quot;&gt;&field;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;container mapping indices to one or more values and
! 	residing in multi-dimensional space&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&lt;glossterm
! 	linkend=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;multi-dimensional mathematical tensor&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&lt;glossterm
! 	linkend=&quot;glossary-matrix&quot;&gt;&matrix;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;two-dimensional mathematical matrix&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;&lt;glossterm
! 	linkend=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossterm&gt;&lt;/entry&gt;
! 	&lt;entry&gt;multi-dimensional mathematical vector&lt;/entry&gt;
!        &lt;/row&gt;
!       &lt;/tbody&gt;
!      &lt;/tgroup&gt;
!     &lt;/table&gt;
! 
! &lt;!-- FIXME: Want firstterm around array. --&gt;
! 
!     &lt;para&gt;A &pooma; &lt;glossterm
!     linkend=&quot;glossary-array&quot;&gt;array;&lt;/glossterm&gt;, generalizing a &c;
!     array, maps indices to values.  Given a index or position in an
!     &array;'s domain, it returns the associated value, either by
!     returning a stored value or by computing it.  The use of indices,
!     which are usually ordered tuples, permits constant-time access
!     although computing a particular value may require significant
!     time.  In addition to the functionality provided by &c; arrays,
!     the &array; class automatically handles memory allocation and
!     deallocation, supports a wider variety of assignments, and can be
!     used in expressions.  For example, the addition of two arrays can
!     be assigned to an array and the product of a scalar element and an
!     array is permissible.&lt;/para&gt;
! 
! &lt;!-- FIXME: Want firstterm around dynamicarray. --&gt;
! 
!     &lt;para&gt;A &pooma; &lt;glossterm
!     linkend=&quot;glossary-dynamicarray&quot;&gt;&dynamicarray;&lt;/glossterm&gt; extends
!     &array; capabilities to support a dynamically-changing domain but
!     is restricted to only one dimension.  When the &dynamicarray; is
!     resized, its values are preserved.&lt;/para&gt;
! 
! &lt;!-- FIXME: Want firstterm around field. --&gt;
! 
!     &lt;para&gt;A &pooma; &lt;glossterm&gt;&field;&lt;/glossterm&gt; is an &array; with
!     spatial extent.  Each domain consists of &lt;glossterm
!     linkend=&quot;glossary-cell&quot;&gt;&lt;firstterm&gt;cell&lt;/firstterm&gt;&lt;/glossterm&gt;s
!     in one-, two-, or three-dimensional space.  Although indexed
!     similarly to &array;s, each cell may contain multiple values and
!     multiple materials.  A &field;'s &lt;glossterm
!     linkend=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossterm&gt; stores its spatial
!     characteristics and can map yield, e.g., a point contained in a
!     cell, the distance between two cells, and a cell's normals.  A
!     &field; should be used whenever geometric or spatial computations
!     are needed, multiple values per index are desired, or a
!     computation involves more than one material.&lt;/para&gt;
! 
! &lt;!-- FIXME: Want firstterm around tensor. --&gt;
! 
!     &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-tensor&quot;&gt;&tensor;&lt;/glossterm&gt;
!     implements a multi-dimensional mathematical tensor.  Since it is a
!     first-class type, it can be used in expressions such as
!     adding two &tensor;s.&lt;/para&gt;
! 
! &lt;!-- FIXME: Want firstterm around matrix. --&gt;
! 
!     &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-matrix&quot;&gt;&matrix;&lt;/glossterm&gt;
!     implements a two-dimensional mathematical matrix.  Since it is a
!     first-class type, it can be used in expressions such as
!     multiplying matrices and assignments to matrices.&lt;/para&gt;
! 
! &lt;!-- FIXME: Want firstterm around vector. --&gt;
! 
!     &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-vector&quot;&gt;&vector;&lt;/glossterm&gt;
!     implements a multi-dimensional mathematical vector, which is an
!     ordered tuple of components.  Since it is a first-class type, it
!     can be used in expressions such as adding two &vector;s and
!     multiplying a &matrix; and a &vector;.&lt;/para&gt;
! 
!     &lt;para&gt;The data of an &array;, &dynamicarray;, or &field; can be
!     viewed using more than one container by taking a view.  A
!     &lt;glossterm
!     linkend=&quot;glossary-view&quot;&gt;&lt;firstterm&gt;view&lt;/firstterm&gt;&lt;/glossterm&gt; of
!     an existing container&nbsp;&container; is a container whose domain
!     is a subset of&nbsp;&container;.  The subset can equal the
!     original domain.  A view acts like a reference in that changing
!     any of the view's values also changes the original container's and
!     vice versa.  While users sometimes explicitly create views, they
!     are perhaps more frequently created as temporaries in expressions.
!     For example, if &lt;varname&gt;A&lt;/varname&gt; is an &array; and
!     &lt;varname&gt;I&lt;/varname&gt; is a domain, &lt;statement&gt;A(I) -
!     A(I-1)&lt;/statement&gt; forms the difference between adjacent
!     values.&lt;/para&gt;
! 
! 
!     &lt;section id=&quot;concepts-containers-choosing&quot;&gt;
!      &lt;title&gt;Choosing a Container&lt;/title&gt;
! 
!      &lt;para&gt;The two most commonly used &pooma; containers are &array;s
!      and &field;s.  &lt;xref
!      linkend=&quot;concepts-containers-choice_table&quot;&gt;&lt;/xref&gt; contains a
!      decision tree describing how to choose an appropriate
!      container.&lt;/para&gt;
! 
!     &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-choice_table&quot;&gt;
!      &lt;title&gt;Choosing a &pooma; Container&lt;/title&gt;
!      &lt;tgroup cols=&quot;2&quot; align=&quot;left&quot;&gt;
!       &lt;tbody&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;If modeling mathematical entries,&lt;/entry&gt;
! 	&lt;entry&gt;use a &vector;, &matrix;, or &tensor;.&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;If indices and values reside in multi-dimensional space
! 	&space;,&lt;/entry&gt;
! 	&lt;entry&gt;use a &field;.&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;If there are multiple values per index,&lt;/entry&gt;
! 	&lt;entry&gt;use a &field;.&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;If there are multiple materials participating in the same computation,&lt;/entry&gt;
! 	&lt;entry&gt;use a &field;.&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;If the domain's size dynamically changes and is one-dimensional,&lt;/entry&gt;
! 	&lt;entry&gt;use a &dynamicarray;.&lt;/entry&gt;
!        &lt;/row&gt;
!        &lt;row&gt;
! 	&lt;entry&gt;Otherwise&lt;/entry&gt;
! 	&lt;entry&gt;use an &array;.&lt;/entry&gt;
!        &lt;/row&gt;
!       &lt;/tbody&gt;
!      &lt;/tgroup&gt;
!     &lt;/table&gt;
! 
!     &lt;/section&gt;&lt;!-- choosing among containers --&gt;
  
  
-     &lt;section id=&quot;concepts-containers-sequential_declarations&quot;&gt;
-      &lt;title&gt;Declaring Sequential Containers&lt;/title&gt;
  
!      &lt;figure float=&quot;1&quot; id=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;
!       &lt;title&gt;Concepts For Declaring Containers&lt;/title&gt;
!       &lt;mediaobject&gt;
!        &lt;imageobject&gt;
! 	&lt;imagedata fileref=&quot;figures/concepts.111&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!        &lt;/imageobject&gt;
!        &lt;textobject&gt;
! 	&lt;phrase&gt;concepts involved in declaring containers&lt;/phrase&gt;
!        &lt;/textobject&gt;
!       &lt;/mediaobject&gt;
!      &lt;/figure&gt;
! 
!      &lt;para&gt;In the previous sections, we introduced the &pooma;
!      containers and described how to choose one appropriate for a
!      given task.  In this section, we describe the concepts involved
!      in declaring them.  Concepts specific to distributed computation
!      are described in the next section.&lt;/para&gt;
! 
!      &lt;para&gt;&lt;xref
!      linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
!      illustrates the containers and the concepts involved in their
!      declarations.  The containers are listed in the top row.  Lines
!      connect these containers to the components necessary for their
!      declarations.  For example, an &array; declaration requires an
!      engine and a layout.  These, in turn, depend on other &pooma;
!      concepts.  Declarations necessary only for distributed, or
!      multiprocessor, computation are surrounded by dashed lines.  You
!      can use these dependences to indicate the concepts needed for a
!      particular container.&lt;/para&gt;
! 
!      &lt;para&gt;An &lt;glossterm
!      linkend=&quot;glossary-engine&quot;&gt;&lt;firstterm&gt;engine&lt;/firstterm&gt;&lt;/glossterm&gt;
!      stores and, if necessary, computes a container's values.  A
!      container has one or more engines.  The separation of a container
!      and its storage permits optimizing a program's space
!      requirements.  For example, a container returning the same value
!      for all indices can use a constant engine, which need only store
!      one value for the entire domain.  A &compressiblebrick; engine
!      reduces its space requirements to a constant whenever all its
!      values are the same.  The separation also permits taking &lt;link
!      linkend=&quot;glossary-view&quot;&gt;view&lt;/link&gt;s of containers without
!      copying storage.&lt;/para&gt;
! 
!      &lt;figure float=&quot;1&quot; id=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;
!       &lt;title&gt;&array; and &field; Mathematical and Computational Concepts&lt;/title&gt;
!       &lt;mediaobject&gt;
!        &lt;imageobject&gt;
! 	&lt;imagedata fileref=&quot;figures/concepts.101&quot; format=&quot;EPS&quot; align=&quot;center&quot;&gt;&lt;/imagedata&gt;
!        &lt;/imageobject&gt;
!        &lt;textobject&gt;
! 	&lt;phrase&gt;maps from indices to values&lt;/phrase&gt;
!        &lt;/textobject&gt;
!       &lt;/mediaobject&gt;
!      &lt;/figure&gt;
! 
!      &lt;para&gt;A &lt;glossterm
!      linkend=&quot;glossary-layout&quot;&gt;&lt;firstterm&gt;layout&lt;/firstterm&gt;&lt;/glossterm&gt;
!      maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; indices to the
!      processors and computer memory used by a container's engines.
!      See &lt;xref
!      linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
!      A computer computes a container's values using a processor and
!      memory.  The layout specifies the processor(s) and memory to use
!      for each particular index.  A container's layout for a
!      uniprocessor implementation consists of its domain, the
!      processor, and its memory.  For a multi-processor implementation,
!      the layout maps portions of the domain to (possibly different)
!      processors and memory.&lt;/para&gt;
! 
!      &lt;para&gt;A &field;'s &lt;glossterm
!      linkend=&quot;glossary-mesh&quot;&gt;&lt;firstterm&gt;mesh&lt;/firstterm&gt;&lt;/glossterm&gt;
!      maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; indices to
!      geometric values in &space; such as distance between cells, edge
!      lengths, and normals to cells.  In other words, it provides a
!      &field;'s spatial extent.  See also &lt;xref
!      linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
!      Different mesh types may support different geometric
!      values.&lt;/para&gt;
! 
!      &lt;para&gt;A mesh's &lt;glossterm
!      linkend=&quot;glossary-corner_position&quot;&gt;&lt;firstterm&gt;corner
!      position&lt;/firstterm&gt;&lt;/glossterm&gt; specifies the &lt;link
!      linkend=&quot;glossary-point&quot;&gt;point&lt;/link&gt; in &space; corresponding to
!      the lower, left corner of its &lt;link
!      linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt;.  Combining this, the
!      domain, and the cell size fully specifies the mesh's map from
!      indices to &space;.&lt;/para&gt;
! 
!      &lt;para&gt;A mesh's &lt;glossterm
!      linkend=&quot;glossary-cell_size&quot;&gt;&lt;firstterm&gt;cell
!      size&lt;/firstterm&gt;&lt;/glossterm&gt; specifies the spatial dimensions of
!      a &field; &lt;link linkend=&quot;glossary-cell&quot;&gt;cell&lt;/link&gt;, e.g., its
!      width, height, and depth, in&nbsp;&space;.  Combining this, the
!      domain, and the corner position fully specifies the mesh's map
!      from indices to &space;.&lt;/para&gt;
! 
!      &lt;para&gt;A &lt;glossterm
!      linkend=&quot;glossary-domain&quot;&gt;&lt;firstterm&gt;domain&lt;/firstterm&gt;&lt;/glossterm&gt;
!      is a set of points on which a container can define values.  An
!      &lt;glossterm
!      linkend=&quot;glossary-interval&quot;&gt;&lt;firstterm&gt;interval&lt;/firstterm&gt;&lt;/glossterm&gt;
!      consists of all integral points between two values.  It is
!      frequently represented using mathematical interval notation [a,b]
!      even though it contains only the integral points, e.g., a, a+1,
!      a+2, &hellip;, b.  The concept is generalized to multiple
!      dimensions by forming tensor product of intervals, i.e., all the
!      integral tuples in an &n;-dimensional space.  For example, the
!      two-dimensional containers in the previous chapter are defined on
!      a two-dimensional domain with the both dimensions' spanning the
!      interval [0,n).  A &lt;glossterm
!      linkend=&quot;glossary-stride&quot;&gt;&lt;firstterm&gt;stride&lt;/firstterm&gt;&lt;/glossterm&gt;
!      is a subset of an interval consisting of regularly-spaced
!      points.  A &lt;glossterm
!      linkend=&quot;glossary-range&quot;&gt;&lt;firstterm&gt;range&lt;/firstterm&gt;&lt;/glossterm&gt;
!      is a subset of an interval formed by the tensor product of strides.
!      A &lt;glossterm
!      linkend=&quot;glossary-region&quot;&gt;&lt;firstterm&gt;region&lt;/firstterm&gt;&lt;/glossterm&gt;
!      represents a continuous &n;-dimensional domain.&lt;/para&gt;
!     &lt;/section&gt;
! 
! 
!     &lt;section id=&quot;concepts-containers-distributed_declarations&quot;&gt;
!      &lt;title&gt;Declaring Distributed Containers&lt;/title&gt;
! 
!      &lt;para&gt;In the previous section, we introduced the concepts
!      important when declaring containers for use on uniprocessor
!      computers.  When using multi-processor computers, we augment
!      these concepts with those for distributed computation.  Reading
!      this section is important only for running the same program on
!      multiple processors.  Many of these concepts were introduced in
!      &lt;xref linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt; and &lt;xref
!      linkend=&quot;tutorial-field_distributed&quot;&gt;&lt;/xref&gt;.  &lt;xref
!      linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
!      illustrates the &pooma; distributed computation model.  In this
!      section, we concentrate on the concepts necessary to declare a
!      distributed container.&lt;/para&gt;
! 
!      &lt;para&gt;As we noted in &lt;xref
!      linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt;, a &pooma;
!      programmer must specify how each container's domain should be
!      distributed among the available processors and memory spaces.
!      Using this information, the Toolkit automatically distributes the
!      data among the available processors and handles any required
!      communication among them.  The three concepts necessary for
!      declaring distributed containers are a partition, a guard layer,
!      and a context mapper tag.&lt;/para&gt;
! 
!      &lt;para&gt;A &lt;glossterm
!      linkend=&quot;glossary-partition&quot;&gt;&lt;firstterm&gt;partition&lt;/firstterm&gt;&lt;/glossterm&gt;
!      specified how to divide a container's domain into distributed
!      pieces.  For example, the partition illustrated in &lt;xref
!      linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
!      would divide a two-dimensional domain into three equally-sized
!      pieces along the x-dimension and two equally-sized pieces along
!      the y-dimension.  Partitions can be independent of the size of
!      container's domain.  The example partition will work on any
!      domain as long as the size of its x-dimension is a multiple of
!      three.  A domain is separated into disjoint &lt;link
!      linkend=&quot;glossary-patch&quot;&gt;patch&lt;/link&gt;es.&lt;/para&gt;
! 
!      &lt;para&gt;A &lt;glossterm
!      linkend=&quot;glossary-guard_layer&quot;&gt;&lt;firstterm&gt;guard
!      layer&lt;/firstterm&gt;&lt;/glossterm&gt; is &lt;quote&gt;extra&lt;/quote&gt; domain
!      surrounding each patch.  This region has read-only values.  An
!      &lt;glossterm
!      linkend=&quot;glossary-external_guard_layer&quot;&gt;&lt;firstterm&gt;external guard
!      layer&lt;/firstterm&gt;&lt;/glossterm&gt; specifies values surrounding the
!      domain.  Its presence eases computation along the domain's edges
!      by permitting the same computations as for more internal
!      computations.  An &lt;glossterm
!      linkend=&quot;glossary-internal_guard_layer&quot;&gt;&lt;firstterm&gt;internal guard
!      layer&lt;/firstterm&gt;&lt;/glossterm&gt; duplicates values from adjacent
!      patches so communication with adjacent patches need not occur
!      during a patch's computation.  The use of guard layers is an
!      optimization; using external guard layers eases programming and
!      using internal guard layers reduces communication among
!      processors.  Their use is not required.&lt;/para&gt;
! 
!      &lt;para&gt;A &lt;glossterm
!      linkend=&quot;glossary-context_mapper&quot;&gt;&lt;firstterm&gt;context
!      mapper&lt;/firstterm&gt;&lt;/glossterm&gt; indicates how a container's
!      patches are mapped to processors and shared memory.  For example,
!      the &distributedtag; indicates that the patches should be
!      distributed among the processors so each patch occurs once in the
!      entire computation.  The &replicatedtag; indicates that the
!      patches should be replicated among the processors so each
!      processing unit has its own copy of all the patches.  While it
!      could be wasteful to have different processors perform the same
!      computation, replicating a container can reduce possibly more
!      expensive communication costs.&lt;/para&gt;
!     &lt;/section&gt;
! 
! 
!     &lt;section&gt;
!      &lt;title&gt;????Computation Syntax????&lt;/title&gt;
! 
!      &lt;para&gt;UNFINISHED&lt;/para&gt;
!     &lt;/section&gt;
! 
! 
!     &lt;section id=&quot;concepts-computation_environment&quot;&gt;
!      &lt;title&gt;Computation Environment&lt;/title&gt;
! 
!      &lt;para&gt;A &pooma; program can execute on a wide variety of
!      computers.  The default &lt;glossterm
!      linkend=&quot;glossary-sequential&quot;&gt;&lt;firstterm&gt;sequential computing
!      environment&lt;/firstterm&gt;&lt;/glossterm&gt; consists of one processor and
!      associated memory, as found on a personal computer.  In contrast,
!      a &lt;glossterm
!      linkend=&quot;glossary-distributed&quot;&gt;&lt;firstterm&gt;distributed computing
!      environment&lt;/firstterm&gt;&lt;/glossterm&gt; may have multiple processors
!      and multiple distributed or shared memories.  For example, some
!      desktop computers have dual processors and shared memory.  A
!      large supercomputer may have thousands of processors, perhaps
!      with groups of eight sharing the same memory.&lt;/para&gt;
! 
!      &lt;para&gt;Using distributed computation requires three things: the
!      programmer must declare how container domains will be
!      distributed, &pooma; must be configured to use a communications
!      library, and the &pooma; executable must be run using the
!      library.  All of these were illustrated in &lt;xref
!      linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt; and &lt;xref
!      linkend=&quot;tutorial-field_distributed&quot;&gt;&lt;/xref&gt;.  &lt;xref
!      linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
!      illustrates the &pooma; distributed computation model.  &lt;xref
!      linkend=&quot;concepts-containers-distributed_declarations&quot;&gt;&lt;/xref&gt;
!      described how to declare containers with distributed domains.
!      Detailed instructions how to configure &pooma; for distributed
!      computation appear in &lt;xref linkend=&quot;installation&quot;&gt;&lt;/xref&gt;.  More
!      detailed instructions how to run distributed &pooma; executables
!      appear in &lt;xref linkend=&quot;parallel&quot;&gt;&lt;/xref&gt;.  Here we present
!      three concepts for distributed computation: context, layout, and
!      a communication library.
! 
!      A &lt;glossterm
!      linkend=&quot;glossary-context&quot;&gt;&lt;firstterm&gt;context&lt;/firstterm&gt;&lt;/glossterm&gt;
!      is a collection of shared memory and processors that can execute
!      a program of a portion of a program.  It can have one or more
!      processors, but all these processors must access the same shared
!      memory.  Usually the computer and its operating system, not the
!      programmer, determine the available contexts.&lt;/para&gt;
  
!      &lt;para&gt;
! HERE&lt;/para&gt;
  
  &lt;!-- HERE --&gt;
-     &lt;/section&gt;
- 
-    &lt;/section&gt;
- 
- &lt;section&gt;
- &lt;title&gt;Extraneous Material&lt;/title&gt;
- 
-    &lt;para&gt;Describe the software application layers similar to
-    &lt;filename&gt;papers/SCPaper-95.html&lt;/filename&gt; and &quot;Short Tour of
-    &pooma;&quot; in &lt;filename&gt;papers/SiamOO98_paper.ps&lt;/filename&gt;.
-    Section&nbsp;2.2, &quot;Why a Framework?,&quot; of
-    &lt;filename&gt;papers/pooma.ps&lt;/filename&gt; argues why a layered approach
-    eases use.  Section&nbsp;3.1, &quot;Framework Layer Description,&quot;
-    describes the five layers.&lt;/para&gt;
  
!    &lt;para&gt;FINISH: Write short glossary entries for each of these.&lt;/para&gt;
! 
!    &lt;para&gt;FINISH: Look through the source code to ensure all main
!    concepts are listed.&lt;/para&gt;
! 
!    &lt;para&gt;Here are (preliminary) &pooma; equations:&lt;/para&gt;
  
!    &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	  orient=&quot;port&quot; pgwide=&quot;0&quot;&gt;
!     &lt;title&gt;&pooma; &lt;quote&gt;Equations&lt;/quote&gt;&lt;/title&gt;
  
!     &lt;tgroup cols=&quot;1&quot; align=&quot;center&quot;&gt;
!      &lt;tbody&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;field = data + materials + centering + layout + mesh&lt;/para&gt;&lt;/entry&gt;
!        &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;map from space to values&lt;/para&gt;&lt;/entry&gt;
!       &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;array = data + layout&lt;/para&gt;&lt;/entry&gt;
!        &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;map from indices to values&lt;/para&gt;&lt;/entry&gt;
!       &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;mesh = layout + origin + spacings&lt;/para&gt;&lt;/entry&gt;
!        &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;distribute domain through physical space&lt;/para&gt;&lt;/entry&gt;
!       &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;layout = domain + partition + context_mapper_tag (distributed/replicated)&lt;/para&gt;&lt;/entry&gt;
!        &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;distribute domain's blocks among processors/contexts&lt;/para&gt;&lt;/entry&gt;
!       &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;partition = blocks + guard layers&lt;/para&gt;&lt;/entry&gt;
!        &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;split domain into blocks&lt;/para&gt;&lt;/entry&gt;
!       &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;domain = newDomain&lt;/para&gt;&lt;/entry&gt;
!        &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;space of permissible indices&lt;/para&gt;&lt;/entry&gt;
!       &lt;/row&gt;
!      &lt;/tbody&gt;
!     &lt;/tgroup&gt;
!    &lt;/table&gt;
  
  
-    &lt;para&gt;FINISH: Following is a first try at describing the &pooma;
-    abstraction layers.  See also paper illustration.&lt;/para&gt;
  
!    &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
! 	  orient=&quot;port&quot; pgwide=&quot;0&quot;&gt;
!     &lt;title&gt;&pooma; Abstraction Layers&lt;/title&gt;
  
!     &lt;tgroup cols=&quot;1&quot; align=&quot;center&quot;&gt;
!      &lt;tbody&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;application program&lt;/para&gt;&lt;/entry&gt;
!       &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;&array; &field; (should have
!        &lt;type&gt;FieldEngine&lt;/type&gt; under it)&lt;/para&gt;&lt;/entry&gt;
!       &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;&engine;&lt;/para&gt;&lt;/entry&gt;
!       &lt;/row&gt;
!       &lt;row&gt;
!        &lt;entry&gt;&lt;para&gt;evaluators&lt;/para&gt;&lt;/entry&gt;
!       &lt;/row&gt;
!      &lt;/tbody&gt;
!     &lt;/tgroup&gt;
!    &lt;/table&gt;
  
-    &lt;para&gt;FINISH: How does parallel execution fit in?&lt;/para&gt;
  
!    &lt;para&gt;FINISH: Should we also name and describe each layer?&lt;/para&gt;
!    &lt;/section&gt;
  
  
!    &lt;section id=&quot;concepts-data_parallel&quot;&gt;
!     &lt;title&gt;Data-Parallel Statements&lt;/title&gt;
  
!     &lt;para&gt;Can we use &quot;An Overview of &pete;&quot; from
      &lt;filename&gt;papers/PETE_DDJ/ddj_article.html&lt;/filename&gt; or is this
      too low-level?&lt;/para&gt;
  
!     &lt;para&gt;Section&nbsp;3.2.1 of &lt;filename&gt;papers/pooma.ps&lt;/filename&gt;
      gives a simple example of data-parallel expression.  It also has a
      paragraph introducing data-parallel operations and selecting
      subsets of domains.  Section&nbsp;3.4 describes the Chained
--- 347,424 ----
  
    &lt;/chapter&gt;
  
  
!   &amp;tutorial-chapter;
  
+   &amp;concepts-chapter;
  
  
!   &lt;chapter id=&quot;sequential&quot;&gt;
!    &lt;title&gt;Writing Sequential Programs&lt;/title&gt;
  
!    &lt;para&gt;QUESTIONS: How do I arrange this section?  What material do I
!    include?  What other books or models can I follow?&lt;/para&gt;
  
  &lt;!-- HERE --&gt;
  
!    &lt;para&gt;&pooma; can reorder computations to permit more efficient
!    computation.  When running a sequential program, reordering may
!    permit omission of unneeded computations.  For example, if only
!    values from a particular field are printed, only computations
!    involving the field and containers dependent on it need to occur.
!    When running a distributed program, reordering may permit
!    computation and communication among processors to overlap.  &pooma;
!    automatically tracks dependences between data-parallel expressions,
!    ensuring correct ordering.  It does not track statements accessing
!    particular &array; and &field; values so the programmer must
!    precede these statements with calls to
!    &lt;function&gt;Pooma::blockAndEvaluate()&lt;/function&gt;.  Each call forces
!    the executable to wait until all computation has completed.  Thus,
!    the desired values are known to be available.  In practice, some
!    calls to &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; may not be
!    necessary, but omitting them requires knowledge of &pooma;'s
!    dependence computations, so the &author; recommends calling
!    &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; before each access to
!    a particular value in an &array; or &field;.  Omitting a necessary
!    call may lead to a race condition.  See &lt;xref
!    linkend=&quot;debugging_profiling-missing_blockandevaluate&quot;&gt;&lt;/xref&gt; for
!    instructions how to diagnose and eliminate these race conditions.&lt;/para&gt;
  
!    &lt;para&gt;UNFINISHED&lt;/para&gt;
  
!    &lt;section id=&quot;sequential-benchmarks&quot;&gt;
!     &lt;title&gt;&benchmark; Programs&lt;/title&gt;
  
+     &lt;para&gt;Define a &benchmark; program vs. an example or an
+     executable.  Provide a short overview of how to run these
+     programs.  Provide an overview of how to write these programs.
+     See &lt;filename
+     class=&quot;headerfile&quot;&gt;src/Utilities/Benchmark.h&lt;/filename&gt;.&lt;/para&gt;
+    &lt;/section&gt;
  
  
!    &lt;section id=&quot;sequential-inform&quot;&gt;
!     &lt;title&gt;Using &lt;type&gt;Inform&lt;/type&gt;s for Output&lt;/title&gt;
  
!     &lt;para&gt;UNFINISHED&lt;/para&gt;
!    &lt;/section&gt;
  
  
!    &lt;section&gt;
!     &lt;title&gt;Miscellaneous&lt;/title&gt;
  
+     &lt;para&gt;Section&nbsp;3, &quot;Domains and Views,&quot; of
+     &lt;filename&gt;papers/iscope98.pdf&lt;/filename&gt; describes five types of
+     domains.&lt;/para&gt;
  
!     &lt;section id=&quot;concepts-data_parallel&quot;&gt;
!      &lt;title&gt;Data-Parallel Statements&lt;/title&gt;
  
!      &lt;para&gt;Can we use &quot;An Overview of &pete;&quot; from
      &lt;filename&gt;papers/PETE_DDJ/ddj_article.html&lt;/filename&gt; or is this
      too low-level?&lt;/para&gt;
  
!      &lt;para&gt;Section&nbsp;3.2.1 of &lt;filename&gt;papers/pooma.ps&lt;/filename&gt;
      gives a simple example of data-parallel expression.  It also has a
      paragraph introducing data-parallel operations and selecting
      subsets of domains.  Section&nbsp;3.4 describes the Chained
*************** HERE&lt;/para&gt;
*** 1013,1019 ****
      &lt;para&gt;From Section&nbsp;4 of
      &lt;filename&gt;papers/SiamOO98_paper.ps&lt;/filename&gt;:&lt;/para&gt;
  
!     &lt;para&gt;This version of &pete; reduces compile time of user codes
      and utilizes compile-time knowledge of expression &domain;s for
      better optimization.  For example, more efficient loops for
      evaluating an expression can be generated if &pete; knows that the
--- 429,435 ----
      &lt;para&gt;From Section&nbsp;4 of
      &lt;filename&gt;papers/SiamOO98_paper.ps&lt;/filename&gt;:&lt;/para&gt;
  
!      &lt;para&gt;This version of &pete; reduces compile time of user codes
      and utilizes compile-time knowledge of expression &domain;s for
      better optimization.  For example, more efficient loops for
      evaluating an expression can be generated if &pete; knows that the
*************** HERE&lt;/para&gt;
*** 1028,1044 ****
      &pete; material.&lt;/para&gt;
     &lt;/section&gt;
  
     &lt;section&gt;
!     &lt;title&gt;Containers&lt;/title&gt;
  
!     &lt;section id=&quot;concepts-containers-array&quot;&gt;
       &lt;title&gt;&array;&lt;/title&gt;
  
       &lt;blockquote&gt;
!       &lt;attribution&gt;Section&nbsp;4 &quot;Future Improvements in
       &pooma;&nbsp;II&quot; of
       &lt;filename&gt;papers/SiamOO98_paper.ps&lt;/filename&gt;&lt;/attribution&gt;
!       &lt;para&gt;
       An &array; can be thought of as a map from one &domain; to
       another.&hellip; &array;s depend only on the interface of
       &domain;s.  Thus, a subset of view of an &array; can be
--- 444,461 ----
      &pete; material.&lt;/para&gt;
     &lt;/section&gt;
  
+ 
     &lt;section&gt;
! 	     &lt;title&gt;Containers&lt;/title&gt;
  
! 	     &lt;section id=&quot;concepts-containers-array&quot;&gt;
       &lt;title&gt;&array;&lt;/title&gt;
  
       &lt;blockquote&gt;
! 	     &lt;attribution&gt;Section&nbsp;4 &quot;Future Improvements in
       &pooma;&nbsp;II&quot; of
       &lt;filename&gt;papers/SiamOO98_paper.ps&lt;/filename&gt;&lt;/attribution&gt;
! 	     &lt;para&gt;
       An &array; can be thought of as a map from one &domain; to
       another.&hellip; &array;s depend only on the interface of
       &domain;s.  Thus, a subset of view of an &array; can be
*************** HERE&lt;/para&gt;
*** 1058,1064 ****
        code. An Array maps a fairly arbitrary input domain to an
        arbitrary range of outputs. When used by itself, an &array;
        object &lt;varname&gt;A&lt;/varname&gt; refers to all of the values in its
!       domain. Element-wise mathematical operations or functions can be
        applied to an array using straightforward notation, like A + B
        or sin(A). Expressions involving Array objects are themselves
        Arrays. The operation A(d), where d is a domain object that
--- 475,481 ----
        code. An Array maps a fairly arbitrary input domain to an
        arbitrary range of outputs. When used by itself, an &array;
        object &lt;varname&gt;A&lt;/varname&gt; refers to all of the values in its
! 				  domain. Element-wise mathematical operations or functions can be
        applied to an array using straightforward notation, like A + B
        or sin(A). Expressions involving Array objects are themselves
        Arrays. The operation A(d), where d is a domain object that
*************** HERE&lt;/para&gt;
*** 1084,1090 ****
        indexed.&lt;/para&gt;
  
       &lt;para&gt;Fortran arrays are dense and the elements are arranged
!       according to column-major conventions. Therefore, X(i1,i2)
        refers to element number i1-1+(i2-1)*numberRowsInA. However, as
        Fig. 1 shows, Fortran-style &quot;Brick&quot; storage is not the only
        storage format of interest to scientific programmers. For
--- 501,507 ----
        indexed.&lt;/para&gt;
  
       &lt;para&gt;Fortran arrays are dense and the elements are arranged
! 		   according to column-major conventions. Therefore, X(i1,i2)
        refers to element number i1-1+(i2-1)*numberRowsInA. However, as
        Fig. 1 shows, Fortran-style &quot;Brick&quot; storage is not the only
        storage format of interest to scientific programmers. For
*************** HERE&lt;/para&gt;
*** 1103,1116 ****
  
       &lt;para&gt;The &pooma; &array; Class Template&lt;/para&gt;
  
!     &lt;para&gt;Next we describe &pooma;'s model of the Array concept, the
       Array class template. The three most important requirements from
       the point of view of overall design are: (1) arbitrary domain,
       (2) arbitrary range, and (3) polymorphic indexing. These express
       themselves in the template parameters for the &pooma; Array
       class. The template
       &lt;programlisting&gt;
!      template &lt;int Dim, class T = double, class EngineTag = Brick&gt;
       class Array;
       &lt;/programlisting&gt;
       is a specification for creating a set of classes all named
--- 520,533 ----
  
       &lt;para&gt;The &pooma; &array; Class Template&lt;/para&gt;
  
!      &lt;para&gt;Next we describe &pooma;'s model of the Array concept, the
       Array class template. The three most important requirements from
       the point of view of overall design are: (1) arbitrary domain,
       (2) arbitrary range, and (3) polymorphic indexing. These express
       themselves in the template parameters for the &pooma; Array
       class. The template
       &lt;programlisting&gt;
! 		      template &lt;int Dim, class T = double, class EngineTag = Brick&gt;
       class Array;
       &lt;/programlisting&gt;
       is a specification for creating a set of classes all named
*************** HERE&lt;/para&gt;
*** 1150,1186 ****
      &lt;section id=&quot;concepts-containers-field&quot;&gt;
       &lt;title&gt;&field;&lt;/title&gt;
  
!      &lt;para&gt;QUESTION: Do we include boundary conditions here?
  
       FINISH: Do we have an example that shows something not possible
       with &array;?&lt;/para&gt;
  
!      &lt;para&gt;Describe and illustrate multi-material and
       multivalue?&lt;/para&gt;
- 
-      &lt;para&gt;ADD: description of meshes and guard layers.&lt;/para&gt;
  
!     &lt;/section&gt;
! 
  
!    &lt;/section&gt;
  
!    &lt;section id=&quot;concepts-engines&quot;&gt;
!     &lt;title&gt;Engines&lt;/title&gt;
  
!     &lt;para&gt;(unformatted) From
      &lt;filename&gt;papers/GenericProgramming_CSE/dubois.html&lt;/filename&gt;:&lt;/para&gt;
  
!     &lt;para&gt;The Engine Concept&lt;/para&gt;
  
!     &lt;para&gt;To implement polymorphic indexing, the Array class defers
      data storage and data lookup to an engine object. The requirements
      that the Array template places on its engine provide the
      definition for the Engine concept. We'll describe these by
      examining a simplified version of the Array template, shown in
      Fig. 2.&lt;/para&gt;
  
!     &lt;para&gt;First, the Array class determines and exports (makes
      Engine_t part of Array's public interface) the type of the engine
      class that it will use:
      &lt;programlisting&gt;
--- 567,601 ----
      &lt;section id=&quot;concepts-containers-field&quot;&gt;
       &lt;title&gt;&field;&lt;/title&gt;
  
! 	     &lt;para&gt;QUESTION: Do we include boundary conditions here?
  
       FINISH: Do we have an example that shows something not possible
       with &array;?&lt;/para&gt;
  
! 	     &lt;para&gt;Describe and illustrate multi-material and
       multivalue?&lt;/para&gt;
  
! 	     &lt;para&gt;ADD: description of meshes and guard layers.&lt;/para&gt;
  
! 	    &lt;/section&gt;
!      &lt;/section&gt;
  
!      &lt;section id=&quot;concepts-engines&quot;&gt;
!       &lt;title&gt;Engines&lt;/title&gt;
  
!       &lt;para&gt;(unformatted) From
      &lt;filename&gt;papers/GenericProgramming_CSE/dubois.html&lt;/filename&gt;:&lt;/para&gt;
  
!       &lt;para&gt;The Engine Concept&lt;/para&gt;
  
!       &lt;para&gt;To implement polymorphic indexing, the Array class defers
      data storage and data lookup to an engine object. The requirements
      that the Array template places on its engine provide the
      definition for the Engine concept. We'll describe these by
      examining a simplified version of the Array template, shown in
      Fig. 2.&lt;/para&gt;
  
!       &lt;para&gt;First, the Array class determines and exports (makes
      Engine_t part of Array's public interface) the type of the engine
      class that it will use:
      &lt;programlisting&gt;
*************** HERE&lt;/para&gt;
*** 1215,1221 ****
      concept: it must provide a version of operator() that takes Dim
      values of type Index_t.&lt;/para&gt;
  
!     &lt;para&gt;Simply passing the indices on to the engine object may seem
      odd. After all, engine(i,j) looks like we're just indexing another
      array. There are several advantages to this extra level of
      indirection. The Array class is as faithful a model of the Array
--- 630,636 ----
      concept: it must provide a version of operator() that takes Dim
      values of type Index_t.&lt;/para&gt;
  
!       &lt;para&gt;Simply passing the indices on to the engine object may seem
      odd. After all, engine(i,j) looks like we're just indexing another
      array. There are several advantages to this extra level of
      indirection. The Array class is as faithful a model of the Array
*************** HERE&lt;/para&gt;
*** 1386,1497 ****
      &lt;/variablelist&gt;
     &lt;/section&gt;
  
- 
-    &lt;section id=&quot;concepts-relations&quot;&gt;
-     &lt;title&gt;Relations&lt;/title&gt;
- 
-     &lt;para&gt;UNFINISHED&lt;/para&gt;
-    &lt;/section&gt;
- 
- 
-    &lt;section id=&quot;concepts-stencils&quot;&gt;
-     &lt;title&gt;Stencils&lt;/title&gt;
- 
-     &lt;para&gt;Section&nbsp;3.5.4, &quot;Stencil Objects,&quot; of
-     &lt;filename&gt;papers/pooma.ps&lt;/filename&gt; provides a few uses of
-     stencils.&lt;/para&gt;
- 
-     &lt;para&gt;Section&nbsp;5, &quot;Performance,&quot; of
-     &lt;filename&gt;papers/iscope98.pdf&lt;/filename&gt; motivates and explains
-     stencils.&lt;/para&gt;
-    &lt;/section&gt;
- 
- 
-    &lt;section id=&quot;concepts-contexts&quot;&gt;
-     &lt;title&gt;Contexts&lt;/title&gt;
- 
-     &lt;blockquote&gt;
-      &lt;attribution&gt;&lt;filename
-      class=&quot;libraryfile&quot;&gt;background.html&lt;/filename&gt;&lt;/attribution&gt;
-      &lt;para&gt;In order to be able to cope with the variations in machine
-      architecture noted above, &pooma;'s distributed execution model
-      is defined in terms of one or more contexts, each of which may
-      host one or more threads. A context is a distinct region of
-      memory in some computer. The threads associated with the context
-      can access data in that memory region and can run on the
-      processors associated with that context. Threads running in
-      different contexts cannot access memory in other contexts.&lt;/para&gt;
- 
-      &lt;para&gt;A single context may include several physical processors,
-      or just one. Conversely, different contexts do not have to be on
-      separate computers&mdash;for example, a 32-node SMP computer could
-      have up to 32 separate contexts. This release of &pooma; only
-      supports a single context for each application, but can use
-      multiple threads in the context on supported platforms. Support
-      for multiple contexts will be added in an upcoming
-      release.&lt;/para&gt;
-     &lt;/blockquote&gt;
-    &lt;/section&gt;
- 
-   &lt;/chapter&gt;
- 
- 
-   &lt;chapter id=&quot;sequential&quot;&gt;
-    &lt;title&gt;Writing Sequential Programs&lt;/title&gt;
- 
-    &lt;para&gt;&pooma; can reorder computations to permit more efficient
-    computation.  When running a sequential program, reordering may
-    permit omission of unneeded computations.  For example, if only
-    values from a particular field are printed, only computations
-    involving the field and containers dependent on it need to occur.
-    When running a distributed program, reordering may permit
-    computation and communication among processors to overlap.  &pooma;
-    automatically tracks dependences between data-parallel expressions,
-    ensuring correct ordering.  It does not track statements accessing
-    particular &array; and &field; values so the programmer must
-    precede these statements with calls to
-    &lt;function&gt;Pooma::blockAndEvaluate()&lt;/function&gt;.  Each call forces
-    the executable to wait until all computation has completed.  Thus,
-    the desired values are known to be available.  In practice, some
-    calls to &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; may not be
-    necessary, but omitting them requires knowledge of &pooma;'s
-    dependence computations, so the &author; recommends calling
-    &lt;function&gt;Pooma::blockAndEvaluate&lt;/function&gt; before each access to
-    a particular value in an &array; or &field;.  Omitting a necessary
-    call may lead to a race condition.  See &lt;xref
-    linkend=&quot;debugging_profiling-missing_blockandevaluate&quot;&gt;&lt;/xref&gt; for
-    instructions how to diagnose and eliminate these race conditions.&lt;/para&gt;
- 
-    &lt;para&gt;Section&nbsp;3, &quot;Domains and Views,&quot; of
-    &lt;filename&gt;papers/iscope98.pdf&lt;/filename&gt; describes five types of
-    domains.&lt;/para&gt;
- 
-    &lt;para&gt;UNFINISHED&lt;/para&gt;
- 
-    &lt;section id=&quot;sequential-benchmarks&quot;&gt;
-     &lt;title&gt;&benchmark; Programs&lt;/title&gt;
- 
-     &lt;para&gt;Define a &benchmark; program vs. an example or an
-     executable.  Provide a short overview of how to run these
-     programs.  Provide an overview of how to write these programs.
-     See &lt;filename
-     class=&quot;headerfile&quot;&gt;src/Utilities/Benchmark.h&lt;/filename&gt;.&lt;/para&gt;
-    &lt;/section&gt;
- 
- 
-    &lt;section id=&quot;sequential-inform&quot;&gt;
-     &lt;title&gt;Using &lt;type&gt;Inform&lt;/type&gt;s for Output&lt;/title&gt;
- 
-     &lt;para&gt;UNFINISHED&lt;/para&gt;
-    &lt;/section&gt;
- 
- 
-    &lt;section&gt;
-     &lt;title&gt;Miscellaneous&lt;/title&gt;
- 
-    &lt;para&gt;Section&nbsp;3, &quot;Domains and Views,&quot; of
-     &lt;filename&gt;papers/iscope98.pdf&lt;/filename&gt; describes five types of
-     domains.&lt;/para&gt;
     &lt;/section&gt;
    &lt;/chapter&gt;
  
--- 801,806 ----
*************** HERE&lt;/para&gt;
*** 3579,3588 ****
     &lt;para&gt;To use multiple processors with &pooma; requires installing
     the &cheetah; messaging library and an underlying messaging library
     such as the Message Passing Interface (&mpi;) Communications
!    Library or the &mm; Shared Memory Library.  In this section, we
!    first describe how to install &mm;.  Read the section only if using
!    &mm;, not &mpi;.  Then we describe how to install &cheetah; and
!    configure &pooma; to use it.&lt;/para&gt;
  
     &lt;section id=&quot;installation-distributed_computing-mm&quot;&gt;
      &lt;title&gt;Obtaining and Installing the &mm; Shared Memory Library&lt;/title&gt;
--- 2888,2897 ----
     &lt;para&gt;To use multiple processors with &pooma; requires installing
     the &cheetah; messaging library and an underlying messaging library
     such as the Message Passing Interface (&mpi;) Communications
!    Library or the &mm; Shared Memory Library.  In the following
!    section, we first describe how to install &mm;.  Read it only if
!    using &mm;, not &mpi;.  Then we describe how to install &cheetah;
!    and configure &pooma; to use it.&lt;/para&gt;
  
     &lt;section id=&quot;installation-distributed_computing-mm&quot;&gt;
      &lt;title&gt;Obtaining and Installing the &mm; Shared Memory Library&lt;/title&gt;
*************** HERE&lt;/para&gt;
*** 3834,3839 ****
--- 3143,3154 ----
     &lt;title&gt;Miscellaneous&lt;/title&gt;
  
     &lt;orderedlist&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;Section&nbsp;5, &quot;Performance,&quot; of
+      &lt;filename&gt;papers/iscope98.pdf&lt;/filename&gt; motivates and explains
+      stencils.&lt;/para&gt;
+     &lt;/listitem&gt;
+ 
      &lt;listitem&gt;
       &lt;para&gt;If there is time, present another example program, e.g., a
       Jacobi solver.&lt;/para&gt;
Index: figures/concepts.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/concepts.mp,v
retrieving revision 1.1
diff -c -p -r1.1 concepts.mp
*** figures/concepts.mp	2001/12/11 20:36:13	1.1
--- figures/concepts.mp	2001/12/13 04:02:07
*************** beginfig(101)
*** 144,150 ****
    boxit.l6(btex \strut \type{Field}: etex);
    boxit.l7(btex \strut $\mbox{index} \mapsto \mbox{value}$ etex);
    boxit.l9(btex \strut \type{Field}: etex);
!   boxit.l10(btex \strut $\mbox{indices} \mapsto \mbox{geometric value}$ etex);
    fixsize(l1,l2,l3,l4,l6,l7,l9,l10);
    
    ypart(l1.c - l2.c) = 0;
--- 144,150 ----
    boxit.l6(btex \strut \type{Field}: etex);
    boxit.l7(btex \strut $\mbox{index} \mapsto \mbox{value}$ etex);
    boxit.l9(btex \strut \type{Field}: etex);
!   boxit.l10(btex \strut $\mbox{indices} \mapsto \mbox{spatial value}$ etex);
    fixsize(l1,l2,l3,l4,l6,l7,l9,l10);
    
    ypart(l1.c - l2.c) = 0;
*************** beginfig(101)
*** 163,169 ****
    % Create and layout the mesh boxes.
    boxit.ia[2](btex indices etex);
    boxit.ea[2](btex mesh etex);
!   boxit.va[2](btex geometric value etex);
    fixsize(ia[2],ea[2],va[2]);
    ia[1].w - ia[2].w = 0.6(ia[0].w - ia[1].w);
    ypart(va[2].w - ea[2].e) = ypart(ea[2].w - ia[2].e) = 0;
--- 163,169 ----
    % Create and layout the mesh boxes.
    boxit.ia[2](btex indices etex);
    boxit.ea[2](btex mesh etex);
!   boxit.va[2](btex spatial value etex);
    fixsize(ia[2],ea[2],va[2]);
    ia[1].w - ia[2].w = 0.6(ia[0].w - ia[1].w);
    ypart(va[2].w - ea[2].e) = ypart(ea[2].w - ia[2].e) = 0;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000871.html">Patch: Fix Typos in Comments
</A></li>
	<LI>Next message: <A HREF="000873.html">Manual Patch: Some Concepts Changes 
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#872">[ date ]</a>
              <a href="thread.html#872">[ thread ]</a>
              <a href="subject.html#872">[ subject ]</a>
              <a href="author.html#872">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
