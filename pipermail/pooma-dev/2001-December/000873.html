<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Manual Patch: Some Concepts Changes 
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%20Patch%3A%20Some%20Concepts%20Changes%20&In-Reply-To=%3C20011213211926.A29012%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000872.html">
   <LINK REL="Next"  HREF="000874.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Manual Patch: Some Concepts Changes </H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Manual%20Patch%3A%20Some%20Concepts%20Changes%20&In-Reply-To=%3C20011213211926.A29012%40codesourcery.com%3E"
       TITLE="Manual Patch: Some Concepts Changes ">oldham at codesourcery.com
       </A><BR>
    <I>Fri Dec 14 05:19:26 UTC 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000872.html">Manual Patch: Finish Concepts Chapter
</A></li>
        <LI>Next message: <A HREF="000874.html">Patch: More Typo Fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#873">[ date ]</a>
              <a href="thread.html#873">[ thread ]</a>
              <a href="subject.html#873">[ subject ]</a>
              <a href="author.html#873">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2001-Dec-13  Jeffrey D. Oldham  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>&gt;

	These changes mainly represent wordsmithing of the concepts
	chapter and some preliminary work on the &quot;Writing Sequential
	Programs&quot; chapter.

	* concepts.xml: Wordsmithing and a little rearrangement.
	* glossary.xml (interval): Improve wording.
	* makefile (manual.dvi): Improve dependence information.
	* manual.xml: Add planning material for the &quot;Writing Sequential
	Programs&quot; chapter.
	* tutorial.xml: Fix an article.
	* figures/concepts.mp: Shrink the figure's horizontal extent.

Applied to	mainline

Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: concepts.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/concepts.xml,v
retrieving revision 1.1
diff -c -p -r1.1 concepts.xml
*** concepts.xml	2001/12/13 04:04:05	1.1
--- concepts.xml	2001/12/14 04:12:54
***************
*** 6,20 ****
  
   &lt;para&gt;In the previous chapter, we presented several different
   implementations of the &amp;doof2d; simulation program.  The
!  implementations illustrate the various containers, computation
!  modes, and computation environments that &pooma; supports.  In this
!  chapter, we describe the concepts associated with each of these
!  three categories.  Specific details needed by programmers are
!  deferred to later chapters.&lt;/para&gt;
  
   &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-table&quot;&gt;
!    &lt;title&gt;&pooma; Implementation Concepts&lt;/title&gt;
     &lt;tgroup cols=&quot;3&quot; align=&quot;center&quot;&gt;
      &lt;thead&gt;
       &lt;row&gt;
--- 6,55 ----
  
   &lt;para&gt;In the previous chapter, we presented several different
   implementations of the &amp;doof2d; simulation program.  The
!  implementations illustrate the various containers, computation modes,
!  and computation environments that &pooma; supports.  In this chapter,
!  we describe the concepts associated with each of these three
!  categories.  Specific details needed for their use are deferred to
!  later chapters.&lt;/para&gt;
  
+  &lt;para&gt;The most important &pooma; concepts can be grouped into three
+  separate categories:
+  &lt;variablelist&gt;
+   &lt;varlistentry&gt;
+     &lt;term&gt;container&lt;/term&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;data structure holding one or more values and addressed
+      by indices&lt;/para&gt;
+     &lt;/listitem&gt;
+    &lt;/varlistentry&gt;
+    &lt;varlistentry&gt;
+     &lt;term&gt;computation modes&lt;/term&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;styles of expressing computations and accesses to container
+      values&lt;/para&gt;
+     &lt;/listitem&gt;
+    &lt;/varlistentry&gt;
+    &lt;varlistentry&gt;
+     &lt;term&gt;computation environment&lt;/term&gt;
+     &lt;listitem&gt;
+      &lt;para&gt;description of resources for computing, e.g., single
+      processor or multi-processor.&lt;/para&gt;
+     &lt;/listitem&gt;
+    &lt;/varlistentry&gt;
+   &lt;/variablelist&gt;
+   See &lt;xref linkend=&quot;concepts-table&quot;&gt;&lt;/xref&gt;.  Many &pooma; programs
+   select one possibility from each column.  For example, &lt;xref
+   linkend=&quot;tutorial-array_stencil-doof2d&quot;&gt;&lt;/xref&gt; used &array;
+   containers and stencils for sequential computation, while &lt;xref
+   linkend=&quot;tutorial-field_distributed-doof2d&quot;&gt;&lt;/xref&gt; used &field;
+   containers and data-parallel statements with distributed
+   computation.  A program may use multiple containers and various
+   computation modes, but the computation environment is either
+   distributed or not.&lt;/para&gt;
+ 
   &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
     orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-table&quot;&gt;
!    &lt;title&gt;&pooma; Concepts&lt;/title&gt;
     &lt;tgroup cols=&quot;3&quot; align=&quot;center&quot;&gt;
      &lt;thead&gt;
       &lt;row&gt;
***************
*** 57,134 ****
      &lt;/tbody&gt;
     &lt;/tgroup&gt;
    &lt;/table&gt;
- 
-  &lt;para&gt;The most important &pooma; concepts can be grouped into three
-  separate categories:
-  &lt;variablelist&gt;
-   &lt;varlistentry&gt;
-     &lt;term&gt;container&lt;/term&gt;
-     &lt;listitem&gt;
-      &lt;para&gt;data structure holding one or more values and addressed
-      by indices&lt;/para&gt;
-     &lt;/listitem&gt;
-    &lt;/varlistentry&gt;
-    &lt;varlistentry&gt;
-     &lt;term&gt;computation modes&lt;/term&gt;
-     &lt;listitem&gt;
-      &lt;para&gt;styles of expressing computations&lt;/para&gt;
-     &lt;/listitem&gt;
-    &lt;/varlistentry&gt;
-    &lt;varlistentry&gt;
-     &lt;term&gt;computation environment&lt;/term&gt;
-     &lt;listitem&gt;
-      &lt;para&gt;description of resources for computing, e.g., single
-      processor or multi-processor&lt;/para&gt;
-     &lt;/listitem&gt;
-    &lt;/varlistentry&gt;
-   &lt;/variablelist&gt;
-   See &lt;xref linkend=&quot;concepts-table&quot;&gt;&lt;/xref&gt;.  Many &pooma; programs
-   select one possibility from each column.  For example, &lt;xref
-   linkend=&quot;tutorial-array_stencil-doof2d&quot;&gt;&lt;/xref&gt; used a &array;
-   container and stencils for sequential computation, while &lt;xref
-   linkend=&quot;tutorial-field_distributed-doof2d&quot;&gt;&lt;/xref&gt; used a &field;
-   container and data-parallel statements with distributed
-   computation.  A program may use multiple containers and various
-   computation modes, but the computation environment either has
-   distributed processors or not.&lt;/para&gt;
  
!  &lt;para&gt;In the rest of this chapter, we explore these three
!  categories.  First, we describe &pooma; containers, illustrating
!  the purposes of each, and explaining the concepts needed to declare
!  them.  Then, we describe the different computation modes and
!  finally distributed computation concepts.&lt;/para&gt;
  
  
   &lt;section id=&quot;concepts-containers&quot;&gt;
    &lt;title&gt;&pooma; Containers&lt;/title&gt;
  
!   &lt;para&gt;Most &pooma; programs use &lt;firstterm&gt;containers&lt;/firstterm&gt;
!   to store groups of values.  &pooma; containers are objects that
!   store other objects.  They control allocation and deallocation of
!   and access to these objects.  They are a generalization of &c;
!   arrays, but &pooma; containers are first-class objects so they can
!   be used directly in expressions.  They are similar to &cc;
!   containers such as &lt;type&gt;vector&lt;/type&gt;, &lt;type&gt;list&lt;/type&gt;, and
!   &lt;type&gt;stack&lt;/type&gt;.  See &lt;xref
    linkend=&quot;concepts-containers-table&quot;&gt;&lt;/xref&gt; for a summary of the
    containers.&lt;/para&gt;
  
!   &lt;para&gt;This chapter describes many concepts, not all of which are
!   needed to begin programming with the &pooma; Toolkit.  Below we
!   introduce the different categories of concepts.  After that, we
!   introduce the different &pooma;'s containers and describe how to
!   choose the appropriate one for a particular task.  &lt;xref
    linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
    indicates which concepts must be understood when declaring a
!   particular container.  All of these concepts are described in
!   &lt;xref
    linkend=&quot;concepts-containers-sequential_declarations&quot;&gt;&lt;/xref&gt; and
    &lt;xref
!   linkend=&quot;concepts-containers-distributed_declarations&quot;&gt;&lt;/xref&gt;.
!   Use this figure to decide which concepts in the former are
!   relevant.  Reading the latter section is necessary only if
!   computing using multiple processors.  The programs in the previous
!   chapter illustrate many of these concepts.&lt;/para&gt;
  
    &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-table&quot;&gt;
--- 92,133 ----
      &lt;/tbody&gt;
     &lt;/tgroup&gt;
    &lt;/table&gt;
  
!  &lt;para&gt;In the rest of this chapter, we explore these three categories.
!  First, we describe &pooma; containers, illustrating the purposes of
!  each, and explaining the concepts needed to declare them.  Then, we
!  describe the different computation modes and distributed computation
!  concepts.&lt;/para&gt;
  
  
   &lt;section id=&quot;concepts-containers&quot;&gt;
    &lt;title&gt;&pooma; Containers&lt;/title&gt;
  
!   &lt;para&gt;Most &pooma; programs use &lt;firstterm&gt;containers&lt;/firstterm&gt; to
!   store groups of values.  &pooma; containers are objects that store
!   other objects such as numbers or vectors.  They control allocation
!   and deallocation of and access to these stored objects.  They are a
!   generalization of &c; arrays, but &pooma; containers are first-class
!   objects so they can be used directly in expressions.  They are
!   similar to &cc; containers such as &lt;type&gt;vector&lt;/type&gt;,
!   &lt;type&gt;list&lt;/type&gt;, and &lt;type&gt;stack&lt;/type&gt;.  See &lt;xref
    linkend=&quot;concepts-containers-table&quot;&gt;&lt;/xref&gt; for a summary of the
    containers.&lt;/para&gt;
  
!   &lt;para&gt;This section describes many concepts, but one need not
!   understand them all to begin programming with the &pooma; Toolkit.
!   First, we introduce the different &pooma;'s containers and describe
!   how to choose an appropriate one for a particular task.  &lt;xref
    linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
    indicates which concepts must be understood when declaring a
!   particular container.  All of these concepts are described in &lt;xref
    linkend=&quot;concepts-containers-sequential_declarations&quot;&gt;&lt;/xref&gt; and
    &lt;xref
!   linkend=&quot;concepts-containers-distributed_declarations&quot;&gt;&lt;/xref&gt;.  Use
!   this figure to decide which concepts in the former are relevant.
!   Reading the latter section is necessary only if computing using
!   multiple processors.  The programs in the previous chapter
!   illustrate many of these concepts.&lt;/para&gt;
  
    &lt;table frame=&quot;none&quot; colsep=&quot;0&quot; rowsep=&quot;0&quot; tocentry=&quot;1&quot;
  	   orient=&quot;port&quot; pgwide=&quot;0&quot; id=&quot;concepts-containers-table&quot;&gt;
***************
*** 175,191 ****
  &lt;!-- FIXME: Want firstterm around array. --&gt;
  
    &lt;para&gt;A &pooma; &lt;glossterm
!   linkend=&quot;glossary-array&quot;&gt;array;&lt;/glossterm&gt;, generalizing a &c;
!   array, maps indices to values.  Given a index or position in an
    &array;'s domain, it returns the associated value, either by
    returning a stored value or by computing it.  The use of indices,
    which are usually ordered tuples, permits constant-time access
!   although computing a particular value may require significant
!   time.  In addition to the functionality provided by &c; arrays,
!   the &array; class automatically handles memory allocation and
!   deallocation, supports a wider variety of assignments, and can be
!   used in expressions.  For example, the addition of two arrays can
!   be assigned to an array and the product of a scalar element and an
    array is permissible.&lt;/para&gt;
  
  &lt;!-- FIXME: Want firstterm around dynamicarray. --&gt;
--- 174,190 ----
  &lt;!-- FIXME: Want firstterm around array. --&gt;
  
    &lt;para&gt;A &pooma; &lt;glossterm
!   linkend=&quot;glossary-array&quot;&gt;&array;&lt;/glossterm&gt; generalizes a &c; array
!   and maps indices to values.  Given an index or position in an
    &array;'s domain, it returns the associated value, either by
    returning a stored value or by computing it.  The use of indices,
    which are usually ordered tuples, permits constant-time access
!   although computing a particular value may require significant time.
!   In addition to the functionality provided by &c; arrays, the &array;
!   class automatically handles memory allocation and deallocation,
!   supports a wider variety of assignments, and can be used in
!   expressions.  For example, the addition of two arrays can be
!   assigned to an array and the product of a scalar element and an
    array is permissible.&lt;/para&gt;
  
  &lt;!-- FIXME: Want firstterm around dynamicarray. --&gt;
***************
*** 200,215 ****
  
    &lt;para&gt;A &pooma; &lt;glossterm&gt;&field;&lt;/glossterm&gt; is an &array; with
    spatial extent.  Each domain consists of &lt;glossterm
!   linkend=&quot;glossary-cell&quot;&gt;&lt;firstterm&gt;cell&lt;/firstterm&gt;&lt;/glossterm&gt;s
!   in one-, two-, or three-dimensional space.  Although indexed
!   similarly to &array;s, each cell may contain multiple values and
!   multiple materials.  A &field;'s &lt;glossterm
    linkend=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossterm&gt; stores its spatial
!   characteristics and can map yield, e.g., a point contained in a
!   cell, the distance between two cells, and a cell's normals.  A
    &field; should be used whenever geometric or spatial computations
!   are needed, multiple values per index are desired, or a
!   computation involves more than one material.&lt;/para&gt;
  
  &lt;!-- FIXME: Want firstterm around tensor. --&gt;
  
--- 199,214 ----
  
    &lt;para&gt;A &pooma; &lt;glossterm&gt;&field;&lt;/glossterm&gt; is an &array; with
    spatial extent.  Each domain consists of &lt;glossterm
!   linkend=&quot;glossary-cell&quot;&gt;&lt;firstterm&gt;cell&lt;/firstterm&gt;&lt;/glossterm&gt;s in
!   one-, two-, or three-dimensional space.  Although indexed similarly
!   to &array;s, each cell may contain multiple values and multiple
!   materials.  A &field;'s &lt;glossterm
    linkend=&quot;glossary-mesh&quot;&gt;mesh&lt;/glossterm&gt; stores its spatial
!   characteristics and can map yield, e.g., the cell at a particular
!   point, the distance between two cells, or a cell's normals.  A
    &field; should be used whenever geometric or spatial computations
!   are needed, multiple values per index are desired, or a computation
!   involves more than one material.&lt;/para&gt;
  
  &lt;!-- FIXME: Want firstterm around tensor. --&gt;
  
***************
*** 222,229 ****
  
    &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-matrix&quot;&gt;&matrix;&lt;/glossterm&gt;
    implements a two-dimensional mathematical matrix.  Since it is a
!   first-class type, it can be used in expressions such as
!   multiplying matrices and assignments to matrices.&lt;/para&gt;
  
  &lt;!-- FIXME: Want firstterm around vector. --&gt;
  
--- 221,228 ----
  
    &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-matrix&quot;&gt;&matrix;&lt;/glossterm&gt;
    implements a two-dimensional mathematical matrix.  Since it is a
!   first-class type, it can be used in expressions such as assignments
!   to matrices and multiplying matrices.&lt;/para&gt;
  
  &lt;!-- FIXME: Want firstterm around vector. --&gt;
  
***************
*** 234,259 ****
    multiplying a &matrix; and a &vector;.&lt;/para&gt;
  
    &lt;para&gt;The data of an &array;, &dynamicarray;, or &field; can be
!   viewed using more than one container by taking a view.  A
!   &lt;glossterm
    linkend=&quot;glossary-view&quot;&gt;&lt;firstterm&gt;view&lt;/firstterm&gt;&lt;/glossterm&gt; of
    an existing container&nbsp;&container; is a container whose domain
!   is a subset of&nbsp;&container;.  The subset can equal the
!   original domain.  A view acts like a reference in that changing
!   any of the view's values also changes the original container's and
!   vice versa.  While users sometimes explicitly create views, they
!   are perhaps more frequently created as temporaries in expressions.
!   For example, if &lt;varname&gt;A&lt;/varname&gt; is an &array; and
!   &lt;varname&gt;I&lt;/varname&gt; is a domain, &lt;statement&gt;A(I) -
!   A(I-1)&lt;/statement&gt; forms the difference between adjacent
!   values.&lt;/para&gt;
  
  
    &lt;section id=&quot;concepts-containers-choosing&quot;&gt;
     &lt;title&gt;Choosing a Container&lt;/title&gt;
  
     &lt;para&gt;The two most commonly used &pooma; containers are &array;s
!    and &field;s.  &lt;xref
     linkend=&quot;concepts-containers-choice_table&quot;&gt;&lt;/xref&gt; contains a
     decision tree describing how to choose an appropriate
     container.&lt;/para&gt;
--- 233,257 ----
    multiplying a &matrix; and a &vector;.&lt;/para&gt;
  
    &lt;para&gt;The data of an &array;, &dynamicarray;, or &field; can be
!   viewed using more than one container by taking a view.  A &lt;glossterm
    linkend=&quot;glossary-view&quot;&gt;&lt;firstterm&gt;view&lt;/firstterm&gt;&lt;/glossterm&gt; of
    an existing container&nbsp;&container; is a container whose domain
!   is a subset of&nbsp;&container;.  The subset can equal the original
!   domain.  A view acts like a reference in that changing any of the
!   view's values also changes the original container's and vice versa.
!   While users sometimes explicitly create views, they are perhaps more
!   frequently created as temporaries in expressions.  For example, if
!   &lt;varname&gt;A&lt;/varname&gt; is an &array; and &lt;varname&gt;I&lt;/varname&gt; is a
!   domain, &lt;statement&gt;A(I) - A(I-1)&lt;/statement&gt; uses two views to form
!   the difference between adjacent values.&lt;/para&gt;
  
  
    &lt;section id=&quot;concepts-containers-choosing&quot;&gt;
     &lt;title&gt;Choosing a Container&lt;/title&gt;
  
     &lt;para&gt;The two most commonly used &pooma; containers are &array;s
!    and &field;s, while &vector;, &matrix;, or &tensor; frequently
!    represent mathematical objects.  &lt;xref
     linkend=&quot;concepts-containers-choice_table&quot;&gt;&lt;/xref&gt; contains a
     decision tree describing how to choose an appropriate
     container.&lt;/para&gt;
***************
*** 298,303 ****
--- 296,307 ----
    &lt;section id=&quot;concepts-containers-sequential_declarations&quot;&gt;
     &lt;title&gt;Declaring Sequential Containers&lt;/title&gt;
  
+    &lt;para&gt;In the previous sections, we introduced the &pooma;
+    containers and described how to choose one appropriate for a
+    given task.  In this section, we describe the concepts involved
+    in declaring them.  Concepts specific to distributed computation
+    are described in the next section.&lt;/para&gt;
+ 
     &lt;figure float=&quot;1&quot; id=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;
      &lt;title&gt;Concepts For Declaring Containers&lt;/title&gt;
      &lt;mediaobject&gt;
***************
*** 310,347 ****
      &lt;/mediaobject&gt;
     &lt;/figure&gt;
  
-    &lt;para&gt;In the previous sections, we introduced the &pooma;
-    containers and described how to choose one appropriate for a
-    given task.  In this section, we describe the concepts involved
-    in declaring them.  Concepts specific to distributed computation
-    are described in the next section.&lt;/para&gt;
- 
     &lt;para&gt;&lt;xref
     linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
     illustrates the containers and the concepts involved in their
     declarations.  The containers are listed in the top row.  Lines
     connect these containers to the components necessary for their
     declarations.  For example, an &array; declaration requires an
!    engine and a layout.  These, in turn, depend on other &pooma;
     concepts.  Declarations necessary only for distributed, or
!    multiprocessor, computation are surrounded by dashed lines.  You
!    can use these dependences to indicate the concepts needed for a
!    particular container.&lt;/para&gt;
  
     &lt;para&gt;An &lt;glossterm
     linkend=&quot;glossary-engine&quot;&gt;&lt;firstterm&gt;engine&lt;/firstterm&gt;&lt;/glossterm&gt;
     stores and, if necessary, computes a container's values.  A
     container has one or more engines.  The separation of a container
!    and its storage permits optimizing a program's space
     requirements.  For example, a container returning the same value
     for all indices can use a constant engine, which need only store
     one value for the entire domain.  A &compressiblebrick; engine
     reduces its space requirements to a constant whenever all its
     values are the same.  The separation also permits taking &lt;link
!    linkend=&quot;glossary-view&quot;&gt;view&lt;/link&gt;s of containers without
!    copying storage.&lt;/para&gt;
  
!    &lt;figure float=&quot;1&quot; id=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;
      &lt;title&gt;&array; and &field; Mathematical and Computational Concepts&lt;/title&gt;
      &lt;mediaobject&gt;
       &lt;imageobject&gt;
--- 314,345 ----
      &lt;/mediaobject&gt;
     &lt;/figure&gt;
  
     &lt;para&gt;&lt;xref
     linkend=&quot;concepts-sequential_containers-declarations-dependences&quot;&gt;&lt;/xref&gt;
     illustrates the containers and the concepts involved in their
     declarations.  The containers are listed in the top row.  Lines
     connect these containers to the components necessary for their
     declarations.  For example, an &array; declaration requires an
!    engine and a layout.  These, in turn, can depend on other &pooma;
     concepts.  Declarations necessary only for distributed, or
!    multiprocessor, computation are surrounded by dashed lines.  These
!    dependences to indicate the concepts needed for a particular
!    container.&lt;/para&gt;
  
     &lt;para&gt;An &lt;glossterm
     linkend=&quot;glossary-engine&quot;&gt;&lt;firstterm&gt;engine&lt;/firstterm&gt;&lt;/glossterm&gt;
     stores and, if necessary, computes a container's values.  A
     container has one or more engines.  The separation of a container
!    from its storage permits optimizing a program's space and time
     requirements.  For example, a container returning the same value
     for all indices can use a constant engine, which need only store
     one value for the entire domain.  A &compressiblebrick; engine
     reduces its space requirements to a constant whenever all its
     values are the same.  The separation also permits taking &lt;link
!    linkend=&quot;glossary-view&quot;&gt;view&lt;/link&gt;s of containers without copying
!    storage.&lt;/para&gt;
  
!    &lt;figure float=&quot;1&quot; pgwide=&quot;1&quot; id=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;
      &lt;title&gt;&array; and &field; Mathematical and Computational Concepts&lt;/title&gt;
      &lt;mediaobject&gt;
       &lt;imageobject&gt;
***************
*** 356,387 ****
     &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-layout&quot;&gt;&lt;firstterm&gt;layout&lt;/firstterm&gt;&lt;/glossterm&gt;
     maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; indices to the
!    processors and computer memory used by a container's engines.
!    See &lt;xref
     linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
!    A computer computes a container's values using a processor and
!    memory.  The layout specifies the processor(s) and memory to use
!    for each particular index.  A container's layout for a
!    uniprocessor implementation consists of its domain, the
!    processor, and its memory.  For a multi-processor implementation,
!    the layout maps portions of the domain to (possibly different)
!    processors and memory.&lt;/para&gt;
  
     &lt;para&gt;A &field;'s &lt;glossterm
     linkend=&quot;glossary-mesh&quot;&gt;&lt;firstterm&gt;mesh&lt;/firstterm&gt;&lt;/glossterm&gt;
     maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; indices to
!    spatial values in &space; such as distance between cells, edge
     lengths, and normals to cells.  In other words, it provides a
     &field;'s spatial extent.  See also &lt;xref
     linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
!    Different mesh types may support different spatial
!    values.&lt;/para&gt;
  
     &lt;para&gt;A mesh's &lt;glossterm
     linkend=&quot;glossary-corner_position&quot;&gt;&lt;firstterm&gt;corner
     position&lt;/firstterm&gt;&lt;/glossterm&gt; specifies the &lt;link
     linkend=&quot;glossary-point&quot;&gt;point&lt;/link&gt; in &space; corresponding to
!    the lower, left corner of its &lt;link
     linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt;.  Combining this, the
     domain, and the cell size fully specifies the mesh's map from
     indices to &space;.&lt;/para&gt;
--- 354,408 ----
     &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-layout&quot;&gt;&lt;firstterm&gt;layout&lt;/firstterm&gt;&lt;/glossterm&gt;
     maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; indices to the
!    processors and computer memory used by a container's engines.  See
!    &lt;xref
     linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
!    A program computes a container's values using a processor and
!    memory.  The layout specifies the processors and memory to use for
!    each particular index.  A container's layout for a uniprocessor
!    implementation consists of its domain, the processor, and its
!    memory.  For a multi-processor implementation, the layout maps
!    portions of the domain to (possibly different) processors and
!    memory.&lt;/para&gt;
  
+    &lt;para&gt;A &lt;glossterm
+    linkend=&quot;glossary-domain&quot;&gt;&lt;firstterm&gt;domain&lt;/firstterm&gt;&lt;/glossterm&gt;
+    is a set of points on which a container can define values.  There
+    are several different types of domains.  An &lt;glossterm
+    linkend=&quot;glossary-interval&quot;&gt;&lt;firstterm&gt;interval&lt;/firstterm&gt;&lt;/glossterm&gt;
+    consists of all integral points between two endpoints.  It is
+    frequently represented using mathematical interval notation [a,b]
+    even though it contains only the integral points, e.g., a, a+1,
+    a+2, &hellip;, b.  The concept is generalized to multiple
+    dimensions by forming tensor product of intervals, i.e., all the
+    integral tuples in an &n;-dimensional space.  For example, the
+    two-dimensional containers in the previous chapter are defined on a
+    two-dimensional domain with the both dimensions' spanning the
+    interval [0,n).  A domain need not contain all integral points
+    between its endpoints.  A &lt;glossterm
+    linkend=&quot;glossary-stride&quot;&gt;&lt;firstterm&gt;stride&lt;/firstterm&gt;&lt;/glossterm&gt;
+    is a subset of an interval consisting of regularly-spaced points.
+    A &lt;glossterm
+    linkend=&quot;glossary-range&quot;&gt;&lt;firstterm&gt;range&lt;/firstterm&gt;&lt;/glossterm&gt;
+    is a subset of an interval formed by the tensor product of strides.
+    A &lt;glossterm
+    linkend=&quot;glossary-region&quot;&gt;&lt;firstterm&gt;region&lt;/firstterm&gt;&lt;/glossterm&gt;
+    represents a continuous &n;-dimensional domain.&lt;/para&gt;
+ 
     &lt;para&gt;A &field;'s &lt;glossterm
     linkend=&quot;glossary-mesh&quot;&gt;&lt;firstterm&gt;mesh&lt;/firstterm&gt;&lt;/glossterm&gt;
     maps &lt;link linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt; indices to
!    spatial values in &space; such as distances between cells, edge
     lengths, and normals to cells.  In other words, it provides a
     &field;'s spatial extent.  See also &lt;xref
     linkend=&quot;concepts-containers-declarations-computational_implementation&quot;&gt;&lt;/xref&gt;.
!    Different mesh types may support different spatial values.&lt;/para&gt;
  
     &lt;para&gt;A mesh's &lt;glossterm
     linkend=&quot;glossary-corner_position&quot;&gt;&lt;firstterm&gt;corner
     position&lt;/firstterm&gt;&lt;/glossterm&gt; specifies the &lt;link
     linkend=&quot;glossary-point&quot;&gt;point&lt;/link&gt; in &space; corresponding to
!    the cell in the lower, left corner of its &lt;link
     linkend=&quot;glossary-domain&quot;&gt;domain&lt;/link&gt;.  Combining this, the
     domain, and the cell size fully specifies the mesh's map from
     indices to &space;.&lt;/para&gt;
***************
*** 393,434 ****
     width, height, and depth, in&nbsp;&space;.  Combining this, the
     domain, and the corner position fully specifies the mesh's map
     from indices to &space;.&lt;/para&gt;
- 
-    &lt;para&gt;A &lt;glossterm
-    linkend=&quot;glossary-domain&quot;&gt;&lt;firstterm&gt;domain&lt;/firstterm&gt;&lt;/glossterm&gt;
-    is a set of points on which a container can define values.  An
-    &lt;glossterm
-    linkend=&quot;glossary-interval&quot;&gt;&lt;firstterm&gt;interval&lt;/firstterm&gt;&lt;/glossterm&gt;
-    consists of all integral points between two values.  It is
-    frequently represented using mathematical interval notation [a,b]
-    even though it contains only the integral points, e.g., a, a+1,
-    a+2, &hellip;, b.  The concept is generalized to multiple
-    dimensions by forming tensor product of intervals, i.e., all the
-    integral tuples in an &n;-dimensional space.  For example, the
-    two-dimensional containers in the previous chapter are defined on
-    a two-dimensional domain with the both dimensions' spanning the
-    interval [0,n).  A &lt;glossterm
-    linkend=&quot;glossary-stride&quot;&gt;&lt;firstterm&gt;stride&lt;/firstterm&gt;&lt;/glossterm&gt;
-    is a subset of an interval consisting of regularly-spaced
-    points.  A &lt;glossterm
-    linkend=&quot;glossary-range&quot;&gt;&lt;firstterm&gt;range&lt;/firstterm&gt;&lt;/glossterm&gt;
-    is a subset of an interval formed by the tensor product of strides.
-    A &lt;glossterm
-    linkend=&quot;glossary-region&quot;&gt;&lt;firstterm&gt;region&lt;/firstterm&gt;&lt;/glossterm&gt;
-    represents a continuous &n;-dimensional domain.&lt;/para&gt;
    &lt;/section&gt;
  
  
    &lt;section id=&quot;concepts-containers-distributed_declarations&quot;&gt;
     &lt;title&gt;Declaring Distributed Containers&lt;/title&gt;
  
!    &lt;para&gt;In the previous section, we introduced the concepts
!    important when declaring containers for use on uniprocessor
!    computers.  When using multi-processor computers, we augment
!    these concepts with those for distributed computation.  Reading
!    this section is important only for running the same program on
!    multiple processors.  Many of these concepts were introduced in
!    &lt;xref linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt; and &lt;xref
     linkend=&quot;tutorial-field_distributed&quot;&gt;&lt;/xref&gt;.  &lt;xref
     linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
     illustrates the &pooma; distributed computation model.  In this
--- 414,432 ----
     width, height, and depth, in&nbsp;&space;.  Combining this, the
     domain, and the corner position fully specifies the mesh's map
     from indices to &space;.&lt;/para&gt;
    &lt;/section&gt;
  
  
    &lt;section id=&quot;concepts-containers-distributed_declarations&quot;&gt;
     &lt;title&gt;Declaring Distributed Containers&lt;/title&gt;
  
!    &lt;para&gt;In the previous section, we introduced the concepts important
!    when declaring containers for use on uniprocessor computers.  When
!    using multi-processor computers, we augment these concepts with
!    those for distributed computation.  Reading this section is
!    important only for running a program on multiple processors.  Many
!    of these concepts were introduced in &lt;xref
!    linkend=&quot;tutorial-array_distributed&quot;&gt;&lt;/xref&gt; and &lt;xref
     linkend=&quot;tutorial-field_distributed&quot;&gt;&lt;/xref&gt;.  &lt;xref
     linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
     illustrates the &pooma; distributed computation model.  In this
***************
*** 447,480 ****
  
     &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-partition&quot;&gt;&lt;firstterm&gt;partition&lt;/firstterm&gt;&lt;/glossterm&gt;
!    specified how to divide a container's domain into distributed
     pieces.  For example, the partition illustrated in &lt;xref
     linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
     would divide a two-dimensional domain into three equally-sized
!    pieces along the x-dimension and two equally-sized pieces along
!    the y-dimension.  Partitions can be independent of the size of
!    container's domain.  The example partition will work on any
!    domain as long as the size of its x-dimension is a multiple of
!    three.  A domain is separated into disjoint &lt;link
     linkend=&quot;glossary-patch&quot;&gt;patch&lt;/link&gt;es.&lt;/para&gt;
  
!    &lt;para&gt;A &lt;glossterm
!    linkend=&quot;glossary-guard_layer&quot;&gt;&lt;firstterm&gt;guard
!    layer&lt;/firstterm&gt;&lt;/glossterm&gt; is &lt;quote&gt;extra&lt;/quote&gt; domain
!    surrounding each patch.  This region has read-only values.  An
!    &lt;glossterm
     linkend=&quot;glossary-external_guard_layer&quot;&gt;&lt;firstterm&gt;external guard
     layer&lt;/firstterm&gt;&lt;/glossterm&gt; specifies values surrounding the
!    domain.  Its presence eases computation along the domain's edges
!    by permitting the same computations as for more internal
     computations.  An &lt;glossterm
     linkend=&quot;glossary-internal_guard_layer&quot;&gt;&lt;firstterm&gt;internal guard
     layer&lt;/firstterm&gt;&lt;/glossterm&gt; duplicates values from adjacent
     patches so communication with adjacent patches need not occur
     during a patch's computation.  The use of guard layers is an
     optimization; using external guard layers eases programming and
!    using internal guard layers reduces communication among
!    processors.  Their use is not required.&lt;/para&gt;
  
     &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-context_mapper&quot;&gt;&lt;firstterm&gt;context
--- 445,476 ----
  
     &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-partition&quot;&gt;&lt;firstterm&gt;partition&lt;/firstterm&gt;&lt;/glossterm&gt;
!    specifies how to divide a container's domain into distributed
     pieces.  For example, the partition illustrated in &lt;xref
     linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
     would divide a two-dimensional domain into three equally-sized
!    pieces along the x-dimension and two equally-sized pieces along the
!    y-dimension.  Partitions can be independent of the size of
!    container's domain.  The example partition will work on any domain
!    as long as the size of its x-dimension is a multiple of three.  A
!    domain is separated into disjoint &lt;link
     linkend=&quot;glossary-patch&quot;&gt;patch&lt;/link&gt;es.&lt;/para&gt;
  
!    &lt;para&gt;A &lt;glossterm linkend=&quot;glossary-guard_layer&quot;&gt;&lt;firstterm&gt;guard
!    layer&lt;/firstterm&gt;&lt;/glossterm&gt; surrounds each patch with read-only
!    values.  An &lt;glossterm
     linkend=&quot;glossary-external_guard_layer&quot;&gt;&lt;firstterm&gt;external guard
     layer&lt;/firstterm&gt;&lt;/glossterm&gt; specifies values surrounding the
!    entire domain.  Its presence eases computation along the domain's
!    edges by permitting the same computations as for more internal
     computations.  An &lt;glossterm
     linkend=&quot;glossary-internal_guard_layer&quot;&gt;&lt;firstterm&gt;internal guard
     layer&lt;/firstterm&gt;&lt;/glossterm&gt; duplicates values from adjacent
     patches so communication with adjacent patches need not occur
     during a patch's computation.  The use of guard layers is an
     optimization; using external guard layers eases programming and
!    using internal guard layers reduces communication among processors.
!    Their use is not required.&lt;/para&gt;
  
     &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-context_mapper&quot;&gt;&lt;firstterm&gt;context
***************
*** 496,512 ****
    &lt;title&gt;Computation Modes&lt;/title&gt;
  
    &lt;para&gt;&pooma; computations can be expressed using a variety of
!   modes.  Most of &pooma; computations involve &array; or &field;
    containers, but how their values are accessed and the associated
!   algorithms using them varies.  Element-wise computation involves
!   explicitly accessing values.  A data-parallel computation uses
!   expressions to represent larger subsets of a container's values.
!   Stencil-based computations write a computation as repeatedly
!   applying a local computation to each element of an array.  A
!   relation among containers establishes a dependency between them so
!   the values of one container are updated whenever any other's
!   values change.  A program may use any or all of these styles,
!   described below.&lt;/para&gt;
  
    &lt;para&gt;&lt;glossterm
    linkend=&quot;glossary-element_wise&quot;&gt;&lt;firstterm&gt;Element-wise&lt;/firstterm&gt;&lt;/glossterm&gt;
--- 492,508 ----
    &lt;title&gt;Computation Modes&lt;/title&gt;
  
    &lt;para&gt;&pooma; computations can be expressed using a variety of
!   modes.  Many &pooma; computations involve &array; or &field;
    containers, but how their values are accessed and the associated
!   algorithms using them varies.  For example, element-wise computation
!   involves explicitly accessing a container's values.  A data-parallel
!   computation uses expressions to represent larger subsets of a
!   container's values.  Stencil-based computations express a
!   computation as repeatedly applying a local computation to each
!   element of an array.  A relation among containers establishes a
!   dependency among them so the values of one container are updated
!   whenever any other's values change.  A program may use any or all of
!   these styles, which are described below.&lt;/para&gt;
  
    &lt;para&gt;&lt;glossterm
    linkend=&quot;glossary-element_wise&quot;&gt;&lt;firstterm&gt;Element-wise&lt;/firstterm&gt;&lt;/glossterm&gt;
***************
*** 515,521 ****
    container&nbsp;&container; might be referenced as
    &lt;statement&gt;&amp;container(3,4)&lt;/statement&gt; or
    &lt;statement&gt;&amp;container(i,j+1)&lt;/statement&gt;.  This is the usual
!   notation for languages without objects such as &c;.&lt;/para&gt;
  
    &lt;para&gt;&lt;glossterm
    linkend=&quot;glossary-data_parallel&quot;&gt;&lt;firstterm&gt;Data-parallel&lt;/firstterm&gt;&lt;/glossterm&gt;
--- 511,517 ----
    container&nbsp;&container; might be referenced as
    &lt;statement&gt;&amp;container(3,4)&lt;/statement&gt; or
    &lt;statement&gt;&amp;container(i,j+1)&lt;/statement&gt;.  This is the usual
!   notation for non-object-oriented languages such as &c;.&lt;/para&gt;
  
    &lt;para&gt;&lt;glossterm
    linkend=&quot;glossary-data_parallel&quot;&gt;&lt;firstterm&gt;Data-parallel&lt;/firstterm&gt;&lt;/glossterm&gt;
***************
*** 523,529 ****
    values.  For example, in &lt;xref
    linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;,
    &lt;statement&gt;a(I,J)&lt;/statement&gt; represents the subset of &array;
!   &lt;varname&gt;a&lt;/varname&gt;'s values with coordinates in the domain
    specified by the one-dimensional &interval;s &lt;varname&gt;I&lt;/varname&gt;
    and &lt;varname&gt;J&lt;/varname&gt;.  Using data-parallel expressions
    frequently eliminates the need for writing explicit loops in
--- 519,525 ----
    values.  For example, in &lt;xref
    linkend=&quot;tutorial-array_parallel-doof2d&quot;&gt;&lt;/xref&gt;,
    &lt;statement&gt;a(I,J)&lt;/statement&gt; represents the subset of &array;
!   &lt;varname&gt;a&lt;/varname&gt;'s values having coordinates in the domain
    specified by the one-dimensional &interval;s &lt;varname&gt;I&lt;/varname&gt;
    and &lt;varname&gt;J&lt;/varname&gt;.  Using data-parallel expressions
    frequently eliminates the need for writing explicit loops in
***************
*** 532,555 ****
    &lt;para&gt;A &lt;glossterm
    linkend=&quot;glossary-stencil&quot;&gt;&lt;firstterm&gt;stencil&lt;/firstterm&gt;&lt;/glossterm&gt;
    computes a container's value using neighboring data values.  Each
!   stencil consists of an indication of which neighboring values to
    read and a function using those values.  For example, an averaging
!   stencil may access all neighbors, averaging them.  In &pooma;, we
!   represent a stencil using a function object having functions
!   indicating which neighboring values are used.  Stencil
!   computations are frequently used in solving partial differential
!   equations, image processing, and geometric modeling.&lt;/para&gt;
  
    &lt;para&gt;A &lt;glossterm
    linkend=&quot;glossary-relation&quot;&gt;&lt;firstterm&gt;relation&lt;/firstterm&gt;&lt;/glossterm&gt;
!   is a dependence among containers so the dependent container's
!   values are updated when its values are needed and any of its
!   related containers' values have changed.  A relation is specified
!   by a dependent container, independent containers, and a function
    computing the dependent container's values using the independent
    containers' values.  To avoid excess computation, the dependent
!   container's values are computed only when needed, e.g., for
!   printing or for computing the values of another dependent
    container.  Thus, this computation is sometimes called &lt;quote&gt;lazy
    evaluation&lt;/quote&gt;.&lt;/para&gt;
   &lt;/section&gt;
--- 528,552 ----
    &lt;para&gt;A &lt;glossterm
    linkend=&quot;glossary-stencil&quot;&gt;&lt;firstterm&gt;stencil&lt;/firstterm&gt;&lt;/glossterm&gt;
    computes a container's value using neighboring data values.  Each
!   stencil consists of a specification of which neighboring values to
    read and a function using those values.  For example, an averaging
!   stencil may access all its adjacent neighbors, averaging them.  In
!   &pooma;, we represent a stencil using a function object with
!   additional functions indicating which neighboring values are used.
!   Stencil computations are frequently used in solving partial
!   differential equations, image processing, and geometric
!   modeling.&lt;/para&gt;
  
    &lt;para&gt;A &lt;glossterm
    linkend=&quot;glossary-relation&quot;&gt;&lt;firstterm&gt;relation&lt;/firstterm&gt;&lt;/glossterm&gt;
!   is a dependence among containers such the dependent container's
!   values are updated when its values are needed and any of its related
!   containers' values have changed.  A relation is specified by a
!   dependent container, independent containers, and a function
    computing the dependent container's values using the independent
    containers' values.  To avoid excess computation, the dependent
!   container's values are computed only when needed, e.g., for printing
!   the container or for computing the values of another dependent
    container.  Thus, this computation is sometimes called &lt;quote&gt;lazy
    evaluation&lt;/quote&gt;.&lt;/para&gt;
   &lt;/section&gt;
***************
*** 558,589 ****
   &lt;section id=&quot;concepts-computation_environment&quot;&gt;
    &lt;title&gt;Computation Environment&lt;/title&gt;
  
!   &lt;para&gt;A &pooma; program can execute on a wide variety of
!    computers.  The default &lt;glossterm
     linkend=&quot;glossary-sequential&quot;&gt;&lt;firstterm&gt;sequential computing
     environment&lt;/firstterm&gt;&lt;/glossterm&gt; consists of one processor and
!    associated memory, as found on a personal computer.  In contrast,
!    a &lt;glossterm
     linkend=&quot;glossary-distributed&quot;&gt;&lt;firstterm&gt;distributed computing
     environment&lt;/firstterm&gt;&lt;/glossterm&gt; may have multiple processors
     and multiple distributed or shared memories.  For example, some
     desktop computers have dual processors and shared memory, while a
!    large supercomputer may have thousands of processors, perhaps
!    with groups of eight sharing the same memory.&lt;/para&gt;
  
    &lt;para&gt;Using distributed computation requires three things:
     &lt;orderedlist&gt;
      &lt;listitem&gt;
!      &lt;para&gt;the programmer must declare how container domains will
!       be distributed,&lt;/para&gt;
      &lt;/listitem&gt;
      &lt;listitem&gt;
       &lt;para&gt;&pooma; must be configured to use a communications
!       library, and &lt;/para&gt;
       &lt;/listitem&gt;
       &lt;listitem&gt;
! 		  &lt;para&gt;the &pooma; executable must be run using the
! 	library.&lt;/para&gt;
      &lt;/listitem&gt;
     &lt;/orderedlist&gt;
     All of these were illustrated in &lt;xref
--- 555,585 ----
   &lt;section id=&quot;concepts-computation_environment&quot;&gt;
    &lt;title&gt;Computation Environment&lt;/title&gt;
  
!   &lt;para&gt;A &pooma; program can execute on a wide variety of computers.
!    The default &lt;glossterm
     linkend=&quot;glossary-sequential&quot;&gt;&lt;firstterm&gt;sequential computing
     environment&lt;/firstterm&gt;&lt;/glossterm&gt; consists of one processor and
!    its associated memory, as found on a personal computer.  In
!    contrast, a &lt;glossterm
     linkend=&quot;glossary-distributed&quot;&gt;&lt;firstterm&gt;distributed computing
     environment&lt;/firstterm&gt;&lt;/glossterm&gt; may have multiple processors
     and multiple distributed or shared memories.  For example, some
     desktop computers have dual processors and shared memory, while a
!    large supercomputer may have thousands of processors, perhaps with
!    groups of eight sharing the same memory.&lt;/para&gt;
  
    &lt;para&gt;Using distributed computation requires three things:
     &lt;orderedlist&gt;
      &lt;listitem&gt;
!      &lt;para&gt;The program must declare how container domains will
!       be distributed.&lt;/para&gt;
      &lt;/listitem&gt;
      &lt;listitem&gt;
       &lt;para&gt;&pooma; must be configured to use a communications
!       library.&lt;/para&gt;
       &lt;/listitem&gt;
       &lt;listitem&gt;
!       &lt;para&gt;The &pooma; executable must be run using the library.&lt;/para&gt;
      &lt;/listitem&gt;
     &lt;/orderedlist&gt;
     All of these were illustrated in &lt;xref
***************
*** 592,604 ****
     linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
     illustrates the &pooma; distributed computation model.  &lt;xref
     linkend=&quot;concepts-containers-distributed_declarations&quot;&gt;&lt;/xref&gt;
!    described how to declare containers with distributed domains.
!    Detailed instructions how to configure &pooma; for distributed
!    computation appear in &lt;xref linkend=&quot;installation&quot;&gt;&lt;/xref&gt;.
!    Detailed instructions how to run distributed &pooma; executables
!    appear in &lt;xref linkend=&quot;parallel&quot;&gt;&lt;/xref&gt;.  Here we present
!    three concepts for distributed computation: patches, context, and
!    a communication library.&lt;/para&gt;
  
    &lt;para&gt;A partition divides a container's domain into disjoint
     &lt;glossterm
--- 588,596 ----
     linkend=&quot;tutorial-array_distributed-doof2d-distributed_model&quot;&gt;&lt;/xref&gt;
     illustrates the &pooma; distributed computation model.  &lt;xref
     linkend=&quot;concepts-containers-distributed_declarations&quot;&gt;&lt;/xref&gt;
!    described how to declare containers with distributed domains.  Here
!    we present three concepts for distributed computation: patches,
!    context, and a communication library.&lt;/para&gt;
  
    &lt;para&gt;A partition divides a container's domain into disjoint
     &lt;glossterm
***************
*** 611,618 ****
  
    &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-context&quot;&gt;&lt;firstterm&gt;context&lt;/firstterm&gt;&lt;/glossterm&gt;
!    is a collection of shared memory and processors that can execute
!    a program of a portion of a program.  It can have one or more
     processors, but all these processors must access the same shared
     memory.  Usually the computer and its operating system, not the
     programmer, determine the available contexts.&lt;/para&gt;
--- 603,610 ----
  
    &lt;para&gt;A &lt;glossterm
     linkend=&quot;glossary-context&quot;&gt;&lt;firstterm&gt;context&lt;/firstterm&gt;&lt;/glossterm&gt;
!    is a collection of shared memory and processors that can execute a
!    program or a portion of a program.  It can have one or more
     processors, but all these processors must access the same shared
     memory.  Usually the computer and its operating system, not the
     programmer, determine the available contexts.&lt;/para&gt;
***************
*** 625,630 ****
     user.  &pooma; works with the Message Passing Interface (&mpi;)
     Communications Library (FIXME: xref linkend=&quot;mpi99&quot;, &lt;ulink
     url=&quot;<A HREF="http://www-unix.mcs.anl.gov/mpi/">http://www-unix.mcs.anl.gov/mpi/</A>&quot;&gt;&lt;/ulink&gt;) and the &mm;
!    Shared Memory Library.&lt;/para&gt;
    &lt;/section&gt;
  &lt;/chapter&gt;
--- 617,623 ----
     user.  &pooma; works with the Message Passing Interface (&mpi;)
     Communications Library (FIXME: xref linkend=&quot;mpi99&quot;, &lt;ulink
     url=&quot;<A HREF="http://www-unix.mcs.anl.gov/mpi/">http://www-unix.mcs.anl.gov/mpi/</A>&quot;&gt;&lt;/ulink&gt;) and the &mm;
!    Shared Memory Library.  See &lt;xref
!    linkend=&quot;installation-distributed_computing&quot;&gt;&lt;/xref&gt; for details.&lt;/para&gt;
    &lt;/section&gt;
  &lt;/chapter&gt;
Index: glossary.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/glossary.xml,v
retrieving revision 1.2
diff -c -p -r1.2 glossary.xml
*** glossary.xml	2001/12/13 04:04:05	1.2
--- glossary.xml	2001/12/14 04:12:54
***************
*** 341,347 ****
    &lt;glossentry id=&quot;glossary-interval&quot;&gt;
     &lt;glossterm&gt;interval&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a set of integral points between two values.  This domain
      is frequently represented using mathematical interval notation
      [a,b] even though it contains only the integral points, e.g., a,
      a+1, a+2, &hellip;, b.  It is also generalized to the tensor
--- 341,347 ----
    &lt;glossentry id=&quot;glossary-interval&quot;&gt;
     &lt;glossterm&gt;interval&lt;/glossterm&gt;
     &lt;glossdef&gt;
!     &lt;para&gt;a set of integral points between two endpoints.  This domain
      is frequently represented using mathematical interval notation
      [a,b] even though it contains only the integral points, e.g., a,
      a+1, a+2, &hellip;, b.  It is also generalized to the tensor
Index: makefile
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/makefile,v
retrieving revision 1.2
diff -c -p -r1.2 makefile
*** makefile	2001/12/11 20:36:13	1.2
--- makefile	2001/12/14 04:12:54
*************** CXXFLAGS= -g -Wall -pedantic -W -Wstrict
*** 25,30 ****
--- 25,32 ----
  
  all: manual.ps
  
+ manual.dvi: manual.xml concepts.xml tutorial.xml
+ 
  %.all:	%.ps %.pdf %.html
  	chmod 644 $*.ps $*.pdf
  	mv $*.ps $*.pdf $*
Index: manual.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/manual.xml,v
retrieving revision 1.2
diff -c -p -r1.2 manual.xml
*** manual.xml	2001/12/13 04:04:05	1.2
--- manual.xml	2001/12/14 04:12:57
***************
*** 356,365 ****
    &lt;chapter id=&quot;sequential&quot;&gt;
     &lt;title&gt;Writing Sequential Programs&lt;/title&gt;
  
!    &lt;para&gt;QUESTIONS: How do I arrange this section?  What material do I
!    include?  What other books or models can I follow?&lt;/para&gt;
  
  &lt;!-- HERE --&gt;
  
     &lt;para&gt;&pooma; can reorder computations to permit more efficient
     computation.  When running a sequential program, reordering may
--- 356,529 ----
    &lt;chapter id=&quot;sequential&quot;&gt;
     &lt;title&gt;Writing Sequential Programs&lt;/title&gt;
  
!    &lt;para&gt;Proposed order.  Basically follow the order in the proposed
!    reference section.
!     &lt;orderedlist&gt;
!      &lt;listitem&gt;&lt;para&gt;starting, stopping&lt;/para&gt;&lt;/listitem&gt;
!      &lt;listitem&gt;&lt;para&gt;&array;&lt;/para&gt;&lt;/listitem&gt;
!      &lt;listitem&gt;&lt;para&gt;&dynamicarray;&lt;/para&gt;&lt;/listitem&gt;
!      &lt;listitem&gt;&lt;para&gt;&field;&lt;/para&gt;&lt;/listitem&gt;
!      &lt;listitem&gt;&lt;para&gt;&vector;&lt;/para&gt;&lt;/listitem&gt;
!      &lt;listitem&gt;&lt;para&gt;&matrix;&lt;/para&gt;&lt;/listitem&gt;
!      &lt;listitem&gt;&lt;para&gt;&tensor;&lt;/para&gt;&lt;/listitem&gt;
!      &lt;listitem&gt;&lt;para&gt;engine&lt;/para&gt;&lt;/listitem&gt;
!      &lt;listitem&gt;&lt;para&gt;domain&lt;/para&gt;&lt;/listitem&gt;
!      &lt;listitem&gt;&lt;para&gt;correctness, e.g., &lt;function&gt;PAssert&lt;/function&gt;&lt;/para&gt;&lt;/listitem&gt;
!      &lt;listitem&gt;&lt;para&gt;&pooma; command-line options&lt;/para&gt;&lt;/listitem&gt;
!     &lt;/orderedlist&gt;
!     Include views of containers in the appropriate sections.&lt;/para&gt;
  
  &lt;!-- HERE --&gt;
+ 
+    &lt;para&gt;&lt;emphasis&gt;&c;: A Reference Manual&lt;/emphasis&gt; uses this
+    structure for &c; libraries:
+     &lt;orderedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;function declarations, separated by rules from rest of text&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;text explanation&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;table of structure members if appropriate&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;example&lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/orderedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;&lt;emphasis&gt;STL Tutorial and Reference Guide&lt;/emphasis&gt;, second
+    edition, uses this structure for STL functions:
+     &lt;orderedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;text description with declaration mixed in&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;example program mixed into text.  It is an entire program,
+       not a program fragment.&lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/orderedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;A tutorial chapter for containers has
+     &lt;orderedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;explanation of template types&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;bulleted list of container types&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;example constructors&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;example programs&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;member and related functions with example programs&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;list of accessors and relation functions&lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/orderedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;The reference chapter for containers has
+     &lt;orderedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;a section listing common members and types for all containers&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;a section listing common member functions for all containers&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;requirements for various container specialties&lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/orderedlist&gt;
+     The section describing &lt;type&gt;vector&lt;/type&gt;s contains
+     &lt;orderedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;files (header files)&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;class declaration&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;description&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;type definitions&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;constructors, destructors, and related functions&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;comparison operators&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;element access member functions&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;insert and erase member functions&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;notes&lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/orderedlist&gt;
+    &lt;/para&gt;
+ 
+    &lt;para&gt;Josuttis's &lt;emphasis&gt;The &cc; Standard Library: A Tutorial
+    and Reference&lt;/emphasis&gt; uses this structure for its STL container
+    chapter:
+     &lt;orderedlist&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;short introduction&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;common container abilities&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;common container operations (with table)&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;vector abilities&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;vector operations:
+        &lt;orderedlist&gt;
+ 	&lt;listitem&gt;
+ 	 &lt;para&gt;create, copy, and destroy operations (mostly table)&lt;/para&gt;
+ 	&lt;/listitem&gt;
+ 	&lt;listitem&gt;
+ 	 &lt;para&gt;nonmodifying operations (mostly table)&lt;/para&gt;
+ 	&lt;/listitem&gt;
+ 	&lt;listitem&gt;
+ 	 &lt;para&gt;assignments (mostly table)&lt;/para&gt;
+ 	&lt;/listitem&gt;
+ 	&lt;listitem&gt;
+ 	 &lt;para&gt;element access (mostly table)&lt;/para&gt;
+ 	&lt;/listitem&gt;
+ 	&lt;listitem&gt;
+ 	 &lt;para&gt;iterator functions (mostly table)&lt;/para&gt;
+ 	&lt;/listitem&gt;
+ 	&lt;listitem&gt;
+ 	 &lt;para&gt;inserting and removing elements (mostly table)&lt;/para&gt;
+ 	&lt;/listitem&gt;
+        &lt;/orderedlist&gt;
+       &lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;using vectors as ordinary arrays&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;exception handling&lt;/para&gt;
+      &lt;/listitem&gt;
+      &lt;listitem&gt;
+       &lt;para&gt;example program&lt;/para&gt;
+      &lt;/listitem&gt;
+     &lt;/orderedlist&gt;
+    &lt;/para&gt;
  
     &lt;para&gt;&pooma; can reorder computations to permit more efficient
     computation.  When running a sequential program, reordering may
Index: tutorial.xml
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/tutorial.xml,v
retrieving revision 1.1
diff -c -p -r1.1 tutorial.xml
*** tutorial.xml	2001/12/11 20:36:13	1.1
--- tutorial.xml	2001/12/14 04:12:58
***************
*** 518,524 ****
   &lt;section id=&quot;tutorial-array_stencil&quot;&gt;
    &lt;title&gt;Stencil &array; Implementation&lt;/title&gt;
  
!   &lt;para&gt;Many computations are local, computing a &array;'s value by
    using close-by &array; values.  Encapsulating this computation in
    a stencil can yield faster code because the compiler can determine
    all accesses come from the same array.  Each stencil consists of a
--- 518,524 ----
   &lt;section id=&quot;tutorial-array_stencil&quot;&gt;
    &lt;title&gt;Stencil &array; Implementation&lt;/title&gt;
  
!   &lt;para&gt;Many computations are local, computing an &array;'s value by
    using close-by &array; values.  Encapsulating this computation in
    a stencil can yield faster code because the compiler can determine
    all accesses come from the same array.  Each stencil consists of a
Index: figures/concepts.mp
===================================================================
RCS file: /home/pooma/Repository/r2/docs/manual/figures/concepts.mp,v
retrieving revision 1.2
diff -c -p -r1.2 concepts.mp
*** figures/concepts.mp	2001/12/13 04:04:05	1.2
--- figures/concepts.mp	2001/12/14 04:12:58
*************** endfig;
*** 116,122 ****
  
  %% Comparisons Between Mathematical Concept And Computational Implementation of Arrays and Fields
  beginfig(101)
!   numeric unit; unit = 0.9cm;
    numeric vertSpace; vertSpace = 2.6unit;   % vertical space between sections
    numeric horizSpace; horizSpace = 8unit; % horizontal space between sections
    
--- 116,122 ----
  
  %% Comparisons Between Mathematical Concept And Computational Implementation of Arrays and Fields
  beginfig(101)
!   numeric unit; unit = 0.8cm;
    numeric vertSpace; vertSpace = 2.6unit;   % vertical space between sections
    numeric horizSpace; horizSpace = 8unit; % horizontal space between sections
    
*************** beginfig(101)
*** 137,144 ****
    endfor
  
    % Create and layout text boxes.
!   boxit.l1(btex \strut mathematical concept etex);
!   boxit.l2(btex \strut computational implementation etex);
    boxit.l3(btex \strut \type{Array}: etex);
    boxit.l4(btex \strut $\mbox{index} \mapsto \mbox{value}$ etex);
    boxit.l6(btex \strut \type{Field}: etex);
--- 137,144 ----
    endfor
  
    % Create and layout text boxes.
!   boxit.l1(btex \strut \underline{mathematical concept} etex);
!   boxit.l2(btex \strut \underline{computational implementation} etex);
    boxit.l3(btex \strut \type{Array}: etex);
    boxit.l4(btex \strut $\mbox{index} \mapsto \mbox{value}$ etex);
    boxit.l6(btex \strut \type{Field}: etex);
*************** beginfig(101)
*** 152,158 ****
    l1.w - l3.w = l4.w - l7.w = (0,vertSpace);
    l4.w - l3.e = l7.nw - l6.ne = (0,0);
    for t = 0 upto 1:
!     xpart(ia[t].w - l[3+3t].e) = 0.65horizSpace;
      ypart(ia[t].w - l[3+3t].c) = 0;
    endfor
    xpart(l10.w - l7.w) = 0;
--- 152,158 ----
    l1.w - l3.w = l4.w - l7.w = (0,vertSpace);
    l4.w - l3.e = l7.nw - l6.ne = (0,0);
    for t = 0 upto 1:
!     xpart(ia[t].w - l[3+3t].e) = 0.6horizSpace;
      ypart(ia[t].w - l[3+3t].c) = 0;
    endfor
    xpart(l10.w - l7.w) = 0;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000872.html">Manual Patch: Finish Concepts Chapter
</A></li>
	<LI>Next message: <A HREF="000874.html">Patch: More Typo Fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#873">[ date ]</a>
              <a href="thread.html#873">[ thread ]</a>
              <a href="subject.html#873">[ subject ]</a>
              <a href="author.html#873">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
