<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] Move print() methods ool
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20%5BPATCH%5D%20Move%20print%28%29%20methods%20ool&In-Reply-To=%3CPine.LNX.4.58.0312032152240.530%40goofy%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001395.html">
   <LINK REL="Next"  HREF="001393.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] Move print() methods ool</H1>
    <B>Richard Guenther</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20%5BPATCH%5D%20Move%20print%28%29%20methods%20ool&In-Reply-To=%3CPine.LNX.4.58.0312032152240.530%40goofy%3E"
       TITLE="[PATCH] Move print() methods ool">rguenth at tat.physik.uni-tuebingen.de
       </A><BR>
    <I>Wed Dec  3 20:53:42 UTC 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="001395.html">[PATCH] Add missing methods to DomainLayout
</A></li>
        <LI>Next message: <A HREF="001393.html">[PATCH] Obvious stuff
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1392">[ date ]</a>
              <a href="thread.html#1392">[ thread ]</a>
              <a href="subject.html#1392">[ subject ]</a>
              <a href="author.html#1392">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi!

The following patch moves print() methods out of the class bodies of
GridLayout and UniformGridLayout. It also moves out of line code to the
appropriate .cpp file instead of cluttering the header.

Ok?

Richard.

Index: GridLayout.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Layout/GridLayout.cpp,v
retrieving revision 1.89
diff -u -u -r1.89 GridLayout.cpp
--- GridLayout.cpp	11 Mar 2003 21:30:44 -0000	1.89
+++ GridLayout.cpp	3 Dec 2003 20:45:42 -0000
@@ -97,6 +97,13 @@
 }

 template&lt;int Dim&gt;
+GridLayoutData&lt;Dim&gt;::~GridLayoutData()
+{
+  for (typename List_t::iterator a = this-&gt;all_m.begin(); a != this-&gt;all_m.end(); ++a)
+    delete (*a);
+}
+
+template&lt;int Dim&gt;
 template &lt;class Partitioner&gt;
 inline void GridLayoutData&lt;Dim&gt;::initialize(const Grid&lt;Dim&gt; &amp;gdom,
 		       const Partitioner &amp;gpar,
@@ -1127,6 +1134,33 @@
   return count;
 }

+template&lt;int Dim&gt;
+template&lt;class Out&gt;
+void GridLayoutData&lt;Dim&gt;::print(Out &amp; ostr)
+{
+  int i;
+  ostr &lt;&lt; &quot; hasInternalGuards_m, hasExternalGuards_m &quot;
+       &lt;&lt; this-&gt;hasInternalGuards_m &lt;&lt; ' ' &lt;&lt; this-&gt;hasExternalGuards_m
+       &lt;&lt; &quot;\n internalGuards_m &quot;;
+  for (i=0; i&lt;Dim; ++i)
+    ostr &lt;&lt; this-&gt;internalGuards_m.upper(i) &lt;&lt; '-'
+	 &lt;&lt; this-&gt;internalGuards_m.lower(i) &lt;&lt; ' ';
+  ostr &lt;&lt; &quot;\n externalGuards_m &quot;;
+  for (i=0; i&lt;Dim; ++i)
+    ostr &lt;&lt; this-&gt;externalGuards_m.upper(i) &lt;&lt; '-'
+	 &lt;&lt; this-&gt;externalGuards_m.lower(i) &lt;&lt; ' ';
+  ostr &lt;&lt; '\n';
+  FillIterator_t gstart = this-&gt;gcFillList_m.begin();
+  FillIterator_t gend = this-&gt;gcFillList_m.end();
+  ostr &lt;&lt; &quot; this-&gt;gcFillList_m\n&quot;;
+  for(; gstart!=gend; ++gstart)
+    ostr &lt;&lt; &quot;       &quot;
+	 &lt;&lt; gstart-&gt;domain_m &lt;&lt; ' '
+	 &lt;&lt; gstart-&gt;ownedID_m &lt;&lt; ' '
+	 &lt;&lt; gstart-&gt;guardID_m &lt;&lt; '\n';
+  ostr &lt;&lt; std::flush;
+}
+


 //============================================================
@@ -1732,6 +1766,47 @@
 {
   this-&gt;pdata_m-&gt;initialize(gdom, gpar, cmap);
 }
+
+template &lt;int Dim&gt;
+template &lt;class Ostream&gt;
+void GridLayout&lt;Dim&gt;::print(Ostream &amp;ostr) const
+{
+  ostr &lt;&lt; &quot;GridLayout &quot; &lt;&lt; this-&gt;ID() &lt;&lt; &quot; on global domain &quot;
+       &lt;&lt; this-&gt;domain() &lt;&lt; &quot;:&quot; &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Total subdomains: &quot; &lt;&lt; this-&gt;sizeGlobal() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Local subdomains: &quot; &lt;&lt; this-&gt;sizeLocal() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;  Remote subdomains: &quot; &lt;&lt; this-&gt;sizeRemote() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;        Grid blocks: &quot; &lt;&lt; this-&gt;blocks() &lt;&lt; '\n';
+  typename GridLayout&lt;Dim&gt;::const_iterator a;
+  for (a = this-&gt;beginGlobal(); a != this-&gt;endGlobal(); ++a)
+    ostr &lt;&lt; &quot;  Global subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+  for (a = this-&gt;beginLocal(); a != this-&gt;endLocal(); ++a)
+    ostr &lt;&lt; &quot;   Local subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+  for (a = this-&gt;beginRemote(); a != this-&gt;endRemote(); ++a)
+    ostr &lt;&lt; &quot;  Remote subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+  this-&gt;pdata_m-&gt;print(ostr);
+}
+
+template&lt;int Dim, int Dim2&gt;
+template &lt;class Ostream&gt;
+void GridLayoutView&lt;Dim, Dim2&gt;::print(Ostream &amp;ostr) const
+{
+  ostr &lt;&lt; &quot;GridLayoutView &quot; &lt;&lt; this-&gt;ID() &lt;&lt; &quot; on global domain &quot;
+       &lt;&lt; this-&gt;domain() &lt;&lt; ':' &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Base ID:          &quot; &lt;&lt; this-&gt;baseID() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Base domain:      &quot; &lt;&lt; this-&gt;baseDomain() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Total subdomains: &quot; &lt;&lt; this-&gt;sizeGlobal() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Local subdomains: &quot; &lt;&lt; this-&gt;sizeLocal() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;  Remote subdomains: &quot; &lt;&lt; this-&gt;sizeRemote() &lt;&lt; '\n';
+  const_iterator a;
+  for (a = this-&gt;beginGlobal(); a != this-&gt;endGlobal(); ++a)
+    ostr &lt;&lt; &quot;  Global subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+  for (a = this-&gt;beginLocal(); a != this-&gt;endLocal(); ++a)
+    ostr &lt;&lt; &quot;   Local subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+  for (a = this-&gt;beginRemote(); a != this-&gt;endRemote(); ++a)
+    ostr &lt;&lt; &quot;  Remote subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+}
+

 // } // namespace POOMA

Index: GridLayout.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Layout/GridLayout.h,v
retrieving revision 1.110
diff -u -u -r1.110 GridLayout.h
--- GridLayout.h	26 Oct 2003 11:28:11 -0000	1.110
+++ GridLayout.h	3 Dec 2003 20:45:44 -0000
@@ -207,11 +207,7 @@
   /// which case we need to delete our nodes. The Observable destructor
   /// will broadcast messages up to all observers of the Layout.

-  ~GridLayoutData()
-    {
-      for (typename List_t::iterator a = this-&gt;all_m.begin(); a != this-&gt;all_m.end(); ++a)
-	delete (*a);
-    }
+  ~GridLayoutData();

   //============================================================
   // Mutators
@@ -307,34 +303,13 @@
   /// can build either pointers or objects.

   template &lt;class OtherDomain, class OutIter, class ConstructTag&gt;
-    int touchesAlloc(const OtherDomain &amp;fulld, OutIter o,
-		     const ConstructTag &amp;ctag) const;
+  int touchesAlloc(const OtherDomain &amp;fulld, OutIter o,
+		   const ConstructTag &amp;ctag) const;

   void sync();

   template&lt;class Out&gt;
-  void print(Out &amp; ostr)
-  {
-    int i;
-    ostr &lt;&lt; &quot; hasInternalGuards_m, hasExternalGuards_m &quot; &lt;&lt;
-      this-&gt;hasInternalGuards_m &lt;&lt;&quot; &quot; &lt;&lt; this-&gt;hasExternalGuards_m &lt;&lt;std::endl;
-    ostr &lt;&lt; &quot; internalGuards_m &quot; ;
-    for ( i=0;i&lt;Dim;++i)
-      ostr &lt;&lt; this-&gt;internalGuards_m.upper(i)&lt;&lt;&quot;-&quot;&lt;&lt;this-&gt;internalGuards_m.lower(i)&lt;&lt;&quot; &quot;;
-    ostr &lt;&lt;std::endl;
-    ostr &lt;&lt; &quot; externalGuards_m &quot; ;
-    for ( i=0;i&lt;Dim;++i)
-      ostr &lt;&lt; this-&gt;externalGuards_m.upper(i)&lt;&lt;&quot;-&quot;&lt;&lt;this-&gt;externalGuards_m.lower(i)&lt;&lt;&quot; &quot;;
-    ostr &lt;&lt;std::endl;
-    FillIterator_t gstart = this-&gt;gcFillList_m.begin();
-    FillIterator_t gend = this-&gt;gcFillList_m.end();
-    ostr&lt;&lt; &quot; this-&gt;gcFillList_m &quot; &lt;&lt;std::endl;
-    for( ; gstart!=gend ; ++gstart)
-      ostr&lt;&lt;&quot;       &quot;
-	  &lt;&lt;gstart-&gt;domain_m&lt;&lt;&quot; &quot;
-	  &lt;&lt;gstart-&gt;ownedID_m&lt;&lt;&quot; &quot;
-	  &lt;&lt;gstart-&gt;guardID_m&lt;&lt;std::endl;
-  }
+  void print(Out &amp; ostr);

 private:
   //============================================================
@@ -765,22 +740,7 @@
   /// Print a GridLayout on an output stream

   template &lt;class Ostream&gt;
-  void print(Ostream &amp;ostr) const {
-    ostr &lt;&lt; &quot;GridLayout &quot; &lt;&lt; this-&gt;ID() &lt;&lt; &quot; on global domain &quot;
-      &lt;&lt; this-&gt;domain() &lt;&lt; &quot;:&quot; &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Total subdomains: &quot; &lt;&lt; this-&gt;sizeGlobal() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Local subdomains: &quot; &lt;&lt; this-&gt;sizeLocal() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;  Remote subdomains: &quot; &lt;&lt; this-&gt;sizeRemote() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;        Grid blocks: &quot; &lt;&lt; this-&gt;blocks() &lt;&lt; '\n';
-    typename GridLayout&lt;Dim&gt;::const_iterator a;
-    for (a = this-&gt;beginGlobal(); a != this-&gt;endGlobal(); ++a)
-      ostr &lt;&lt; &quot;  Global subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-    for (a = this-&gt;beginLocal(); a != this-&gt;endLocal(); ++a)
-      ostr &lt;&lt; &quot;   Local subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-    for (a = this-&gt;beginRemote(); a != this-&gt;endRemote(); ++a)
-      ostr &lt;&lt; &quot;  Remote subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-    this-&gt;pdata_m-&gt;print(ostr);
-  }
+  void print(Ostream &amp;ostr) const;

 #if !POOMA_NO_TEMPLATE_FRIENDS

@@ -1041,23 +1001,7 @@
   // Print a GridLayoutView on an output stream

   template &lt;class Ostream&gt;
-  void print(Ostream &amp;ostr) const
-  {
-    ostr &lt;&lt; &quot;GridLayoutView &quot; &lt;&lt; this-&gt;ID() &lt;&lt; &quot; on global domain &quot;
-      &lt;&lt; this-&gt;domain() &lt;&lt; &quot;:&quot; &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Base ID:          &quot; &lt;&lt; this-&gt;baseID() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Base domain:      &quot; &lt;&lt; this-&gt;baseDomain() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Total subdomains: &quot; &lt;&lt; this-&gt;sizeGlobal() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Local subdomains: &quot; &lt;&lt; this-&gt;sizeLocal() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;  Remote subdomains: &quot; &lt;&lt; this-&gt;sizeRemote() &lt;&lt; '\n';
-    const_iterator a;
-    for (a = this-&gt;beginGlobal(); a != this-&gt;endGlobal(); ++a)
-      ostr &lt;&lt; &quot;  Global subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-    for (a = this-&gt;beginLocal(); a != this-&gt;endLocal(); ++a)
-      ostr &lt;&lt; &quot;   Local subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-    for (a = this-&gt;beginRemote(); a != this-&gt;endRemote(); ++a)
-      ostr &lt;&lt; &quot;  Remote subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-  }
+  void print(Ostream &amp;ostr) const;

 #if !POOMA_NO_TEMPLATE_FRIENDS

Index: UniformGridLayout.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Layout/UniformGridLayout.cpp,v
retrieving revision 1.40
diff -u -u -r1.40 UniformGridLayout.cpp
--- UniformGridLayout.cpp	11 Mar 2003 21:30:44 -0000	1.40
+++ UniformGridLayout.cpp	3 Dec 2003 20:45:49 -0000
@@ -279,7 +279,7 @@
 //-----------------------------------------------------------------------------
 //
 // template &lt;int Dim&gt;
-// void UniformGridLayout&lt;Dim&gt;::calcGCFillList()
+// void UniformGridLayoutData&lt;Dim&gt;::calcGCFillList()
 //
 // Calculates the cached information needed by MultiPatch Engine to
 // fill the guard cells.
@@ -1182,6 +1182,950 @@
   // Return the number of non-empty domains we found.

   return count;
+}
+
+
+//=============================================================================
+// UniformGridLayout &amp; UniformGridLayoutData inline method definitions
+//=============================================================================
+
+//-----------------------------------------------------------------------------
+//
+// Constructors and Initialize methods
+//
+//-----------------------------------------------------------------------------
+
+// See comments in class definition above.
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout()
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+    (new LayoutData_t()),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+		  const DistributedTag&amp; t)
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+    (new LayoutData_t(gdom,
+		      UniformGridPartition&lt;Dim&gt;(),
+		      DistributedMapper&lt;Dim&gt;(UniformGridPartition&lt;Dim&gt;()))),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+		  const ReplicatedTag &amp; t)
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+    (new LayoutData_t(gdom,
+		      UniformGridPartition&lt;Dim&gt;(),
+		      LocalMapper&lt;Dim&gt;())),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+		  const GuardLayers_t &amp;gcs,
+		  const DistributedTag &amp;)
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+    (new LayoutData_t(gdom,
+		      UniformGridPartition&lt;Dim&gt;(gcs),
+		      DistributedMapper&lt;Dim&gt;(UniformGridPartition&lt;Dim&gt;(gcs)))),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+		  const GuardLayers_t &amp;gcs,
+		  const ReplicatedTag &amp; )
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+    (new LayoutData_t(gdom,
+		      UniformGridPartition&lt;Dim&gt;(gcs),
+		      LocalMapper&lt;Dim&gt;())),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+		  const Loc&lt;Dim&gt; &amp;blocks,
+		  const DistributedTag &amp; )
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+    (new LayoutData_t(gdom,
+		      UniformGridPartition&lt;Dim&gt;(blocks),
+		      DistributedMapper&lt;Dim&gt;(
+		        UniformGridPartition&lt;Dim&gt;(blocks)))),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+		  const Loc&lt;Dim&gt; &amp;blocks,
+		  const ReplicatedTag &amp; t)
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+    (new LayoutData_t(gdom,
+		      UniformGridPartition&lt;Dim&gt;(blocks),
+		      LocalMapper&lt;Dim&gt;())),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+                  const Loc&lt;Dim&gt; &amp;blocks,
+                  const GuardLayers_t &amp;igcs,
+		  const DistributedTag &amp;)
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+   (new LayoutData_t(gdom,
+		     UniformGridPartition&lt;Dim&gt;(blocks,igcs),
+		     DistributedMapper&lt;Dim&gt;(
+		      UniformGridPartition&lt;Dim&gt;(blocks,igcs)))),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+                  const Loc&lt;Dim&gt; &amp;blocks,
+                  const GuardLayers_t &amp;igcs,
+		  const ReplicatedTag &amp;)
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+     (new LayoutData_t(gdom,
+		       UniformGridPartition&lt;Dim&gt;(blocks,igcs),
+		       LocalMapper&lt;Dim&gt;())),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+                  const Loc&lt;Dim&gt; &amp;blocks,
+                  const GuardLayers_t &amp;igcs,
+                  const GuardLayers_t &amp;egcs,
+		  const DistributedTag &amp;)
+
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+    (new LayoutData_t(gdom,
+		      UniformGridPartition&lt;Dim&gt;(blocks,igcs,egcs),
+		      DistributedMapper&lt;Dim&gt;(
+                       UniformGridPartition&lt;Dim&gt;(blocks,igcs,egcs)))),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+                  const Loc&lt;Dim&gt; &amp;blocks,
+                  const GuardLayers_t &amp;igcs,
+                  const GuardLayers_t &amp;egcs,
+		  const ReplicatedTag &amp;t)
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+    (new LayoutData_t(gdom,
+		      UniformGridPartition&lt;Dim&gt;(blocks,igcs,egcs),
+		      LocalMapper&lt;Dim&gt;())),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+template &lt;class Partitioner&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+		  const Partitioner &amp;gpar,
+		  const DistributedTag &amp; )
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+   (new LayoutData_t(gdom,gpar,DistributedMapper&lt;Dim&gt;(gpar))),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+template &lt;class Partitioner&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+		  const Partitioner &amp;gpar,
+		  const ReplicatedTag &amp;)
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+   (new LayoutData_t(gdom,gpar,LocalMapper&lt;Dim&gt;())),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+template &lt;class Partitioner&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const Domain_t &amp;gdom,
+		  const Partitioner &amp;gpar,
+		  const ContextMapper&lt;Dim&gt; &amp; cmap)
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
+    (new LayoutData_t(gdom,gpar,cmap)),
+  Observable&lt;This_t&gt;(*this)
+{
+  this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt;::
+UniformGridLayout(const This_t &amp;model)
+: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;(model.pdata_m),
+  Observable&lt;This_t&gt;(*this)
+{
+   this-&gt;pdata_m-&gt;attach(*this);
+}
+
+template &lt;int Dim&gt;
+inline UniformGridLayout&lt;Dim&gt; &amp; UniformGridLayout&lt;Dim&gt;::
+operator=(const This_t &amp;model)
+{
+  if (this != &amp;model)
+    {
+      this-&gt;pdata_m-&gt;detach(*this);
+      this-&gt;pdata_m = model.pdata_m;
+      this-&gt;pdata_m-&gt;attach(*this);
+    }
+  return *this;
+}
+
+// Initialize methods...
+
+template &lt;int Dim&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+	   const DistributedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+
+  // Initialize our global domain, and then do the partitioning.
+
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(),
+		     DistributedMapper&lt;Dim&gt;(UniformGridPartition&lt;Dim&gt;()));
+}
+
+template &lt;int Dim&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+	   const ReplicatedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+
+  // Initialize our global domain, and then do the partitioning.
+
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(),
+		     LocalMapper&lt;Dim&gt;());
+}
+
+template &lt;int Dim&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+	   const GuardLayers_t &amp;gcs,
+	   const DistributedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+
+  // Initialize our global domain, and then do the partitioning.
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(gcs),
+		     DistributedMapper&lt;Dim&gt;(UniformGridPartition&lt;Dim&gt;(gcs) ));
+}
+
+template &lt;int Dim&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+	   const GuardLayers_t &amp;gcs,
+	   const ReplicatedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+
+  // Initialize our global domain, and then do the partitioning.
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(gcs),
+		     LocalMapper&lt;Dim&gt;());
+}
+
+template &lt;int Dim&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+	   const Loc&lt;Dim&gt; &amp;blocks,
+	   const DistributedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+
+  // Initialize our global domain, and then do the partitioning.
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks),
+		    DistributedMapper&lt;Dim&gt;(UniformGridPartition&lt;Dim&gt;(blocks)));
+}
+
+template &lt;int Dim&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+	   const Loc&lt;Dim&gt; &amp;blocks,
+	   const ReplicatedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks),
+		     LocalMapper&lt;Dim&gt;());
+}
+
+template &lt;int Dim&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+           const Loc&lt;Dim&gt; &amp;blocks,
+           const GuardLayers_t &amp;gcs,
+	   const DistributedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks, gcs),
+		     DistributedMapper&lt;Dim&gt;(
+		       UniformGridPartition&lt;Dim&gt;(blocks, gcs)));
+}
+
+template &lt;int Dim&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+           const Loc&lt;Dim&gt; &amp;blocks,
+           const GuardLayers_t &amp;gcs,
+	   const ReplicatedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks, gcs),
+		     LocalMapper&lt;Dim&gt;());
+}
+
+template &lt;int Dim&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+           const Loc&lt;Dim&gt; &amp;blocks,
+           const GuardLayers_t &amp;igcs,
+           const GuardLayers_t &amp;egcs,
+	   const DistributedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+
+  // Initialize our global domain, and then do the partitioning.
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks, igcs, egcs),
+		     DistributedMapper&lt;Dim&gt;(
+		       UniformGridPartition&lt;Dim&gt;(blocks, igcs, egcs)));
+}
+
+template &lt;int Dim&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+           const Loc&lt;Dim&gt; &amp;blocks,
+           const GuardLayers_t &amp;igcs,
+           const GuardLayers_t &amp;egcs,
+	   const ReplicatedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+
+  // Initialize our global domain, and then do the partitioning.
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;blocks_m = blocks;
+  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks, igcs, egcs),
+		     LocalMapper&lt;Dim&gt;());
+}
+
+
+template &lt;int Dim&gt;
+template &lt;class Partitioner&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+           const Partitioner &amp;p,
+	   const DistributedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+
+  // Initialize our global domain, and then do the partitioning.
+
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;blocks_m = p.blocks();
+  this-&gt;pdata_m-&gt;partition(p,DistributedMapper&lt;Dim&gt;(p));
+}
+
+template &lt;int Dim&gt;
+template &lt;class Partitioner&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+           const Partitioner &amp;p,
+	   const ReplicatedTag &amp;)
+{
+  PAssert(!this-&gt;initialized());
+
+  // Initialize our global domain, and then do the partitioning.
+
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;blocks_m = p.blocks();
+  this-&gt;pdata_m-&gt;partition(p,LocalMapper&lt;Dim&gt;());
+}
+template &lt;int Dim&gt;
+template &lt;class Partitioner&gt;
+inline void
+UniformGridLayout&lt;Dim&gt;::
+initialize(const Domain_t &amp;gdom,
+           const Partitioner &amp;p,
+	   const ContextMapper&lt;Dim&gt; &amp;cmap)
+{
+  PAssert(!this-&gt;initialized());
+
+  // Initialize our global domain, and then do the partitioning.
+
+  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
+  this-&gt;pdata_m-&gt;domain_m = gdom;
+  this-&gt;pdata_m-&gt;blocks_m = p.blocks();
+  this-&gt;pdata_m-&gt;partition(p,cmap);
+}
+
+// This initializer is intented to be used by the I/O system
+
+template &lt;int Dim&gt;
+void UniformGridLayout&lt;Dim&gt;::initialize(const Domain_t&amp; idom,
+				 const List_t&amp; nodes,
+				 const Loc&lt;Dim&gt;&amp; blocks,
+				 bool hasIG, bool hasEG,
+				 const GuardLayers_t&amp; ig,
+				 const GuardLayers_t&amp; eg)
+{
+  this-&gt;pdata_m-&gt;initialize(idom,nodes,blocks,hasIG,hasEG,ig,eg);
+}
+
+// Here are the implementations for globalID:
+
+template &lt;int Dim&gt;
+inline int
+UniformGridLayoutData&lt;Dim&gt;::globalID(const Loc&lt;Dim&gt; &amp;loc) const
+{
+  // Make sure the point is in our domain.
+  PAssert(contains(this-&gt;domain_m, loc));
+  int currloc;
+
+  if (!this-&gt;hasExternalGuards_m)
+    {
+      currloc = (loc[0].first() - this-&gt;firsti_m[0]) / blocksizes_m[0];
+      for (int d = 1; d &lt; Dim; ++d)
+        currloc += blockstride_m[d] *
+          ((loc[d].first() - this-&gt;firsti_m[d]) / blocksizes_m[d]);
+    }
+  else
+    {
+      currloc = 0;
+      for (int d = 0; d &lt; Dim; ++d)
+        {
+          int l = loc[d].first();
+
+          // If l &lt; this-&gt;firsti_m[0], currloc is unchanged.
+
+          if (l &gt;= this-&gt;firsti_m[d])
+            {
+              if (l &lt;= this-&gt;innerdomain_m[d].last())
+                {
+                  // The usual expression in this direction.
+
+                  currloc += blockstride_m[d] *
+                    ((l - this-&gt;firsti_m[d]) / blocksizes_m[d]);
+                }
+              else
+                {
+                  // Must be in the last block in this direction.
+
+                  currloc += blockstride_m[d] * allDomain_m[d].last();
+                }
+            }
+        }
+    }
+
+  // Return the globalID for the currloc's node
+
+  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
+  return currloc;
+}
+
+template &lt;int Dim&gt;
+inline int
+UniformGridLayoutData&lt;Dim&gt;::globalID(int i0) const
+{
+  PAssert(Dim == 1);
+  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
+
+  // Compute fortran-order index from position in block grid
+  // See the Loc&lt;Dim&gt; version for comments.
+
+  int currloc;
+  if (!this-&gt;hasExternalGuards_m)
+    {
+      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
+    }
+  else
+    {
+      currloc = 0;
+      if (i0 &gt;= this-&gt;firsti_m[0]) {
+        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
+          currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
+        else
+          currloc = allDomain_m[0].last();
+      }
+    }
+
+  // Return the globalID for the currloc's node.
+
+  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
+  return currloc;
+}
+
+template &lt;int Dim&gt;
+inline int
+UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1) const
+{
+  PAssert(Dim == 2);
+  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
+  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
+
+  // Compute fortran-order index from position in block grid
+
+  int currloc;
+  if (!this-&gt;hasExternalGuards_m)
+    {
+      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
+              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
+    }
+  else
+    {
+      currloc = 0;
+      if (i0 &gt;= this-&gt;firsti_m[0]) {
+        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
+          currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
+        else
+          currloc = allDomain_m[0].last();
+      }
+      if (i1 &gt;= this-&gt;firsti_m[1]) {
+        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
+          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
+        else
+          currloc += blockstride_m[1] * allDomain_m[1].last();
+      }
+    }
+
+  // Return the globalID for the currloc's node
+
+  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
+  return currloc;
+}
+
+template &lt;int Dim&gt;
+inline int
+UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1, int i2) const
+{
+  PAssert(Dim == 3);
+  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
+  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
+  PAssert(i2 &gt;= this-&gt;domain_m[2].first() &amp;&amp; i2 &lt;= this-&gt;domain_m[2].last());
+
+  // Compute fortran-order index from position in block grid
+
+  int currloc;
+  if (!this-&gt;hasExternalGuards_m)
+    {
+      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
+              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1])
+              + blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
+    }
+  else
+    {
+      currloc = 0;
+      if (i0 &gt;= this-&gt;firsti_m[0]) {
+        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
+          currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
+        else
+          currloc = allDomain_m[0].last();
+      }
+      if (i1 &gt;= this-&gt;firsti_m[1]) {
+        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
+          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
+        else
+          currloc += blockstride_m[1] * allDomain_m[1].last();
+      }
+      if (i2 &gt;= this-&gt;firsti_m[2]) {
+        if (i2 &lt;= this-&gt;innerdomain_m[2].last())
+          currloc += blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
+        else
+          currloc += blockstride_m[2] * allDomain_m[2].last();
+      }
+    }
+
+  // Return the globalID for the currloc's node
+
+  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
+  return currloc;
+}
+
+template &lt;int Dim&gt;
+inline int
+UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1, int i2, int i3) const
+{
+  PAssert(Dim == 4);
+  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
+  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
+  PAssert(i2 &gt;= this-&gt;domain_m[2].first() &amp;&amp; i2 &lt;= this-&gt;domain_m[2].last());
+  PAssert(i3 &gt;= this-&gt;domain_m[3].first() &amp;&amp; i3 &lt;= this-&gt;domain_m[3].last());
+
+  // Compute fortran-order index from position in block grid
+
+  int currloc;
+  if (!this-&gt;hasExternalGuards_m)
+    {
+      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
+              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1])
+              + blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2])
+              + blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3]);
+    }
+  else
+    {
+      currloc = 0;
+      if (i0 &gt;= this-&gt;firsti_m[0]) {
+        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
+           currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
+        else
+           currloc = allDomain_m[0].last();
+      }
+      if (i1 &gt;= this-&gt;firsti_m[1]) {
+        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
+          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
+        else
+          currloc += blockstride_m[1] * allDomain_m[1].last();
+      }
+      if (i2 &gt;= this-&gt;firsti_m[2]) {
+        if (i2 &lt;= this-&gt;innerdomain_m[2].last())
+          currloc += blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
+        else
+          currloc += blockstride_m[2] * allDomain_m[2].last();
+      }
+      if (i3 &gt;= this-&gt;firsti_m[3]) {
+        if (i3 &lt;= this-&gt;innerdomain_m[3].last())
+          currloc += blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3]);
+        else
+          currloc += blockstride_m[3] * allDomain_m[3].last();
+      }
+    }
+
+  // Return the globalID for the currloc's node
+
+  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
+  return currloc;
+}
+
+template &lt;int Dim&gt;
+inline int
+UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1, int i2, int i3,
+                                     int i4) const
+{
+  PAssert(Dim == 5);
+  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
+  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
+  PAssert(i2 &gt;= this-&gt;domain_m[2].first() &amp;&amp; i2 &lt;= this-&gt;domain_m[2].last());
+  PAssert(i3 &gt;= this-&gt;domain_m[3].first() &amp;&amp; i3 &lt;= this-&gt;domain_m[3].last());
+  PAssert(i4 &gt;= this-&gt;domain_m[4].first() &amp;&amp; i4 &lt;= this-&gt;domain_m[4].last());
+
+  // Compute fortran-order index from position in block grid
+
+  int currloc;
+  if (!this-&gt;hasExternalGuards_m)
+    {
+      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
+              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1])
+              + blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2])
+              + blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3])
+              + blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4]);
+    }
+  else
+    {
+      currloc = 0;
+      if (i0 &gt;= this-&gt;firsti_m[0]) {
+        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
+           currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
+        else
+           currloc = allDomain_m[0].last();
+      }
+      if (i1 &gt;= this-&gt;firsti_m[1]) {
+        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
+          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
+        else
+          currloc += blockstride_m[1] * allDomain_m[1].last();
+      }
+      if (i2 &gt;= this-&gt;firsti_m[2]) {
+        if (i2 &lt;= this-&gt;innerdomain_m[2].last())
+          currloc += blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
+        else
+          currloc += blockstride_m[2] * allDomain_m[2].last();
+      }
+      if (i3 &gt;= this-&gt;firsti_m[3]) {
+        if (i3 &lt;= this-&gt;innerdomain_m[3].last())
+          currloc += blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3]);
+        else
+          currloc += blockstride_m[3] * allDomain_m[3].last();
+      }
+      if (i4 &gt;= this-&gt;firsti_m[4]) {
+        if (i4 &lt;= this-&gt;innerdomain_m[4].last())
+          currloc += blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4]);
+        else
+          currloc += blockstride_m[4] * allDomain_m[4].last();
+      }
+    }
+
+  // Return the globalID for the currloc's node
+
+  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
+  return currloc;
+}
+
+template &lt;int Dim&gt;
+inline int
+UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1, int i2, int i3,
+                                     int i4, int i5) const
+{
+  PAssert(Dim == 6);
+  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
+  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
+  PAssert(i2 &gt;= this-&gt;domain_m[2].first() &amp;&amp; i2 &lt;= this-&gt;domain_m[2].last());
+  PAssert(i3 &gt;= this-&gt;domain_m[3].first() &amp;&amp; i3 &lt;= this-&gt;domain_m[3].last());
+  PAssert(i4 &gt;= this-&gt;domain_m[4].first() &amp;&amp; i4 &lt;= this-&gt;domain_m[4].last());
+  PAssert(i5 &gt;= this-&gt;domain_m[5].first() &amp;&amp; i5 &lt;= this-&gt;domain_m[5].last());
+
+  // Compute fortran-order index from position in block grid
+
+  int currloc;
+  if (!this-&gt;hasExternalGuards_m)
+    {
+      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
+              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1])
+              + blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2])
+              + blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3])
+              + blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4])
+              + blockstride_m[5] * ((i5 - this-&gt;firsti_m[5]) / blocksizes_m[5]);
+    }
+  else
+    {
+      currloc = 0;
+      if (i0 &gt;= this-&gt;firsti_m[0]) {
+        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
+           currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
+        else
+           currloc = allDomain_m[0].last();
+      }
+      if (i1 &gt;= this-&gt;firsti_m[1]) {
+        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
+          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
+        else
+          currloc += blockstride_m[1] * allDomain_m[1].last();
+      }
+      if (i2 &gt;= this-&gt;firsti_m[2]) {
+        if (i2 &lt;= this-&gt;innerdomain_m[2].last())
+          currloc += blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
+        else
+          currloc += blockstride_m[2] * allDomain_m[2].last();
+      }
+      if (i3 &gt;= this-&gt;firsti_m[3]) {
+        if (i3 &lt;= this-&gt;innerdomain_m[3].last())
+          currloc += blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3]);
+        else
+          currloc += blockstride_m[3] * allDomain_m[3].last();
+      }
+      if (i4 &gt;= this-&gt;firsti_m[4]) {
+        if (i4 &lt;= this-&gt;innerdomain_m[4].last())
+          currloc += blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4]);
+        else
+          currloc += blockstride_m[4] * allDomain_m[4].last();
+      }
+      if (i5 &gt;= this-&gt;firsti_m[5]) {
+        if (i5 &lt;= this-&gt;innerdomain_m[5].last())
+          currloc += blockstride_m[5] * ((i5 - this-&gt;firsti_m[5]) / blocksizes_m[5]);
+        else
+          currloc += blockstride_m[5] * allDomain_m[5].last();
+      }
+    }
+
+  // Return the globalID for the currloc's node
+
+  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
+  return currloc;
+}
+
+template &lt;int Dim&gt;
+inline int
+UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1, int i2, int i3,
+                                     int i4, int i5, int i6) const
+{
+  PAssert(Dim == 7);
+  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
+  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
+  PAssert(i2 &gt;= this-&gt;domain_m[2].first() &amp;&amp; i2 &lt;= this-&gt;domain_m[2].last());
+  PAssert(i3 &gt;= this-&gt;domain_m[3].first() &amp;&amp; i3 &lt;= this-&gt;domain_m[3].last());
+  PAssert(i4 &gt;= this-&gt;domain_m[4].first() &amp;&amp; i4 &lt;= this-&gt;domain_m[4].last());
+  PAssert(i5 &gt;= this-&gt;domain_m[5].first() &amp;&amp; i5 &lt;= this-&gt;domain_m[5].last());
+  PAssert(i6 &gt;= this-&gt;domain_m[6].first() &amp;&amp; i6 &lt;= this-&gt;domain_m[6].last());
+
+  // Compute fortran-order index from position in block grid
+
+  int currloc;
+  if (!this-&gt;hasExternalGuards_m)
+    {
+      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
+              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1])
+              + blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2])
+              + blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3])
+              + blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4])
+              + blockstride_m[5] * ((i5 - this-&gt;firsti_m[5]) / blocksizes_m[5])
+              + blockstride_m[6] * ((i6 - this-&gt;firsti_m[6]) / blocksizes_m[6]);
+    }
+  else
+    {
+      currloc = 0;
+      if (i0 &gt;= this-&gt;firsti_m[0]) {
+        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
+           currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
+        else
+           currloc = allDomain_m[0].last();
+      }
+      if (i1 &gt;= this-&gt;firsti_m[1]) {
+        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
+          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
+        else
+          currloc += blockstride_m[1] * allDomain_m[1].last();
+      }
+      if (i2 &gt;= this-&gt;firsti_m[2]) {
+        if (i2 &lt;= this-&gt;innerdomain_m[2].last())
+          currloc += blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
+        else
+          currloc += blockstride_m[2] * allDomain_m[2].last();
+      }
+      if (i3 &gt;= this-&gt;firsti_m[3]) {
+        if (i3 &lt;= this-&gt;innerdomain_m[3].last())
+          currloc += blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3]);
+        else
+          currloc += blockstride_m[3] * allDomain_m[3].last();
+      }
+      if (i4 &gt;= this-&gt;firsti_m[4]) {
+        if (i4 &lt;= this-&gt;innerdomain_m[4].last())
+          currloc += blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4]);
+        else
+          currloc += blockstride_m[4] * allDomain_m[4].last();
+      }
+      if (i5 &gt;= this-&gt;firsti_m[5]) {
+        if (i5 &lt;= this-&gt;innerdomain_m[5].last())
+          currloc += blockstride_m[5] * ((i5 - this-&gt;firsti_m[5]) / blocksizes_m[5]);
+        else
+          currloc += blockstride_m[5] * allDomain_m[5].last();
+      }
+      if (i6 &gt;= this-&gt;firsti_m[6]) {
+        if (i6 &lt;= this-&gt;innerdomain_m[6].last())
+          currloc += blockstride_m[6] * ((i6 - this-&gt;firsti_m[6]) / blocksizes_m[6]);
+        else
+          currloc += blockstride_m[6] * allDomain_m[6].last();
+      }
+    }
+
+  // Return the globalID for the currloc's node
+
+  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
+  return currloc;
+}
+
+
+template &lt;int Dim&gt;
+template &lt;class Ostream&gt;
+void UniformGridLayout&lt;Dim&gt;::print(Ostream &amp;ostr) const
+{
+  ostr &lt;&lt; &quot;UniformGridLayout &quot; &lt;&lt; this-&gt;ID() &lt;&lt; &quot; on global domain &quot;
+       &lt;&lt; this-&gt;domain() &lt;&lt; &quot;:&quot; &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Total subdomains: &quot; &lt;&lt; this-&gt;sizeGlobal() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Local subdomains: &quot; &lt;&lt; this-&gt;sizeLocal() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;  Remote subdomains: &quot; &lt;&lt; this-&gt;sizeRemote() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;        Grid blocks: &quot; &lt;&lt; this-&gt;blocks() &lt;&lt; '\n';
+  typename UniformGridLayout&lt;Dim&gt;::const_iterator a;
+  for (a = this-&gt;beginGlobal(); a != this-&gt;endGlobal(); ++a)
+    ostr &lt;&lt; &quot;  Global subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+  for (a = this-&gt;beginLocal(); a != this-&gt;endLocal(); ++a)
+    ostr &lt;&lt; &quot;   Local subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+  for (a = this-&gt;beginRemote(); a != this-&gt;endRemote(); ++a)
+    ostr &lt;&lt; &quot;  Remote subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+}
+
+template &lt;int Dim, int Dim2&gt;
+template &lt;class Ostream&gt;
+void UniformGridLayoutView&lt;Dim, Dim2&gt;::print(Ostream &amp;ostr) const
+{
+  ostr &lt;&lt; &quot;UniformGridLayoutView &quot; &lt;&lt; this-&gt;ID() &lt;&lt; &quot; on global domain &quot;
+       &lt;&lt; this-&gt;domain() &lt;&lt; &quot;:&quot; &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Base ID:          &quot; &lt;&lt; this-&gt;baseID() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Base domain:      &quot; &lt;&lt; this-&gt;baseDomain() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Total subdomains: &quot; &lt;&lt; this-&gt;sizeGlobal() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;   Local subdomains: &quot; &lt;&lt; this-&gt;sizeLocal() &lt;&lt; '\n';
+  ostr &lt;&lt; &quot;  Remote subdomains: &quot; &lt;&lt; this-&gt;sizeRemote() &lt;&lt; '\n';
+  const_iterator a;
+  for (a = this-&gt;beginGlobal(); a != this-&gt;endGlobal(); ++a)
+    ostr &lt;&lt; &quot;  Global subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+  for (a = this-&gt;beginLocal(); a != this-&gt;endLocal(); ++a)
+    ostr &lt;&lt; &quot;   Local subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
+  for (a = this-&gt;beginRemote(); a != this-&gt;endRemote(); ++a)
+    ostr &lt;&lt; &quot;  Remote subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
 }


Index: UniformGridLayout.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Layout/UniformGridLayout.h,v
retrieving revision 1.87
diff -u -u -r1.87 UniformGridLayout.h
--- UniformGridLayout.h	26 Oct 2003 11:28:11 -0000	1.87
+++ UniformGridLayout.h	3 Dec 2003 20:45:51 -0000
@@ -596,21 +596,7 @@
   // Print a UniformGridLayout on an output stream

   template &lt;class Ostream&gt;
-  void print(Ostream &amp;ostr) const {
-    ostr &lt;&lt; &quot;UniformGridLayout &quot; &lt;&lt; this-&gt;ID() &lt;&lt; &quot; on global domain &quot;
-      &lt;&lt; this-&gt;domain() &lt;&lt; &quot;:&quot; &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Total subdomains: &quot; &lt;&lt; this-&gt;sizeGlobal() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Local subdomains: &quot; &lt;&lt; this-&gt;sizeLocal() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;  Remote subdomains: &quot; &lt;&lt; this-&gt;sizeRemote() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;        Grid blocks: &quot; &lt;&lt; this-&gt;blocks() &lt;&lt; '\n';
-    typename UniformGridLayout&lt;Dim&gt;::const_iterator a;
-    for (a = this-&gt;beginGlobal(); a != this-&gt;endGlobal(); ++a)
-      ostr &lt;&lt; &quot;  Global subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-    for (a = this-&gt;beginLocal(); a != this-&gt;endLocal(); ++a)
-      ostr &lt;&lt; &quot;   Local subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-    for (a = this-&gt;beginRemote(); a != this-&gt;endRemote(); ++a)
-      ostr &lt;&lt; &quot;  Remote subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-  }
+  void print(Ostream &amp;ostr) const;


 #if !POOMA_NO_TEMPLATE_FRIENDS
@@ -881,23 +867,7 @@
   // Print a UniformGridLayoutView on an output stream

   template &lt;class Ostream&gt;
-  void print(Ostream &amp;ostr) const
-  {
-    ostr &lt;&lt; &quot;UniformGridLayoutView &quot; &lt;&lt; this-&gt;ID() &lt;&lt; &quot; on global domain &quot;
-      &lt;&lt; this-&gt;domain() &lt;&lt; &quot;:&quot; &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Base ID:          &quot; &lt;&lt; this-&gt;baseID() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Base domain:      &quot; &lt;&lt; this-&gt;baseDomain() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Total subdomains: &quot; &lt;&lt; this-&gt;sizeGlobal() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;   Local subdomains: &quot; &lt;&lt; this-&gt;sizeLocal() &lt;&lt; '\n';
-    ostr &lt;&lt; &quot;  Remote subdomains: &quot; &lt;&lt; this-&gt;sizeRemote() &lt;&lt; '\n';
-    const_iterator a;
-    for (a = this-&gt;beginGlobal(); a != this-&gt;endGlobal(); ++a)
-      ostr &lt;&lt; &quot;  Global subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-    for (a = this-&gt;beginLocal(); a != this-&gt;endLocal(); ++a)
-      ostr &lt;&lt; &quot;   Local subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-    for (a = this-&gt;beginRemote(); a != this-&gt;endRemote(); ++a)
-      ostr &lt;&lt; &quot;  Remote subdomain = &quot; &lt;&lt; *a &lt;&lt; '\n';
-  }
+  void print(Ostream &amp;ostr) const;

 #if !POOMA_NO_TEMPLATE_FRIENDS

@@ -922,909 +892,6 @@

 };

-
-//=============================================================================
-// UniformGridLayout &amp; UniformGridLayoutData inline method definitions
-//=============================================================================
-
-//-----------------------------------------------------------------------------
-//
-// Constructors and Initialize methods
-//
-//-----------------------------------------------------------------------------
-
-// See comments in class definition above.
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout()
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-    (new LayoutData_t()),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-		  const DistributedTag&amp; t)
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-    (new LayoutData_t(gdom,
-		      UniformGridPartition&lt;Dim&gt;(),
-		      DistributedMapper&lt;Dim&gt;(UniformGridPartition&lt;Dim&gt;()))),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-		  const ReplicatedTag &amp; t)
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-    (new LayoutData_t(gdom,
-		      UniformGridPartition&lt;Dim&gt;(),
-		      LocalMapper&lt;Dim&gt;())),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-		  const GuardLayers_t &amp;gcs,
-		  const DistributedTag &amp;)
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-    (new LayoutData_t(gdom,
-		      UniformGridPartition&lt;Dim&gt;(gcs),
-		      DistributedMapper&lt;Dim&gt;(UniformGridPartition&lt;Dim&gt;(gcs)))),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-		  const GuardLayers_t &amp;gcs,
-		  const ReplicatedTag &amp; )
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-    (new LayoutData_t(gdom,
-		      UniformGridPartition&lt;Dim&gt;(gcs),
-		      LocalMapper&lt;Dim&gt;())),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-		  const Loc&lt;Dim&gt; &amp;blocks,
-		  const DistributedTag &amp; )
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-    (new LayoutData_t(gdom,
-		      UniformGridPartition&lt;Dim&gt;(blocks),
-		      DistributedMapper&lt;Dim&gt;(
-		        UniformGridPartition&lt;Dim&gt;(blocks)))),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-		  const Loc&lt;Dim&gt; &amp;blocks,
-		  const ReplicatedTag &amp; t)
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-    (new LayoutData_t(gdom,
-		      UniformGridPartition&lt;Dim&gt;(blocks),
-		      LocalMapper&lt;Dim&gt;())),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-                  const Loc&lt;Dim&gt; &amp;blocks,
-                  const GuardLayers_t &amp;igcs,
-		  const DistributedTag &amp;)
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-   (new LayoutData_t(gdom,
-		     UniformGridPartition&lt;Dim&gt;(blocks,igcs),
-		     DistributedMapper&lt;Dim&gt;(
-		      UniformGridPartition&lt;Dim&gt;(blocks,igcs)))),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-                  const Loc&lt;Dim&gt; &amp;blocks,
-                  const GuardLayers_t &amp;igcs,
-		  const ReplicatedTag &amp;)
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-     (new LayoutData_t(gdom,
-		       UniformGridPartition&lt;Dim&gt;(blocks,igcs),
-		       LocalMapper&lt;Dim&gt;())),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-                  const Loc&lt;Dim&gt; &amp;blocks,
-                  const GuardLayers_t &amp;igcs,
-                  const GuardLayers_t &amp;egcs,
-		  const DistributedTag &amp;)
-
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-    (new LayoutData_t(gdom,
-		      UniformGridPartition&lt;Dim&gt;(blocks,igcs,egcs),
-		      DistributedMapper&lt;Dim&gt;(
-                       UniformGridPartition&lt;Dim&gt;(blocks,igcs,egcs)))),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-                  const Loc&lt;Dim&gt; &amp;blocks,
-                  const GuardLayers_t &amp;igcs,
-                  const GuardLayers_t &amp;egcs,
-		  const ReplicatedTag &amp;t)
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-    (new LayoutData_t(gdom,
-		      UniformGridPartition&lt;Dim&gt;(blocks,igcs,egcs),
-		      LocalMapper&lt;Dim&gt;())),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-template &lt;class Partitioner&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-		  const Partitioner &amp;gpar,
-		  const DistributedTag &amp; )
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-   (new LayoutData_t(gdom,gpar,DistributedMapper&lt;Dim&gt;(gpar))),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-template &lt;class Partitioner&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-		  const Partitioner &amp;gpar,
-		  const ReplicatedTag &amp;)
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-   (new LayoutData_t(gdom,gpar,LocalMapper&lt;Dim&gt;())),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-template &lt;class Partitioner&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const Domain_t &amp;gdom,
-		  const Partitioner &amp;gpar,
-		  const ContextMapper&lt;Dim&gt; &amp; cmap)
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;
-    (new LayoutData_t(gdom,gpar,cmap)),
-  Observable&lt;This_t&gt;(*this)
-{
-  this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt;::
-UniformGridLayout(const This_t &amp;model)
-: LayoutBase&lt;Dim,UniformGridLayoutData&lt;Dim&gt; &gt;(model.pdata_m),
-  Observable&lt;This_t&gt;(*this)
-{
-   this-&gt;pdata_m-&gt;attach(*this);
-}
-
-template &lt;int Dim&gt;
-inline UniformGridLayout&lt;Dim&gt; &amp; UniformGridLayout&lt;Dim&gt;::
-operator=(const This_t &amp;model)
-{
-  if (this != &amp;model)
-    {
-      this-&gt;pdata_m-&gt;detach(*this);
-      this-&gt;pdata_m = model.pdata_m;
-      this-&gt;pdata_m-&gt;attach(*this);
-    }
-  return *this;
-}
-
-// Initialize methods...
-
-template &lt;int Dim&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-	   const DistributedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-
-  // Initialize our global domain, and then do the partitioning.
-
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(),
-		     DistributedMapper&lt;Dim&gt;(UniformGridPartition&lt;Dim&gt;()));
-}
-
-template &lt;int Dim&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-	   const ReplicatedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-
-  // Initialize our global domain, and then do the partitioning.
-
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(),
-		     LocalMapper&lt;Dim&gt;());
-}
-
-template &lt;int Dim&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-	   const GuardLayers_t &amp;gcs,
-	   const DistributedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-
-  // Initialize our global domain, and then do the partitioning.
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(gcs),
-		     DistributedMapper&lt;Dim&gt;(UniformGridPartition&lt;Dim&gt;(gcs) ));
-}
-
-template &lt;int Dim&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-	   const GuardLayers_t &amp;gcs,
-	   const ReplicatedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-
-  // Initialize our global domain, and then do the partitioning.
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(gcs),
-		     LocalMapper&lt;Dim&gt;());
-}
-
-template &lt;int Dim&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-	   const Loc&lt;Dim&gt; &amp;blocks,
-	   const DistributedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-
-  // Initialize our global domain, and then do the partitioning.
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks),
-		    DistributedMapper&lt;Dim&gt;(UniformGridPartition&lt;Dim&gt;(blocks)));
-}
-
-template &lt;int Dim&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-	   const Loc&lt;Dim&gt; &amp;blocks,
-	   const ReplicatedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks),
-		     LocalMapper&lt;Dim&gt;());
-}
-
-template &lt;int Dim&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-           const Loc&lt;Dim&gt; &amp;blocks,
-           const GuardLayers_t &amp;gcs,
-	   const DistributedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks, gcs),
-		     DistributedMapper&lt;Dim&gt;(
-		       UniformGridPartition&lt;Dim&gt;(blocks, gcs)));
-}
-
-template &lt;int Dim&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-           const Loc&lt;Dim&gt; &amp;blocks,
-           const GuardLayers_t &amp;gcs,
-	   const ReplicatedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks, gcs),
-		     LocalMapper&lt;Dim&gt;());
-}
-
-template &lt;int Dim&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-           const Loc&lt;Dim&gt; &amp;blocks,
-           const GuardLayers_t &amp;igcs,
-           const GuardLayers_t &amp;egcs,
-	   const DistributedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-
-  // Initialize our global domain, and then do the partitioning.
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks, igcs, egcs),
-		     DistributedMapper&lt;Dim&gt;(
-		       UniformGridPartition&lt;Dim&gt;(blocks, igcs, egcs)));
-}
-
-template &lt;int Dim&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-           const Loc&lt;Dim&gt; &amp;blocks,
-           const GuardLayers_t &amp;igcs,
-           const GuardLayers_t &amp;egcs,
-	   const ReplicatedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-
-  // Initialize our global domain, and then do the partitioning.
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;blocks_m = blocks;
-  this-&gt;pdata_m-&gt;partition(UniformGridPartition&lt;Dim&gt;(blocks, igcs, egcs),
-		     LocalMapper&lt;Dim&gt;());
-}
-
-
-template &lt;int Dim&gt;
-template &lt;class Partitioner&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-           const Partitioner &amp;p,
-	   const DistributedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-
-  // Initialize our global domain, and then do the partitioning.
-
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;blocks_m = p.blocks();
-  this-&gt;pdata_m-&gt;partition(p,DistributedMapper&lt;Dim&gt;(p));
-}
-
-template &lt;int Dim&gt;
-template &lt;class Partitioner&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-           const Partitioner &amp;p,
-	   const ReplicatedTag &amp;)
-{
-  PAssert(!this-&gt;initialized());
-
-  // Initialize our global domain, and then do the partitioning.
-
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;blocks_m = p.blocks();
-  this-&gt;pdata_m-&gt;partition(p,LocalMapper&lt;Dim&gt;());
-}
-template &lt;int Dim&gt;
-template &lt;class Partitioner&gt;
-inline void
-UniformGridLayout&lt;Dim&gt;::
-initialize(const Domain_t &amp;gdom,
-           const Partitioner &amp;p,
-	   const ContextMapper&lt;Dim&gt; &amp;cmap)
-{
-  PAssert(!this-&gt;initialized());
-
-  // Initialize our global domain, and then do the partitioning.
-
-  this-&gt;pdata_m-&gt;innerdomain_m = gdom;
-  this-&gt;pdata_m-&gt;domain_m = gdom;
-  this-&gt;pdata_m-&gt;blocks_m = p.blocks();
-  this-&gt;pdata_m-&gt;partition(p,cmap);
-}
-
-// This initializer is intented to be used by the I/O system
-
-template &lt;int Dim&gt;
-void UniformGridLayout&lt;Dim&gt;::initialize(const Domain_t&amp; idom,
-				 const List_t&amp; nodes,
-				 const Loc&lt;Dim&gt;&amp; blocks,
-				 bool hasIG, bool hasEG,
-				 const GuardLayers_t&amp; ig,
-				 const GuardLayers_t&amp; eg)
-{
-  this-&gt;pdata_m-&gt;initialize(idom,nodes,blocks,hasIG,hasEG,ig,eg);
-}
-
-// Here are the implementations for globalID:
-
-template &lt;int Dim&gt;
-inline int
-UniformGridLayoutData&lt;Dim&gt;::globalID(const Loc&lt;Dim&gt; &amp;loc) const
-{
-  // Make sure the point is in our domain.
-  PAssert(contains(this-&gt;domain_m, loc));
-  int currloc;
-
-  if (!this-&gt;hasExternalGuards_m)
-    {
-      currloc = (loc[0].first() - this-&gt;firsti_m[0]) / blocksizes_m[0];
-      for (int d = 1; d &lt; Dim; ++d)
-        currloc += blockstride_m[d] *
-          ((loc[d].first() - this-&gt;firsti_m[d]) / blocksizes_m[d]);
-    }
-  else
-    {
-      currloc = 0;
-      for (int d = 0; d &lt; Dim; ++d)
-        {
-          int l = loc[d].first();
-
-          // If l &lt; this-&gt;firsti_m[0], currloc is unchanged.
-
-          if (l &gt;= this-&gt;firsti_m[d])
-            {
-              if (l &lt;= this-&gt;innerdomain_m[d].last())
-                {
-                  // The usual expression in this direction.
-
-                  currloc += blockstride_m[d] *
-                    ((l - this-&gt;firsti_m[d]) / blocksizes_m[d]);
-                }
-              else
-                {
-                  // Must be in the last block in this direction.
-
-                  currloc += blockstride_m[d] * allDomain_m[d].last();
-                }
-            }
-        }
-    }
-
-  // Return the globalID for the currloc's node
-
-  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
-  return currloc;
-}
-
-template &lt;int Dim&gt;
-inline int
-UniformGridLayoutData&lt;Dim&gt;::globalID(int i0) const
-{
-  PAssert(Dim == 1);
-  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
-
-  // Compute fortran-order index from position in block grid
-  // See the Loc&lt;Dim&gt; version for comments.
-
-  int currloc;
-  if (!this-&gt;hasExternalGuards_m)
-    {
-      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
-    }
-  else
-    {
-      currloc = 0;
-      if (i0 &gt;= this-&gt;firsti_m[0]) {
-        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
-          currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
-        else
-          currloc = allDomain_m[0].last();
-      }
-    }
-
-  // Return the globalID for the currloc's node.
-
-  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
-  return currloc;
-}
-
-template &lt;int Dim&gt;
-inline int
-UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1) const
-{
-  PAssert(Dim == 2);
-  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
-  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
-
-  // Compute fortran-order index from position in block grid
-
-  int currloc;
-  if (!this-&gt;hasExternalGuards_m)
-    {
-      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
-              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
-    }
-  else
-    {
-      currloc = 0;
-      if (i0 &gt;= this-&gt;firsti_m[0]) {
-        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
-          currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
-        else
-          currloc = allDomain_m[0].last();
-      }
-      if (i1 &gt;= this-&gt;firsti_m[1]) {
-        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
-          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
-        else
-          currloc += blockstride_m[1] * allDomain_m[1].last();
-      }
-    }
-
-  // Return the globalID for the currloc's node
-
-  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
-  return currloc;
-}
-
-template &lt;int Dim&gt;
-inline int
-UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1, int i2) const
-{
-  PAssert(Dim == 3);
-  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
-  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
-  PAssert(i2 &gt;= this-&gt;domain_m[2].first() &amp;&amp; i2 &lt;= this-&gt;domain_m[2].last());
-
-  // Compute fortran-order index from position in block grid
-
-  int currloc;
-  if (!this-&gt;hasExternalGuards_m)
-    {
-      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
-              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1])
-              + blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
-    }
-  else
-    {
-      currloc = 0;
-      if (i0 &gt;= this-&gt;firsti_m[0]) {
-        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
-          currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
-        else
-          currloc = allDomain_m[0].last();
-      }
-      if (i1 &gt;= this-&gt;firsti_m[1]) {
-        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
-          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
-        else
-          currloc += blockstride_m[1] * allDomain_m[1].last();
-      }
-      if (i2 &gt;= this-&gt;firsti_m[2]) {
-        if (i2 &lt;= this-&gt;innerdomain_m[2].last())
-          currloc += blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
-        else
-          currloc += blockstride_m[2] * allDomain_m[2].last();
-      }
-    }
-
-  // Return the globalID for the currloc's node
-
-  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
-  return currloc;
-}
-
-template &lt;int Dim&gt;
-inline int
-UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1, int i2, int i3) const
-{
-  PAssert(Dim == 4);
-  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
-  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
-  PAssert(i2 &gt;= this-&gt;domain_m[2].first() &amp;&amp; i2 &lt;= this-&gt;domain_m[2].last());
-  PAssert(i3 &gt;= this-&gt;domain_m[3].first() &amp;&amp; i3 &lt;= this-&gt;domain_m[3].last());
-
-  // Compute fortran-order index from position in block grid
-
-  int currloc;
-  if (!this-&gt;hasExternalGuards_m)
-    {
-      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
-              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1])
-              + blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2])
-              + blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3]);
-    }
-  else
-    {
-      currloc = 0;
-      if (i0 &gt;= this-&gt;firsti_m[0]) {
-        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
-           currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
-        else
-           currloc = allDomain_m[0].last();
-      }
-      if (i1 &gt;= this-&gt;firsti_m[1]) {
-        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
-          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
-        else
-          currloc += blockstride_m[1] * allDomain_m[1].last();
-      }
-      if (i2 &gt;= this-&gt;firsti_m[2]) {
-        if (i2 &lt;= this-&gt;innerdomain_m[2].last())
-          currloc += blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
-        else
-          currloc += blockstride_m[2] * allDomain_m[2].last();
-      }
-      if (i3 &gt;= this-&gt;firsti_m[3]) {
-        if (i3 &lt;= this-&gt;innerdomain_m[3].last())
-          currloc += blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3]);
-        else
-          currloc += blockstride_m[3] * allDomain_m[3].last();
-      }
-    }
-
-  // Return the globalID for the currloc's node
-
-  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
-  return currloc;
-}
-
-template &lt;int Dim&gt;
-inline int
-UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1, int i2, int i3,
-                                     int i4) const
-{
-  PAssert(Dim == 5);
-  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
-  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
-  PAssert(i2 &gt;= this-&gt;domain_m[2].first() &amp;&amp; i2 &lt;= this-&gt;domain_m[2].last());
-  PAssert(i3 &gt;= this-&gt;domain_m[3].first() &amp;&amp; i3 &lt;= this-&gt;domain_m[3].last());
-  PAssert(i4 &gt;= this-&gt;domain_m[4].first() &amp;&amp; i4 &lt;= this-&gt;domain_m[4].last());
-
-  // Compute fortran-order index from position in block grid
-
-  int currloc;
-  if (!this-&gt;hasExternalGuards_m)
-    {
-      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
-              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1])
-              + blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2])
-              + blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3])
-              + blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4]);
-    }
-  else
-    {
-      currloc = 0;
-      if (i0 &gt;= this-&gt;firsti_m[0]) {
-        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
-           currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
-        else
-           currloc = allDomain_m[0].last();
-      }
-      if (i1 &gt;= this-&gt;firsti_m[1]) {
-        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
-          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
-        else
-          currloc += blockstride_m[1] * allDomain_m[1].last();
-      }
-      if (i2 &gt;= this-&gt;firsti_m[2]) {
-        if (i2 &lt;= this-&gt;innerdomain_m[2].last())
-          currloc += blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
-        else
-          currloc += blockstride_m[2] * allDomain_m[2].last();
-      }
-      if (i3 &gt;= this-&gt;firsti_m[3]) {
-        if (i3 &lt;= this-&gt;innerdomain_m[3].last())
-          currloc += blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3]);
-        else
-          currloc += blockstride_m[3] * allDomain_m[3].last();
-      }
-      if (i4 &gt;= this-&gt;firsti_m[4]) {
-        if (i4 &lt;= this-&gt;innerdomain_m[4].last())
-          currloc += blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4]);
-        else
-          currloc += blockstride_m[4] * allDomain_m[4].last();
-      }
-    }
-
-  // Return the globalID for the currloc's node
-
-  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
-  return currloc;
-}
-
-template &lt;int Dim&gt;
-inline int
-UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1, int i2, int i3,
-                                     int i4, int i5) const
-{
-  PAssert(Dim == 6);
-  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
-  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
-  PAssert(i2 &gt;= this-&gt;domain_m[2].first() &amp;&amp; i2 &lt;= this-&gt;domain_m[2].last());
-  PAssert(i3 &gt;= this-&gt;domain_m[3].first() &amp;&amp; i3 &lt;= this-&gt;domain_m[3].last());
-  PAssert(i4 &gt;= this-&gt;domain_m[4].first() &amp;&amp; i4 &lt;= this-&gt;domain_m[4].last());
-  PAssert(i5 &gt;= this-&gt;domain_m[5].first() &amp;&amp; i5 &lt;= this-&gt;domain_m[5].last());
-
-  // Compute fortran-order index from position in block grid
-
-  int currloc;
-  if (!this-&gt;hasExternalGuards_m)
-    {
-      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
-              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1])
-              + blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2])
-              + blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3])
-              + blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4])
-              + blockstride_m[5] * ((i5 - this-&gt;firsti_m[5]) / blocksizes_m[5]);
-    }
-  else
-    {
-      currloc = 0;
-      if (i0 &gt;= this-&gt;firsti_m[0]) {
-        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
-           currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
-        else
-           currloc = allDomain_m[0].last();
-      }
-      if (i1 &gt;= this-&gt;firsti_m[1]) {
-        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
-          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
-        else
-          currloc += blockstride_m[1] * allDomain_m[1].last();
-      }
-      if (i2 &gt;= this-&gt;firsti_m[2]) {
-        if (i2 &lt;= this-&gt;innerdomain_m[2].last())
-          currloc += blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
-        else
-          currloc += blockstride_m[2] * allDomain_m[2].last();
-      }
-      if (i3 &gt;= this-&gt;firsti_m[3]) {
-        if (i3 &lt;= this-&gt;innerdomain_m[3].last())
-          currloc += blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3]);
-        else
-          currloc += blockstride_m[3] * allDomain_m[3].last();
-      }
-      if (i4 &gt;= this-&gt;firsti_m[4]) {
-        if (i4 &lt;= this-&gt;innerdomain_m[4].last())
-          currloc += blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4]);
-        else
-          currloc += blockstride_m[4] * allDomain_m[4].last();
-      }
-      if (i5 &gt;= this-&gt;firsti_m[5]) {
-        if (i5 &lt;= this-&gt;innerdomain_m[5].last())
-          currloc += blockstride_m[5] * ((i5 - this-&gt;firsti_m[5]) / blocksizes_m[5]);
-        else
-          currloc += blockstride_m[5] * allDomain_m[5].last();
-      }
-    }
-
-  // Return the globalID for the currloc's node
-
-  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
-  return currloc;
-}
-
-template &lt;int Dim&gt;
-inline int
-UniformGridLayoutData&lt;Dim&gt;::globalID(int i0, int i1, int i2, int i3,
-                                     int i4, int i5, int i6) const
-{
-  PAssert(Dim == 7);
-  PAssert(i0 &gt;= this-&gt;domain_m[0].first() &amp;&amp; i0 &lt;= this-&gt;domain_m[0].last());
-  PAssert(i1 &gt;= this-&gt;domain_m[1].first() &amp;&amp; i1 &lt;= this-&gt;domain_m[1].last());
-  PAssert(i2 &gt;= this-&gt;domain_m[2].first() &amp;&amp; i2 &lt;= this-&gt;domain_m[2].last());
-  PAssert(i3 &gt;= this-&gt;domain_m[3].first() &amp;&amp; i3 &lt;= this-&gt;domain_m[3].last());
-  PAssert(i4 &gt;= this-&gt;domain_m[4].first() &amp;&amp; i4 &lt;= this-&gt;domain_m[4].last());
-  PAssert(i5 &gt;= this-&gt;domain_m[5].first() &amp;&amp; i5 &lt;= this-&gt;domain_m[5].last());
-  PAssert(i6 &gt;= this-&gt;domain_m[6].first() &amp;&amp; i6 &lt;= this-&gt;domain_m[6].last());
-
-  // Compute fortran-order index from position in block grid
-
-  int currloc;
-  if (!this-&gt;hasExternalGuards_m)
-    {
-      currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0]
-              + blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1])
-              + blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2])
-              + blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3])
-              + blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4])
-              + blockstride_m[5] * ((i5 - this-&gt;firsti_m[5]) / blocksizes_m[5])
-              + blockstride_m[6] * ((i6 - this-&gt;firsti_m[6]) / blocksizes_m[6]);
-    }
-  else
-    {
-      currloc = 0;
-      if (i0 &gt;= this-&gt;firsti_m[0]) {
-        if (i0 &lt;= this-&gt;innerdomain_m[0].last())
-           currloc = (i0 - this-&gt;firsti_m[0]) / blocksizes_m[0];
-        else
-           currloc = allDomain_m[0].last();
-      }
-      if (i1 &gt;= this-&gt;firsti_m[1]) {
-        if (i1 &lt;= this-&gt;innerdomain_m[1].last())
-          currloc += blockstride_m[1] * ((i1 - this-&gt;firsti_m[1]) / blocksizes_m[1]);
-        else
-          currloc += blockstride_m[1] * allDomain_m[1].last();
-      }
-      if (i2 &gt;= this-&gt;firsti_m[2]) {
-        if (i2 &lt;= this-&gt;innerdomain_m[2].last())
-          currloc += blockstride_m[2] * ((i2 - this-&gt;firsti_m[2]) / blocksizes_m[2]);
-        else
-          currloc += blockstride_m[2] * allDomain_m[2].last();
-      }
-      if (i3 &gt;= this-&gt;firsti_m[3]) {
-        if (i3 &lt;= this-&gt;innerdomain_m[3].last())
-          currloc += blockstride_m[3] * ((i3 - this-&gt;firsti_m[3]) / blocksizes_m[3]);
-        else
-          currloc += blockstride_m[3] * allDomain_m[3].last();
-      }
-      if (i4 &gt;= this-&gt;firsti_m[4]) {
-        if (i4 &lt;= this-&gt;innerdomain_m[4].last())
-          currloc += blockstride_m[4] * ((i4 - this-&gt;firsti_m[4]) / blocksizes_m[4]);
-        else
-          currloc += blockstride_m[4] * allDomain_m[4].last();
-      }
-      if (i5 &gt;= this-&gt;firsti_m[5]) {
-        if (i5 &lt;= this-&gt;innerdomain_m[5].last())
-          currloc += blockstride_m[5] * ((i5 - this-&gt;firsti_m[5]) / blocksizes_m[5]);
-        else
-          currloc += blockstride_m[5] * allDomain_m[5].last();
-      }
-      if (i6 &gt;= this-&gt;firsti_m[6]) {
-        if (i6 &lt;= this-&gt;innerdomain_m[6].last())
-          currloc += blockstride_m[6] * ((i6 - this-&gt;firsti_m[6]) / blocksizes_m[6]);
-        else
-          currloc += blockstride_m[6] * allDomain_m[6].last();
-      }
-    }
-
-  // Return the globalID for the currloc's node
-
-  PAssert(currloc &gt;= 0 &amp;&amp; currloc &lt; this-&gt;all_m.size());
-  return currloc;
-}

 //============================================================
 // NewDomain1 traits classes for UniformGridLayout and

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001395.html">[PATCH] Add missing methods to DomainLayout
</A></li>
	<LI>Next message: <A HREF="001393.html">[PATCH] Obvious stuff
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1392">[ date ]</a>
              <a href="thread.html#1392">[ thread ]</a>
              <a href="subject.html#1392">[ subject ]</a>
              <a href="author.html#1392">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
