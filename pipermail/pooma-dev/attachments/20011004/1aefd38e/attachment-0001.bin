Index: examples/Field/ScalarAdvection/ScalarAdvection.cpp===================================================================RCS file: /home/pooma/Repository/r2/examples/Field/ScalarAdvection/ScalarAdvection.cpp,vretrieving revision 1.10diff -p -c -2 -r1.10 ScalarAdvection.cpp*** examples/Field/ScalarAdvection/ScalarAdvection.cpp  2001/09/21 20:27:21     1.10--- examples/Field/ScalarAdvection/ScalarAdvection.cpp  2001/10/04 21:40:32****************** 28,95 ****    // ----------------------------------------------------------------------------! // Scalar advection example, illustrating use of Field, Mesh, DiscreteGeometry,! // and the canned second-order divergence operator div<Cell>()  // ----------------------------------------------------------------------------    #include "Pooma/Fields.h"  ! #include <iostream>    int main(int argc, char *argv[])  {    // Set up the library    Pooma::initialize(argc,argv);  !   // Create the physical domains:  -   // Set the dimensionality:    const int Dim    = 1;!   const int nVerts = 129;    const int nCells = nVerts - 1;-   Interval<Dim> vertexDomain;    int d;!   for (d = 0; d < Dim; d++)!   {!     vertexDomain[d] = Interval<1>(nVerts);!   }      // Create the (uniform, logically rectilinear) mesh.    Vector<Dim> origin(0.0), spacings(0.2);    typedef UniformRectilinearMesh<Dim> Mesh_t;!   Mesh_t mesh(vertexDomain, origin, spacings);! !   // Create two geometry objects - one allowing 1 guard layer to account for!   // stencil width and another with no guard layers to support temporaries:!   typedef DiscreteGeometry<Cell, UniformRectilinearMesh<Dim> > Geometry_t;!   Geometry_t geom(mesh, GuardLayers<Dim>(1));!   Geometry_t geomNG(mesh);!     // Create the Fields:      // The flow Field u(x,t):!   Field<Geometry_t> u(geom);    // The same, stored at the previous timestep for staggered leapfrog    // plus a useful temporary:!   Field<Geometry_t> uPrev(geomNG), uTemp(geomNG);      // Initialize Fields to zero everywhere, even global guard layers:    u.all() = 0.0;      // Set up periodic boundary conditions on all mesh faces:!   Pooma::addAllPeriodicFaceBC(u, 0.0);      // Load initial condition u(x,0), a symmetric pulse centered around nCells/4    // and decaying to zero away from nCells/4 all directions, with a height of    // 1.0, with a half-width of nCells/8:!   const double pulseWidth = spacings(0)*nCells/8;    Loc<Dim> pulseCenter;!   for (d = 0; d < Dim; d++) { pulseCenter[d] = Loc<1>(nCells/4); }!   Vector<Dim> u0 = u.x(pulseCenter);!   u = 1.0 * exp(-dot(u.x() - u0, u.x() - u0) / (2.0 * pulseWidth));      // Output the initial field on its physical domain:-   std::cout << "Time = 0:\n";-   std::cout << u() << std::endl;      const Vector<Dim> v(0.2);   // Propagation velocity    const double dt = 0.1;      // Timestep--- 28,121 ----    // ----------------------------------------------------------------------------! // Scalar advection example, illustrating use of Field, UniformRectilinearMesh,! // and the canned second-order divergence operator divCellToCell()  // ----------------------------------------------------------------------------    #include "Pooma/Fields.h"  ! #if POOMA_CHEETAH!   typedef DistributedTag LayoutTag_t;!   typedef Remote<CompressibleBrick> BrickTag_t;! #else!   typedef ReplicatedTag LayoutTag_t;!   typedef CompressibleBrick BrickTag_t;! #endif  + using namespace std;+   int main(int argc, char *argv[])  {    // Set up the library+       Pooma::initialize(argc,argv);  !   // Create the physical domains      const int Dim    = 1;!   const int nVerts = 128;    const int nCells = nVerts - 1;    int d;!   Interval<Dim> vertexDomain;!   for (d = 0; d < Dim; d++) { vertexDomain[d] = Interval<1>(nVerts); }  +   // Create some layouts.+   +   Loc<Dim> patches(8);+   UniformGridLayout<Dim> layout(vertexDomain, patches, +                               GuardLayers<Dim>(1), GuardLayers<Dim>(1), +                               LayoutTag_t());+   UniformGridLayout<Dim> layoutNG(vertexDomain, patches, LayoutTag_t());+   typedef MultiPatch<UniformTag, BrickTag_t> MP_t;+       // Create the (uniform, logically rectilinear) mesh.+       Vector<Dim> origin(0.0), spacings(0.2);    typedef UniformRectilinearMesh<Dim> Mesh_t;!   Mesh_t mesh(layout, origin, spacings);!   Mesh_t meshNG(layoutNG, origin, spacings);!   !   // Create the centering.!   !   Centering<Dim> cell = canonicalCentering<Dim>(CellType, Continuous);!       // Create the Fields:      // The flow Field u(x,t):!   !   Field<Mesh_t, double, MP_t> u(cell, layout, mesh);!   Field<Mesh_t, Vector<Dim>, MP_t> dtvu(cell, layout, mesh);!       // The same, stored at the previous timestep for staggered leapfrog    // plus a useful temporary:!   !   Field<Mesh_t, double, MP_t> uPrev(cell, layoutNG, meshNG), !     uTemp(cell, layoutNG, meshNG);      // Initialize Fields to zero everywhere, even global guard layers:+       u.all() = 0.0;      // Set up periodic boundary conditions on all mesh faces:!   !   Pooma::addAllPeriodicFaceBC(u);      // Load initial condition u(x,0), a symmetric pulse centered around nCells/4    // and decaying to zero away from nCells/4 all directions, with a height of    // 1.0, with a half-width of nCells/8:!   !   const double pulseWidth = spacings(0)  * nCells / 8;    Loc<Dim> pulseCenter;!   for (d = 0; d < Dim; d++) { pulseCenter[d] = Loc<1>(nCells / 4); }!   !   PositionsTraits<Mesh_t>::Type_t ux = positions(u);!   Vector<Dim> u0 = ux.read(pulseCenter);!   u = 1.0 * exp(-dot(ux - u0, ux - u0) / (2.0 * pulseWidth));      // Output the initial field on its physical domain:  +   Inform iout;+   iout << "Time = 0:\n";+   iout << u() << endl;+     const Vector<Dim> v(0.2);   // Propagation velocity    const double dt = 0.1;      // Timestep*************** int main(int argc, char *argv[])*** 97,122 ****    // Prime the leapfrog by setting the field at the previous timestep using the    // initial conditions:    uPrev = u;      // Do a preliminary timestep using forward Euler, using the canned POOMA    // stencil-based divergence operator div() for the spatial difference:-   u -= div<Cell>(v * dt * u);      // Now use staggered leapfrog (second-order) for the remaining timesteps.    // The spatial derivative is just the second-order finite difference in the    // canned POOMA stencil-based divergence operator div():    for (int timestep = 2; timestep <= 1000; timestep++)-   {-     uTemp = u;-     u = uPrev - 2.0 * div<Cell>(v * dt * u);-     if ((timestep % 100) == 0)      {!       // Output the field on its physical domain at the current timestep:!       std::cout << "Time = " << timestep*dt << ":\n";!       std::cout << u() << std::endl;      }!     uPrev = uTemp;!   }!     Pooma::finalize();    return 0;--- 123,154 ----    // Prime the leapfrog by setting the field at the previous timestep using the    // initial conditions:+     uPrev = u;      // Do a preliminary timestep using forward Euler, using the canned POOMA    // stencil-based divergence operator div() for the spatial difference:  +   dtvu.all() = dt * v * u.all();+   u -= divCellToCell(dtvu);+     // Now use staggered leapfrog (second-order) for the remaining timesteps.    // The spatial derivative is just the second-order finite difference in the    // canned POOMA stencil-based divergence operator div():+       for (int timestep = 2; timestep <= 1000; timestep++)      {!       uTemp = u;!       dtvu.all() = dt * v * u.all();!       u = uPrev - 2.0 * divCellToCell(dtvu);!       if ((timestep % 100) == 0)!       {!         // Output the field on its physical domain at the current timestep:!         !         iout << "Time = " << timestep*dt << ":\n";!         iout << u() << endl;!       }!       uPrev = uTemp;      }!       Pooma::finalize();    return 0;Index: src/Field/DiffOps/Div.UR.h===================================================================RCS file: /home/pooma/Repository/r2/src/Field/DiffOps/Div.UR.h,vretrieving revision 1.1diff -p -c -2 -r1.1 Div.UR.h*** src/Field/DiffOps/Div.UR.h  2001/08/30 01:15:09     1.1--- src/Field/DiffOps/Div.UR.h  2001/10/04 21:40:33*************** private:*** 241,248 ****  };  ! template<class T2, class Mesh, int OC>  class DivSameToSame;  ! template<class T2, int Dim, class TM, int OC>  class DivSameToSame<Vector<Dim, T2>, UniformRectilinearMesh<Dim, TM>, OC>  {--- 241,248 ----  };  ! template<class T2, class Mesh, CenteringType OC>  class DivSameToSame;  ! template<class T2, int Dim, class TM, CenteringType OC>  class DivSameToSame<Vector<Dim, T2>, UniformRectilinearMesh<Dim, TM>, OC>  {*************** public:*** 285,289 ****      }      inputCentering_m = fieldEngine.centering();!     PAssert(inputCentering_m == outputCentering);    }  --- 285,291 ----      }      inputCentering_m = fieldEngine.centering();! !     // FIXME: need operator== for centerings!     //PAssert(inputCentering_m == outputCentering);    }  Index: src/Field/DiffOps/Div.h===================================================================RCS file: /home/pooma/Repository/r2/src/Field/DiffOps/Div.h,vretrieving revision 1.8diff -p -c -2 -r1.8 Div.h*** src/Field/DiffOps/Div.h     2001/08/30 01:15:09     1.8--- src/Field/DiffOps/Div.h     2001/10/04 21:40:33*************** template<class T2, class Mesh>*** 108,112 ****  class DivVertToCell;  ! template<class T2, class Mesh, int OC>  class DivSameToSame;  --- 108,112 ----  class DivVertToCell;  ! template<class T2, class Mesh, CenteringType OC>  class DivSameToSame;  Index: src/Field/FieldEngine/FieldEngine.ExprEngine.h===================================================================RCS file: /home/pooma/Repository/r2/src/Field/FieldEngine/FieldEngine.ExprEngine.h,vretrieving revision 1.2diff -p -c -2 -r1.2 FieldEngine.ExprEngine.h*** src/Field/FieldEngine/FieldEngine.ExprEngine.h      2001/09/10 21:41:26     1.2--- src/Field/FieldEngine/FieldEngine.ExprEngine.h      2001/10/04 21:40:33*************** public:*** 192,196 ****      ReferenceField_t;  -     //---------------------------------------------------------------------------    // Constructors.--- 192,195 ----*************** public:*** 281,285 ****    }    -     //---------------------------------------------------------------------------    // Domain accessor functions. --- 280,283 ----*************** public:*** 332,335 ****--- 330,346 ----        return referenceField_m.numMaterials();      }+ +   //---------------------------------------------------------------------------+   // Mesh accessors.+ +   Mesh &mesh()+   {+     return referenceField_m.mesh();+   }        + +   const Mesh &mesh() const+   {+     return referenceField_m.mesh();+   }                  Index: src/Field/FieldEngine/FieldEngine.h===================================================================RCS file: /home/pooma/Repository/r2/src/Field/FieldEngine/FieldEngine.h,vretrieving revision 1.1diff -p -c -2 -r1.1 FieldEngine.h*** src/Field/FieldEngine/FieldEngine.h 2001/08/30 01:15:10     1.1--- src/Field/FieldEngine/FieldEngine.h 2001/10/04 21:40:33****************** 32,37 ****  //-----------------------------------------------------------------------------  ! #ifndef POOMA_FIELD_FIELDENGINE_FIELDENGINEBASE_H! #define POOMA_FIELD_FIELDENGINE_FIELDENGINEBASE_H    //-------------------------------------------------------------------------------- 32,37 ----  //-----------------------------------------------------------------------------  ! #ifndef POOMA_FIELD_FIELDENGINE_FIELDENGINE_H! #define POOMA_FIELD_FIELDENGINE_FIELDENGINE_H    //-----------------------------------------------------------------------------*************** struct LeafFunctor<FieldEngine<Mesh, T, *** 688,692 ****  };  ! #endif // POOMA_FIELD_FIELDENGINE_FIELDENGINEBASE_H    // ACL:rcsinfo--- 688,692 ----  };  ! #endif // POOMA_FIELD_FIELDENGINE_FIELDENGINE_H    // ACL:rcsinfoIndex: src/Field/Relations/PeriodicFaceBC.h===================================================================RCS file: /home/pooma/Repository/r2/src/Field/Relations/PeriodicFaceBC.h,vretrieving revision 1.1diff -p -c -2 -r1.1 PeriodicFaceBC.h*** src/Field/Relations/PeriodicFaceBC.h        2001/08/30 01:15:12     1.1--- src/Field/Relations/PeriodicFaceBC.h        2001/10/04 21:40:33*************** public:*** 90,99 ****               int d = face_m / 2;                 !     int adjust;!     if (t.fieldEngine().offsets()[d].min() == 1) !       adjust = 1;!     else!       adjust = 0;                // Select the high or low face.--- 90,97 ----               int d = face_m / 2;+ +     // Check if we're on a vertex in the current direction.                 !     int adjust = 1 - t.centering().orientation(0)[d].min();                // Select the high or low face.*************** public:*** 104,108 ****          // Get the number of guard layers in the upper direction.          !         int nGuards = subject().fieldEngine().guardLayers().upper(d);                      // Adjust the domain.--- 102,106 ----          // Get the number of guard layers in the upper direction.          !         int nGuards = t.fieldEngine().guardLayers().upper(d);                      // Adjust the domain.*************** public:*** 127,135 ****        // Get the number of guard layers in the lower direction.  !         int nGuards = subject().fieldEngine().guardLayers().lower(d);                      // Adjust the domain.                     !       domain_m[d] = Interval<1>(domain_m[d].min() + (nGuards - 1));          // The source domain is just the destination domain offset by the--- 125,134 ----        // Get the number of guard layers in the lower direction.  !         int nGuards = t.fieldEngine().guardLayers().lower(d);                      // Adjust the domain.                     !       domain_m[d] = Interval<1>(domain_m[d].min(), !                                 domain_m[d].min() + (nGuards - 1));          // The source domain is just the destination domain offset by the*************** public:*** 137,143 ****          srcDomain_m[d] = !         Interval<1>(domain_m[d].min() -                       (t.physicalDomain()[d].length() - adjust),!                      domain_m[d].max() -                        (t.physicalDomain()[d].length() - adjust));        }--- 136,142 ----          srcDomain_m[d] = !         Interval<1>(domain_m[d].min() +                       (t.physicalDomain()[d].length() - adjust),!                      domain_m[d].max() +                        (t.physicalDomain()[d].length() - adjust));        }Index: src/Pooma/Fields.h===================================================================RCS file: /home/pooma/Repository/r2/src/Pooma/Fields.h,vretrieving revision 1.11diff -p -c -2 -r1.11 Fields.h*** src/Pooma/Fields.h  2001/08/30 01:15:42     1.11--- src/Pooma/Fields.h  2001/10/04 21:40:33****************** 62,65 ****--- 62,70 ----  #include "Field/Relations/PeriodicFaceBC.h"  + // Differential Operators:+ + #include "Field/DiffOps/Div.UR.h"+ #include "Field/DiffOps/Div.h"+   // Other stuff: