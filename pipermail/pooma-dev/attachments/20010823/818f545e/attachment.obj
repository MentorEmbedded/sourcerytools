Index: benchmarks/Doof2d/Doof2dInP2.h
===================================================================
RCS file: /home/pooma/Repository/r2/benchmarks/Doof2d/Doof2dInP2.h,v
retrieving revision 1.38.2.1
diff -c -p -r1.38.2.1 Doof2dInP2.h
*** benchmarks/Doof2d/Doof2dInP2.h	2001/08/08 23:35:21	1.38.2.1
--- benchmarks/Doof2d/Doof2dInP2.h	2001/08/23 22:59:12
*************** public:
*** 53,59 ****
  
    // Typedefs for the Array types we'll be using here.
  
!   typedef Field<UniformRectilinear<2>, double, Brick> Field2D;
  
    // This is a Pooma II benchmark
  
--- 53,59 ----
  
    // Typedefs for the Array types we'll be using here.
  
!   typedef Field<UniformRectilinearMesh<2>, double, Brick> Field2D;
  
    // This is a Pooma II benchmark
  
Index: examples/NewField/Caramana/Caramana.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/NewField/Caramana/Caramana.cpp,v
retrieving revision 1.1
diff -c -p -r1.1 Caramana.cpp
*** examples/NewField/Caramana/Caramana.cpp	2001/06/20 23:36:32	1.1
--- examples/NewField/Caramana/Caramana.cpp	2001/08/23 22:59:13
*************** int main(int argc, char *argv[])
*** 123,129 ****
    // Preparation for Field creation.
    Vector<Dim> origin(0.0);
    Vector<Dim> spacings(1.0,1.0);  // TODO: What does this do?
!   typedef UniformRectilinear<Dim, double, Cartesian<Dim> > Geometry_t;
    typedef Field<Geometry_t, double,      Brick> Fields_t;
    typedef Field<Geometry_t, double,      Brick> ConstFields_t; // TODO: Change to ConstField when ConstField is available.
    typedef Field<Geometry_t, Vector<Dim>, Brick> Fieldv_t;
--- 123,129 ----
    // Preparation for Field creation.
    Vector<Dim> origin(0.0);
    Vector<Dim> spacings(1.0,1.0);  // TODO: What does this do?
!   typedef UniformRectilinearMesh<Dim, double> Geometry_t;
    typedef Field<Geometry_t, double,      Brick> Fields_t;
    typedef Field<Geometry_t, double,      Brick> ConstFields_t; // TODO: Change to ConstField when ConstField is available.
    typedef Field<Geometry_t, Vector<Dim>, Brick> Fieldv_t;
Index: examples/NewField/StatigraphicFlow/StatigraphicFlow.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/examples/NewField/StatigraphicFlow/Attic/StatigraphicFlow.cpp,v
retrieving revision 1.1.2.2
diff -c -p -r1.1.2.2 StatigraphicFlow.cpp
*** examples/NewField/StatigraphicFlow/StatigraphicFlow.cpp	2001/08/16 20:29:09	1.1.2.2
--- examples/NewField/StatigraphicFlow/StatigraphicFlow.cpp	2001/08/23 22:59:13
*************** int main(int argc, char *argv[])
*** 148,154 ****
  
    Vector<Dim> origin(0.0);
    Vector<Dim> spacings(1.0,1.0);
!   typedef UniformRectilinear<Dim, double, Cartesian<Dim> > Geometry_t;
    typedef Field<Geometry_t, double, Brick> Fields_t;
    typedef Tensor<Dim,double,Full> Tensor_t;
    typedef Field<Geometry_t, Tensor_t, Brick> FieldT_t;
--- 148,154 ----
  
    Vector<Dim> origin(0.0);
    Vector<Dim> spacings(1.0,1.0);
!   typedef UniformRectilinearMesh<Dim, double> Geometry_t;
    typedef Field<Geometry_t, double, Brick> Fields_t;
    typedef Tensor<Dim,double,Full> Tensor_t;
    typedef Field<Geometry_t, Tensor_t, Brick> FieldT_t;
Index: src/Engine/BrickEngine.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/BrickEngine.cpp,v
retrieving revision 1.74
diff -c -p -r1.74 BrickEngine.cpp
*** src/Engine/BrickEngine.cpp	2000/07/11 23:06:40	1.74
--- src/Engine/BrickEngine.cpp	2001/08/23 22:59:13
*************** Engine<Dim,T,Brick> &Engine<Dim,T,Brick>
*** 166,171 ****
--- 166,181 ----
  ///////////////////////////////////////////////////////////////////////////////
  
  //-----------------------------------------------------------------------------
+ // Default constructor is required for containers.
+ //-----------------------------------------------------------------------------
+ 
+ template <int Dim, class T>
+ Engine<Dim,T,BrickView>::
+ Engine()
+   : Base_t(), data_m()
+ { }
+ 
+ //-----------------------------------------------------------------------------
  //
  // ~Engine<Dim,T,BrickView<Dim2> >()
  //
Index: src/Engine/BrickEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/BrickEngine.h,v
retrieving revision 1.129
diff -c -p -r1.129 BrickEngine.h
*** src/Engine/BrickEngine.h	2000/07/11 23:06:40	1.129
--- src/Engine/BrickEngine.h	2001/08/23 22:59:13
*************** public:
*** 342,347 ****
--- 342,351 ----
    // its data, and thus there are no constructors that create
    // a BrickView-Engine directly from a domain.
  
+   // Default constructor is required for containers.
+ 
+   Engine();
+ 
    // Copy constructor performs a SHALLOW copy:
  
    Engine(const Engine_t &);
Index: src/Engine/CompressibleBrick.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/CompressibleBrick.h,v
retrieving revision 1.70
diff -c -p -r1.70 CompressibleBrick.h
*** src/Engine/CompressibleBrick.h	2001/05/23 21:13:30	1.70
--- src/Engine/CompressibleBrick.h	2001/08/23 22:59:13
*************** public:
*** 426,431 ****
--- 426,436 ----
    // Constructors and Factory Methods
    //============================================================
  
+   // Default constructor. Creates a CompressibleBrickView-Engine with no
+   // data and an "empty" domain.
+ 
+   Engine() : data0_m(0) { }
+ 
    // Copy constructor performs a SHALLOW copy:
  
    Engine(const Engine_t &model);
Index: src/Engine/ForwardingEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/ForwardingEngine.h,v
retrieving revision 1.42
diff -c -p -r1.42 ForwardingEngine.h
*** src/Engine/ForwardingEngine.h	2001/04/18 03:03:56	1.42
--- src/Engine/ForwardingEngine.h	2001/08/23 22:59:13
*************** public:
*** 107,112 ****
--- 107,119 ----
    enum { multiPatch = Eng::multiPatch };
  
    //---------------------------------------------------------------------------
+   // Empty constructor required for containers of engines.
+ 
+   Engine()
+     : engine_m(), components_m()
+   { }
+ 
+   //---------------------------------------------------------------------------
    // This is the most basic way to build a forwarding engine. We take an
    // engine and a Components giving the components we're supposed to forward.
  
Index: src/Engine/MultiPatchEngine.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/MultiPatchEngine.cpp,v
retrieving revision 1.49
diff -c -p -r1.49 MultiPatchEngine.cpp
*** src/Engine/MultiPatchEngine.cpp	2001/05/23 21:08:41	1.49
--- src/Engine/MultiPatchEngine.cpp	2001/08/23 22:59:13
*************** Engine(const Engine_t &modelEngine)
*** 149,160 ****
      data_m(modelEngine.data_m),
      pDirty_m(modelEngine.pDirty_m)
  {
-   // Make sure the RHS is initialized.
- 
-   PAssert(modelEngine.initialized());
- 
    // Attach ourself to the layout so we can receive messages.
!   
    layout_m.attach(*this);  
  }
  
--- 149,156 ----
      data_m(modelEngine.data_m),
      pDirty_m(modelEngine.pDirty_m)
  {
    // Attach ourself to the layout so we can receive messages.
! 
    layout_m.attach(*this);  
  }
  
*************** operator=(const Engine_t &model)
*** 205,211 ****
   
    // Make sure the RHS is initialized.
  
!   PAssert(model.initialized());
  
    // If we have been previously initialized, clean up ...
  
--- 201,208 ----
   
    // Make sure the RHS is initialized.
  
!   if (!model.initialized())
!     return *this;
  
    // If we have been previously initialized, clean up ...
  
Index: src/Engine/ViewEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/ViewEngine.h,v
retrieving revision 1.22
diff -c -p -r1.22 ViewEngine.h
*** src/Engine/ViewEngine.h	2001/04/11 00:48:36	1.22
--- src/Engine/ViewEngine.h	2001/08/23 22:59:14
*************** public:
*** 107,112 ****
--- 107,120 ----
    enum { multiPatch = ViewedEngine_t::multiPatch };
  
    //---------------------------------------------------------------------------
+   // Default constructor allows engines to be used in containers.
+ 
+   Engine()
+     : eng_m()
+   {
+   }
+ 
+   //---------------------------------------------------------------------------
    // Construct from an existing Engine and various sorts of domains 
    // (e.g., take a view).
  
Index: src/NewField/Field.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/Field.h,v
retrieving revision 1.15.2.10
diff -c -p -r1.15.2.10 Field.h
*** src/NewField/Field.h	2001/08/21 18:26:14	1.15.2.10
--- src/NewField/Field.h	2001/08/23 22:59:14
***************
*** 80,94 ****
  
  struct CompressibleBrick;
  
! template<class GeometryTag, class T, class EngineTag>
  class Field;
  
! template<class GeometryTag, class T, class EngineTag> class FieldEngine;
  
  template<class LTag, class EngineTag>
  struct MultiPatch;
  
! template<int Dim> struct NoGeometry;
  
  struct POOMA_DEFAULT_ENGINE_TYPE;
  
--- 80,94 ----
  
  struct CompressibleBrick;
  
! template<class MeshTag, class T, class EngineTag>
  class Field;
  
! template<class MeshTag, class T, class EngineTag> class FieldEngine;
  
  template<class LTag, class EngineTag>
  struct MultiPatch;
  
! template<int Dim> struct NoMesh;
  
  struct POOMA_DEFAULT_ENGINE_TYPE;
  
*************** class RelationListItem;
*** 117,138 ****
  // right-hand side in an expression with a Field on the left-hand side.
  //-----------------------------------------------------------------------------
    
! template<class GeometryTag, class T, class EngineTag,
!   class GeometryTag2, class T2, class EngineTag2, class Op>
! const Field<GeometryTag, T, EngineTag> &
! assign(const Field<GeometryTag,  T,  EngineTag> &lhs,
!        const Field<GeometryTag2, T2, EngineTag2> &rhs,
         const Op &op);
  
! template<class GeometryTag, class T, class EngineTag, 
   int Dim2, class T2, class EngineTag2, class Op>
! const Field<GeometryTag, T, EngineTag> &
! assign(const Field<GeometryTag, T, EngineTag> &lhs, 
         const Array<Dim2, T2, EngineTag2> &rhs, const Op &op);
  
! template<class GeometryTag, class T, class EngineTag, class T1, class Op>
! const Field<GeometryTag, T, EngineTag> &
! assign(const Field<GeometryTag, T, EngineTag> &lhs, 
         const T1 &rhs, const Op &op);
  
  
--- 117,138 ----
  // right-hand side in an expression with a Field on the left-hand side.
  //-----------------------------------------------------------------------------
    
! template<class MeshTag, class T, class EngineTag,
!   class MeshTag2, class T2, class EngineTag2, class Op>
! const Field<MeshTag, T, EngineTag> &
! assign(const Field<MeshTag,  T,  EngineTag> &lhs,
!        const Field<MeshTag2, T2, EngineTag2> &rhs,
         const Op &op);
  
! template<class MeshTag, class T, class EngineTag, 
   int Dim2, class T2, class EngineTag2, class Op>
! const Field<MeshTag, T, EngineTag> &
! assign(const Field<MeshTag, T, EngineTag> &lhs, 
         const Array<Dim2, T2, EngineTag2> &rhs, const Op &op);
  
! template<class MeshTag, class T, class EngineTag, class T1, class Op>
! const Field<MeshTag, T, EngineTag> &
! assign(const Field<MeshTag, T, EngineTag> &lhs, 
         const T1 &rhs, const Op &op);
  
  
*************** assign(const Field<GeometryTag, T, Engin
*** 143,156 ****
  
  struct SubFieldViewFunctorTag;
  
! template<class GeometryTag, class T, class EngineTag>
! class SubFieldView<Field<GeometryTag, T, EngineTag> > {
    
  public:
    
    // Use it to construct the output field type.
  
!   typedef Field<GeometryTag, T, EngineTag> Type_t;
  
    // The function that actually creates the view.
    
--- 143,156 ----
  
  struct SubFieldViewFunctorTag;
  
! template<class MeshTag, class T, class EngineTag>
! class SubFieldView<Field<MeshTag, T, EngineTag> > {
    
  public:
    
    // Use it to construct the output field type.
  
!   typedef Field<MeshTag, T, EngineTag> Type_t;
  
    // The function that actually creates the view.
    
*************** public:
*** 164,181 ****
      }
  };
  
! template<class GeometryTag, class T, class Expr>
! class SubFieldView<Field<GeometryTag, T, ExpressionTag<Expr> > > {
    
  public:
    
    // Use it to construct the output field type.
  
!   typedef Field<GeometryTag, T, ExpressionTag<Expr> > Subject_t;
    typedef 
      typename ForEach<Expr, SubFieldViewFunctorTag, TreeCombine>::Type_t 
        Expr_t;
!   typedef Field<GeometryTag, T, ExpressionTag<Expr_t> > Type_t;
  
    // The function that actually creates the view.
    
--- 164,181 ----
      }
  };
  
! template<class MeshTag, class T, class Expr>
! class SubFieldView<Field<MeshTag, T, ExpressionTag<Expr> > > {
    
  public:
    
    // Use it to construct the output field type.
  
!   typedef Field<MeshTag, T, ExpressionTag<Expr> > Subject_t;
    typedef 
      typename ForEach<Expr, SubFieldViewFunctorTag, TreeCombine>::Type_t 
        Expr_t;
!   typedef Field<MeshTag, T, ExpressionTag<Expr_t> > Type_t;
  
    // The function that actually creates the view.
    
*************** public:
*** 201,212 ****
  
  // Single-valued version. Handles scalars and Locs.
  
! template<class GeometryTag, class T, class EngineTag, class Domain>
! struct View1Implementation<Field<GeometryTag, T, EngineTag>, Domain, true>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // The return types are pretty simple here.
    
--- 201,212 ----
  
  // Single-valued version. Handles scalars and Locs.
  
! template<class MeshTag, class T, class EngineTag, class Domain>
! struct View1Implementation<Field<MeshTag, T, EngineTag>, Domain, true>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // The return types are pretty simple here.
    
*************** struct View1Implementation<Field<Geometr
*** 317,346 ****
  // It is always a NoGeometry unless the view is from an interval or
  // an INode.
  
! template<int Dim, class GeometryTag, class Domain>
! struct NewGeometryTag
  {
!   typedef NoGeometry<Dim> Type_t;
  };
  
! template<int Dim, class GeometryTag>
! struct NewGeometryTag<Dim, GeometryTag, Interval<Dim> >
  {
!   typedef GeometryTag Type_t;
  };
  
! template<int Dim, class GeometryTag>
! struct NewGeometryTag<Dim, GeometryTag, INode<Dim> >
  {
!   typedef GeometryTag Type_t;
  };
  
! template<class GeometryTag, class T, class EngineTag, class Domain>
! struct View1Implementation<Field<GeometryTag, T, EngineTag>, Domain, false>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    
--- 317,346 ----
  // It is always a NoGeometry unless the view is from an interval or
  // an INode.
  
! template<int Dim, class MeshTag, class Domain>
! struct NewMeshTag
  {
!   typedef NoMesh<Dim> Type_t;
  };
  
! template<int Dim, class MeshTag>
! struct NewMeshTag<Dim, MeshTag, Interval<Dim> >
  {
!   typedef MeshTag Type_t;
  };
  
! template<int Dim, class MeshTag>
! struct NewMeshTag<Dim, MeshTag, INode<Dim> >
  {
!   typedef MeshTag Type_t;
  };
  
! template<class MeshTag, class T, class EngineTag, class Domain>
! struct View1Implementation<Field<MeshTag, T, EngineTag>, Domain, false>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    
*************** struct View1Implementation<Field<Geometr
*** 349,364 ****
    typedef typename NewEngine_t::Element_t NewT_t;
    typedef typename NewEngine_t::Tag_t NewEngineTag_t;
    
!   // Deduce the new GeometryTag.
    
    typedef typename
!     NewGeometryTag<NewEngine_t::dimensions, GeometryTag, Domain>::Type_t 
!       NewGeometryTag_t;
    
    // The output types.
    
!   typedef Field<NewGeometryTag_t, NewT_t, NewEngineTag_t> ReadType_t;
!   typedef Field<NewGeometryTag_t, NewT_t, NewEngineTag_t> Type_t;
  
    template<class S1, class Combine>
    static 
--- 349,364 ----
    typedef typename NewEngine_t::Element_t NewT_t;
    typedef typename NewEngine_t::Tag_t NewEngineTag_t;
    
!   // Deduce the new MeshTag.
    
    typedef typename
!     NewMeshTag<NewEngine_t::dimensions, MeshTag, Domain>::Type_t 
!       NewMeshTag_t;
    
    // The output types.
    
!   typedef Field<NewMeshTag_t, NewT_t, NewEngineTag_t> ReadType_t;
!   typedef Field<NewMeshTag_t, NewT_t, NewEngineTag_t> Type_t;
  
    template<class S1, class Combine>
    static 
*************** struct View1Implementation<Field<Geometr
*** 445,456 ****
  template<class Subject, class Domain, bool SV>
  struct AltView1Implementation;
  
! template<class GeometryTag, class T, class EngineTag, class Domain>
! struct AltView1Implementation<Field<GeometryTag, T, EngineTag>, Domain, true>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // The return types are pretty simple here.
    
--- 445,456 ----
  template<class Subject, class Domain, bool SV>
  struct AltView1Implementation;
  
! template<class MeshTag, class T, class EngineTag, class Domain>
! struct AltView1Implementation<Field<MeshTag, T, EngineTag>, Domain, true>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // The return types are pretty simple here.
    
*************** struct AltView1Implementation<Field<Geom
*** 458,469 ****
    typedef typename Subject_t::ElementRef_t Type_t;
  };
  
! template<class GeometryTag, class T, class EngineTag, class Domain>
! struct AltView1Implementation<Field<GeometryTag, T, EngineTag>, Domain, false>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    
--- 458,469 ----
    typedef typename Subject_t::ElementRef_t Type_t;
  };
  
! template<class MeshTag, class T, class EngineTag, class Domain>
! struct AltView1Implementation<Field<MeshTag, T, EngineTag>, Domain, false>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    
*************** struct AltView1Implementation<Field<Geom
*** 472,487 ****
    typedef typename NewEngine_t::Element_t NewT_t;
    typedef typename NewEngine_t::Tag_t NewEngineTag_t;
    
!   // Deduce the new GeometryTag.
    
    typedef typename
!     NewGeometryTag<NewEngine_t::dimensions, GeometryTag, Domain>::Type_t 
!       NewGeometryTag_t;
    
    // The output types.
    
!   typedef Field<NewGeometryTag_t, NewT_t, NewEngineTag_t> ReadType_t;
!   typedef Field<NewGeometryTag_t, NewT_t, NewEngineTag_t> Type_t;
  };
  
  
--- 472,487 ----
    typedef typename NewEngine_t::Element_t NewT_t;
    typedef typename NewEngine_t::Tag_t NewEngineTag_t;
    
!   // Deduce the new MeshTag.
    
    typedef typename
!     NewMeshTag<NewEngine_t::dimensions, MeshTag, Domain>::Type_t 
!       NewMeshTag_t;
    
    // The output types.
    
!   typedef Field<NewMeshTag_t, NewT_t, NewEngineTag_t> ReadType_t;
!   typedef Field<NewMeshTag_t, NewT_t, NewEngineTag_t> Type_t;
  };
  
  
*************** struct AltView1Implementation<Field<Geom
*** 491,502 ****
  // Any changes to View1 should also be made to AltView1.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, class Sub1>
! struct View1<Field<GeometryTag, T, EngineTag>, Sub1>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    // At some point, we need to fix NewDomain1; until then, use
--- 491,502 ----
  // Any changes to View1 should also be made to AltView1.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, class Sub1>
! struct View1<Field<MeshTag, T, EngineTag>, Sub1>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    // At some point, we need to fix NewDomain1; until then, use
*************** struct View1<Field<GeometryTag, T, Engin
*** 542,553 ****
  // Any changes to View1 should also be made to AltView1.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag>
! struct View1<Field<GeometryTag, T, EngineTag>, int>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // The return types.
    
--- 542,553 ----
  // Any changes to View1 should also be made to AltView1.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag>
! struct View1<Field<MeshTag, T, EngineTag>, int>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // The return types.
    
*************** struct View1<Field<GeometryTag, T, Engin
*** 593,604 ****
  template<class FieldTag, class DomainTag>
  struct AltView1;
  
! template<class GeometryTag, class T, class EngineTag, class Sub1>
! struct AltView1<Field<GeometryTag, T, EngineTag>, Sub1>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    // At some point, we need to fix NewDomain1; until then, use
--- 593,604 ----
  template<class FieldTag, class DomainTag>
  struct AltView1;
  
! template<class MeshTag, class T, class EngineTag, class Sub1>
! struct AltView1<Field<MeshTag, T, EngineTag>, Sub1>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    // At some point, we need to fix NewDomain1; until then, use
*************** struct AltView1<Field<GeometryTag, T, En
*** 632,643 ****
  // Do NOT explicitly instantiate this class.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag>
! struct AltView1<Field<GeometryTag, T, EngineTag>, int>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // The return types.
    
--- 632,643 ----
  // Do NOT explicitly instantiate this class.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag>
! struct AltView1<Field<MeshTag, T, EngineTag>, int>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // The return types.
    
*************** struct AltView1<Field<GeometryTag, T, En
*** 652,664 ****
  // domains.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, 
    class Sub1, class Sub2>
! struct View2<Field<GeometryTag, T, EngineTag>, Sub1, Sub2>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    
--- 652,664 ----
  // domains.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, 
    class Sub1, class Sub2>
! struct View2<Field<MeshTag, T, EngineTag>, Sub1, Sub2>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    
*************** struct View2<Field<GeometryTag, T, Engin
*** 701,712 ****
  // integers.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag>
! struct View2<Field<GeometryTag, T, EngineTag>, int, int>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // The return types.
    
--- 701,712 ----
  // integers.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag>
! struct View2<Field<MeshTag, T, EngineTag>, int, int>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // The return types.
    
*************** struct View2<Field<GeometryTag, T, Engin
*** 746,759 ****
  // indexing a field with a FieldOffset and a Loc.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, int Dim>
! struct View2<Field<GeometryTag, T, EngineTag>,
               FieldOffset<Dim>,
               Loc<Dim> >
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // The field's dimension (i.e., the number of indices required to select a point).
    
--- 746,759 ----
  // indexing a field with a FieldOffset and a Loc.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, int Dim>
! struct View2<Field<MeshTag, T, EngineTag>,
               FieldOffset<Dim>,
               Loc<Dim> >
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // The field's dimension (i.e., the number of indices required to select a point).
    
*************** struct View2<Field<GeometryTag, T, Engin
*** 819,831 ****
  // domains.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, 
    class Sub1, class Sub2, class Sub3>
! struct View3<Field<GeometryTag, T, EngineTag>, Sub1, Sub2, Sub3>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    
--- 819,831 ----
  // domains.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, 
    class Sub1, class Sub2, class Sub3>
! struct View3<Field<MeshTag, T, EngineTag>, Sub1, Sub2, Sub3>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // Deduce domains for the output type.
    
*************** struct View3<Field<GeometryTag, T, Engin
*** 870,881 ****
  // integers.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag>
! struct View3<Field<GeometryTag, T, EngineTag>, int, int, int>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
  
    // The return types.
--- 870,881 ----
  // integers.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag>
! struct View3<Field<MeshTag, T, EngineTag>, int, int, int>
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
  
    // The return types.
*************** struct View3<Field<GeometryTag, T, Engin
*** 917,932 ****
  
  template<class Subject> struct Patch;
  
! template<class GeometryTag, class T, class EngineTag>
! struct Patch<Field<GeometryTag, T, EngineTag> >
  {
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::Engine_t OldEngine_t;
    typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;
  
!   // We've assumed that GeometryTag and T are the same for the patch engine.
  
!   typedef Field<GeometryTag, T, typename Engine_t::Tag_t> Type_t;
  
    enum { dim = OldEngine_t::dimensions };
  
--- 917,932 ----
  
  template<class Subject> struct Patch;
  
! template<class MeshTag, class T, class EngineTag>
! struct Patch<Field<MeshTag, T, EngineTag> >
  {
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::Engine_t OldEngine_t;
    typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;
  
!   // We've assumed that MeshTag and T are the same for the patch engine.
  
!   typedef Field<MeshTag, T, typename Engine_t::Tag_t> Type_t;
  
    enum { dim = OldEngine_t::dimensions };
  
*************** struct Patch<Field<GeometryTag, T, Engin
*** 939,954 ****
    }
  };
  
! template<class GeometryTag, class T, class LTag, class EngineTag>
! struct Patch<Field<GeometryTag, T, MultiPatch<LTag, EngineTag> > >
  {
!   typedef Field<GeometryTag, T, MultiPatch<LTag, EngineTag> > Subject_t;
    typedef typename Subject_t::Engine_t OldEngine_t;
    typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;
  
!   // We've assumed that GeometryTag and T are the same for the patch engine.
  
!   typedef Field<GeometryTag, T, typename Engine_t::Tag_t> Type_t;
  
    enum { dim = OldEngine_t::dimensions };
    typedef typename OldEngine_t::Layout_t Layout_t;
--- 939,954 ----
    }
  };
  
! template<class MeshTag, class T, class LTag, class EngineTag>
! struct Patch<Field<MeshTag, T, MultiPatch<LTag, EngineTag> > >
  {
!   typedef Field<MeshTag, T, MultiPatch<LTag, EngineTag> > Subject_t;
    typedef typename Subject_t::Engine_t OldEngine_t;
    typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;
  
!   // We've assumed that MeshTag and T are the same for the patch engine.
  
!   typedef Field<MeshTag, T, typename Engine_t::Tag_t> Type_t;
  
    enum { dim = OldEngine_t::dimensions };
    typedef typename OldEngine_t::Layout_t Layout_t;
*************** private:
*** 987,998 ****
    const Components &c_m;
  };
  
! template<class Components, class GeometryTag, class T, class EngineTag>
! struct ComponentView<Components, Field<GeometryTag, T, EngineTag> >
  {
    // Convenience typedef for the thing we're taking a component view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
  
    // Deduce the template parameters for the output type.
    
--- 987,998 ----
    const Components &c_m;
  };
  
! template<class Components, class MeshTag, class T, class EngineTag>
! struct ComponentView<Components, Field<MeshTag, T, EngineTag> >
  {
    // Convenience typedef for the thing we're taking a component view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
  
    // Deduce the template parameters for the output type.
    
*************** struct ComponentView<Components, Field<G
*** 1003,1009 ****
    
    // The output type.
    
!   typedef Field<GeometryTag, NewT_t, NewEngineTag_t> Type_t;
  
    // A function that creates the view.
    
--- 1003,1009 ----
    
    // The output type.
    
!   typedef Field<MeshTag, NewT_t, NewEngineTag_t> Type_t;
  
    // A function that creates the view.
    
*************** struct ComponentView<Components, Field<G
*** 1019,1025 ****
  // Field.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, 
           class T = POOMA_DEFAULT_ELEMENT_TYPE,
           class EngineTag = POOMA_DEFAULT_ENGINE_TYPE>
  class Field {
--- 1019,1025 ----
  // Field.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, 
           class T = POOMA_DEFAULT_ELEMENT_TYPE,
           class EngineTag = POOMA_DEFAULT_ENGINE_TYPE>
  class Field {
*************** public:
*** 1030,1036 ****
      
    // The specification type.
    
!   typedef GeometryTag GeometryTag_t;
  
    // The type.
    
--- 1030,1037 ----
      
    // The specification type.
    
!   typedef MeshTag MeshTag_t;
!   typedef MeshTag Mesh_t;
  
    // The type.
    
*************** public:
*** 1042,1052 ****
    
    // This class.
    
!   typedef Field<GeometryTag, T, EngineTag> This_t;
    
    // The field engine type.
    
!   typedef FieldEngine<GeometryTag, T, EngineTag> FieldEngine_t;
    
    // The dimension (i.e., the number of indices required to select a point).
    
--- 1043,1053 ----
    
    // This class.
    
!   typedef Field<MeshTag, T, EngineTag> This_t;
    
    // The field engine type.
    
!   typedef FieldEngine<MeshTag, T, EngineTag> FieldEngine_t;
    
    // The dimension (i.e., the number of indices required to select a point).
    
*************** public:
*** 1077,1083 ****
    //---------------------------------------------------------------------------
    // User-callable constructors. These ctors are meant to be called by users.
  
!   // GeometryTag/centering/layout constructors. We use the specified mesh 
    // object to initialize our mesh and the layout to initialize 
    // the engines. Clearly, these must be synchronized. This is appropriate 
    // for multi-patch engines. We just store the centering.
--- 1078,1084 ----
    //---------------------------------------------------------------------------
    // User-callable constructors. These ctors are meant to be called by users.
  
!   // MeshTag/centering/layout constructors. We use the specified mesh 
    // object to initialize our mesh and the layout to initialize 
    // the engines. Clearly, these must be synchronized. This is appropriate 
    // for multi-patch engines. We just store the centering.
*************** public:
*** 1086,1154 ****
    : fieldEngine_m()
      { } 
  
!   template<class I1>  
!   explicit Field(const I1 &i1)
!   : fieldEngine_m(i1)
!     { } 
! 
!   template<class I1, class I2>  
!   Field(const I1 &i1, const I2 &i2)
!   : fieldEngine_m(i1, i2)
!     { } 
  
-   template<class I1, class I2, class I3>  
-   Field(const I1 &i1, const I2 &i2, const I3 &i3)
-   : fieldEngine_m(i1, i2, i3)
-     { } 
- 
-   template<class I1, class I2, class I3, class I4>  
-   Field(const I1 &i1, const I2 &i2, const I3 &i3, const I4 &i4)
-   : fieldEngine_m(i1, i2, i3, i4)
-     { } 
- 
    template<class I1>  
!   Field(const Centering_t &centering, const I1 &i1)
!     : fieldEngine_m(centering, i1)
    { } 
  
!   template<class I1, class I2>  
!   Field(const Centering_t &centering, const I1 &i1, const I2 &i2)
!     : fieldEngine_m(centering, i1, i2)
!   { } 
  
!   template<class I1, class I2, class I3>  
!   Field(const Centering_t &centering, const I1 &i1, const I2 &i2, const I3 &i3)
!     : fieldEngine_m(centering, i1, i2, i3)
    { } 
  
!   template<class I1>  
!   Field(int materials, const Centering_t &centering, const I1 &i1)
!     : fieldEngine_m(materials, centering, i1)
    { } 
  
    template<class I1, class I2>  
!   Field(int materials, const Centering_t &centering,
!         const I1 &i1, const I2 &i2)
!     : fieldEngine_m(materials, centering, i1, i2)
    { } 
  
!   template<class I1, class I2, class I3>  
!   Field(int materials, const Centering_t &centering,
!         const I1 &i1, const I2 &i2, const I3 &i3)
!     : fieldEngine_m(materials, centering, i1, i2, i3)
    { } 
  
    // Copy constructor.
    
    Field(const This_t &model)
    : fieldEngine_m(model.fieldEngine())
!     { }
  
    // Copy initializer.
    
    void initialize(const This_t &model)
!   { fieldEngine_m = model.fieldEngine(); }
! 
    
    //---------------------------------------------------------------------------
    // Internal POOMA constructors. These ctors are used internally by POOMA.
--- 1087,1136 ----
    : fieldEngine_m()
      { } 
  
!   // This version is used for expressions.
!   // FIXME: perhaps it should be more specific.
  
    template<class I1>  
!   explicit Field(const I1 &i1)
!     : fieldEngine_m(i1)
    { } 
  
!   // Layout is templated so you can use a compatible layout to construct the
!   // engine.
  
!   template<class Layout2>
!   Field(const Centering_t &centering, const Layout2 &layout, const Mesh_t &mesh)
!     : fieldEngine_m(centering, layout, mesh)
    { } 
  
!   template<class Layout2>
!   Field(int materials, const Centering_t &centering, const Layout2 &layout, const Mesh_t &mesh)
!     : fieldEngine_m(centering, layout, mesh, materials)
    { } 
  
    template<class I1, class I2>  
!   Field(const Centering_t &centering, const Layout_t &layout, const I1 &i1, const I2 &i2)
!     : fieldEngine_m(centering, layout, Mesh_t(layout, i1, i2))
    { } 
  
!   template<class I1, class I2>  
!   Field(int materials, const Centering_t &centering, const Layout_t &layout,
!         const I1 &i1, const I2 &i2)
!     : fieldEngine_m(centering, layout, Mesh_t(layout, i1, i2), materials)
    { } 
  
    // Copy constructor.
    
    Field(const This_t &model)
    : fieldEngine_m(model.fieldEngine())
!   { }
  
    // Copy initializer.
    
    void initialize(const This_t &model)
!   {
!     fieldEngine_m = model.fieldEngine();
!   }
    
    //---------------------------------------------------------------------------
    // Internal POOMA constructors. These ctors are used internally by POOMA.
*************** public:
*** 1160,1167 ****
    template<class GT2, class T2, class ET2, class Initializer>
    Field(const Field<GT2, T2, ET2> &model, const Initializer &i)
    : fieldEngine_m(model.fieldEngine(), i)
!     { }
  
    //---------------------------------------------------------------------------
    // Empty destructor is fine for us.
    
--- 1142,1153 ----
    template<class GT2, class T2, class ET2, class Initializer>
    Field(const Field<GT2, T2, ET2> &model, const Initializer &i)
    : fieldEngine_m(model.fieldEngine(), i)
!   { }
  
+   Field(const This_t &model, int m, int c)
+   : fieldEngine_m(model.fieldEngine(), m, c)
+   { }
+ 
    //---------------------------------------------------------------------------
    // Empty destructor is fine for us.
    
*************** public:
*** 1236,1262 ****
      {
        return fieldEngine_m.physicalDomain();
      }
- 
  
    //---------------------------------------------------------------------------
    // Instruct the field to make its own copy of its data.
    // Recursively call ourself with subfield views of this field. When we're
    // through, tell the fieldEngine to make a distinct copy of itself.
  
    void makeOwnCopy()
!     {
!       if (numSubFields() == 0)
!         {
!           // Make a distinct copy of the fieldEngine.
            
!           fieldEngine_m.makeOwnCopy(*this);
!         }
!       else
!         {
!           for (int i = 0; i < numSubFields(); i++)
!             (*this)[i].makeOwnCopy();
!         }
!     }
        
    
    //---------------------------------------------------------------------------
--- 1222,1250 ----
      {
        return fieldEngine_m.physicalDomain();
      }
  
+   inline
+   const Mesh_t &mesh() const
+   {
+     return fieldEngine_m.mesh();
+   }
+         
+   inline Layout_t layout() const
+   {
+     return fieldEngine_m.engine().layout();
+   }
+         
    //---------------------------------------------------------------------------
    // Instruct the field to make its own copy of its data.
    // Recursively call ourself with subfield views of this field. When we're
    // through, tell the fieldEngine to make a distinct copy of itself.
  
    void makeOwnCopy()
!   {
!     // Make a distinct copy of the fieldEngine.
            
!     fieldEngine_m.makeOwnCopy(*this);
!   }
        
    
    //---------------------------------------------------------------------------
*************** public:
*** 1271,1276 ****
--- 1259,1282 ----
        return Ret_t::make(*this, iSubfield);
      }
  
+   inline This_t
+   subField(int m, int c) const
+   {
+     return This_t(*this, m, c);
+   }
+ 
+   inline This_t
+   center(int c) const
+   {
+     return This_t(c, *this);
+   }
+ 
+   inline This_t
+   material(int m) const
+   {
+     PAssert(numMaterials() > 1);
+     return This_t(*this, m);
+   }
  
    //---------------------------------------------------------------------------
    // View-creation operations. These operator() and read() functions take 
*************** public:
*** 1358,1364 ****
  
    //---------------------------------------------------------------------------
    // Component-forwarding functions. These work quite similarly to the
!   // ones from Array except we produce a Field with the same GeometryTag.
  
    inline typename ComponentView<Loc<1>, This_t>::Type_t
    comp(const int &i1) const
--- 1364,1370 ----
  
    //---------------------------------------------------------------------------
    // Component-forwarding functions. These work quite similarly to the
!   // ones from Array except we produce a Field with the same MeshTag.
  
    inline typename ComponentView<Loc<1>, This_t>::Type_t
    comp(const int &i1) const
*************** public:
*** 1516,1571 ****
    }
    
    void removeRelations()
      {
!       if (numSubFields() == 0)
!         fieldEngine_m.relations().erase();
!       else
!         {
!           for (int i = 0; i < numSubFields(); i++)
!             (*this)[i].removeRelations();
!         }
      }
    
    void applyRelations(bool makeDirty = false) const
      {
!       if (numSubFields() == 0)
!         {
!           if (makeDirty)
!             fieldEngine_m.relations().setDirty();
!           fieldEngine_m.relations().notifyPreRead();
!         }
!       else
!         {
!           for (int i = 0; i < numSubFields(); i++)
!             (*this)[i].applyRelations(makeDirty);
!         }
      }
    
    void setDirty() const
      {
!       if (numSubFields() == 0)
!         {
!           fieldEngine_m.relations().setDirty();
!         }
!       else
!         {
!           for (int i = 0; i < numSubFields(); i++)
!             (*this)[i].setDirty();
!         }
      }
    
    void clearDirty() const
      {
!       if (numSubFields() == 0)
!         {
!           fieldEngine_m.relations().clearDirty();
!         }
!       else
!         {
!           for (int i = 0; i < numSubFields(); i++)
!             (*this)[i].clearDirty();
!         }
      }
  
  
  private:
--- 1522,1571 ----
    }
    
    void removeRelations()
+   {
+     for (int m = 0; m < numMaterials(); ++m)
      {
!       for (int c = 0; c < centering().size(); ++ c)
!       {
!         fieldEngine_m.data(m, c).relations().erase();
!       }
      }
+   }
    
    void applyRelations(bool makeDirty = false) const
+   {
+     for (int m = 0; m < numMaterials(); ++m)
      {
!       for (int c = 0; c < centering().size(); ++ c)
!       {
!         if (makeDirty)
!           fieldEngine_m.data(m, c).relations().setDirty();
!         fieldEngine_m.data(m, c).relations().notifyPreRead();
!       }
      }
+   }
    
    void setDirty() const
+   {
+     for (int m = 0; m < numMaterials(); ++m)
      {
!       for (int c = 0; c < centering().size(); ++ c)
!       {
!         fieldEngine_m.data(m, c).relations().setDirty();
!       }
      }
+   }
    
    void clearDirty() const
+   {
+     for (int m = 0; m < numMaterials(); ++m)
      {
!       for (int c = 0; c < centering().size(); ++ c)
!       {
!         fieldEngine_m.data(m, c).relations().clearDirty();
!       }
      }
+   }
  
  
  private:
*************** struct AssignOpReadWriteTraits<OpAssign>
*** 1598,1605 ****
  // Check to see if a given Field conforms.
  //----------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, int Dim>
! struct LeafFunctor<Field<GeometryTag, T, EngineTag>, ConformTag<Dim> >
  {
    typedef bool Type_t;
    static Type_t apply1(const Interval<Dim> &d, 
--- 1598,1605 ----
  // Check to see if a given Field conforms.
  //----------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, int Dim>
! struct LeafFunctor<Field<MeshTag, T, EngineTag>, ConformTag<Dim> >
  {
    typedef bool Type_t;
    static Type_t apply1(const Interval<Dim> &d, 
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1613,1619 ****
      {
        return false;
      }
!   static Type_t apply(const Field<GeometryTag, T, EngineTag> &f,
      const ConformTag<Dim> &ct)
      {
        return apply1(f.physicalDomain(), ct);
--- 1613,1619 ----
      {
        return false;
      }
!   static Type_t apply(const Field<MeshTag, T, EngineTag> &f,
      const ConformTag<Dim> &ct)
      {
        return apply1(f.physicalDomain(), ct);
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1628,1638 ****
  // fieldEngine's engine.
  //----------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, class RequestType>
! struct LeafFunctor<Field<GeometryTag, T, EngineTag>,
    DataObjectRequest<RequestType> >
  {
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::FieldEngine_t FieldEngine_t;
    typedef LeafFunctor<FieldEngine_t, DataObjectRequest<RequestType> > 
      LeafFunctor_t;
--- 1628,1638 ----
  // fieldEngine's engine.
  //----------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, class RequestType>
! struct LeafFunctor<Field<MeshTag, T, EngineTag>,
    DataObjectRequest<RequestType> >
  {
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::FieldEngine_t FieldEngine_t;
    typedef LeafFunctor<FieldEngine_t, DataObjectRequest<RequestType> > 
      LeafFunctor_t;
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1647,1662 ****
      }
  };
  
! template<class GeometryTag, class T, class EngineTag, class RequestType>
! struct LeafFunctor<FieldEngine<GeometryTag, T, EngineTag>,
    DataObjectRequest<RequestType> >
  {
!   typedef typename FieldEngine<GeometryTag, T, EngineTag>::Engine_t 
      Engine_t;
    enum { dataObject = Engine_t::dataObject };
    typedef typename DataObjectRequest<RequestType>::Type_t Type_t;
    inline static
!   Type_t apply(const FieldEngine<GeometryTag, T, EngineTag> &f,
  	           const DataObjectRequest<RequestType> &functor)
      {
        return DataObjectApply<dataObject>::apply(f.engine(), functor);
--- 1647,1662 ----
      }
  };
  
! template<class MeshTag, class T, class EngineTag, class RequestType>
! struct LeafFunctor<FieldEngine<MeshTag, T, EngineTag>,
    DataObjectRequest<RequestType> >
  {
!   typedef typename FieldEngine<MeshTag, T, EngineTag>::Engine_t 
      Engine_t;
    enum { dataObject = Engine_t::dataObject };
    typedef typename DataObjectRequest<RequestType>::Type_t Type_t;
    inline static
!   Type_t apply(const FieldEngine<MeshTag, T, EngineTag> &f,
  	           const DataObjectRequest<RequestType> &functor)
      {
        return DataObjectApply<dataObject>::apply(f.engine(), functor);
*************** struct LeafFunctor<FieldEngine<GeometryT
*** 1669,1680 ****
  // (zero-based) domain itself from a Field. Used only by Expression-Engine.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag>
! struct LeafFunctor<Field<GeometryTag, T, EngineTag>, DomainFunctorTag>
  {
!   typedef typename Field<GeometryTag, T, EngineTag>::Domain_t Type_t;
  
!   inline static Type_t apply(const Field<GeometryTag, T, EngineTag> &f, 
      const DomainFunctorTag &)
      {
        // Return zero-based domain.
--- 1669,1680 ----
  // (zero-based) domain itself from a Field. Used only by Expression-Engine.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag>
! struct LeafFunctor<Field<MeshTag, T, EngineTag>, DomainFunctorTag>
  {
!   typedef typename Field<MeshTag, T, EngineTag>::Domain_t Type_t;
  
!   inline static Type_t apply(const Field<MeshTag, T, EngineTag> &f, 
      const DomainFunctorTag &)
      {
        // Return zero-based domain.
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1691,1700 ****
  // below, is to just pass it on to the fieldEngine's engine.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, class Tag>
! struct LeafFunctor<Field<GeometryTag, T, EngineTag>, ExpressionApply<Tag> >
  {
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::FieldEngine_t FieldEngine_t;
    typedef LeafFunctor<FieldEngine_t, ExpressionApply<Tag> > LeafFunctor_t;
    typedef int Type_t;
--- 1691,1700 ----
  // below, is to just pass it on to the fieldEngine's engine.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, class Tag>
! struct LeafFunctor<Field<MeshTag, T, EngineTag>, ExpressionApply<Tag> >
  {
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::FieldEngine_t FieldEngine_t;
    typedef LeafFunctor<FieldEngine_t, ExpressionApply<Tag> > LeafFunctor_t;
    typedef int Type_t;
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1706,1733 ****
        return LeafFunctor_t::apply(field.fieldEngine(), tag);
      }
  };
- 
- template<class GeometryTag, class T, class EngineTag, class Tag>
- struct LeafFunctor<FieldEngine<GeometryTag, T, EngineTag>,
-   ExpressionApply<Tag> >
- {
-   typedef FieldEngine<GeometryTag, T, EngineTag> Subject_t;
-   typedef typename Subject_t::Base_t Base_t;
-   typedef LeafFunctor<Base_t, ExpressionApply<Tag> > LeafFunctor_t;
-   typedef int Type_t;
  
!   inline static
!   Type_t apply(const Subject_t &fieldEngine, 
! 	       const ExpressionApply<Tag> &tag)
!   {
!     return LeafFunctor_t::apply(fieldEngine, tag);
!   }
! };
! 
! template<class GeometryTag, class T, class EngineTag, class Tag>
! struct LeafFunctor<Field<GeometryTag, T, EngineTag>, EngineView<Tag> >
  {
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::Engine_t Engine_t;
    typedef typename LeafFunctor<Engine_t, EngineView<Tag> >::Type_t NewEngine_t;
    typedef typename NewEngine_t::Tag_t NewEngineTag_t;
--- 1706,1716 ----
        return LeafFunctor_t::apply(field.fieldEngine(), tag);
      }
  };
  
! template<class MeshTag, class T, class EngineTag, class Tag>
! struct LeafFunctor<Field<MeshTag, T, EngineTag>, EngineView<Tag> >
  {
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::Engine_t Engine_t;
    typedef typename LeafFunctor<Engine_t, EngineView<Tag> >::Type_t NewEngine_t;
    typedef typename NewEngine_t::Tag_t NewEngineTag_t;
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1735,1741 ****
    // Don't bother computing NewGeometry tag yet.
    // For now all EngineView operations are equivalent to Interval views.
  
!   typedef Field<GeometryTag, T, NewEngineTag_t> Type_t;
  
    inline static
    Type_t apply(const Subject_t &field,
--- 1718,1724 ----
    // Don't bother computing NewGeometry tag yet.
    // For now all EngineView operations are equivalent to Interval views.
  
!   typedef Field<MeshTag, T, NewEngineTag_t> Type_t;
  
    inline static
    Type_t apply(const Subject_t &field,
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1750,1762 ****
  // Handle general engine functor requests.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, class Tag>
! struct LeafFunctor<Field<GeometryTag, T, EngineTag>, EngineFunctorTag<Tag> >
  {
!   typedef typename Field<GeometryTag,T,EngineTag>::Engine_t Engine_t;
    typedef typename EngineFunctor<Engine_t,Tag>::Type_t Type_t;
    inline static
!   Type_t apply(const Field<GeometryTag, T, EngineTag> &field,
  	       const EngineFunctorTag<Tag> &tag)
    {
      return EngineFunctor<Engine_t,Tag>::apply(field.engine(), tag.tag());
--- 1733,1745 ----
  // Handle general engine functor requests.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, class Tag>
! struct LeafFunctor<Field<MeshTag, T, EngineTag>, EngineFunctorTag<Tag> >
  {
!   typedef typename Field<MeshTag,T,EngineTag>::Engine_t Engine_t;
    typedef typename EngineFunctor<Engine_t,Tag>::Type_t Type_t;
    inline static
!   Type_t apply(const Field<MeshTag, T, EngineTag> &field,
  	       const EngineFunctorTag<Tag> &tag)
    {
      return EngineFunctor<Engine_t,Tag>::apply(field.engine(), tag.tag());
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1768,1781 ****
  // A specialization of EngineFunctor for field.
  //---------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, class Tag>
! struct EngineFunctor<Field<GeometryTag, T, EngineTag>, Tag>
  {
!   typedef typename Field<GeometryTag, T, EngineTag>::Engine_t Engine_t;
    typedef typename EngineFunctor<Engine_t, Tag>::Type_t Type_t;
  
    inline static 
!   Type_t apply(const Field<GeometryTag, T, EngineTag> &field,
  	           const Tag &tag)
      {
        return engineFunctor(field.engine(), tag);
--- 1751,1764 ----
  // A specialization of EngineFunctor for field.
  //---------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, class Tag>
! struct EngineFunctor<Field<MeshTag, T, EngineTag>, Tag>
  {
!   typedef typename Field<MeshTag, T, EngineTag>::Engine_t Engine_t;
    typedef typename EngineFunctor<Engine_t, Tag>::Type_t Type_t;
  
    inline static 
!   Type_t apply(const Field<MeshTag, T, EngineTag> &field,
  	           const Tag &tag)
      {
        return engineFunctor(field.engine(), tag);
*************** struct EngineFunctor<Field<GeometryTag, 
*** 1788,1799 ****
  // evaluate a Field using indices. 
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, int Dim>
! struct LeafFunctor<Field<GeometryTag, T, EngineTag>, EvalLeaf<Dim> >
  {
!   typedef typename Field<GeometryTag, T, EngineTag>::Element_t Type_t;
    inline static
!   Type_t apply(const Field<GeometryTag, T, EngineTag> &f, 
      const EvalLeaf<Dim> &t) 
      {
        return t.eval(f.engine());
--- 1771,1782 ----
  // evaluate a Field using indices. 
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, int Dim>
! struct LeafFunctor<Field<MeshTag, T, EngineTag>, EvalLeaf<Dim> >
  {
!   typedef typename Field<MeshTag, T, EngineTag>::Element_t Type_t;
    inline static
!   Type_t apply(const Field<MeshTag, T, EngineTag> &f, 
      const EvalLeaf<Dim> &t) 
      {
        return t.eval(f.engine());
*************** struct LeafFunctor<Node, PerformUpdateTa
*** 1836,1846 ****
  };
  
  
! template<class GeometryTag, class T, class EngineTag>
! struct LeafFunctor<Field<GeometryTag, T, EngineTag>, 
    PerformUpdateTag>
  {
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
    typedef int Type_t;
  
    inline static
--- 1819,1829 ----
  };
  
  
! template<class MeshTag, class T, class EngineTag>
! struct LeafFunctor<Field<MeshTag, T, EngineTag>, 
    PerformUpdateTag>
  {
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
    typedef int Type_t;
  
    inline static
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1851,1861 ****
      }
  };
  
! template<class GeometryTag, class T, class Expr>
! struct LeafFunctor<Field<GeometryTag, T, ExpressionTag<Expr> >, 
    PerformUpdateTag>
  {
!   typedef Field<GeometryTag, T, ExpressionTag<Expr> > Subject_t;
    typedef int Type_t;
  
    inline static
--- 1834,1844 ----
      }
  };
  
! template<class MeshTag, class T, class Expr>
! struct LeafFunctor<Field<MeshTag, T, ExpressionTag<Expr> >, 
    PerformUpdateTag>
  {
!   typedef Field<MeshTag, T, ExpressionTag<Expr> > Subject_t;
    typedef int Type_t;
  
    inline static
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1872,1881 ****
  // sub-field view. 
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag>
! struct LeafFunctor<Field<GeometryTag, T, EngineTag>, SubFieldViewFunctorTag>
  {
!   typedef Field<GeometryTag, T, EngineTag> Type_t;
  };
  
  template<class T>
--- 1855,1864 ----
  // sub-field view. 
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag>
! struct LeafFunctor<Field<MeshTag, T, EngineTag>, SubFieldViewFunctorTag>
  {
!   typedef Field<MeshTag, T, EngineTag> Type_t;
  };
  
  template<class T>
*************** struct LeafFunctor<Scalar<T>, SubFieldVi
*** 1892,1901 ****
  // the domain.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, class Domain>
! struct LeafFunctor<Field<GeometryTag, T, EngineTag>, ViewFunctorTag<Domain> >
  {
!   typedef typename View1<Field<GeometryTag, T, EngineTag>, Domain>::Type_t 
      Type_t;
  };
  
--- 1875,1884 ----
  // the domain.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, class Domain>
! struct LeafFunctor<Field<MeshTag, T, EngineTag>, ViewFunctorTag<Domain> >
  {
!   typedef typename View1<Field<MeshTag, T, EngineTag>, Domain>::Type_t 
      Type_t;
  };
  
*************** struct LeafFunctor<Field<GeometryTag, T,
*** 1907,1924 ****
  // return the stream object.
  //-----------------------------------------------------------------------------
  
! template <class GeometryTag, class T, class EngineTag>
  std::ostream &operator<<(std::ostream &o, 
!   const Field<GeometryTag, T, EngineTag> &cf)
  {
    Pooma::blockAndEvaluate();
    PrintField().print(o, cf);
    return o;
  }
  
! template <class GeometryTag, class T, class EngineTag>
  std::fstream &operator<<(std::fstream &f, 
!   const Field<GeometryTag, T, EngineTag> &cf)
  {
    Pooma::blockAndEvaluate();
    PrintField().print(f, cf);
--- 1890,1907 ----
  // return the stream object.
  //-----------------------------------------------------------------------------
  
! template <class MeshTag, class T, class EngineTag>
  std::ostream &operator<<(std::ostream &o, 
!   const Field<MeshTag, T, EngineTag> &cf)
  {
    Pooma::blockAndEvaluate();
    PrintField().print(o, cf);
    return o;
  }
  
! template <class MeshTag, class T, class EngineTag>
  std::fstream &operator<<(std::fstream &f, 
!   const Field<MeshTag, T, EngineTag> &cf)
  {
    Pooma::blockAndEvaluate();
    PrintField().print(f, cf);
*************** std::fstream &operator<<(std::fstream &f
*** 1930,1939 ****
  // assign() function for Field assign-op array.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, 
   int Dim2, class T2, class EngineTag2, class Op>
! const Field<GeometryTag, T, EngineTag> &
! assign(const Field<GeometryTag, T, EngineTag> &lhs, 
         const Array<Dim2, T2, EngineTag2> &rhs, const Op &op)
  {
    int nsf = lhs.numSubFields();
--- 1913,1922 ----
  // assign() function for Field assign-op array.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, 
   int Dim2, class T2, class EngineTag2, class Op>
! const Field<MeshTag, T, EngineTag> &
! assign(const Field<MeshTag, T, EngineTag> &lhs, 
         const Array<Dim2, T2, EngineTag2> &rhs, const Op &op)
  {
    int nsf = lhs.numSubFields();
*************** assign(const Field<GeometryTag, T, Engin
*** 1969,1979 ****
  // assign() function for Field assign-op Field.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag,
!   class GeometryTag2, class T2, class EngineTag2, class Op>
! const Field<GeometryTag, T, EngineTag> &
! assign(const Field<GeometryTag, T, EngineTag> &lhs,
!        const Field<GeometryTag2, T2, EngineTag2> &rhs,
         const Op &op)
  {
    int nsf = lhs.numSubFields();
--- 1952,1962 ----
  // assign() function for Field assign-op Field.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag,
!   class MeshTag2, class T2, class EngineTag2, class Op>
! const Field<MeshTag, T, EngineTag> &
! assign(const Field<MeshTag, T, EngineTag> &lhs,
!        const Field<MeshTag2, T2, EngineTag2> &rhs,
         const Op &op)
  {
    int nsf = lhs.numSubFields();
*************** assign(const Field<GeometryTag, T, Engin
*** 2014,2054 ****
  // assign() function for Field assign-op scalar.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, class T1, class Op>
! const Field<GeometryTag, T, EngineTag> &
! assign(const Field<GeometryTag, T, EngineTag> &lhs, const T1 &rhs,
         const Op &op)
  {
!   int nsf = lhs.numSubFields();
!   
!   if (nsf != 0)
!     {
!       // We need to take sub-field views in order to get at all of the
!       // internal fields.
!       
!       for (int i = 0; i < nsf; i++)
!         assign(lhs[i], rhs, op);
!     }
!   else
      {
        if (AssignOpReadWriteTraits<Op>::readLHS)
!         lhs.applyRelations();
  
        // Make an array out of the scalar.
  
!       typedef Field<GeometryTag, T, EngineTag> LHS_t;
!       Array<LHS_t::dimensions, T1, ConstantFunction>  rhsExpr(lhs.physicalDomain());
        rhsExpr.engine().setConstant(rhs);
       
        // Evaluate. 
  
!       Evaluator<MainEvaluatorTag>().evaluate(lhs, op, rhsExpr);
  
        // Having done the evaluation, we need to notify the LHS
        // that we've just written.
    
!       lhs.setDirty();
      }
          
    return lhs;
  }
--- 1997,2030 ----
  // assign() function for Field assign-op scalar.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, class T1, class Op>
! const Field<MeshTag, T, EngineTag> &
! assign(const Field<MeshTag, T, EngineTag> &lhs, const T1 &rhs,
         const Op &op)
  {
!   for (int m = 0; m < lhs.numMaterials(); ++m)
!   {
!     for (int c = 0; c < lhs.centering().size(); ++ c)
      {
        if (AssignOpReadWriteTraits<Op>::readLHS)
!         lhs.subField(m, c).applyRelations();
  
        // Make an array out of the scalar.
  
!       typedef Field<MeshTag, T, EngineTag> LHS_t;
!       Array<LHS_t::dimensions, T1, ConstantFunction>  rhsExpr(lhs.physicalDomain(c));
        rhsExpr.engine().setConstant(rhs);
       
        // Evaluate. 
  
!       Evaluator<MainEvaluatorTag>().evaluate(lhs.subField(m, c), op, rhsExpr);
  
        // Having done the evaluation, we need to notify the LHS
        // that we've just written.
    
!       lhs.subField(m, c).setDirty();
      }
+   }
          
    return lhs;
  }
*************** assign(const Field<GeometryTag, T, Engin
*** 2061,2070 ****
  // assertion.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class LTag>
  inline double
  compressedFraction(
!   const Field<GeometryTag, T, MultiPatch<LTag,CompressibleBrick> > &f)
  {
    PAssert(f.numSubFields() == 0);
    return compressedFraction(f.engine());
--- 2037,2046 ----
  // assertion.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class LTag>
  inline double
  compressedFraction(
!   const Field<MeshTag, T, MultiPatch<LTag,CompressibleBrick> > &f)
  {
    PAssert(f.numSubFields() == 0);
    return compressedFraction(f.engine());
*************** compressedFraction(
*** 2076,2094 ****
  // multipatch engines.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class LTag>
  void
! compress(Field<GeometryTag, T, MultiPatch<LTag,CompressibleBrick> > &)
  {
!   if (numSubFields() == 0)
!     {
!       compress(f.engine());
!     }
!   else
      {
!       for (int i = 0; i < numSubFields(); i++)
!         compress(f[i]);
      }
  }
  
  
--- 2052,2068 ----
  // multipatch engines.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class LTag>
  void
! compress(Field<MeshTag, T, MultiPatch<LTag,CompressibleBrick> > &f)
  {
!   for (int m = 0; m < f.numMaterials(); ++m)
!   {
!     for (int c = 0; c < f.centering().size(); ++ c)
      {
!       compress(f.fieldEngine().data(m, c).engine());
      }
+   }
  }
  
  
*************** compress(Field<GeometryTag, T, MultiPatc
*** 2097,2115 ****
  // multipatch engines.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class LTag>
  void
! uncompress(Field<GeometryTag, T, MultiPatch<LTag,CompressibleBrick> > &f)
  {
!   if (numSubFields() == 0)
!     {
!       uncompress(f.engine());
!     }
!   else
      {
!       for (int i = 0; i < numSubFields(); i++)
!         uncompress(f[i]);
      }
  }
  
  #endif // POOMA_NEWFIELD_FIELD_H
--- 2071,2087 ----
  // multipatch engines.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class LTag>
  void
! uncompress(Field<MeshTag, T, MultiPatch<LTag,CompressibleBrick> > &f)
  {
!   for (int m = 0; m < f.numMaterials(); ++m)
!   {
!     for (int c = 0; c < f.centering().size(); ++ c)
      {
!       uncompress(f.fieldEngine().data(m, c).engine());
      }
+   }
  }
  
  #endif // POOMA_NEWFIELD_FIELD_H
Index: src/NewField/FieldMakeReturn.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/FieldMakeReturn.h,v
retrieving revision 1.1
diff -c -p -r1.1 FieldMakeReturn.h
*** src/NewField/FieldMakeReturn.h	2000/08/08 17:31:33	1.1
--- src/NewField/FieldMakeReturn.h	2001/08/23 22:59:14
*************** struct MakeFieldReturn<UnaryNode<Op, Lea
*** 91,101 ****
    typedef typename ForEach<Tree_t, EvalLeaf<dim>, OpCombine>::Type_t T_t;
    typedef Engine<dim, T_t, ExpressionTag<Tree_t> > Engine_t;
    typedef typename ForEach<Tree_t, FarLeftTag, FarLeftTag>::
!     Type_t::GeometryTag_t GeometryTag_t;
  
    // Construct the type of the Field we're making.
  
!   typedef Field<GeometryTag_t, T_t, ExpressionTag<Tree_t> > Expression_t;
  
    // This function turns the tree node into a Field.
    
--- 91,101 ----
    typedef typename ForEach<Tree_t, EvalLeaf<dim>, OpCombine>::Type_t T_t;
    typedef Engine<dim, T_t, ExpressionTag<Tree_t> > Engine_t;
    typedef typename ForEach<Tree_t, FarLeftTag, FarLeftTag>::
!     Type_t::MeshTag_t MeshTag_t;
  
    // Construct the type of the Field we're making.
  
!   typedef Field<MeshTag_t, T_t, ExpressionTag<Tree_t> > Expression_t;
  
    // This function turns the tree node into a Field.
    
*************** struct MakeFieldReturn<BinaryNode<Op, Le
*** 128,138 ****
    typedef typename ForEach<Tree_t, EvalLeaf<dim>, OpCombine>::Type_t T_t;
    typedef Engine<dim, T_t, ExpressionTag<Tree_t> > Engine_t;
    typedef typename ForEach<Tree_t, FarLeftTag, FarLeftTag>::
!     Type_t::GeometryTag_t GeometryTag_t;
    
    // Construct the type of the Field we're making.
  
!   typedef Field<GeometryTag_t, T_t, ExpressionTag<Tree_t> > 
      Expression_t;
  
    // This function turns the tree node into a Field.
--- 128,138 ----
    typedef typename ForEach<Tree_t, EvalLeaf<dim>, OpCombine>::Type_t T_t;
    typedef Engine<dim, T_t, ExpressionTag<Tree_t> > Engine_t;
    typedef typename ForEach<Tree_t, FarLeftTag, FarLeftTag>::
!     Type_t::MeshTag_t MeshTag_t;
    
    // Construct the type of the Field we're making.
  
!   typedef Field<MeshTag_t, T_t, ExpressionTag<Tree_t> > 
      Expression_t;
  
    // This function turns the tree node into a Field.
*************** struct MakeFieldReturn<TrinaryNode<Op, L
*** 166,176 ****
    typedef typename ForEach<Tree_t, EvalLeaf<dim>, OpCombine>::Type_t T_t;
    typedef Engine<dim, T_t, ExpressionTag<Tree_t> > Engine_t;
    typedef typename ForEach<Tree_t, FarLeftTag, FarLeftTag>::
!     Type_t::GeometryTag_t GeometryTag_t;
    
    // Construct the type of the Field we're making.
  
!   typedef Field<GeometryTag_t, T_t, ExpressionTag<Tree_t> > Expression_t;
  
    // This function turns the tree node into a Field.
  
--- 166,176 ----
    typedef typename ForEach<Tree_t, EvalLeaf<dim>, OpCombine>::Type_t T_t;
    typedef Engine<dim, T_t, ExpressionTag<Tree_t> > Engine_t;
    typedef typename ForEach<Tree_t, FarLeftTag, FarLeftTag>::
!     Type_t::MeshTag_t MeshTag_t;
    
    // Construct the type of the Field we're making.
  
!   typedef Field<MeshTag_t, T_t, ExpressionTag<Tree_t> > Expression_t;
  
    // This function turns the tree node into a Field.
  
Index: src/NewField/DiffOps/Div.UR.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/DiffOps/Div.UR.h,v
retrieving revision 1.5.2.2
diff -c -p -r1.5.2.2 Div.UR.h
*** src/NewField/DiffOps/Div.UR.h	2001/08/03 19:02:09	1.5.2.2
--- src/NewField/DiffOps/Div.UR.h	2001/08/23 22:59:14
***************
*** 55,61 ****
  
  #include "Tiny/Vector.h"
  #include "NewField/DiffOps/FieldStencil.h"
! #include "NewField/FieldEngine/FieldEngine.UR.h"
  
  //-----------------------------------------------------------------------------
  // Forward Declarations:
--- 55,61 ----
  
  #include "Tiny/Vector.h"
  #include "NewField/DiffOps/FieldStencil.h"
! #include "NewField/Mesh/UniformRectilinearMesh.h"
  
  //-----------------------------------------------------------------------------
  // Forward Declarations:
***************
*** 86,102 ****
  // 
  // Exported typedefs:
  //
- // OutputCentering_t - Centering parameter of the output DiscreteGeometry class
- // InputField_t      - Type of the input Field, which is restricted to 
- //                     something from the
- //                     DiscreteGeometry<Centering, UniformRectilinearMesh<Dim...> >
- //                     geometry and a vector or tensor type..
  // OutputElement_t   - Type of the elements in the output ConstField; 
  //                     restricted to a scalar type (vector input) or vector
  //                     (tensor input)
  // 
  // Accessors:
  //
  // lowerExtent(int d) - Returns the stencil width in direction d, at the "low"
  //                      end of the (logically) rectilinear mesh. This is the
  //                      maximum positive integer offset from the element 
--- 86,102 ----
  // 
  // Exported typedefs:
  //
  // OutputElement_t   - Type of the elements in the output ConstField; 
  //                     restricted to a scalar type (vector input) or vector
  //                     (tensor input)
  // 
  // Accessors:
  //
+ // inputCentering()   - Returns the centering of the input field.  This
+ //                      function is just provided as a sanity check for when
+ //                      the stencil is created.
+ // outputCentering()  - The centering of the output field. This centering is
+ //                      used to construct the return value of the stencil.
  // lowerExtent(int d) - Returns the stencil width in direction d, at the "low"
  //                      end of the (logically) rectilinear mesh. This is the
  //                      maximum positive integer offset from the element 
***************
*** 135,142 ****
  template<class T2, class Mesh>
  class DivVertToCell;
  
! template<class T2, int Dim, class TM, class CS>
! class DivVertToCell<Vector<Dim, T2>, UniformRectilinear<Dim, TM, CS> >
  {
  public:
  
--- 135,142 ----
  template<class T2, class Mesh>
  class DivVertToCell;
  
! template<class T2, int Dim, class TM>
! class DivVertToCell<Vector<Dim, T2>, UniformRectilinearMesh<Dim, TM> >
  {
  public:
  
*************** public:
*** 144,156 ****
  
    Centering<Dim> outputCentering() const
    {
!     return canonicalCentering<Dim>(CellType, Continuous);
    }
  
!   Loc<Dim> inputOffsets() const
    {
!     // input centering is Vert:
!     return Loc<Dim>(1);
    }
  
    // 
--- 144,155 ----
  
    Centering<Dim> outputCentering() const
    {
!     return canonicalCentering<Dim>(CellType, Continuous, AllDim);
    }
  
!   Centering<Dim> inputCentering() const
    {
!     return canonicalCentering<Dim>(VertexType, Continuous, AllDim);
    }
  
    // 
*************** public:
*** 174,180 ****
      int d;
      for (d = 0; d < Dim; ++d)
      {
!       fact_m(d) = 1 / fieldEngine.spacings()(d);
      }
    }
  
--- 173,179 ----
      int d;
      for (d = 0; d < Dim; ++d)
      {
!       fact_m(d) = 1 / fieldEngine.mesh().spacings()(d);
      }
    }
  
*************** private:
*** 244,251 ****
  template<class T2, class Mesh, int OC>
  class DivSameToSame;
  
! template<class T2, int Dim, class TM, class CS, int OC>
! class DivSameToSame<Vector<Dim, T2>, UniformRectilinear<Dim, TM, CS>, OC>
  {
  public:
  
--- 243,250 ----
  template<class T2, class Mesh, int OC>
  class DivSameToSame;
  
! template<class T2, int Dim, class TM, int OC>
! class DivSameToSame<Vector<Dim, T2>, UniformRectilinearMesh<Dim, TM>, OC>
  {
  public:
  
*************** public:
*** 256,264 ****
      return canonicalCentering<Dim>(OC, Continuous);
    }
  
!   Loc<Dim> inputOffsets() const
    {
!     return inputOffsets_m;
    }
  
    // 
--- 255,263 ----
      return canonicalCentering<Dim>(OC, Continuous);
    }
  
!   Centering<Dim> inputCentering() const
    {
!     return inputCentering_m;
    }
  
    // 
*************** public:
*** 274,280 ****
      {
        fact_m(d) = 0.5;
      }
-     inputOffsets_m = Loc<Dim>(0);
    }
  
    template<class FE>
--- 273,278 ----
*************** public:
*** 283,291 ****
      int d;
      for (d = 0; d < Dim; ++d)
      {
!       fact_m(d) = 0.5 / fieldEngine.spacings()(d);
      }
!     inputOffsets_m = fieldEngine.offsets();
    }
  
    //
--- 281,290 ----
      int d;
      for (d = 0; d < Dim; ++d)
      {
!       fact_m(d) = 0.5 / fieldEngine.mesh().spacings()(d);
      }
!     inputCentering_m = fieldEngine.centering();
!     PAssert(inputCentering_m == outputCentering);
    }
  
    //
*************** public:
*** 333,339 ****
  private:
  
    Vector<Dim, TM> fact_m;
!   Loc<Dim> inputOffsets_m;
  };
  
  #endif     // POOMA_NEWFIELD_DIFFOPS_DIV_UR_H
--- 332,338 ----
  private:
  
    Vector<Dim, TM> fact_m;
!   Centering<Dim> inputCentering_m;
  };
  
  #endif     // POOMA_NEWFIELD_DIFFOPS_DIV_UR_H
Index: src/NewField/DiffOps/Div.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/DiffOps/Div.h,v
retrieving revision 1.3.2.2
diff -c -p -r1.3.2.2 Div.h
*** src/NewField/DiffOps/Div.h	2001/08/03 19:02:09	1.3.2.2
--- src/NewField/DiffOps/Div.h	2001/08/23 22:59:14
***************
*** 101,113 ****
  // General Div template
  // ----------------------------------------------------------------------------
  
! template<class T2, class Geometry>
  class DivCellToVert;
  
! template<class T2, class Geometry>
  class DivVertToCell;
  
! template<class T2, class Geometry, int OC>
  class DivSameToSame;
  
  
--- 101,113 ----
  // General Div template
  // ----------------------------------------------------------------------------
  
! template<class T2, class Mesh>
  class DivCellToVert;
  
! template<class T2, class Mesh>
  class DivVertToCell;
  
! template<class T2, class Mesh, int OC>
  class DivSameToSame;
  
  
*************** class DivSameToSame;
*** 119,165 ****
  
  // Divergence.
  
! template<class Geometry, class T, class EngineTag>
  typename
! FieldStencilSimple<DivSameToSame<T, Geometry, CellType>,
!   Field<Geometry, T, EngineTag> >::Type_t
! divCellToCell(const Field<Geometry, T, EngineTag> &f)
  {
!   typedef DivSameToSame<T, Geometry, CellType> Div_t;
!   typedef FieldStencilSimple<Div_t, Field<Geometry, T, EngineTag> > Ret_t;
    return Ret_t::make(Div_t(f.fieldEngine()), f);
  }
  
! template<class Geometry, class T, class EngineTag>
  typename
! FieldStencilSimple<DivVertToCell<T, Geometry>,
!   Field<Geometry, T, EngineTag> >::Type_t
! divVertToCell(const Field<Geometry, T, EngineTag> &f)
  {
!   typedef DivVertToCell<T, Geometry> Div_t;
!   typedef FieldStencilSimple<Div_t, Field<Geometry, T, EngineTag> > Ret_t;
    return Ret_t::make(Div_t(f.fieldEngine()), f);
  }
  
! template<class Geometry, class T, class EngineTag>
  typename
! FieldStencilSimple<DivCellToVert<T, Geometry>,
!   Field<Geometry, T, EngineTag> >::Type_t
! divCellToVert(const Field<Geometry, T, EngineTag> &f)
  {
!   typedef DivCellToVert<T, Geometry> Div_t;
!   typedef FieldStencilSimple<Div_t, Field<Geometry, T, EngineTag> > Ret_t;
    return Ret_t::make(Div_t(f.fieldEngine()), f);
  }
  
! template<class Geometry, class T, class EngineTag>
  typename
! FieldStencilSimple<DivSameToSame<T, Geometry, VertexType>,
!   Field<Geometry, T, EngineTag> >::Type_t
! divVertToVert(const Field<Geometry, T, EngineTag> &f)
  {
!   typedef DivSameToSame<T, Geometry, VertexType> Div_t;
!   typedef FieldStencilSimple<Div_t, Field<Geometry, T, EngineTag> > Ret_t;
    return Ret_t::make(Div_t(f.fieldEngine()), f);
  }
  
--- 119,165 ----
  
  // Divergence.
  
! template<class Mesh, class T, class EngineTag>
  typename
! FieldStencilSimple<DivSameToSame<T, Mesh, CellType>,
!   Field<Mesh, T, EngineTag> >::Type_t
! divCellToCell(const Field<Mesh, T, EngineTag> &f)
  {
!   typedef DivSameToSame<T, Mesh, CellType> Div_t;
!   typedef FieldStencilSimple<Div_t, Field<Mesh, T, EngineTag> > Ret_t;
    return Ret_t::make(Div_t(f.fieldEngine()), f);
  }
  
! template<class Mesh, class T, class EngineTag>
  typename
! FieldStencilSimple<DivVertToCell<T, Mesh>,
!   Field<Mesh, T, EngineTag> >::Type_t
! divVertToCell(const Field<Mesh, T, EngineTag> &f)
  {
!   typedef DivVertToCell<T, Mesh> Div_t;
!   typedef FieldStencilSimple<Div_t, Field<Mesh, T, EngineTag> > Ret_t;
    return Ret_t::make(Div_t(f.fieldEngine()), f);
  }
  
! template<class Mesh, class T, class EngineTag>
  typename
! FieldStencilSimple<DivCellToVert<T, Mesh>,
!   Field<Mesh, T, EngineTag> >::Type_t
! divCellToVert(const Field<Mesh, T, EngineTag> &f)
  {
!   typedef DivCellToVert<T, Mesh> Div_t;
!   typedef FieldStencilSimple<Div_t, Field<Mesh, T, EngineTag> > Ret_t;
    return Ret_t::make(Div_t(f.fieldEngine()), f);
  }
  
! template<class Mesh, class T, class EngineTag>
  typename
! FieldStencilSimple<DivSameToSame<T, Mesh, VertexType>,
!   Field<Mesh, T, EngineTag> >::Type_t
! divVertToVert(const Field<Mesh, T, EngineTag> &f)
  {
!   typedef DivSameToSame<T, Mesh, VertexType> Div_t;
!   typedef FieldStencilSimple<Div_t, Field<Mesh, T, EngineTag> > Ret_t;
    return Ret_t::make(Div_t(f.fieldEngine()), f);
  }
  
Index: src/NewField/DiffOps/FieldShiftEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/DiffOps/Attic/FieldShiftEngine.h,v
retrieving revision 1.1.2.3
diff -c -p -r1.1.2.3 FieldShiftEngine.h
*** src/NewField/DiffOps/FieldShiftEngine.h	2001/08/16 18:26:41	1.1.2.3
--- src/NewField/DiffOps/FieldShiftEngine.h	2001/08/23 22:59:14
*************** public:
*** 114,119 ****
--- 114,128 ----
    }
  
    //---------------------------------------------------------------------------
+   // Construct an empty engine from a layout.
+ 
+   template<class Layout>
+   explicit Engine(const Layout &layout)
+     : domain_m(layout.domain()), exprEngine_m()
+   {
+   }
+ 
+   //---------------------------------------------------------------------------
    // Construct from a given field and an offset.
  
    Engine(const Expression_t &f, const Loc<Dim> &offset, Domain_t domain)
*************** struct NewEngineDomain<Engine<Dim, T, Fi
*** 360,373 ****
  template<class Expression>
  struct FieldShiftSimple
  {
!   typedef typename Expression::GeometryTag_t GeometryTag_t;
    typedef typename Expression::Element_t OutputElement_t;
    enum { outputDim = Expression::dimensions };
  
    typedef typename Expression::Engine_t InputEngine_t;
    typedef FieldShift<InputEngine_t> OutputEngineTag_t;
  
!   typedef Field<GeometryTag_t, OutputElement_t, OutputEngineTag_t> Type_t;
  
    typedef Engine<outputDim, OutputElement_t, OutputEngineTag_t> SEngine_t;
  
--- 369,382 ----
  template<class Expression>
  struct FieldShiftSimple
  {
!   typedef typename Expression::MeshTag_t MeshTag_t;
    typedef typename Expression::Element_t OutputElement_t;
    enum { outputDim = Expression::dimensions };
  
    typedef typename Expression::Engine_t InputEngine_t;
    typedef FieldShift<InputEngine_t> OutputEngineTag_t;
  
!   typedef Field<MeshTag_t, OutputElement_t, OutputEngineTag_t> Type_t;
  
    typedef Engine<outputDim, OutputElement_t, OutputEngineTag_t> SEngine_t;
  
*************** struct FieldShiftSimple
*** 376,385 ****
  	      const FieldOffset<outputDim> &s1,
                const Centering<outputDim> &centering)
    {
!     // This should be h(centering, f.mesh(), f.layout())
!     // (Ideally centering would come out of offset.)
  
!     Type_t h(f, centering);
  
      // Could change this to loop over centerings.
  
--- 385,394 ----
  	      const FieldOffset<outputDim> &s1,
                const Centering<outputDim> &centering)
    {
!     // Create a model field with the new centering.
  
!     Type_t h(centering, f.layout(), f.mesh());
!     h.fieldEngine().physicalCellDomain() = f.fieldEngine().physicalCellDomain();
  
      // Could change this to loop over centerings.
  
*************** struct FieldShiftSimple
*** 406,411 ****
--- 415,422 ----
        (f.numSubFields() > 0) ? f[s1.subFieldNumber()] : f;
      const Loc<outputDim> &offset = s1.cellOffset();
  
+     // FIXME: need to adjust guard layers based on centering???
+ 
      GuardLayers<outputDim> og(fld.fieldEngine().guardLayers());
      for (int d = 0; d < outputDim; d++)
        {
*************** struct FieldShiftSimple
*** 413,419 ****
  	og.upper(d) -= offset[d].first();
        }
  
-     // need to set domain???
      h.fieldEngine().guardLayers() = og;
      h.fieldEngine().engine() = SEngine_t(fld.engine(), offset, fld.domain());
  
--- 424,429 ----
*************** struct FieldShiftSimple
*** 427,436 ****
    {
      typedef std::vector<FieldOffset<outputDim> >::size_type size_type;
  
!     // This should be h(centering, f.mesh(), f.layout())
!     // (Ideally centering would come out of offset.)
  
!     Type_t h(f, centering);
  
      // Could change this to loop over centerings.
  
--- 437,446 ----
    {
      typedef std::vector<FieldOffset<outputDim> >::size_type size_type;
  
!     // Create a model field with the new centering.
  
!     Type_t h(centering, f.layout(), f.mesh());
!     h.fieldEngine().physicalCellDomain() = f.fieldEngine().physicalCellDomain();
  
      // Could change this to loop over centerings.
  
*************** struct FieldShiftSimple
*** 474,480 ****
  	  og.upper(d) -= offset[d].first();
  	}
  
-       // need to set domain???
        hField.fieldEngine().guardLayers() = og;
        hField.fieldEngine().engine() =
  	SEngine_t(fld.engine(), offset, fld.domain());
--- 484,489 ----
*************** struct FieldShiftSimple
*** 486,492 ****
  };
  
  //-----------------------------------------------------------------------------
! // Specializations for selecting the appropriate evaluator for the Stencil
  // engine.  We just get the appropriate types from the Expression's engine.
  //-----------------------------------------------------------------------------
  
--- 495,501 ----
  };
  
  //-----------------------------------------------------------------------------
! // Specializations for selecting the appropriate evaluator for the Shift
  // engine.  We just get the appropriate types from the Expression's engine.
  //-----------------------------------------------------------------------------
  
*************** struct LeafFunctor<Engine<Dim, T, FieldS
*** 689,707 ****
  // field with a FieldOffset.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, int Dim>
! struct View2<Field<GeometryTag, T, EngineTag>, FieldOffset<Dim>,
               Centering<Dim> >
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::Engine_t Engine_t;
  
    // The return types.
  
!   typedef Field<GeometryTag, T, FieldShift<Engine_t> > ReadType_t;
!   typedef Field<GeometryTag, T, FieldShift<Engine_t> > Type_t;
  
    // The functions that do the indexing.
  
--- 698,716 ----
  // field with a FieldOffset.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, int Dim>
! struct View2<Field<MeshTag, T, EngineTag>, FieldOffset<Dim>,
               Centering<Dim> >
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::Engine_t Engine_t;
  
    // The return types.
  
!   typedef Field<MeshTag, T, FieldShift<Engine_t> > ReadType_t;
!   typedef Field<MeshTag, T, FieldShift<Engine_t> > Type_t;
  
    // The functions that do the indexing.
  
*************** struct View2<Field<GeometryTag, T, Engin
*** 727,745 ****
  // field with a vector<FieldOffset>.
  //-----------------------------------------------------------------------------
  
! template<class GeometryTag, class T, class EngineTag, int Dim>
! struct View2<Field<GeometryTag, T, EngineTag>, std::vector<FieldOffset<Dim> >,
               Centering<Dim> >
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<GeometryTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::Engine_t Engine_t;
  
    // The return types.
  
!   typedef Field<GeometryTag, T, FieldShift<Engine_t> > ReadType_t;
!   typedef Field<GeometryTag, T, FieldShift<Engine_t> > Type_t;
  
    // The functions that do the indexing.
  
--- 736,754 ----
  // field with a vector<FieldOffset>.
  //-----------------------------------------------------------------------------
  
! template<class MeshTag, class T, class EngineTag, int Dim>
! struct View2<Field<MeshTag, T, EngineTag>, std::vector<FieldOffset<Dim> >,
               Centering<Dim> >
  {
    // Convenience typedef for the thing we're taking a view of.
    
!   typedef Field<MeshTag, T, EngineTag> Subject_t;
    typedef typename Subject_t::Engine_t Engine_t;
  
    // The return types.
  
!   typedef Field<MeshTag, T, FieldShift<Engine_t> > ReadType_t;
!   typedef Field<MeshTag, T, FieldShift<Engine_t> > Type_t;
  
    // The functions that do the indexing.
  
Index: src/NewField/DiffOps/FieldStencil.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/DiffOps/FieldStencil.h,v
retrieving revision 1.5.2.4
diff -c -p -r1.5.2.4 FieldStencil.h
*** src/NewField/DiffOps/FieldStencil.h	2001/08/21 17:08:39	1.5.2.4
--- src/NewField/DiffOps/FieldStencil.h	2001/08/23 22:59:15
*************** public:
*** 120,125 ****
--- 120,136 ----
    }
  
    //---------------------------------------------------------------------------
+   // Generic layout constructor lets you build an empty stencil object that
+   // has a given domain.
+ 
+   template<class Layout2>
+   explicit Engine(const Layout2 &layout)
+     : domain_m(layout.domain()), field_m(), functor_m()
+   {
+   }
+ 
+ 
+   //---------------------------------------------------------------------------
    // Construct from a stencil, an input field, and a new total domain.
    // Note: the way domains work with FieldStencils is a little screwy.
    // When originally constructing a FieldStencil, the domain of the engine
*************** struct NewEngine<Engine<Dim, T, ApplyFie
*** 409,433 ****
  template<class Functor, class Expression>
  struct FieldStencilSimple
  {
!   typedef typename Expression::GeometryTag_t GeometryTag_t;
    enum { outputDim = Expression::dimensions };
  
    typedef typename Functor::OutputElement_t OutputElement_t;
  
    typedef ApplyFieldStencil<Functor, Expression> OutputEngineTag_t;
!   typedef Field<GeometryTag_t, OutputElement_t, OutputEngineTag_t> Type_t;
  
    typedef Engine<outputDim, OutputElement_t, OutputEngineTag_t> SEngine_t;
  
    static inline
    Type_t make(const Functor &stencil, const Expression &f)
    {
!     Type_t h(f, stencil.outputCentering());
  
!     // FIXME: replace the following assertion with a check on
!     // stencil.inputCentering()
!     //    Loc<outputDim> inputOffsets = f.fieldEngine().offsets();
!     //    PAssert(inputOffsets == stencil.inputOffsets());
  
      GuardLayers<outputDim> og(f.fieldEngine().guardLayers());
      for (int d = 0; d < outputDim; d++)
--- 420,443 ----
  template<class Functor, class Expression>
  struct FieldStencilSimple
  {
!   typedef typename Expression::MeshTag_t MeshTag_t;
    enum { outputDim = Expression::dimensions };
  
    typedef typename Functor::OutputElement_t OutputElement_t;
  
    typedef ApplyFieldStencil<Functor, Expression> OutputEngineTag_t;
!   typedef Field<MeshTag_t, OutputElement_t, OutputEngineTag_t> Type_t;
  
    typedef Engine<outputDim, OutputElement_t, OutputEngineTag_t> SEngine_t;
  
    static inline
    Type_t make(const Functor &stencil, const Expression &f)
    {
!     Type_t h(stencil.outputCentering(), f.layout(), f.mesh());
!     h.fieldEngine().physicalCellDomain() = f.fieldEngine().physicalCellDomain();
  
!     // FIXME: need to add comparison for centerings.
!     //    PAssert(f.centering() == stencil.inputCentering());
  
      GuardLayers<outputDim> og(f.fieldEngine().guardLayers());
      for (int d = 0; d < outputDim; d++)
*************** struct FieldStencilSimple
*** 461,467 ****
    {
      PAssert(nn.size() == outputCentering.size());
  
!     Type_t h(f, outputCentering);
  
      // FIXME: The guard layers are wrong; we need to find the maximum
      // offsets from all the functors below.  (Should the individual
--- 471,478 ----
    {
      PAssert(nn.size() == outputCentering.size());
  
!     Type_t h(outputCentering, f.layout(), f.mesh());
!     h.fieldEngine().physicalCellDomain() = f.fieldEngine().physicalCellDomain();
  
      // FIXME: The guard layers are wrong; we need to find the maximum
      // offsets from all the functors below.  (Should the individual
*************** struct FieldStencilSimple
*** 506,512 ****
  // which computes a central difference divergence of a vertex-centered Field
  // and maps it to a cell-centered Field:
  //
! // template<class OutputCentering, class Geometry, class T>
  // class Div { };
  //  
  // template<class T2, int Dim, class TM, class CS>
--- 517,523 ----
  // which computes a central difference divergence of a vertex-centered Field
  // and maps it to a cell-centered Field:
  //
! // template<class OutputCentering, class Mesh, class T>
  // class Div { };
  //  
  // template<class T2, int Dim, class TM, class CS>
*************** struct FieldStencilSimple
*** 564,572 ****
  // A ConstField that contains an ApplyFieldStencil-engine that operates on
  // a Field f, is constructed by using operator()() for FieldStencil:
  //
! // View1<FieldStencil<Div<OutputCentering, Geometry, T> >, 
! //  ConstField<Geometry, T, EngineTag> >::make(
! //  Div<OutputCentering, Geometry, T>(), f);
  // 
  //-----------------------------------------------------------------------------
  
--- 575,583 ----
  // A ConstField that contains an ApplyFieldStencil-engine that operates on
  // a Field f, is constructed by using operator()() for FieldStencil:
  //
! // View1<FieldStencil<Div<OutputCentering, Mesh, T> >, 
! //  ConstField<Mesh, T, EngineTag> >::make(
! //  Div<OutputCentering, Mesh, T>(), f);
  // 
  //-----------------------------------------------------------------------------
  
Index: src/NewField/FieldEngine/FieldEngine.ExprEngine.h
===================================================================
RCS file: FieldEngine.ExprEngine.h
diff -N FieldEngine.ExprEngine.h
*** /dev/null	Tue May  5 14:32:27 1998
--- FieldEngine.ExprEngine.h	Thu Aug 23 16:59:15 2001
***************
*** 0 ****
--- 1,346 ----
+ // -*- C++ -*-
+ // ACL:license
+ // ----------------------------------------------------------------------
+ // This software and ancillary information (herein called "SOFTWARE")
+ // called POOMA (Parallel Object-Oriented Methods and Applications) is
+ // made available under the terms described here.  The SOFTWARE has been
+ // approved for release with associated LA-CC Number LA-CC-98-65.
+ // 
+ // Unless otherwise indicated, this SOFTWARE has been authored by an
+ // employee or employees of the University of California, operator of the
+ // Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
+ // the U.S. Department of Energy.  The U.S. Government has rights to use,
+ // reproduce, and distribute this SOFTWARE. The public may copy, distribute,
+ // prepare derivative works and publicly display this SOFTWARE without 
+ // charge, provided that this Notice and any statement of authorship are 
+ // reproduced on all copies.  Neither the Government nor the University 
+ // makes any warranty, express or implied, or assumes any liability or 
+ // responsibility for the use of this SOFTWARE.
+ // 
+ // If SOFTWARE is modified to produce derivative works, such modified
+ // SOFTWARE should be clearly marked, so as not to confuse it with the
+ // version available from LANL.
+ // 
+ // For more information about POOMA, send e-mail to pooma@acl.lanl.gov,
+ // or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
+ // ----------------------------------------------------------------------
+ // ACL:license
+ 
+ //-----------------------------------------------------------------------------
+ // Classes: 
+ //   FieldEngineBase specialized for Expression-engines
+ //-----------------------------------------------------------------------------
+ 
+ #ifndef POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_EXPRENGINE__H
+ #define POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_EXPRENGINE__H
+ 
+ //-----------------------------------------------------------------------------
+ // Overview: 
+ // 
+ // FieldEngineBase and related classes. POOMA supports a flexible form 
+ // of "centering" that allows a hierarchy of multiple centering points per 
+ // cell. The centering information, managed by the FieldEngineBase
+ // class, is initialized using a flexible set of functors.
+ //-----------------------------------------------------------------------------
+ 
+ //-----------------------------------------------------------------------------
+ // Includes:
+ //-----------------------------------------------------------------------------
+ 
+ #include "Domain/Loc.h"
+ #include "Engine/ExpressionEngine.h"
+ #include "Layout/GuardLayers.h"
+ #include "Utilities/PAssert.h"
+ 
+ 
+ //-----------------------------------------------------------------------------
+ // Forward declarations:
+ //-----------------------------------------------------------------------------
+ 
+ template<int Dim, class T, class EngineTag> class FieldEngineBase;
+ template<class GeometryTag, class T, class EngineTag> class Field;
+ 
+ 
+ //-----------------------------------------------------------------------------
+ // Handy combiners for getting the far-left field in an expression.
+ //-----------------------------------------------------------------------------
+ 
+ struct FarLeftTag
+ {
+   POOMA_PURIFY_CONSTRUCTORS(FarLeftTag)
+ };
+ 
+ template<class G1, class T1, class E1, class Op>
+ struct Combine1<Field<G1, T1, E1>, Op, FarLeftTag>
+ {
+   typedef Field<G1, T1, E1> Type_t;
+   inline static
+   const Type_t &combine(const Field<G1, T1, E1> &a,
+ 			const FarLeftTag &) 
+     { 
+       return a; 
+     }
+ };
+ 
+ template<class G1, class T1, class E1, class G2, class T2, class E2, 
+   class Op>
+ struct Combine2<Field<G1, T1, E1>, Field<G2, T2, E2>, Op, FarLeftTag>
+ {
+   typedef Field<G1, T1, E1> Type_t;
+   inline static
+   const Type_t &combine(const Field<G1, T1, E1> &a, 
+                         const Field<G2, T2, E2> &, FarLeftTag)
+     {
+       return a;
+     }
+ };
+ 
+ template<class T, class G2, class T2, class E2, class Op>
+ struct Combine2<T, Field<G2, T2, E2>, Op, FarLeftTag>
+ {
+   typedef Field<G2, T2, E2> Type_t;
+   inline static
+   const Type_t &combine(const T &, 
+                         const Field<G2, T2, E2> &b, FarLeftTag)
+     {
+       return b;
+     }
+ };
+ 
+ template<class G1, class T1, class E1, class T, class Op>
+ struct Combine2<Field<G1, T1, E1>, T, Op, FarLeftTag>
+ {
+   typedef Field<G1, T1, E1> Type_t;
+   inline static
+   const Type_t &combine(const Field<G1, T1, E1> &a, 
+                         const T &, FarLeftTag)
+     {
+       return a;
+     }
+ };
+ 
+ template<class A,class B,class C,class Op>
+ struct Combine3<A, B, C, Op, FarLeftTag>
+ {
+   typedef typename Combine2<A, B, Op, FarLeftTag>::Type_t Type1_t;
+   typedef typename Combine2<Type1_t, C, Op, FarLeftTag>::Type_t Type_t;
+   inline static
+   const Type_t &combine(const A& a, const B& b, const C& c,
+ 			const FarLeftTag& t)
+   {
+     return
+       Combine2<Type1_t, C,
+       Op, FarLeftTag>::combine(Combine2<A, B, Op,
+ 			       FarLeftTag>::combine(a, b, t), c, t);
+   }
+ };
+ 
+ //-----------------------------------------------------------------------------
+ // This version of LeafFunctor is used by Expression-Engines to 
+ // get at the far-left field in an expression. 
+ //-----------------------------------------------------------------------------
+ 
+ template<class GeometryTag, class T, class EngineTag>
+ struct LeafFunctor<Field<GeometryTag, T, EngineTag>, FarLeftTag>
+ {
+   typedef Field<GeometryTag, T, EngineTag> Type_t;
+   inline static
+   const Type_t &apply(const Field<GeometryTag, T, EngineTag> &f, 
+     const FarLeftTag &) 
+     {
+       return f;
+     }
+ };
+ 
+ template<class T>
+ struct LeafFunctor<Scalar<T>, FarLeftTag>
+ {
+   typedef Scalar<T> Type_t;
+   inline static
+   const Type_t &apply(const Scalar<T> &s, const FarLeftTag &) 
+     {
+       return s;
+     }
+ };
+ 
+ 
+ // ----------------------------------------------------------------------------
+ // FieldEngine<Dim, T, ExpressionTag<Expr> >
+ //
+ // This is a specialization of FieldEngine for expression-engines.
+ // ----------------------------------------------------------------------------
+ 
+ template<class Mesh, class T, class Expr>
+ class FieldEngine<Mesh, T, ExpressionTag<Expr> >
+ {
+ public:
+ 
+   //---------------------------------------------------------------------------
+   // Exported typedefs and enumerations.
+     
+   enum { dimensions = Mesh::dimensions };
+   enum { Dim = dimensions };
+   typedef ExpressionTag<Expr> EngineTag_t;
+   typedef FieldEngine<Mesh, T, EngineTag_t> This_t;
+   typedef Engine<Dim, T, EngineTag_t> Engine_t;
+   typedef typename Engine_t::Domain_t Domain_t;
+   typedef typename Engine_t::Layout_t Layout_t;
+   typedef typename Engine_t::Element_t Element_t;
+   typedef typename Engine_t::ElementRef_t ElementRef_t;
+   typedef GuardLayers<Dim> GuardLayers_t;
+   typedef typename ForEach<Expr, FarLeftTag, FarLeftTag>::Type_t 
+     ReferenceField_t;
+ 
+ 
+   //---------------------------------------------------------------------------
+   // Constructors.
+ 
+   // Expression constructor.  
+   
+   FieldEngine(const Engine_t &e)
+   : engine_m(e),
+     referenceField_m(
+       forEachRef(engine_m.expression(), FarLeftTag(), FarLeftTag()))
+     { }  
+     
+   // Domain view constructor. 
+ 
+   template<class Expr2, class Domain>  
+   FieldEngine(const FieldEngine<Mesh, T, ExpressionTag<Expr2> > &model, 
+     const Domain &d)
+   : engine_m(NewEngineEngine<Engine<Dim, T, ExpressionTag<Expr2> >, Domain>::apply(model.engine(), d),
+ 	     NewEngineDomain<Engine<Dim, T, ExpressionTag<Expr2> >, Domain>::apply(model.engine(), d)
+ 	     ),
+     referenceField_m(
+       forEachRef(engine_m.expression(), FarLeftTag(), FarLeftTag()))
+     { }  
+     
+   // Sub-field view constructor. This is when we want to construct a view of
+   // one of the subFields in our top-level list.
+ 
+   template<class Expr2>  
+   FieldEngine(const FieldEngine<Mesh, T, ExpressionTag<Expr2> > &model, 
+     const int &iSubField)
+   : engine_m(model.engine(), iSubField),
+     referenceField_m(
+       forEachRef(engine_m.expression(), FarLeftTag(), FarLeftTag()))
+     { }  
+ 
+   // Very important! Copy constructor is needed so that referenceField_m
+   // doesn't refer to someone else's expression.      
+ 
+   FieldEngine(const FieldEngine<Mesh, T, ExpressionTag<Expr> > &other)
+   : engine_m(other.engine()),
+     referenceField_m(forEachRef(engine_m.expression(),
+ 				FarLeftTag(), FarLeftTag()))
+   { }  
+     
+   //---------------------------------------------------------------------------
+   // Accessors and modifiers.
+     
+   // FIXME: This function is deprecated.
+   inline int numSubFields() const
+     {
+       return referenceField().numSubFields();
+     }
+ 
+   inline const Engine_t &engine() const
+     {
+       return engine_m;
+     }
+ 
+   const ReferenceField_t &referenceField() const
+   {
+     return referenceField_m;
+   }
+   
+ 
+   //---------------------------------------------------------------------------
+   // Domain accessor functions. 
+         
+   inline const Domain_t physicalCellDomain() const
+     {
+       return referenceField_m.physicalCellDomain();
+     }
+         
+   inline Domain_t totalCellDomain() const
+     {
+       return referenceField_m.totalCellDomain();
+     }
+ 
+   Domain_t physicalDomain() const
+     {
+       return referenceField_m.physicalDomain();
+     }
+ 
+   Domain_t totalDomain() const
+     {
+       return referenceField_m.totalDomain();
+     }
+ 
+   Domain_t physicalDomain(int iSubField) const
+     {
+       return referenceField_m.physicalDomain(iSubField);
+     }
+ 
+   Domain_t totalDomain(int iSubField) const
+     {
+       return referenceField_m.totalDomain(iSubField);
+     }
+ 
+   //---------------------------------------------------------------------------
+   // Centering accessors.
+ 
+   const Centering<Dim> &centering() const
+   {
+     return referenceField_m.centering();
+   }        
+ 
+   inline int centeringSize() const
+     {
+       return referenceField_m.centering().size();
+     }
+ 
+   inline int numMaterials() const
+     {
+       return referenceField_m.numMaterials();
+     }
+ 
+       
+ private:
+ 
+   // There is no way to reinitialize the reference, so assignment
+   // cannot be implemented.
+ 
+   This_t &operator=(const This_t &other);
+     
+   Engine_t engine_m;
+   const ReferenceField_t &referenceField_m;
+ };
+ 
+ template<class Mesh, class T, class Expr, class Tag>
+ struct LeafFunctor<FieldEngine<Mesh, T, ExpressionTag<Expr> >,
+   ExpressionApply<Tag> >
+ {
+   typedef FieldEngine<Mesh, T, ExpressionTag<Expr> > Subject_t;
+   typedef typename Subject_t::Engine_t Engine_t;
+   typedef LeafFunctor<Engine_t, ExpressionApply<Tag> > LeafFunctor_t;
+   typedef int Type_t;
+ 
+   inline static
+   Type_t apply(const Subject_t &fieldEngineBase, 
+ 	       const ExpressionApply<Tag> &tag)
+   {
+     LeafFunctor_t::apply(fieldEngineBase.engine(), tag);
+     return 0;
+   }
+ };
+ 
+ #endif // POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_EXPRENGINE__H
+ 
+ // ACL:rcsinfo
+ // ----------------------------------------------------------------------
+ // $RCSfile: FieldEngineBase.ExprEngine.h,v $   $Author: oldham $
+ // $Revision: 1.12.2.1 $   $Date: 2001/08/14 20:24:18 $
+ // ----------------------------------------------------------------------
+ // ACL:rcsinfo
Index: src/NewField/FieldEngine/FieldEngine.Lagrangian.h
===================================================================
RCS file: FieldEngine.Lagrangian.h
diff -N FieldEngine.Lagrangian.h
*** /tmp/cvsRZdAGh	Thu Aug 23 16:59:29 2001
--- /dev/null	Tue May  5 14:32:27 1998
***************
*** 1,275 ****
- // -*- C++ -*-
- // ACL:license
- // ----------------------------------------------------------------------
- // This software and ancillary information (herein called "SOFTWARE")
- // called POOMA (Parallel Object-Oriented Methods and Applications) is
- // made available under the terms described here.  The SOFTWARE has been
- // approved for release with associated LA-CC Number LA-CC-98-65.
- // 
- // Unless otherwise indicated, this SOFTWARE has been authored by an
- // employee or employees of the University of California, operator of the
- // Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
- // the U.S. Department of Energy.  The U.S. Government has rights to use,
- // reproduce, and distribute this SOFTWARE. The public may copy, distribute,
- // prepare derivative works and publicly display this SOFTWARE without 
- // charge, provided that this Notice and any statement of authorship are 
- // reproduced on all copies.  Neither the Government nor the University 
- // makes any warranty, express or implied, or assumes any liability or 
- // responsibility for the use of this SOFTWARE.
- // 
- // If SOFTWARE is modified to produce derivative works, such modified
- // SOFTWARE should be clearly marked, so as not to confuse it with the
- // version available from LANL.
- // 
- // For more information about POOMA, send e-mail to pooma@acl.lanl.gov,
- // or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
- // ----------------------------------------------------------------------
- // ACL:license
- 
- //-----------------------------------------------------------------------------
- // Classes: 
- //   Lagrangian<Dim, TM, CoordinateSystem>
- //   FieldEngine<Lagrangian<...>, T, EngineTag>
- //-----------------------------------------------------------------------------
- 
- #ifndef POOMA_NEWFIELD_FIELDENGINE_LAGRANGIAN_H
- #define POOMA_NEWFIELD_FIELDENGINE_LAGRANGIAN_H
- 
- //-----------------------------------------------------------------------------
- // Overview: 
- // 
- // FieldEngine<Lagrangian, T, EngineTag>
- //-----------------------------------------------------------------------------
- 
- //-----------------------------------------------------------------------------
- // Includes:
- //-----------------------------------------------------------------------------
- 
- #include "NewField/FieldEngine/FieldEngineBase.h"
- 
- #include "Array/Array.h"
- #include "CoordinateSystems/Cartesian.h"
- #include "Domain/Interval.h"
- #include "Engine/ConstantFunctionEngine.h"
- #include "Engine/EnginePatch.h"
- #include "Engine/IndexFunctionEngine.h"
- #include "Layout/INode.h"
- #include "PETE/PETE.h"
- #include "Pooma/Indices.h"
- #include "Tiny/Vector.h"
- #include "Utilities/PAssert.h"
- 
- 
- //-----------------------------------------------------------------------------
- // Forward Declarations:
- //-----------------------------------------------------------------------------
- 
- template<class GeometryTag, class T, class EngineTag> class FieldEngine;
- 
- 
- //-----------------------------------------------------------------------------
- // Full Description:
- // 
- // Lagrangian tag class.
- //-----------------------------------------------------------------------------
- 
- template<int Dim, class TM =  POOMA_DEFAULT_POSITION_TYPE,
-   class CoordinateSystem = Cartesian<Dim> >
- struct Lagrangian;
- 
- 
- //-----------------------------------------------------------------------------
- // Full Description:
- // 
- // FieldEngine, specialized for a rudimentary Lagrangian mesh.
- //-----------------------------------------------------------------------------
- 
- template<int Dim, class TM, class CoordinateSystem, class T, class EngineTag>
- class FieldEngine<Lagrangian<Dim, TM, CoordinateSystem>, T, EngineTag> :
-   public FieldEngineBase<Dim, T, EngineTag>
- {
- public:
- 
-   //---------------------------------------------------------------------------
-   // Exported typedefs and enumerations.
- 
-   // This class.
-   
-   typedef FieldEngine<Lagrangian<Dim, TM, CoordinateSystem>, T, EngineTag>
-     This_t;
-     
-   // Our base class.
-   
-   typedef FieldEngineBase<Dim, T, EngineTag> Base_t;
- 
-   // The geometry tag.
-   
-   typedef Lagrangian<Dim, TM, CoordinateSystem> GeometryTag_t;
-   
-   // The engine tag.
-   
-   typedef EngineTag EngineTag_t;
-   
-   // The coordinate system.
-   
-   typedef CoordinateSystem CoordinateSystem_t;
-   
-   // The domain type.
-   
-   typedef typename Base_t::Domain_t Domain_t;
-   
-   // The number of indices required to select a point in this mesh.
-   
-   enum { dimensions = Dim };
-   
-   // The type used to represent a point in the mesh.
-   
-   typedef Vector<Dim, TM> PointType_t;
-   
-   // Our engine type.
-   
-   typedef Engine<Dim, T, EngineTag> Engine_t;
-   
-   // Our layout type.
-   
-   typedef typename Engine_t::Layout_t Layout_t;
- 
- 
-   //---------------------------------------------------------------------------
-   // Constructors. We don't use default arguments for the origin and spacings
-   // because that produces ambiguities.
- 
-   template<class BaseInitializer>  
-   FieldEngine(const BaseInitializer &baseInit, 
-     const Layout_t &layout,
-     const PointType_t &origin,
-     const PointType_t &spacings)
-   : Base_t(baseInit, layout),
-     positions_m(layout)
-     {
-       positions_m = origin + iota(growRight(totalCellDomain(), 1) - 
-         physicalCellDomain().firsts()) * spacings;
-     }
-     
-   // Copy constructor.
-   
-   FieldEngine(const This_t &model)
-   : Base_t(model),
-     positions_m(model.positions_m)
-     { }
-     
-   // Copy constructor (except for updaters).
- 
-   FieldEngine(const This_t &model, const Pooma::DontCopyRelations &d)
-   : Base_t(model, d),
-     positions_m(model.positions_m)
-     { }
-     
-   // Sub-field constructor.
-   
-   FieldEngine(const This_t &model, const int &iSubField)
-   : Base_t(model, iSubField),
-     positions_m(model.positions_m)
-     { }
- 
-   // Domain view constructors.
- 
-   template<class T2, class ET2>  
-   FieldEngine(const FieldEngine<GeometryTag_t, T2, ET2> &model, 
-     const Domain_t &d)
-   : Base_t(model, d),
-     positions_m(model.vertexPositions()(translateToVertexDomain(d)))
-     { }
- 
-   template<class T2, class ET2>  
-   FieldEngine(const FieldEngine<GeometryTag_t, T2, ET2> &model, 
-     const INode<Dim> &inode)
-   : Base_t(model, inode),
-     positions_m(model.vertexPositions()(inode))
-     { }
- 
-   // Note there is no change to the vertex positions, because EngineView
-   // currently is only used to support RemoteView operations which don't
-   // change the domain.
-   template<class T2, class ET2, class Tag>  
-   FieldEngine(const FieldEngine<GeometryTag_t, T2, ET2> &model, 
-     const EngineView<Tag> &engineView)
-   : Base_t(model, engineView),
-     positions_m(forEach(model.vertexPositions(), engineView, TreeCombine()))
-   { }
- 
-   // Expression-engine constructor.    
- 
-   FieldEngine(const Engine<Dim, T, EngineTag> &e)
-   : Base_t(e),
-     positions_m(referenceField().fieldEngine().vertexPositions())
-     { }
- 
-   // Patch constructor.    
- 
-   template<class ET2>
-   FieldEngine(const FieldEngine<GeometryTag_t, T, ET2> &model, 
-               const FieldEnginePatch<Dim> &p)
-   : Base_t(model, p),
-     positions_m(model.vertexPositions().patchLocal(p.patch_m))
-     { }
- 
- 
-   //---------------------------------------------------------------------------
-   // Copy assignment operator (shallow).
-   
-   This_t &operator=(const This_t &rhs);
- 
- 
-   //---------------------------------------------------------------------------
-   // Empty destructor is fine.
-   
-   ~FieldEngine() { }
- 
- 
-   //---------------------------------------------------------------------------
-   // Return the vertex centers. 
-   
-   typedef Array<Dim, PointType_t, EngineTag_t> VertexPositionsArray_t;
- 
-   const VertexPositionsArray_t &vertexPositions() const
-     {
-       return positions_m;
-     }
-   
- private:
- 
-   VertexPositionsArray_t positions_m;
- 
- };
- 
- template<int Dim, class TM, class CoordinateSystem, class T, class EngineTag,
-   class Tag>
- struct LeafFunctor<
-   FieldEngine<Lagrangian<Dim, TM, CoordinateSystem>, T, EngineTag>, 
-   ExpressionApply<Tag> >
- {
-   typedef Lagrangian<Dim, TM, CoordinateSystem> GeometryTag_t;
-   typedef FieldEngine<GeometryTag_t, T, EngineTag> Subject_t;
-   typedef typename Subject_t::Engine_t Engine_t;
-   typedef LeafFunctor<Engine_t, ExpressionApply<Tag> > LeafFunctor_t;
-   typedef int Type_t;
- 
-   inline static
-   Type_t apply(const Subject_t &fieldEngine, const ExpressionApply<Tag> &tag)
-   {
-     forEach(fieldEngine.vertexPositions(), tag, NullCombine());
-     
-     return LeafFunctor_t::apply(fieldEngine.engine(), tag);
-   }
- };
- 
- #endif // POOMA_NEWFIELD_FIELDENGINE_LAGRANGIAN_H
- 
- // ACL:rcsinfo
- // ----------------------------------------------------------------------
- // $RCSfile: FieldEngine.Lagrangian.h,v $   $Author: sasmith $
- // $Revision: 1.5.2.2 $   $Date: 2001/08/21 18:26:14 $
- // ----------------------------------------------------------------------
- // ACL:rcsinfo
- 
--- 0 ----
Index: src/NewField/FieldEngine/FieldEngine.NoGeometry.h
===================================================================
RCS file: FieldEngine.NoGeometry.h
diff -N FieldEngine.NoGeometry.h
*** /tmp/cvsC9TNim	Thu Aug 23 16:59:29 2001
--- /dev/null	Tue May  5 14:32:27 1998
***************
*** 1,344 ****
- // -*- C++ -*-
- // ACL:license
- // ----------------------------------------------------------------------
- // This software and ancillary information (herein called "SOFTWARE")
- // called POOMA (Parallel Object-Oriented Methods and Applications) is
- // made available under the terms described here.  The SOFTWARE has been
- // approved for release with associated LA-CC Number LA-CC-98-65.
- // 
- // Unless otherwise indicated, this SOFTWARE has been authored by an
- // employee or employees of the University of California, operator of the
- // Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
- // the U.S. Department of Energy.  The U.S. Government has rights to use,
- // reproduce, and distribute this SOFTWARE. The public may copy, distribute,
- // prepare derivative works and publicly display this SOFTWARE without 
- // charge, provided that this Notice and any statement of authorship are 
- // reproduced on all copies.  Neither the Government nor the University 
- // makes any warranty, express or implied, or assumes any liability or 
- // responsibility for the use of this SOFTWARE.
- // 
- // If SOFTWARE is modified to produce derivative works, such modified
- // SOFTWARE should be clearly marked, so as not to confuse it with the
- // version available from LANL.
- // 
- // For more information about POOMA, send e-mail to pooma@acl.lanl.gov,
- // or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
- // ----------------------------------------------------------------------
- // ACL:license
- 
- //-----------------------------------------------------------------------------
- // Classes: 
- //   NoGeometry<Dim>
- //   FieldEngine<NoGeometry, T, EngineTag>
- //-----------------------------------------------------------------------------
- 
- #ifndef POOMA_NEWFIELD_FIELDENGINE_NOGEOMETRY_H
- #define POOMA_NEWFIELD_FIELDENGINE_NOGEOMETRY_H
- 
- //-----------------------------------------------------------------------------
- // Overview: 
- // 
- // FieldEngine<NoGeometry, T, EngineTag>
- //-----------------------------------------------------------------------------
- 
- //-----------------------------------------------------------------------------
- // Includes:
- //-----------------------------------------------------------------------------
- #include "NewField/FieldEngine/FieldEngineBase.h"
- 
- #include "Array/Array.h"
- #include "Domain/Interval.h"
- #include "Engine/ConstantFunctionEngine.h"
- #include "Engine/IndexFunctionEngine.h"
- #include "Layout/INode.h"
- #include "NewField/Relations/RelationList.h"
- #include "Tiny/Vector.h"
- #include "Utilities/PAssert.h"
- 
- 
- //-----------------------------------------------------------------------------
- // Forward Declarations:
- //-----------------------------------------------------------------------------
- 
- template<class Components> class ComponentWrapper;
- template<int Dim, class T, class EngineTag> class Engine;
- template<class GeometryTag, class T, class EngineTag> class FieldEngine;
- 
- 
- //-----------------------------------------------------------------------------
- // NoGeometry tag class.
- //-----------------------------------------------------------------------------
- 
- template<int Dim>
- struct NoGeometry;
- 
- 
- //-----------------------------------------------------------------------------
- // FieldEngine, specialized for no geometry. This is really just a field
- // wrapper of a single engine.
- //-----------------------------------------------------------------------------
- 
- template<int Dim, class T, class EngineTag>
- class FieldEngine<NoGeometry<Dim>, T, EngineTag> :
-   public FieldEngineBase<Dim, T, EngineTag>
- {
- public:
- 
-   //---------------------------------------------------------------------------
-   // Exported typedefs and enumerations.
- 
-   // This class.
-   
-   typedef FieldEngine<NoGeometry<Dim>, T, EngineTag> This_t;
-     
-   // Our base class.
-   
-   typedef FieldEngineBase<Dim, T, EngineTag> Base_t;
- 
-   // The geometry tag.
-   
-   typedef NoGeometry<Dim> GeometryTag_t;
-   
-   // The engine tag.
-   
-   typedef EngineTag EngineTag_t;
-     
-   // The domain type.
-   
-   typedef typename Base_t::Domain_t Domain_t;
-   
-   // The number of indices required to select a point in this mesh.
-   
-   enum { dimensions = Dim };
-   
-   // Our engine type.
-   
-   typedef Engine<Dim, T, EngineTag> Engine_t;
-   
-   // Our layout type.
-   
-   typedef typename Engine_t::Layout_t Layout_t;
-   
-   // Our guard layers type.
-   
-   typedef GuardLayers<Dim> GuardLayers_t;
- 
- 
-   //---------------------------------------------------------------------------
-   // Constructors.
-   //
-   // There is no sub-field constructor because this field-engine can't have
-   // subfields.
- 
-   // Default constructor.
-   FieldEngine()
-   : engine_m(Pooma::NoInit()),
-     guards_m(0),
-     relations_m()
-     { }
- 
-   // Copy constructor.
-   
-   FieldEngine(const This_t &model)
-   : engine_m(model.engine_m),
-     guards_m(model.guards_m),
-     relations_m(model.relations_m)
-     { }
- 
-   // Domain view constructor, including INodes and non-interval
-   // views. 
- 
-   template<class G2, class T2, class ET2, class Domain>  
-   FieldEngine(const FieldEngine<G2, T2, ET2> &model, 
-     const Domain &d)
-   : engine_m(NewEngineEngine<typename 
-       FieldEngine<G2, T2, ET2>::Engine_t, Domain>::apply(model.engine(), d), 
-              NewEngineDomain<typename
-       FieldEngine<G2, T2, ET2>::Engine_t, Domain>::apply(model.engine(), d)),
-     relations_m(model.relations())
-     { }
-     
-   // Sub-field constructor. Needs to exist, but shouldn't be called since we
-   // have no subfields.
-   
-   template<class G2, class T2, class ET2>  
-   FieldEngine(const FieldEngine<G2, T2, ET2> &model, const int &)
-   : engine_m(model.engine())
-     {
-       PError("Can't create a sub-field of a FieldEngine<NoGeometry,...>.");
-     }
- 
-   // Expression-engine constructor.    
- 
-   FieldEngine(const Engine<Dim, T, EngineTag> &e)
-   : engine_m(e)
-     {
-     }
- 
-   // Patch constructor.    
- 
-   template<class ET2>
-   FieldEngine(const FieldEngine<GeometryTag_t, T, ET2> &model, 
-               const FieldEnginePatch<Dim> &p)
-   : engine_m(engineFunctor(model.engine(), p)),
-     relations_m(model.relations())
-     { }
-     
-   // ComponentView constructor. The geometry for the model should be the
-   // same since a component view simply mutates the elements.
- 
-   template<class T2, class ET2, class Components>  
-   FieldEngine(const FieldEngine<GeometryTag_t, T2, ET2> &model, 
-     const ComponentWrapper<Components> &c)
-   : engine_m(model.engine(), c.components()),
-     relations_m(model.relations())
-     { }
- 
-   // EngineView version used for remote computations.
- 
-   template<class G2, class T2, class ET2, class Tag>  
-   FieldEngine(const FieldEngine<G2, T2, ET2> &model, 
- 	      const EngineView<Tag> &engineView)
-     : engine_m(leafFunctor(model.engine(), engineView)),
-     relations_m(model.relations())
-   { }
-     
-   //---------------------------------------------------------------------------
-   // Copy assignment operator (disabled).
-   
-   This_t &operator=(const This_t &rhs);
- 
- 
-   //---------------------------------------------------------------------------
-   // Empty destructor is fine.
-   
-   ~FieldEngine() { }
-       
- 
-   //---------------------------------------------------------------------------
-   // Accessors and modifiers.
-     
-   // FIXME: This function is deprecated.
-   inline int numSubFields() const
-     {
-       return 0;
-     }
- 
-   const Loc<Dim> offsets() const
-     {
-       // Always vert-centered...
-       
-       return Loc<Dim>(1); 
-     }
-     
-   Engine_t &engine()
-     {
-       return engine_m;
-     }
-     
-   const Engine_t &engine() const
-     {
-       return engine_m;
-     }
- 
-   RelationList &relations() const
-     {
-       return relations_m;
-     }
-     
-   const GuardLayers_t &guardLayers() const
-     {
-       return guards_m;
-     }
- 
- 
-   //---------------------------------------------------------------------------
-   // Domain accessor functions.
-   //
-   // This field-engine always has vert-centering and the total domain is
-   // given by the engine.
-         
-   inline const Domain_t physicalCellDomain() const
-     {
-       return shrinkRight(physicalDomain(), 1);
-     }
-         
-   inline Domain_t totalCellDomain() const
-     {
-       return shrinkRight(engine_m.domain(), 1);
-     }
- 
-   Domain_t physicalDomain() const
-     {
-       return shrink(engine_m.domain(), guards_m);
-     }
- 
-   Domain_t totalDomain() const
-     {
-       return engine_m.domain();
-     }
- 
-   Domain_t physicalDomain(int iSubField) const
-     {
-       // This field engine cannot have subfields.
-       PAssert(iSubField == 0);
-       return physicalDomain();
-     }
- 
-   Domain_t totalDomain(int iSubField) const
-     {
-       // This field engine cannot have subfields.
-       PAssert(iSubField == 0);
-       return engine_m.domain();
-     }
- 
-   //---------------------------------------------------------------------------
-   // Make a distinct copy of this fieldEngineBase.   
-  
-   template<class Subject>
-   void makeOwnCopy(const Subject &s)
-     {
-       // Deepen the copies of the engine & relations list.
-       
-       engine().makeOwnCopy();
-       relations().makeOwnCopy(s);
-     }
-   
- private:
- 
-   Engine_t engine_m;
-   GuardLayers_t guards_m;
-   mutable RelationList relations_m;
- };
- 
- // This version of field engine requires a specialization of ExpressionApply,
- // since the default version assume a field engine that uses FieldEngineBase.
- 
- template<int Dim, class T, class EngineTag, class Tag>
- struct LeafFunctor<
-   FieldEngine<NoGeometry<Dim>, T, EngineTag>, 
-   ExpressionApply<Tag> >
- {
-   typedef NoGeometry<Dim> GeometryTag_t;
-   typedef FieldEngine<GeometryTag_t, T, EngineTag> Subject_t;
-   typedef typename Subject_t::Engine_t Engine_t;
-   typedef LeafFunctor<Engine_t, ExpressionApply<Tag> > LeafFunctor_t;
-   typedef int Type_t;
- 
-   inline static
-   Type_t apply(const Subject_t &fieldEngine, const ExpressionApply<Tag> &tag)
-   {
-     return LeafFunctor_t::apply(fieldEngine.engine(), tag);
-   }
- };
- 
- 
- #endif // POOMA_NEWFIELD_FIELDENGINE_NOGEOMETRY_H
- 
- // ACL:rcsinfo
- // ----------------------------------------------------------------------
- // $RCSfile: FieldEngine.NoGeometry.h,v $   $Author: sasmith $
- // $Revision: 1.5.2.3 $   $Date: 2001/08/21 18:26:15 $
- // ----------------------------------------------------------------------
- // ACL:rcsinfo
- 
--- 0 ----
Index: src/NewField/FieldEngine/FieldEngine.UR.h
===================================================================
RCS file: FieldEngine.UR.h
diff -N FieldEngine.UR.h
*** /tmp/cvsBUNegs	Thu Aug 23 16:59:29 2001
--- /dev/null	Tue May  5 14:32:27 1998
***************
*** 1,324 ****
- // -*- C++ -*-
- // ACL:license
- // ----------------------------------------------------------------------
- // This software and ancillary information (herein called "SOFTWARE")
- // called POOMA (Parallel Object-Oriented Methods and Applications) is
- // made available under the terms described here.  The SOFTWARE has been
- // approved for release with associated LA-CC Number LA-CC-98-65.
- // 
- // Unless otherwise indicated, this SOFTWARE has been authored by an
- // employee or employees of the University of California, operator of the
- // Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
- // the U.S. Department of Energy.  The U.S. Government has rights to use,
- // reproduce, and distribute this SOFTWARE. The public may copy, distribute,
- // prepare derivative works and publicly display this SOFTWARE without 
- // charge, provided that this Notice and any statement of authorship are 
- // reproduced on all copies.  Neither the Government nor the University 
- // makes any warranty, express or implied, or assumes any liability or 
- // responsibility for the use of this SOFTWARE.
- // 
- // If SOFTWARE is modified to produce derivative works, such modified
- // SOFTWARE should be clearly marked, so as not to confuse it with the
- // version available from LANL.
- // 
- // For more information about POOMA, send e-mail to pooma@acl.lanl.gov,
- // or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
- // ----------------------------------------------------------------------
- // ACL:license
- 
- //-----------------------------------------------------------------------------
- // Classes: 
- //   UniformRectilinear<Dim, TM, CoordinateSystem>
- //   FieldEngine<UniformRectilinear, T, EngineTag>
- //-----------------------------------------------------------------------------
- 
- #ifndef POOMA_NEWFIELD_FIELDENGINE_UR_H
- #define POOMA_NEWFIELD_FIELDENGINE_UR_H
- 
- //-----------------------------------------------------------------------------
- // Overview: 
- // 
- // FieldEngine<UniformRectilinear, T, EngineTag>
- //-----------------------------------------------------------------------------
- 
- //-----------------------------------------------------------------------------
- // Includes:
- //-----------------------------------------------------------------------------
- 
- #include "NewField/FieldEngine/FieldEngineBase.h"
- 
- #include "Array/Array.h"
- #include "CoordinateSystems/Cartesian.h"
- #include "Domain/Interval.h"
- #include "Engine/ConstantFunctionEngine.h"
- #include "Engine/IndexFunctionEngine.h"
- #include "Layout/INode.h"
- #include "Tiny/Vector.h"
- #include "Utilities/PAssert.h"
- 
- 
- //-----------------------------------------------------------------------------
- // Forward Declarations:
- //-----------------------------------------------------------------------------
- 
- template<class GeometryTag, class T, class EngineTag> class FieldEngine;
- template<class Components> class ComponentWrapper;
- 
- 
- //-----------------------------------------------------------------------------
- // Full Description:
- // 
- // UniformRectilinear tag class.
- //-----------------------------------------------------------------------------
- 
- template<int Dim, class T = POOMA_DEFAULT_POSITION_TYPE,
-   class CoordinateSystem = Cartesian<Dim> >
- struct UniformRectilinear;
- 
- 
- //-----------------------------------------------------------------------------
- // Full Description:
- // 
- // FieldEngine, specialized for uniform rectilinear meshes.
- //-----------------------------------------------------------------------------
- 
- template<int Dim, class TM, class CoordinateSystem, class T, class EngineTag>
- class FieldEngine<UniformRectilinear<Dim, TM, CoordinateSystem>, T, EngineTag>
- : public FieldEngineBase<Dim, T, EngineTag>
- {
- public:
- 
-   //---------------------------------------------------------------------------
-   // Exported typedefs and enumerations.
- 
-   // This class.
-   
-   typedef 
-     FieldEngine<UniformRectilinear<Dim, TM, CoordinateSystem>, T, EngineTag>
-       This_t;
-     
-   // Our base class.
-   
-   typedef FieldEngineBase<Dim, T, EngineTag> Base_t;
- 
-   // The geometry tag.
-   
-   typedef UniformRectilinear<Dim, TM, CoordinateSystem> GeometryTag_t;
-   
-   // The engine tag.
-   
-   typedef EngineTag EngineTag_t;
-   
-   // The coordinate system.
-   
-   typedef CoordinateSystem CoordinateSystem_t;
-   
-   // The domain type.
-   
-   typedef typename Base_t::Domain_t Domain_t;
-   
-   // The number of indices required to select a point in this mesh.
-   
-   enum { dimensions = Dim };
-   
-   // The type used to represent a point in the mesh.
-   
-   typedef Vector<Dim, TM> PointType_t;
-   
-   // Our engine type.
-   
-   typedef Engine<Dim, T, EngineTag> Engine_t;
-   
-   // Our layout type.
-   
-   typedef typename Engine_t::Layout_t Layout_t;
- 
- 
-   //---------------------------------------------------------------------------
-   // Constructors. We don't use default arguments for the origin and spacings
-   // because that produces ambiguities.
- 
-   FieldEngine()
-   : Base_t()
-     { }
- 
-   template<class BaseInitializer>  
-   FieldEngine(const BaseInitializer &baseInit, 
-               const Layout_t &layout,
-               const PointType_t &origin,
-               const PointType_t &spacings)
-   : Base_t(baseInit, layout),
-     origin_m(origin),
-     spacings_m(spacings)
-     { }
- 
-   FieldEngine(const Centering<Dim> &centering,
-               const Layout_t &layout,
-               const PointType_t &origin,
-               const PointType_t &spacings)
-   : Base_t(centering, layout),
-     origin_m(origin),
-     spacings_m(spacings)
-     { }
- 
-   FieldEngine(int materials,
-               const Centering<Dim> &centering,
-               const Layout_t &layout,
-               const PointType_t &origin,
-               const PointType_t &spacings)
-   : Base_t(centering, layout, materials),
-     origin_m(origin),
-     spacings_m(spacings)
-     { }
- 
-   // Copy constructor.
-   
-   FieldEngine(const This_t &model)
-   : Base_t(model),
-     origin_m(model.origin_m),
-     spacings_m(model.spacings_m)
-     { }
-     
-   // Copy constructor (except for updaters).
- 
-   FieldEngine(const This_t &model, const Pooma::DontCopyRelations &d)
-   : Base_t(model, d),
-     origin_m(model.origin_m),
-     spacings_m(model.spacings_m)
-     { }
-     
-   // Sub-field constructor.
- 
-   template<class ET2>  
-   FieldEngine(const FieldEngine<GeometryTag_t, T, ET2> &model, 
-     const int &iSubField)
-   : Base_t(model, iSubField),
-     origin_m(model.origin()),
-     spacings_m(model.spacings())
-     { }
- 
-   // Domain view constructor.
- 
-   template<class T2, class ET2>  
-   FieldEngine(const FieldEngine<GeometryTag_t, T2, ET2> &model, 
-     const Domain_t &d)
-   : Base_t(model, d),
-     origin_m(model.origin()),
-     spacings_m(model.spacings())
-     {
-       for (int i = 0; i < Dim; i++)
-         origin_m(i) += 
-           (d[i].first() - model.physicalCellDomain()[i].first()) *
-           spacings_m(i);
-     }
- 
-   template<class T2, class ET2>  
-   FieldEngine(const FieldEngine<GeometryTag_t, T2, ET2> &model, 
-     const INode<Dim> &inode)
-   : Base_t(model, inode),
-     origin_m(model.origin()),
-     spacings_m(model.spacings())
-     {
-       for (int i = 0; i < Dim; i++)
-         origin_m(i) += 
-           (inode.domain()[i].first() - model.physicalCellDomain()[i].first()) *
-           spacings_m(i);
-     }
- 
-   template<class T2, class ET2, class Tag>  
-   FieldEngine(const FieldEngine<GeometryTag_t, T2, ET2> &model, 
- 	      const EngineView<Tag> &engineView)
-   : Base_t(model, engineView),
-     origin_m(model.origin()),
-     spacings_m(model.spacings())
-   {
-     // Will need to fix up origin_m if EnginView replaces INode<> view.
-   }
- 
-   // Expression-engine constructor.    
- 
-   FieldEngine(const Engine<Dim, T, EngineTag> &e)
-   : Base_t(e)
-     {
-       origin_m = referenceField().fieldEngine().origin(); 
-       spacings_m = referenceField().fieldEngine().spacings(); 
-     }
- 
-   // Patch constructor.    
- 
-   template<class ET2>
-   FieldEngine(const FieldEngine<GeometryTag_t, T, ET2> &model, 
-               const FieldEnginePatch<Dim> &p)
-   : Base_t(model, p),
-     spacings_m(model.spacings())
-     { 
-       for (int i = 0; i < Dim; i++)
-         origin_m(i) += 
-           (physicalCellDomain()[i].first() - 
-           model.physicalCellDomain()[i].first()) *
-           spacings_m(i);
-     }
-     
-   // ComponentView constructor. The geometry for the model should be the
-   // same since a component view simply mutates the elements.
- 
-   template<class T2, class ET2, class Components>  
-   FieldEngine(const FieldEngine<GeometryTag_t, T2, ET2> &model, 
-     const ComponentWrapper<Components> &c)
-   : Base_t(model, c),
-     origin_m(model.origin()),
-     spacings_m(model.spacings())
-     { }
- 
-   // Model/Centering constructor used by stencils.
-   // Eventually to be axed and replaced with mesh/centering
- 
-   template<class T2, class ET2>
-   FieldEngine(const FieldEngine<GeometryTag_t, T2, ET2> &model, 
-               const Centering<Dim> &centering)
-     : Base_t(centering, model),
-       origin_m(model.origin()),
-       spacings_m(model.spacings())
-   {
-   }
- 
-   //---------------------------------------------------------------------------
-   // Copy assignment operator (shallow).
-   
-   This_t &operator=(const This_t &rhs)
-   {
-     origin_m = rhs.origin();
-     spacings_m = rhs.spacings();
-     initialize(rhs);
-     return *this;
-   }
- 
-   //---------------------------------------------------------------------------
-   // Empty destructor is fine.
-   
-   ~FieldEngine() { }
- 
- 
-   //---------------------------------------------------------------------------
-   // Accessors.
-   
-   inline const PointType_t &origin() const { return origin_m; }
-   inline const PointType_t &spacings() const { return spacings_m; }
- 
- 
- private:
- 
-   PointType_t origin_m, spacings_m;
- 
- };
- 
- 
- #endif // POOMA_NEWFIELD_FIELDENGINE_UR_H
- 
- // ACL:rcsinfo
- // ----------------------------------------------------------------------
- // $RCSfile: FieldEngine.UR.h,v $   $Author: sasmith $
- // $Revision: 1.7.2.4 $   $Date: 2001/08/21 18:26:15 $
- // ----------------------------------------------------------------------
- // ACL:rcsinfo
- 
--- 0 ----
Index: src/NewField/FieldEngine/FieldEngine.h
===================================================================
RCS file: FieldEngine.h
diff -N FieldEngine.h
*** /dev/null	Tue May  5 14:32:27 1998
--- FieldEngine.h	Thu Aug 23 16:59:15 2001
***************
*** 0 ****
--- 1,691 ----
+ // -*- C++ -*-
+ // ACL:license
+ // ----------------------------------------------------------------------
+ // This software and ancillary information (herein called "SOFTWARE")
+ // called POOMA (Parallel Object-Oriented Methods and Applications) is
+ // made available under the terms described here.  The SOFTWARE has been
+ // approved for release with associated LA-CC Number LA-CC-98-65.
+ // 
+ // Unless otherwise indicated, this SOFTWARE has been authored by an
+ // employee or employees of the University of California, operator of the
+ // Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
+ // the U.S. Department of Energy.  The U.S. Government has rights to use,
+ // reproduce, and distribute this SOFTWARE. The public may copy, distribute,
+ // prepare derivative works and publicly display this SOFTWARE without 
+ // charge, provided that this Notice and any statement of authorship are 
+ // reproduced on all copies.  Neither the Government nor the University 
+ // makes any warranty, express or implied, or assumes any liability or 
+ // responsibility for the use of this SOFTWARE.
+ // 
+ // If SOFTWARE is modified to produce derivative works, such modified
+ // SOFTWARE should be clearly marked, so as not to confuse it with the
+ // version available from LANL.
+ // 
+ // For more information about POOMA, send e-mail to pooma@acl.lanl.gov,
+ // or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
+ // ----------------------------------------------------------------------
+ // ACL:license
+ 
+ //-----------------------------------------------------------------------------
+ // Classes: 
+ //   FieldEngineBase
+ //-----------------------------------------------------------------------------
+ 
+ #ifndef POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_H
+ #define POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_H
+ 
+ //-----------------------------------------------------------------------------
+ // Overview: 
+ // 
+ // FieldEngineBase and related classes. POOMA supports a flexible form 
+ // of "centering" that allows a hierarchy of multiple centering points per 
+ // cell. The centering information, managed by the FieldEngineBase
+ // class, is initialized using a flexible set of functors.
+ //-----------------------------------------------------------------------------
+ 
+ //-----------------------------------------------------------------------------
+ // Includes:
+ //-----------------------------------------------------------------------------
+ 
+ #include "Domain/Interval.h"
+ #include "Domain/Loc.h"
+ #include "Domain/Shrink.h"
+ #include "Layout/INode.h"
+ #include "Layout/GuardLayers.h"
+ #include "Utilities/PAssert.h"
+ #include "Utilities/RefCountedBlockPtr.h"
+ #include "Engine/EnginePatch.h"
+ #include "Engine/EngineFunctor.h"
+ #include "NewField/Relations/RelationList.h"
+ #include "NewField/FieldCentering.h"
+ #include "NewField/FieldEngine/FieldEnginePatch.h"
+ 
+ //-----------------------------------------------------------------------------
+ // Forward declarations:
+ //-----------------------------------------------------------------------------
+ 
+ template<int Dim, class T, class EngineTag> class Engine;
+ template<class Components> class ComponentWrapper;
+ 
+ 
+ // ----------------------------------------------------------------------------
+ // FieldEngineBaseData holds an engine and the relations.
+ // ----------------------------------------------------------------------------
+ 
+ template <int Dim, class T, class EngineTag>
+ class FieldEngineBaseData
+ {
+ public:
+ 
+   FieldEngineBaseData()
+     : engine_m()
+   { }
+ 
+   template<class Initializer>
+   FieldEngineBaseData(const Initializer &init)
+     : engine_m(init)
+   { }
+ 
+   FieldEngineBaseData(const Pooma::NoInit &)
+     : engine_m()
+   { }
+ 
+   template<class Initializer>
+   FieldEngineBaseData(const Initializer &init, const RelationList &l)
+     : engine_m(init),
+       relations_m(l)
+   { }
+ 
+   template<class Engine, class Domain>
+   FieldEngineBaseData(const Engine &e,
+                       const Domain &d, const RelationList &l)
+     : engine_m(NewEngineEngine<Engine, Domain>::apply(e, d), 
+                NewEngineDomain<Engine, Domain>::apply(e, d)),
+       relations_m(l)
+   {
+   }
+     
+   const Engine<Dim, T, EngineTag> &engine() const { return engine_m; }
+   Engine<Dim, T, EngineTag> &engine() { return engine_m; }
+ 
+   const RelationList &relations() const { return relations_m; }
+   RelationList &relations() { return relations_m; }
+   
+ private:
+ 
+   Engine<Dim, T, EngineTag> engine_m;
+   mutable RelationList relations_m;
+ };
+ 
+ 
+ // ----------------------------------------------------------------------------
+ // FieldEngineBase manages a hierarchy of engines, making it possible for
+ // FieldEngine specializations to implement geometry-specific behavior only.
+ // ----------------------------------------------------------------------------
+ 
+ template<class Mesh, class T, class EngineTag>
+ class FieldEngine
+ {
+ public:
+ 
+   //---------------------------------------------------------------------------
+   // Exported typedefs and enumerations.
+     
+   enum { dimensions = Mesh::dimensions };
+   enum { Dim = dimensions };
+   typedef FieldEngine<Mesh, T, EngineTag> This_t;
+   typedef FieldEngineBaseData<Dim, T, EngineTag> Data_t;
+   typedef Engine<Dim, T, EngineTag> Engine_t;
+   typedef typename Engine_t::Domain_t Domain_t;
+   typedef typename Engine_t::Layout_t Layout_t;
+   typedef typename Engine_t::Element_t Element_t;
+   typedef typename Engine_t::ElementRef_t ElementRef_t;
+   typedef GuardLayers<Dim> GuardLayers_t;
+ 
+ 
+   //---------------------------------------------------------------------------
+   // Constructors.
+ 
+   // Default constructor.
+   
+   FieldEngine()
+     : num_materials_m(0),
+       physicalCellDomain_m(Pooma::NoInit()),
+       guards_m(0)
+   { }
+   
+   // General version takes centering, layout, mesh, materials
+ 
+   template<class Layout2>
+   FieldEngine(const Centering<Dim> &centering, const Layout2 &layout,
+               const Mesh &mesh, int materials = 1)
+     : num_materials_m(materials),
+       centering_m(centering),
+       stride_m(centering.size()),
+       physicalCellDomain_m(layout.domain()),
+       guards_m(layout.externalGuards()),
+       mesh_m(mesh)
+   {
+     shrinkInPlace(physicalCellDomain_m, guards_m);
+     shrinkRightInPlace(physicalCellDomain_m, 1);
+     addSubFields();
+     for (int m = 0; m < num_materials_m; ++m)
+     {
+       for (int c = 0; c < centering.size(); ++ c)
+       {
+         data(m, c) = Data_t(layout);
+       }
+     }
+   }
+ 
+   // Copy constructor.
+   
+   FieldEngine(const This_t &model)
+     : num_materials_m(model.num_materials_m),
+       stride_m(model.stride_m),
+       centering_m(model.centering_m),
+       data_m(model.data_m),
+       physicalCellDomain_m(model.physicalCellDomain_m),
+       guards_m(model.guards_m),
+       mesh_m(model.mesh_m)
+   {
+   }
+ 
+   // Sub-field view constructor. This is when we want to construct a view of
+   // one of the subFields in our top-level list.
+   
+   FieldEngine(const This_t &model, int subField)
+     : num_materials_m(1),
+       stride_m(model.stride_m),
+       physicalCellDomain_m(model.physicalCellDomain_m),
+       guards_m(model.guards_m),
+       mesh_m(model.mesh_m)
+   {
+     if (model.numMaterials() > 1)
+     {
+       centering_m = model.centering();
+       data_m = model.data_m + model.stride_m * subField;
+     }
+     else
+     {
+       centering_m = model.centering()[subField];
+       data_m = model.data_m + subField;
+     }
+   }
+ 
+   FieldEngine(const This_t &model, int m, int c)
+     : num_materials_m(1),
+       stride_m(model.stride_m),
+       physicalCellDomain_m(model.physicalCellDomain_m),
+       guards_m(model.guards_m),
+       mesh_m(model.mesh_m)
+   {
+     PAssert((m >= 0) && (m < model.numMaterials()));
+     PAssert((c >= 0) && (c < model.centeringSize()));
+     centering_m = model.centering()[c];
+     data_m = model.data_m + model.stride_m * m + c;
+   }
+ 
+   FieldEngine(int c, const This_t &model)
+     : num_materials_m(1),
+       stride_m(model.stride_m),
+       physicalCellDomain_m(model.physicalCellDomain_m),
+       guards_m(model.guards_m),
+       mesh_m(model.mesh_m)
+   {
+     PAssert((c >= 0) && (c < model.centeringSize()));
+     centering_m = model.centering()[c];
+     data_m = model.data_m + c;
+   }
+ 
+   // View constructors.  
+ 
+   template<class T2, class EngineTag2>
+   FieldEngine(const FieldEngine<Mesh, T2, EngineTag2> &model,
+               const Domain_t &d)
+     : num_materials_m(model.numMaterials()),
+       stride_m(model.centeringSize()),
+       centering_m(model.centering()),
+       guards_m(0),
+       mesh_m(model.mesh(),
+              inputDomainToVertexDomain(d))
+   {
+     addSubFields();
+     physicalCellDomain_m = d - d.firsts();
+     if (centering_m.size() == 1)
+     {
+       physicalCellDomain_m =
+         centeringDomainToCellDomain(physicalCellDomain_m, centering_m, 0);
+     }
+     for (int m = 0; m < num_materials_m; ++m)
+     {
+       if (centering_m.size() == 1)
+       {
+         data(m, 0) = Data_t(model.data(m, 0).engine(), d,
+                             model.data(m, 0).relations());
+       }
+       else
+       {
+         for (int c = 0; c < centering_m.size(); ++ c)
+         {
+           data(m, c) = Data_t(model.data(m, c).engine(),
+                               cellDomainToCenteringDomain(d, centering_m, c),
+                               model.data(m, c).relations());
+         }
+       }
+     }
+   }
+ 
+   // This constructor handle weird things like range views.
+ 
+   template<class Mesh2, class T2, class EngineTag2, class Domain>
+   FieldEngine(const FieldEngine<Mesh2, T2, EngineTag2> &model,
+               const Domain &d)
+     : num_materials_m(model.numMaterials()),
+       stride_m(model.centeringSize()),
+       centering_m(model.centering()),
+       guards_m(0)
+   {
+     addSubFields();
+     // FIXME: Does this ever happen to fields with multiple centering points?
+     // (or event to fields with multiple materials???)
+     PAssert(model.centeringSize() == 1);
+     for (int m = 0; m < num_materials_m; ++m)
+     {
+       data(m, 0) = Data_t(model.data(m, 0).engine(), d,
+                           model.data(m, 0).relations());
+     }
+     // FIXME: how do we construct the mesh?????
+     mesh_m = Mesh(DomainLayout<Dim>(inputDomainToVertexDomain(data(0,0).engine().domain())));
+     physicalCellDomain_m = mesh_m.physicalCellDomain();
+   }
+ 
+   template<class T2, class EngineTag2>
+   FieldEngine(const FieldEngine<Mesh, T2, EngineTag2> &model,
+               const INode<Dim> &i)
+     : num_materials_m(model.numMaterials()),
+       stride_m(model.centeringSize()),
+       centering_m(model.centering()),
+       guards_m(0),
+       mesh_m(model.mesh(),
+              inputDomainToVertexDomain(i.domain())) // FIXME: should hand INode to mesh?
+   {
+     addSubFields();
+     physicalCellDomain_m = i.domain() - i.domain().firsts();
+     if (centering_m.size() == 1)
+     {
+       physicalCellDomain_m =
+         centeringDomainToCellDomain(physicalCellDomain_m, centering_m, 0);
+     }
+     for (int m = 0; m < num_materials_m; ++m)
+     {
+       if (centering_m.size() == 1)
+       {
+         data(m, 0) = Data_t(model.data(m, 0).engine(), i,
+                             model.data(m, 0).relations());
+       }
+       else
+       {
+         for (int c = 0; c < centering_m.size(); ++ c)
+         { 
+           data(m, c) =
+             Data_t(model.data(m, c).engine(),
+                    INode<Dim>(i, cellDomainToCenteringDomain(i.domain(),
+                                                              centering_m, c)),
+                    model.data(m, c).relations());
+         }
+       }
+     }
+   }
+ 
+   template<class Mesh2, class T2, class EngineTag2, class Tag>
+   FieldEngine(const FieldEngine<Mesh2, T2, EngineTag2> &model,
+               const EngineView<Tag> &ev)
+     : num_materials_m(model.numMaterials()),
+       stride_m(model.centeringSize()),
+       centering_m(model.centering()),
+       physicalCellDomain_m(model.physicalCellDomain()),
+       guards_m(model.guardLayers()),
+       mesh_m(model.mesh())
+   {
+     typedef typename FieldEngine<Mesh2, T2, EngineTag2>::Engine_t EngIn_t;
+     typedef LeafFunctor<EngIn_t, EngineView<Tag> > Functor_t;
+     addSubFields();
+     for (int m = 0; m < num_materials_m; ++m)
+     {
+       for (int c = 0; c < centering_m.size(); ++ c)
+       {
+         data(m, c)
+           = Data_t(Functor_t::apply(model.data(m, c).engine(), ev),
+                    model.data(m, c).relations());
+       }
+     }
+   }
+ 
+   template<class EngineTag2>
+   FieldEngine(const FieldEngine<Mesh, T, EngineTag2> &model,
+               const FieldEnginePatch<Dim> &p)
+     : num_materials_m(model.numMaterials()),
+       stride_m(model.centeringSize()),
+       centering_m(model.centering()),
+       guards_m(model.guardLayers()),
+       mesh_m(model.mesh()) // FIXME: should take a view of the mesh???
+   {
+     // FIXME: should we copy the relations for patch?  Do we want
+     // to take patch views of composite fields?
+     PAssert((model.numMaterials() == 1) && (model.centeringSize() == 1));
+     addSubFields();
+     data(0, 0) = Data_t(engineFunctor(model.engine(), EnginePatch(p.patch_m)));
+     physicalCellDomain_m =
+       centeringDomainToCellDomain(p.domain_m, centering_m, 0);
+   }
+ 
+   template<class Mesh2, class T2, class EngineTag2, class Components>
+   FieldEngine(const FieldEngine<Mesh2, T2, EngineTag2> &model, 
+               const ComponentWrapper<Components> &cw)
+     : num_materials_m(model.numMaterials()),
+       stride_m(model.centeringSize()),
+       centering_m(model.centering()),
+       physicalCellDomain_m(model.physicalCellDomain()),
+       guards_m(model.guardLayers()),
+       mesh_m(model.mesh())
+   {
+     addSubFields();
+     for (int m = 0; m < num_materials_m; ++m)
+     {
+       for (int c = 0; c < centering_m.size(); ++ c)
+       {
+         data(m, c) =
+           Data_t(Engine_t(model.data(m, c).engine(), cw.components()),
+                  model.data(m, c).relations());
+       }
+     }
+   }
+ 
+   FieldEngine(const This_t &model, 
+               const Pooma::DontCopyRelations &d)
+     : num_materials_m(model.numMaterials()),
+       stride_m(model.centeringSize()),
+       centering_m(model.centering()),
+       physicalCellDomain_m(model.physicalCellDomain_m),
+       guards_m(model.guardLayers()),
+       mesh_m(model.mesh())
+   {
+     addSubFields();
+     for (int m = 0; m < num_materials_m; ++m)
+     {
+       for (int c = 0; c < centering_m.size(); ++ c)
+       {
+         data(m, c) = Data_t(model.data(m, c).engine());
+       }
+     }
+   }
+       
+   //---------------------------------------------------------------------------
+   // Initialize functions. 
+ 
+   void initialize(const This_t &model)
+   {
+     num_materials_m = model.num_materials_m;
+     stride_m = model.stride_m;
+     centering_m = model.centering_m;
+     data_m = model.data_m;
+     physicalCellDomain_m = model.physicalCellDomain_m;
+     guards_m = model.guards_m;
+     mesh_m = model.mesh_m;
+   }
+ 
+ 
+   //---------------------------------------------------------------------------
+   // Accessors and modifiers.
+     
+   void addSubFields()
+   {
+     PAssert(data_m.size() == 0);
+ 
+     int size = num_materials_m * centering_m.size();
+ 
+     data_m.reserve(size);
+     data_m.resize(size);
+   }
+ 
+   // FIXME: This function is deprecated.
+   inline int numSubFields() const
+   {
+     if (numMaterials() > 1)
+     {
+       return numMaterials();
+     }
+     else
+     {
+       if (centering().size() > 1)
+       {
+         return centering().size();
+       }
+       else
+       {
+         return 0;
+       }
+     }
+   }
+ 
+   // FIXME: these should assert that there is 1 subfield.
+   Engine_t &engine()
+   {
+     PAssert(data_m.isValid());
+     return data_m->engine();
+   }
+     
+   const Engine_t &engine() const
+   {
+     PAssert(data_m.isValid());
+     return data_m->engine();
+   }
+ 
+   RelationList &relations() const
+   {
+     PAssert(data_m.isValid());
+     return data_m->relations();
+   }
+     
+   const GuardLayers_t &guardLayers() const
+   {
+     return guards_m;
+   }
+ 
+   GuardLayers_t &guardLayers()
+   {
+     return guards_m;
+   }
+ 
+   inline int numMaterials() const
+   {
+     return num_materials_m;
+   }
+ 
+   //---------------------------------------------------------------------------
+   // Domain accessor functions. 
+         
+   inline Domain_t &physicalCellDomain()
+   {
+     return physicalCellDomain_m;
+   }
+         
+   inline const Domain_t &physicalCellDomain() const
+   {
+     return physicalCellDomain_m;
+   }
+         
+   inline Domain_t totalCellDomain() const
+   {
+     return grow(physicalCellDomain_m, guards_m);
+   }
+ 
+   Domain_t physicalDomain() const
+   {
+     if (centeringSize() == 1)
+       return cellDomainToCenteringDomain(physicalCellDomain_m, centering_m, 0);
+     else
+       return physicalCellDomain_m;
+   }
+ 
+   Domain_t physicalDomain(int i) const
+   {
+     return cellDomainToCenteringDomain(physicalCellDomain_m, centering_m, i);
+   }
+ 
+   Domain_t totalDomain() const
+   {
+     if (centeringSize() == 1)
+       return cellDomainToCenteringDomain(totalCellDomain(), centering_m, 0);
+     else
+       return totalCellDomain();
+   }
+ 
+   Domain_t totalDomain(int i) const
+   {
+     return cellDomainToCenteringDomain(totalCellDomain(), centering_m, i);
+   }
+ 
+   //---------------------------------------------------------------------------
+   // Centering accessors.
+ 
+   const Centering<Dim> &centering() const
+   {
+     return centering_m;
+   }        
+ 
+   inline int centeringSize() const
+     {
+       return centering_m.size();
+     }
+ 
+   //---------------------------------------------------------------------------
+   // Mesh accessors.
+ 
+   Mesh &mesh()
+   {
+     return mesh_m;
+   }        
+ 
+   const Mesh &mesh() const
+   {
+     return mesh_m;
+   }        
+ 
+   //---------------------------------------------------------------------------
+   // Make a distinct copy of this fieldEngineBase.   
+  
+   template<class Subject>
+   void makeOwnCopy(const Subject &s)
+   {
+     PAssert(data_m.isValid());
+ 
+     // Create a blank slate of engines:
+ 
+     data_m = RefCountedBlockPtr<Data_t>();
+     stride_m = centering_m.size();
+     addSubFields();
+ 
+     // Copy then engines and relations and
+     // Deepen the copies of the engine & relations list.
+     
+     for (int m = 0; m < num_materials_m; ++m)
+     {
+       for (int c = 0; c < centering_m.size(); ++ c)
+       {
+         data(m, c) = model.data(m, c);
+         data(m, c).engine().makeOwnCopy();
+         data(m, c).relations().makeOwnCopy(s);
+       }
+     }
+   }
+ 
+ 
+   //---------------------------------------------------------------------------
+   // Domain translation function. 
+   
+   // FIXME: This function should go away.  Currently it's only used by
+   // the lagrangian field engine.
+ 
+   inline Domain_t
+   translateToVertexDomain(const Domain_t &d) const
+   {
+     if (centering_m.size() == 1)
+       return d;
+     else
+       return growRight(d, 1);
+   }
+ 
+   inline Domain_t
+   inputDomainToVertexDomain(const Domain_t &d) const
+   {
+     if (centering_m.size() == 1)
+       return growRight(centeringDomainToCellDomain(d, centering(), 0), 1);
+     else
+       return growRight(d, 1);
+   }
+ 
+   //---------------------------------------------------------------------------
+   // Access material, centering subfield data.
+   
+   inline Data_t &
+   data(int material, int centering)
+   {
+     PAssert(data_m.isValid());
+     return data_m[material * stride_m + centering];
+   }
+       
+   inline const Data_t &
+   data(int material, int centering) const
+   {
+     PAssert(data_m.isValid());
+     return data_m[material * stride_m + centering];
+   }
+       
+       
+ private:
+ 
+   unsigned int num_materials_m;
+   Centering<Dim> centering_m;
+   int stride_m;
+   RefCountedBlockPtr<Data_t> data_m;
+ 
+   Domain_t physicalCellDomain_m;
+   GuardLayers_t guards_m;
+ 
+   Mesh mesh_m;
+ };
+ 
+ template<class Mesh, class T, class EngineTag, class Tag>
+ struct LeafFunctor<FieldEngine<Mesh, T, EngineTag>,
+                    ExpressionApply<Tag> >
+ {
+   typedef FieldEngine<Mesh, T, EngineTag> Subject_t;
+   typedef typename Subject_t::Engine_t Engine_t;
+   typedef LeafFunctor<Engine_t, ExpressionApply<Tag> > LeafFunctor_t;
+   typedef int Type_t;
+ 
+   inline static
+   Type_t apply(const Subject_t &fieldEngineBase, 
+ 	       const ExpressionApply<Tag> &tag)
+   {
+     for (int m = 0; m < fieldEngineBase.numMaterials(); ++m)
+     {
+       for (int c = 0; c < fieldEngineBase.centering().size(); ++ c)
+       {
+         LeafFunctor_t::apply(fieldEngineBase.data(m, c).engine(), tag);
+       }
+     }
+     return 0;
+   }
+ };
+ 
+ #endif // POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_H
+ 
+ // ACL:rcsinfo
+ // ----------------------------------------------------------------------
+ // $RCSfile: FieldEngineBase.h,v $   $Author: sasmith $
+ // $Revision: 1.13.2.8 $   $Date: 2001/08/21 18:26:15 $
+ // ----------------------------------------------------------------------
+ // ACL:rcsinfo
Index: src/NewField/FieldEngine/FieldEngineBase.ExprEngine.h
===================================================================
RCS file: FieldEngineBase.ExprEngine.h
diff -N FieldEngineBase.ExprEngine.h
*** /tmp/cvs4UV8yJ	Thu Aug 23 16:59:29 2001
--- /dev/null	Tue May  5 14:32:27 1998
***************
*** 1,350 ****
- // -*- C++ -*-
- // ACL:license
- // ----------------------------------------------------------------------
- // This software and ancillary information (herein called "SOFTWARE")
- // called POOMA (Parallel Object-Oriented Methods and Applications) is
- // made available under the terms described here.  The SOFTWARE has been
- // approved for release with associated LA-CC Number LA-CC-98-65.
- // 
- // Unless otherwise indicated, this SOFTWARE has been authored by an
- // employee or employees of the University of California, operator of the
- // Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
- // the U.S. Department of Energy.  The U.S. Government has rights to use,
- // reproduce, and distribute this SOFTWARE. The public may copy, distribute,
- // prepare derivative works and publicly display this SOFTWARE without 
- // charge, provided that this Notice and any statement of authorship are 
- // reproduced on all copies.  Neither the Government nor the University 
- // makes any warranty, express or implied, or assumes any liability or 
- // responsibility for the use of this SOFTWARE.
- // 
- // If SOFTWARE is modified to produce derivative works, such modified
- // SOFTWARE should be clearly marked, so as not to confuse it with the
- // version available from LANL.
- // 
- // For more information about POOMA, send e-mail to pooma@acl.lanl.gov,
- // or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
- // ----------------------------------------------------------------------
- // ACL:license
- 
- //-----------------------------------------------------------------------------
- // Classes: 
- //   FieldEngineBase specialized for Expression-engines
- //-----------------------------------------------------------------------------
- 
- #ifndef POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_EXPRENGINE__H
- #define POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_EXPRENGINE__H
- 
- //-----------------------------------------------------------------------------
- // Overview: 
- // 
- // FieldEngineBase and related classes. POOMA supports a flexible form 
- // of "centering" that allows a hierarchy of multiple centering points per 
- // cell. The centering information, managed by the FieldEngineBase
- // class, is initialized using a flexible set of functors.
- //-----------------------------------------------------------------------------
- 
- //-----------------------------------------------------------------------------
- // Includes:
- //-----------------------------------------------------------------------------
- 
- #include "Domain/Loc.h"
- #include "Engine/ExpressionEngine.h"
- #include "Layout/GuardLayers.h"
- #include "Utilities/PAssert.h"
- 
- 
- //-----------------------------------------------------------------------------
- // Forward declarations:
- //-----------------------------------------------------------------------------
- 
- template<int Dim, class T, class EngineTag> class FieldEngineBase;
- template<class GeometryTag, class T, class EngineTag> class Field;
- 
- 
- //-----------------------------------------------------------------------------
- // Handy combiners for getting the far-left field in an expression.
- //-----------------------------------------------------------------------------
- 
- struct FarLeftTag
- {
-   POOMA_PURIFY_CONSTRUCTORS(FarLeftTag)
- };
- 
- template<class G1, class T1, class E1, class Op>
- struct Combine1<Field<G1, T1, E1>, Op, FarLeftTag>
- {
-   typedef Field<G1, T1, E1> Type_t;
-   inline static
-   const Type_t &combine(const Field<G1, T1, E1> &a,
- 			const FarLeftTag &) 
-     { 
-       return a; 
-     }
- };
- 
- template<class G1, class T1, class E1, class G2, class T2, class E2, 
-   class Op>
- struct Combine2<Field<G1, T1, E1>, Field<G2, T2, E2>, Op, FarLeftTag>
- {
-   typedef Field<G1, T1, E1> Type_t;
-   inline static
-   const Type_t &combine(const Field<G1, T1, E1> &a, 
-                         const Field<G2, T2, E2> &, FarLeftTag)
-     {
-       return a;
-     }
- };
- 
- template<class T, class G2, class T2, class E2, class Op>
- struct Combine2<T, Field<G2, T2, E2>, Op, FarLeftTag>
- {
-   typedef Field<G2, T2, E2> Type_t;
-   inline static
-   const Type_t &combine(const T &, 
-                         const Field<G2, T2, E2> &b, FarLeftTag)
-     {
-       return b;
-     }
- };
- 
- template<class G1, class T1, class E1, class T, class Op>
- struct Combine2<Field<G1, T1, E1>, T, Op, FarLeftTag>
- {
-   typedef Field<G1, T1, E1> Type_t;
-   inline static
-   const Type_t &combine(const Field<G1, T1, E1> &a, 
-                         const T &, FarLeftTag)
-     {
-       return a;
-     }
- };
- 
- template<class A,class B,class C,class Op>
- struct Combine3<A, B, C, Op, FarLeftTag>
- {
-   typedef typename Combine2<A, B, Op, FarLeftTag>::Type_t Type1_t;
-   typedef typename Combine2<Type1_t, C, Op, FarLeftTag>::Type_t Type_t;
-   inline static
-   const Type_t &combine(const A& a, const B& b, const C& c,
- 			const FarLeftTag& t)
-   {
-     return
-       Combine2<Type1_t, C,
-       Op, FarLeftTag>::combine(Combine2<A, B, Op,
- 			       FarLeftTag>::combine(a, b, t), c, t);
-   }
- };
- 
- //-----------------------------------------------------------------------------
- // This version of LeafFunctor is used by Expression-Engines to 
- // get at the far-left field in an expression. 
- //-----------------------------------------------------------------------------
- 
- template<class GeometryTag, class T, class EngineTag>
- struct LeafFunctor<Field<GeometryTag, T, EngineTag>, FarLeftTag>
- {
-   typedef Field<GeometryTag, T, EngineTag> Type_t;
-   inline static
-   const Type_t &apply(const Field<GeometryTag, T, EngineTag> &f, 
-     const FarLeftTag &) 
-     {
-       return f;
-     }
- };
- 
- template<class T>
- struct LeafFunctor<Scalar<T>, FarLeftTag>
- {
-   typedef Scalar<T> Type_t;
-   inline static
-   const Type_t &apply(const Scalar<T> &s, const FarLeftTag &) 
-     {
-       return s;
-     }
- };
- 
- 
- // ----------------------------------------------------------------------------
- // FieldEngineBase<Dim, T, ExpressionTag<Expr> >
- //
- // This is a specialization of FieldEngineBase for expression-engines.
- // ----------------------------------------------------------------------------
- 
- template<int Dim, class T, class Expr>
- class FieldEngineBase<Dim, T, ExpressionTag<Expr> >
- {
- public:
- 
-   //---------------------------------------------------------------------------
-   // Exported typedefs and enumerations.
-     
-   typedef ExpressionTag<Expr> EngineTag_t;
-   typedef FieldEngineBase<Dim, T, EngineTag_t> This_t;
-   typedef Engine<Dim, T, EngineTag_t> Engine_t;
-   typedef typename Engine_t::Domain_t Domain_t;
-   typedef typename Engine_t::Layout_t Layout_t;
-   typedef typename Engine_t::Element_t Element_t;
-   typedef typename Engine_t::ElementRef_t ElementRef_t;
-   enum { dimensions = Dim };
-   typedef GuardLayers<Dim> GuardLayers_t;
-   typedef typename ForEach<Expr, FarLeftTag, FarLeftTag>::Type_t 
-     ReferenceField_t;
- 
- 
-   //---------------------------------------------------------------------------
-   // Constructors.
- 
-   // Expression constructor.  
-   
-   FieldEngineBase(const Engine_t &e)
-   : engine_m(e),
-     referenceField_m(
-       forEachRef(engine_m.expression(), FarLeftTag(), FarLeftTag()))
-     { }  
-     
-   // Domain view constructor. 
- 
-   template<class Expr2, class Domain>  
-   FieldEngineBase(const FieldEngineBase<Dim, T, ExpressionTag<Expr2> > &model, 
-     const Domain &d)
-   : engine_m(NewEngineEngine<Engine<Dim, T, ExpressionTag<Expr2> >, Domain>::apply(model.engine(), d),
- 	     NewEngineDomain<Engine<Dim, T, ExpressionTag<Expr2> >, Domain>::apply(model.engine(), d)
- 	     ),
-     referenceField_m(
-       forEachRef(engine_m.expression(), FarLeftTag(), FarLeftTag()))
-     { }  
-     
-   // Sub-field view constructor. This is when we want to construct a view of
-   // one of the subFields in our top-level list.
- 
-   template<class Expr2>  
-   FieldEngineBase(const FieldEngineBase<Dim, T, ExpressionTag<Expr2> > &model, 
-     const int &iSubField)
-   : engine_m(model.engine(), iSubField),
-     referenceField_m(
-       forEachRef(engine_m.expression(), FarLeftTag(), FarLeftTag()))
-     { }  
- 
-   // Very important! Copy constructor is needed so that referenceField_m
-   // doesn't refer to someone else's expression.      
- 
-   FieldEngineBase(const FieldEngineBase<Dim, T, ExpressionTag<Expr> > &other)
-   : engine_m(other.engine()),
-     referenceField_m(forEachRef(engine_m.expression(),
- 				FarLeftTag(), FarLeftTag()))
-   { }  
-     
-   //---------------------------------------------------------------------------
-   // Accessors and modifiers.
-     
-   // FIXME: This function is deprecated.
-   inline int numSubFields() const
-     {
-       return referenceField().numSubFields();
-     }
- 
-   inline const Loc<Dim> &offsets() const
-     {
-       return referenceField().offsets();
-     }
-     
-   inline const Engine_t &engine() const
-     {
-       return engine_m;
-     }
- 
-   const ReferenceField_t &referenceField() const
-   {
-     return referenceField_m;
-   }
-   
- 
-   //---------------------------------------------------------------------------
-   // Domain accessor functions. 
-         
-   inline const Domain_t physicalCellDomain() const
-     {
-       return referenceField_m.physicalCellDomain();
-     }
-         
-   inline Domain_t totalCellDomain() const
-     {
-       return referenceField_m.totalCellDomain();
-     }
- 
-   Domain_t physicalDomain() const
-     {
-       return referenceField_m.physicalDomain();
-     }
- 
-   Domain_t totalDomain() const
-     {
-       return referenceField_m.totalDomain();
-     }
- 
-   Domain_t physicalDomain(int iSubField) const
-     {
-       return referenceField_m.physicalDomain(iSubField);
-     }
- 
-   Domain_t totalDomain(int iSubField) const
-     {
-       return referenceField_m.totalDomain(iSubField);
-     }
- 
-   //---------------------------------------------------------------------------
-   // Centering accessors.
- 
-   const Centering<Dim> &centering() const
-   {
-     return referenceField_m.centering();
-   }        
- 
-   inline int centeringSize() const
-     {
-       return referenceField_m.centering().size();
-     }
- 
-   inline int numMaterials() const
-     {
-       return referenceField_m.numMaterials();
-     }
- 
-       
- private:
- 
-   // There is no way to reinitialize the reference, so assignment
-   // cannot be implemented.
- 
-   This_t &operator=(const This_t &other);
-     
-   Engine_t engine_m;
-   const ReferenceField_t &referenceField_m;
- };
- 
- template<int Dim, class T, class Expr, class Tag>
- struct LeafFunctor<FieldEngineBase<Dim, T, ExpressionTag<Expr> >,
-   ExpressionApply<Tag> >
- {
-   typedef FieldEngineBase<Dim, T, ExpressionTag<Expr> > Subject_t;
-   typedef typename Subject_t::Engine_t Engine_t;
-   typedef LeafFunctor<Engine_t, ExpressionApply<Tag> > LeafFunctor_t;
-   typedef int Type_t;
- 
-   inline static
-   Type_t apply(const Subject_t &fieldEngineBase, 
- 	       const ExpressionApply<Tag> &tag)
-   {
-     LeafFunctor_t::apply(fieldEngineBase.engine(), tag);
-     return 0;
-   }
- };
- 
- #endif // POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_EXPRENGINE__H
- 
- // ACL:rcsinfo
- // ----------------------------------------------------------------------
- // $RCSfile: FieldEngineBase.ExprEngine.h,v $   $Author: oldham $
- // $Revision: 1.12.2.1 $   $Date: 2001/08/14 20:24:18 $
- // ----------------------------------------------------------------------
- // ACL:rcsinfo
--- 0 ----
Index: src/NewField/FieldEngine/FieldEngineBase.h
===================================================================
RCS file: FieldEngineBase.h
diff -N FieldEngineBase.h
*** /tmp/cvsZfzvB4	Thu Aug 23 16:59:29 2001
--- /dev/null	Tue May  5 14:32:27 1998
***************
*** 1,707 ****
- // -*- C++ -*-
- // ACL:license
- // ----------------------------------------------------------------------
- // This software and ancillary information (herein called "SOFTWARE")
- // called POOMA (Parallel Object-Oriented Methods and Applications) is
- // made available under the terms described here.  The SOFTWARE has been
- // approved for release with associated LA-CC Number LA-CC-98-65.
- // 
- // Unless otherwise indicated, this SOFTWARE has been authored by an
- // employee or employees of the University of California, operator of the
- // Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
- // the U.S. Department of Energy.  The U.S. Government has rights to use,
- // reproduce, and distribute this SOFTWARE. The public may copy, distribute,
- // prepare derivative works and publicly display this SOFTWARE without 
- // charge, provided that this Notice and any statement of authorship are 
- // reproduced on all copies.  Neither the Government nor the University 
- // makes any warranty, express or implied, or assumes any liability or 
- // responsibility for the use of this SOFTWARE.
- // 
- // If SOFTWARE is modified to produce derivative works, such modified
- // SOFTWARE should be clearly marked, so as not to confuse it with the
- // version available from LANL.
- // 
- // For more information about POOMA, send e-mail to pooma@acl.lanl.gov,
- // or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
- // ----------------------------------------------------------------------
- // ACL:license
- 
- //-----------------------------------------------------------------------------
- // Classes: 
- //   FieldEngineBase
- //-----------------------------------------------------------------------------
- 
- #ifndef POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_H
- #define POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_H
- 
- //-----------------------------------------------------------------------------
- // Overview: 
- // 
- // FieldEngineBase and related classes. POOMA supports a flexible form 
- // of "centering" that allows a hierarchy of multiple centering points per 
- // cell. The centering information, managed by the FieldEngineBase
- // class, is initialized using a flexible set of functors.
- //-----------------------------------------------------------------------------
- 
- //-----------------------------------------------------------------------------
- // Includes:
- //-----------------------------------------------------------------------------
- 
- #include "Domain/Interval.h"
- #include "Domain/Loc.h"
- #include "Domain/Shrink.h"
- #include "Layout/INode.h"
- #include "Layout/GuardLayers.h"
- #include "Utilities/PAssert.h"
- #include "Utilities/RefCountedBlockPtr.h"
- #include "Engine/EnginePatch.h"
- #include "Engine/EngineFunctor.h"
- #include "NewField/Relations/RelationList.h"
- #include "NewField/FieldCentering.h"
- #include "NewField/FieldEngine/FieldEnginePatch.h"
- 
- //-----------------------------------------------------------------------------
- // Forward declarations:
- //-----------------------------------------------------------------------------
- 
- template<int Dim, class T, class EngineTag> class Engine;
- template<class Components> class ComponentWrapper;
- 
- 
- // ----------------------------------------------------------------------------
- // FieldEngineBaseData holds offset information about the centering along
- // with a copy of the engine containing the data associated with the centering.
- // ----------------------------------------------------------------------------
- 
- template <int Dim, class T, class EngineTag>
- class FieldEngineBaseData : public RefCounted
- {
- public:
- 
-   template<class Initializer>
-   FieldEngineBaseData(const Loc<Dim> &offsets, 
-                       const Initializer &init)
-     : offsets_m(offsets), 
-       engine_m(init)
-     { }
- 
-   FieldEngineBaseData(const Loc<Dim> &offsets, 
-                       const Pooma::NoInit &)
-     : offsets_m(offsets), 
-       engine_m()
-     { }
- 
-   template<class Initializer>
-   FieldEngineBaseData(const Loc<Dim> &offsets, 
-                       const Initializer &init, const RelationList &l)
-     : offsets_m(offsets), 
-       engine_m(init),
-       relations_m(l)
-     { }
- 
-   template<class Engine, class Domain>
-   FieldEngineBaseData(const Loc<Dim> &offsets, const Engine &e,
-     const Domain &d, const RelationList &l)
-     : offsets_m(offsets), 
-       engine_m(NewEngineEngine<Engine, Domain>::apply(e, d), 
-                NewEngineDomain<Engine, Domain>::apply(e, d)),
-       relations_m(l)
-     { }
-     
-   const Loc<Dim> &offsets() const { return offsets_m; }
- 
-   const Engine<Dim, T, EngineTag> &engine() const { return engine_m; }
-   Engine<Dim, T, EngineTag> &engine() { return engine_m; }
- 
-   const RelationList &relations() const { return relations_m; }
-   RelationList &relations() { return relations_m; }
-   
- private:
- 
-   Loc<Dim> offsets_m;
-   Engine<Dim, T, EngineTag> engine_m;
-   mutable RelationList relations_m;
- };
- 
- 
- // ----------------------------------------------------------------------------
- // FieldEngineBase manages a hierarchy of engines, making it possible for
- // FieldEngine specializations to implement geometry-specific behavior only.
- // ----------------------------------------------------------------------------
- 
- template<int Dim, class T, class EngineTag>
- class FieldEngineBase
- {
- public:
- 
-   //---------------------------------------------------------------------------
-   // Exported typedefs and enumerations.
-     
-   typedef FieldEngineBase<Dim, T, EngineTag> This_t;
-   typedef FieldEngineBaseData<Dim, T, EngineTag> Data_t;
-   typedef Engine<Dim, T, EngineTag> Engine_t;
-   typedef typename Engine_t::Domain_t Domain_t;
-   typedef typename Engine_t::Layout_t Layout_t;
-   typedef typename Engine_t::Element_t Element_t;
-   typedef typename Engine_t::ElementRef_t ElementRef_t;
-   enum { dimensions = Dim };
-   typedef GuardLayers<Dim> GuardLayers_t;
- 
- 
-   //---------------------------------------------------------------------------
-   // Constructors.
- 
-   // Default constructor.
-   
-   FieldEngineBase()
-   : physicalCellDomain_m(Pooma::NoInit()),
-     guards_m(0),
-     num_materials_m(0)
-     { }
-   
-   // -----------------------------------------------
-   // Initialize with a new centering from a model.
-   // This will be unnecessary when we have a mesh,
-   // but the above version will become centering, layout.
- 
-   template<class T2, class ET2>
-   FieldEngineBase(const Centering<Dim> &centering,
- 		  const FieldEngineBase<Dim, T2, ET2> &model)
-     : physicalCellDomain_m(model.physicalCellDomain()),
-       guards_m(model.guardLayers()),
-       centering_m(centering),
-       num_materials_m(0)
-   {
-     if (centering.size() > 1)
-     {
-       addSubFields(centering.size());
-       for (int c = 0; c < centering.size(); ++ c)
-       {
-         Loc<Dim> offset(1);
-         offset -= centering.orientation(c);
-         subField(c).data_m = new Data_t(offset, Pooma::NoInit());
-       }
-     }
-     else
-     {
-       Loc<Dim> offset(1);
-       offset -= centering.orientation(0);
-       data_m = new Data_t(offset, Pooma::NoInit());
-     }
-   }
- 
-   // Centering versions. These construct sub-fields based on a
-   // centering.
- 
-   FieldEngineBase(const Centering<Dim> &centering,
-                   const Layout_t &layout, int materials = 0)
-     : physicalCellDomain_m(layout.domain()),
-       guards_m(layout.externalGuards()),
-       centering_m(centering),
-       num_materials_m(materials)
-   {
-     shrinkInPlace(physicalCellDomain_m, guards_m);
-     shrinkRightInPlace(physicalCellDomain_m, 1);
-     if (num_materials_m > 0)
-     {
-       addSubFields(num_materials_m);
-       for (int m = 0; m < num_materials_m; ++m)
-       {
-         if (centering.size() > 1)
-         {
-           subField(m).addSubFields(centering.size());
-           for (int c = 0; c < centering.size(); ++ c)
-           {
-             Loc<Dim> offset(1);
-             offset -= centering.orientation(c);
-             subField(m).subField(c).data_m = new Data_t(offset, layout);
-           }
-         }
-         else
-         {
-           Loc<Dim> offset(1);
-           offset -= centering.orientation(0);
-           subField(m).data_m = new Data_t(offset, layout);
-         }
-       }
-     }
-     else
-     {
-       if (centering.size() > 1)
-       {
-         addSubFields(centering.size());
-         for (int c = 0; c < centering.size(); ++ c)
-         {
-           Loc<Dim> offset(1);
-           offset -= centering.orientation(c);
-           subField(c).data_m = new Data_t(offset, layout);
-         }
-       }
-       else
-       {
-         Loc<Dim> offset(1);
-         offset -= centering.orientation(0);
-         data_m = new Data_t(offset, layout);
-       }
-     }
-   }
- 
-   // Copy constructor.
-   
-   FieldEngineBase(const This_t &model)
-   : subFields_m(model.subFields_m),
-     data_m(model.data_m),
-     physicalCellDomain_m(model.physicalCellDomain_m),
-     guards_m(model.guards_m),
-     centering_m(model.centering_m),
-     num_materials_m(model.num_materials_m)
-     { }
- 
-   // Sub-field view constructor. This is when we want to construct a view of
-   // one of the subFields in our top-level list.
-   
-   FieldEngineBase(const This_t &model, int iSubField)
-   : subFields_m(model.subFields_m[iSubField].subFields_m),
-     data_m(model.subFields_m[iSubField].data_m),
-     physicalCellDomain_m(model.physicalCellDomain_m),
-     guards_m(model.guards_m),
-     centering_m(model.subFields_m[iSubField].centering_m),
-     num_materials_m(model.subFields_m[iSubField].num_materials_m)
-     {
-       PInsist(iSubField >= 0 && iSubField < model.numSubFields(),
- 	      "Illegal attempt to extract a non-existent subfield.");
-     }
- 
-   // View constructor.  
-   
-   template<int Dim2, class T2, class EngineTag2, class Initializer>
-   FieldEngineBase(const FieldEngineBase<Dim2, T2, EngineTag2> &model, 
-                   const Initializer &i)
-     {
-       initialize(*this, model, i); 
-     }  
- 
-   //---------------------------------------------------------------------------
-   // Initialize functions. 
- 
-   template<class Initializer>
-   void initialize(const Loc<Dim> &loc, const Initializer &init)
-     {
-       data_m = new Data_t(loc, init);
-     }
- 
-   template<class Initializer>
-   void initialize(const Loc<Dim> &loc, const Initializer &init, 
-                   const RelationList &l)
-     {
-       data_m = new Data_t(loc, init, l);
-     }
- 
-   template<class Engine, class Domain>
-   void initialize(const Loc<Dim> &loc, const Engine &e, const Domain &d,
-     const RelationList &l)
-     {
-       data_m = new Data_t(loc, e, d, l);
-     }
- 
-   void initialize(const This_t &model)
-   {
-     subFields_m = model.subFields_m;
-     data_m = model.data_m;
-     physicalCellDomain_m = model.physicalCellDomain_m;
-     guards_m = model.guards_m;
-     centering_m = model.centering_m;
-     num_materials_m = model.num_materials_m;
-   }
- 
-   template<int Dim2, class T2, class EngineTag2>
-   void initialize(This_t &s, 
- 		  const FieldEngineBase<Dim2, T2, EngineTag2> &model,
- 		  const Domain_t &d)
-   {
-     int n = model.numSubFields();
-     s.centering_m = model.centering();
-     s.num_materials_m = model.numMaterials();
-     s.physicalCellDomain_m = d - d.firsts();
-     if (n == 0)
-     {
-       s.physicalCellDomain_m =
-         centeringDomainToCellDomain(s.physicalCellDomain_m, s.centering_m, 0);
-       s.initialize(model.offsets(), model.engine(), d, model.relations());
-     }
-     else
-     {
-       s.addSubFields(n);  
-       for (int i = 0; i < n; i++)
-       {
-         if (s.numMaterials() > 0)
-           initialize(s.subFields_m[i], model.subField(i), d);
-         else
-           initialize(s.subFields_m[i], model.subField(i),
-                      cellDomainToCenteringDomain(d, s.centering_m, i));
-       }
-     }
-   }
- 
-   template<int Dim2, class T2, class EngineTag2>
-   void initialize(This_t &s, 
-                   const FieldEngineBase<Dim2, T2, EngineTag2> &model,
-                   const INode<Dim> &i)
-   {
-     int n = model.numSubFields();
-     s.centering_m = model.centering();
-     s.num_materials_m = model.numMaterials();
-     s.physicalCellDomain_m = i.domain() - i.domain().firsts();
-     if (n == 0)
-     {
-       s.physicalCellDomain_m = 
-         centeringDomainToCellDomain(s.physicalCellDomain_m, s.centering_m, 0);
-       s.initialize(model.offsets(), model.engine(), i, model.relations());
-     }
-     else
-     {
-       s.physicalCellDomain_m = i.domain() - i.domain().firsts();
-       s.addSubFields(n);
-       for (int j = 0; j < n; j++)
-       {
-         if (s.numMaterials() > 0)
-           initialize(s.subFields_m[j], model.subField(j), i);
-         else
-           initialize(s.subFields_m[j], model.subField(j),
-                      INode<Dim>(i, cellDomainToCenteringDomain(i.domain(),
-                                                                s.centering_m,
-                                                                j)));
-       }
-     }
-   }
- 
-   template<int Dim2, class T2, class EngineTag2, class Tag>
-   void initialize(This_t &s, 
- 		  const FieldEngineBase<Dim2, T2, EngineTag2> &model,
- 		  const EngineView<Tag> &ev)
-   {
-     typedef typename FieldEngineBase<Dim2, T2, EngineTag2>::Engine_t EngIn_t;
-     const int n = model.numSubFields();
-     num_materials_m = model.numMaterials();
-     s.centering_m = model.centering();
-     if (n == 0)
-       {
-         s.physicalCellDomain_m = model.physicalCellDomain();
-         s.guards_m = model.guardLayers();
-         s.initialize(model.offsets(),
- 	    	     LeafFunctor<EngIn_t,
- 		     EngineView<Tag> >::apply(model.engine(), ev),
- 		     model.relations());
-       }
-     else
-       {
-         s.physicalCellDomain_m = model.physicalCellDomain();
-         s.guards_m = model.guardLayers();
-         s.addSubFields(n);
-         for (int i = 0; i < n; i++)
- 	  initialize(s.subFields_m[i], model.subField(i), ev);
-       }
-   }
- 
-   template<class EngineTag2>
-   void initialize(This_t &s,
- 		  const FieldEngineBase<Dim, T, EngineTag2> &model,
- 		  const FieldEnginePatch<Dim> &p)
-     {
-       PAssert(model.numSubFields() == 0);
-       num_materials_m = model.numMaterials();
-       s.centering_m = model.centering();
-       s.initialize(model.offsets(),
- 		   engineFunctor(model.engine(), EnginePatch(p.patch_m)));
-       s.physicalCellDomain_m =
-         centeringDomainToCellDomain(p.domain_m, s.centering_m, 0);
-       s.guards_m = model.guardLayers();
-     }
- 
-   template<int Dim2, class T2, class EngineTag2, class Components>
-   void initialize(This_t &s, 
-     const FieldEngineBase<Dim2, T2, EngineTag2> &model, 
-     const ComponentWrapper<Components> &c)
-     {
-       const int n = model.numSubFields();
-       s.centering_m = model.centering();
-       num_materials_m = model.numMaterials();
-       if (n == 0)
-         {
-           s.physicalCellDomain_m = model.physicalCellDomain();
-           s.guards_m = model.guardLayers();
-           s.initialize(model.offsets(), 
-                        Engine_t(model.engine(), c.components()),
-                        model.relations());
-         }
-       else
-         {
-           s.physicalCellDomain_m = model.physicalCellDomain();
-           s.guards_m = model.guardLayers();
-           s.addSubFields(n);
-           for (int i = 0; i < n; i++)
-             initialize(s.subFields_m[i], model.subField(i), c);
-         }
-     }
- 
-   void initialize(This_t &s, const This_t &model, 
-     const Pooma::DontCopyRelations &d)
-     {
-       const int n = model.numSubFields();
-       num_materials_m = model.numMaterials();
-       s.physicalCellDomain_m = model.physicalCellDomain();
-       s.guards_m = model.guardLayers();
-       s.centering_m = model.centering();
-       if (n == 0)
-         {
-           s.initialize(model.offsets(), model.engine());
-         }
-       else
-         {
-           s.addSubFields(n);
-           for (int i = 0; i < n; i++)
-             initialize(s.subFields_m[i], model.subField(i), d);
-         }
-     }
-       
- 
-   //---------------------------------------------------------------------------
-   // Accessors and modifiers.
-     
-   void addSubFields(int n)
-     {
-       PAssert(subFields_m.size() == 0);
-       PAssert((numMaterials() == n) ||
-               (numMaterials() == 0) && (centering_m.size() == n));
-       
-       subFields_m.reserve(n);
-       subFields_m.resize(n);
-       for (int i = 0; i < n; i++)
-         {
-           subFields_m[i].physicalCellDomain_m = physicalCellDomain_m;
-           subFields_m[i].guards_m = guards_m;
-           if (numMaterials() > 0)
-             subFields_m[i].centering_m = centering_m;
-           else
-             subFields_m[i].centering_m = centering_m[i];
-         }
-     }
-     
-   // FIXME: This function is deprecated.
-   inline int numSubFields() const
-     {
-       return subFields_m.size();
-     }
-     
-   This_t &subField(int i)
-     {
-       return subFields_m[i];
-     }
-     
-   const This_t &subField(int i) const
-     {
-       return subFields_m[i];
-     }
- 
-   const Loc<Dim> &offsets() const
-     {
-       PAssert(data_m.isValid());
-       return data_m->offsets();
-     }
-     
-   Engine_t &engine()
-     {
-       PAssert(data_m.isValid());
-       return data_m->engine();
-     }
-     
-   const Engine_t &engine() const
-     {
-       PAssert(data_m.isValid());
-       return data_m->engine();
-     }
- 
-   RelationList &relations() const
-     {
-       PAssert(data_m.isValid());
-       return data_m->relations();
-     }
-     
-   const GuardLayers_t &guardLayers() const
-     {
-       return guards_m;
-     }
- 
-   GuardLayers_t &guardLayers()
-     {
-       return guards_m;
-     }
- 
-   inline int numMaterials() const
-     {
-       return num_materials_m;
-     }
- 
-   //---------------------------------------------------------------------------
-   // Domain accessor functions. 
-         
-   inline const Domain_t physicalCellDomain() const
-   {
-     return physicalCellDomain_m;
-   }
-         
-   inline Domain_t totalCellDomain() const
-   {
-     return grow(physicalCellDomain_m, guards_m);
-   }
- 
-   Domain_t physicalDomain() const
-   {
-     if (centeringSize() == 1)
-       return cellDomainToCenteringDomain(physicalCellDomain_m, centering_m, 0);
-     else
-       return physicalCellDomain_m;
-   }
- 
-   Domain_t physicalDomain(int i) const
-   {
-     return cellDomainToCenteringDomain(physicalCellDomain_m, centering_m, i);
-   }
- 
-   Domain_t totalDomain() const
-   {
-     if (centeringSize() == 1)
-       return cellDomainToCenteringDomain(totalCellDomain(), centering_m, 0);
-     else
-       return totalCellDomain();
-   }
- 
-   Domain_t totalDomain(int i) const
-   {
-     return cellDomainToCenteringDomain(totalCellDomain(), centering_m, i);
-   }
- 
-   //---------------------------------------------------------------------------
-   // Centering accessors.
- 
-   const Centering<Dim> &centering() const
-   {
-     return centering_m;
-   }        
- 
-   inline int centeringSize() const
-     {
-       return centering_m.size();
-     }
- 
-   //---------------------------------------------------------------------------
-   // Make a distinct copy of this fieldEngineBase.   
-  
-   template<class Subject>
-   void makeOwnCopy(const Subject &s)
-     {
-       // This only make sense if we have no subfields.
-       
-       PAssert(data_m.isValid());
- 
-       // Create a new data block with shallow copies of the engine and the
-       // relations.
-       
-       initialize(offsets(), engine(), relations());
-       
-       // Deepen the copies of the engine & relations list.
-       
-       engine().makeOwnCopy();
-       relations().makeOwnCopy(s);
-     }
- 
- 
-   //---------------------------------------------------------------------------
-   // Domain translation function. 
-   
-   // FIXME: This function should go away.  Currently it's only used by
-   // the lagrangian field engine.
- 
-   inline Domain_t
-   translateToVertexDomain(const Domain_t &d) const
-     {
-       if (subFields_m.size() == 0)
-         return d;
-       else
-         return growRight(d, 1);
-     }
- 
-       
- private:
- 
-   RefCountedBlockPtr<This_t> subFields_m;
-   RefCountedPtr<Data_t> data_m;
-   Domain_t physicalCellDomain_m;
-   GuardLayers_t guards_m;
-   Centering<Dim> centering_m;
-   unsigned int num_materials_m;
- };
- 
- template<int Dim, class T, class EngineTag, class Tag>
- struct LeafFunctor<FieldEngineBase<Dim, T, EngineTag>,
-   ExpressionApply<Tag> >
- {
-   typedef FieldEngineBase<Dim, T, EngineTag> Subject_t;
-   typedef typename Subject_t::Engine_t Engine_t;
-   typedef LeafFunctor<Engine_t, ExpressionApply<Tag> > LeafFunctor_t;
-   typedef int Type_t;
- 
-   inline static
-   Type_t apply(const Subject_t &fieldEngineBase, 
- 	       const ExpressionApply<Tag> &tag)
-   {
-     int n = fieldEngineBase.numSubFields();
- 
-     if (n == 0)
-     {
-       LeafFunctor_t::apply(fieldEngineBase.engine(), tag);
-     }
-     else
-     {
-       int i;
-       for (i = 0; i < n; ++i)
-       {
- 	apply(fieldEngineBase.subField(i), tag);
-       }
-     }
-     return 0;
-   }
- };
- 
- // This function applies a generic thing to all the FieldEngineBase
- // objects that contain an engine.
- 
- template<int Dim, class T, class ETag, class Thing>
- void
- applyThingToFieldEngineBase(FieldEngineBase<Dim, T, ETag> &fieldEngineBase, 
- 			    const Thing &thing)
- {
-   int n = fieldEngineBase.numSubFields();
- 
-   if (n == 0)
-   {
-     thing(fieldEngineBase);
-   }
-   else
-   {
-     int i;
-     for (i = 0; i < n; ++i)
-     {
-       applyThingToFieldEngineBase(fieldEngineBase.subField(i), thing);
-     }
-   }
- }
- 
- #endif // POOMA_NEWFIELD_FIELDENGINE_FIELDENGINEBASE_H
- 
- // ACL:rcsinfo
- // ----------------------------------------------------------------------
- // $RCSfile: FieldEngineBase.h,v $   $Author: sasmith $
- // $Revision: 1.13.2.8 $   $Date: 2001/08/21 18:26:15 $
- // ----------------------------------------------------------------------
- // ACL:rcsinfo
--- 0 ----
Index: src/NewField/Mesh/NoMesh.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/Mesh/Attic/NoMesh.h,v
retrieving revision 1.1.2.1
diff -c -p -r1.1.2.1 NoMesh.h
*** src/NewField/Mesh/NoMesh.h	2001/08/07 22:30:47	1.1.2.1
--- src/NewField/Mesh/NoMesh.h	2001/08/23 22:59:15
*************** public:
*** 173,182 ****
    enum { dimensions = Dim };
  
    //---------------------------------------------------------------------------
!   // We do not provide a default constructor because we want construction to be
!   // an atomic operation.
!   //
!   //   NoMesh() { }
  
    // This constructor fully constructs the object using the layout to
    // compute domains.
--- 173,180 ----
    enum { dimensions = Dim };
  
    //---------------------------------------------------------------------------
! 
!   NoMesh() { }
  
    // This constructor fully constructs the object using the layout to
    // compute domains.
Index: src/NewField/Mesh/PositionFunctions.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/Mesh/PositionFunctions.h,v
retrieving revision 1.3
diff -c -p -r1.3 PositionFunctions.h
*** src/NewField/Mesh/PositionFunctions.h	2000/09/28 20:54:12	1.3
--- src/NewField/Mesh/PositionFunctions.h	2001/08/23 22:59:15
***************
*** 50,55 ****
--- 50,57 ----
  // Includes:
  //-----------------------------------------------------------------------------
  
+ #include "Tiny/Vector.h"
+ 
  //-----------------------------------------------------------------------------
  // Forward Declarations:
  //-----------------------------------------------------------------------------
*************** struct PositionFunctorUR
*** 76,90 ****
    }
  
    PositionFunctorUR(const PointType_t &origin,
! 	       const PointType_t &spacings,
! 	       const Interval<Dim> &physicalCellDomain,
! 	       const Loc<Dim> &offsets)
      : origin_m(origin), spacings_m(spacings)
    {
      for (int i = 0; i < Dim; i++)
      {
!       if (offsets[i].first() == 0)
! 	origin_m(i) += 0.5 * spacings_m(i);
        origin_m(i) -= physicalCellDomain[i].first() * spacings_m(i);
      }
    }
--- 78,91 ----
    }
  
    PositionFunctorUR(const PointType_t &origin,
!                     const PointType_t &spacings,
!                     const Interval<Dim> &physicalCellDomain,
!                     const Vector<Dim, double> &position)
      : origin_m(origin), spacings_m(spacings)
    {
      for (int i = 0; i < Dim; i++)
      {
!       origin_m(i) += position(i) * spacings_m(i);
        origin_m(i) -= physicalCellDomain[i].first() * spacings_m(i);
      }
    }
*************** struct FixPositionFunctorUR
*** 123,145 ****
    {
      typedef PositionFunctorUR<Dim, TM> Functor_t;
  
!     fieldEngineBase.engine().
!       setFunctor(Functor_t(origin_m, spacings_m,
! 			   fieldEngineBase.physicalCellDomain(),
! 			   fieldEngineBase.offsets())
! 		 );
    }
  
    PointType_t origin_m, spacings_m;
  };
  
! template<int Dim, class TM, class CoordinateSystem, class T, class EngineTag>
  FixPositionFunctorUR<Dim, TM>
! fixPositionFunctor(const Field<UniformRectilinear<Dim, TM, CoordinateSystem>,
  		   T, EngineTag> &field)
  {
!   return FixPositionFunctorUR<Dim, TM>(field.fieldEngine().origin(),
! 				       field.fieldEngine().spacings());
  }
  
  template<class Geom>
--- 124,152 ----
    {
      typedef PositionFunctorUR<Dim, TM> Functor_t;
  
!     for (int m = 0; m < fieldEngineBase.numMaterials(); ++m)
!     {
!       for (int c = 0; c < fieldEngineBase.centering().size(); ++ c)
!       {
!         fieldEngineBase.data(m, c).engine().
!           setFunctor(Functor_t(origin_m, spacings_m,
!                                fieldEngineBase.physicalCellDomain(),
!                                fieldEngineBase.centering().position(c))
!                      );
!       }
!     }
    }
  
    PointType_t origin_m, spacings_m;
  };
  
! template<int Dim, class TM, class T, class EngineTag>
  FixPositionFunctorUR<Dim, TM>
! fixPositionFunctor(const Field<UniformRectilinearMesh<Dim, TM>,
  		   T, EngineTag> &field)
  {
!   return FixPositionFunctorUR<Dim, TM>(field.mesh().origin(),
! 				       field.mesh().spacings());
  }
  
  template<class Geom>
*************** struct XField
*** 147,156 ****
  {
  };
  
! template<int Dim, class TM, class CoordinateSystem>
! struct XField<UniformRectilinear<Dim, TM, CoordinateSystem> >
  {
!   typedef UniformRectilinear<Dim, TM, CoordinateSystem> GeometryTag_t;
    typedef Vector<Dim, TM> PointType_t;
    typedef IndexFunction<PositionFunctorUR<Dim, TM> > PositionEngine_t;
    typedef Field<GeometryTag_t, PointType_t, PositionEngine_t> Type_t;
--- 154,163 ----
  {
  };
  
! template<int Dim, class TM>
! struct XField<UniformRectilinearMesh<Dim, TM> >
  {
!   typedef UniformRectilinearMesh<Dim, TM> GeometryTag_t;
    typedef Vector<Dim, TM> PointType_t;
    typedef IndexFunction<PositionFunctorUR<Dim, TM> > PositionEngine_t;
    typedef Field<GeometryTag_t, PointType_t, PositionEngine_t> Type_t;
*************** struct XField<UniformRectilinear<Dim, TM
*** 159,165 ****
  template<class F>
  void setXField(F &f)
  {
!   applyThingToFieldEngineBase(f.fieldEngine(), fixPositionFunctor(f));
  }
  
  template<class F, class Init>
--- 166,172 ----
  template<class F>
  void setXField(F &f)
  {
!   fixPositionFunctor(f)(f.fieldEngine());
  }
  
  template<class F, class Init>
Index: src/NewField/Mesh/UniformRectilinearMesh.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/Mesh/Attic/UniformRectilinearMesh.h,v
retrieving revision 1.1.2.5
diff -c -p -r1.1.2.5 UniformRectilinearMesh.h
*** src/NewField/Mesh/UniformRectilinearMesh.h	2001/08/21 00:02:39	1.1.2.5
--- src/NewField/Mesh/UniformRectilinearMesh.h	2001/08/23 22:59:15
*************** public:
*** 187,196 ****
    enum { dimensions = Dim };
  
    //---------------------------------------------------------------------------
!   // We do not provide a default constructor because we want construction to be
!   // an atomic operation.
!   //
!   //   UniformRectilinearMesh() { }
  
    // This constructor fully constructs the object. It uses the layout to
    // compute domains and also initializes the origin and the spacings in each
--- 187,194 ----
    enum { dimensions = Dim };
  
    //---------------------------------------------------------------------------
! 
!   UniformRectilinearMesh() { }
  
    // This constructor fully constructs the object. It uses the layout to
    // compute domains and also initializes the origin and the spacings in each
Index: src/NewField/Relations/ConstantFaceBC.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/Relations/Attic/ConstantFaceBC.h,v
retrieving revision 1.1.2.1
diff -c -p -r1.1.2.1 ConstantFaceBC.h
*** src/NewField/Relations/ConstantFaceBC.h	2001/08/21 15:22:38	1.1.2.1
--- src/NewField/Relations/ConstantFaceBC.h	2001/08/23 22:59:15
*************** public:
*** 103,111 ****
      // Therefore, we just chop out the guard layers, taking care to 
      // handle the case where we are enforcing a constant boundary 
      // (appropriate only for vert-centering).
  	 
      int adjust;
!     if (enforceConstantBoundary_m && t.fieldEngine().offsets()[d].min() == 1) 
        adjust = 0;
      else
        adjust = 1;
--- 103,114 ----
      // Therefore, we just chop out the guard layers, taking care to 
      // handle the case where we are enforcing a constant boundary 
      // (appropriate only for vert-centering).
+ 
+     // FIXME: what about discontinuous fields?
  	 
      int adjust;
!     if (enforceConstantBoundary_m &&
!         t.centering().orientation(0)[d].min() == 0)
        adjust = 0;
      else
        adjust = 1;
Index: src/NewField/Relations/PosReflectFaceBC.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/Relations/Attic/PosReflectFaceBC.h,v
retrieving revision 1.1.2.1
diff -c -p -r1.1.2.1 PosReflectFaceBC.h
*** src/NewField/Relations/PosReflectFaceBC.h	2001/08/21 15:22:49	1.1.2.1
--- src/NewField/Relations/PosReflectFaceBC.h	2001/08/23 22:59:15
*************** public:
*** 112,119 ****
      // Therefore, we just chop out the guard layers, taking care to 
      // handle the case where we are enforcing a zero boundary 
      // (appropriate only for vert-centering).
  	 
!     int adjust = t.fieldEngine().offsets()[d].min();
  
      // Select the high or low face.
  
--- 112,121 ----
      // Therefore, we just chop out the guard layers, taking care to 
      // handle the case where we are enforcing a zero boundary 
      // (appropriate only for vert-centering).
+ 
+     // FIXME: what about discontinuous fields?
  	 
!     int adjust = 1 - t.centering().orientation(0)[d].min();
  
      // Select the high or low face.
  
*************** public:
*** 186,192 ****
    {  
      t(domain_m) = t(srcRange_m);
  
!     if (enforceZeroBoundary_m &&  t.fieldEngine().offsets()[face_m / 2] == 1) 
        {
          typedef typename Target::Element_t T;
          t(vertFaceDomain_m) = T(0.0);
--- 188,195 ----
    {  
      t(domain_m) = t(srcRange_m);
  
!     if (enforceZeroBoundary_m &&
!         t.centering().orientation(0)[face_m / 2].min() == 0)
        {
          typedef typename Target::Element_t T;
          t(vertFaceDomain_m) = T(0.0);
Index: src/NewField/tests/BasicTest1.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/BasicTest1.cpp,v
retrieving revision 1.2.2.2
diff -c -p -r1.2.2.2 BasicTest1.cpp
*** src/NewField/tests/BasicTest1.cpp	2001/08/21 15:18:23	1.2.2.2
--- src/NewField/tests/BasicTest1.cpp	2001/08/23 22:59:15
*************** int main(int argc, char *argv[])
*** 104,119 ****
    // Make a Brick-Engine-based field.
  
    DomainLayout<2> layout1(physicalVertexDomain, GuardLayers<2>(1));
!   Centering<2> cell = canonicalCentering<2>(CellType, Continuous);
    
!   Field<UniformRectilinear<2>, double, Brick> 
      f(cell, layout1, origin, spacings);
  
    doTest(tester, f);
    
    // Make a CompressibleBrick-Engine-based field.
    
!   Field<UniformRectilinear<2>, double, CompressibleBrick> 
      fc(cell, layout1, origin, spacings);
  
    doTest(tester, fc);
--- 104,119 ----
    // Make a Brick-Engine-based field.
  
    DomainLayout<2> layout1(physicalVertexDomain, GuardLayers<2>(1));
!   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
    
!   Field<UniformRectilinearMesh<2>, double, Brick> 
      f(cell, layout1, origin, spacings);
  
    doTest(tester, f);
    
    // Make a CompressibleBrick-Engine-based field.
    
!   Field<UniformRectilinearMesh<2>, double, CompressibleBrick> 
      fc(cell, layout1, origin, spacings);
  
    doTest(tester, fc);
*************** int main(int argc, char *argv[])
*** 125,131 ****
                          GuardLayers<2>(0), GuardLayers<2>(1),
                          ReplicatedTag());
    typedef MultiPatch<GridTag, Brick> MP2_t;
!   Field<UniformRectilinear<2>, double, MP2_t> 
      fg(cell, layout2, origin, spacings);
  
    doTest(tester, fg);
--- 125,131 ----
                          GuardLayers<2>(0), GuardLayers<2>(1),
                          ReplicatedTag());
    typedef MultiPatch<GridTag, Brick> MP2_t;
!   Field<UniformRectilinearMesh<2>, double, MP2_t> 
      fg(cell, layout2, origin, spacings);
  
    doTest(tester, fg);
Index: src/NewField/tests/BasicTest2.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/BasicTest2.cpp,v
retrieving revision 1.1.2.2
diff -c -p -r1.1.2.2 BasicTest2.cpp
*** src/NewField/tests/BasicTest2.cpp	2001/08/21 15:18:28	1.1.2.2
--- src/NewField/tests/BasicTest2.cpp	2001/08/23 22:59:15
*************** int main(int argc, char *argv[])
*** 65,71 ****
    DomainLayout<2> layout1(Interval<2>(I, J), GuardLayers<2>(1));
    Centering<2> vert = canonicalCentering<2>(VertexType, Continuous);
    
!   Field<UniformRectilinear<2>, double, Brick> 
      f(vert, layout1, origin, spacings),
      g(vert, layout1, origin, spacings),
      h(vert, layout1, origin, spacings);
--- 65,71 ----
    DomainLayout<2> layout1(Interval<2>(I, J), GuardLayers<2>(1));
    Centering<2> vert = canonicalCentering<2>(VertexType, Continuous);
    
!   Field<UniformRectilinearMesh<2>, double, Brick> 
      f(vert, layout1, origin, spacings),
      g(vert, layout1, origin, spacings),
      h(vert, layout1, origin, spacings);
Index: src/NewField/tests/ExpressionTest.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/ExpressionTest.cpp,v
retrieving revision 1.2.2.2
diff -c -p -r1.2.2.2 ExpressionTest.cpp
*** src/NewField/tests/ExpressionTest.cpp	2001/08/06 17:02:50	1.2.2.2
--- src/NewField/tests/ExpressionTest.cpp	2001/08/23 22:59:15
*************** int main(int argc, char *argv[])
*** 397,403 ****
    Centering<1> cell = canonicalCentering<1>(CellType, Continuous);
  
    typedef 
!     Field<UniformRectilinear<1>, double, MultiPatch<UniformTag, BrickTag_t> >
      Field_t;
  
    Field_t initial(cell, layout, Vector<1>(0.0), Vector<1>(1.0));
--- 397,403 ----
    Centering<1> cell = canonicalCentering<1>(CellType, Continuous);
  
    typedef 
!     Field<UniformRectilinearMesh<1>, double, MultiPatch<UniformTag, BrickTag_t> >
      Field_t;
  
    Field_t initial(cell, layout, Vector<1>(0.0), Vector<1>(1.0));
*************** int main(int argc, char *argv[])
*** 425,431 ****
    //  test4(tester, 4, a1, a2, a3, a4, initial, cellInterior);
  
    typedef 
!     Field<UniformRectilinear<1>, double, MultiPatch<UniformTag,
                                                      CompBrickTag_t> >
      CompressibleField_t;
  
--- 425,431 ----
    //  test4(tester, 4, a1, a2, a3, a4, initial, cellInterior);
  
    typedef 
!     Field<UniformRectilinearMesh<1>, double, MultiPatch<UniformTag,
                                                      CompBrickTag_t> >
      CompressibleField_t;
  
Index: src/NewField/tests/FieldOffset.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/Attic/FieldOffset.cpp,v
retrieving revision 1.1.2.5
diff -c -p -r1.1.2.5 FieldOffset.cpp
*** src/NewField/tests/FieldOffset.cpp	2001/08/15 23:14:00	1.1.2.5
--- src/NewField/tests/FieldOffset.cpp	2001/08/23 22:59:15
*************** int main(int argc, char *argv[])
*** 47,53 ****
  
    Interval<Dim> physicalVertexDomain(4, 4);
    DomainLayout<Dim> layout(physicalVertexDomain, GuardLayers<Dim>(1));
!   typedef Field<UniformRectilinear<Dim>, double, Brick> Field_t;
    Field_t f(edges, layout, Vector<Dim>(0.0), Vector<Dim>(1.0, 2.0));
    Field_t fS(cell, layout, Vector<Dim>(0.0), Vector<Dim>(1.0, 2.0));
    Field_t g(3, edges, layout, Vector<Dim>(0.0), Vector<Dim>(1.0, 2.0));
--- 47,53 ----
  
    Interval<Dim> physicalVertexDomain(4, 4);
    DomainLayout<Dim> layout(physicalVertexDomain, GuardLayers<Dim>(1));
!   typedef Field<UniformRectilinearMesh<Dim>, double, Brick> Field_t;
    Field_t f(edges, layout, Vector<Dim>(0.0), Vector<Dim>(1.0, 2.0));
    Field_t fS(cell, layout, Vector<Dim>(0.0), Vector<Dim>(1.0, 2.0));
    Field_t g(3, edges, layout, Vector<Dim>(0.0), Vector<Dim>(1.0, 2.0));
Index: src/NewField/tests/FieldReductions.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/Attic/FieldReductions.cpp,v
retrieving revision 1.1.2.2
diff -c -p -r1.1.2.2 FieldReductions.cpp
*** src/NewField/tests/FieldReductions.cpp	2001/08/10 17:40:53	1.1.2.2
--- src/NewField/tests/FieldReductions.cpp	2001/08/23 22:59:15
*************** int main(int argc, char *argv[])
*** 70,76 ****
  
    Interval<Dim> physicalVertexDomain(4, 4);
    DomainLayout<Dim> layout(physicalVertexDomain, GuardLayers<Dim>(1));
!   typedef Field<UniformRectilinear<Dim>, double, Brick> Field_t;
  
  
    // Test 2D Discontinuous Vertex -> Continuous Vertex.
--- 70,76 ----
  
    Interval<Dim> physicalVertexDomain(4, 4);
    DomainLayout<Dim> layout(physicalVertexDomain, GuardLayers<Dim>(1));
!   typedef Field<UniformRectilinearMesh<Dim>, double, Brick> Field_t;
  
  
    // Test 2D Discontinuous Vertex -> Continuous Vertex.
*************** int main(int argc, char *argv[])
*** 128,134 ****
  
    Interval<3> physicalVertexDomain3(4, 4, 4);
    DomainLayout<3> layout3(physicalVertexDomain3, GuardLayers<3>(1));
!   Field<UniformRectilinear<3>, double, Brick>
      G(inputCenteringThree, layout3, Vector<3>(0.0), Vector<3>(1.0, 2.0, 0.0));
  
    G.all() = 2.0;
--- 128,134 ----
  
    Interval<3> physicalVertexDomain3(4, 4, 4);
    DomainLayout<3> layout3(physicalVertexDomain3, GuardLayers<3>(1));
!   Field<UniformRectilinearMesh<3>, double, Brick>
      G(inputCenteringThree, layout3, Vector<3>(0.0), Vector<3>(1.0, 2.0, 0.0));
  
    G.all() = 2.0;
Index: src/NewField/tests/FieldTour1.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/FieldTour1.cpp,v
retrieving revision 1.5.2.2
diff -c -p -r1.5.2.2 FieldTour1.cpp
*** src/NewField/tests/FieldTour1.cpp	2001/08/21 15:18:33	1.5.2.2
--- src/NewField/tests/FieldTour1.cpp	2001/08/23 22:59:15
*************** int main(int argc, char *argv[])
*** 64,70 ****
    Centering<2> allFace = canonicalCentering<2>(FaceType, Continuous);
  
    typedef 
!     Field<UniformRectilinear<2>, double,
      MultiPatch<UniformTag, BrickTag_t> > Field_t;
    Field_t f(allFace, layout, Vector<2>(0.0), Vector<2>(1.0, 2.0));
  
--- 64,70 ----
    Centering<2> allFace = canonicalCentering<2>(FaceType, Continuous);
  
    typedef 
!     Field<UniformRectilinearMesh<2>, double,
      MultiPatch<UniformTag, BrickTag_t> > Field_t;
    Field_t f(allFace, layout, Vector<2>(0.0), Vector<2>(1.0, 2.0));
  
*************** int main(int argc, char *argv[])
*** 143,148 ****
--- 143,149 ----
    std::cout << f.all() << std::endl;
    std::cout << g.all() << std::endl;
  
+   /*
    typedef 
      Field<Lagrangian<2>, double,
      MultiPatch<UniformTag, BrickTag_t> > 
*************** int main(int argc, char *argv[])
*** 156,161 ****
--- 157,163 ----
    h.all() = 3.0; // .all means also set guards as well as physical
    h = -6.0;
    std::cout << h.all() << std::endl;
+   */
     
    // Check out the patch function.
    
*************** int main(int argc, char *argv[])
*** 188,194 ****
    // Try to create a vector field.
  
    typedef 
!     Field<UniformRectilinear<2>, Vector<2>,
      MultiPatch<UniformTag, BrickTag_t> > 
       VectorField_t;
    VectorField_t l(allFace, layout, Vector<2>(0.0), Vector<2>(1.0, 2.0));
--- 190,196 ----
    // Try to create a vector field.
  
    typedef 
!     Field<UniformRectilinearMesh<2>, Vector<2>,
      MultiPatch<UniformTag, BrickTag_t> > 
       VectorField_t;
    VectorField_t l(allFace, layout, Vector<2>(0.0), Vector<2>(1.0, 2.0));
Index: src/NewField/tests/FieldTour2.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/FieldTour2.cpp,v
retrieving revision 1.2.2.1
diff -c -p -r1.2.2.1 FieldTour2.cpp
*** src/NewField/tests/FieldTour2.cpp	2001/08/03 16:07:13	1.2.2.1
--- src/NewField/tests/FieldTour2.cpp	2001/08/23 22:59:15
*************** int main(int argc, char *argv[])
*** 48,56 ****
    // Now, we can declare a field. Let's make this a multi-material
    // field with cell centering.
  
!   Centering<2> cell = canonicalCentering<2>(CellType, Continuous);
  
!   typedef Field<UniformRectilinear<2>, double, Brick> Field_t;
    Field_t f(3, cell, layout, // 3 fields each Cell-centered
      Vector<2>(0.0), Vector<2>(1.0, 2.0));
  
--- 48,56 ----
    // Now, we can declare a field. Let's make this a multi-material
    // field with cell centering.
  
!   Centering<2> cell = canonicalCentering<2>(CellType, Continuous, AllDim);
  
!   typedef Field<UniformRectilinearMesh<2>, double, Brick> Field_t;
    Field_t f(3, cell, layout, // 3 fields each Cell-centered
      Vector<2>(0.0), Vector<2>(1.0, 2.0));
  
Index: src/NewField/tests/FieldTour3.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/Attic/FieldTour3.cpp,v
retrieving revision 1.1.2.2
diff -c -p -r1.1.2.2 FieldTour3.cpp
*** src/NewField/tests/FieldTour3.cpp	2001/07/24 19:50:45	1.1.2.2
--- src/NewField/tests/FieldTour3.cpp	2001/08/23 22:59:15
*************** int main(int argc, char *argv[])
*** 43,49 ****
  
    Interval<2> physicalVertexDomain(4, 4);
    DomainLayout<2> layout(physicalVertexDomain, GuardLayers<2>(1));
!   typedef Field<UniformRectilinear<2>, double, Brick> Field_t;
  
    // Create a field with edge-centered values for the x- and y-directions.
    Field_t f(edges, layout, Vector<2>(0.0), Vector<2>(1.0, 2.0));
--- 43,49 ----
  
    Interval<2> physicalVertexDomain(4, 4);
    DomainLayout<2> layout(physicalVertexDomain, GuardLayers<2>(1));
!   typedef Field<UniformRectilinearMesh<2>, double, Brick> Field_t;
  
    // Create a field with edge-centered values for the x- and y-directions.
    Field_t f(edges, layout, Vector<2>(0.0), Vector<2>(1.0, 2.0));
Index: src/NewField/tests/Gradient.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/Attic/Gradient.cpp,v
retrieving revision 1.1.2.1
diff -c -p -r1.1.2.1 Gradient.cpp
*** src/NewField/tests/Gradient.cpp	2001/08/13 21:14:31	1.1.2.1
--- src/NewField/tests/Gradient.cpp	2001/08/23 22:59:15
*************** int main(int argc, char *argv[])
*** 146,152 ****
    Centering<dim> vertex = canonicalCentering<dim>(VertexType, Continuous);
    Centering<dim> discVertex = canonicalCentering<dim>(VertexType, Discontinuous);
  
!   typedef UniformRectilinear<dim> Geometry_t;
  
    typedef 
      Field<Geometry_t, double, MultiPatch<UniformTag, BrickTag_t> >
--- 146,152 ----
    Centering<dim> vertex = canonicalCentering<dim>(VertexType, Continuous);
    Centering<dim> discVertex = canonicalCentering<dim>(VertexType, Discontinuous);
  
!   typedef UniformRectilinearMesh<dim> Geometry_t;
  
    typedef 
      Field<Geometry_t, double, MultiPatch<UniformTag, BrickTag_t> >
Index: src/NewField/tests/LocalPatch.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/LocalPatch.cpp,v
retrieving revision 1.1.2.1
diff -c -p -r1.1.2.1 LocalPatch.cpp
*** src/NewField/tests/LocalPatch.cpp	2001/08/21 18:26:15	1.1.2.1
--- src/NewField/tests/LocalPatch.cpp	2001/08/23 22:59:16
*************** int main(int argc, char *argv[])
*** 82,88 ****
    // on a brick.
  
    typedef
!     Field<UniformRectilinear<2>, double,
      MultiPatch<GridTag, BrickTag_t> > Field_t;
    Field_t b0(cell, layout1, origin, spacings);
    Field_t b1(vert, layout1, origin, spacings);
--- 82,88 ----
    // on a brick.
  
    typedef
!     Field<UniformRectilinearMesh<2>, double,
      MultiPatch<GridTag, BrickTag_t> > Field_t;
    Field_t b0(cell, layout1, origin, spacings);
    Field_t b1(vert, layout1, origin, spacings);
*************** int main(int argc, char *argv[])
*** 169,175 ****
    tester.out() << "bb2:" << std::endl << bb2 << std::endl;
  
    typedef
!     Field<UniformRectilinear<2>, double,
      MultiPatch<GridTag, CompressibleBrickTag_t> > CField_t;
    CField_t c0(cell, layout1, origin, spacings);
    CField_t c1(vert, layout1, origin, spacings);
--- 169,175 ----
    tester.out() << "bb2:" << std::endl << bb2 << std::endl;
  
    typedef
!     Field<UniformRectilinearMesh<2>, double,
      MultiPatch<GridTag, CompressibleBrickTag_t> > CField_t;
    CField_t c0(cell, layout1, origin, spacings);
    CField_t c1(vert, layout1, origin, spacings);
Index: src/NewField/tests/OffsetReduction.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/Attic/OffsetReduction.cpp,v
retrieving revision 1.1.2.1
diff -c -p -r1.1.2.1 OffsetReduction.cpp
*** src/NewField/tests/OffsetReduction.cpp	2001/08/21 17:08:39	1.1.2.1
--- src/NewField/tests/OffsetReduction.cpp	2001/08/23 22:59:16
*************** int main(int argc, char *argv[])
*** 80,86 ****
    Centering<dim> vertex = canonicalCentering<dim>(VertexType, Continuous, AllDim);
    Centering<dim> discVertex = canonicalCentering<dim>(VertexType, Discontinuous, AllDim);
  
!   typedef UniformRectilinear<dim> Geometry_t;
  
    typedef 
      Field<Geometry_t, double, MultiPatch<UniformTag, BrickTag_t> >
--- 80,86 ----
    Centering<dim> vertex = canonicalCentering<dim>(VertexType, Continuous, AllDim);
    Centering<dim> discVertex = canonicalCentering<dim>(VertexType, Discontinuous, AllDim);
  
!   typedef UniformRectilinearMesh<dim> Geometry_t;
  
    typedef 
      Field<Geometry_t, double, MultiPatch<UniformTag, BrickTag_t> >
Index: src/NewField/tests/Replicate.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/Attic/Replicate.cpp,v
retrieving revision 1.1.2.1
diff -c -p -r1.1.2.1 Replicate.cpp
*** src/NewField/tests/Replicate.cpp	2001/08/16 18:26:41	1.1.2.1
--- src/NewField/tests/Replicate.cpp	2001/08/23 22:59:16
*************** int main(int argc, char *argv[])
*** 44,50 ****
    Centering<Dim> inputCenteringTwo, outputCenteringTwo;
    Interval<Dim> physicalVertexDomain(4, 4);
    DomainLayout<Dim> layout(physicalVertexDomain, GuardLayers<Dim>(1));
!   typedef Field<UniformRectilinear<Dim>, double, Brick> Field_t;
  
    // Test 2D Continuous Cell -> Discontinuous Edge.
  
--- 44,50 ----
    Centering<Dim> inputCenteringTwo, outputCenteringTwo;
    Interval<Dim> physicalVertexDomain(4, 4);
    DomainLayout<Dim> layout(physicalVertexDomain, GuardLayers<Dim>(1));
!   typedef Field<UniformRectilinearMesh<Dim>, double, Brick> Field_t;
  
    // Test 2D Continuous Cell -> Discontinuous Edge.
  
Index: src/NewField/tests/ScalarCode.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/ScalarCode.cpp,v
retrieving revision 1.7.2.2
diff -c -p -r1.7.2.2 ScalarCode.cpp
*** src/NewField/tests/ScalarCode.cpp	2001/08/21 21:10:49	1.7.2.2
--- src/NewField/tests/ScalarCode.cpp	2001/08/23 22:59:16
*************** int main(int argc, char *argv[])
*** 315,325 ****
  			  GuardLayers<dim>(1), GuardLayers<dim>(0),
  			  LayoutTag_t());
  
!   typedef UniformRectilinear<dim> Geometry_t;
!   typedef Field<Geometry_t, double, Brick> FieldBrick_t;
    typedef MultiPatch<GridTag, BrickTag_t> MP2_t;
!   typedef Field<UniformRectilinear<dim>, double, MP2_t> Field_t;
!   typedef Field<UniformRectilinear<dim>, Vector<dim>, MP2_t> FieldV_t;
  
    Centering<dim> cell = canonicalCentering<dim>(CellType, Continuous);
    Centering<dim> allFace = canonicalCentering<dim>(FaceType, Continuous);
--- 315,325 ----
  			  GuardLayers<dim>(1), GuardLayers<dim>(0),
  			  LayoutTag_t());
  
!   typedef UniformRectilinearMesh<dim> Mesh_t;
!   typedef Field<Mesh_t, double, Brick> FieldBrick_t;
    typedef MultiPatch<GridTag, BrickTag_t> MP2_t;
!   typedef Field<Mesh_t, double, MP2_t> Field_t;
!   typedef Field<Mesh_t, Vector<dim>, MP2_t> FieldV_t;
  
    Centering<dim> cell = canonicalCentering<dim>(CellType, Continuous);
    Centering<dim> allFace = canonicalCentering<dim>(FaceType, Continuous);
*************** int main(int argc, char *argv[])
*** 327,333 ****
    FieldBrick_t f(allFace, layout1, origin, spacings);
    Pooma::addAllConstantFaceBC(f, 4.0, true);
  
!   XField<Geometry_t>::Type_t x(allFace, layout1, origin, spacings);
    setXField(x);
  
    for(d = 0; d < dim; ++d)
--- 327,333 ----
    FieldBrick_t f(allFace, layout1, origin, spacings);
    Pooma::addAllConstantFaceBC(f, 4.0, true);
  
!   XField<Mesh_t>::Type_t x(allFace, layout1, origin, spacings);
    setXField(x);
  
    for(d = 0; d < dim; ++d)
*************** int main(int argc, char *argv[])
*** 385,391 ****
    Field_t EdgePsiLimiter(edge, layout3, origin, spacings);
  
    DomainLayout<dim> layout4(physicalVertexDomain, GuardLayers<dim>(1));
!   XField<Geometry_t>::Type_t xEdge(edge, layout4, origin, spacings);
    setXField(xEdge);
  
    EdgeGammaConstant = 1.4;
--- 385,391 ----
    Field_t EdgePsiLimiter(edge, layout3, origin, spacings);
  
    DomainLayout<dim> layout4(physicalVertexDomain, GuardLayers<dim>(1));
!   XField<Mesh_t>::Type_t xEdge(edge, layout4, origin, spacings);
    setXField(xEdge);
  
    EdgeGammaConstant = 1.4;
*************** int main(int argc, char *argv[])
*** 414,420 ****
    Field_t edgeValues(edgeY, layout3, origin, spacings);
    Field_t cellValues(cell, layout3, origin, spacings);
  
!   XField<Geometry_t>::Type_t xEdgeY(edgeY, layout4, origin, spacings);
    setXField(xEdgeY);
  
    edgeValues.all() = 42.0;
--- 414,420 ----
    Field_t edgeValues(edgeY, layout3, origin, spacings);
    Field_t cellValues(cell, layout3, origin, spacings);
  
!   XField<Mesh_t>::Type_t xEdgeY(edgeY, layout4, origin, spacings);
    setXField(xEdgeY);
  
    edgeValues.all() = 42.0;
Index: src/NewField/tests/StencilTests.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/StencilTests.cpp,v
retrieving revision 1.1.2.1
diff -c -p -r1.1.2.1 StencilTests.cpp
*** src/NewField/tests/StencilTests.cpp	2001/08/03 16:07:13	1.1.2.1
--- src/NewField/tests/StencilTests.cpp	2001/08/23 22:59:16
*************** int main(int argc, char *argv[])
*** 84,90 ****
    Centering<2> vertex = canonicalCentering<2>(VertexType, Continuous);
    Centering<2> allFace = canonicalCentering<2>(FaceType, Continuous);
  
!   typedef UniformRectilinear<2> Geometry_t;
  
    typedef 
      Field<Geometry_t, double, MultiPatch<UniformTag, BrickTag_t> >
--- 84,90 ----
    Centering<2> vertex = canonicalCentering<2>(VertexType, Continuous);
    Centering<2> allFace = canonicalCentering<2>(FaceType, Continuous);
  
!   typedef UniformRectilinearMesh<2> Geometry_t;
  
    typedef 
      Field<Geometry_t, double, MultiPatch<UniformTag, BrickTag_t> >
Index: src/NewField/tests/TestBasicRelations.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/Attic/TestBasicRelations.cpp,v
retrieving revision 1.1.2.1
diff -c -p -r1.1.2.1 TestBasicRelations.cpp
*** src/NewField/tests/TestBasicRelations.cpp	2001/08/21 15:17:32	1.1.2.1
--- src/NewField/tests/TestBasicRelations.cpp	2001/08/23 22:59:16
***************
*** 31,37 ****
  
  #include "Pooma/NewFields.h"
  
! typedef Field<UniformRectilinear<2>, double, Brick> Field_t;
  
  const double g = 9.8;
  
--- 31,37 ----
  
  #include "Pooma/NewFields.h"
  
! typedef Field<UniformRectilinearMesh<2>, double, Brick> Field_t;
  
  const double g = 9.8;
  
Index: src/NewField/tests/VectorTest.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/VectorTest.cpp,v
retrieving revision 1.3.2.1
diff -c -p -r1.3.2.1 VectorTest.cpp
*** src/NewField/tests/VectorTest.cpp	2001/08/03 16:07:13	1.3.2.1
--- src/NewField/tests/VectorTest.cpp	2001/08/23 22:59:16
*************** int main(int argc, char *argv[])
*** 89,95 ****
  
    Centering<2> allFace = canonicalCentering<2>(FaceType, Continuous);
  
!   typedef UniformRectilinear<2> Geometry_t;
    typedef MultiPatch<UniformTag, BrickTag_t> EngineTag_t;
    //  typedef BrickTag_t EngineTag_t;
  
--- 89,95 ----
  
    Centering<2> allFace = canonicalCentering<2>(FaceType, Continuous);
  
!   typedef UniformRectilinearMesh<2> Geometry_t;
    typedef MultiPatch<UniformTag, BrickTag_t> EngineTag_t;
    //  typedef BrickTag_t EngineTag_t;
  
Index: src/NewField/tests/WhereTest.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/NewField/tests/WhereTest.cpp,v
retrieving revision 1.3.2.1
diff -c -p -r1.3.2.1 WhereTest.cpp
*** src/NewField/tests/WhereTest.cpp	2001/08/03 16:07:13	1.3.2.1
--- src/NewField/tests/WhereTest.cpp	2001/08/23 22:59:16
*************** int main(int argc, char *argv[])
*** 87,93 ****
  
    Centering<2> allFace = canonicalCentering<2>(FaceType, Continuous);
  
!   typedef UniformRectilinear<2> Geometry_t;
  
    typedef 
      Field<Geometry_t, double, MultiPatch<UniformTag, BrickTag_t> >
--- 87,93 ----
  
    Centering<2> allFace = canonicalCentering<2>(FaceType, Continuous);
  
!   typedef UniformRectilinearMesh<2> Geometry_t;
  
    typedef 
      Field<Geometry_t, double, MultiPatch<UniformTag, BrickTag_t> >
Index: src/Pooma/NewFields.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Pooma/NewFields.h,v
retrieving revision 1.5.2.5
diff -c -p -r1.5.2.5 NewFields.h
*** src/Pooma/NewFields.h	2001/08/22 15:26:37	1.5.2.5
--- src/Pooma/NewFields.h	2001/08/23 22:59:16
***************
*** 46,55 ****
  
  // FieldEngines:
  
! #include "NewField/FieldEngine/FieldEngine.UR.h"
! #include "NewField/FieldEngine/FieldEngine.Lagrangian.h"
! #include "NewField/FieldEngine/FieldEngine.NoGeometry.h"
! #include "NewField/FieldEngine/FieldEngineBase.ExprEngine.h"
  
  // Meshes:
  
--- 46,53 ----
  
  // FieldEngines:
  
! #include "NewField/FieldEngine/FieldEngine.h"
! #include "NewField/FieldEngine/FieldEngine.ExprEngine.h"
  
  // Meshes:
  
