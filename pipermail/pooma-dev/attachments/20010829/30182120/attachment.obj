Index: Engine/BrickBase.cpp===================================================================RCS file: /home/pooma/Repository/r2/src/Engine/BrickBase.cpp,vretrieving revision 1.8diff -p -c -2 -r1.8 BrickBase.cpp*** Engine/BrickBase.cpp	2000/07/11 23:06:40	1.8--- Engine/BrickBase.cpp	2001/08/29 16:39:07*************** BrickBase<Dim>::BrickBase(bool compressi*** 74,78 ****  template <int Dim>   BrickBase<Dim>::BrickBase(const Domain_t &dom, bool compressible)!   : domain_m(dom), compressibleBase_m(compressible)  {    // Compute the strides and offset.--- 74,134 ----  template <int Dim>   BrickBase<Dim>::BrickBase(const Domain_t &dom, bool compressible)!   : layout_m(dom), compressibleBase_m(compressible)! {!   // Compute the strides and offset.! !   strides_m[0] = 1;!   firsts_m[0]  = domain()[0].first();!   off_m        = -firsts_m[0];! !   for (int d = 1; d < Dim; ++d)!     {!       firsts_m[d]  = domain()[d].first();!       strides_m[d] = strides_m[d-1]*domain()[d-1].length();!       off_m       -= domain()[d].first()*strides_m[d];!     }!   !   for (int d = 0; d < Dim; ++d) ostrides_m[d] = strides_m[d];! }! ! //-----------------------------------------------------------------------------! //! // BrickBase(const Node<Domain_t> &node)! //! // Constructs a BrickBase using the specified Node.! //! //-----------------------------------------------------------------------------! ! template <int Dim> ! BrickBase<Dim>::BrickBase(const Node<Domain_t> &node, bool compressible)!   : layout_m(node), compressibleBase_m(compressible)! {!   // Compute the strides and offset.! !   strides_m[0] = 1;!   firsts_m[0]  = domain()[0].first();!   off_m        = -firsts_m[0];! !   for (int d = 1; d < Dim; ++d)!     {!       firsts_m[d]  = domain()[d].first();!       strides_m[d] = strides_m[d-1]*domain()[d-1].length();!       off_m       -= domain()[d].first()*strides_m[d];!     }!   !   for (int d = 0; d < Dim; ++d) ostrides_m[d] = strides_m[d];! }! ! //-----------------------------------------------------------------------------! //! // BrickBase(const domainLayout<Dim> &layout)! //! // Constructs a BrickBase using the specified DomainLayout.! //! //-----------------------------------------------------------------------------! ! template <int Dim> ! BrickBase<Dim>::BrickBase(const Layout_t &layout, bool compressible)!   : layout_m(layout), compressibleBase_m(compressible)  {    // Compute the strides and offset.Index: Engine/BrickBase.h===================================================================RCS file: /home/pooma/Repository/r2/src/Engine/BrickBase.h,vretrieving revision 1.11diff -p -c -2 -r1.11 BrickBase.h*** Engine/BrickBase.h	2000/07/11 23:06:40	1.11--- Engine/BrickBase.h	2001/08/29 16:39:08****************** 57,60 ****--- 57,61 ----  #include "Domain/SliceRange.h"  #include "Domain/SliceInterval.h"+ #include "Layout/DomainLayout.h"  #include "Utilities/PAssert.h"  *************** public:*** 109,112 ****--- 110,114 ----      typedef Interval<Dim>  Domain_t;+   typedef DomainLayout<Dim> Layout_t;        typedef BrickBase<Dim> This_t;*************** public:*** 130,133 ****--- 132,145 ----    explicit BrickBase(const Domain_t &domain, bool compressible = false);  +   // Initialize the BrickBase with a Layout describing the Dim-+   // dimensional domain to be indexed.+   +   explicit BrickBase(const Node<Domain_t> &node, bool compressible = false);+ +   // Initialize the BrickBase with a Layout describing the Dim-+   // dimensional domain to be indexed.+   +   explicit BrickBase(const Layout_t &layout, bool compressible = false);+     // Copy constructor - Use compiler generated version.  *************** public:*** 148,152 ****    // Return the domain.  !   inline const Domain_t &domain() const { return domain_m; }      // Return the strides array.--- 160,168 ----    // Return the domain.  !   inline const Domain_t &domain() const { return layout_m.domain(); }! !   // Return the layout.! !   inline const Layout_t &layout() const { return layout_m; }      // Return the strides array.*************** protected:*** 296,302 ****    //============================================================  !   // Brick domain.  !   Domain_t domain_m;      // Strides through actual data block when stepping in different directions.--- 312,318 ----    //============================================================  !   // Layout.  !   Layout_t layout_m;      // Strides through actual data block when stepping in different directions.*************** struct DoubleSliceHelper*** 352,355 ****--- 368,372 ----  {    typedef Interval<Dim>  Domain_t;+   typedef DomainLayout<Dim> Layout_t;        static void init(Domain_t &domain, *************** public:*** 402,405 ****--- 419,423 ----        typedef Interval<Dim>  Domain_t;+   typedef DomainLayout<Dim> Layout_t;        //============================================================*************** public:*** 508,511 ****--- 526,533 ----      inline const Domain_t &domain() const { return domain_m; }+ +   // Return our layout:+ +   inline Layout_t layout() const { return Layout_t(domain_m); }      // Return the strides array.Index: Engine/BrickEngine.cpp===================================================================RCS file: /home/pooma/Repository/r2/src/Engine/BrickEngine.cpp,vretrieving revision 1.74.2.1diff -p -c -2 -r1.74.2.1 BrickEngine.cpp*** Engine/BrickEngine.cpp	2001/08/23 23:01:20	1.74.2.1--- Engine/BrickEngine.cpp	2001/08/29 16:39:08*************** Engine<Dim,T,Brick>::Engine(const Domain*** 63,67 ****  template <int Dim, class T>  Engine<Dim,T,Brick>::Engine(const Node<Domain_t> &node)!   : Base_t(node.allocated()),      data_m(node.allocated().size(), node.affinity(),              DataBlockPtr<T>::WithAffinity_t())--- 63,67 ----  template <int Dim, class T>  Engine<Dim,T,Brick>::Engine(const Node<Domain_t> &node)!   : Base_t(node),      data_m(node.allocated().size(), node.affinity(),              DataBlockPtr<T>::WithAffinity_t())*************** Engine<Dim,T,Brick>::Engine(const Node<D*** 70,74 ****  template <int Dim, class T>  Engine<Dim,T,Brick>::Engine(const Layout_t &layout)!   : Base_t(layout.domain()), data_m(layout.domain().size())  { }  --- 70,74 ----  template <int Dim, class T>  Engine<Dim,T,Brick>::Engine(const Layout_t &layout)!   : Base_t(layout), data_m(layout.domain().size())  { }  Index: Engine/BrickEngine.h===================================================================RCS file: /home/pooma/Repository/r2/src/Engine/BrickEngine.h,vretrieving revision 1.129.2.1diff -p -c -2 -r1.129.2.1 BrickEngine.h*** Engine/BrickEngine.h	2001/08/23 23:01:20	1.129.2.1--- Engine/BrickEngine.h	2001/08/29 16:39:08*************** public:*** 245,252 ****    ElementRef_t operator()(int, int, int, int, int, int, int) const;  -   // Return the layout.- -   inline Layout_t layout() const { return Layout_t(domain_m); }-     // Get a private copy of data viewed by this Engine.  --- 245,248 ----Index: Engine/CompressibleBrick.h===================================================================RCS file: /home/pooma/Repository/r2/src/Engine/CompressibleBrick.h,vretrieving revision 1.70.2.1diff -p -c -2 -r1.70.2.1 CompressibleBrick.h*** Engine/CompressibleBrick.h	2001/08/23 23:01:21	1.70.2.1--- Engine/CompressibleBrick.h	2001/08/29 16:39:08*************** public:*** 234,241 ****    Element_t read(const Loc<Dim> &) const;  -   // Return the layout.- -   inline Layout_t layout() const { return Layout_t(domain_m); }-     //---------------------------------------------------------------------------    // Return the domain and base domain.--- 234,237 ----*************** public:*** 243,247 ****    inline const Domain_t &domain() const    {!     return domain_m;    }  --- 239,243 ----    inline const Domain_t &domain() const    {!     return layout_m.domain();    }  Index: Engine/ConstantFunctionEngine.h===================================================================RCS file: /home/pooma/Repository/r2/src/Engine/ConstantFunctionEngine.h,vretrieving revision 1.17diff -p -c -2 -r1.17 ConstantFunctionEngine.h*** Engine/ConstantFunctionEngine.h	2001/04/11 21:39:27	1.17--- Engine/ConstantFunctionEngine.h	2001/08/29 16:39:08****************** 50,53 ****--- 50,54 ----  #include "Engine/Engine.h"  #include "Layout/INode.h"+ #include "Layout/DomainLayout.h"  #include "PETE/ErrorType.h"  *************** public:*** 88,91 ****--- 89,93 ----    typedef This_t                             Engine_t;    typedef Interval<Dim>                      Domain_t;+   typedef DomainLayout<Dim>                  Layout_t;    typedef T                                  Element_t;    typedef ErrorType                          ElementRef_t;*************** public:*** 98,101 ****--- 100,108 ----      //---------------------------------------------------------------------------+   // Default constructor.+ +   Engine() { }+   +   //---------------------------------------------------------------------------    // Construct from a domain object.  *************** public:*** 105,108 ****--- 112,122 ----      for (int d = 0; d < Dim; ++d)        firsts_m[d] = domain[d].first();+   }+ +   Engine(const Layout_t &layout, T val = T())+   : val_m(val), domain_m(layout.domain())+   { +     for (int d = 0; d < Dim; ++d)+       firsts_m[d] = domain_m[d].first();    }  Index: Engine/IndexFunctionEngine.h===================================================================RCS file: /home/pooma/Repository/r2/src/Engine/IndexFunctionEngine.h,vretrieving revision 1.22diff -p -c -2 -r1.22 IndexFunctionEngine.h*** Engine/IndexFunctionEngine.h	2001/05/04 15:41:28	1.22--- Engine/IndexFunctionEngine.h	2001/08/29 16:39:09*************** public:*** 120,124 ****      //---------------------------------------------------------------------------!   // Construct from a domain object and an optional Functor object.      Engine(const Domain_t &domain, const Functor &f = Functor())--- 120,124 ----      //---------------------------------------------------------------------------!   // Construct from a domain/layout object and an optional Functor object.      Engine(const Domain_t &domain, const Functor &f = Functor())Index: Layout/DomainLayout.h===================================================================RCS file: /home/pooma/Repository/r2/src/Layout/DomainLayout.h,vretrieving revision 1.24.2.1diff -p -c -2 -r1.24.2.1 DomainLayout.h*** Layout/DomainLayout.h	2001/08/08 15:16:26	1.24.2.1--- Layout/DomainLayout.h	2001/08/29 16:39:13*************** public:*** 98,113 ****    // General public typedefs.  !   typedef DomainLayout<Dim>                          This_t;!   typedef Interval<Dim>                              Domain_t;!   typedef Node<Domain_t>                             Value_t;!   typedef DynamicEvents::PatchID_t                   PatchID_t;!   typedef DynamicEvents::CreateSize_t                CreateSize_t;!   typedef GuardLayers<Dim>                           GuardLayers_t;  !   // Iterator through nodes. Basically the same as the vector iterator!   // except it dereferences automatically.      !   typedef DerefIterator<Value_t>               iterator;!   typedef ConstDerefIterator<Value_t>          const_iterator;      // General public enums.--- 98,112 ----    // General public typedefs.  !   typedef DomainLayout<Dim>                  This_t;!   typedef Interval<Dim>                      Domain_t;!   typedef Node<Domain_t>                     Value_t;!   typedef DynamicEvents::PatchID_t           PatchID_t;!   typedef DynamicEvents::CreateSize_t        CreateSize_t;!   typedef GuardLayers<Dim>                   GuardLayers_t;  !   // Iterator through our one node. Just a pointer.      !   typedef Value_t                            *iterator;!   typedef const Value_t                      *const_iterator;      // General public enums.*************** public:*** 124,128 ****      DomainLayout()-     : nodePtr_m(&node_m)      {      }--- 123,126 ----*************** public:*** 132,136 ****      explicit DomainLayout(const Domain_t &dom)!     : node_m(0, dom, Pooma::context(), 0, 0), nodePtr_m(&node_m)      {      }--- 130,134 ----      explicit DomainLayout(const Domain_t &dom)!     : node_m(0, dom, Pooma::context(), 0, 0)      {      }*************** public:*** 139,154 ****      DomainLayout(const Domain_t &dom, const GuardLayers_t &g)!     : node_m(0, dom, grow(dom, g), Pooma::context(), 0, 0), !       nodePtr_m(&node_m),!       externalGuards_m(g)      {      }      // Copy: Construct a layout object from another layout object.  This layout    // object will share usage of the other layout's data object.      DomainLayout(const This_t &layout)!     : node_m(layout.node_m), nodePtr_m(&node_m),!       externalGuards_m(layout.externalGuards_m)      {      }--- 137,156 ----      DomainLayout(const Domain_t &dom, const GuardLayers_t &g)!     : node_m(0, dom, grow(dom, g), Pooma::context(), 0, 0)      {      }  +   // Construct a layout with a global domain and guard layers.+ +   explicit DomainLayout(const Value_t &node)+     : node_m(node)+     {+     }+     // Copy: Construct a layout object from another layout object.  This layout    // object will share usage of the other layout's data object.      DomainLayout(const This_t &layout)!     : node_m(layout.node_m)      {      }*************** public:*** 165,169 ****    void initialize(const Domain_t &dom, const GuardLayers_t &g)      {-       externalGuards_m.initialize(g);        node_m = Value_t(0, dom,  grow(dom, g), Pooma::context(), 0, 0);      }--- 167,170 ----*************** public:*** 174,178 ****    {      node_m = layout.node_m;-     externalGuards_m = layout.externalGuards_m;    }  --- 175,178 ----*************** public:*** 216,220 ****    inline const Domain_t &domain() const      {!       return node().allocated();      }  --- 216,220 ----    inline const Domain_t &domain() const      {!       return node_m.allocated();      }  *************** public:*** 223,227 ****    inline const Domain_t &innerDomain() const    {!     return node().domain();    }  --- 223,227 ----    inline const Domain_t &innerDomain() const    {!     return node_m.domain();    }  *************** public:*** 230,234 ****    inline const Domain_t &allocated() const      {!       return node().allocated();      }  --- 230,234 ----    inline const Domain_t &allocated() const      {!       return node_m.allocated();      }  *************** public:*** 238,244 ****    }  !   inline const GuardLayers_t &externalGuards() const    {!     return externalGuards_m;    }  --- 238,251 ----    }  !   inline GuardLayers_t externalGuards() const    {!     GuardLayers_t gl;!     for (int i = 0; i < Dim; i++)!       {!         gl.lower(i) = node_m.domain()[i].min() - node_m.allocated()[i].min();!         gl.upper(i) = node_m.allocated()[i].max() - node_m.domain()[i].max();!       }!         !     return gl;    }  *************** public:*** 246,250 ****    {      PAssert(i==0);!     return node().allocated();    }    --- 253,257 ----    {      PAssert(i==0);!     return node_m.allocated();    }    *************** public:*** 252,256 ****    {      PAssert(i==0);!     return node().domain();    }  --- 259,263 ----    {      PAssert(i==0);!     return node_m.domain();    }  *************** public:*** 260,264 ****      {        PAssert(i==0);!       return node().allocated();      }  --- 267,271 ----      {        PAssert(i==0);!       return node_m.allocated();      }  *************** public:*** 288,304 ****    inline iterator begin()      { !       return iterator(&nodePtr_m);      }    inline iterator end()      { !       return iterator(&nodePtr_m + 1);      }    inline const_iterator begin() const      { !       return const_iterator(&nodePtr_m);      }    inline const_iterator end() const      { !       return const_iterator(&nodePtr_m + 1);      }  --- 295,311 ----    inline iterator begin()      { !       return &node_m;      }    inline iterator end()      { !       return &node_m + 1;      }    inline const_iterator begin() const      { !       return &node_m;      }    inline const_iterator end() const      { !       return &node_m + 1;      }  *************** public:*** 499,504 ****    void print(Out &o) const       {!       o << "DomainLayout: Node = " << node_m << " External Guards:"! 	<< externalGuards();      }  --- 506,510 ----    void print(Out &o) const       {!       o << "DomainLayout: Node = " << node_m;      }  *************** private:*** 512,523 ****      Value_t node_m;- -   // A pointer to the node, used for iterators- -   Value_t *nodePtr_m;-   -   // External guard layers.-   -   GuardLayers_t externalGuards_m;  };  --- 518,521 ----Index: Layout/tests/domainLayout.cpp===================================================================RCS file: /home/pooma/Repository/r2/src/Layout/tests/domainLayout.cpp,vretrieving revision 1.1diff -p -c -2 -r1.1 domainLayout.cpp*** Layout/tests/domainLayout.cpp	2000/09/25 20:38:37	1.1--- Layout/tests/domainLayout.cpp	2001/08/29 16:39:13****************** 27,31 ****  // ACL:license  //-----------------------------------------------------------------------------! // GridLayout test: Create and use GridLayout objects  //-----------------------------------------------------------------------------  --- 27,31 ----  // ACL:license  //-----------------------------------------------------------------------------! // DomainLayout test: Create and use DomainLayout objects  //-----------------------------------------------------------------------------  *************** int main(int argc, char *argv[])*** 43,50 ****    Pooma::initialize(argc, argv);    Pooma::Tester tester(argc, argv);!   tester.out() << argv[0] << ": GridLayout operations." << std::endl;    tester.out() << "----------------------------------------" << std::endl;  -     Interval<1> I1(0,9);    Interval<2> I2(I1,I1);--- 43,49 ----    Pooma::initialize(argc, argv);    Pooma::Tester tester(argc, argv);!   tester.out() << argv[0] << ": DomainLayout operations." << std::endl;    tester.out() << "----------------------------------------" << std::endl;      Interval<1> I1(0,9);    Interval<2> I2(I1,I1);*************** int main(int argc, char *argv[])*** 66,70 ****       tester.out() << "-------------------------------------------" << std::endl;!   int retval = tester.results("GridLayout operations");    Pooma::finalize();    return retval;--- 65,69 ----       tester.out() << "-------------------------------------------" << std::endl;!   int retval = tester.results("DomainLayout operations");    Pooma::finalize();    return retval;Index: NewField/Field.h===================================================================RCS file: /home/pooma/Repository/r2/src/NewField/Field.h,vretrieving revision 1.15.2.12diff -p -c -2 -r1.15.2.12 Field.h*** NewField/Field.h	2001/08/28 21:39:34	1.15.2.12--- NewField/Field.h	2001/08/29 16:39:15****************** 81,88 ****  struct CompressibleBrick;  ! template<class MeshTag, class T, class EngineTag>  class Field;  ! template<class MeshTag, class T, class EngineTag> class FieldEngine;    template<class LTag, class EngineTag>--- 81,88 ----  struct CompressibleBrick;  ! template<class Mesh, class T, class EngineTag>  class Field;  ! template<class Mesh, class T, class EngineTag> class FieldEngine;    template<class LTag, class EngineTag>*************** class RelationListItem;*** 112,116 ****  // extra assign() functions that take the following arguments:  //! //   assign(Field<MeshTag,T,EngineTag>, yourclass, Operator)  //  // where "yourclass" is the class that you would like to work on the--- 112,116 ----  // extra assign() functions that take the following arguments:  //! //   assign(Field<Mesh,T,EngineTag>, yourclass, Operator)  //  // where "yourclass" is the class that you would like to work on the*************** class RelationListItem;*** 118,137 ****  //-----------------------------------------------------------------------------    ! template<class MeshTag, class T, class EngineTag,    class MeshTag2, class T2, class EngineTag2, class Op>! const Field<MeshTag, T, EngineTag> &! assign(const Field<MeshTag,  T,  EngineTag> &lhs,         const Field<MeshTag2, T2, EngineTag2> &rhs,         const Op &op);  ! template<class MeshTag, class T, class EngineTag,    int Dim2, class T2, class EngineTag2, class Op>! const Field<MeshTag, T, EngineTag> &! assign(const Field<MeshTag, T, EngineTag> &lhs,          const Array<Dim2, T2, EngineTag2> &rhs, const Op &op);  ! template<class MeshTag, class T, class EngineTag, class T1, class Op>! const Field<MeshTag, T, EngineTag> &! assign(const Field<MeshTag, T, EngineTag> &lhs,          const T1 &rhs, const Op &op);  --- 118,137 ----  //-----------------------------------------------------------------------------    ! template<class Mesh, class T, class EngineTag,    class MeshTag2, class T2, class EngineTag2, class Op>! const Field<Mesh, T, EngineTag> &! assign(const Field<Mesh,  T,  EngineTag> &lhs,         const Field<MeshTag2, T2, EngineTag2> &rhs,         const Op &op);  ! template<class Mesh, class T, class EngineTag,    int Dim2, class T2, class EngineTag2, class Op>! const Field<Mesh, T, EngineTag> &! assign(const Field<Mesh, T, EngineTag> &lhs,          const Array<Dim2, T2, EngineTag2> &rhs, const Op &op);  ! template<class Mesh, class T, class EngineTag, class T1, class Op>! const Field<Mesh, T, EngineTag> &! assign(const Field<Mesh, T, EngineTag> &lhs,          const T1 &rhs, const Op &op);  *************** assign(const Field<MeshTag, T, EngineTag*** 144,149 ****  struct SubFieldViewFunctorTag;  ! template<class MeshTag, class T, class EngineTag>! class SubFieldView<Field<MeshTag, T, EngineTag> > {      public:--- 144,149 ----  struct SubFieldViewFunctorTag;  ! template<class Mesh, class T, class EngineTag>! class SubFieldView<Field<Mesh, T, EngineTag> > {      public:*************** public:*** 151,155 ****    // Use it to construct the output field type.  !   typedef Field<MeshTag, T, EngineTag> Type_t;      // The function that actually creates the view.--- 151,155 ----    // Use it to construct the output field type.  !   typedef Field<Mesh, T, EngineTag> Type_t;      // The function that actually creates the view.*************** public:*** 185,190 ****  };  ! template<class MeshTag, class T, class Expr>! class SubFieldView<Field<MeshTag, T, ExpressionTag<Expr> > > {      public:--- 185,190 ----  };  ! template<class Mesh, class T, class Expr>! class SubFieldView<Field<Mesh, T, ExpressionTag<Expr> > > {      public:*************** public:*** 192,200 ****    // Use it to construct the output field type.  !   typedef Field<MeshTag, T, ExpressionTag<Expr> > Subject_t;    typedef       typename ForEach<Expr, SubFieldViewFunctorTag, TreeCombine>::Type_t         Expr_t;!   typedef Field<MeshTag, T, ExpressionTag<Expr_t> > Type_t;      // The function that actually creates the view.--- 192,200 ----    // Use it to construct the output field type.  !   typedef Field<Mesh, T, ExpressionTag<Expr> > Subject_t;    typedef       typename ForEach<Expr, SubFieldViewFunctorTag, TreeCombine>::Type_t         Expr_t;!   typedef Field<Mesh, T, ExpressionTag<Expr_t> > Type_t;      // The function that actually creates the view.*************** public:*** 242,251 ****  // Single-valued version. Handles scalars and Locs.  ! template<class MeshTag, class T, class EngineTag, class Domain>! struct View1Implementation<Field<MeshTag, T, EngineTag>, Domain, true>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // The return types are pretty simple here.--- 242,251 ----  // Single-valued version. Handles scalars and Locs.  ! template<class Mesh, class T, class EngineTag, class Domain>! struct View1Implementation<Field<Mesh, T, EngineTag>, Domain, true>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // The return types are pretty simple here.*************** struct View1Implementation<Field<MeshTag*** 358,362 ****  // an INode.  ! template<int Dim, class MeshTag, class Domain>  struct NewMeshTag  {--- 358,362 ----  // an INode.  ! template<int Dim, class Mesh, class Domain>  struct NewMeshTag  {*************** struct NewMeshTag*** 364,385 ****  };  ! template<int Dim, class MeshTag>! struct NewMeshTag<Dim, MeshTag, Interval<Dim> >  {!   typedef MeshTag Type_t;  };  ! template<int Dim, class MeshTag>! struct NewMeshTag<Dim, MeshTag, INode<Dim> >  {!   typedef MeshTag Type_t;  };  ! template<class MeshTag, class T, class EngineTag, class Domain>! struct View1Implementation<Field<MeshTag, T, EngineTag>, Domain, false>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // Deduce domains for the output type.--- 364,385 ----  };  ! template<int Dim, class Mesh>! struct NewMeshTag<Dim, Mesh, Interval<Dim> >  {!   typedef Mesh Type_t;  };  ! template<int Dim, class Mesh>! struct NewMeshTag<Dim, Mesh, INode<Dim> >  {!   typedef Mesh Type_t;  };  ! template<class Mesh, class T, class EngineTag, class Domain>! struct View1Implementation<Field<Mesh, T, EngineTag>, Domain, false>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // Deduce domains for the output type.*************** struct View1Implementation<Field<MeshTag*** 390,397 ****    typedef typename NewEngine_t::Tag_t NewEngineTag_t;    !   // Deduce the new MeshTag.        typedef typename!     NewMeshTag<NewEngine_t::dimensions, MeshTag, Domain>::Type_t         NewMeshTag_t;    --- 390,397 ----    typedef typename NewEngine_t::Tag_t NewEngineTag_t;    !   // Deduce the new Mesh.        typedef typename!     NewMeshTag<NewEngine_t::dimensions, Mesh, Domain>::Type_t         NewMeshTag_t;    *************** template<class Subject, class Domain, bo*** 486,495 ****  struct AltView1Implementation;  ! template<class MeshTag, class T, class EngineTag, class Domain>! struct AltView1Implementation<Field<MeshTag, T, EngineTag>, Domain, true>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // The return types are pretty simple here.--- 486,495 ----  struct AltView1Implementation;  ! template<class Mesh, class T, class EngineTag, class Domain>! struct AltView1Implementation<Field<Mesh, T, EngineTag>, Domain, true>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // The return types are pretty simple here.*************** struct AltView1Implementation<Field<Mesh*** 499,508 ****  };  ! template<class MeshTag, class T, class EngineTag, class Domain>! struct AltView1Implementation<Field<MeshTag, T, EngineTag>, Domain, false>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // Deduce domains for the output type.--- 499,508 ----  };  ! template<class Mesh, class T, class EngineTag, class Domain>! struct AltView1Implementation<Field<Mesh, T, EngineTag>, Domain, false>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // Deduce domains for the output type.*************** struct AltView1Implementation<Field<Mesh*** 513,520 ****    typedef typename NewEngine_t::Tag_t NewEngineTag_t;    !   // Deduce the new MeshTag.        typedef typename!     NewMeshTag<NewEngine_t::dimensions, MeshTag, Domain>::Type_t         NewMeshTag_t;    --- 513,520 ----    typedef typename NewEngine_t::Tag_t NewEngineTag_t;    !   // Deduce the new Mesh.        typedef typename!     NewMeshTag<NewEngine_t::dimensions, Mesh, Domain>::Type_t         NewMeshTag_t;    *************** struct AltView1Implementation<Field<Mesh*** 532,541 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag, class Sub1>! struct View1<Field<MeshTag, T, EngineTag>, Sub1>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // Deduce domains for the output type.--- 532,541 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag, class Sub1>! struct View1<Field<Mesh, T, EngineTag>, Sub1>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // Deduce domains for the output type.*************** struct View1<Field<MeshTag, T, EngineTag*** 583,592 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag>! struct View1<Field<MeshTag, T, EngineTag>, int>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // The return types.--- 583,592 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag>! struct View1<Field<Mesh, T, EngineTag>, int>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // The return types.*************** template<class FieldTag, class DomainTag*** 634,643 ****  struct AltView1;  ! template<class MeshTag, class T, class EngineTag, class Sub1>! struct AltView1<Field<MeshTag, T, EngineTag>, Sub1>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // Deduce domains for the output type.--- 634,643 ----  struct AltView1;  ! template<class Mesh, class T, class EngineTag, class Sub1>! struct AltView1<Field<Mesh, T, EngineTag>, Sub1>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // Deduce domains for the output type.*************** struct AltView1<Field<MeshTag, T, Engine*** 673,682 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag>! struct AltView1<Field<MeshTag, T, EngineTag>, int>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // The return types.--- 673,682 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag>! struct AltView1<Field<Mesh, T, EngineTag>, int>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // The return types.*************** struct AltView1<Field<MeshTag, T, Engine*** 693,703 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag,     class Sub1, class Sub2>! struct View2<Field<MeshTag, T, EngineTag>, Sub1, Sub2>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // Deduce domains for the output type.--- 693,703 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag,     class Sub1, class Sub2>! struct View2<Field<Mesh, T, EngineTag>, Sub1, Sub2>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // Deduce domains for the output type.*************** struct View2<Field<MeshTag, T, EngineTag*** 742,751 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag>! struct View2<Field<MeshTag, T, EngineTag>, int, int>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // The return types.--- 742,751 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag>! struct View2<Field<Mesh, T, EngineTag>, int, int>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // The return types.*************** struct View2<Field<MeshTag, T, EngineTag*** 787,792 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag, int Dim>! struct View2<Field<MeshTag, T, EngineTag>,               FieldOffset<Dim>,               Loc<Dim> >--- 787,792 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag, int Dim>! struct View2<Field<Mesh, T, EngineTag>,               FieldOffset<Dim>,               Loc<Dim> >*************** struct View2<Field<MeshTag, T, EngineTag*** 794,798 ****    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // The field's dimension (i.e., the number of indices required to select a point).--- 794,798 ----    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // The field's dimension (i.e., the number of indices required to select a point).*************** struct View2<Field<MeshTag, T, EngineTag*** 860,870 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag,     class Sub1, class Sub2, class Sub3>! struct View3<Field<MeshTag, T, EngineTag>, Sub1, Sub2, Sub3>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // Deduce domains for the output type.--- 860,870 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag,     class Sub1, class Sub2, class Sub3>! struct View3<Field<Mesh, T, EngineTag>, Sub1, Sub2, Sub3>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // Deduce domains for the output type.*************** struct View3<Field<MeshTag, T, EngineTag*** 911,920 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag>! struct View3<Field<MeshTag, T, EngineTag>, int, int, int>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;    --- 911,920 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag>! struct View3<Field<Mesh, T, EngineTag>, int, int, int>  {    // Convenience typedef for the thing we're taking a view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;    *************** struct View3<Field<MeshTag, T, EngineTag*** 958,971 ****  template<class Subject> struct Patch;  ! template<class MeshTag, class T, class EngineTag>! struct Patch<Field<MeshTag, T, EngineTag> >  {!   typedef Field<MeshTag, T, EngineTag> Subject_t;    typedef typename Subject_t::Engine_t OldEngine_t;    typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;  !   // We've assumed that MeshTag and T are the same for the patch engine.  !   typedef Field<MeshTag, T, typename Engine_t::Tag_t> Type_t;      enum { dim = OldEngine_t::dimensions };--- 958,971 ----  template<class Subject> struct Patch;  ! template<class Mesh, class T, class EngineTag>! struct Patch<Field<Mesh, T, EngineTag> >  {!   typedef Field<Mesh, T, EngineTag> Subject_t;    typedef typename Subject_t::Engine_t OldEngine_t;    typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;  !   // We've assumed that Mesh and T are the same for the patch engine.  !   typedef Field<Mesh, T, typename Engine_t::Tag_t> Type_t;      enum { dim = OldEngine_t::dimensions };*************** struct Patch<Field<MeshTag, T, EngineTag*** 980,993 ****  };  ! template<class MeshTag, class T, class LTag, class EngineTag>! struct Patch<Field<MeshTag, T, MultiPatch<LTag, EngineTag> > >  {!   typedef Field<MeshTag, T, MultiPatch<LTag, EngineTag> > Subject_t;    typedef typename Subject_t::Engine_t OldEngine_t;    typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;  !   // We've assumed that MeshTag and T are the same for the patch engine.  !   typedef Field<MeshTag, T, typename Engine_t::Tag_t> Type_t;      enum { dim = OldEngine_t::dimensions };--- 980,993 ----  };  ! template<class Mesh, class T, class LTag, class EngineTag>! struct Patch<Field<Mesh, T, MultiPatch<LTag, EngineTag> > >  {!   typedef Field<Mesh, T, MultiPatch<LTag, EngineTag> > Subject_t;    typedef typename Subject_t::Engine_t OldEngine_t;    typedef typename EngineFunctor<OldEngine_t, EnginePatch>::Type_t Engine_t;  !   // We've assumed that Mesh and T are the same for the patch engine.  !   typedef Field<Mesh, T, typename Engine_t::Tag_t> Type_t;      enum { dim = OldEngine_t::dimensions };*************** private:*** 1028,1037 ****  };  ! template<class Components, class MeshTag, class T, class EngineTag>! struct ComponentView<Components, Field<MeshTag, T, EngineTag> >  {    // Convenience typedef for the thing we're taking a component view of.    !   typedef Field<MeshTag, T, EngineTag> Subject_t;      // Deduce the template parameters for the output type.--- 1028,1037 ----  };  ! template<class Components, class Mesh, class T, class EngineTag>! struct ComponentView<Components, Field<Mesh, T, EngineTag> >  {    // Convenience typedef for the thing we're taking a component view of.    !   typedef Field<Mesh, T, EngineTag> Subject_t;      // Deduce the template parameters for the output type.*************** struct ComponentView<Components, Field<M*** 1044,1048 ****    // The output type.    !   typedef Field<MeshTag, NewT_t, NewEngineTag_t> Type_t;      // A function that creates the view.--- 1044,1048 ----    // The output type.    !   typedef Field<Mesh, NewT_t, NewEngineTag_t> Type_t;      // A function that creates the view.*************** struct ComponentView<Components, Field<M*** 1060,1064 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag,            class T = POOMA_DEFAULT_ELEMENT_TYPE,           class EngineTag = POOMA_DEFAULT_ENGINE_TYPE>--- 1060,1064 ----  //-----------------------------------------------------------------------------  ! template<class Mesh,            class T = POOMA_DEFAULT_ELEMENT_TYPE,           class EngineTag = POOMA_DEFAULT_ENGINE_TYPE>*************** public:*** 1071,1076 ****    // The specification type.    !   typedef MeshTag MeshTag_t;!   typedef MeshTag Mesh_t;      // The type.--- 1071,1076 ----    // The specification type.    !   typedef Mesh MeshTag_t;!   typedef Mesh Mesh_t;      // The type.*************** public:*** 1084,1092 ****    // This class.    !   typedef Field<MeshTag, T, EngineTag> This_t;        // The field engine type.    !   typedef FieldEngine<MeshTag, T, EngineTag> FieldEngine_t;        // The dimension (i.e., the number of indices required to select a point).--- 1084,1092 ----    // This class.    !   typedef Field<Mesh, T, EngineTag> This_t;        // The field engine type.    !   typedef FieldEngine<Mesh, T, EngineTag> FieldEngine_t;        // The dimension (i.e., the number of indices required to select a point).*************** public:*** 1119,1123 ****    // User-callable constructors. These ctors are meant to be called by users.  !   // MeshTag/centering/layout constructors. We use the specified mesh     // object to initialize our mesh and the layout to initialize     // the engines. Clearly, these must be synchronized. This is appropriate --- 1119,1123 ----    // User-callable constructors. These ctors are meant to be called by users.  !   // Mesh/centering/layout constructors. We use the specified mesh     // object to initialize our mesh and the layout to initialize     // the engines. Clearly, these must be synchronized. This is appropriate *************** public:*** 1129,1133 ****      // This version is used for expressions.-   // FIXME: perhaps it should be more specific.      template<class I1>  --- 1129,1132 ----*************** public:*** 1186,1195 ****      template<class ET2>!   Field(const Field<MeshTag, T, ET2> &model, int m, int c)      : fieldEngine_m(model.fieldEngine(), m, c)    { }      template<class ET2>!   Field(int c, const Field<MeshTag, T, ET2> &model)      : fieldEngine_m(c, model.fieldEngine())    { }--- 1185,1194 ----      template<class ET2>!   Field(const Field<Mesh, T, ET2> &model, int m, int c)      : fieldEngine_m(model.fieldEngine(), m, c)    { }      template<class ET2>!   Field(int c, const Field<Mesh, T, ET2> &model)      : fieldEngine_m(c, model.fieldEngine())    { }*************** public:*** 1209,1212 ****--- 1208,1216 ----      }  +   inline Engine_t &engine()+     {+       return fieldEngine_m.engine();+     }+     inline const FieldEngine_t &fieldEngine() const      {*************** public:*** 1219,1223 ****      }      -   // FIXME: This function is deprecated.    inline int numSubFields() const      {--- 1223,1226 ----*************** public:*** 1229,1232 ****--- 1232,1240 ----      return fieldEngine().centering();    }+         +   const Centering<dimensions> centering(int c) const+   {+     return fieldEngine().centering()[c];+   }      inline int centeringSize() const*************** public:*** 1419,1423 ****    //---------------------------------------------------------------------------    // Component-forwarding functions. These work quite similarly to the!   // ones from Array except we produce a Field with the same MeshTag.      inline typename ComponentView<Loc<1>, This_t>::Type_t--- 1427,1431 ----    //---------------------------------------------------------------------------    // Component-forwarding functions. These work quite similarly to the!   // ones from Array except we produce a Field with the same Mesh.      inline typename ComponentView<Loc<1>, This_t>::Type_t*************** struct AssignOpReadWriteTraits<OpAssign>*** 1653,1658 ****  //----------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag, int Dim>! struct LeafFunctor<Field<MeshTag, T, EngineTag>, ConformTag<Dim> >  {    typedef bool Type_t;--- 1661,1666 ----  //----------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag, int Dim>! struct LeafFunctor<Field<Mesh, T, EngineTag>, ConformTag<Dim> >  {    typedef bool Type_t;*************** struct LeafFunctor<Field<MeshTag, T, Eng*** 1668,1672 ****        return false;      }!   static Type_t apply(const Field<MeshTag, T, EngineTag> &f,      const ConformTag<Dim> &ct)      {--- 1676,1680 ----        return false;      }!   static Type_t apply(const Field<Mesh, T, EngineTag> &f,      const ConformTag<Dim> &ct)      {*************** struct LeafFunctor<Field<MeshTag, T, Eng*** 1683,1691 ****  //----------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag, class RequestType>! struct LeafFunctor<Field<MeshTag, T, EngineTag>,    DataObjectRequest<RequestType> >  {!   typedef Field<MeshTag, T, EngineTag> Subject_t;    typedef typename Subject_t::FieldEngine_t FieldEngine_t;    typedef LeafFunctor<FieldEngine_t, DataObjectRequest<RequestType> > --- 1691,1699 ----  //----------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag, class RequestType>! struct LeafFunctor<Field<Mesh, T, EngineTag>,    DataObjectRequest<RequestType> >  {!   typedef Field<Mesh, T, EngineTag> Subject_t;    typedef typename Subject_t::FieldEngine_t FieldEngine_t;    typedef LeafFunctor<FieldEngine_t, DataObjectRequest<RequestType> > *************** struct LeafFunctor<Field<MeshTag, T, Eng*** 1702,1715 ****  };  ! template<class MeshTag, class T, class EngineTag, class RequestType>! struct LeafFunctor<FieldEngine<MeshTag, T, EngineTag>,    DataObjectRequest<RequestType> >  {!   typedef typename FieldEngine<MeshTag, T, EngineTag>::Engine_t       Engine_t;    enum { dataObject = Engine_t::dataObject };    typedef typename DataObjectRequest<RequestType>::Type_t Type_t;    inline static!   Type_t apply(const FieldEngine<MeshTag, T, EngineTag> &f,  	           const DataObjectRequest<RequestType> &functor)      {--- 1710,1723 ----  };  ! template<class Mesh, class T, class EngineTag, class RequestType>! struct LeafFunctor<FieldEngine<Mesh, T, EngineTag>,    DataObjectRequest<RequestType> >  {!   typedef typename FieldEngine<Mesh, T, EngineTag>::Engine_t       Engine_t;    enum { dataObject = Engine_t::dataObject };    typedef typename DataObjectRequest<RequestType>::Type_t Type_t;    inline static!   Type_t apply(const FieldEngine<Mesh, T, EngineTag> &f,  	           const DataObjectRequest<RequestType> &functor)      {*************** struct LeafFunctor<FieldEngine<MeshTag, *** 1724,1733 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag>! struct LeafFunctor<Field<MeshTag, T, EngineTag>, DomainFunctorTag>  {!   typedef typename Field<MeshTag, T, EngineTag>::Domain_t Type_t;  !   inline static Type_t apply(const Field<MeshTag, T, EngineTag> &f,       const DomainFunctorTag &)      {--- 1732,1741 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag>! struct LeafFunctor<Field<Mesh, T, EngineTag>, DomainFunctorTag>  {!   typedef typename Field<Mesh, T, EngineTag>::Domain_t Type_t;  !   inline static Type_t apply(const Field<Mesh, T, EngineTag> &f,       const DomainFunctorTag &)      {*************** struct LeafFunctor<Field<MeshTag, T, Eng*** 1746,1753 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag, class Tag>! struct LeafFunctor<Field<MeshTag, T, EngineTag>, ExpressionApply<Tag> >  {!   typedef Field<MeshTag, T, EngineTag> Subject_t;    typedef typename Subject_t::FieldEngine_t FieldEngine_t;    typedef LeafFunctor<FieldEngine_t, ExpressionApply<Tag> > LeafFunctor_t;--- 1754,1761 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag, class Tag>! struct LeafFunctor<Field<Mesh, T, EngineTag>, ExpressionApply<Tag> >  {!   typedef Field<Mesh, T, EngineTag> Subject_t;    typedef typename Subject_t::FieldEngine_t FieldEngine_t;    typedef LeafFunctor<FieldEngine_t, ExpressionApply<Tag> > LeafFunctor_t;*************** struct LeafFunctor<Field<MeshTag, T, Eng*** 1762,1769 ****  };  ! template<class MeshTag, class T, class EngineTag, class Tag>! struct LeafFunctor<Field<MeshTag, T, EngineTag>, EngineView<Tag> >  {!   typedef Field<MeshTag, T, EngineTag> Subject_t;    typedef typename Subject_t::Engine_t Engine_t;    typedef typename LeafFunctor<Engine_t, EngineView<Tag> >::Type_t NewEngine_t;--- 1770,1777 ----  };  ! template<class Mesh, class T, class EngineTag, class Tag>! struct LeafFunctor<Field<Mesh, T, EngineTag>, EngineView<Tag> >  {!   typedef Field<Mesh, T, EngineTag> Subject_t;    typedef typename Subject_t::Engine_t Engine_t;    typedef typename LeafFunctor<Engine_t, EngineView<Tag> >::Type_t NewEngine_t;*************** struct LeafFunctor<Field<MeshTag, T, Eng*** 1773,1777 ****    // For now all EngineView operations are equivalent to Interval views.  !   typedef Field<MeshTag, T, NewEngineTag_t> Type_t;      inline static--- 1781,1785 ----    // For now all EngineView operations are equivalent to Interval views.  !   typedef Field<Mesh, T, NewEngineTag_t> Type_t;      inline static*************** struct LeafFunctor<Field<MeshTag, T, Eng*** 1788,1798 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag, class Tag>! struct LeafFunctor<Field<MeshTag, T, EngineTag>, EngineFunctorTag<Tag> >  {!   typedef typename Field<MeshTag,T,EngineTag>::Engine_t Engine_t;    typedef typename EngineFunctor<Engine_t,Tag>::Type_t Type_t;    inline static!   Type_t apply(const Field<MeshTag, T, EngineTag> &field,  	       const EngineFunctorTag<Tag> &tag)    {--- 1796,1806 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag, class Tag>! struct LeafFunctor<Field<Mesh, T, EngineTag>, EngineFunctorTag<Tag> >  {!   typedef typename Field<Mesh,T,EngineTag>::Engine_t Engine_t;    typedef typename EngineFunctor<Engine_t,Tag>::Type_t Type_t;    inline static!   Type_t apply(const Field<Mesh, T, EngineTag> &field,  	       const EngineFunctorTag<Tag> &tag)    {*************** struct LeafFunctor<Field<MeshTag, T, Eng*** 1806,1817 ****  //---------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag, class Tag>! struct EngineFunctor<Field<MeshTag, T, EngineTag>, Tag>  {!   typedef typename Field<MeshTag, T, EngineTag>::Engine_t Engine_t;    typedef typename EngineFunctor<Engine_t, Tag>::Type_t Type_t;      inline static !   Type_t apply(const Field<MeshTag, T, EngineTag> &field,  	           const Tag &tag)      {--- 1814,1825 ----  //---------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag, class Tag>! struct EngineFunctor<Field<Mesh, T, EngineTag>, Tag>  {!   typedef typename Field<Mesh, T, EngineTag>::Engine_t Engine_t;    typedef typename EngineFunctor<Engine_t, Tag>::Type_t Type_t;      inline static !   Type_t apply(const Field<Mesh, T, EngineTag> &field,  	           const Tag &tag)      {*************** struct EngineFunctor<Field<MeshTag, T, E*** 1826,1835 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag, int Dim>! struct LeafFunctor<Field<MeshTag, T, EngineTag>, EvalLeaf<Dim> >  {!   typedef typename Field<MeshTag, T, EngineTag>::Element_t Type_t;    inline static!   Type_t apply(const Field<MeshTag, T, EngineTag> &f,       const EvalLeaf<Dim> &t)       {--- 1834,1843 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag, int Dim>! struct LeafFunctor<Field<Mesh, T, EngineTag>, EvalLeaf<Dim> >  {!   typedef typename Field<Mesh, T, EngineTag>::Element_t Type_t;    inline static!   Type_t apply(const Field<Mesh, T, EngineTag> &f,       const EvalLeaf<Dim> &t)       {*************** struct LeafFunctor<Node, PerformUpdateTa*** 1874,1882 ****    ! template<class MeshTag, class T, class EngineTag>! struct LeafFunctor<Field<MeshTag, T, EngineTag>,     PerformUpdateTag>  {!   typedef Field<MeshTag, T, EngineTag> Subject_t;    typedef int Type_t;  --- 1882,1890 ----    ! template<class Mesh, class T, class EngineTag>! struct LeafFunctor<Field<Mesh, T, EngineTag>,     PerformUpdateTag>  {!   typedef Field<Mesh, T, EngineTag> Subject_t;    typedef int Type_t;  *************** struct LeafFunctor<Field<MeshTag, T, Eng*** 1889,1897 ****  };  ! template<class MeshTag, class T, class Expr>! struct LeafFunctor<Field<MeshTag, T, ExpressionTag<Expr> >,     PerformUpdateTag>  {!   typedef Field<MeshTag, T, ExpressionTag<Expr> > Subject_t;    typedef int Type_t;  --- 1897,1905 ----  };  ! template<class Mesh, class T, class Expr>! struct LeafFunctor<Field<Mesh, T, ExpressionTag<Expr> >,     PerformUpdateTag>  {!   typedef Field<Mesh, T, ExpressionTag<Expr> > Subject_t;    typedef int Type_t;  *************** struct LeafFunctor<Field<MeshTag, T, Exp*** 1910,1917 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag>! struct LeafFunctor<Field<MeshTag, T, EngineTag>, SubFieldViewFunctorTag>  {!   typedef Field<MeshTag, T, EngineTag> Type_t;  };  --- 1918,1925 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag>! struct LeafFunctor<Field<Mesh, T, EngineTag>, SubFieldViewFunctorTag>  {!   typedef Field<Mesh, T, EngineTag> Type_t;  };  *************** struct LeafFunctor<Scalar<T>, SubFieldVi*** 1930,1937 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag, class Domain>! struct LeafFunctor<Field<MeshTag, T, EngineTag>, ViewFunctorTag<Domain> >  {!   typedef typename View1<Field<MeshTag, T, EngineTag>, Domain>::Type_t       Type_t;  };--- 1938,1945 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag, class Domain>! struct LeafFunctor<Field<Mesh, T, EngineTag>, ViewFunctorTag<Domain> >  {!   typedef typename View1<Field<Mesh, T, EngineTag>, Domain>::Type_t       Type_t;  };*************** struct LeafFunctor<Field<MeshTag, T, Eng*** 1945,1951 ****  //-----------------------------------------------------------------------------  ! template <class MeshTag, class T, class EngineTag>  std::ostream &operator<<(std::ostream &o, !   const Field<MeshTag, T, EngineTag> &cf)  {    Pooma::blockAndEvaluate();--- 1953,1959 ----  //-----------------------------------------------------------------------------  ! template <class Mesh, class T, class EngineTag>  std::ostream &operator<<(std::ostream &o, !   const Field<Mesh, T, EngineTag> &cf)  {    Pooma::blockAndEvaluate();*************** std::ostream &operator<<(std::ostream &o*** 1954,1960 ****  }  ! template <class MeshTag, class T, class EngineTag>  std::fstream &operator<<(std::fstream &f, !   const Field<MeshTag, T, EngineTag> &cf)  {    Pooma::blockAndEvaluate();--- 1962,1968 ----  }  ! template <class Mesh, class T, class EngineTag>  std::fstream &operator<<(std::fstream &f, !   const Field<Mesh, T, EngineTag> &cf)  {    Pooma::blockAndEvaluate();*************** std::fstream &operator<<(std::fstream &f*** 1968,2000 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag,    int Dim2, class T2, class EngineTag2, class Op>! const Field<MeshTag, T, EngineTag> &! assign(const Field<MeshTag, T, EngineTag> &lhs,          const Array<Dim2, T2, EngineTag2> &rhs, const Op &op)  {!   int nsf = lhs.numSubFields();!   !   if (nsf != 0)!     {!       // We need to take sub-field views in order to get at all of the!       // internal fields.!       !       for (int i = 0; i < nsf; i++)!         assign(lhs[i], rhs, op);!     }!   else      {!       if (AssignOpReadWriteTraits<Op>::readLHS)!         lhs.applyRelations();!      !       // Evaluate.   !       Evaluator<MainEvaluatorTag>().evaluate(lhs, op, rhs);  !       // Having done the evaluation, we need to notify the LHS!       // that we've just written.    !       lhs.setDirty();      }          --- 1976,2003 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag,    int Dim2, class T2, class EngineTag2, class Op>! const Field<Mesh, T, EngineTag> &! assign(const Field<Mesh, T, EngineTag> &lhs,          const Array<Dim2, T2, EngineTag2> &rhs, const Op &op)  {!   for (int m = 0; m < lhs.numMaterials(); ++m)      {!       for (int c = 0; c < lhs.centeringSize(); ++c)!         {!           const Field<Mesh, T, EngineTag> &l = lhs.subField(m, c);  !           if (AssignOpReadWriteTraits<Op>::readLHS)!             l.applyRelations();!   !           // Evaluate.! !           Evaluator<MainEvaluatorTag>().evaluate(l, op, rhs);  !           // Having done the evaluation, we need to notify the LHS!           // that we've just written.    !           l.setDirty();!         }      }          *************** assign(const Field<MeshTag, T, EngineTag*** 2007,2040 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag,!   class MeshTag2, class T2, class EngineTag2, class Op>! const Field<MeshTag, T, EngineTag> &! assign(const Field<MeshTag, T, EngineTag> &lhs,!        const Field<MeshTag2, T2, EngineTag2> &rhs,         const Op &op)  {    for (int m = 0; m < lhs.numMaterials(); ++m)-   {-     for (int c = 0; c < lhs.centering().size(); ++ c)      {!       // We need to notify the RHS and, when not doing pure assignment, the!       // LHS that we are getting ready to read.!       !       forEach(rhs.subField(m, c), PerformUpdateTag(), NullCombine());!       !       if (AssignOpReadWriteTraits<Op>::readLHS)!         lhs.subField(m, c).applyRelations();    !       // Evaluate.  !       Evaluator<MainEvaluatorTag>().evaluate(lhs.subField(m, c), op,!                                              rhs.subField(m, c));  !       // Having done the evaluation, we need to notify the LHS!       // that we've just written.    !       lhs.subField(m, c).setDirty();      }-   }              return lhs;--- 2010,2043 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag,!   class Mesh2, class T2, class EngineTag2, class Op>! const Field<Mesh, T, EngineTag> &! assign(const Field<Mesh, T, EngineTag> &lhs,!        const Field<Mesh2, T2, EngineTag2> &rhs,         const Op &op)  {    for (int m = 0; m < lhs.numMaterials(); ++m)      {!       for (int c = 0; c < lhs.centeringSize(); ++c)!         {!           const Field<Mesh, T, EngineTag> &l = lhs.subField(m, c);!           const typename SubFieldView<Field<Mesh2, T2, EngineTag2> >::Type_t &r = !             rhs.subField(m, c);! !           forEach(r, PerformUpdateTag(), NullCombine());! !           if (AssignOpReadWriteTraits<Op>::readLHS)!             l.applyRelations();    !           // Evaluate.  !           Evaluator<MainEvaluatorTag>().evaluate(l, op, r);  !           // Having done the evaluation, we need to notify the LHS!           // that we've just written.    !           l.setDirty();!         }      }              return lhs;*************** assign(const Field<MeshTag, T, EngineTag*** 2046,2077 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class EngineTag, class T1, class Op>! const Field<MeshTag, T, EngineTag> &! assign(const Field<MeshTag, T, EngineTag> &lhs, const T1 &rhs,         const Op &op)  {    for (int m = 0; m < lhs.numMaterials(); ++m)-   {-     for (int c = 0; c < lhs.centering().size(); ++ c)      {!       if (AssignOpReadWriteTraits<Op>::readLHS)!         lhs.subField(m, c).applyRelations();  !       // Make an array out of the scalar.  !       typedef Field<MeshTag, T, EngineTag> LHS_t;!       Array<LHS_t::dimensions, T1, ConstantFunction>  rhsExpr(lhs.physicalDomain(c));!       rhsExpr.engine().setConstant(rhs);       !       // Evaluate.   !       Evaluator<MainEvaluatorTag>().evaluate(lhs.subField(m, c), op, rhsExpr);  !       // Having done the evaluation, we need to notify the LHS!       // that we've just written.    !       lhs.subField(m, c).setDirty();      }-   }              return lhs;--- 2049,2082 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class EngineTag, class T1, class Op>! const Field<Mesh, T, EngineTag> &! assign(const Field<Mesh, T, EngineTag> &lhs, const T1 &rhs,         const Op &op)  {    for (int m = 0; m < lhs.numMaterials(); ++m)      {!       for (int c = 0; c < lhs.centeringSize(); ++c)!         {!           const Field<Mesh, T, EngineTag> &l = lhs.subField(m, c);!       !           if (AssignOpReadWriteTraits<Op>::readLHS)!             l.applyRelations();  !           // Make an array out of the scalar.  !           typedef Field<Mesh, T, EngineTag> LHS_t;!           Array<LHS_t::dimensions, T1, ConstantFunction>  rhsExpr(l.physicalDomain());!           rhsExpr.engine().setConstant(rhs);       !           // Evaluate.   !           Evaluator<MainEvaluatorTag>().evaluate(l, op, rhsExpr);  !           // Having done the evaluation, we need to notify the LHS!           // that we've just written.    !           l.setDirty();!         }      }              return lhs;*************** assign(const Field<MeshTag, T, EngineTag*** 2086,2093 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class LTag>  inline double  compressedFraction(!   const Field<MeshTag, T, MultiPatch<LTag,CompressibleBrick> > &f)  {    PAssert(f.numSubFields() == 0);--- 2091,2098 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class LTag>  inline double  compressedFraction(!   const Field<Mesh, T, MultiPatch<LTag,CompressibleBrick> > &f)  {    PAssert(f.numSubFields() == 0);*************** compressedFraction(*** 2101,2111 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class LTag>  void! compress(Field<MeshTag, T, MultiPatch<LTag,CompressibleBrick> > &f)  {    for (int m = 0; m < f.numMaterials(); ++m)    {!     for (int c = 0; c < f.centering().size(); ++ c)      {        compress(f.fieldEngine().data(m, c).engine());--- 2106,2116 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class LTag>  void! compress(Field<Mesh, T, MultiPatch<LTag,CompressibleBrick> > &f)  {    for (int m = 0; m < f.numMaterials(); ++m)    {!     for (int c = 0; c < f.centeringSize(); ++c)      {        compress(f.fieldEngine().data(m, c).engine());*************** compress(Field<MeshTag, T, MultiPatch<LT*** 2120,2130 ****  //-----------------------------------------------------------------------------  ! template<class MeshTag, class T, class LTag>  void! uncompress(Field<MeshTag, T, MultiPatch<LTag,CompressibleBrick> > &f)  {    for (int m = 0; m < f.numMaterials(); ++m)    {!     for (int c = 0; c < f.centering().size(); ++ c)      {        uncompress(f.fieldEngine().data(m, c).engine());--- 2125,2135 ----  //-----------------------------------------------------------------------------  ! template<class Mesh, class T, class LTag>  void! uncompress(Field<Mesh, T, MultiPatch<LTag,CompressibleBrick> > &f)  {    for (int m = 0; m < f.numMaterials(); ++m)    {!     for (int c = 0; c < f.centeringSize(); ++c)      {        uncompress(f.fieldEngine().data(m, c).engine());Index: NewField/FieldCentering.h===================================================================RCS file: /home/pooma/Repository/r2/src/NewField/Attic/FieldCentering.h,vretrieving revision 1.1.2.10diff -p -c -2 -r1.1.2.10 FieldCentering.h*** NewField/FieldCentering.h	2001/08/21 17:08:38	1.1.2.10--- NewField/FieldCentering.h	2001/08/29 16:39:16*************** std::ostream &operator<<(std::ostream &o*** 463,467 ****                           const Centering<Dim> &centering)  {-   o << "Centering: (";    switch (centering.centeringType())    {--- 463,466 ----*************** std::ostream &operator<<(std::ostream &o*** 490,494 ****        o << ",";    }!   o << "})";      return o;--- 489,493 ----        o << ",";    }!   o << "}";      return o;Index: NewField/PrintField.h===================================================================RCS file: /home/pooma/Repository/r2/src/NewField/PrintField.h,vretrieving revision 1.3.2.2diff -p -c -2 -r1.3.2.2 PrintField.h*** NewField/PrintField.h	2001/08/28 21:39:34	1.3.2.2--- NewField/PrintField.h	2001/08/29 16:39:16*************** class PrintField;*** 111,115 ****  //   - change setting with "setSpacing(int newval)"  //! // PRINTING FIELDE OBJECTS WITH A PrintField:  // -----------------------------------------  // PrintField is not templated, so that you can reuse the same formatter--- 111,115 ----  //   - change setting with "setSpacing(int newval)"  //! // PRINTING FIELD OBJECTS WITH A PrintField:  // -----------------------------------------  // PrintField is not templated, so that you can reuse the same formatter*************** struct PerformPrintField<S, A, 1>*** 171,175 ****    //-----------------------------------------------------------------------------! // PrintAarry class declaration  //-----------------------------------------------------------------------------  --- 171,175 ----    //-----------------------------------------------------------------------------! // PrintField class declaration  //-----------------------------------------------------------------------------  *************** public:*** 232,246 ****        a.applyRelations();        Pooma::blockAndEvaluate();!       !       for (int m = 0; m < a.numMaterials(); ++m)!       {!         s << "material #" << m << ":\n"<< "-------------\n";!         for (int c = 0; c < a.centering().size(); ++ c)!         {!           s << "centering #" << c << " " << a.centering()[c]!             << ":\n"<< "-----------------\n";!           PerformPrintField<S,A,A::dimensions>::print(*this, s, a.subField(m, c));!         }!       }      }      --- 232,243 ----        a.applyRelations();        Pooma::blockAndEvaluate();! !       for (int m = 0; m < a.numMaterials(); m++)!         for (int c = 0; c < a.centeringSize(); c++)!           {!             s << "Material #" << m << ", Centering #" << c << " " << a.centering(c) !               << "\n"<< "-------------\n";!             PerformPrintField<S,A,A::dimensions>::print(*this, s, a.subField(m, c));!           }      }      Index: NewField/Mesh/NoMesh.h===================================================================RCS file: /home/pooma/Repository/r2/src/NewField/Mesh/Attic/NoMesh.h,vretrieving revision 1.1.2.2diff -p -c -2 -r1.1.2.2 NoMesh.h*** NewField/Mesh/NoMesh.h	2001/08/23 23:01:22	1.1.2.2--- NewField/Mesh/NoMesh.h	2001/08/29 16:39:14****************** 41,44 ****--- 41,47 ----  #include "Domain/Interval.h"          // NoMeshData<> class member  #include "Domain/Shrink.h"            // shrinkRight() in NoMeshData<> ctor+ #include "Layout/INode.h"             // Used in ctors+ #include "NewField/FieldEngine/FieldEnginePatch.h" +                                       // Used in ctors  #include "Utilities/RefCountedPtr.h"  // Reference counting used  #include "Utilities/RefCounted.h"     // Reference counting used*************** public:*** 57,67 ****    // Constructors.  !   // We do not provide a default constructor because we want construction to be!   // an atomic operation.!   //!   //   NoMeshData() { }      // This constructor fully constructs the object. It uses the layout to set    // up the appropriate domains.      template<class Layout>  --- 60,75 ----    // Constructors.  !   // We provide a default constructor that creates the object with empty!   // domains. To be useful, this object must be replaced by another version !   // via assignment.!   !   NoMeshData() !     { !     }      // This constructor fully constructs the object. It uses the layout to set    // up the appropriate domains.+   //+   // The Layout supplied must refer to VERTEX positions.      template<class Layout>  *************** public:*** 72,76 ****      totalCellDomain_m(shrinkRight(totalVertexDomain_m, 1))      {-       // This space intentionally left blank.      }      --- 80,83 ----*************** public:*** 83,93 ****      totalCellDomain_m(model.totalCellDomain_m)      {-       // This space intentionally left blank.      }      !   // View constructor. For now, we support interval views only and!   // simply make the zero-based total domain == physical domain.    !   NoMeshData(const NoMeshData<Dim> &, const Interval<Dim> &d)    : physicalVertexDomain_m(d - d.firsts()),      physicalCellDomain_m(shrinkRight(physicalVertexDomain_m, 1)),--- 90,103 ----      totalCellDomain_m(model.totalCellDomain_m)      {      }      !   // View constructors.     !   // Interval view. For now, we simply make the zero-based !   // total domain == physical domain.!   //!   // The Interval supplied must refer to VERTEX positions.!   !   NoMeshData(const Interval<Dim> &d)    : physicalVertexDomain_m(d - d.firsts()),      physicalCellDomain_m(shrinkRight(physicalVertexDomain_m, 1)),*************** public:*** 95,99 ****      totalCellDomain_m(shrinkRight(totalVertexDomain_m, 1))      {!       // This space intentionally left blank.      }    --- 105,120 ----      totalCellDomain_m(shrinkRight(totalVertexDomain_m, 1))      {!     }!     !   // FieldEnginePatch constructor.!   //!   // The FieldEnginePatch supplied must refer to VERTEX positions.! !   NoMeshData(const NoMeshData<Dim> &model, const FieldEnginePatch<Dim> &p)!   : physicalVertexDomain_m(p.domain_m),!     physicalCellDomain_m(shrinkRight(physicalVertexDomain_m, 1)),!     totalVertexDomain_m(p.domain_m),!     totalCellDomain_m(shrinkRight(totalVertexDomain_m, 1))!     {      }    *************** public:*** 174,205 ****      //---------------------------------------------------------------------------  !   NoMesh() { }      // This constructor fully constructs the object using the layout to    // compute domains.        template<class Layout>!   explicit NoMesh(const Layout &layout)    : data_m(new NoMeshData<Dim>(layout))      { -       // This space intentionally left blank.      }          // Copy constructor.     !   NoMesh(const NoMesh<Dim> &model)    : data_m(model.data_m)      {!       // This space intentionally left blank.      }      !   // View constructor.     !   NoMesh(const NoMesh<Dim> &model, const Interval<Dim> &d)!   : data_m(new NoMeshData<Dim>(*model.data_m, d))      {!       // This space intentionally left blank.      }      //------------------------------------------------------------------------------ 195,270 ----      //---------------------------------------------------------------------------+   // Constructors.  !   // We provide a default constructor that creates the object with empty!   // domains. To be useful, this object must be replaced by another version !   // via assignment.!   !   inline NoMesh() !   : data_m(new NoMeshData<Dim>)!     { !     }      // This constructor fully constructs the object using the layout to    // compute domains.+   //+   // The Layout supplied must refer to VERTEX positions.        template<class Layout>!   inline explicit NoMesh(const Layout &layout)    : data_m(new NoMeshData<Dim>(layout))      {       }          // Copy constructor.     !   inline NoMesh(const NoMesh<Dim> &model)    : data_m(model.data_m)      {!     }!     !   // View constructors. !   !   // Interval view.!   //!   // The Interval supplied must refer to VERTEX positions.!   !   inline NoMesh(const NoMesh<Dim> &model, const Interval<Dim> &d)!   : data_m(new NoMeshData<Dim>(d))!     {!     }!   !   // INode view.!   //!   // The INode supplied must refer to VERTEX positions.!   !   NoMesh(const NoMesh<Dim> &model, const INode<Dim> &i)!   : data_m(new NoMeshData<Dim>(i.domain()))!     {!     }!   !   // FieldEnginePatch view.!   //!   // The FieldEnginePatch supplied must refer to VERTEX positions.!   !   inline NoMesh(const NoMesh<Dim> &model, const FieldEnginePatch<Dim> &p)!   : data_m(new NoMeshData<Dim>(*model.data_m, p))!     {      }      !   // General view. Made, for instance, by taking a Range-view of some!   // other mesh.!   //!   // The Domain supplied must refer to VERTEX positions.    !   template<class Mesh, class Domain>!   inline NoMesh(const Mesh &, const Domain &d)      {!       Interval<Dim> dom;!       for (int i = 0; i < Dim; i++)!         dom[i] = d[i].size();!       data_m = new NoMeshData<Dim>(dom);      }+         //---------------------------------------------------------------------------*************** public:*** 208,211 ****--- 273,290 ----        ~NoMesh() { }+ +   //---------------------------------------------------------------------------+   // Copy assignment operator.+   +   NoMesh<Dim> &+   operator=(const NoMesh<Dim> &rhs)+     {+       if (&rhs != this)+         {+           data_m = rhs.data_m;+         }+       +       return *this;+     }        //---------------------------------------------------------------------------Index: NewField/Mesh/UniformRectilinearMesh.h===================================================================RCS file: /home/pooma/Repository/r2/src/NewField/Mesh/Attic/UniformRectilinearMesh.h,vretrieving revision 1.1.2.6diff -p -c -2 -r1.1.2.6 UniformRectilinearMesh.h*** NewField/Mesh/UniformRectilinearMesh.h	2001/08/23 23:01:22	1.1.2.6--- NewField/Mesh/UniformRectilinearMesh.h	2001/08/29 16:39:14****************** 42,50 ****  //-----------------------------------------------------------------------------  ! #include "Engine/ConstantFunctionEngine.h" // Used in functors! #include "Engine/IndexFunctionEngine.h"    // Used in functors! #include "NewField/Mesh/NoMesh.h"          // Base class! #include "NewField/FieldCentering.h"       // Centering<Dim> used inline! #include "Tiny/Vector.h"                   // Class member    //-------------------------------------------------------------------------------- 42,52 ----  //-----------------------------------------------------------------------------  ! #include "Engine/ConstantFunctionEngine.h"         // Used in functors! #include "Engine/IndexFunctionEngine.h"            // Used in functors! #include "Layout/INode.h"                          // Used in ctors! #include "NewField/FieldEngine/FieldEnginePatch.h" // Used in ctors! #include "NewField/Mesh/NoMesh.h"                  // Base class! #include "NewField/FieldCentering.h"               // Centering<Dim> inline! #include "Tiny/Vector.h"                           // Class member    //-----------------------------------------------------------------------------*************** public:*** 61,72 ****    // Constructors.  !   // We do not provide a default constructor because we want construction to be!   // an atomic operation.!   //!   //   UniformRectilinearMeshData() { }      // This constructor fully constructs the object. It uses the layout to    // compute domains and also initializes the origin and the spacings in each!   // coordinate direction.      template<class Layout>  --- 63,79 ----    // Constructors.  !   // We provide a default constructor that creates the object with empty!   // domains and. To be useful, this object must be replaced by another !   // version via assignment.!   !   UniformRectilinearMeshData()!     { !       // This space intentionally left blank.!     }      // This constructor fully constructs the object. It uses the layout to    // compute domains and also initializes the origin and the spacings in each!   // coordinate direction. The indices in the layout refer to VERTEX!   // positions.      template<class Layout>  *************** public:*** 79,83 ****      spacings_m(spacings)      {-       // This space intentionally left blank.      }      --- 86,89 ----*************** public:*** 92,104 ****      }       !   // View constructor. We only handle the case here where we are taking!   // an interval-view. This means that we simply need to adjust the    // origin by the amount the view is offset from the model's physical    // cell domain. We rely on the base class to do the heavy lifting    // with respect to figuring out the domains correctly.        UniformRectilinearMeshData(const UniformRectilinearMeshData<Dim, T> &model,                                const Interval<Dim> &d)!   : NoMeshData<Dim>(model, d),      origin_m(model.origin_m),      spacings_m(model.spacings_m)--- 98,113 ----      }       !   // View constructors.!   !   // Interval view. This means that we simply need to adjust the    // origin by the amount the view is offset from the model's physical    // cell domain. We rely on the base class to do the heavy lifting    // with respect to figuring out the domains correctly.+   //+   // The Interval supplied must refer to VERTEX positions.        UniformRectilinearMeshData(const UniformRectilinearMeshData<Dim, T> &model,                                const Interval<Dim> &d)!   : NoMeshData<Dim>(d),      origin_m(model.origin_m),      spacings_m(model.spacings_m)*************** public:*** 110,113 ****--- 119,136 ----      }    +   // FieldEnginePatch view. We don't fiddle with the origin because we are not+   // making the domain zero-based.+   //+   // The domain supplied by the FieldEnginePatch must refer to VERTEX+   // positions.+   +   UniformRectilinearMeshData(const UniformRectilinearMeshData<Dim, T> &model, +                              const FieldEnginePatch<Dim> &p)+   : NoMeshData<Dim>(model, p),+     origin_m(model.origin_m),+     spacings_m(model.spacings_m)+     {+     }+       //---------------------------------------------------------------------------    // Copy assignment operator.*************** public:*** 188,223 ****      //---------------------------------------------------------------------------! !   UniformRectilinearMesh() { }      // This constructor fully constructs the object. It uses the layout to    // compute domains and also initializes the origin and the spacings in each    // coordinate direction.        template<class Layout>!   UniformRectilinearMesh(const Layout &layout, !                          const PointType_t &origin,!                          const PointType_t &spacings)    : data_m(new UniformRectilinearMeshData<Dim, T>(layout, origin, spacings))      { -       // This space intentionally left blank.      }          // Copy constructor.     !   UniformRectilinearMesh(const UniformRectilinearMesh<Dim, T> &model)    : data_m(model.data_m)      {-       // This space intentionally left blank.      }      !   // View constructor.     !   UniformRectilinearMesh(const UniformRectilinearMesh<Dim, T> &model, !                          const Interval<Dim> &d)    : data_m(new UniformRectilinearMeshData<Dim, T>(*model.data_m, d))      {-       // This space intentionally left blank.      }      //------------------------------------------------------------------------------ 211,292 ----      //---------------------------------------------------------------------------!   // Constructors.!   !   // We supply a default constructor, but it doesn't generate a useful mesh.!   // This is accomplished through assignment.!   !   UniformRectilinearMesh() !   : data_m(new UniformRectilinearMeshData<Dim, T>)!     { !       // This space intentionally left blank.!     }      // This constructor fully constructs the object. It uses the layout to    // compute domains and also initializes the origin and the spacings in each    // coordinate direction.+   //+   // The Layout supplied must refer to VERTEX positions.        template<class Layout>!   inline UniformRectilinearMesh(const Layout &layout, !                                 const PointType_t &origin,!                                 const PointType_t &spacings)    : data_m(new UniformRectilinearMeshData<Dim, T>(layout, origin, spacings))      {       }          // Copy constructor.     !   inline UniformRectilinearMesh(const UniformRectilinearMesh<Dim, T> &model)    : data_m(model.data_m)      {      }      !   // View constructors. These are the only possible views of this!   // mesh. Other views will make a NoMesh.!   !   // Interval view.!   //!   // The Interval supplied must refer to VERTEX positions.    !   inline UniformRectilinearMesh(const UniformRectilinearMesh<Dim, T> &model, !                                 const Interval<Dim> &d)    : data_m(new UniformRectilinearMeshData<Dim, T>(*model.data_m, d))      {      }+   +   // INode view.+   //+   // The INode supplied must refer to VERTEX positions.+   +   inline UniformRectilinearMesh(const UniformRectilinearMesh<Dim, T> &model, +                                 const INode<Dim> &i)+   : data_m(new UniformRectilinearMeshData<Dim, T>(*model.data_m, i.domain()))+     {+     }+     +   // FieldEnginePatch view.+   //+   // The FieldEnginePatch supplied must refer to VERTEX positions.+   +   inline UniformRectilinearMesh(const UniformRectilinearMesh<Dim, T> &model, +                                 const FieldEnginePatch<Dim> &p)+   : data_m(new UniformRectilinearMeshData<Dim, T>(*model.data_m, p))+     {+     }+ +   //---------------------------------------------------------------------------+   // Copy assignment operator.+   +   inline UniformRectilinearMesh<Dim, T> &+   operator=(const UniformRectilinearMesh<Dim, T> &rhs)+     {+       if (&rhs != this)+         {+           data_m = rhs.data_m;+         }+       +       return *this;+     }      //---------------------------------------------------------------------------*************** public:*** 225,229 ****    // lifetime is correctly managed.    !   ~UniformRectilinearMesh() { }        //------------------------------------------------------------------------------ 294,300 ----    // lifetime is correctly managed.    !   ~UniformRectilinearMesh()!     {!     }        //---------------------------------------------------------------------------Index: NewField/Relations/RelationGroups.cmpl.cpp===================================================================RCS file: /home/pooma/Repository/r2/src/NewField/Relations/Attic/RelationGroups.cmpl.cpp,vretrieving revision 1.1.2.1diff -p -c -2 -r1.1.2.1 RelationGroups.cmpl.cpp*** NewField/Relations/RelationGroups.cmpl.cpp	2001/08/21 15:22:57	1.1.2.1--- NewField/Relations/RelationGroups.cmpl.cpp	2001/08/29 16:39:14****************** 31,34 ****--- 31,35 ----    #include "NewField/Relations/RelationGroups.h"+ #include "Pooma/Pooma.h"    namespace Pooma {*************** namespace Pooma {*** 48,69 ****    bool isRelationGroupActive(unsigned int groups)      {!         return (groups & activeGroups_g) != 0;      }          void activateRelationGroup(unsigned int group)      {!         activeGroups_g |= group;      }            void deactivateRelationGroup(unsigned int group)      {!         activeGroups_g &= ~group;      }            unsigned int newRelationGroup()      {!         unsigned int n = (1 << numGroups_g++);!         activateRelationGroup(n);!         return n;      }  --- 49,72 ----    bool isRelationGroupActive(unsigned int groups)      {!       return (groups & activeGroups_g) != 0;      }          void activateRelationGroup(unsigned int group)      {!       blockAndEvaluate();!       activeGroups_g |= group;      }            void deactivateRelationGroup(unsigned int group)      {!       blockAndEvaluate();!       activeGroups_g &= ~group;      }            unsigned int newRelationGroup()      {!       unsigned int n = (1 << numGroups_g++);!       activateRelationGroup(n);!       return n;      }  Index: NewField/Relations/Relations.h===================================================================RCS file: /home/pooma/Repository/r2/src/NewField/Relations/Attic/Relations.h,vretrieving revision 1.1.2.3diff -p -c -2 -r1.1.2.3 Relations.h*** NewField/Relations/Relations.h	2001/08/21 21:10:18	1.1.2.3--- NewField/Relations/Relations.h	2001/08/29 16:39:14*************** namespace Pooma {*** 1003,1017 ****    void newRelation(const RelationFunctor &f, const L &l)    {!     if (l.numSubFields() > 0)        {!         for (int i = 0; i < l.numSubFields(); i++)!           newRelation(f, l[i]);        }-     else-       {-         RelationListItem *r = new Relation0<L, RelationFunctor>(l, f);-         r->setPriority(RelationFunctorTraits<RelationFunctor>::defaultPriority);-         l.addRelation(r);-       }    }    --- 1003,1016 ----    void newRelation(const RelationFunctor &f, const L &l)    {!     for (int m = 0; m < l.numMaterials(); ++m)        {!         for (int c = 0; c < l.centeringSize(); ++c)!           {!             const L &lsub = l.subField(m, c);!             RelationListItem *r = new Relation0<L, RelationFunctor>(lsub, f);!             r->setPriority(RelationFunctorTraits<RelationFunctor>::defaultPriority);!             lsub.addRelation(r);!           }        }    }    *************** namespace Pooma {*** 1020,1035 ****                     const R1 &r1)    {!     if (l.numSubFields() > 0)        {!         for (int i = 0; i < l.numSubFields(); i++)!           newRelation(f, l[i], r1[i]);        }-     else-       {  -         r1.addRelation(new InfluenceRelation(l));-   -         RelationListItem *r = new Relation1<L, R1, RelationFunctor>(l, r1, f);-         l.addRelation(r);-       }    }    --- 1019,1037 ----                     const R1 &r1)    {!     for (int m = 0; m < l.numMaterials(); ++m)        {!         for (int c = 0; c < l.centeringSize(); ++c)!           {!             const L &lsub = l.subField(m, c);!             const R1 &r1sub = r1.subField(m, c);!             !             r1sub.addRelation(new InfluenceRelation(lsub));!   !             RelationListItem *r = new !               Relation1<L, R1, RelationFunctor>!                 (lsub, r1sub, f);!             lsub.addRelation(r);!           }        }    }    *************** namespace Pooma {*** 1038,1054 ****                     const R1 &r1, const R2 &r2)    {!     if (l.numSubFields() > 0)        {!         for (int i = 0; i < l.numSubFields(); i++)!           newRelation(f, l[i], r1[i], r2[i]);!       }!     else!       {  !         r1.addRelation(new InfluenceRelation(l));!         r2.addRelation(new InfluenceRelation(l));!   !         RelationListItem *r = !           new Relation2<L, R1, R2, RelationFunctor>(l, r1, r2, f);!         l.addRelation(r);        }    }--- 1040,1058 ----                     const R1 &r1, const R2 &r2)    {!     for (int m = 0; m < l.numMaterials(); ++m)        {!         for (int c = 0; c < l.centeringSize(); ++c)!           {!             const L &lsub = l.subField(m, c);!             const R1 &r1sub = r1.subField(m, c);!             const R2 &r2sub = r2.subField(m, c);!             !             r1sub.addRelation(new InfluenceRelation(lsub));!             r2sub.addRelation(new InfluenceRelation(lsub));!   !             RelationListItem *r = !               new Relation2<L, R1, R2, RelationFunctor>(lsub, r1sub, r2sub, f);!             lsub.addRelation(r);!           }        }    }*************** namespace Pooma {*** 1058,1077 ****                     const R1 &r1, const R2 &r2, const R3 &r3)    {!     if (l.numSubFields() > 0)        {!         for (int i = 0; i < l.numSubFields(); i++)!           newRelation(f, l[i], r1[i], r2[i], r3[i]);        }-     else-       {  -         r1.addRelation(new InfluenceRelation(l));-         r2.addRelation(new InfluenceRelation(l));-         r3.addRelation(new InfluenceRelation(l));-   -         RelationListItem *r = new -           Relation3<L, R1, R2, R3, RelationFunctor>-             (l, r1, r2, r3, f);-         l.addRelation(r);-       }    }    --- 1062,1084 ----                     const R1 &r1, const R2 &r2, const R3 &r3)    {!     for (int m = 0; m < l.numMaterials(); ++m)        {!         for (int c = 0; c < l.centeringSize(); ++c)!           {!             const L &lsub = l.subField(m, c);!             const R1 &r1sub = r1.subField(m, c);!             const R2 &r2sub = r2.subField(m, c);!             const R3 &r3sub = r3.subField(m, c);!             !             r1sub.addRelation(new InfluenceRelation(lsub));!             r2sub.addRelation(new InfluenceRelation(lsub));!             r3sub.addRelation(new InfluenceRelation(lsub));!   !             RelationListItem *r = new !               Relation3<L, R1, R2, R3, RelationFunctor>!                 (lsub, r1sub, r2sub, r3sub, f);!             lsub.addRelation(r);!           }        }    }    *************** namespace Pooma {*** 1082,1101 ****                     const R3 &r3, const R4 &r4)    {!     if (l.numSubFields() > 0)        {!         for (int i = 0; i < l.numSubFields(); i++)!           newRelation(f, l[i], r1[i], r2[i], r3[i], r4[i]);!       }!     else!       {  !         r1.addRelation(new InfluenceRelation(l));!         r2.addRelation(new InfluenceRelation(l));!         r3.addRelation(new InfluenceRelation(l));!         r4.addRelation(new InfluenceRelation(l));!   !         RelationListItem *r = new !           Relation4<L, R1, R2, R3, R4, RelationFunctor>!             (l, r1, r2, r3, r4, f);!         l.addRelation(r);        }    }--- 1089,1112 ----                     const R3 &r3, const R4 &r4)    {!     for (int m = 0; m < l.numMaterials(); ++m)        {!         for (int c = 0; c < l.centeringSize(); ++c)!           {!             const L &lsub = l.subField(m, c);!             const R1 &r1sub = r1.subField(m, c);!             const R2 &r2sub = r2.subField(m, c);!             const R3 &r3sub = r3.subField(m, c);!             const R4 &r4sub = r4.subField(m, c);!             !             r1sub.addRelation(new InfluenceRelation(lsub));!             r2sub.addRelation(new InfluenceRelation(lsub));!             r3sub.addRelation(new InfluenceRelation(lsub));!             r4sub.addRelation(new InfluenceRelation(lsub));!   !             RelationListItem *r = new !               Relation4<L, R1, R2, R3, R4, RelationFunctor>!                 (lsub, r1sub, r2sub, r3sub, r4sub, f);!             lsub.addRelation(r);!           }        }    }*************** namespace Pooma {*** 1107,1128 ****                     const R3 &r3, const R4 &r4, const R5 &r5)    {!     if (l.numSubFields() > 0)        {!         for (int i = 0; i < l.numSubFields(); i++)!           newRelation(f, l[i], r1[i], r2[i], r3[i], r4[i], r5[i]);        }-     else-       {  -         r1.addRelation(new InfluenceRelation(l));-         r2.addRelation(new InfluenceRelation(l));-         r3.addRelation(new InfluenceRelation(l));-         r4.addRelation(new InfluenceRelation(l));-         r5.addRelation(new InfluenceRelation(l));-   -         RelationListItem *r = new -           Relation5<L, R1, R2, R3, R4, R5, RelationFunctor>-             (l, r1, r2, r3, r4, r5, f);-         l.addRelation(r);-       }    }    --- 1118,1144 ----                     const R3 &r3, const R4 &r4, const R5 &r5)    {!     for (int m = 0; m < l.numMaterials(); ++m)        {!         for (int c = 0; c < l.centeringSize(); ++c)!           {!             const L &lsub = l.subField(m, c);!             const R1 &r1sub = r1.subField(m, c);!             const R2 &r2sub = r2.subField(m, c);!             const R3 &r3sub = r3.subField(m, c);!             const R4 &r4sub = r4.subField(m, c);!             const R5 &r5sub = r5.subField(m, c);!             !             r1sub.addRelation(new InfluenceRelation(lsub));!             r2sub.addRelation(new InfluenceRelation(lsub));!             r3sub.addRelation(new InfluenceRelation(lsub));!             r4sub.addRelation(new InfluenceRelation(lsub));!             r5sub.addRelation(new InfluenceRelation(lsub));!   !             RelationListItem *r = new !               Relation5<L, R1, R2, R3, R4, R5, RelationFunctor>!                 (lsub, r1sub, r2sub, r3sub, r4sub, r5sub, f);!             lsub.addRelation(r);!           }        }    }    *************** namespace Pooma {*** 1133,1154 ****                     const R3 &r3, const R4 &r4, const R5 &r5, const R6 &r6)    {!     if (l.numSubFields() > 0)        {!         for (int i = 0; i < l.numSubFields(); i++)!           newRelation(f, l[i], r1[i], r2[i], r3[i], r4[i], r5[i], r6[i]);!       }!     else!       {  !         r1.addRelation(new InfluenceRelation(l));!         r2.addRelation(new InfluenceRelation(l));!         r3.addRelation(new InfluenceRelation(l));!         r4.addRelation(new InfluenceRelation(l));!         r5.addRelation(new InfluenceRelation(l));!         r6.addRelation(new InfluenceRelation(l));!   !         RelationListItem *r = new !           Relation6<L, R1, R2, R3, R4, R5, R6, RelationFunctor>!             (l, r1, r2, r3, r4, r5, r6, f);!         l.addRelation(r);        }    }--- 1149,1176 ----                     const R3 &r3, const R4 &r4, const R5 &r5, const R6 &r6)    {!     for (int m = 0; m < l.numMaterials(); ++m)        {!         for (int c = 0; c < l.centeringSize(); ++c)!           {!             const L &lsub = l.subField(m, c);!             const R1 &r1sub = r1.subField(m, c);!             const R2 &r2sub = r2.subField(m, c);!             const R3 &r3sub = r3.subField(m, c);!             const R4 &r4sub = r4.subField(m, c);!             const R5 &r5sub = r5.subField(m, c);!             const R6 &r6sub = r6.subField(m, c);!             !             r1sub.addRelation(new InfluenceRelation(lsub));!             r2sub.addRelation(new InfluenceRelation(lsub));!             r3sub.addRelation(new InfluenceRelation(lsub));!             r4sub.addRelation(new InfluenceRelation(lsub));!             r5sub.addRelation(new InfluenceRelation(lsub));!             r6sub.addRelation(new InfluenceRelation(lsub));!   !             RelationListItem *r = new !               Relation6<L, R1, R2, R3, R4, R5, R6, RelationFunctor>!                 (lsub, r1sub, r2sub, r3sub, r4sub, r5sub, r6sub, f);!             lsub.addRelation(r);!           }        }    }Index: NewField/tests/ScalarCode.cpp===================================================================RCS file: /home/pooma/Repository/r2/src/NewField/tests/ScalarCode.cpp,vretrieving revision 1.7.2.3diff -p -c -2 -r1.7.2.3 ScalarCode.cpp*** NewField/tests/ScalarCode.cpp	2001/08/23 23:01:24	1.7.2.3--- NewField/tests/ScalarCode.cpp	2001/08/29 16:39:15*************** int main(int argc, char *argv[])*** 328,333 ****    Pooma::addAllConstantFaceBC(f, 4.0, true);  !   XField<Mesh_t>::Type_t x(allFace, layout1, origin, spacings);!   setXField(x);      for(d = 0; d < dim; ++d)--- 328,332 ----    Pooma::addAllConstantFaceBC(f, 4.0, true);  !   PositionsTraits<Mesh_t>::Type_t x = positions(f);      for(d = 0; d < dim; ++d)*************** int main(int argc, char *argv[])*** 386,395 ****      DomainLayout<dim> layout4(physicalVertexDomain, GuardLayers<dim>(1));!   XField<Mesh_t>::Type_t xEdge(edge, layout4, origin, spacings);!   setXField(xEdge);      EdgeGammaConstant = 1.4;!   EdgeSoundSpeed = 42.0 + xEdge.comp(1);!   EdgeVelocity = 3.0 * xEdge;    EdgePsiLimiter = 1.0;  --- 385,393 ----      DomainLayout<dim> layout4(physicalVertexDomain, GuardLayers<dim>(1));!   FieldBrick_t fEdge(edge, layout4, origin, spacings);      EdgeGammaConstant = 1.4;!   EdgeSoundSpeed = 42.0 + positions(fEdge).comp(1);!   EdgeVelocity = 3.0 * positions(fEdge);    EdgePsiLimiter = 1.0;  *************** int main(int argc, char *argv[])*** 414,424 ****    Field_t edgeValues(edgeY, layout3, origin, spacings);    Field_t cellValues(cell, layout3, origin, spacings);  -   XField<Mesh_t>::Type_t xEdgeY(edgeY, layout4, origin, spacings);-   setXField(xEdgeY);-     edgeValues.all() = 42.0;    cellValues.all() = 5.0;!   cellValues = xEdgeY.comp(0);      tester.out() << "starting cell values: " << std::endl--- 412,420 ----    Field_t edgeValues(edgeY, layout3, origin, spacings);    Field_t cellValues(cell, layout3, origin, spacings);+   FieldBrick_t fEdgeY(edgeY, layout4, origin, spacings);      edgeValues.all() = 42.0;    cellValues.all() = 5.0;!   cellValues = positions(fEdgeY).comp(0);      tester.out() << "starting cell values: " << std::endlIndex: NewField/tests/TestBasicRelations.cpp===================================================================RCS file: /home/pooma/Repository/r2/src/NewField/tests/Attic/TestBasicRelations.cpp,vretrieving revision 1.1.2.2diff -p -c -2 -r1.1.2.2 TestBasicRelations.cpp*** NewField/tests/TestBasicRelations.cpp	2001/08/23 23:01:24	1.1.2.2--- NewField/tests/TestBasicRelations.cpp	2001/08/29 16:39:15****************** 31,34 ****--- 31,35 ----    #include "Pooma/NewFields.h"+ #include "Utilities/Tester.h"    typedef Field<UniformRectilinearMesh<2>, double, Brick> Field_t;*************** int main(int argc, char *argv[])*** 70,73 ****--- 71,75 ----  {    Pooma::initialize(argc, argv);+   Pooma::Tester tester(argc, argv);      Interval<2> physicalVertexDomain(4, 4);*************** int main(int argc, char *argv[])*** 97,108 ****    Pooma::newRelation(Pooma::memberPtr(obj, &ComputeVelocity::doit), v, p, m);    !   std::cout << E << std::endl;        h = 0;    !   std::cout << E << std::endl;!     Pooma::finalize();!   return 0;   }  --- 99,111 ----    Pooma::newRelation(Pooma::memberPtr(obj, &ComputeVelocity::doit), v, p, m);    !   tester.out() << E << std::endl;        h = 0;    !   tester.out() << E << std::endl;!     !   int ret = tester.results("TestBasicRelations");    Pooma::finalize();!   return ret;  }  Index: Pooma/NewFields.h===================================================================RCS file: /home/pooma/Repository/r2/src/Pooma/NewFields.h,vretrieving revision 1.5.2.6diff -p -c -2 -r1.5.2.6 NewFields.h*** Pooma/NewFields.h	2001/08/23 23:01:24	1.5.2.6--- Pooma/NewFields.h	2001/08/29 16:39:18****************** 54,58 ****  #include "NewField/Mesh/NoMesh.h"  #include "NewField/Mesh/UniformRectilinearMesh.h"! #include "NewField/Mesh/PositionFunctions.h"    // Relations:--- 54,58 ----  #include "NewField/Mesh/NoMesh.h"  #include "NewField/Mesh/UniformRectilinearMesh.h"! #include "NewField/Mesh/MeshFunctions.h"    // Relations: