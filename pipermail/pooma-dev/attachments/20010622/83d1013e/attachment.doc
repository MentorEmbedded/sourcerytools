{\rtf1\ansi\deff0
{\fonttbl{\f2\fnil\fcharset0 Courier New;}
{\f1\fnil\fcharset0 Arial;}
{\f0\fnil\fcharset0 Times New Roman;}
}
{\colortbl;}{\stylesheet{\s1 Heading 1;}{\s2 Heading 2;}{\s3 Heading 3;}{\s4 Heading 4;}{\s5 Heading 5;}{\s6 Heading 6;}{\s7 Heading 7;}{\s8 Heading 8;}{\s9 Heading 9;}}
\deflang1024\notabind\facingp\hyphauto1\widowctrl
\sectd\plain\pgwsxn12240\pghsxn15840\marglsxn1440\margrsxn1440\margtsxn1440\margbsxn1920\headery0\footery0\pgndec\titlepg{\headerf\pard\sl-240\sb770\sa430\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {}\par}{\footerf\pard\sl-240\sb770\sa910\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {\i\fs20 \chpgn }\par}{\headerl\pard\sl-240\sb770\sa430\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {\i\fs20 Notes on Pooma Layout}\par}{\footerl\pard\sl-240\sb770\sa910\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {\i\fs20 \chpgn }\par}{\headerr\pard\sl-240\sb770\sa430\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {\i\fs20 Notes on Pooma Layout}\par}{\footerr\pard\sl-240\sb770\sa910\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {\i\fs20 \chpgn }\par}\pard\sb373\li960\sl647\qc \b\fs49\f1 Notes on Pooma Layout\keepn\hyphpar0\par\pard\sb216\li960\sl449\qc \fs34  \keepn\hyphpar0\par\pard\sb259\s2\sl449 Layouts and related classes\keepn\hyphpar0\par\pard\sb216\s3\sl374 \fs28 Introduction\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 All POOMA data objects that use the MultiPatchEngine will use one of the Layout classes to define how the data patches are organized. Layouts define how the data object is sub-divided into 'patches', a single contiguous region of memory. Most Layouts also provide for GuardLayers definitions. \hyphpar0\par\pard\sb100\li960\sl260 The following is a code fragment illustrating the creation of a POOMA Array using a GridLayout. \hyphpar0\par\pard\sb200\li960\sl234 \fs18\lang1024\f2 IndirectionList<-int-> g1(5); \sa0\par\fi0\sb0
g1(0) = 0; g1(1) = 5; g1(2) = 11; g1(3) = 17; g1(4) = 25; \sa0\par\fi0\sb0
Interval<-1-> dom(g1(0),g1(4)-1); \sa0\par\fi0\sb0
\sa0\par\fi0\sb0
GuardLayers<-1-> igl(1), egl(0,2); \sa0\par\fi0\sb0
GridPartition<-1-> martition(Grid<-1->(g1),igl,egl); \sa0\par\fi0\sb0
GridLayout<-1-> mayout2(dom, martition, ReplicatedTag() ); \sa0\par\fi0\sb0
Array<-1, double, MultiPatch<-GridTag, Brick-> -> aa(mayout2); \sa0\par\fi0\sb0
        \hyphpar0\par\pard\sb259\s2\sl449 \b\fs34\f1 GuardLayers\keepn\hyphpar0\par\pard\sb173\li960\sl260 \b0\fs20\lang1033\f0 The GuardLayers<-Dim-> class is used to specify both internal and external guard layers. Each dimension has a pair of integers to allow for asymmetric guard layer thicknesses. External guard layer specifications override those specified by the internal guard layer for those patches that make up the edges of the data object. \hyphpar0\par\pard\sb100\li960\sl260 There are two types of GuardLayers used by a MultiPatchEngine based Pooma data object. These are internal guard Layers, and external guard layers. Each data patch that makes up POOMA data object has it's domain extended by the number of data elements specified by the GuardLayers object. Internal guard layers are layers of elements or cells added to the upper and/or lower end of the sub-domain of the PatchEngine. These cells are to be filled with the data values of the adjacent patches, in order to minimize cross context data dependency of execution of expressions for each PatchEngine. In general it is an error to specify a internal guard layer that is larger than the patch dimension. This is especially important to remember when dealing with SparseTileLayout and GridLayout. \hyphpar0\par\pard\sb100\li960\sl260 External guard layers are on the edge of the entire data object. Used for external boundary conditions. In this diagram, the external guard layers are indicated by 'egl'. External guard layers data allocation exists only for those PatchEngines that are on the edges of the full domain of the Pooma data object. The data elements that make up the external guard layers are generaly used for external boundary conditions. \hyphpar0\par\pard\sb100\li960\sl260 In this example, the GuardLayers specification is symmetric, and the size of the internal and external guard layers are both 2. In general, GuardLayers may be specified asymmetrically, for instance: \hyphpar0\par\pard\sb200\li960\sl234 \fs18\lang1024\f2 GuardLayers<-2-> egl(0,5,3,1); \sa0\par\fi0\sb0
    \hyphpar0\par\pard\sb200\li960\sl260 \fs20\lang1033\f0 The first axis has an (external) GuardLayers specification that is 0 on the lower edge of the domain, and has a width of 5 on the upper edge of the domain, while in the second axis, the lower edge of the domain is extended by 3, and extended by 1 on the upper edge of the domain. \hyphpar0\par\pard\sb100\li960\sl260 When the external guard layers and internal guard layers are specified separately, the thickness of the external guard layer region in the patches that form the edges of the domain will be that which was specified by the external guard layer. Where those patches don't have an edge on the border of the domain, the internal guard layer specification will determine the size of the patches. \hyphpar0\par\pard\sb200\li960\sl260 \b\lang1024 Figure 1. Sample Image\keepn\hyphpar0\par\pard\sb100\li960\sl260 {\field\flddirty{\*\fldinst INCLUDEPICTURE "images/bordergraph.png" }{\fldrslt }}\par\pard\sb100\li960\sl260 \b0\lang1033 Orange cells replicate neighboring blue cells.\hyphpar0\par\pard\sb200\li960\sl260 The following graphic illustrates the internal and external guard cell regions for a UniformGridLayout with asymmetric guard cell specifications. \hyphpar0\par\pard\sb200\li960\sl234 \fs18\lang1024\f2 GuardLayers egl(1,3,2,3); \sa0\par\fi0\sb0
GuardLayers igl(2,1,1,3); \sa0\par\fi0\sb0
Interval<-2-> dom(Interval<-1->(0,14),Interval<-1->(0,9)); \sa0\par\fi0\sb0
UniformGridPartition<-2->  asypart(Loc<-2->(3,2),igl,egl); \sa0\par\fi0\sb0
Array<-2,double,MultiPatchEngine<-UniformTag,CompressibleBrick-> ->     Aarray(UniformGridLayout<-2->(dom,asypart,ReplicatedTag());\sa0\par\fi0\sb0
    \hyphpar0\par\pard\sb259\s2\sl449 \b\fs34\f1 Layouts\keepn\hyphpar0\par\pard\sb173\li960\sl260 \b0\fs20\lang1033\f0 The currently existent Layouts are: \hyphpar0\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 UniformGridLayout<-Dim->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 Divides the data space into regions defined by dividing each axis into an integral number of equally size segments. \hyphpar0\par\pard\sb200\li960\sl260 {\field\flddirty{\*\fldinst INCLUDEPICTURE "images/grid-2ugl.png" }{\fldrslt }}\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 GridLayout<-Dim->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 Divides the data space into regions by segmenting each axis arbitrarily. \hyphpar0\par\pard\sb200\li960\sl260 {\field\flddirty{\*\fldinst INCLUDEPICTURE "images/grid-2gl.png" }{\fldrslt }}\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 SparseTileLayout<-Dim->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 Tiles the domain (called the BoundingBox for this Layout) with non-overlapping patches. The patches do not have to completely tile the BoundingBox. The SparseTileLayout was designed in anticipation of Adaptive Mesh Refinement codes development within Pooma. In SparseTileLayout, there are class member functions that support accessing both the list of conventional internal and external guard layer regions, as well as guard layers that do not intersect or overlap onto the data space of patches defined within the layout. \hyphpar0\par\pard\sb200\li960\sl260 {\field\flddirty{\*\fldinst INCLUDEPICTURE "images/grid-2stl.png" }{\fldrslt }}\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 DynamicLayout\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 An inherently 1 dimensional Layout, that allows the patches to be resized. \hyphpar0\par\pard\sb200\li960\sl260 {\field\flddirty{\*\fldinst INCLUDEPICTURE "images/grid-2D.png" }{\fldrslt }}\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 DomainLayout<-Dim->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 A single patch domain defined by a single Interval. \hyphpar0\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 UniformGridLayout, GridLayout, and SparseTileLayout\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 The UniformGridLayout, GridLayout, and SparseTileLayout all have a trailingtag argument on most of their constructors that specifies how the data is ContextMappered. These tags are ReplicatedTag and DistributedTag.If ReplicatedTag is specified, then LocalMapper is used, while if DistributedTagis specified, the the DistributedMapper is used. All of the aforementioned layouts have the default constructor that doesn't require the use of the ReplicatedTag or DistributedTag, and the constructor of the form (Domain,Partitioner, ContextMapper), since it explicitly specifies a ContextMapper,doesn't require the use of the trailing tags. \keepn\hyphpar0\par\pard\sb259\li960\sl260 Layouts have Partitioners that are invoked to generate the patch-subdomains, taking into account internal and external GuardLayers. \hyphpar0\par\pard\sb100\li960\sl260 The currently available Partitioners are: \hyphpar0\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 UniformGridPartitioner<-Dim->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 Used to generate patches for a UniformGirdLayout. \hyphpar0\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 GirdPartitioner<-Dim->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 Used to generate patches for a GridLayout \hyphpar0\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 TilePartition<-Dim->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 Generates patches from a provided list of domains. \hyphpar0\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 SpatialPartition<-ReferenceLayout->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 Generates a list of empty patches that correspond in context and affinity to the patch list of a provided reference Layout. Generally used with DynamicLayout. \hyphpar0\par\pard\sb259\s2\sl449 \b\fs34\lang1024\f1 ContextMapper and derived classes\keepn\hyphpar0\par\pard\sb173\li960\sl260 \b0\fs20\lang1033\f0 Once the patch lists have been generated, the assignment of the context and affinity values of each of the patches is determined by the ContextMapper. The ContextMapper class is a base class of a set of derived mappers specialized for particular data-distributed or data-replicated data objects. \hyphpar0\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 LocalMapper<-Dim->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 Assigns all patches to a Context == -1. The value -1 is a special value used by other parts of POOMA to indicate that the entire data object should be replicated on each context. \hyphpar0\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 DistributedMapper<-Dim->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 The DistributedMapper is a wrapper for other ContextMappers that tries to pick an optimal mapper for the case where the data is distributed over multiple contexts. \hyphpar0\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 UniformMapper\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 This is a mapper specialized to Dim == 1, and evenly divides the patch list sequence into the number of contexts. \hyphpar0\par\pard\sb200\li960\sl260 {\field\flddirty{\*\fldinst INCLUDEPICTURE "images/grid-2uniform.png" }{\fldrslt }}\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 BisectionMapper<-Dim->\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 Uses Recursive bisection of the largest group of patches to produce contexts with an approximately minimum surface to volume ratio. See figure. \hyphpar0\par\pard\sb200\li960\sl260 {\field\flddirty{\*\fldinst INCLUDEPICTURE "images/grid-2bisection.png" }{\fldrslt }}\par\pard\sb216\s3\sl374 \b\fs28\lang1024\f1 ContiguousMapper\keepn\hyphpar0\par\pard\sb144\li960\sl260 \b0\fs20\lang1033\f0 Assigns patches to a context in a modified Fortran storage order: as the index gets to an boundary, the lowest axis index decrements, rather than going from LowIndex = IndexMax to LowIndex = 0; See the figure for an illustration of this mapper. \hyphpar0\par\pard\sb259\s2\sl449 \b\fs34\lang1024\f1 Restrictions on combinations of Layouts, Partitioners, and ContextMappers.\keepn\hyphpar0\par\pard\sb173\li960\sl260 \b0\fs20\lang1033\f0 Only some combinations of Layouts, Partitioners and ContextMappers are valid. \hyphpar0\par\pard\sb100\li960\sl260  It is a logical error to use a GridPartitioner or SpatialPartitioner with a UniformGridLayout, as one of the optimizations within UniformGridLayout is that all domains are the same size. However, you can use a UniformGridPartitioner with a GridLayout, as the partitioning performed is within the restrictions imposed by GridLayout. SparseTileLayout is only compatible with TilePartition. \hyphpar0\par\pard\sb100\li960\sl260  It is an error to try to use a MultiPatch engine of Brick or CompressibleBrick with any other mapper other than LocalMapper, and/or any layout that is not constructed with a ReplicatedTag argument. Since Bricks are single context only data engines, any MultiPatch engine constructed using Brick patch engines must not be distributed. \hyphpar0\par\pard\sb100\li960\sl260  Similarly, MultiPatchEngine may not be constructed with the PatchEngine tag specified as Remote<-PatchEngine-> if LocalMapper is specified in the Layout used to construct the MultiPatchEngine. Either of the aforementioned combinations will generate a Pinsist error inside MultiPatchEngine \hyphpar0\par}
