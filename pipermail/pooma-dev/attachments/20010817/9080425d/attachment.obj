Index: r2-branch/src/NewField/Mesh/UniformRectilinearMesh.h===================================================================RCS file: /home/pooma/Repository/r2/src/NewField/Mesh/Attic/UniformRectilinearMesh.h,vretrieving revision 1.1.2.3diff -p -c -2 -r1.1.2.3 UniformRectilinearMesh.h*** r2-branch/src/NewField/Mesh/UniformRectilinearMesh.h	2001/08/14 20:24:18	1.1.2.3--- r2-branch/src/NewField/Mesh/UniformRectilinearMesh.h	2001/08/17 17:52:03*************** public:*** 274,287 ****        return data_m->origin();       }        //---------------------------------------------------------------------------    // Support for the positions() function. We need to provide a functor for    // use with IndexFunction-engine. We also need to export the    // PositionsEngineTag_t typedef and the positionsFunctor() member function,!   // which computes the positions using the centering point offsets.        class PositionsFunctor {    public:          PositionsFunctor(const UniformRectilinearMesh<Dim, T> &m,                        const Centering<Dim> &c)--- 274,317 ----        return data_m->origin();       }+ +   // The cell containing a particular point.    +   inline Loc<Dim> cellContaining(const Vector<Dim, T> &point) const+     {+       Loc<Dim> loc(Pooma::NoInit);+       +       for (int i = 0; i < Dim; i++)+         loc[i] = +           Loc<1>(static_cast<int>((point(i) - origin()(i)) / spacings()(i)));+       +       return loc;+     }+ +   // The lower-left vertex associated with a given cell location.+     +   inline Vector<Dim, T> vertexPosition(const Loc<Dim> &loc) const+     {+       Vector<Dim, T> point;+       +       for (int i = 0; i < Dim; i++)+         point(i) = origin()(i) + spacings()(i) * +           (loc[i].first() - physicalCellDomain()[i].first());+     }+         //---------------------------------------------------------------------------    // Support for the positions() function. We need to provide a functor for    // use with IndexFunction-engine. We also need to export the    // PositionsEngineTag_t typedef and the positionsFunctor() member function,!   // which computes the positions using the centering point positions.!   // The indices passed in refer to cells.        class PositionsFunctor {    public:    +     // Need to be able to default construct since we fill in the details+     // after the fact.+     +     PositionsFunctor() { }+           PositionsFunctor(const UniformRectilinearMesh<Dim, T> &m,                        const Centering<Dim> &c)*************** public:*** 290,307 ****          for (int i = 0; i < Dim; i++)            origin_m(i) += spacings_m(i) * !             (c.position(0) - m.physicalCellDomain[i].first());        }!    !     PointType_t operator()(int i0) const        {          return origin_m + PointType_t(i0) * spacings_m;        }        !     PointType_t operator()(int i0, int i1) const        {          return origin_m + PointType_t(i0, i1) * spacings_m;        }  !     PointType_t operator()(int i0, int i1, int i2) const        {          return origin_m + PointType_t(i0, i1, i2) * spacings_m;--- 320,337 ----          for (int i = 0; i < Dim; i++)            origin_m(i) += spacings_m(i) * !             (c.position(0)(i) - m.physicalCellDomain()[i].first());        }!       !     inline PointType_t operator()(int i0) const        {          return origin_m + PointType_t(i0) * spacings_m;        }        !     inline PointType_t operator()(int i0, int i1) const        {          return origin_m + PointType_t(i0, i1) * spacings_m;        }  !     inline PointType_t operator()(int i0, int i1, int i2) const        {          return origin_m + PointType_t(i0, i1, i2) * spacings_m;*************** public:*** 314,333 ****    };        //---------------------------------------------------------------------------!   // Support for the outwardNormals() function. We also need to export the!   // OutwardNormalsEngineTag_t typedef and the initializeOutwardNormals() !   // member function, which sets the appropriate constant value (since the!   // normals exactly align with the coordinate axes.  !   typedef ConstantFunction OutwardNormalsEngineTag_t;    !   template<class Engine>    !   void initializePositions(const Engine &e, const Centering<Dim> &c)      {! //      VectorType_t v(static_cast<T>(0));! //      e.setConstant(v);      }      private:      // Our data, stored as a ref-counted pointer to simplify memory management.--- 344,482 ----    };    +   typedef IndexFunction<PositionsFunctor> PositionsEngineTag_t;+   +   void initializePositions(+     Engine<Dim, PointType_t, PositionsEngineTag_t> &e, +     const Centering<Dim> &c) const+     {+       e.setFunctor(PositionsFunctor(*this, c));+     }+       //---------------------------------------------------------------------------!   // Support for the outwardNormals() and coordinateNormals() functions. !   // We also need to export the NormalsEngineTag_t typedef and the !   // initializeNormals() member function, which sets the appropriate constant !   // value (since the normals exactly align with the coordinate axes).!   // The boolean value passed is true if we are asking for outward normals,!   // as opposed to coordinate normals. The indices passed in refer to cells.  !   typedef ConstantFunction NormalsEngineTag_t;    !   void initializeNormals(!     Engine<Dim, VectorType_t, NormalsEngineTag_t> &e, !     const Centering<Dim> &c,!     bool outward = true) const      {!       // Check some pre-conditions. We need there to be a single centering!       // point and it must be face-centered.!       !       PAssert(c.size() == 1);!       PAssert(c.centeringType() == FaceType);!       !       // Generate the normals. The coordinate normals are computed from!       // 1 - orientation. Then, if we are on the near face, indicated by!       // position == 0.0, we need to multiply by -1.0 if we are doing!       // outward normals.!       !       VectorType_t normal;!       for (int i = 0; i < Dim; i++)!         {!           normal(i) = static_cast<T_t>(1 - c.orientation(0)[i].first());!           if (outward && c.position(0)(i) == 0.0)!             normal(i) *= static_cast<T_t>(-1);!         }!         !       e.setConstant(normal);      }    +   //---------------------------------------------------------------------------+   // Support for the cellVolumes() function. We also need to export the +   // CellVolumesEngineTag_t typedef and the initializeCellVolumes() member +   // function, which sets the appropriate constant value for the volume. +   // The indices passed in refer to cells.+ +   typedef ConstantFunction CellVolumesEngineTag_t;+   +   void initializeCellVolumes(+     Engine<Dim, T_t, CellVolumesEngineTag_t> &e, +     const Centering<Dim> &c) const+     {+       // Check some pre-conditions. We need there to be a single centering+       // point and it must be cell-centered.+       +       PAssert(c.size() == 1);+       PAssert(c.centeringType() == CellType);+       +       // Use the general function to do the job.+       +       initializeGeneralVolume(e, c);+     }+   +   //---------------------------------------------------------------------------+   // Support for the faceAreas() function. We also need to export the +   // FaceAreasEngineTag_t typedef and the initializeFaceAreas() member +   // function, which sets the appropriate constant face area value.+   // The indices passed in refer to cells.+ +   typedef ConstantFunction FaceAreasEngineTag_t;+   +   void initializeFaceAreas(+     Engine<Dim, T_t, FaceAreasEngineTag_t> &e, +     const Centering<Dim> &c) const+     {+       // Check some pre-conditions. We need there to be a single centering+       // point and it must be face-centered.+       +       PAssert(c.size() == 1);+       PAssert(c.centeringType() == FaceType);+       +       // Use the general function to do the job.+       +       initializeGeneralVolume(e, c);+     }+   +   //---------------------------------------------------------------------------+   // Support for the edgeLengths() function. We also need to export the +   // EdgeLengthsEngineTag_t typedef and the initializeEdgeLengths() member +   // function, which sets the appropriate constant edge length value.+   // The indices passed in refer to cells.+ +   typedef ConstantFunction EdgeLengthsEngineTag_t;+   +   void initializeEdgeLengths(+     Engine<Dim, T_t, EdgeLengthsEngineTag_t> &e, +     const Centering<Dim> &c) const+     {+       // Check some pre-conditions. We need there to be a single centering+       // point and it must be edge-centered.+       +       PAssert(c.size() == 1);+       PAssert(c.centeringType() == EdgeType);+       +       // Use the general function to do the job.+       +       initializeGeneralVolume(e, c);+     }+     private:+ +   // General "volume" computation: works for edges, faces, and cells.+   +   void initializeGeneralVolume(+     Engine<Dim, T_t, ConstantFunction> &e, +     const Centering<Dim> &c) const+     {+       // Generate the volume by multiplying the spacings in the+       // directions where the orientation is non-zero.+       +       T_t volume = static_cast<T_t>(1);+       for (int i = 1; i < Dim; i++)+         {+           if (c.orientation(0)[i].first() != 0)+             volume *= spacings()(i);+         }+         +       e.setConstant(volume);+     }      // Our data, stored as a ref-counted pointer to simplify memory management.