Index: Doof2d.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/benchmarks/Doof2d/Doof2d.cpp,v
retrieving revision 1.19
diff -c -p -r1.19 Doof2d.cpp
*** Doof2d.cpp	2001/08/30 01:14:23	1.19
--- Doof2d.cpp	2001/09/28 03:34:28
***************
*** 29,40 ****
  // Doof2d Benchmark
  //-----------------------------------------------------------------------------
  
! // include files
  
! #include "Doof2dInP2.h"
! #include "Doof2dInCppTran.h"
  #include "Doof2dInC.h"
  
  
  //-----------------------------------------------------------------------------
  // Main program.
--- 29,47 ----
  // Doof2d Benchmark
  //-----------------------------------------------------------------------------
  
! // Include files
  
! #include "Pooma/Pooma.h"
! #include "Doof2d.h"
  #include "Doof2dInC.h"
  
+ #if POOMA_CHEETAH
+   typedef Remote<Brick> BrickTag_t;
+   typedef Remote<CompressibleBrick> CompressibleBrickTag_t;
+ #else
+   typedef Brick BrickTag_t;
+   typedef CompressibleBrick CompressibleBrickTag_t;
+ #endif
  
  //-----------------------------------------------------------------------------
  // Main program.
***************
*** 42,91 ****
  
  int main(int argc, char* argv[])
  {
!   Pooma::initialize(argc, argv);
! 
!   // Run 9pt doof2d without coefficients.
! 
!   Benchmark doof2d(argc, argv, "9 Pt Without Coefs");
  
  #if !POOMA_NO_RESTRICT
    doof2d.addImplementation(new Doof2dInC<true>());
  #endif
    doof2d.addImplementation(new Doof2dInC<false>());
!   doof2d.addImplementation(new Doof2dInCppTran);
!   doof2d.addImplementation(new Doof2dInP2Field);
!   doof2d.addImplementation(new Doof2dInP2UnOpt);
!   doof2d.addImplementation(new Doof2dInP2Opt);
  
!   doof2d.setSamplingParameters(10,2,3);
!   doof2d.run();
  
!   // Run 9pt doof2d with coefficients.
  
! #if defined(COMPILE_COEF_VERSIONS)
  
!   Benchmark doof2dCoefs(argc, argv, "9 Pt With Coefs");
  
! #if !POOMA_NO_RESTRICT
!   doof2dCoefs.addImplementation(new Doof2dCoefsInC<true>());
! #endif
!   doof2dCoefs.addImplementation(new Doof2dCoefsInC<false>());
!   doof2dCoefs.addImplementation(new Doof2dCoefsInCppTran);
!   doof2dCoefs.addImplementation(new Doof2dCoefsInP2UnOpt);
!   doof2dCoefs.addImplementation(new Doof2dCoefsInP2Opt);
  
!   doof2dCoefs.setSamplingParameters(10,2,3);
!   doof2dCoefs.run();
  
! #endif
  
    Pooma::finalize();
    return 0;
  }
  
  // ACL:rcsinfo
  // ----------------------------------------------------------------------
! // $RCSfile: Doof2d.cpp,v $   $Author: oldham $
! // $Revision: 1.19 $   $Date: 2001/08/30 01:14:23 $
  // ----------------------------------------------------------------------
  // ACL:rcsinfo
--- 49,145 ----
  
  int main(int argc, char* argv[])
  {
!   Pooma::initialize(argc, argv); 
!   
!   Benchmark doof2d(argc, argv);
! 
!   typedef Array<2, double, BrickTag_t>
!     BrickStore_t;
!   typedef Array<2, double, CompressibleBrickTag_t>
!     CompBrickStore_t;
!   typedef Array<2, double, MultiPatch<UniformTag, BrickTag_t> >
!     MPBrickStore_t;
!   typedef Array<2, double, MultiPatch<UniformTag, CompressibleBrickTag_t> >
!     MPCompBrickStore_t;
! 
!   typedef Field<UniformRectilinearMesh<2>, double, BrickTag_t>
!     FBrickStore_t;
!   typedef Field<UniformRectilinearMesh<2>, double, CompressibleBrickTag_t>
!     FCompBrickStore_t;
!   typedef Field<UniformRectilinearMesh<2>, double,
!                 MultiPatch<UniformTag, BrickTag_t> >
!     FMPBrickStore_t;
!   typedef Field<UniformRectilinearMesh<2>, double,
!                 MultiPatch<UniformTag, CompressibleBrickTag_t> >
!     FMPCompBrickStore_t;
  
+   // C versions
  #if !POOMA_NO_RESTRICT
    doof2d.addImplementation(new Doof2dInC<true>());
  #endif
    doof2d.addImplementation(new Doof2dInC<false>());
!  
!   // CppTran version Brick
!   doof2d.addImplementation(new Doof2dCppTran<BrickStore_t>);
  
!   // Brick single patch
!   doof2d.addImplementation(new Doof2dP2<BrickStore_t>);
  
!   // Compressible Brick single patch
!   doof2d.addImplementation(new Doof2dP2<CompBrickStore_t>);
  
!   // Brick multi-patch no guards
!   doof2d.addImplementation(new Doof2dP2<MPBrickStore_t>(doof2d.numPatches()));
  
!   // Brick multi-patch with 1 guard layer
!   doof2d.addImplementation(new Doof2dP2<MPBrickStore_t>(doof2d.numPatches(),1));
  
!   // Brick multi-patch with 1 guard layer using stencil object
!   doof2d.addImplementation(new Doof2dP2Opt<MPBrickStore_t>(doof2d.numPatches(),1));
  
!   // Compressible brick multi-patch no guard layers
!   doof2d.addImplementation(new Doof2dP2<MPCompBrickStore_t>(doof2d.numPatches()));
  
!   // Compressible brick multi-patch with 1 guard layer
!   doof2d.addImplementation(new Doof2dP2<MPCompBrickStore_t>(doof2d.numPatches(),1));
! 
!   // Compressible brick multi-patch with 1 guard layer using stencil object
!   doof2d.addImplementation(new Doof2dP2Opt<MPCompBrickStore_t>(doof2d.numPatches(),1));
! 
!   // Field CppTran version Brick
!   doof2d.addImplementation(new Doof2dCppTran<FBrickStore_t>);
  
+   // Field Brick single patch
+   doof2d.addImplementation(new Doof2dP2<FBrickStore_t>);
+ 
+   // Field Compressible Brick single patch
+   doof2d.addImplementation(new Doof2dP2<FCompBrickStore_t>);
+ 
+   // Field Brick multi-patch no guards
+   doof2d.addImplementation(new Doof2dP2<FMPBrickStore_t>(doof2d.numPatches()));
+ 
+   // Field Brick multi-patch with 1 guard layer
+   doof2d.addImplementation(new Doof2dP2<FMPBrickStore_t>(doof2d.numPatches(),1));
+ 
+   // Field Compressible brick multi-patch no guard layers
+   doof2d.addImplementation(new Doof2dP2<FMPCompBrickStore_t>(doof2d.numPatches()));
+ 
+   // Field Compressible brick multi-patch with 1 guard layer
+   doof2d.addImplementation(new Doof2dP2<FMPCompBrickStore_t>(doof2d.numPatches(),1));
+ 
+   // Need to add implementations for stencils on Field.
+ 
+   doof2d.setSamplingParameters(100,0,1);
+   doof2d.run();
+   
    Pooma::finalize();
+ 
    return 0;
  }
  
  // ACL:rcsinfo
  // ----------------------------------------------------------------------
! // $RCSfile: Doof2dUMP.cpp,v $   $Author: julianc $
! // $Revision: 1.9 $   $Date: 2000/04/13 19:56:39 $
  // ----------------------------------------------------------------------
  // ACL:rcsinfo
Index: Doof2d.h
===================================================================
RCS file: Doof2d.h
diff -N Doof2d.h
*** /dev/null	Fri Mar 23 21:37:44 2001
--- Doof2d.h	Thu Sep 27 21:34:28 2001
***************
*** 0 ****
--- 1,610 ----
+ // -*- C++ -*-
+ // ACL:license
+ // ----------------------------------------------------------------------
+ // This software and ancillary information (herein called "SOFTWARE")
+ // called POOMA (Parallel Object-Oriented Methods and Applications) is
+ // made available under the terms described here.  The SOFTWARE has been
+ // approved for release with associated LA-CC Number LA-CC-98-65.
+ // 
+ // Unless otherwise indicated, this SOFTWARE has been authored by an
+ // employee or employees of the University of California, operator of the
+ // Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
+ // the U.S. Department of Energy.  The U.S. Government has rights to use,
+ // reproduce, and distribute this SOFTWARE. The public may copy, distribute,
+ // prepare derivative works and publicly display this SOFTWARE without 
+ // charge, provided that this Notice and any statement of authorship are 
+ // reproduced on all copies.  Neither the Government nor the University 
+ // makes any warranty, express or implied, or assumes any liability or 
+ // responsibility for the use of this SOFTWARE.
+ // 
+ // If SOFTWARE is modified to produce derivative works, such modified
+ // SOFTWARE should be clearly marked, so as not to confuse it with the
+ // version available from LANL.
+ // 
+ // For more information about POOMA, send e-mail to pooma@acl.lanl.gov,
+ // or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
+ // ----------------------------------------------------------------------
+ // ACL:license
+ 
+ //-----------------------------------------------------------------------------
+ // Classes Doof2dCppTran, Doof2dP2, DoofNinePt, Doof2dOpt
+ // Implementation Classes Doof2dStorage, Doof2dBase, 
+ //-----------------------------------------------------------------------------
+ 
+ #ifndef POOMA_BENCHMARKS_DOOF2D_H
+ #define POOMA_BENCHMARKS_DOOF2D_H
+ 
+ // Include files
+ 
+ #include "Pooma/Arrays.h"
+ #include "Pooma/Fields.h"
+ #include "Utilities/Benchmark.h"
+ 
+ #include <cstdlib>
+ #include <typeinfo>
+ #include <string>
+ 
+ #if POOMA_CHEETAH
+   typedef DistributedTag LayoutTag_t;
+ #else
+   typedef ReplicatedTag LayoutTag_t;
+ #endif
+ 
+ //-----------------------------------------------------------------------------
+ // PatchString class definitions.  These return a string notation of
+ // the engine type.
+ //-----------------------------------------------------------------------------
+ 
+ template<class ETag>
+ struct PatchString
+ {
+   static
+   std::string get()
+   {
+     if (typeid(ETag) == typeid(Brick))
+       return "Bk";
+     else
+       return "CmBk";
+   }
+ };
+ 
+ template<class ETag>
+ struct PatchString<Remote<ETag> >
+ {
+   static
+   std::string get()
+   {
+     return "r" + PatchString<ETag>::get();
+   }
+ };
+ 
+ template<class LTag, class ETag>
+ struct PatchString<MultiPatch<LTag, ETag> >
+ {
+   static
+   std::string get()
+   {
+     return PatchString<ETag>::get() + "MP";
+   }
+ };
+ 
+ template<int D, class T, class ETag>
+ std::string qualification(const Array<D, T, ETag> &)
+ {
+   return PatchString<ETag>::get();
+ }
+ 
+ template<class Mesh, class T, class ETag>
+ std::string qualification(const Field<Mesh, T, ETag> &)
+ {
+   return "Fd" + PatchString<ETag>::get();
+ }
+ 
+ //-----------------------------------------------------------------------------
+ // Doof2dStorage class definitions.  These classes allocate the array
+ // or field and initialize it.  We define this as a partially
+ // specialized class so it is easy to make subclasses work for Uniform
+ // MultiPatch (UMP) or not.
+ //-----------------------------------------------------------------------------
+ 
+ template<class Storage, bool UMP>
+ class Doof2dStorage
+ {
+ };
+ 
+ template<class ETag>
+ class Doof2dStorage<Array<2, double, ETag>, false>
+ {
+ public:
+ 
+   void initializeStorage(int &n, int np, int ng) 
+   {
+     // Get new array domain, including "guards".
+     
+     Interval<1> N(1, n);
+     Interval<2> vertDomain(N, N);
+ 
+     // Resize the arrays.
+     
+     a_m.initialize(vertDomain);
+     b_m.initialize(vertDomain);
+   }
+ 
+   Array<2, double, ETag> a_m, b_m;
+ };
+ 
+ template<class Mesh, class ETag>
+ class Doof2dStorage<Field<Mesh, double, ETag>, false>
+ {
+ public:
+ 
+   void initializeStorage(int &n, int np, int ng) 
+   {
+     // Get new array domain, including "guards".
+ 
+     Interval<1> N(1, n);
+     Interval<2> vertDomain(N, N);
+ 
+     DomainLayout<2> layout(vertDomain);
+ 
+     Mesh mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
+ 
+     Centering<2> vert = canonicalCentering<2>(VertexType, Continuous, AllDim);
+ 
+     // Initialize the fields.
+ 
+     a_m.initialize(vert, layout, mesh);
+     b_m.initialize(vert, layout, mesh);
+   }
+ 
+   Field<Mesh, double, ETag> a_m, b_m;
+ };
+ 
+ template<class ETag>
+ class Doof2dStorage<Array<2, double, ETag>, true>
+ {
+ public:
+ 
+   void initializeStorage(int &n, int np, int ng) 
+   {
+     n = (n / np) * np;
+     
+     // Get new array domain.
+     
+     Interval<1> N(1, n);
+     Interval<2> newDomain(N, N);
+ 
+     // Create the block sizes.
+     
+     Loc<2> blocks(np, np);
+ 
+     // Create the partitioner:
+     // We set the internal guard layers to ng_m, and don't allocate external
+     // guard layers because all the problem implementations loop from 2 to n-1.
+     
+     UniformGridPartition<2> partition(blocks,
+                                       GuardLayers<2>(ng),
+                                       GuardLayers<2>(0));
+ 
+     // Create the layout.
+     
+     UniformGridLayout<2> layout(newDomain, partition, LayoutTag_t());
+ 
+     // Create the arrays.
+     
+     a_m.initialize(layout);
+     b_m.initialize(layout);
+   }
+ 
+   Array<2, double, ETag> a_m, b_m;
+ };
+ 
+ template<class Mesh, class ETag>
+ class Doof2dStorage<Field<Mesh, double, ETag>, true>
+ {
+ public:
+ 
+   void initializeStorage(int &n, int np, int ng) 
+   {
+     n = (n / np) * np;
+     
+     // Get new array domain.
+     
+     Interval<1> N(1, n);
+     Interval<2> newDomain(N, N);
+ 
+     // Create the block sizes.
+     
+     Loc<2> blocks(np, np);
+ 
+     // Create the partitioner:
+     // We set the internal guard layers to ng_m, and don't allocate external
+     // guard layers because all the problem implementations loop from 2 to n-1.
+     
+     UniformGridPartition<2> partition(blocks,
+                                       GuardLayers<2>(ng),
+                                       GuardLayers<2>(0));
+ 
+     // Create the layout.
+     
+     UniformGridLayout<2> layout(newDomain, partition, LayoutTag_t());
+ 
+     Mesh mesh(layout, Vector<2>(0.0), Vector<2>(1.0, 1.0));
+ 
+     Centering<2> vert = canonicalCentering<2>(VertexType, Continuous, AllDim);
+ 
+     // Initialize the fields.
+ 
+     a_m.initialize(vert, layout, mesh);
+     b_m.initialize(vert, layout, mesh);
+   }
+ 
+   Field<Mesh, double, ETag> a_m, b_m;
+ };
+ 
+ template<class Store>
+ struct StoreTraits
+ {
+   typedef typename Store::Engine_t Engine_t;
+   static const bool multiPatch = Engine_t::multiPatch;
+ };
+ 
+ 
+ //-----------------------------------------------------------------------------
+ // Doof2dBase class definitions.  We define this as a partially specialized
+ // class so it is easy to make subclasses work for Uniform MultiPatch
+ // (UMP) or not.
+ //-----------------------------------------------------------------------------
+ 
+ template<class Store>
+ class Doof2dBase :
+   public Implementation,
+   public Doof2dStorage<Store, StoreTraits<Store>::multiPatch>
+ {
+ public:
+ 
+   // Dummy constructor.
+   
+   Doof2dBase(int np = 1, int ng = 0) 
+   : np_m(np), ng_m(ng)
+   { }
+   
+   // Initialize function gets the size and adjusts the arrays.
+     
+   void initialize(int n) 
+   {
+     // Save the problem size.
+     
+     n_m = n;
+ 
+     // This call can decrease n_m to an integral multiple of np_m.
+     initializeStorage(n_m, np_m, ng_m);
+ 
+     // Set up domains for the internal cells.
+     
+     I = Interval<1>(2,n_m-1);
+     J = Interval<1>(2,n_m-1);
+ 
+     // Intialize Array element values.
+     
+     setInitialConditions();
+   }
+ 
+   // Return value for checking result of benchmark run.
+ 
+   double resultCheck() const { return check_m; }
+ 
+   // Return number of flops in this kernel.
+ 
+   double opCount() const { return ( 90 * (n_m - 2) * (n_m - 2) ); }
+ 
+ protected:
+ 
+   // Problem check value.
+ 
+   double check_m;
+ 
+   // Problem size/number of patches.
+ 
+   int n_m, np_m;
+   
+   // Guard layers.
+ 
+   int ng_m;
+ 
+   // Domains for stencil.
+   
+   Interval<1> I, J;
+ 
+ private:
+ 
+   void setInitialConditions()
+   {
+     // Initialize arrays.
+ 
+     a_m = 0.0;
+     b_m = 0.0;
+     
+     Pooma::blockAndEvaluate();
+   }
+ };
+ 
+ 
+ //-----------------------------------------------------------------------------
+ // Doof2dCppTran class definition, executing a C++ version of ForTran code.
+ //-----------------------------------------------------------------------------
+ 
+ template<class Store>
+ class Doof2dCppTran :
+   public Doof2dBase<Store>
+ {
+ public:
+ 
+   // Constructor allows us to specify the number of patches for each direction.
+   
+   Doof2dCppTran(int np = 1)
+     : Doof2dBase<Store>(np)
+   { }
+ 
+   // This is a C++Tran benchmark, perhaps using UMP.
+ 
+   const char* type() const { return CppTranType(); }
+   const char* qualification() const
+   {
+     typedef typename Store::Engine_t Engine_t;
+     return ::qualification(a_m).c_str();
+   }
+ 
+   void run() 
+   {
+     const double fact = 1.0 / 9.0;
+ 
+     int i, j, k;
+ 
+     // Run setup.
+ 
+     runSetup();
+     
+     // Run kernel.
+     
+     for (k = 0; k < 5; ++k)
+     {
+       for (j = 2; j <= n_m - 1; j++) 
+       {
+ 	for (i = 2; i <= n_m - 1; i++) 
+ 	{
+ 	  a_m(i,j) = fact *
+ 	    (b_m(i+1,j+1) + b_m(i+1,j  ) + b_m(i+1,j-1) +
+ 	     b_m(i  ,j+1) + b_m(i  ,j  ) + b_m(i  ,j-1) +
+ 	     b_m(i-1,j+1) + b_m(i-1,j  ) + b_m(i-1,j-1));
+ 	}
+       }
+       for (j = 2; j <= n_m-1; j++) 
+       {
+         for (i = 2; i <= n_m-1; i++) 
+ 	{
+ 	  b_m(i,j) = fact *
+ 	    (a_m(i+1,j+1) + a_m(i+1,j  ) + a_m(i+1,j-1) +
+ 	     a_m(i  ,j+1) + a_m(i  ,j  ) + a_m(i  ,j-1) +
+ 	     a_m(i-1,j+1) + a_m(i-1,j  ) + a_m(i-1,j-1));
+ 	}
+       }
+     }
+      
+     // Save result for checking.
+     
+     check_m = b_m(n_m / 2, n_m / 2);
+   }
+ 
+   void runSetup()
+   {
+     // Run setup.
+     
+     for (int j = 1; j <= n_m; j++) 
+     {
+       for (int i = 1; i <= n_m; i++) 
+       {
+ 	a_m(i,j) = 0.0;
+ 	b_m(i,j) = 0.0;
+       }
+     }
+     b_m(n_m/2,n_m/2) = 1000.0;
+   }
+ };
+ 
+ 
+ //-----------------------------------------------------------------------------
+ // Doof2dP2 class definition, executing Pooma data-parallel code.
+ //-----------------------------------------------------------------------------
+ 
+ template<class Store>
+ class Doof2dP2
+   : public Doof2dBase<Store>
+ {
+ public:
+ 
+   // Constructor allows us to specify the number of patches for each direction.
+   
+   Doof2dP2(int np = 1, int ng = 0)
+     : Doof2dBase<Store>(np,ng),
+       guarded_m(ng > 0)
+   { }
+ 
+   // This is a P2 benchmark, perhaps using UMP.
+ 
+   const char* type() const { return P2Type(); }
+   const char* qualification() const
+   {
+     typedef typename Store::Engine_t Engine_t;
+ 
+     std::string qual = ::qualification(a_m);
+ 
+     if (guarded_m)
+     {
+       PAssert(Engine_t::multiPatch);
+       return ("GC" + qual).c_str();
+     }
+     else
+     {
+       return qual.c_str();
+     }
+   }
+ 
+   void run() 
+   {
+     const double fact = 1.0 / 9.0;
+ 
+     int k;
+ 
+     // Run setup.
+ 
+     runSetup();
+ 
+     // Run kernel.
+     
+     for (k = 0; k < 5; ++k)
+     {
+       a_m(I,J) = fact *
+ 	(b_m(I+1,J+1) + b_m(I+1,J  ) + b_m(I+1,J-1) +
+ 	 b_m(I  ,J+1) + b_m(I  ,J  ) + b_m(I  ,J-1) +
+ 	 b_m(I-1,J+1) + b_m(I-1,J  ) + b_m(I-1,J-1));
+       b_m(I,J) = fact *
+ 	(a_m(I+1,J+1) + a_m(I+1,J  ) + a_m(I+1,J-1) +
+ 	 a_m(I  ,J+1) + a_m(I  ,J  ) + a_m(I  ,J-1) +
+ 	 a_m(I-1,J+1) + a_m(I-1,J  ) + a_m(I-1,J-1));
+     }
+ 
+     Pooma::blockAndEvaluate();
+ 
+     // Save result for checking.
+     
+     check_m = b_m(n_m / 2, n_m / 2);
+   }
+ 
+   void runSetup()
+   {
+     // Run setup.
+     
+     a_m = 0.0;
+     b_m = 0.0;
+     Pooma::blockAndEvaluate();
+     b_m(n_m/2,n_m/2) = 1000.0;
+   }
+ 
+ private:
+   bool guarded_m;
+ };
+ 
+ //-----------------------------------------------------------------------------
+ // Stencil DoofNinePt
+ //-----------------------------------------------------------------------------
+ 
+ class DoofNinePt
+ {
+ public:
+   template <class A>
+   inline
+   typename A::Element_t
+   operator()(const A& x, int i, int j) const
+   {
+     return ( (1.0/9.0) *
+              ( x.read(i+1,j+1) + x.read(i+1,j  ) + x.read(i+1,j-1) +
+                x.read(i  ,j+1) + x.read(i  ,j  ) + x.read(i  ,j-1) +
+                x.read(i-1,j+1) + x.read(i-1,j  ) + x.read(i-1,j-1) ) );
+   }
+ 
+   inline int lowerExtent(int) const { return 1; }
+   inline int upperExtent(int) const { return 1; }
+ 
+ };
+ 
+ //-----------------------------------------------------------------------------
+ // Doof2dP2Opt class definition, using a stencil for computation.
+ //-----------------------------------------------------------------------------
+ 
+ template<class Store>
+ class Doof2dP2Opt
+   : public Doof2dBase<Store>
+ {
+ public:
+ 
+   // Constructor allows us to specify the number of patches for each direction.
+   
+   Doof2dP2Opt(int np = 1, int ng = 0)
+     : Doof2dBase<Store>(np,ng),
+       guarded_m(ng > 0)
+   { }
+ 
+   // This is a P2 benchmark, perhaps using UMP.
+ 
+   const char* type() const { return "P2Opt"; }
+   const char* qualification() const
+   {
+     typedef typename Store::Engine_t Engine_t;
+     std::string qual = ::qualification(a_m);
+ 
+     if (guarded_m)
+     {
+       PAssert(Engine_t::multiPatch);
+       return ("GC" + qual).c_str();
+     }
+     else
+     {
+       return qual.c_str();
+     }
+   }
+ 
+   void run() 
+   {
+     int k;
+     Interval<2> IJ(I,J);
+ 
+     // Run setup.
+     
+     runSetup();
+ 
+     // Run kernel.
+     
+     for (k = 0; k < 5; ++k)
+     {
+       a_m(IJ) = stencil_m(b_m,IJ);
+ 
+       // Note we use this form of the stencil since adding guard cells can
+       // add external guard cells so the domain of a_m might be bigger than
+       // we expect, in which case stencil_m(a_m) would be bigger than IJ.
+ 
+       b_m(IJ) = stencil_m(a_m,IJ);
+     }
+ 
+     Pooma::blockAndEvaluate();
+ 
+     // Save result for checking.
+     
+     check_m = b_m(n_m / 2, n_m / 2);
+   }
+ 
+   void runSetup()
+   {
+     // Run setup.
+     
+     a_m = 0.0;
+     b_m = 0.0;
+     Pooma::blockAndEvaluate();
+     b_m(n_m/2,n_m/2) = 1000.0;
+ 
+   }
+ 
+ private:
+   bool guarded_m;
+   Stencil<DoofNinePt> stencil_m;
+ };
+ 
+ 
+ #endif // POOMA_BENCHMARKS_DOOF2D_H
+ 
+ // ACL:rcsinfo
+ // ----------------------------------------------------------------------
+ // $RCSfile: Doof2d.h,v $   $Author: sa_smith $
+ // $Revision: 1.34 $   $Date: 2000/07/04 05:06:36 $
+ // ----------------------------------------------------------------------
+ // ACL:rcsinfo
Index: Doof2dInC.c
===================================================================
RCS file: /home/pooma/Repository/r2/benchmarks/Doof2d/Doof2dInC.c,v
retrieving revision 1.13
diff -c -p -r1.13 Doof2dInC.c
*** Doof2dInC.c	2000/03/07 13:14:46	1.13
--- Doof2dInC.c	2001/09/28 03:34:28
***************
*** 43,96 ****
  extern "C" {
  #endif
  
  /* Doof2d kernels */
  
  void
  runDoof2dInCRestrict(double *restrict a, double *restrict b, int n) {
!   int i, j;
    double fact = 1.0 / 9.0;
  
!   for (j = 1; j <= n - 2; j++) {
!     for (i = 1; i <= n - 2; i++) {
!       b[i + n * j] = fact *
!         (a[i + 1 + n * (j + 1)] + a[i + 1 + n * j] + a[i + 1 + n * (j - 1)] +
! 	 a[i + n * (j + 1)] + a[i + n * j] + a[i + n * (j - 1)] +
!          a[i - 1 + n * (j + 1)] + a[i - 1 + n * j] + a[i - 1 + n * (j - 1)]);
      }
    }
  }
  
  void
  runDoof2dCoefsInCRestrict(double *restrict a, double* restrict b, 
    double* c, int n) {
!   int i, j;
    double fact = 1.0 / 9.0;
    const double c1 = c[0], c2 = c[1], c3 = c[2], c4 = c[3], c5 = c[4],
                 c6 = c[5], c7 = c[6], c8 = c[7], c9 = c[8];
  
!   for (j = 1; j <= n - 2; j++) {
!     for (i = 1; i <= n - 2; i++) {
!       b[i + n * j] = fact *
!         (c1 * a[i + 1 + n * (j + 1)] + c2 * a[i + 1 + n * j] +
!          c3 * a[i + 1 + n * (j - 1)] + c4 * a[i + n * (j + 1)] +
!          c5 * a[i + n * j] + c6 * a[i + n * (j - 1)] +
!          c7 * a[i - 1 + n * (j + 1)] + c8 * a[i - 1 + n * j] +
!          c9 * a[i - 1 + n * (j - 1)]);
      }
    }
  }
  
  void
! runDoof2dInC(double* a, double* b, int n) {
!   int i, j;
    double fact = 1.0 / 9.0;
  
!   for (j = 1; j <= n - 2; j++) {
!     for (i = 1; i <= n - 2; i++) {
!       b[i + n * j] = fact *
!         (a[i + 1 + n * (j + 1)] + a[i + 1 + n * j] + a[i + 1 + n * (j - 1)] +
  	 a[i + n * (j + 1)] + a[i + n * j] + a[i + n * (j - 1)] +
!          a[i - 1 + n * (j + 1)] + a[i - 1 + n * j] + a[i - 1 + n * (j - 1)]);
      }
    }
  }
--- 43,154 ----
  extern "C" {
  #endif
  
+ void
+ runDoof2dSetup(double* a, double* b, int n)
+ {
+   int i, j;
+ 
+   for (j = 0; j <= n - 1; j++)
+   {
+     for (i = 0; i <= n - 1; i++)
+     {
+       a[i + n * j] = 0.0;
+       b[i + n * j] = 0.0;
+     }
+   }
+   b[n / 2 - 1 + n * (n / 2 - 1)] = 1000.0;
+ }
+ 
  /* Doof2d kernels */
  
  void
  runDoof2dInCRestrict(double *restrict a, double *restrict b, int n) {
!   int i, j, k;
    double fact = 1.0 / 9.0;
  
!   runDoof2dSetup(a, b, n);
! 
!   for (k = 0; k < 5; ++k)
!   {
!     for (j = 1; j <= n - 2; j++) {
!       for (i = 1; i <= n - 2; i++) {
!         a[i + n * j] = fact *
!           (b[i + 1 + n * (j + 1)] + b[i + 1 + n * j] + b[i + 1 + n * (j - 1)] +
!            b[i + n * (j + 1)] + b[i + n * j] + b[i + n * (j - 1)] +
!            b[i - 1 + n * (j + 1)] + b[i - 1 + n * j] + b[i - 1 + n * (j - 1)]);
!       }
      }
+     for (j = 1; j <= n - 2; j++) {
+       for (i = 1; i <= n - 2; i++) {
+         b[i + n * j] = fact *
+           (a[i + 1 + n * (j + 1)] + a[i + 1 + n * j] + a[i + 1 + n * (j - 1)] +
+            a[i + n * (j + 1)] + a[i + n * j] + a[i + n * (j - 1)] +
+            a[i - 1 + n * (j + 1)] + a[i - 1 + n * j] + a[i - 1 + n * (j - 1)]);
+       }
+     }
    }
  }
  
  void
  runDoof2dCoefsInCRestrict(double *restrict a, double* restrict b, 
    double* c, int n) {
!   int i, j, k;
    double fact = 1.0 / 9.0;
    const double c1 = c[0], c2 = c[1], c3 = c[2], c4 = c[3], c5 = c[4],
                 c6 = c[5], c7 = c[6], c8 = c[7], c9 = c[8];
+ 
+   runDoof2dSetup(a, b, n);
  
!   for (k = 0; k < 5; ++k)
!   {
!     for (j = 1; j <= n - 2; j++) {
!       for (i = 1; i <= n - 2; i++) {
!         a[i + n * j] = fact *
!           (c1 * b[i + 1 + n * (j + 1)] + c2 * b[i + 1 + n * j] +
!            c3 * b[i + 1 + n * (j - 1)] + c4 * b[i + n * (j + 1)] +
!            c5 * b[i + n * j] + c6 * b[i + n * (j - 1)] +
!            c7 * b[i - 1 + n * (j + 1)] + c8 * b[i - 1 + n * j] +
!            c9 * b[i - 1 + n * (j - 1)]);
!       }
      }
+     for (j = 1; j <= n - 2; j++) {
+       for (i = 1; i <= n - 2; i++) {
+         b[i + n * j] = fact *
+           (c1 * a[i + 1 + n * (j + 1)] + c2 * a[i + 1 + n * j] +
+            c3 * a[i + 1 + n * (j - 1)] + c4 * a[i + n * (j + 1)] +
+            c5 * a[i + n * j] + c6 * a[i + n * (j - 1)] +
+            c7 * a[i - 1 + n * (j + 1)] + c8 * a[i - 1 + n * j] +
+            c9 * a[i - 1 + n * (j - 1)]);
+       }
+     }
    }
  }
  
  void
! runDoof2dInC(double* a, double* b, int n)
! {
!   int i, j, k;
    double fact = 1.0 / 9.0;
  
!   runDoof2dSetup(a, b, n);
! 
!   for (k = 0; k < 5; ++k)
!   {
!     for (j = 1; j <= n - 2; j++) {
!       for (i = 1; i <= n - 2; i++) {
!         a[i + n * j] = fact *
!           (b[i + 1 + n * (j + 1)] + b[i + 1 + n * j] + b[i + 1 + n * (j - 1)] +
!            b[i + n * (j + 1)] + b[i + n * j] + b[i + n * (j - 1)] +
!            b[i - 1 + n * (j + 1)] + b[i - 1 + n * j] + b[i - 1 + n * (j - 1)]);
!       }
!     }
!     for (j = 1; j <= n - 2; j++) {
!       for (i = 1; i <= n - 2; i++) {
!         b[i + n * j] = fact *
!           (a[i + 1 + n * (j + 1)] + a[i + 1 + n * j] + a[i + 1 + n * (j - 1)] +
  	 a[i + n * (j + 1)] + a[i + n * j] + a[i + n * (j - 1)] +
!            a[i - 1 + n * (j + 1)] + a[i - 1 + n * j] + a[i - 1 + n * (j - 1)]);
!       }
      }
    }
  }
*************** runDoof2dInC(double* a, double* b, int n
*** 98,116 ****
  void
  runDoof2dCoefsInC(double* a, double* b, 
    double* c, int n) {
!   int i, j;
    double fact = 1.0 / 9.0;
    const double c1 = c[0], c2 = c[1], c3 = c[2], c4 = c[3], c5 = c[4],
                 c6 = c[5], c7 = c[6], c8 = c[7], c9 = c[8];
  
!   for (j = 1; j <= n - 2; j++) {
!     for (i = 1; i <= n - 2; i++) {
!       b[i + n * j] = fact *
!         (c1 * a[i + 1 + n * (j + 1)] + c2 * a[i + 1 + n * j] +
!          c3 * a[i + 1 + n * (j - 1)] + c4 * a[i + n * (j + 1)] +
!          c5 * a[i + n * j] + c6 * a[i + n * (j - 1)] +
!          c7 * a[i - 1 + n * (j + 1)] + c8 * a[i - 1 + n * j] +
!          c9 * a[i - 1 + n * (j - 1)]);
      }
    }
  }
--- 156,189 ----
  void
  runDoof2dCoefsInC(double* a, double* b, 
    double* c, int n) {
!   int i, j, k;
    double fact = 1.0 / 9.0;
    const double c1 = c[0], c2 = c[1], c3 = c[2], c4 = c[3], c5 = c[4],
                 c6 = c[5], c7 = c[6], c8 = c[7], c9 = c[8];
  
!   runDoof2dSetup(a, b, n);
! 
!   for (k = 0; k < 5; ++k)
!   {
!     for (j = 1; j <= n - 2; j++) {
!       for (i = 1; i <= n - 2; i++) {
!         a[i + n * j] = fact *
!           (c1 * b[i + 1 + n * (j + 1)] + c2 * b[i + 1 + n * j] +
!            c3 * b[i + 1 + n * (j - 1)] + c4 * b[i + n * (j + 1)] +
!            c5 * b[i + n * j] + c6 * b[i + n * (j - 1)] +
!            c7 * b[i - 1 + n * (j + 1)] + c8 * b[i - 1 + n * j] +
!            c9 * b[i - 1 + n * (j - 1)]);
!       }
!     }
!     for (j = 1; j <= n - 2; j++) {
!       for (i = 1; i <= n - 2; i++) {
!         b[i + n * j] = fact *
!           (c1 * a[i + 1 + n * (j + 1)] + c2 * a[i + 1 + n * j] +
!            c3 * a[i + 1 + n * (j - 1)] + c4 * a[i + n * (j + 1)] +
!            c5 * a[i + n * j] + c6 * a[i + n * (j - 1)] +
!            c7 * a[i - 1 + n * (j + 1)] + c8 * a[i - 1 + n * j] +
!            c9 * a[i - 1 + n * (j - 1)]);
!       }
      }
    }
  }
Index: Doof2dInC.h
===================================================================
RCS file: /home/pooma/Repository/r2/benchmarks/Doof2d/Doof2dInC.h,v
retrieving revision 1.22
diff -c -p -r1.22 Doof2dInC.h
*** Doof2dInC.h	2000/03/07 13:14:46	1.22
--- Doof2dInC.h	2001/09/28 03:34:28
***************
*** 43,48 ****
--- 43,49 ----
  // function declarations
  
  extern "C" {
+   void runDoof2dSetup(double* a, double* b, int n);
    void runDoof2dInC(double* a, double* b, int n);
    void runDoof2dCoefsInC(double* a, double* b, double* c, int n);
    void runDoof2dInCRestrict(double* a, double* b,int n);
*************** public:
*** 108,120 ****
      check_m =  b_m[n_m / 2 - 1 + n_m * (n_m / 2 - 1)];
    }
  
    // Return value for checking result of benchmark run.
  
    double resultCheck() const { return check_m; }
  
    // Return number of flops in this kernel.
  
!   double opCount() const { return ( 9 * ((double)n_m - 2) * ((double)n_m - 2) ); }
  
  private:
  
--- 109,126 ----
      check_m =  b_m[n_m / 2 - 1 + n_m * (n_m / 2 - 1)];
    }
  
+   void runSetup()
+   {
+     runDoof2dSetup(a_m, b_m, n_m);
+   }
+ 
    // Return value for checking result of benchmark run.
  
    double resultCheck() const { return check_m; }
  
    // Return number of flops in this kernel.
  
!   double opCount() const { return ( 90 * ((double)n_m - 2) * ((double)n_m - 2) ); }
  
  private:
  
*************** private:
*** 123,130 ****
      // initialize the arrays.
      for (int j = 0; j < n_m; j++) {
        for (int i = 0; i < n_m; i++) {
! 	a_m[i + n_m * j] = 1.1 * n_m;
          b_m[i + n_m * j] = 0.0;
        }
      }
    }
--- 129,137 ----
      // initialize the arrays.
      for (int j = 0; j < n_m; j++) {
        for (int i = 0; i < n_m; i++) {
! 	a_m[i + n_m * j] = 0.0;
          b_m[i + n_m * j] = 0.0;
+         b_m[n_m / 2 - 1 + n_m * (n_m / 2 - 1)] = 1000.0;
        }
      }
    }
*************** public:
*** 199,211 ****
      check_m =  b_m[n_m / 2 - 1 + n_m * (n_m / 2 - 1)];
    }
  
    // Return value for checking result of benchmark run.
  
    double resultCheck() const { return check_m; }
  
    // Return number of flops in this kernel.
  
!   double opCount() const { return ( 18 * ((double)n_m - 2) * ((double)n_m - 2) ); }
  
  private:
  
--- 206,223 ----
      check_m =  b_m[n_m / 2 - 1 + n_m * (n_m / 2 - 1)];
    }
  
+   void runSetup()
+   {
+     runDoof2dSetup(a_m, b_m, n_m);
+   }
+ 
    // Return value for checking result of benchmark run.
  
    double resultCheck() const { return check_m; }
  
    // Return number of flops in this kernel.
  
!   double opCount() const { return ( 180 * ((double)n_m - 2) * ((double)n_m - 2) ); }
  
  private:
  
*************** private:
*** 214,223 ****
      // initialize the arrays.
      for (int j = 0; j < n_m; j++) {
        for (int i = 0; i < n_m; i++) {
! 	a_m[i + n_m * j] = 1.1 * n_m;
          b_m[i + n_m * j] = 0.0;
        }
      }
    }
  
    // Data Arrays.
--- 226,236 ----
      // initialize the arrays.
      for (int j = 0; j < n_m; j++) {
        for (int i = 0; i < n_m; i++) {
! 	a_m[i + n_m * j] = 0.0;
          b_m[i + n_m * j] = 0.0;
        }
      }
+     b_m[n_m / 2 - 1 + n_m * (n_m / 2 - 1)] = 1000.0;
    }
  
    // Data Arrays.
Index: Doof2dInCppTran.h
===================================================================
RCS file: Doof2dInCppTran.h
diff -N Doof2dInCppTran.h
*** /tmp/cvssYgjgf	Thu Sep 27 21:34:29 2001
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,237 ****
- // -*- C++ -*-
- // ACL:license
- // ----------------------------------------------------------------------
- // This software and ancillary information (herein called "SOFTWARE")
- // called POOMA (Parallel Object-Oriented Methods and Applications) is
- // made available under the terms described here.  The SOFTWARE has been
- // approved for release with associated LA-CC Number LA-CC-98-65.
- // 
- // Unless otherwise indicated, this SOFTWARE has been authored by an
- // employee or employees of the University of California, operator of the
- // Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
- // the U.S. Department of Energy.  The U.S. Government has rights to use,
- // reproduce, and distribute this SOFTWARE. The public may copy, distribute,
- // prepare derivative works and publicly display this SOFTWARE without 
- // charge, provided that this Notice and any statement of authorship are 
- // reproduced on all copies.  Neither the Government nor the University 
- // makes any warranty, express or implied, or assumes any liability or 
- // responsibility for the use of this SOFTWARE.
- // 
- // If SOFTWARE is modified to produce derivative works, such modified
- // SOFTWARE should be clearly marked, so as not to confuse it with the
- // version available from LANL.
- // 
- // For more information about POOMA, send e-mail to pooma@acl.lanl.gov,
- // or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
- // ----------------------------------------------------------------------
- // ACL:license
- 
- #ifndef POOMA_BENCHMARKS_DOOF2D_DOOF2DINCPPTRAN_H
- #define POOMA_BENCHMARKS_DOOF2D_DOOF2DINCPPTRAN_H
- 
- //-----------------------------------------------------------------------------
- // Classes Doof2dInCppTran and Doof2dCoefsInCppTran.
- //-----------------------------------------------------------------------------
- 
- // include files
- 
- #include "Pooma/Arrays.h"
- #include "Utilities/Benchmark.h"
- 
- #include <stdlib.h>
- 
- 
- //-----------------------------------------------------------------------------
- // Doof2dInCppTran class definition.
- //-----------------------------------------------------------------------------
- 
- class Doof2dInCppTran : public Implementation {
- public:
- 
-   // Typedefs for the Array types we'll be using here.
- 
-   typedef Array<2,double,Brick> Array2D;
- 
-   // This is a CppTran benchmark
- 
-   const char* type() const { return CppTranType(); }
- 
-   void initialize(int n) {
-     // get new array domain
-     Interval<1> N(1, n);
-     Interval<2> newDomain(N, N);
- 
-     // Reset the size of member Arrays.
-     a_m.initialize(newDomain);
-     b_m.initialize(newDomain);
- 
-     // Save the problem size.
-     n_m = n;
- 
-     // Intialize Array element values.
-     setInitialConditions();
-   }
- 
-   void run() {
-     const double fact = 1.0 / 9.0;
-     int i, j;
-     // run kernel
-     for (j = 2; j <= n_m-1; j++) {
-       for (i = 2; i <= n_m-1; i++) {
-         b_m(i,j) = fact *
-           (a_m(i+1,j+1) + a_m(i+1,j  ) + a_m(i+1,j-1) +
-            a_m(i  ,j+1) + a_m(i  ,j  ) + a_m(i  ,j-1) +
-            a_m(i-1,j+1) + a_m(i-1,j  ) + a_m(i-1,j-1));
-       }
-     }
-      
-     // save result for checking 
-     check_m = b_m(n_m / 2, n_m / 2);
-   }
- 
-   // Return value for checking result of benchmark run.
- 
-   double resultCheck() const { return check_m; }
- 
-   // Return number of flops in this kernel.
- 
-   double opCount() const { return ( 9 * ((double)n_m - 2) * ((double)n_m - 2) ); }
- 
- private:
- 
-   void setInitialConditions()
-   {
-     // initialize arrays
-     for (int j=1; j<=n_m; ++j) {
-       for (int i=1; i<=n_m; ++i) {
-         a_m(i,j) = 1.1 * n_m;
-         b_m(i,j) = 0.0;
-       }
-     }
-   }
- 
-   // 2D Data Arrays.
- 
-   Array2D a_m, b_m;
- 
-   // Problem check value.
- 
-   double check_m;
- 
-   // Problem Size.
- 
-   int n_m;
- 
- };
- 
- 
- //-----------------------------------------------------------------------------
- // Doof2dCoefsInCppTran class definition.
- //-----------------------------------------------------------------------------
- 
- class Doof2dCoefsInCppTran : public Implementation {
- public:
- 
-   // Typedefs for the Array types we'll be using here.
- 
-   typedef Array<2,double,Brick> Array2D;
-   typedef Array<1,double,Brick> Array1D;
- 
-   Doof2dCoefsInCppTran() : c_m(Interval<1>(1, 9)) {
- 
-     // Initialize rand() random number generator.
-     srand(12345U);
- 
-     // Loop over Array elements and assign random values.
-     for (int i = 1; i <= 9; i++)
-       c_m(i) = rand() / (static_cast<double>(RAND_MAX)+1);
-   }
- 
-   // This is a CppTran benchmark
- 
-   const char* type() const { return CppTranType(); }
- 
-   void initialize(int n) {
-     // get new array domain
-     Interval<1> N(1, n);
-     Interval<2> newDomain(N, N);
- 
-     // Reset the size of member Arrays.
-     a_m.initialize(newDomain);
-     b_m.initialize(newDomain);
- 
-     // Save the problem size.
-     n_m = n;
- 
-     // Intialize Array element values.
-     setInitialConditions();
-   }
- 
-   // run benchmark
-   void run() {
-     const int n = n_m;
-     const double fact = 1.0 / 9.0;
-     int i, j;
-     const double c1 = c_m(1), c2 = c_m(2), c3 = c_m(3), c4 = c_m(4),
-       c5 = c_m(5), c6 = c_m(6), c7 = c_m(7), c8 = c_m(8), c9 = c_m(9);
-     // run kernel
-     for (j = 2; j <= n-1; j++) {
-       for (i = 2; i <= n-1; i++) {
- 	b_m(i,j) = fact *
-           (c1 * a_m(i+1,j+1) + c2 * a_m(i+1,j  ) + c3 * a_m(i+1,j-1) + 
-            c4 * a_m(i  ,j+1) + c5 * a_m(i  ,j  ) + c6 * a_m(i  ,j-1) +
-            c7 * a_m(i-1,j+1) + c8 * a_m(i-1,j  ) + c9 * a_m(i-1,j-1));
-       }
-     }
- 
-     // save results for checking
-     check_m = b_m(n / 2, n / 2);
-   }
- 
-   // Return value for checking result of benchmark run.
- 
-   double resultCheck() const { return check_m; }
- 
-   // Return number of flops in this kernel.
- 
-   double opCount() const { return ( 18 * ((double)n_m - 2) * ((double)n_m - 2) ); }
- 
- private:
- 
-   void setInitialConditions()
-   {
-     // initialize arrays
-     for (int j=1; j<=n_m; ++j) {
-       for (int i=1; i<=n_m; ++i) {
-         a_m(i,j) = 1.1 * n_m;
-         b_m(i,j) = 0.0;
-       }
-     }
-   }
- 
-   // 2D Data Arrays.
- 
-   Array2D a_m, b_m;
- 
-   // Coefficient array.
- 
-   Array1D c_m;
- 
-   // Problem check value.
- 
-   double check_m;
- 
-   // Problem Size.
- 
-   int n_m;
- 
- };
- 
- #endif // POOMA_BENCHMARKS_DOOF2D_DOOF2DINCPPTRAN_H
- 
- // ACL:rcsinfo
- // ----------------------------------------------------------------------
- // $RCSfile: Doof2dInCppTran.h,v $   $Author: swhaney $
- // $Revision: 1.22 $   $Date: 2000/03/07 13:14:47 $
- // ----------------------------------------------------------------------
- // ACL:rcsinfo
--- 0 ----
Index: Doof2dInP2.h
===================================================================
RCS file: Doof2dInP2.h
diff -N Doof2dInP2.h
*** /tmp/cvsyWLPre	Thu Sep 27 21:34:29 2001
--- /dev/null	Fri Mar 23 21:37:44 2001
***************
*** 1,629 ****
- // -*- C++ -*-
- // ACL:license
- // ----------------------------------------------------------------------
- // This software and ancillary information (herein called "SOFTWARE")
- // called POOMA (Parallel Object-Oriented Methods and Applications) is
- // made available under the terms described here.  The SOFTWARE has been
- // approved for release with associated LA-CC Number LA-CC-98-65.
- // 
- // Unless otherwise indicated, this SOFTWARE has been authored by an
- // employee or employees of the University of California, operator of the
- // Los Alamos National Laboratory under Contract No. W-7405-ENG-36 with
- // the U.S. Department of Energy.  The U.S. Government has rights to use,
- // reproduce, and distribute this SOFTWARE. The public may copy, distribute,
- // prepare derivative works and publicly display this SOFTWARE without 
- // charge, provided that this Notice and any statement of authorship are 
- // reproduced on all copies.  Neither the Government nor the University 
- // makes any warranty, express or implied, or assumes any liability or 
- // responsibility for the use of this SOFTWARE.
- // 
- // If SOFTWARE is modified to produce derivative works, such modified
- // SOFTWARE should be clearly marked, so as not to confuse it with the
- // version available from LANL.
- // 
- // For more information about POOMA, send e-mail to pooma@acl.lanl.gov,
- // or visit the POOMA web page at http://www.acl.lanl.gov/pooma/.
- // ----------------------------------------------------------------------
- // ACL:license
- 
- #ifndef POOMA_BENCHMARKS_DOOF2D_DOOF2DINP2_H
- #define POOMA_BENCHMARKS_DOOF2D_DOOF2DINP2_H
- 
- //-----------------------------------------------------------------------------
- // Classes Doof2dInP2UnOpt, Doof2dInP2Op, Doof2dCoefsInP2UnOpt, and
- //   Doof2dCoefsInP2Opt.
- //-----------------------------------------------------------------------------
- 
- // include files
- 
- #include "Pooma/Arrays.h"
- #include "Pooma/Fields.h"
- #include "Utilities/Benchmark.h"
- 
- #include <stdlib.h>
- 
- 
- //-----------------------------------------------------------------------------
- // Doof2dInP2Field class definition.
- //-----------------------------------------------------------------------------
- 
- class Doof2dInP2Field : public Implementation
- {
- public:
- 
-   // Typedefs for the Array types we'll be using here.
- 
-   typedef Field<UniformRectilinearMesh<2>, double, Brick> Field2D;
- 
-   // This is a Pooma II benchmark
- 
-   const char *type() const { return "Field"; }
-   const char *qualification() const { return "UnOpt"; }
- 
-   void initialize(int n)
-   {
-     // get new array domain
-     Interval<1> N(1, n);
-     Interval<2> newDomain(N, N);
- 
-     DomainLayout<2> layout(newDomain);
-     Centering<2> vert = canonicalCentering<2>(VertexType, Continuous);
-     Vector<2> origin(0.0, 0.0);
-     Vector<2> spacings(1.0, 1.0);
- 
-     // Reset the size of member Arrays.
-     a_m.fieldEngine() = Field2D(vert, layout, origin, spacings).fieldEngine();
-     b_m.fieldEngine() = Field2D(vert, layout, origin, spacings).fieldEngine();
- 
-     // reset Intervals for diffusion stencil
-     I = Interval<1>(2,n-1);
-     J = Interval<1>(2,n-1);
- 
-     // Save the problem size.
-     n_m = n;
- 
-     // Intialize Arrays.
-     setInitialConditions();
-   }
- 
-   // run benchmark
-   void run()
-   {
-     // run kernel
-     b_m(I,J) = fact_s *
-       (a_m(I+1,J+1) + a_m(I+1,J  ) + a_m(I+1,J-1) +
-        a_m(I  ,J+1) + a_m(I  ,J  ) + a_m(I  ,J-1) +
-        a_m(I-1,J+1) + a_m(I-1,J  ) + a_m(I-1,J-1));
- 
-     Pooma::blockAndEvaluate();
- 
-     // save results for checking
-     check_m = b_m(n_m / 2, n_m / 2);
-   }
- 
-   // Return value for checking result of benchmark run.
- 
-   double resultCheck() const { return check_m; }
- 
-   // Return number of flops in this kernel.
- 
-   double opCount() const { return ( 9 * ((double) n_m - 2) * (n_m - 2) ); }
- 
- private:
- 
-   void setInitialConditions()
-   {
-     // Intialize Array element values.
-     a_m = 1.1 * n_m;
-     b_m = 0.0;
- 
-     Pooma::blockAndEvaluate();
-   }
- 
-   // 2D Data Arrays.
- 
-   Field2D a_m, b_m;
- 
-   // 1D Intervals
- 
-   Interval<1> I, J;
- 
-   // Problem check value.
- 
-   double check_m;
- 
-   // Problem Size.
- 
-   int n_m;
- 
-   // constant factor
- 
-   static const double fact_s;
- };
- 
- // static initializer
- const double Doof2dInP2Field::fact_s = 1.0 / 9.0;
- 
- //-----------------------------------------------------------------------------
- // Doof2dInP2UnOpt class definition.
- //-----------------------------------------------------------------------------
- 
- class Doof2dInP2UnOpt : public Implementation
- {
- public:
- 
-   // Typedefs for the Array types we'll be using here.
- 
-   typedef Array<2,double,Brick> Array2D;
- 
-   // This is a Pooma II benchmark
- 
-   const char *type() const { return P2Type(); }
-   const char *qualification() const { return "UnOpt"; }
- 
-   void initialize(int n) {
-     // get new array domain
-     Interval<1> N(1, n);
-     Interval<2> newDomain(N, N);
- 
-     // Reset the size of member Arrays.
-     a_m.initialize(newDomain);
-     b_m.initialize(newDomain);
- 
-     // reset Intervals for diffusion stencil
-     I = Interval<1>(2,n-1);
-     J = Interval<1>(2,n-1);
- 
-     // Save the problem size.
-     n_m = n;
- 
-     // Intialize Arrays.
-     setInitialConditions();
-   }
- 
-   // run benchmark
-   void run()
-   {
-     // run kernel
-     b_m(I,J) = fact_s *
-       (a_m(I+1,J+1) + a_m(I+1,J  ) + a_m(I+1,J-1) +
-        a_m(I  ,J+1) + a_m(I  ,J  ) + a_m(I  ,J-1) +
-        a_m(I-1,J+1) + a_m(I-1,J  ) + a_m(I-1,J-1));
- 
-     Pooma::blockAndEvaluate();
- 
-     // save results for checking
-     check_m = b_m(n_m / 2, n_m / 2);
-   }
- 
-   // Return value for checking result of benchmark run.
- 
-   double resultCheck() const { return check_m; }
- 
-   // Return number of flops in this kernel.
- 
-   double opCount() const { return ( 9 * ((double) n_m - 2) * (n_m - 2) ); }
- 
- private:
- 
-   void setInitialConditions()
-   {
-     // Intialize Array element values.
-     a_m = 1.1 * n_m;
-     b_m = 0.0;
- 
-     Pooma::blockAndEvaluate();
-   }
- 
-   // 2D Data Arrays.
- 
-   Array2D a_m, b_m;
- 
-   // 1D Intervals
- 
-   Interval<1> I, J;
- 
-   // Problem check value.
- 
-   double check_m;
- 
-   // Problem Size.
- 
-   int n_m;
- 
-   // constant factor
- 
-   static const double fact_s;
- };
- 
- // static initializer
- const double Doof2dInP2UnOpt::fact_s = 1.0 / 9.0;
- 
- 
- //-----------------------------------------------------------------------------
- // Doof2dCoefsInP2UnOpt class definition.
- //-----------------------------------------------------------------------------
- 
- class Doof2dCoefsInP2UnOpt : public Implementation
- {
- public:
- 
-   // Typedefs for the Array types we'll be using here.
- 
-   typedef Array<2,double,Brick> Array2D;
-   typedef Array<1,double,Brick> Array1D;
- 
-   Doof2dCoefsInP2UnOpt() : c_m(Interval<1>(1, 9)) { 
- 
-     // Initialize rand() random number generator.
-     srand(12345U);
- 
-     // Loop over Array elements and assign random values.
-     for (int i = 1; i <= 9; i++)
-       c_m(i) = rand() / (static_cast<double>(RAND_MAX)+1);
-   }
- 
-   // This is a Pooma II benchmark
- 
-   const char* type() const { return P2Type(); }
-   const char *qualification() const { return "UnOpt"; }
- 
-   void initialize(int n) {
-     // get new array domains
-     Interval<1> N(1, n);
-     Interval<2> newDomain(N, N);
- 
-     // Reset the size of member Arrays.
-     a_m.initialize(newDomain);
-     b_m.initialize(newDomain);
- 
-     // reset Intervals for diffusion stencil
-     I = Interval<1>(2,n-1);
-     J = Interval<1>(2,n-1);
- 
-     // Save the problem size.
-     n_m = n;
- 
-     // Intialize Arrays.
-     setInitialConditions();
-   }
- 
-   // run benchmark
-   void run()
-   {
-     // run kernel
-     b_m(I,J) = fact_s *
-       (c_m(1) * a_m(I+1,J+1) + c_m(2) * a_m(I+1,J  ) + c_m(3) * a_m(I+1,J-1) + 
-        c_m(4) * a_m(I  ,J+1) + c_m(5) * a_m(I  ,J  ) + c_m(6) * a_m(I  ,J-1) +
-        c_m(7) * a_m(I-1,J+1) + c_m(8) * a_m(I-1,J  ) + c_m(9) * a_m(I-1,J-1));
- 
-     Pooma::blockAndEvaluate();
- 
-     // save results for checking
-     check_m = b_m(n_m / 2, n_m / 2);
-   }
- 
-   // Return value for checking result of benchmark run.
- 
-   double resultCheck() const { return check_m; }
- 
-   // Return number of flops in this kernel.
- 
-   double opCount() const { 
-     return ( 18 * ((double)n_m - 2) * ((double)n_m - 2) ); }
- 
- private:
- 
-   void setInitialConditions()
-   {
-     // Intialize Array element values.
-     a_m = 1.1 * n_m;
-     b_m = 0.0;
- 
-     Pooma::blockAndEvaluate();
-   }
- 
-   // 2D Data Arrays.
- 
-   Array2D a_m, b_m;
- 
-   // 1D Intervals
- 
-   Interval<1> I, J;
- 
-   // Coefficient array.
- 
-   Array1D c_m;
- 
-   // Problem check value.
- 
-   double check_m;
- 
-   // Problem Size.
- 
-   int n_m;
- 
-   // constant coefficient
- 
-   static const double fact_s;
- };
- 
- // static initializer
- const double Doof2dCoefsInP2UnOpt::fact_s = 1.0 / 9.0;
- 
- 
- //-----------------------------------------------------------------------------
- // Stencil DoofNinePt
- //-----------------------------------------------------------------------------
- 
- class DoofNinePt
- {
- public:
-   DoofNinePt() {}
- 
-   template <class A>
-   inline
-   typename A::Element_t
-   operator()(const A& x, int i, int j) const
-   {
-     return ( fact_s *
-              ( x(i+1,j+1) + x(i+1,j  ) + x(i+1,j-1) +
-                x(i  ,j+1) + x(i  ,j  ) + x(i  ,j-1) +
-                x(i-1,j+1) + x(i-1,j  ) + x(i-1,j-1) ) );
-   }
- 
-   inline int lowerExtent(int) const { return 1; }
-   inline int upperExtent(int) const { return 1; }
- 
- private:
-   static const double fact_s;
- };
- 
- const double DoofNinePt::fact_s = 1.0/9.0;
- 
- 
- //-----------------------------------------------------------------------------
- // Doof2dInP2Opt class definition.
- //-----------------------------------------------------------------------------
- 
- class Doof2dInP2Opt : public Implementation {
- public:
- 
-   // Typedefs for the Array types we'll be using here.
- 
-   typedef Array<2,double,Brick> Array2D;
- 
-   // This is a Pooma II benchmark
- 
-   const char* type() const { return P2Type(); }
- 
-   void initialize(int n) {
-     // get new array domain
-     Interval<1> N(1, n);
-     Interval<2> newDomain(N, N);
- 
-     // Reset the size of member Arrays.
-     a_m.initialize(newDomain);
-     b_m.initialize(newDomain);
- 
-     // reset Intervals for diffusion stencil
-     I = Interval<1>(2,n-1);
-     J = Interval<1>(2,n-1);
- 
-     // Save the problem size.
-     n_m = n;
- 
-     // Intialize Arrays.
-     setInitialConditions();
-   }
- 
-   // run benchmark
-   void run()
-   {
-     // apply diffusion stencil
-     b_m(I,J) = stencil_m( a_m );
- 
-     Pooma::blockAndEvaluate();
- 
-     // save results for checking
-     check_m = b_m(n_m/2,n_m/2);
-   }
- 
-   // Return value for checking result of benchmark run.
- 
-   double resultCheck() const { return check_m; }
- 
-   // Return number of flops in this kernel.
- 
-   double opCount() const { 
-     return ( 9 * ((double)n_m - 2) * ((double)n_m - 2) ); }
- 
- private:
- 
-   void setInitialConditions()
-   {
-     // Intialize Array element values.
-     a_m = 1.1 * n_m;
-     b_m = 0.0;
- 
-     Pooma::blockAndEvaluate();
-   }
- 
-   // 2D Data Arrays.
- 
-   Array2D a_m, b_m;
- 
-   // 1D Intervals
- 
-   Interval<1> I, J;
- 
-   // Stencil object
- 
-   Stencil<DoofNinePt> stencil_m;
- 
-   // Problem check value.
- 
-   double check_m;
- 
-   // Problem Size.
- 
-   int n_m;
- 
- };
- 
- 
- //-----------------------------------------------------------------------------
- // Stencil DoofNinePtCoefs
- //-----------------------------------------------------------------------------
- 
- class DoofNinePtCoefs
- {
- public:
-   // constructor
-   DoofNinePtCoefs(double* coefs)
-     : c1_m(coefs[0]), c2_m(coefs[1]), c3_m(coefs[2]), c4_m(coefs[3]),
-       c5_m(coefs[4]), c6_m(coefs[5]), c7_m(coefs[6]), c8_m(coefs[7]),
-       c9_m(coefs[8]) {}
- 
-   // apply method for evaluating stencil
-   template <class A>
-   inline
-   typename A::Element_t
-   operator()(const A& x, int i, int j) const
-   {
-     return ( fact_s *
-              ( c1_m*x(i+1,j+1) + c2_m*x(i+1,j  ) + c3_m*x(i+1,j-1) +
-                c4_m*x(i  ,j+1) + c5_m*x(i  ,j  ) + c6_m*x(i  ,j-1) +
-                c7_m*x(i-1,j+1) + c8_m*x(i-1,j  ) + c9_m*x(i-1,j-1) ) );
-   }
- 
-   inline int lowerExtent(int) const { return 1; }
-   inline int upperExtent(int) const { return 1; }
- 
- private:
-   static const double fact_s;
-   const double c1_m, c2_m, c3_m, c4_m, c5_m, c6_m, c7_m, c8_m, c9_m;
- };
- 
- const double DoofNinePtCoefs::fact_s = 1.0/9.0;
- 
- 
- //-----------------------------------------------------------------------------
- // Doof2dCoefsInP2Opt class definitions.
- //-----------------------------------------------------------------------------
- 
- class Doof2dCoefsInP2Opt : public Implementation {
- public:
- 
-   // Typedefs for the Array types we'll be using here.
- 
-   typedef Array<2,double,Brick> Array2D;
- 
-   // constructor
-   Doof2dCoefsInP2Opt()
-   { 
-     // Initialize rand() random number generator.
-     srand(12345U);
- 
-     // Loop over array elements and assign random values.
-     double coefs[9];
-     for (int i = 0; i < 9; i++)
-       coefs[i] = rand() / (static_cast<double>(RAND_MAX)+1);
- 
-     // initialize our stencil object
-     stencil_m = 
-       new Stencil<DoofNinePtCoefs>(static_cast<double *>(coefs));
-   }
- 
-   // destructor
-   ~Doof2dCoefsInP2Opt()
-   {
-     delete stencil_m;
-   }
- 
-   // This is a Pooma II benchmark
- 
-   const char* type() const { return P2Type(); }
- 
-   void initialize(int n) {
-     // get new array domain
-     Interval<1> N(1, n);
-     Interval<2> newDomain(N, N);
- 
-     // Reset the size of member Arrays.
-     a_m.initialize(newDomain);
-     b_m.initialize(newDomain);
- 
-     // reset Intervals for diffusion stencil
-     I = Interval<1>(2,n-1);
-     J = Interval<1>(2,n-1);
- 
-     // Save the problem size.
-     n_m = n;
- 
-     // Intialize Arrays.
-     setInitialConditions();
-   }
- 
-   // run benchmark
-   void run()
-   {
-     // apply diffusion stencil
-     b_m(I,J) = (*stencil_m)( a_m );
- 
-     Pooma::blockAndEvaluate();
- 
-     // save results for checking
-     check_m = b_m(n_m/2,n_m/2);
-   }
- 
-   // Return value for checking result of benchmark run.
- 
-   double resultCheck() const { return check_m; }
- 
-   // Return number of flops in this kernel.
- 
-   double opCount() const { 
-     return ( 18 * ((double)n_m - 2) * ((double)n_m - 2) ); }
- 
- private:
- 
-   void setInitialConditions()
-   {
-     // Intialize Array element values.
-     a_m = 1.1 * n_m;
-     b_m = 0.0;
- 
-     Pooma::blockAndEvaluate();
-   }
- 
-   // 2D Data Arrays.
- 
-   Array2D a_m, b_m;
- 
-   // 1D Intervals
- 
-   Interval<1> I, J;
- 
-   // Stencil object
- 
-   Stencil<DoofNinePtCoefs> *stencil_m;
- 
-   // Problem check value.
- 
-   double check_m;
- 
-   // Problem Size.
- 
-   int n_m;
- };
- 
- 
- #endif // POOMA_BENCHMARKS_DOOF2D_DOOF2DINP2_H
- 
- // ACL:rcsinfo
- // ----------------------------------------------------------------------
- // $RCSfile: Doof2dInP2.h,v $   $Author: oldham $
- // $Revision: 1.39 $   $Date: 2001/08/30 01:14:23 $
- // ----------------------------------------------------------------------
- // ACL:rcsinfo
--- 0 ----
