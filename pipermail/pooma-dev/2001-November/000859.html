<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Identifying Loop Invariant Data Members: Mark Mitchell's Approach
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Identifying%20Loop%20Invariant%20Data%20Members%3A%20Mark%20Mitchell%27s%20Approach&In-Reply-To=%3C20011105123140.A19107%40codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000858.html">
   <LINK REL="Next"  HREF="000860.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Identifying Loop Invariant Data Members: Mark Mitchell's Approach</H1>
    <B>Jeffrey Oldham</B> 
    <A HREF="mailto:pooma-dev%40codesourcery.com?Subject=Re%3A%20Identifying%20Loop%20Invariant%20Data%20Members%3A%20Mark%20Mitchell%27s%20Approach&In-Reply-To=%3C20011105123140.A19107%40codesourcery.com%3E"
       TITLE="Identifying Loop Invariant Data Members: Mark Mitchell's Approach">oldham at codesourcery.com
       </A><BR>
    <I>Mon Nov  5 20:31:40 UTC 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000858.html">Reminder to Submit Timesheets
</A></li>
        <LI>Next message: <A HREF="000860.html">Patch: Fix Typographical Error
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#859">[ date ]</a>
              <a href="thread.html#859">[ thread ]</a>
              <a href="subject.html#859">[ subject ]</a>
              <a href="author.html#859">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>	The attached patch partially implements Mark Mitchell's idea
to mark loop-invariant Engine data members so the KCC optimizer can
move them out of inner loops.

	Without this patch or a similar idea by Stephen Smith, the
intermediate C code produced by KCC for the loops in
src/Evaluator/InlineEvaluator.h's evaluate() reveals reloading of
engine data members such as strides_m.  These data values are
invariant during the evaluate() loop.  To notify the optimizer of the
invariance, a separate constant structure containing these values is
constructed just before the loop begins.  This constant information is
passed into the operations performed within the loop.  Thus, the
optimizer can determine the values are loop-invariant and may be
hoisted out of the loop.  For example, consider the evaluate() loop
for the two-dimensional version of src/Evaluator/InlineEvaluator.h:

    for (int i1=0; i1&lt;e1; ++i1)
      for (int i0=0; i0&lt;e0; ++i0)
	op(lhs(i0,i1),rhs.read(i0,i1));

This is modified to

    const LHSLoopInvariant_t lli = lhs.loopInvariant();
    const RHSLoopInvariant_t rli = rhs.loopInvariant();
    for (int i1=0; i1&lt;e1; ++i1)
      for (int i0=0; i0&lt;e0; ++i0)
	op(lhs(lli, i0,i1),rhs.read(rli, i0,i1));

	Implementing this idea requires three steps:

1) modifying src/Evaluator/InlineEvaluator.h and other similar loops,
2) modifying containers, e.g., Array and Field, and related classes to
   create loop-invariant structures, and
3) modifying operations that use these structures.

	The first step is sketched above.  Containers are assumed to
have a 'loopInvariant' member function returning a 'LoopInvariant_t'
structure.  These containers' 'read' and 'operator()' members are
assumed to accept and use these packages.

	Implementing containers' 'LoopInvariant_t' structures mostly
involves passing the work onto the containers' engines.  For example,
Array's 'loopInvariant' consists of

    inline const
    LoopInvariant_t loopInvariant() const { return engine_m.loopInvariant(); }

Each engine has its own 'LoopInvariant_t' nested class storing its
loop-invariant data members.  For example, the Brick engine, derived
from BrickBase, stores the 'strides_m' data member.

   class LoopInvariant_t {
   public:
 
     inline int *strides() { return strides_m; }
     inline int&amp; strides(const int i) { return strides_m[i]; }
     inline const int *strides() const { return strides_m; }
     inline int strides(const int i) const { return strides_m[i]; }
 
   private:
 
     int strides_m[Dim];
   };

The engine's 'loopInvariant' returns this structure:

   inline const LoopInvariant_t loopInvariant() const { return invariant_m; }

from its 'invariant_m' data member.

	Unfortunately, the creation of loop-invariant structures must
also ripple through the expression code, as created by PETE.  The
loop-invariant structure for a PETE expression, represented by a tree,
is an analogous tree of loop-invariant structures.  For example, a
binary node's loop-invariant structure consists of its two children's
loop-invariant structures.

	Using containers' LoopInvariant_t structures consists of
changing containers' and engines' 'read' and 'operator()' member
functions and the PETE evaluation mechanisms.

	The 'read' and 'operator()' member functions receive an
additional LoopInvariant_t parameter, whose contents are used if
appropriate.  For example, a Brick 'read' function changes from

    template &lt;int Dim, class T&gt;
    inline T Engine&lt;Dim,T,Brick&gt;::
    read(int i1, int i2) const
    {
      PAssert(Dim == 2);
      return data_m[offset(i1,i2)];
    }

to

    template &lt;int Dim, class T&gt;
    inline T Engine&lt;Dim,T,Brick&gt;::
    read(const LoopInvariant_t&amp; li, int i1, int i2) const
    {
      PAssert(Dim == 2);
      return li.data()[offset(li,i1,i2)];
    }

Here, li's data() returns a loop-invariant copy of the 'data_m'
pointer and 'offset' also uses the loop-invariant object li.

	The PETE evaluation functions also need to support
loop-invariant objects.  The forEach functions in src/PETE/ForEach.h
propagate evaluation through the expression objects.  A copy of the
ForEach 'apply' member functions accepting loop-invariant objects need
to be added.  Evaluation at the expression leaves are handled by
'apply' functions, which should be modified in a way similar to the
'read' and 'operator()' functions so the loop-invariant objects'
contents are used.

	Stencil writers supply 'operator()' functions.  Stephen Smith
supplied a patch so these functions' parameters need not include
loop-invariant objects.  This idea is not incorporated in the first
attached patch.  Stephen Smith's patch is also attached.

	To permit Pooma users to directly call 'read' and 'operator()'
functions, the original interface should be maintained, at least for
containers.  Thus, parallel code must be maintained, a disadvantage of
this technique.

Thanks,
Jeffrey D. Oldham
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">oldham at codesourcery.com</A>
-------------- next part --------------
Index: benchmarks/Doof2d/Doof2d.h
===================================================================
RCS file: /home/pooma/Repository/r2/benchmarks/Doof2d/Doof2d.h,v
retrieving revision 1.3
diff -c -p -r1.3 Doof2d.h
*** benchmarks/Doof2d/Doof2d.h	2001/10/16 18:26:09	1.3
--- benchmarks/Doof2d/Doof2d.h	2001/11/05 19:28:25
*************** public:
*** 360,373 ****
      
      for (k = 0; k &lt; 5; ++k)
      {
        for (j = 2; j &lt;= n_m - 1; j++) 
        {
  	for (i = 2; i &lt;= n_m - 1; i++) 
  	{
  	  a_m(i,j) = fact *
! 	    (b_m(i+1,j+1) + b_m(i+1,j  ) + b_m(i+1,j-1) +
! 	     b_m(i  ,j+1) + b_m(i  ,j  ) + b_m(i  ,j-1) +
! 	     b_m(i-1,j+1) + b_m(i-1,j  ) + b_m(i-1,j-1));
  	}
        }
        for (j = 2; j &lt;= n_m-1; j++) 
--- 360,375 ----
      
      for (k = 0; k &lt; 5; ++k)
      {
+       const typename Store::LoopInvariant_t&amp; ali = a_m.loopInvariant();
+       const typename Store::LoopInvariant_t&amp; bli = b_m.loopInvariant();
        for (j = 2; j &lt;= n_m - 1; j++) 
        {
  	for (i = 2; i &lt;= n_m - 1; i++) 
  	{
  	  a_m(i,j) = fact *
! 	    (b_m.read(bli,i+1,j+1) + b_m.read(bli,i+1,j  ) + b_m.read(bli,i+1,j-1) +
! 	     b_m.read(bli,i  ,j+1) + b_m.read(bli,i  ,j  ) + b_m.read(bli,i  ,j-1) +
! 	     b_m.read(bli,i-1,j+1) + b_m.read(bli,i-1,j  ) + b_m.read(bli,i-1,j-1));
  	}
        }
        for (j = 2; j &lt;= n_m-1; j++) 
*************** public:
*** 375,383 ****
          for (i = 2; i &lt;= n_m-1; i++) 
  	{
  	  b_m(i,j) = fact *
! 	    (a_m(i+1,j+1) + a_m(i+1,j  ) + a_m(i+1,j-1) +
! 	     a_m(i  ,j+1) + a_m(i  ,j  ) + a_m(i  ,j-1) +
! 	     a_m(i-1,j+1) + a_m(i-1,j  ) + a_m(i-1,j-1));
  	}
        }
      }
--- 377,385 ----
          for (i = 2; i &lt;= n_m-1; i++) 
  	{
  	  b_m(i,j) = fact *
! 	    (a_m.read(ali,i+1,j+1) + a_m.read(ali,i+1,j  ) + a_m.read(ali,i+1,j-1) +
! 	     a_m.read(ali,i  ,j+1) + a_m.read(ali,i  ,j  ) + a_m.read(ali,i  ,j-1) +
! 	     a_m.read(ali,i-1,j+1) + a_m.read(ali,i-1,j  ) + a_m.read(ali,i-1,j-1));
  	}
        }
      }
*************** public:
*** 496,507 ****
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, int i, int j) const
    {
      return ( (1.0/9.0) *
!              ( x.read(i+1,j+1) + x.read(i+1,j  ) + x.read(i+1,j-1) +
!                x.read(i  ,j+1) + x.read(i  ,j  ) + x.read(i  ,j-1) +
!                x.read(i-1,j+1) + x.read(i-1,j  ) + x.read(i-1,j-1) ) );
    }
  
    inline int lowerExtent(int) const { return 1; }
--- 498,510 ----
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, const typename A::LoopInvariant_t&amp; li,
! 	     int i, int j) const
    {
      return ( (1.0/9.0) *
!              ( x.read(li,i+1,j+1) + x.read(li,i+1,j  ) + x.read(li,i+1,j-1) +
!                x.read(li,i  ,j+1) + x.read(li,i  ,j  ) + x.read(li,i  ,j-1) +
!                x.read(li,i-1,j+1) + x.read(li,i-1,j  ) + x.read(li,i-1,j-1) ) );
    }
  
    inline int lowerExtent(int) const { return 1; }
Index: src/Array/Array.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Array/Array.h,v
retrieving revision 1.144
diff -c -p -r1.144 Array.h
*** src/Array/Array.h	2001/09/14 22:37:56	1.144
--- src/Array/Array.h	2001/11/05 19:28:26
*************** struct View1Implementation&lt;Array&lt;Dim, T,
*** 136,141 ****
--- 136,142 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // The return types are pretty simple here.
    
*************** struct View1Implementation&lt;Array&lt;Dim, T,
*** 146,175 ****
    
    template&lt;class S1, class Combine&gt;
    inline static 
!   Type_t make(const Subject_t &amp;a, const S1 &amp;s1,
  	      const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine()(s);
!     }
  
    template&lt;class S1, class S2, class Combine&gt;
    inline static 
    Type_t make(const Subject_t &amp;a,
  	      const S1 &amp;s1, const S2 &amp;s2,
  	      const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine()(s);
!     }
  
    template&lt;class S1, class S2, class S3,
      class Combine&gt;
--- 147,177 ----
    
    template&lt;class S1, class Combine&gt;
    inline static 
!   Type_t make(const Subject_t &amp;a,
! 	      const S1 &amp;s1,
  	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine()(s);
!   }
  
    template&lt;class S1, class S2, class Combine&gt;
    inline static 
    Type_t make(const Subject_t &amp;a,
  	      const S1 &amp;s1, const S2 &amp;s2,
  	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine()(s);
!   }
  
    template&lt;class S1, class S2, class S3,
      class Combine&gt;
*************** struct View1Implementation&lt;Array&lt;Dim, T,
*** 177,190 ****
    Type_t make(const Subject_t &amp;a,
  	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
  	      const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine()(s);
!     }
  
    template&lt;class S1, class S2, class S3, class S4,
      class Combine&gt;
--- 179,192 ----
    Type_t make(const Subject_t &amp;a,
  	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
  	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine()(s);
!   }
  
    template&lt;class S1, class S2, class S3, class S4,
      class Combine&gt;
*************** struct View1Implementation&lt;Array&lt;Dim, T,
*** 193,206 ****
  	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
  	      const S4 &amp;s4,
  	      const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine()(s);
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class Combine&gt;
--- 195,208 ----
  	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
  	      const S4 &amp;s4,
  	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine()(s);
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class Combine&gt;
*************** struct View1Implementation&lt;Array&lt;Dim, T,
*** 209,222 ****
  	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
  	      const S4 &amp;s4, const S5 &amp;s5,
  	      const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4, s5));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine()(s);
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class Combine&gt;
--- 211,224 ----
  	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
  	      const S4 &amp;s4, const S5 &amp;s5,
  	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine()(s);
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class Combine&gt;
*************** struct View1Implementation&lt;Array&lt;Dim, T,
*** 225,238 ****
  	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
  	      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
  	      const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine()(s);
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class S7, class Combine&gt;
--- 227,240 ----
  	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
  	      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
  	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine()(s);
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class S7, class Combine&gt;
*************** struct View1Implementation&lt;Array&lt;Dim, T,
*** 242,366 ****
  	      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
  	      const S7 &amp;s7,
  	      const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine()(s);
!     }
  
    // Read only versions.
    
    template&lt;class S1, class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a, const S1 &amp;s1,
! 	                  const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine().read(s);
!     }
  
    template&lt;class S1, class S2, class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 	                  const S1 &amp;s1, const S2 &amp;s2,
! 	                  const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine().read(s);
!     }
  
    template&lt;class S1, class S2, class S3,
      class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 	                  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	                  const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine().read(s);
!     }
  
    template&lt;class S1, class S2, class S3, class S4,
      class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 	                  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	                  const S4 &amp;s4,
! 	                  const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine().read(s);
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 	                  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	                  const S4 &amp;s4, const S5 &amp;s5,
! 	                  const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4, s5));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine().read(s);
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 	                  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	                  const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 	                  const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine().read(s);
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class S7, class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 	                  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	                  const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 	                  const S7 &amp;s7,
! 	                  const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
!         &quot;Array view bounds error.&quot;);
  #endif
!       return a.engine().read(s);
!     }
  };
  
  // Non-single-valued implementation. Works for general domains
  // including Nodes and INodes.
  
--- 244,599 ----
  	      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
  	      const S7 &amp;s7,
  	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine()(s);
!   }
! 
!   template&lt;class S1, class Combine&gt;
!   inline static 
!   Type_t make(const Subject_t &amp;a,
! 	      const LoopInvariant_t &amp;li,
! 	      const S1 &amp;s1,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine()(li, s);
!   }
! 
!   template&lt;class S1, class S2, class Combine&gt;
!   inline static 
!   Type_t make(const Subject_t &amp;a,
! 	      const LoopInvariant_t &amp;li,
! 	      const S1 &amp;s1, const S2 &amp;s2,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine()(li, s);
!   }
! 
!   template&lt;class S1, class S2, class S3,
!     class Combine&gt;
!   inline static 
!   Type_t make(const Subject_t &amp;a,
! 	      const LoopInvariant_t &amp;li,
! 	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine()(li, s);
!   }
! 
!   template&lt;class S1, class S2, class S3, class S4,
!     class Combine&gt;
!   inline static 
!   Type_t make(const Subject_t &amp;a,
! 	      const LoopInvariant_t &amp;li,
! 	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	      const S4 &amp;s4,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine()(li, s);
!   }
! 
!   template&lt;class S1, class S2, class S3, class S4, class S5,
!     class Combine&gt;
!   inline static 
!   Type_t make(const Subject_t &amp;a,
! 	      const LoopInvariant_t &amp;li,
! 	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	      const S4 &amp;s4, const S5 &amp;s5,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine()(li, s);
!   }
  
+   template&lt;class S1, class S2, class S3, class S4, class S5,
+     class S6, class Combine&gt;
+   inline static 
+   Type_t make(const Subject_t &amp;a,
+ 	      const LoopInvariant_t &amp;li,
+ 	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
+ 	      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
+ 	      const Combine &amp;)
+   {
+     Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
+ #if POOMA_BOUNDS_CHECK
+     PInsist(contains(a.domain(), s),
+ 	    &quot;Array view bounds error.&quot;);
+ #endif
+     return a.engine()(li, s);
+   }
+ 
+   template&lt;class S1, class S2, class S3, class S4, class S5,
+     class S6, class S7, class Combine&gt;
+   inline static 
+   Type_t make(const Subject_t &amp;a,
+ 	      const LoopInvariant_t &amp;li,
+ 	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
+ 	      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
+ 	      const S7 &amp;s7,
+ 	      const Combine &amp;)
+   {
+     Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
+ #if POOMA_BOUNDS_CHECK
+     PInsist(contains(a.domain(), s),
+ 	    &quot;Array view bounds error.&quot;);
+ #endif
+     return a.engine()(li, s);
+   }
+ 
    // Read only versions.
    
    template&lt;class S1, class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a, const S1 &amp;s1,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine().read(s);
!   }
  
    template&lt;class S1, class S2, class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 		      const S1 &amp;s1, const S2 &amp;s2,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine().read(s);
!   }
  
    template&lt;class S1, class S2, class S3,
      class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 		      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine().read(s);
!   }
  
    template&lt;class S1, class S2, class S3, class S4,
      class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 		      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		      const S4 &amp;s4,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine().read(s);
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 		      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		      const S4 &amp;s4, const S5 &amp;s5,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine().read(s);
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 		      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine().read(s);
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class S7, class Combine&gt;
    inline static 
    ReadType_t makeRead(const Subject_t &amp;a,
! 		      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 		      const S7 &amp;s7,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine().read(s);
!   }
! 
!   template&lt;class S1, class Combine&gt;
!   inline static 
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const LoopInvariant_t &amp;li,
! 		      const S1 &amp;s1,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
  #endif
!     return a.engine().read(li, s);
!   }
! 
!   template&lt;class S1, class S2, class Combine&gt;
!   inline static 
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const LoopInvariant_t &amp;li,
! 		      const S1 &amp;s1, const S2 &amp;s2,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine().read(li, s);
!   }
! 
!   template&lt;class S1, class S2, class S3,
!     class Combine&gt;
!   inline static 
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const LoopInvariant_t &amp;li,
! 		      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine().read(li, s);
!   }
! 
!   template&lt;class S1, class S2, class S3, class S4,
!     class Combine&gt;
!   inline static 
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const LoopInvariant_t &amp;li,
! 		      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		      const S4 &amp;s4,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine().read(li, s);
!   }
! 
!   template&lt;class S1, class S2, class S3, class S4, class S5,
!     class Combine&gt;
!   inline static 
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const LoopInvariant_t &amp;li,
! 		      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		      const S4 &amp;s4, const S5 &amp;s5,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine().read(li, s);
!   }
! 
!   template&lt;class S1, class S2, class S3, class S4, class S5,
!     class S6, class Combine&gt;
!   inline static 
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const LoopInvariant_t &amp;li,
! 		      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine().read(li, s);
!   }
! 
!   template&lt;class S1, class S2, class S3, class S4, class S5,
!     class S6, class S7, class Combine&gt;
!   inline static 
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const LoopInvariant_t &amp;li,
! 		      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 		      const S7 &amp;s7,
! 		      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
! #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
! 	    &quot;Array view bounds error.&quot;);
! #endif
!     return a.engine().read(li, s);
!   }
  };
  
+ 
  // Non-single-valued implementation. Works for general domains
  // including Nodes and INodes.
  
*************** struct View1Implementation&lt;Array&lt;Dim, T,
*** 370,375 ****
--- 603,609 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce the template parameters for the output type.
    
*************** struct View1Implementation&lt;Array&lt;Dim, T,
*** 393,593 ****
    template&lt;class S1, class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a, const S1 &amp;s1,
! 	          const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!       return Type_t(
! 		NewEE_t::apply(a.engine(), s),
! 		NewED_t::apply(a.engine(), s));
!     }
  
    template&lt;class S1, class S2, class Combine&gt;
    static 
!   Type_t make(const Subject_t &amp;a, const S1 &amp;s1,
! 	          const S2 &amp;s2, const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!       return Type_t(
! 	    NewEE_t::apply(a.engine(), s),
! 		NewED_t::apply(a.engine(), s));
!     }
  
    template&lt;class S1, class S2, class S3,
      class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a,
! 	          const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	          const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!       return Type_t(
! 		NewEE_t::apply(a.engine(), s),
! 		NewED_t::apply(a.engine(), s));
!     }
  
    template&lt;class S1, class S2, class S3, class S4,
      class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a,
! 	          const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	          const S4 &amp;s4,
! 	          const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!       return Type_t(
! 		NewEE_t::apply(a.engine(), s),
! 		NewED_t::apply(a.engine(), s));
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a,
! 	          const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	          const S4 &amp;s4, const S5 &amp;s5,
! 	          const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4, s5));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!       return Type_t(
! 		NewEE_t::apply(a.engine(), s),
! 		NewED_t::apply(a.engine(), s));
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a,
! 	          const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	          const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 	          const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!       return Type_t(
! 		NewEE_t::apply(a.engine(), s),
! 		NewED_t::apply(a.engine(), s));
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class S7, class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a,
! 	          const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	          const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 	          const S7 &amp;s7,
! 	          const Combine &amp;)
!     {
!       Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
  #if POOMA_BOUNDS_CHECK
!       PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!       return Type_t(
! 		NewEE_t::apply(a.engine(), s),
! 		NewED_t::apply(a.engine(), s));
!     }
  
    // Read-only versions.
    
    template&lt;class S1, class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a, const S1 &amp;s1,
! 	              const Combine &amp;c)
!     {
!       return make(a, s1, c);
!     }
  
    template&lt;class S1, class S2, class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a, const S1 &amp;s1,
! 	              const S2 &amp;s2, const Combine &amp;c)
!     {
!       return make(a, s1, s2, c);
!     }
  
    template&lt;class S1, class S2, class S3,
      class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a,
! 	              const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	              const Combine &amp;c)
!     {
!       return make(a, s1, s2, s3, c);
!     }
  
    template&lt;class S1, class S2, class S3, class S4,
      class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a,
! 	              const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	              const S4 &amp;s4, const Combine &amp;c)
!     {
!       return make(a, s1, s2, s3, s4, c);
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a,
! 	              const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	              const S4 &amp;s4, const S5 &amp;s5, const Combine &amp;c)
!     {
!       return make(a, s1, s2, s3, s4, s5, c);
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6,
      class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a,
! 	              const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	              const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 	              const Combine &amp;c)
!     {
!       return make(a, s1, s2, s3, s4, s5, s6, c);
!     }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class S7,
      class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a,
! 	              const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	              const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 	              const S7 &amp;s7, const Combine &amp;c)
!     {
!       return make(a, s1, s2, s3, s4, s5, s6, s7, c);
!     }
  };
  
  // General version.
--- 627,906 ----
    template&lt;class S1, class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a, const S1 &amp;s1,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!     return Type_t(
! 		  NewEE_t::apply(a.engine(), s),
! 		  NewED_t::apply(a.engine(), s));
!   }
  
    template&lt;class S1, class S2, class Combine&gt;
    static 
!   Type_t make(const Subject_t &amp;a,
! 	      const S1 &amp;s1, const S2 &amp;s2,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!     return Type_t(
! 		  NewEE_t::apply(a.engine(), s),
! 		  NewED_t::apply(a.engine(), s));
!   }
  
    template&lt;class S1, class S2, class S3,
      class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a,
! 	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!     return Type_t(
! 		  NewEE_t::apply(a.engine(), s),
! 		  NewED_t::apply(a.engine(), s));
!   }
  
    template&lt;class S1, class S2, class S3, class S4,
      class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a,
! 	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	      const S4 &amp;s4,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!     return Type_t(
! 		  NewEE_t::apply(a.engine(), s),
! 		  NewED_t::apply(a.engine(), s));
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a,
! 	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	      const S4 &amp;s4, const S5 &amp;s5,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!     return Type_t(
! 		  NewEE_t::apply(a.engine(), s),
! 		  NewED_t::apply(a.engine(), s));
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a,
! 	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!     return Type_t(
! 		  NewEE_t::apply(a.engine(), s),
! 		  NewED_t::apply(a.engine(), s));
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class S7, class Combine&gt;
    static 
    Type_t make(const Subject_t &amp;a,
! 	      const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 	      const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 	      const S7 &amp;s7,
! 	      const Combine &amp;)
!   {
!     Domain s(Combine::make(a, s1, s2, s3, s4, s5, s6, s7));
  #if POOMA_BOUNDS_CHECK
!     PInsist(contains(a.domain(), s),
  	    &quot;Array view bounds error.&quot;);
  #endif
  
!     return Type_t(
! 		  NewEE_t::apply(a.engine(), s),
! 		  NewED_t::apply(a.engine(), s));
!   }
  
    // Read-only versions.
    
    template&lt;class S1, class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a, const S1 &amp;s1,
! 		  const Combine &amp;c)
!   {
!     return make(a, s1, c);
!   }
  
    template&lt;class S1, class S2, class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a, const S1 &amp;s1,
! 		  const S2 &amp;s2, const Combine &amp;c)
!   {
!     return make(a, s1, s2, c);
!   }
  
    template&lt;class S1, class S2, class S3,
      class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a,
! 		  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		  const Combine &amp;c)
!   {
!     return make(a, s1, s2, s3, c);
!   }
  
    template&lt;class S1, class S2, class S3, class S4,
      class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a,
! 		  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		  const S4 &amp;s4, const Combine &amp;c)
!   {
!     return make(a, s1, s2, s3, s4, c);
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a,
! 		  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		  const S4 &amp;s4, const S5 &amp;s5, const Combine &amp;c)
!   {
!     return make(a, s1, s2, s3, s4, s5, c);
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6,
      class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a,
! 		  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		  const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 		  const Combine &amp;c)
!   {
!     return make(a, s1, s2, s3, s4, s5, s6, c);
!   }
  
    template&lt;class S1, class S2, class S3, class S4, class S5,
      class S6, class S7,
      class Combine&gt;
    inline static 
    Type_t makeRead(const Subject_t &amp;a,
! 		  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		  const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 		  const S7 &amp;s7, const Combine &amp;c)
!   {
!     return make(a, s1, s2, s3, s4, s5, s6, s7, c);
!   }
! 
!   template&lt;class S1, class Combine&gt;
!   inline static 
!   Type_t makeRead(const Subject_t &amp;a,
!                   const LoopInvariant_t &amp;li,
!                   const S1 &amp;s1,
! 	          const Combine &amp;c)
!   {
!     return make(a, li, s1, c);
!   }
! 
!   template&lt;class S1, class S2, class Combine&gt;
!   inline static 
!   Type_t makeRead(const Subject_t &amp;a,
!                   const LoopInvariant_t &amp;li,
!                   const S1 &amp;s1, const S2 &amp;s2, const Combine &amp;c)
!   {
!     return make(a, li, s1, s2, c);
!   }
! 
!   template&lt;class S1, class S2, class S3,
!     class Combine&gt;
!   inline static 
!   Type_t makeRead(const Subject_t &amp;a,
!                   const LoopInvariant_t &amp;li,
! 		  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		  const Combine &amp;c)
!   {
!     return make(a, li, s1, s2, s3, c);
!   }
! 
!   template&lt;class S1, class S2, class S3, class S4,
!     class Combine&gt;
!   inline static 
!   Type_t makeRead(const Subject_t &amp;a,
!                   const LoopInvariant_t &amp;li,
! 		  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		  const S4 &amp;s4, const Combine &amp;c)
!   {
!     return make(a, li, s1, s2, s3, s4, c);
!   }
! 
!   template&lt;class S1, class S2, class S3, class S4, class S5,
!     class Combine&gt;
!   inline static 
!   Type_t makeRead(const Subject_t &amp;a,
!                   const LoopInvariant_t &amp;li,
! 		  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		  const S4 &amp;s4, const S5 &amp;s5, const Combine &amp;c)
!   {
!     return make(a, li, s1, s2, s3, s4, s5, c);
!   }
! 
!   template&lt;class S1, class S2, class S3, class S4, class S5,
!     class S6,
!     class Combine&gt;
!   inline static 
!   Type_t makeRead(const Subject_t &amp;a,
!                   const LoopInvariant_t &amp;li,
! 		  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		  const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 		  const Combine &amp;c)
!   {
!     return make(a, li, s1, s2, s3, s4, s5, s6, c);
!   }
! 
!   template&lt;class S1, class S2, class S3, class S4, class S5,
!     class S6, class S7,
!     class Combine&gt;
!   inline static 
!   Type_t makeRead(const Subject_t &amp;a,
!                   const LoopInvariant_t &amp;li,
! 		  const S1 &amp;s1, const S2 &amp;s2, const S3 &amp;s3,
! 		  const S4 &amp;s4, const S5 &amp;s5, const S6 &amp;s6,
! 		  const S7 &amp;s7, const Combine &amp;c)
!   {
!     return make(a, li, s1, s2, s3, s4, s5, s6, s7, c);
!   }
  };
  
  // General version.
*************** struct View1&lt;Array&lt;Dim, T, EngineTag&gt;, D
*** 598,603 ****
--- 911,917 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce domains for the output type.
    // At some point, we need to fix NewDomain1; until then, use
*************** struct View1&lt;Array&lt;Dim, T, EngineTag&gt;, D
*** 634,639 ****
--- 948,961 ----
      {
        return Dispatch_t::makeRead(a, s1, Combine_t());
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t &amp;li,
+ 		      const Domain &amp;s1)
+     {
+       return Dispatch_t::makeRead(a, li, s1, Combine_t());
+     }
  };
  
  // View0 deals with the special case of read() and
*************** struct View0&lt;Array&lt;Dim, T, EngineTag&gt; &gt;
*** 651,656 ****
--- 973,979 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce domains for the output type.
    // At some point, we need to fix NewDomain1; until then, use
*************** struct View0&lt;Array&lt;Dim, T, EngineTag&gt; &gt;
*** 686,691 ****
--- 1009,1020 ----
      {
        return make(a);
      }
+ 
+   inline static ReadType_t makeRead(const Subject_t &amp;a,
+ 				    const LoopInvariant_t &amp;li)
+     {
+       return make(a, li);
+     }
  };
  
  // AltView0 avoids an instantiation problem that arises when two
*************** struct View1&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 729,734 ****
--- 1058,1064 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // The return types.
    
*************** struct View1&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 756,761 ****
--- 1086,1103 ----
  #endif
        return a.engine().read(s1);
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t &amp;li,
+ 		      int s1)
+     { 
+ #if POOMA_BOUNDS_CHECK
+       PInsist(contains(a.domain(), Loc&lt;1&gt;(s1)),
+ 	    &quot;Array view bounds error.&quot;);
+ #endif
+       return a.engine().read(li, s1);
+     }
  };
  
  template&lt;int D1, class T1, class E1, int D2, class T2, class E2&gt;
*************** struct View1&lt;Array&lt;D1, T1, E1&gt;, Array&lt;D2
*** 765,770 ****
--- 1107,1113 ----
    typedef Array&lt;D2, T2, E2&gt; Array2_t;
  
    typedef IndirectionTag&lt;Array1_t, Array2_t&gt; Tag_t;
+   // HERE
  
    // The return types.
    
*************** struct View2&lt;Array&lt;Dim, T, EngineTag&gt;, S
*** 795,800 ****
--- 1138,1144 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce domains for the output type.
    
*************** struct View2&lt;Array&lt;Dim, T, EngineTag&gt;, S
*** 818,827 ****
  
    // Functions that create the view.
    
    inline static
!   Type_t make(const Subject_t &amp;a, const Sub1 &amp;s1, const Sub2 &amp;s2)
      {
!       return Dispatch_t::make(a, s1, s2, Combine_t());
      }
    
    inline static
--- 1162,1180 ----
  
    // Functions that create the view.
    
+   inline static
+   Type_t make(const Subject_t &amp;a, const Sub1 &amp;s1, const Sub2 &amp;s2)
+     {
+       return Dispatch_t::make(a, s1, s2, Combine_t());
+     }
+ 
+   // FIXME: Convert other dimensions' versions.
    inline static
!   Type_t make(const Subject_t &amp;a,
! 	      const LoopInvariant_t &amp;li,
! 	      const Sub1 &amp;s1, const Sub2 &amp;s2)
      {
!       return Dispatch_t::make(a, li, s1, s2, Combine_t());
      }
    
    inline static
*************** struct View2&lt;Array&lt;Dim, T, EngineTag&gt;, S
*** 829,834 ****
--- 1182,1195 ----
      {
        return Dispatch_t::makeRead(a, s1, s2, Combine_t());
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      const Sub1 &amp;s1, const Sub2 &amp;s2)
+     {
+       return Dispatch_t::makeRead(a, li, s1, s2, Combine_t());
+     }
  };
  
  template&lt;int Dim, class T, class EngineTag&gt;
*************** struct View2&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 837,842 ****
--- 1198,1204 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // The return types.
    
*************** struct View2&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 855,860 ****
--- 1217,1236 ----
        return a.engine()(s1, s2);
      }
    
+   // FIXME: Convert other dimensions' versions.
+   inline static
+   Type_t make(const Subject_t &amp;a,
+ 	      const LoopInvariant_t &amp;li,
+ 	      int s1, int s2)
+     {
+ #if POOMA_BOUNDS_CHECK
+       PInsist(contains(a.domain(), Loc&lt;2&gt;(s1, s2)),
+ 	    &quot;Array view bounds error.&quot;);
+ #endif
+       // HERE
+       return a.engine()(li, s1, s2);
+     }
+ 
    inline static
    ReadType_t makeRead(const Subject_t &amp;a, int s1, int s2)
      {
*************** struct View2&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 864,869 ****
--- 1240,1257 ----
  #endif
        return a.engine().read(s1, s2);
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      int s1, int s2)
+     {
+ #if POOMA_BOUNDS_CHECK
+       PInsist(contains(a.domain(), Loc&lt;2&gt;(s1, s2)),
+ 	    &quot;Array view bounds error.&quot;);
+ #endif
+       return a.engine().read(li, s1, s2);
+     }
  };
  
  // These are for views of the form a(b, c, d).
*************** struct View3&lt;Array&lt;Dim, T, EngineTag&gt;, S
*** 875,880 ****
--- 1263,1269 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce domains for the output type.
    
*************** struct View3&lt;Array&lt;Dim, T, EngineTag&gt;, S
*** 911,916 ****
--- 1300,1314 ----
      {
        return Dispatch_t::makeRead(a, s1, s2, s3, Combine_t());
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      const Sub1 &amp;s1, const Sub2 &amp;s2, 
+ 		      const Sub3 &amp;s3)
+     {
+       return Dispatch_t::makeRead(a, li, s1, s2, s3, Combine_t());
+     }
  };
  
  template&lt;int Dim, class T, class EngineTag&gt;
*************** struct View3&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 919,924 ****
--- 1317,1323 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // The return types.
    
*************** struct View3&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 946,951 ****
--- 1345,1362 ----
  #endif
        return a.engine().read(s1, s2, s3);
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      int s1, int s2, int s3)
+     {
+ #if POOMA_BOUNDS_CHECK
+       PInsist(contains(a.domain(), Loc&lt;3&gt;(s1, s2, s3)),
+ 	    &quot;Array view bounds error.&quot;);
+ #endif
+       return a.engine().read(li, s1, s2, s3);
+     }
  };
  
  // These are for views of the form a(b, c, d, e).
*************** struct View4&lt;Array&lt;Dim, T, EngineTag&gt;, 
*** 958,963 ****
--- 1369,1375 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce domains for the output type.
    
*************** struct View4&lt;Array&lt;Dim, T, EngineTag&gt;, 
*** 989,999 ****
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a, const Sub1 &amp;s1, const Sub2 &amp;s2, 
!     const Sub3 &amp;s3, const Sub4 &amp;s4)
      {
        return Dispatch_t::makeRead(a, s1, s2, s3, s4, Combine_t());
      }
  };
  
  template&lt;int Dim, class T, class EngineTag&gt;
--- 1401,1421 ----
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const Sub1 &amp;s1, const Sub2 &amp;s2, 
! 		      const Sub3 &amp;s3, const Sub4 &amp;s4)
      {
        return Dispatch_t::makeRead(a, s1, s2, s3, s4, Combine_t());
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      const Sub1 &amp;s1, const Sub2 &amp;s2, 
+ 		      const Sub3 &amp;s3, const Sub4 &amp;s4)
+     {
+       return Dispatch_t::makeRead(a, li, s1, s2, s3, s4, Combine_t());
+     }
  };
  
  template&lt;int Dim, class T, class EngineTag&gt;
*************** struct View4&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1002,1007 ****
--- 1424,1430 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // The return types.
    
*************** struct View4&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1029,1034 ****
--- 1452,1469 ----
  #endif
        return a.engine().read(s1, s2, s3, s4);
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      int s1, int s2, int s3, int s4)
+     {
+ #if POOMA_BOUNDS_CHECK
+       PInsist(contains(a.domain(), Loc&lt;4&gt;(s1, s2, s3, s4)),
+ 	    &quot;Array view bounds error.&quot;);
+ #endif
+       return a.engine().read(li, s1, s2, s3, s4);
+     }
  };
  
  // These are for views of the form a(b, c, d, e, f).
*************** struct View5&lt;Array&lt;Dim, T, EngineTag&gt;, 
*** 1041,1046 ****
--- 1476,1482 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce domains for the output type.
    
*************** struct View5&lt;Array&lt;Dim, T, EngineTag&gt;, 
*** 1072,1082 ****
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a, const Sub1 &amp;s1, const Sub2 &amp;s2, 
!     const Sub3 &amp;s3, const Sub4 &amp;s4, const Sub5 &amp;s5)
      {
        return Dispatch_t::makeRead(a, s1, s2, s3, s4, s5, Combine_t());
      }
  };
  
  template&lt;int Dim, class T, class EngineTag&gt;
--- 1508,1528 ----
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const Sub1 &amp;s1, const Sub2 &amp;s2, 
! 		      const Sub3 &amp;s3, const Sub4 &amp;s4, const Sub5 &amp;s5)
      {
        return Dispatch_t::makeRead(a, s1, s2, s3, s4, s5, Combine_t());
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      const Sub1 &amp;s1, const Sub2 &amp;s2, 
+ 		      const Sub3 &amp;s3, const Sub4 &amp;s4, const Sub5 &amp;s5)
+     {
+       return Dispatch_t::makeRead(a, li, s1, s2, s3, s4, s5, Combine_t());
+     }
  };
  
  template&lt;int Dim, class T, class EngineTag&gt;
*************** struct View5&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1085,1090 ****
--- 1531,1537 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // The return types.
    
*************** struct View5&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1094,1101 ****
    // Functions that perform the indexing.
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a, int s1, int s2, int s3, 
!     int s4, int s5)
      {
  #if POOMA_BOUNDS_CHECK
        PInsist(contains(a.domain(), Loc&lt;5&gt;(s1, s2, s3, s4, s5)),
--- 1541,1549 ----
    // Functions that perform the indexing.
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      int s1, int s2, int s3, 
! 		      int s4, int s5)
      {
  #if POOMA_BOUNDS_CHECK
        PInsist(contains(a.domain(), Loc&lt;5&gt;(s1, s2, s3, s4, s5)),
*************** struct View5&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1105,1110 ****
--- 1553,1571 ----
      }
    
    inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      int s1, int s2, int s3, 
+ 		      int s4, int s5)
+     {
+ #if POOMA_BOUNDS_CHECK
+       PInsist(contains(a.domain(), Loc&lt;5&gt;(s1, s2, s3, s4, s5)),
+ 	    &quot;Array view bounds error.&quot;);
+ #endif
+       return a.engine().read(li, s1, s2, s3, s4, s5);
+     }
+   
+   inline static
    Type_t make(const Subject_t &amp;a, int s1, int s2, int s3, int s4, int s5)
      {
  #if POOMA_BOUNDS_CHECK
*************** struct View6&lt;Array&lt;Dim, T, EngineTag&gt;, 
*** 1126,1131 ****
--- 1587,1593 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce domains for the output type.
    
*************** struct View6&lt;Array&lt;Dim, T, EngineTag&gt;, 
*** 1157,1167 ****
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a, const Sub1 &amp;s1, const Sub2 &amp;s2, 
!     const Sub3 &amp;s3, const Sub4 &amp;s4, const Sub5 &amp;s5, const Sub6 &amp;s6)
      {
        return Dispatch_t::makeRead(a, s1, s2, s3, s4, s5, s6, Combine_t());
      }
  };
  
  template&lt;int Dim, class T, class EngineTag&gt;
--- 1619,1641 ----
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const Sub1 &amp;s1, const Sub2 &amp;s2, 
! 		      const Sub3 &amp;s3, const Sub4 &amp;s4,
! 		      const Sub5 &amp;s5, const Sub6 &amp;s6)
      {
        return Dispatch_t::makeRead(a, s1, s2, s3, s4, s5, s6, Combine_t());
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      const Sub1 &amp;s1, const Sub2 &amp;s2, 
+ 		      const Sub3 &amp;s3, const Sub4 &amp;s4,
+ 		      const Sub5 &amp;s5, const Sub6 &amp;s6)
+     {
+       return Dispatch_t::makeRead(a, li, s1, s2, s3, s4, s5, s6, Combine_t());
+     }
  };
  
  template&lt;int Dim, class T, class EngineTag&gt;
*************** struct View6&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1170,1175 ****
--- 1644,1650 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // The return types.
    
*************** struct View6&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1190,1197 ****
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a, int s1, int s2, int s3, 
!     int s4, int s5, int s6)
      {
  #if POOMA_BOUNDS_CHECK
        PInsist(contains(a.domain(), Loc&lt;6&gt;(s1, s2, s3, s4, s5, s6)),
--- 1665,1673 ----
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      int s1, int s2, int s3, 
! 		      int s4, int s5, int s6)
      {
  #if POOMA_BOUNDS_CHECK
        PInsist(contains(a.domain(), Loc&lt;6&gt;(s1, s2, s3, s4, s5, s6)),
*************** struct View6&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1199,1204 ****
--- 1675,1693 ----
  #endif
        return a.engine().read(s1, s2, s3, s4, s5, s6);
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      int s1, int s2, int s3, 
+ 		      int s4, int s5, int s6)
+     {
+ #if POOMA_BOUNDS_CHECK
+       PInsist(contains(a.domain(), Loc&lt;6&gt;(s1, s2, s3, s4, s5, s6)),
+ 	    &quot;Array view bounds error.&quot;);
+ #endif
+       return a.engine().read(li, s1, s2, s3, s4, s5, s6);
+     }
  };
  
  // These are for views of the form a(b, c, d, e, f, g, h).
*************** struct View7&lt;Array&lt;Dim, T, EngineTag&gt;, 
*** 1212,1217 ****
--- 1701,1707 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce domains for the output type.
    
*************** struct View7&lt;Array&lt;Dim, T, EngineTag&gt;, 
*** 1245,1257 ****
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a, const Sub1 &amp;s1, const Sub2 &amp;s2, 
!     const Sub3 &amp;s3, const Sub4 &amp;s4, const Sub5 &amp;s5, const Sub6 &amp;s6, 
!     const Sub7 &amp;s7)
      {
        return Dispatch_t::makeRead(a, s1, s2, s3, s4, s5, s6, s7, 
          Combine_t());
      }
  };
  
  template&lt;int Dim, class T, class EngineTag&gt;
--- 1735,1761 ----
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      const Sub1 &amp;s1, const Sub2 &amp;s2, 
! 		      const Sub3 &amp;s3, const Sub4 &amp;s4,
! 		      const Sub5 &amp;s5, const Sub6 &amp;s6, 
! 		      const Sub7 &amp;s7)
      {
        return Dispatch_t::makeRead(a, s1, s2, s3, s4, s5, s6, s7, 
          Combine_t());
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      const Sub1 &amp;s1, const Sub2 &amp;s2, 
+ 		      const Sub3 &amp;s3, const Sub4 &amp;s4,
+ 		      const Sub5 &amp;s5, const Sub6 &amp;s6, 
+ 		      const Sub7 &amp;s7)
+     {
+       return Dispatch_t::makeRead(a, li, s1, s2, s3, s4, s5, s6, s7, 
+         Combine_t());
+     }
  };
  
  template&lt;int Dim, class T, class EngineTag&gt;
*************** struct View7&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1260,1265 ****
--- 1764,1770 ----
    // Convenience typedef for the thing we're taking a view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // The return types.
    
*************** struct View7&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1280,1287 ****
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a, int s1, int s2, int s3, 
!     int s4, int s5, int s6, int s7)
      {
  #if POOMA_BOUNDS_CHECK
        PInsist(contains(a.domain(), Loc&lt;7&gt;(s1, s2, s3, s4, s5, s6, s7)),
--- 1785,1794 ----
      }
    
    inline static
!   ReadType_t makeRead(const Subject_t &amp;a,
! 		      int s1, int s2, int s3, 
! 		      int s4, int s5, int s6,
! 		      int s7)
      {
  #if POOMA_BOUNDS_CHECK
        PInsist(contains(a.domain(), Loc&lt;7&gt;(s1, s2, s3, s4, s5, s6, s7)),
*************** struct View7&lt;Array&lt;Dim, T, EngineTag&gt;, i
*** 1289,1294 ****
--- 1796,1815 ----
  #endif
        return a.engine().read(s1, s2, s3, s4, s5, s6, s7);
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;a,
+ 		      const LoopInvariant_t&amp; li,
+ 		      int s1, int s2, int s3, 
+ 		      int s4, int s5, int s6,
+ 		      int s7)
+     {
+ #if POOMA_BOUNDS_CHECK
+       PInsist(contains(a.domain(), Loc&lt;7&gt;(s1, s2, s3, s4, s5, s6, s7)),
+ 	    &quot;Array view bounds error.&quot;);
+ #endif
+       return a.engine().read(li, s1, s2, s3, s4, s5, s6, s7);
+     }
  };
  
  //-----------------------------------------------------------------------------
*************** struct ComponentView&lt;Components, Array&lt;D
*** 1330,1335 ****
--- 1851,1857 ----
    // Convenience typedef for the thing we're taking a component view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce the template parameters for the output type.
    
*************** struct AltComponentView&lt;Components, Arra
*** 1368,1373 ****
--- 1890,1896 ----
    // Convenience typedef for the thing we're taking a component view of.
    
    typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
    // Deduce the template parameters for the output type.
    
*************** public:
*** 1430,1435 ****
--- 1953,1959 ----
    typedef typename Engine_t::ElementRef_t ElementRef_t;
    typedef typename Engine_t::Domain_t Domain_t;
    typedef typename Engine_t::Layout_t Layout_t;
+   typedef typename Engine_t::LoopInvariant_t LoopInvariant_t;
    enum { dimensions = Engine_t::dimensions };
    enum { rank = Engine_t::dimensions };
  
*************** public:
*** 1825,1832 ****
      {
        return engine_m.layout();
      }
!     
    //---------------------------------------------------------------------------
    // View-creation operations. These operator() functions take one or more
    // sub-domains, which combine to form a domain with dimensionality identical
    // to the rank of the array. Views based on up to 7 subdomains are supported.
--- 2349,2362 ----
      {
        return engine_m.layout();
      }
!   
    //---------------------------------------------------------------------------
+   // Loop invariants.
+ 
+   inline const
+   LoopInvariant_t loopInvariant() const { return engine_m.loopInvariant(); }
+   
+   //---------------------------------------------------------------------------
    // View-creation operations. These operator() functions take one or more
    // sub-domains, which combine to form a domain with dimensionality identical
    // to the rank of the array. Views based on up to 7 subdomains are supported.
*************** public:
*** 1905,1910 ****
--- 2435,2510 ----
        return Ret_t::makeRead(*this, s1, s2, s3, s4, s5, s6, s7);
      }
  
+   typename AltView0&lt;This_t&gt;::ReadType_t 
+   read(const LoopInvariant_t&amp; li) const
+     {
+       typedef View0&lt;This_t&gt; Ret_t;
+       return Ret_t::makeRead(*this, li);
+     }
+ 
+   template&lt;class Sub1&gt; 
+   inline typename View1&lt;This_t, Sub1&gt;::ReadType_t 
+   read(const LoopInvariant_t&amp; li, const Sub1 &amp;s1) const
+     {
+       typedef View1&lt;This_t, Sub1&gt; Ret_t;
+       return Ret_t::makeRead(*this, li, s1);
+     }
+   
+   template&lt;class Sub1, class Sub2&gt; 
+   inline typename View2&lt;This_t, Sub1, Sub2&gt;::ReadType_t
+   read(const LoopInvariant_t&amp; li, const Sub1 &amp;s1, const Sub2 &amp;s2) const
+     {
+       typedef View2&lt;This_t, Sub1, Sub2&gt; Ret_t;
+       return Ret_t::makeRead(*this, li, s1, s2);
+     }
+   
+   template&lt;class Sub1, class Sub2, class Sub3&gt; 
+   inline typename View3&lt;This_t, Sub1, Sub2, Sub3&gt;::ReadType_t
+   read(const LoopInvariant_t&amp; li, const Sub1 &amp;s1, const Sub2 &amp;s2, const Sub3 &amp;s3) const
+     {
+       typedef View3&lt;This_t, Sub1, Sub2, Sub3&gt; Ret_t;
+       return Ret_t::makeRead(*this, li, s1, s2, s3);
+     }
+   
+   template&lt;class Sub1, class Sub2, class Sub3, class Sub4&gt; 
+   inline typename View4&lt;This_t, Sub1, Sub2, Sub3, Sub4&gt;::ReadType_t
+   read(const LoopInvariant_t&amp; li, const Sub1 &amp;s1, const Sub2 &amp;s2, const Sub3 &amp;s3, 
+     const Sub4 &amp;s4) const
+     {
+       typedef View4&lt;This_t, Sub1, Sub2, Sub3, Sub4&gt; Ret_t;
+       return Ret_t::makeRead(*this, li, s1, s2, s3, s4);
+     }
+   
+   template&lt;class Sub1, class Sub2, class Sub3, class Sub4, class Sub5&gt; 
+   inline typename View5&lt;This_t, Sub1, Sub2, Sub3, Sub4, Sub5&gt;::ReadType_t
+   read(const LoopInvariant_t&amp; li, const Sub1 &amp;s1, const Sub2 &amp;s2, const Sub3 &amp;s3, 
+     const Sub4 &amp;s4, const Sub5 &amp;s5) const
+     {
+       typedef View5&lt;This_t, Sub1, Sub2, Sub3, Sub4, Sub5&gt; Ret_t;
+       return Ret_t::makeRead(*this, li, s1, s2, s3, s4, s5);
+     }
+   
+   template&lt;class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
+     class Sub6&gt; 
+   inline typename View6&lt;This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6&gt;::ReadType_t
+   read(const LoopInvariant_t&amp; li, const Sub1 &amp;s1, const Sub2 &amp;s2, const Sub3 &amp;s3, 
+     const Sub4 &amp;s4, const Sub5 &amp;s5, const Sub6 &amp;s6) const
+     {
+       typedef View6&lt;This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6&gt; Ret_t;
+       return Ret_t::makeRead(*this, li, s1, s2, s3, s4, s5, s6);
+     }
+   
+   template&lt;class Sub1, class Sub2, class Sub3, class Sub4, class Sub5,
+     class Sub6, class Sub7&gt; 
+   inline typename 
+     View7&lt;This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7&gt;::ReadType_t
+   read(const LoopInvariant_t&amp; li, const Sub1 &amp;s1, const Sub2 &amp;s2, const Sub3 &amp;s3, 
+     const Sub4 &amp;s4, const Sub5 &amp;s5, const Sub6 &amp;s6, const Sub7 &amp;s7) const
+     {
+       typedef View7&lt;This_t, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6, Sub7&gt; Ret_t;
+       return Ret_t::makeRead(*this, li, s1, s2, s3, s4, s5, s6, s7);
+     }
+ 
    typename AltView0&lt;This_t&gt;::Type_t 
    operator()() const
      {
*************** public:
*** 1927,1933 ****
        typedef View2&lt;This_t, Sub1, Sub2&gt; Ret_t;
        return Ret_t::make(*this, s1, s2);
      }
!   
    template&lt;class Sub1, class Sub2, class Sub3&gt; 
    inline typename View3&lt;This_t, Sub1, Sub2, Sub3&gt;::Type_t
    operator()(const Sub1 &amp;s1, const Sub2 &amp;s2, const Sub3 &amp;s3) const
--- 2527,2533 ----
        typedef View2&lt;This_t, Sub1, Sub2&gt; Ret_t;
        return Ret_t::make(*this, s1, s2);
      }
! 
    template&lt;class Sub1, class Sub2, class Sub3&gt; 
    inline typename View3&lt;This_t, Sub1, Sub2, Sub3&gt;::Type_t
    operator()(const Sub1 &amp;s1, const Sub2 &amp;s2, const Sub3 &amp;s3) const
*************** public:
*** 1976,1981 ****
--- 2576,2640 ----
        return Ret_t::make(*this, s1, s2, s3, s4, s5, s6, s7);
      }
  
+   // HERE
+   // FIXME: Convert other dimensions' versions.
+   // When we use LoopInvariant_t, we are guaranteed to have integral
+   // indices, not general indices.
+   inline ElementRef_t
+   operator()(const LoopInvariant_t &amp;li) const
+     {
+       return engine()(li);
+     }
+ 
+   inline ElementRef_t
+   operator()(const LoopInvariant_t &amp;li,
+ 	     int s1) const
+     {
+       return engine()(li, s1);
+     }
+ 
+   inline ElementRef_t
+   operator()(const LoopInvariant_t &amp;li,
+ 	     int s1, int s2) const
+     {
+       return engine()(li, s1, s2);
+     }
+ 
+   inline ElementRef_t
+   operator()(const LoopInvariant_t &amp;li,
+ 	     int s1, int s2, int s3) const
+     {
+       return engine()(li, s1, s2, s3);
+     }
+ 
+   inline ElementRef_t
+   operator()(const LoopInvariant_t &amp;li,
+ 	     int s1, int s2, int s3, int s4) const
+     {
+       return engine()(li, s1, s2, s3, s4);
+     }
+ 
+   inline ElementRef_t
+   operator()(const LoopInvariant_t &amp;li,
+ 	     int s1, int s2, int s3, int s4, int s5) const
+     {
+       return engine()(li, s1, s2, s3, s4, s5);
+     }
+ 
+   inline ElementRef_t
+   operator()(const LoopInvariant_t &amp;li,
+ 	     int s1, int s2, int s3, int s4, int s5, int s6) const
+     {
+       return engine()(li, s1, s2, s3, s4, s5, s6);
+     }
+ 
+   inline ElementRef_t
+   operator()(const LoopInvariant_t &amp;li,
+ 	     int s1, int s2, int s3, int s4, int s5, int s6, int s7) const
+     {
+       return engine()(li, s1, s2, s3, s4, s5, s6, s7);
+     }
+   
    //---------------------------------------------------------------------------
    // Component forwarding function. This is used when Element_t has components,
    // as is the case for vectors, tensors, or arrays. A Forwarding engine
*************** private:    
*** 2225,2236 ****
  template&lt;int Dim, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, EngineTag&gt;, DomainFunctorTag&gt;
  {
    typedef typename Engine&lt;Dim, T, EngineTag&gt;::Domain_t Type_t;
!   static Type_t apply(const Array&lt;Dim, T, EngineTag&gt; &amp;a, 
! 		      const DomainFunctorTag &amp;)
    {
      return a.domain();
    }
  };
  
  //-----------------------------------------------------------------------------
--- 2884,2906 ----
  template&lt;int Dim, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, EngineTag&gt;, DomainFunctorTag&gt;
  {
+   typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DomainFunctorTag Tag_t;
    typedef typename Engine&lt;Dim, T, EngineTag&gt;::Domain_t Type_t;
! 
!   static Type_t apply(const Subject_t &amp;a, 
! 		      const Tag_t &amp;)
    {
      return a.domain();
    }
+ 
+   static Type_t apply(const Subject_t &amp;a, 
+ 		      const LoopInvariant_t &amp;li,
+ 		      const Tag_t &amp;t)
+   {
+     return apply(a,t);
+   }
  };
  
  //-----------------------------------------------------------------------------
*************** struct LeafFunctor&lt;Array&lt;Dim, T, EngineT
*** 2243,2255 ****
  template&lt;int Dim, class T, class EngineTag, class Domain&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, EngineTag&gt;, ViewFunctorTag&lt;Domain&gt; &gt;
  {
!   typedef typename View1&lt;Array&lt;Dim, T, EngineTag&gt;, Domain&gt;::Type_t Type_t;
!   inline static Type_t apply(const Array&lt;Dim, T, EngineTag&gt; &amp;a, 
!     const ViewFunctorTag&lt;Domain&gt; &amp;t) 
!     {
!       typedef View1&lt;Array&lt;Dim, T, EngineTag&gt;, Domain&gt; Ret_t;
!       return Ret_t::make(a, t.domain_m + a.firsts());
!     }
  };
  
  //-----------------------------------------------------------------------------
--- 2913,2939 ----
  template&lt;int Dim, class T, class EngineTag, class Domain&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, EngineTag&gt;, ViewFunctorTag&lt;Domain&gt; &gt;
  {
!   typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef ViewFunctorTag&lt;Domain&gt; Tag_t;
!   typedef typename View1&lt;Subject_t, Domain&gt;::Type_t Type_t;
! 
!   inline static
!   Type_t apply(const Subject_t &amp;a, 
! 	       const Tag_t &amp;t) 
!   {
!     typedef View1&lt;Array&lt;Dim, T, EngineTag&gt;, Domain&gt; Ret_t;
!     return Ret_t::make(a, t.domain_m + a.firsts());
!   }
! 
!   inline static
!   Type_t apply(const Subject_t &amp;a, 
! 	       const LoopInvariant_t &amp;,
! 	       const Tag_t &amp;t) 
!   {
!     // HERE FIXME: Is this correct?
!     return apply(a,t);
!   }
  };
  
  //-----------------------------------------------------------------------------
*************** struct LeafFunctor&lt;Array&lt;Dim, T, EngineT
*** 2260,2273 ****
  template&lt;int Dim, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, EngineTag&gt;, EvalLeaf&lt;Dim&gt; &gt;
  {
!   typedef typename Array&lt;Dim, T, EngineTag&gt;::Element_t Type_t;
    inline static
!   Type_t apply(const Array&lt;Dim, T, EngineTag&gt; &amp;a, const EvalLeaf&lt;Dim&gt; &amp;t) 
      {
        return t.eval(a.engine());
      }
  };
  
  //-----------------------------------------------------------------------------
  // EngineView functor acting on array.  The functor is applied to the contained
  // engine and the result is packed back inside the array.
--- 2944,2970 ----
  template&lt;int Dim, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, EngineTag&gt;, EvalLeaf&lt;Dim&gt; &gt;
  {
!   typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef EvalLeaf&lt;Dim&gt; Tag_t;
!   typedef typename Subject_t::Element_t Type_t;
! 
    inline static
!   Type_t apply(const Subject_t &amp;a, const Tag_t &amp;t) 
      {
        return t.eval(a.engine());
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;a,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;t) 
+     {
+       return t.eval(a.engine(), li);
+     }
  };
  
+ 
  //-----------------------------------------------------------------------------
  // EngineView functor acting on array.  The functor is applied to the contained
  // engine and the result is packed back inside the array.
*************** struct LeafFunctor&lt;Array&lt;Dim, T, EngineT
*** 2276,2281 ****
--- 2973,2981 ----
  template&lt;int Dim, class T, class E, class Tag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, E&gt;, EngineView&lt;Tag&gt; &gt;
  {
+   typedef Array&lt;Dim, T, E&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef EngineView&lt;Tag&gt; Tag_t;
    typedef LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, EngineView&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t NewEngine_t;
  
*************** struct LeafFunctor&lt;Array&lt;Dim, T, E&gt;, Eng
*** 2283,2293 ****
    typedef Array&lt;Dim, T, NewTag_t&gt; Type_t;
  
    inline static
!   Type_t apply(const Array&lt;Dim, T, E&gt; &amp;array, 
! 	       const EngineView&lt;Tag&gt; &amp;tag)
    {
      return Type_t(LeafFunctor_t::apply(array.engine(), tag));
    }
  };
  
  //-----------------------------------------------------------------------------
--- 2983,3001 ----
    typedef Array&lt;Dim, T, NewTag_t&gt; Type_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;array, 
! 	       const Tag_t &amp;tag)
    {
      return Type_t(LeafFunctor_t::apply(array.engine(), tag));
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;array, 
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return Type_t(LeafFunctor_t::apply(array.engine(), li, tag));
+   }
  };
  
  //-----------------------------------------------------------------------------
*************** struct LeafFunctor&lt;Array&lt;Dim, T, E&gt;, Eng
*** 2298,2312 ****
  template&lt;int Dim, class T, class E, class Tag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, E&gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, ExpressionApply&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef int Type_t;
  
    inline static
!   Type_t apply(const Array&lt;Dim, T, E&gt; &amp;array, 
! 	       const ExpressionApply&lt;Tag&gt; &amp;tag)
    {
      return LeafFunctor_t::apply(array.engine(), tag);
    }
  };
  
  //----------------------------------------------------------------------
--- 3006,3031 ----
  template&lt;int Dim, class T, class E, class Tag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, E&gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
+   typedef Array&lt;Dim, T, E&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef ExpressionApply&lt;Tag&gt; Tag_t;
    typedef LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, ExpressionApply&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef int Type_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;array, 
! 	       const Tag_t &amp;tag)
    {
      return LeafFunctor_t::apply(array.engine(), tag);
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;array, 
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return LeafFunctor_t::apply(array.engine(), li, tag);
+   }
  };
  
  //----------------------------------------------------------------------
*************** struct LeafFunctor&lt;Array&lt;Dim, T, E&gt;, Exp
*** 2322,2333 ****
  template&lt;int Dim, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, EngineTag&gt;, ConformTag&lt;Dim&gt; &gt;
  {
    typedef bool Type_t;
!   static Type_t apply(const Array&lt;Dim, T, EngineTag&gt; &amp;array,
!     const ConformTag&lt;Dim&gt; &amp;ct)
      {
        return conforms(array.domain(), ct);
      }
  };
  
  // Now the case where the rank of the Array is not the same
--- 3041,3065 ----
  template&lt;int Dim, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, EngineTag&gt;, ConformTag&lt;Dim&gt; &gt;
  {
+   typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef ConformTag&lt;Dim&gt; Tag_t;
    typedef bool Type_t;
! 
!   inline static
!   Type_t apply(const Subject_t &amp;array,
! 	       const Tag_t &amp;ct)
      {
        return conforms(array.domain(), ct);
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;array,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;ct)
+     {
+       return apply(array, ct);
+     }
  };
  
  // Now the case where the rank of the Array is not the same
*************** struct LeafFunctor&lt;Array&lt;Dim, T, EngineT
*** 2336,2347 ****
  template&lt;int Dim1, int Dim2, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Array&lt;Dim1, T, EngineTag&gt;, ConformTag&lt;Dim2&gt; &gt;
  {
    typedef bool Type_t;
!   static Type_t apply(const Array&lt;Dim1, T, EngineTag&gt; &amp;,
!     const ConformTag&lt;Dim2&gt; &amp;)
      {
        return false;
      }
  };
  
  //----------------------------------------------------------------------
--- 3068,3092 ----
  template&lt;int Dim1, int Dim2, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Array&lt;Dim1, T, EngineTag&gt;, ConformTag&lt;Dim2&gt; &gt;
  {
+   typedef Array&lt;Dim1, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef ConformTag&lt;Dim2&gt; Tag_t;
    typedef bool Type_t;
! 
!   inline static
!   Type_t apply(const Subject_t &amp;,
! 	       const Tag_t &amp;)
      {
        return false;
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;s,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;t)
+     {
+       return apply(s,t);
+     }
  };
  
  //----------------------------------------------------------------------
*************** struct LeafFunctor&lt;Array&lt;Dim1, T, Engine
*** 2352,2363 ****
  template&lt;int Dim, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, EngineTag&gt;, NotifyPreReadTag&gt;
  {
    typedef bool Type_t;
!   static Type_t apply(const Array&lt;Dim, T, EngineTag&gt; &amp;a, 
!     const NotifyPreReadTag &amp;)
      {
        return true;
      }
  };
  
  //-----------------------------------------------------------------------------
--- 3097,3121 ----
  template&lt;int Dim, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, EngineTag&gt;, NotifyPreReadTag&gt;
  {
+   typedef Array&lt;Dim, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef NotifyPreReadTag Tag_t;
    typedef bool Type_t;
! 
!   inline static
!   Type_t apply(const Subject_t &amp;a, 
! 	       const Tag_t &amp;)
      {
        return true;
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;s,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;t)
+     {
+       return apply(s,t);
+     }
  };
  
  //-----------------------------------------------------------------------------
*************** struct LeafFunctor&lt;Array&lt;Dim, T, EngineT
*** 2367,2378 ****
  template&lt;int Dim, class T, class E, class Tag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, E&gt;, EngineFunctorTag&lt;Tag&gt; &gt;
  {
!   typedef typename Array&lt;Dim,T,E&gt;::Engine_t Engine_t;
    typedef typename EngineFunctor&lt;Engine_t,Tag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const Array&lt;Dim, T, E&gt; &amp;array, const EngineFunctorTag&lt;Tag&gt; &amp;tag)
    {
      return EngineFunctor&lt;Engine_t,Tag&gt;::apply(array.engine(), tag.tag());
    }
  };
  
--- 3125,3148 ----
  template&lt;int Dim, class T, class E, class Tag&gt;
  struct LeafFunctor&lt;Array&lt;Dim, T, E&gt;, EngineFunctorTag&lt;Tag&gt; &gt;
  {
!   typedef Array&lt;Dim, T, E&gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef EngineFunctorTag&lt;Tag&gt; Tag_t;
!   typedef typename Subject_t::Engine_t Engine_t;
    typedef typename EngineFunctor&lt;Engine_t,Tag&gt;::Type_t Type_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;array, const Tag_t &amp;tag)
    {
      return EngineFunctor&lt;Engine_t,Tag&gt;::apply(array.engine(), tag.tag());
+   }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;array,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return EngineFunctor&lt;Engine_t,Tag&gt;::apply(array.engine(), li, tag.tag());
    }
  };
  
Index: src/Array/PrintArray.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Array/PrintArray.h,v
retrieving revision 1.21
diff -c -p -r1.21 PrintArray.h
*** src/Array/PrintArray.h	2001/03/29 17:09:25	1.21
--- src/Array/PrintArray.h	2001/11/05 19:28:26
*************** class PrintArray;
*** 120,126 ****
  // PRINTING ARRAY OBJECTS WITH A PrintArray:
  // -----------------------------------------
  // PrintArray is not templated, so that you can reuse the same formatter
! // for different array's.  It has one templated member function 'print':
  //
  //   template&lt;class S, class A&gt;
  //   void print(S &amp;s, const A &amp;a) const
--- 120,126 ----
  // PRINTING ARRAY OBJECTS WITH A PrintArray:
  // -----------------------------------------
  // PrintArray is not templated, so that you can reuse the same formatter
! // for different arrays.  It has one templated member function 'print':
  //
  //   template&lt;class S, class A&gt;
  //   void print(S &amp;s, const A &amp;a) const
*************** PerformPrintArray&lt;S,A,1,DomainType&gt;::pri
*** 412,422 ****
  
    Domain_t domain(d);
  
!   // create an iterator over the domain of the array
  
    Iterator_t griditer = domain.begin();
    Iterator_t  enditer = domain.end();
  
    // For a domain of total extent 1 (single Array element), treat specially:
    if (domain.size() == 1) {
  
--- 412,425 ----
  
    Domain_t domain(d);
  
!   // Create an iterator over the domain of the array.
  
    Iterator_t griditer = domain.begin();
    Iterator_t  enditer = domain.end();
  
+   // Obtain array data members that are invariant during array traversal.
+   typedef typename A::LoopInvariant_t LoopInvariant_t;
+ 
    // For a domain of total extent 1 (single Array element), treat specially:
    if (domain.size() == 1) {
  
*************** PerformPrintArray&lt;S,A,1,DomainType&gt;::pri
*** 470,475 ****
--- 473,479 ----
  
    // loop over the elements, printing out values as necessary
  
+   const LoopInvariant_t li = a.loopInvariant();
    int i, printed = 0;
    while (griditer != enditer)
      {
*************** PerformPrintArray&lt;S,A,1,DomainType&gt;::pri
*** 495,501 ****
  	s.setf(std::ios::scientific);
        s.precision(p.dataPrecision());
        s.width(p.dataWidth());
!       s &lt;&lt; a.read(*griditer);
  
        // increment iterator and counter
        ++griditer;
--- 499,505 ----
  	s.setf(std::ios::scientific);
        s.precision(p.dataPrecision());
        s.width(p.dataWidth());
!       s &lt;&lt; a.read(li, *griditer);
  
        // increment iterator and counter
        ++griditer;
Index: src/Array/tests/ExpressionTest.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Array/tests/ExpressionTest.h,v
retrieving revision 1.3
diff -c -p -r1.3 ExpressionTest.h
*** src/Array/tests/ExpressionTest.h	2000/07/20 15:36:24	1.3
--- src/Array/tests/ExpressionTest.h	2001/11/05 19:28:26
*************** public:
*** 223,231 ****
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, int i) const
    {
!     return ( x.read(i-1) + x.read(i) );
    }
  
    inline int lowerExtent(int) const { return 1; }
--- 223,233 ----
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x,
! 	     const typename A::LoopInvariant_t &amp;li,
! 	     int i) const
    {
!     return ( x.read(li, i-1) + x.read(li, i) );
    }
  
    inline int lowerExtent(int) const { return 1; }
Index: src/Array/tests/array_test19.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Array/tests/array_test19.cpp,v
retrieving revision 1.20
diff -c -p -r1.20 array_test19.cpp
*** src/Array/tests/array_test19.cpp	2001/10/05 01:29:02	1.20
--- src/Array/tests/array_test19.cpp	2001/11/05 19:28:26
*************** public:
*** 108,116 ****
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, int i) const
    {
!     return ( x(i-1) + x(i) + x(i+1) );
    }
  
    inline int lowerExtent(int) const { return 1; }
--- 108,116 ----
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, const typename A::LoopInvariant_t&amp; li, int i) const
    {
!     return ( x.read(li,i-1) + x.read(li,i) + x.read(li,i+1) );
    }
  
    inline int lowerExtent(int) const { return 1; }
*************** public:
*** 137,145 ****
    template &lt;class A&gt;
    inline
    typename NormResult&lt;typename A::Element_t&gt;::Type_t
!   operator()(const A&amp; x, int i) const
    {
!     return ( 0.5*(dot(x(i-1), x(i)) + dot(x(i), x(i+1))) );
    }
  
    inline int lowerExtent(int) const { return 1; }
--- 137,145 ----
    template &lt;class A&gt;
    inline
    typename NormResult&lt;typename A::Element_t&gt;::Type_t
!   operator()(const A&amp; x, const typename A::LoopInvariant_t&amp; li, int i) const
    {
!     return ( 0.5*(dot(x.read(li,i-1), x.read(li,i)) + dot(x.read(li,i), x.read(li,i+1))) );
    }
  
    inline int lowerExtent(int) const { return 1; }
*************** public:
*** 167,178 ****
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, int i, int j) const
    {
      return ( (1.0/15.0) *
!              ( x(i+1,j+1) + 2*x(i+1,j  ) + 3*x(i+1,j-1) +
!                3*x(i  ,j+1) + x(i  ,j  ) + 2*x(i  ,j-1) +
!                4*x(i-1,j+1) + 3*x(i-1,j  ) + 5*x(i-1,j-1) ) );
    }
  
    inline int lowerExtent(int) const { return 1; }
--- 167,179 ----
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, const typename A::LoopInvariant_t&amp; li,
! 	     int i, int j) const
    {
      return ( (1.0/15.0) *
!              ( x.read(li, i+1,j+1) + 2*x.read(li, i+1,j  ) + 3*x.read(li, i+1,j-1) +
!                3*x.read(li, i  ,j+1) + x.read(li, i  ,j  ) + 2*x.read(li, i  ,j-1) +
!                4*x.read(li, i-1,j+1) + 3*x.read(li, i-1,j  ) + 5*x.read(li, i-1,j-1) ) );
    }
  
    inline int lowerExtent(int) const { return 1; }
*************** public:
*** 189,200 ****
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, int i, int j) const
    {
      return ( (1.0/9.0) *
!              ( x(i+1,j+1) + x(i+1,j  ) + x(i+1,j-1) +
!                x(i  ,j+1) + x(i  ,j  ) + x(i  ,j-1) +
!                x(i-1,j+1) + x(i-1,j  ) + x(i-1,j-1) ) );
    }
  
    inline int lowerExtent(int) const { return 1; }
--- 190,202 ----
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, const typename A::LoopInvariant_t&amp; li,
! 	     int i, int j) const
    {
      return ( (1.0/9.0) *
!              ( x.read(li, i+1,j+1) + x.read(li, i+1,j  ) + x.read(li, i+1,j-1) +
!                x.read(li, i  ,j+1) + x.read(li, i  ,j  ) + x.read(li, i  ,j-1) +
!                x.read(li, i-1,j+1) + x.read(li, i-1,j  ) + x.read(li, i-1,j-1) ) );
    }
  
    inline int lowerExtent(int) const { return 1; }
*************** public:
*** 213,223 ****
    template &lt;class A&gt;
    inline
    complex&lt;double&gt;
!   operator()(const A&amp; x, int i, int j) const
    {
      return ( (1.0/3.0) *
!              ( x(i  ,j  ) + alpha_m * x(i  ,j-1) +
!                alphaConj_m * x(i-1,j  ) + x(i-1,j-1) ) );
    }
  
    inline int lowerExtent(int) const { return 1; }
--- 215,226 ----
    template &lt;class A&gt;
    inline
    complex&lt;double&gt;
!   operator()(const A&amp; x, const typename A::LoopInvariant_t&amp; li,
! 	     int i, int j) const
    {
      return ( (1.0/3.0) *
!              ( x.read(li, i  ,j  ) + alpha_m * x.read(li, i  ,j-1) +
!                alphaConj_m * x.read(li, i-1,j  ) + x.read(li, i-1,j-1) ) );
    }
  
    inline int lowerExtent(int) const { return 1; }
*************** public:
*** 238,248 ****
    template &lt;class A&gt;
    inline
    complex&lt;double&gt;
!   operator()(const A&amp; x, int i, int j) const
    {
      return ( (1.0/3.0) *
!              ( x.read(i  ,j  ) + alpha_m * x.read(i  ,j+1) +
!                alphaConj_m * x.read(i+1,j  ) + x.read(i+1,j+1) ) );
    }
  
    inline int lowerExtent(int) const { return 0; }
--- 241,252 ----
    template &lt;class A&gt;
    inline
    complex&lt;double&gt;
!   operator()(const A&amp; x, const typename A::LoopInvariant_t&amp; li,
! 	     int i, int j) const
    {
      return ( (1.0/3.0) *
!              ( x.read(li, i  ,j  ) + alpha_m * x.read(li, i  ,j+1) +
!                alphaConj_m * x.read(li, i+1,j  ) + x.read(li, i+1,j+1) ) );
    }
  
    inline int lowerExtent(int) const { return 0; }
Index: src/Array/tests/array_test23.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Array/tests/array_test23.cpp,v
retrieving revision 1.5
diff -c -p -r1.5 array_test23.cpp
*** src/Array/tests/array_test23.cpp	2000/07/04 05:06:54	1.5
--- src/Array/tests/array_test23.cpp	2001/11/05 19:28:26
*************** public:
*** 61,72 ****
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, int i, int j) const
    {
      return ( (1.0/15.0) *
!              ( x(i+1,j+1) + 2*x(i+1,j  ) + 3*x(i+1,j-1) +
!                3*x(i  ,j+1) + x(i  ,j  ) + 2*x(i  ,j-1) +
!                4*x(i-1,j+1) + 3*x(i-1,j  ) + 5*x(i-1,j-1) ) );
    }
  
    inline int lowerExtent(int) const { return 1; }
--- 61,73 ----
    template &lt;class A&gt;
    inline
    typename A::Element_t
!   operator()(const A&amp; x, const typename A::LoopInvariant_t &amp;li,
! 	     int i, int j) const
    {
      return ( (1.0/15.0) *
!              ( x.read(li,i+1,j+1) + 2*x.read(li,i+1,j  ) + 3*x.read(li,i+1,j-1) +
!                3*x.read(li,i  ,j+1) + x.read(li,i  ,j  ) + 2*x.read(li,i  ,j-1) +
!                4*x.read(li,i-1,j+1) + 3*x.read(li,i-1,j  ) + 5*x.read(li,i-1,j-1) ) );
    }
  
    inline int lowerExtent(int) const { return 1; }
Index: src/DynamicArray/DynamicArray.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/DynamicArray/DynamicArray.h,v
retrieving revision 1.30
diff -c -p -r1.30 DynamicArray.h
*** src/DynamicArray/DynamicArray.h	2001/04/30 18:26:34	1.30
--- src/DynamicArray/DynamicArray.h	2001/11/05 19:28:26
*************** struct LeafFunctor&lt;DynamicArray&lt;T, E&gt;, E
*** 882,895 ****
  {
    typedef typename DynamicArray&lt;T,E&gt;::Engine_t Engine_t;
    typedef typename EngineFunctor&lt;Engine_t,Tag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const DynamicArray&lt;T, E&gt; &amp;array,
  	       const EngineFunctorTag&lt;Tag&gt; &amp;tag)
    {
      return EngineFunctor&lt;Engine_t,Tag&gt;::apply(array.engine(), tag.tag());
    }
- };
  
  
  #endif
  
--- 882,905 ----
  {
    typedef typename DynamicArray&lt;T,E&gt;::Engine_t Engine_t;
    typedef typename EngineFunctor&lt;Engine_t,Tag&gt;::Type_t Type_t;
+   typedef DynamicArray&lt;T,E&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;array,
  	       const EngineFunctorTag&lt;Tag&gt; &amp;tag)
    {
      return EngineFunctor&lt;Engine_t,Tag&gt;::apply(array.engine(), tag.tag());
    }
  
+   inline static
+   Type_t apply(const Subject_t &amp;array,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const EngineFunctorTag&lt;Tag&gt; &amp;tag)
+   {
+     return EngineFunctor&lt;Engine_t,Tag&gt;::apply(array.engine(), li, tag.tag());
+   }
+ };
  
  #endif
  
Index: src/Engine/BrickBase.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/BrickBase.cpp,v
retrieving revision 1.9
diff -c -p -r1.9 BrickBase.cpp
*** src/Engine/BrickBase.cpp	2001/08/30 01:15:01	1.9
--- src/Engine/BrickBase.cpp	2001/11/05 19:28:26
*************** BrickBase&lt;Dim&gt;::BrickBase(const Domain_t
*** 77,94 ****
  {
    // Compute the strides and offset.
  
!   strides_m[0] = 1;
    firsts_m[0]  = domain()[0].first();
    off_m        = -firsts_m[0];
  
    for (int d = 1; d &lt; Dim; ++d)
      {
        firsts_m[d]  = domain()[d].first();
!       strides_m[d] = strides_m[d-1]*domain()[d-1].length();
!       off_m       -= domain()[d].first()*strides_m[d];
      }
    
!   for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = strides_m[d];
  }
  
  //-----------------------------------------------------------------------------
--- 77,94 ----
  {
    // Compute the strides and offset.
  
!   invariant_m.strides()[0] = 1;
    firsts_m[0]  = domain()[0].first();
    off_m        = -firsts_m[0];
  
    for (int d = 1; d &lt; Dim; ++d)
      {
        firsts_m[d]  = domain()[d].first();
!       invariant_m.strides()[d] = invariant_m.strides()[d-1]*domain()[d-1].length();
!       off_m       -= domain()[d].first()*invariant_m.strides()[d];
      }
    
!   for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = invariant_m.strides()[d];
  }
  
  //-----------------------------------------------------------------------------
*************** BrickBase&lt;Dim&gt;::BrickBase(const Node&lt;Dom
*** 105,122 ****
  {
    // Compute the strides and offset.
  
!   strides_m[0] = 1;
    firsts_m[0]  = domain()[0].first();
    off_m        = -firsts_m[0];
  
    for (int d = 1; d &lt; Dim; ++d)
      {
        firsts_m[d]  = domain()[d].first();
!       strides_m[d] = strides_m[d-1]*domain()[d-1].length();
!       off_m       -= domain()[d].first()*strides_m[d];
      }
    
!   for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = strides_m[d];
  }
  
  //-----------------------------------------------------------------------------
--- 105,122 ----
  {
    // Compute the strides and offset.
  
!   invariant_m.strides()[0] = 1;
    firsts_m[0]  = domain()[0].first();
    off_m        = -firsts_m[0];
  
    for (int d = 1; d &lt; Dim; ++d)
      {
        firsts_m[d]  = domain()[d].first();
!       invariant_m.strides()[d] = invariant_m.strides()[d-1]*domain()[d-1].length();
!       off_m       -= domain()[d].first()*invariant_m.strides()[d];
      }
    
!   for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = invariant_m.strides()[d];
  }
  
  //-----------------------------------------------------------------------------
*************** BrickBase&lt;Dim&gt;::BrickBase(const Layout_t
*** 133,150 ****
  {
    // Compute the strides and offset.
  
!   strides_m[0] = 1;
    firsts_m[0]  = domain()[0].first();
    off_m        = -firsts_m[0];
  
    for (int d = 1; d &lt; Dim; ++d)
      {
        firsts_m[d]  = domain()[d].first();
!       strides_m[d] = strides_m[d-1]*domain()[d-1].length();
!       off_m       -= domain()[d].first()*strides_m[d];
      }
    
!   for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = strides_m[d];
  }
  
  //-----------------------------------------------------------------------------
--- 133,150 ----
  {
    // Compute the strides and offset.
  
!   invariant_m.strides()[0] = 1;
    firsts_m[0]  = domain()[0].first();
    off_m        = -firsts_m[0];
  
    for (int d = 1; d &lt; Dim; ++d)
      {
        firsts_m[d]  = domain()[d].first();
!       invariant_m.strides()[d] = invariant_m.strides()[d-1]*domain()[d-1].length();
!       off_m       -= domain()[d].first()*invariant_m.strides()[d];
      }
    
!   for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = invariant_m.strides()[d];
  }
  
  //-----------------------------------------------------------------------------
*************** sliceInit(const This_t &amp;bvbase, const Ra
*** 275,285 ****
    for (int d = 0; d &lt; Dim; ++d)
      {
        domain_m[d]   = Interval&lt;1&gt;(domain[d].length());
!       strides_m[d]  = bvbase.ostrides_m[d] * domain[d].stride();
        baseOffset_m += domain[d].first() * bvbase.ostrides_m[d];
      }
  
!   for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = strides_m[d];
  }
  
  //-----------------------------------------------------------------------------
--- 275,285 ----
    for (int d = 0; d &lt; Dim; ++d)
      {
        domain_m[d]   = Interval&lt;1&gt;(domain[d].length());
!       invariant_m.strides()[d]  = bvbase.ostrides_m[d] * domain[d].stride();
        baseOffset_m += domain[d].first() * bvbase.ostrides_m[d];
      }
  
!   for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = invariant_m.strides()[d];
  }
  
  //-----------------------------------------------------------------------------
Index: src/Engine/BrickBase.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/BrickBase.h,v
retrieving revision 1.12
diff -c -p -r1.12 BrickBase.h
*** src/Engine/BrickBase.h	2001/08/30 01:15:02	1.12
--- src/Engine/BrickBase.h	2001/11/05 19:28:26
*************** class BrickBase 
*** 105,111 ****
  public:
  
    //============================================================
!   // Exported typedefs and constants
    //============================================================
  
    typedef Interval&lt;Dim&gt;  Domain_t;
--- 105,111 ----
  public:
  
    //============================================================
!   // Exported typedefs, constants, and classes
    //============================================================
  
    typedef Interval&lt;Dim&gt;  Domain_t;
*************** public:
*** 117,122 ****
--- 117,143 ----
    enum { brick      = true  };
    enum { zeroBased  = false };
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t {
+   public:
+ 
+     inline int *strides() { return strides_m; }
+     inline int&amp; strides(const int i) { return strides_m[i]; }
+     inline const int *strides() const { return strides_m; }
+     inline int strides(const int i) const { return strides_m[i]; }
+ 
+   private:
+ 
+     // Strides through actual data block when stepping in different directions.
+     // We keep two copies - strides_m is used by the offset calculations. 
+     // If we are compressible, then when compressed, these will all be 
+     // set to zero. 
+   
+     int strides_m[Dim];
+   };
+ 
    //============================================================
    // Constructors and Factory Methods
    //============================================================
*************** public:
*** 165,173 ****
  
    inline const Layout_t &amp;layout() const { return layout_m; }
  
    // Return the strides array.
    
!   inline const int *strides() const { return &amp;strides_m[0]; }
    
    // Return the true strides array.
    
--- 186,198 ----
  
    inline const Layout_t &amp;layout() const { return layout_m; }
  
+   // Return the loop invariant object.
+ 
+   inline const LoopInvariant_t loopInvariant() const { return invariant_m; }
+ 
    // Return the strides array.
    
!   inline const int *strides() const { return invariant_m.strides(); }
    
    // Return the true strides array.
    
*************** public:
*** 191,197 ****
    // offset0 treats the input domain as a zero-based domain giving 
    // offsets from the beginning in each dimension, rather than as 
    // points in the Brick's underlying domain. offsetC is similar, 
!   // except that it multiplies the first offset by strides_m[0].
    // This is only for use in CompressibleBrick.
    
    template &lt;class Domain&gt;
--- 216,222 ----
    // offset0 treats the input domain as a zero-based domain giving 
    // offsets from the beginning in each dimension, rather than as 
    // points in the Brick's underlying domain. offsetC is similar, 
!   // except that it multiplies the first offset by invariant_m.strides(0).
    // This is only for use in CompressibleBrick.
    
    template &lt;class Domain&gt;
*************** public:
*** 203,208 ****
--- 228,242 ----
    template &lt;class Domain&gt;
    int offsetC(const Domain &amp;) const;
  
+   template &lt;class Domain&gt;
+   int offset(const LoopInvariant_t &amp;, const Domain &amp;) const;
+   
+   template &lt;class Domain&gt;
+   int offset0(const LoopInvariant_t &amp;, const Domain &amp;) const;
+   
+   template &lt;class Domain&gt;
+   int offsetC(const LoopInvariant_t &amp;, const Domain &amp;) const;
+ 
    // The &quot;int&quot; versions do not assert that their dimensionality is
    // correct. The inheriting class should make these checks.
    // These are fairly short and there are a lot of them so I define
*************** public:
*** 218,296 ****
    { return off_m + i0; }
    
    inline int offset(int i0, int i1) const
!   { return off_m + i0 + i1*strides_m[1]; }
    
    inline int offset(int i0, int i1, int i2) const
!   { return off_m + i0 + i1*strides_m[1] + i2*strides_m[2]; }
  
    inline int offset(int i0, int i1, int i2, int i3) const
!   { return off_m + i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]; }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4) const
!   { return off_m + i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
!                       + i4*strides_m[4]; }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4, int i5) const
!   { return off_m + i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
!                       + i4*strides_m[4] + i5*strides_m[5]; }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4, int i5, int i6) 
    const
!   { return off_m + i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3] 
!                       + i4*strides_m[4] + i5*strides_m[5] + i6*strides_m[6]; }
                      
    inline int offset0(int i0) const
    { return i0; }
    
    inline int offset0(int i0, int i1) const
!   { return i0 + i1*strides_m[1]; }
    
    inline int offset0(int i0, int i1, int i2) const
!   { return i0 + i1*strides_m[1] + i2*strides_m[2]; }
    
    inline int offset0(int i0, int i1, int i2, int i3) const
!   { return i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]; }
    
    inline int offset0(int i0, int i1, int i2, int i3, int i4) const
!   { return i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
!               + i4*strides_m[4]; }
    
    inline int offset0(int i0, int i1, int i2, int i3, int i4, int i5) const
!   { return i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
!               + i4*strides_m[4] + i5*strides_m[5]; }
    
    inline int offset0(int i0, int i1, int i2, int i3, int i4, int i5, int i6) 
    const
!   { return i0 + i1*strides_m[1] + i2*strides_m[2] + i3*strides_m[3]
!               + i4*strides_m[4] + i5*strides_m[5] + i6*strides_m[6]; }
      
    inline int offsetC(int i0) const 
!   { return i0*strides_m[0]; }
    
    inline int offsetC(int i0, int i1) const 
!   { return i0*strides_m[0] + i1*strides_m[1]; }
    
    inline int offsetC(int i0, int i1, int i2) const
!   { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]; }
  
    inline int offsetC(int i0, int i1, int i2, int i3) const
!   { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2] 
!          + i3*strides_m[3]; }
                      
    inline int offsetC(int i0, int i1, int i2, int i3, int i4) const
!   { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2] 
!          + i3*strides_m[3] + i4*strides_m[4]; }
                      
    inline int offsetC(int i0, int i1, int i2, int i3, int i4, int i5) const
!   { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2] 
!          + i3*strides_m[3] + i4*strides_m[4] + i5*strides_m[5]; }
                      
    inline int offsetC(int i0, int i1, int i2, int i3, int i4, int i5, int i6) 
    const
!   { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2] 
!          + i3*strides_m[3] + i4*strides_m[4] + i5*strides_m[5] 
!          + i6*strides_m[6]; }
!   
  protected:
  
    //============================================================
--- 252,413 ----
    { return off_m + i0; }
    
    inline int offset(int i0, int i1) const
!   { return off_m + i0 + i1*invariant_m.strides(1); }
    
    inline int offset(int i0, int i1, int i2) const
!   { return off_m + i0 + i1*invariant_m.strides(1) + i2*invariant_m.strides(2); }
  
    inline int offset(int i0, int i1, int i2, int i3) const
!   { return off_m + i0 + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) + i3*invariant_m.strides(3); }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4) const
!   { return off_m + i0 + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) + i3*invariant_m.strides(3)
!                       + i4*invariant_m.strides(4); }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4, int i5) const
!   { return off_m + i0 + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) + i3*invariant_m.strides(3)
!                       + i4*invariant_m.strides(4) + i5*invariant_m.strides(5); }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4, int i5, int i6) 
+   const
+   { return off_m + i0 + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) + i3*invariant_m.strides(3) 
+                       + i4*invariant_m.strides(4) + i5*invariant_m.strides(5) + i6*invariant_m.strides(6); }
+                     
+   inline int offset(const LoopInvariant_t&amp;) const
+   { return off_m; }
+   
+   inline int baseOffset(const LoopInvariant_t&amp;) const
+   { return off_m; }
+   
+   inline int offset(const LoopInvariant_t&amp;, int i0) const
+   { return off_m + i0; }
+   
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1) const
+   { return off_m + i0 + i1*li.strides(1); }
+   
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1, int i2) const
+   { return off_m + i0 + i1*li.strides(1) + i2*li.strides(2); }
+ 
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3) const
+   { return off_m + i0 + i1*li.strides(1) + i2*li.strides(2) + i3*li.strides(3); }
+                     
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4) const
+   { return off_m + i0 + i1*li.strides(1) + i2*li.strides(2) + i3*li.strides(3)
+                       + i4*li.strides(4); }
+                     
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5) const
+   { return off_m + i0 + i1*li.strides(1) + i2*li.strides(2) + i3*li.strides(3)
+                       + i4*li.strides(4) + i5*li.strides(5); }
+                     
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5, int i6) 
    const
!   { return off_m + i0 + i1*li.strides(1) + i2*li.strides(2) + i3*li.strides(3) 
!                       + i4*li.strides(4) + i5*li.strides(5) + i6*li.strides(6); }
                      
    inline int offset0(int i0) const
    { return i0; }
    
    inline int offset0(int i0, int i1) const
!   { return i0 + i1*invariant_m.strides(1); }
    
    inline int offset0(int i0, int i1, int i2) const
!   { return i0 + i1*invariant_m.strides(1) + i2*invariant_m.strides(2); }
    
    inline int offset0(int i0, int i1, int i2, int i3) const
!   { return i0 + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) + i3*invariant_m.strides(3); }
    
    inline int offset0(int i0, int i1, int i2, int i3, int i4) const
!   { return i0 + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) + i3*invariant_m.strides(3)
!               + i4*invariant_m.strides(4); }
    
    inline int offset0(int i0, int i1, int i2, int i3, int i4, int i5) const
!   { return i0 + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) + i3*invariant_m.strides(3)
!               + i4*invariant_m.strides(4) + i5*invariant_m.strides(5); }
    
    inline int offset0(int i0, int i1, int i2, int i3, int i4, int i5, int i6) 
    const
!   { return i0 + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) + i3*invariant_m.strides(3)
!               + i4*invariant_m.strides(4) + i5*invariant_m.strides(5) + i6*invariant_m.strides(6); }
      
+   inline int offset0(const LoopInvariant_t&amp; li, int i0) const
+   { return i0; }
+   
+   inline int offset0(const LoopInvariant_t&amp; li, int i0, int i1) const
+   { return i0 + i1*li.strides(1); }
+   
+   inline int offset0(const LoopInvariant_t&amp; li, int i0, int i1, int i2) const
+   { return i0 + i1*li.strides(1) + i2*li.strides(2); }
+   
+   inline int offset0(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3) const
+   { return i0 + i1*li.strides(1) + i2*li.strides(2) + i3*li.strides(3); }
+   
+   inline int offset0(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4) const
+   { return i0 + i1*li.strides(1) + i2*li.strides(2) + i3*li.strides(3)
+               + i4*li.strides(4); }
+   
+   inline int offset0(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5) const
+   { return i0 + i1*li.strides(1) + i2*li.strides(2) + i3*li.strides(3)
+               + i4*li.strides(4) + i5*li.strides(5); }
+   
+   inline int offset0(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5, int i6) 
+   const
+   { return i0 + i1*li.strides(1) + i2*li.strides(2) + i3*li.strides(3)
+               + i4*li.strides(4) + i5*li.strides(5) + i6*li.strides(6); }
+     
    inline int offsetC(int i0) const 
!   { return i0*invariant_m.strides(0); }
    
    inline int offsetC(int i0, int i1) const 
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1); }
    
    inline int offsetC(int i0, int i1, int i2) const
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1) + i2*invariant_m.strides(2); }
  
    inline int offsetC(int i0, int i1, int i2, int i3) const
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) 
!          + i3*invariant_m.strides(3); }
                      
    inline int offsetC(int i0, int i1, int i2, int i3, int i4) const
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) 
!          + i3*invariant_m.strides(3) + i4*invariant_m.strides(4); }
                      
    inline int offsetC(int i0, int i1, int i2, int i3, int i4, int i5) const
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) 
!          + i3*invariant_m.strides(3) + i4*invariant_m.strides(4) + i5*invariant_m.strides(5); }
                      
    inline int offsetC(int i0, int i1, int i2, int i3, int i4, int i5, int i6) 
    const
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) 
!       + i3*invariant_m.strides(3) + i4*invariant_m.strides(4) + i5*invariant_m.strides(5) 
!          + i6*invariant_m.strides(6); }
! 
!   inline int offsetC(const LoopInvariant_t&amp; li, int i0) const 
!   { return i0*li.strides(0); }
!   
!   inline int offsetC(const LoopInvariant_t&amp; li, int i0, int i1) const 
!   { return i0*li.strides(0) + i1*li.strides(1); }
!   
!   inline int offsetC(const LoopInvariant_t&amp; li, int i0, int i1, int i2) const
!   { return i0*li.strides(0) + i1*li.strides(1) + i2*li.strides(2); }
! 
!   inline int offsetC(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3) const
!   { return i0*li.strides(0) + i1*li.strides(1) + i2*li.strides(2) 
!          + i3*li.strides(3); }
!                     
!   inline int offsetC(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4) const
!   { return i0*li.strides(0) + i1*li.strides(1) + i2*li.strides(2) 
!          + i3*li.strides(3) + i4*li.strides(4); }
!                     
!   inline int offsetC(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5) const
!   { return i0*li.strides(0) + i1*li.strides(1) + i2*li.strides(2) 
!          + i3*li.strides(3) + i4*li.strides(4) + i5*li.strides(5); }
!                     
!   inline int offsetC(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5, int i6) 
!   const
!   { return i0*li.strides(0) + i1*li.strides(1) + i2*li.strides(2) 
!       + i3*li.strides(3) + i4*li.strides(4) + i5*li.strides(5) 
!          + i6*li.strides(6); }
! 
  protected:
  
    //============================================================
*************** protected:
*** 302,311 ****
    // on a noncompressible engine.
    
    void zeroStrides() 
!   { for (int d = 0; d &lt; Dim; ++d) strides_m[d] = 0; }
    
    void restoreStrides() 
!   { for (int d = 0; d &lt; Dim; ++d) strides_m[d] = ostrides_m[d]; }
    
    //============================================================
    // Protected data
--- 419,428 ----
    // on a noncompressible engine.
    
    void zeroStrides() 
!   { for (int d = 0; d &lt; Dim; ++d) invariant_m.strides(d) = 0; }
    
    void restoreStrides() 
!   { for (int d = 0; d &lt; Dim; ++d) invariant_m.strides(d) = ostrides_m[d]; }
    
    //============================================================
    // Protected data
*************** protected:
*** 315,327 ****
  
    Layout_t layout_m;
  
!   // Strides through actual data block when stepping in different directions.
!   // We keep two copies - strides_m is used by the offset calculations. 
!   // If we are compressible, then when compressed, these will all be 
!   // set to zero. 
!   
!   int strides_m[Dim];
!   
    int ostrides_m[Dim];
      
    // First index values (cached to optimize indexing).
--- 432,442 ----
  
    Layout_t layout_m;
  
!   // Values that do not change during the evaluation of a single 
!   // data parallel statement.
! 
!   LoopInvariant_t invariant_m;
! 
    int ostrides_m[Dim];
      
    // First index values (cached to optimize indexing).
*************** public:
*** 420,425 ****
--- 535,561 ----
    typedef Interval&lt;Dim&gt;  Domain_t;
    typedef DomainLayout&lt;Dim&gt; Layout_t;
    
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t {
+   public:
+ 
+     inline int *strides() { return strides_m; }
+     inline int&amp; strides(const int i) { return strides_m[i]; }
+     inline const int *strides() const { return strides_m; }
+     inline int strides(const int i) const { return strides_m[i]; }
+ 
+   private:
+ 
+     // Strides through actual data block when stepping in different directions.
+     // We keep two copies - strides_m is used by the offset calculations. 
+     // If we are compressible, then when compressed, these will all be 
+     // set to zero. 
+   
+     int strides_m[Dim];
+   };
+ 
    //============================================================
    // Constructors
    //============================================================
*************** public:
*** 491,499 ****
      baseOffset_m(bvbase.baseOffset())
    {
      DoubleSliceHelper&lt;Dim,Dim2&gt;::
!     init(domain_m, strides_m, baseOffset_m, 
           bvbase, dom);
!     for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = strides_m[d];
    }
    
    template &lt;int Dim2&gt;
--- 627,635 ----
      baseOffset_m(bvbase.baseOffset())
    {
      DoubleSliceHelper&lt;Dim,Dim2&gt;::
!     init(domain_m, invariant_m.strides(), baseOffset_m, 
           bvbase, dom);
!     for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = invariant_m.strides(d);
    }
    
    template &lt;int Dim2&gt;
*************** public:
*** 503,511 ****
      baseOffset_m(bvbase.baseOffset())
    {
      DoubleSliceHelper&lt;Dim,Dim2&gt;::
!     init(domain_m, strides_m, baseOffset_m,
           bvbase, dom);
!     for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = strides_m[d];
    }
    
    //============================================================
--- 639,647 ----
      baseOffset_m(bvbase.baseOffset())
    {
      DoubleSliceHelper&lt;Dim,Dim2&gt;::
!     init(domain_m, invariant_m.strides(), baseOffset_m,
           bvbase, dom);
!     for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = invariant_m.strides(d);
    }
    
    //============================================================
*************** public:
*** 530,539 ****
  
    inline Layout_t layout() const { return Layout_t(domain_m); }
  
!   // Return the strides array.
  
!   inline const int *strides() const { return &amp;strides_m[0]; }
    
    // Return the true strides array.
    
    inline const int *originalStrides() const { return &amp;ostrides_m[0]; }
--- 666,679 ----
  
    inline Layout_t layout() const { return Layout_t(domain_m); }
  
!   // Return the loop invariant object.
  
!   inline const LoopInvariant_t loopInvariant() const { return invariant_m; }
! 
!   // Return the strides array.
    
+   inline const int *strides() const { return invariant_m.strides(); }
+   
    // Return the true strides array.
    
    inline const int *originalStrides() const { return &amp;ostrides_m[0]; }
*************** public:
*** 552,588 ****
    int baseOffset() const { return baseOffset_m; }
    
    // Offset calculations
!   
    template &lt;class Domain&gt;
    int offset(const Domain &amp;) const;
    
    inline int offset(int i0) const 
!   { return i0*strides_m[0]; }
    
    inline int offset(int i0, int i1) const 
!   { return i0*strides_m[0] + i1*strides_m[1]; }
    
    inline int offset(int i0, int i1, int i2) const
!   { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2]; }
  
    inline int offset(int i0, int i1, int i2, int i3) const
!   { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2] 
!          + i3*strides_m[3]; }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4) const
!   { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2] 
!          + i3*strides_m[3] + i4*strides_m[4]; }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4, int i5) const
!   { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2] 
!          + i3*strides_m[3] + i4*strides_m[4] + i5*strides_m[5]; }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
      const
!   { return i0*strides_m[0] + i1*strides_m[1] + i2*strides_m[2] 
!          + i3*strides_m[3] + i4*strides_m[4] + i5*strides_m[5] 
!          + i6*strides_m[6]; }
    
  protected:
  
    //============================================================
--- 692,758 ----
    int baseOffset() const { return baseOffset_m; }
    
    // Offset calculations
! 
    template &lt;class Domain&gt;
    int offset(const Domain &amp;) const;
    
    inline int offset(int i0) const 
!   { return i0*invariant_m.strides(0); }
    
    inline int offset(int i0, int i1) const 
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1); }
    
    inline int offset(int i0, int i1, int i2) const
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1) + i2*invariant_m.strides(2); }
  
    inline int offset(int i0, int i1, int i2, int i3) const
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) 
!          + i3*invariant_m.strides(3); }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4) const
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) 
!          + i3*invariant_m.strides(3) + i4*invariant_m.strides(4); }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4, int i5) const
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) 
!          + i3*invariant_m.strides(3) + i4*invariant_m.strides(4) + i5*invariant_m.strides(5); }
                      
    inline int offset(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
      const
!   { return i0*invariant_m.strides(0) + i1*invariant_m.strides(1) + i2*invariant_m.strides(2) 
!       + i3*invariant_m.strides(3) + i4*invariant_m.strides(4) + i5*invariant_m.strides(5) 
!          + i6*invariant_m.strides(6); }
! 
!   template &lt;class Domain&gt;
!   int offset(const LoopInvariant_t&amp; li, const Domain &amp;) const;
    
+   inline int offset(const LoopInvariant_t&amp; li, int i0) const 
+   { return i0*li.strides(0); }
+   
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1) const 
+   { return i0*li.strides(0) + i1*li.strides(1); }
+   
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1, int i2) const
+   { return i0*li.strides(0) + i1*li.strides(1) + i2*li.strides(2); }
+ 
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3) const
+   { return i0*li.strides(0) + i1*li.strides(1) + i2*li.strides(2) 
+          + i3*li.strides(3); }
+                     
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4) const
+   { return i0*li.strides(0) + i1*li.strides(1) + i2*li.strides(2) 
+          + i3*li.strides(3) + i4*li.strides(4); }
+                     
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5) const
+   { return i0*li.strides(0) + i1*li.strides(1) + i2*li.strides(2) 
+          + i3*li.strides(3) + i4*li.strides(4) + i5*li.strides(5); }
+                     
+   inline int offset(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5, int i6)
+     const
+   { return i0*li.strides(0) + i1*li.strides(1) + i2*li.strides(2) 
+       + i3*li.strides(3) + i4*li.strides(4) + i5*li.strides(5) 
+          + i6*li.strides(6); }
+   
  protected:
  
    //============================================================
*************** protected:
*** 594,603 ****
    // on a noncompressible engine.
    
    void zeroStrides() 
!   { for (int d = 0; d &lt; Dim; ++d) strides_m[d] = 0; }
    
    void restoreStrides() 
!   { for (int d = 0; d &lt; Dim; ++d) strides_m[d] = ostrides_m[d]; }
    
    //============================================================
    // Utility functions
--- 764,773 ----
    // on a noncompressible engine.
    
    void zeroStrides() 
!   { for (int d = 0; d &lt; Dim; ++d) invariant_m.strides(d) = 0; }
    
    void restoreStrides() 
!   { for (int d = 0; d &lt; Dim; ++d) invariant_m.strides(d) = ostrides_m[d]; }
    
    //============================================================
    // Utility functions
*************** protected:
*** 625,631 ****
        {
  	PAssert(d &lt; Dim);
  	domain_m[d]  = Interval&lt;1&gt;(domain[dt].length());
! 	strides_m[d] = baseStrides[dt] * domain[dt].stride();
  	++d;
        }
          
--- 795,801 ----
        {
  	PAssert(d &lt; Dim);
  	domain_m[d]  = Interval&lt;1&gt;(domain[dt].length());
! 	invariant_m.strides(d) = baseStrides[dt] * domain[dt].stride();
  	++d;
        }
          
*************** protected:
*** 635,641 ****
  
      PAssert(d == Dim);
    
!     for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = strides_m[d];
    }
  
    void sliceInit(const This_t &amp;, const Range&lt;Dim&gt; &amp;domain);
--- 805,811 ----
  
      PAssert(d == Dim);
    
!     for (int d = 0; d &lt; Dim; ++d) ostrides_m[d] = invariant_m.strides(d);
    }
  
    void sliceInit(const This_t &amp;, const Range&lt;Dim&gt; &amp;domain);
*************** protected:
*** 645,652 ****
      for (int d = 0; d &lt; Dim; ++d)
      {
        domain_m[d]   = Interval&lt;1&gt;(domain[d].length());
!       strides_m[d]  = bbase.originalStrides()[d] * domain[d].stride();
!       ostrides_m[d] = strides_m[d];
        baseOffset_m  += domain[d].first() * bbase.originalStrides()[d];
      }
    }
--- 815,822 ----
      for (int d = 0; d &lt; Dim; ++d)
      {
        domain_m[d]   = Interval&lt;1&gt;(domain[d].length());
!       invariant_m.strides(d)  = bbase.originalStrides()[d] * domain[d].stride();
!       ostrides_m[d] = invariant_m.strides(d);
        baseOffset_m  += domain[d].first() * bbase.originalStrides()[d];
      }
    }
*************** protected:
*** 663,675 ****
    
    Domain_t domain_m;
  
!   // Strides through actual data block when stepping in each direction.
!   // We keep two copies - strides_m is used by the offset calculations. 
!   // If we are compressible, then when compressed, these will all be 
!   // set to zero. 
!   
!   int strides_m[Dim];
  
    int ostrides_m[Dim];
      
    // Base offset - offset of beginning of view from underlying Brick's
--- 833,843 ----
    
    Domain_t domain_m;
  
!   // Values that do not change during the evaluation of a single 
!   // data parallel statement.
  
+   LoopInvariant_t invariant_m;
+ 
    int ostrides_m[Dim];
      
    // Base offset - offset of beginning of view from underlying Brick's
*************** inline int BrickBase&lt;Dim&gt;::offset0(const
*** 707,713 ****
    CTAssert(Domain::dimensions == Dim);
    int offset = dom[0].first();
    for (int d = 1; d &lt; Dim; ++d)
!     offset += dom[d].first() * strides_m[d];
    return offset;
  }
  
--- 875,881 ----
    CTAssert(Domain::dimensions == Dim);
    int offset = dom[0].first();
    for (int d = 1; d &lt; Dim; ++d)
!     offset += dom[d].first() * invariant_m.strides(d);
    return offset;
  }
  
*************** template &lt;class Domain&gt;
*** 716,724 ****
  inline int BrickBase&lt;Dim&gt;::offsetC(const Domain &amp;dom) const
  {
    CTAssert(Domain::dimensions == Dim);
!   int offset = dom[0].first() * strides_m[0];
    for (int d = 1; d &lt; Dim; ++d)
!     offset += dom[d].first() * strides_m[d];
    return offset;
  }
  
--- 884,892 ----
  inline int BrickBase&lt;Dim&gt;::offsetC(const Domain &amp;dom) const
  {
    CTAssert(Domain::dimensions == Dim);
!   int offset = dom[0].first() * invariant_m.strides(0);
    for (int d = 1; d &lt; Dim; ++d)
!     offset += dom[d].first() * invariant_m.strides(d);
    return offset;
  }
  
*************** inline int BrickBase&lt;Dim&gt;::offset(const 
*** 729,735 ****
--- 897,936 ----
    return off_m + offset0(dom);
  }
  
+ // HERE
+ template &lt;int Dim&gt;
+ template &lt;class Domain&gt;
+ inline int BrickBase&lt;Dim&gt;::offset0(const LoopInvariant_t &amp;li,
+ 				   const Domain &amp;dom) const
+ {
+   CTAssert(Domain::dimensions == Dim);
+   int offset = dom[0].first();
+   for (int d = 1; d &lt; Dim; ++d)
+     offset += dom[d].first() * li.strides(d);
+   return offset;
+ }
  
+ template &lt;int Dim&gt;
+ template &lt;class Domain&gt;
+ inline int BrickBase&lt;Dim&gt;::offsetC(const LoopInvariant_t &amp;li,
+ 				   const Domain &amp;dom) const
+ {
+   CTAssert(Domain::dimensions == Dim);
+   int offset = dom[0].first() * li.strides(0);
+   for (int d = 1; d &lt; Dim; ++d)
+     offset += dom[d].first() * li.strides(d);
+   return offset;
+ }
+ 
+ template &lt;int Dim&gt;
+ template &lt;class Domain&gt;
+ inline int BrickBase&lt;Dim&gt;::offset(const LoopInvariant_t &amp;,
+ 				  const Domain &amp;dom) const
+ {
+   return off_m + offset0(dom);
+ }
+ 
+ 
  //////////////////////////////////////////////////////////////////////
  //
  // Inline implementation of the functions for BrickViewBase
*************** template &lt;class Domain&gt;
*** 745,754 ****
  inline int BrickViewBase&lt;Dim&gt;::
  offset(const Domain &amp;dom) const
  {
    CTAssert(Domain::dimensions == Dim);
!   int offset = dom[0].first() * strides_m[0];
    for (int d = 1; d &lt; Dim; ++d)
!     offset += dom[d].first() * strides_m[d];
    return offset;
  }
  
--- 946,967 ----
  inline int BrickViewBase&lt;Dim&gt;::
  offset(const Domain &amp;dom) const
  {
+   CTAssert(Domain::dimensions == Dim);
+   int offset = dom[0].first() * invariant_m.strides(0);
+   for (int d = 1; d &lt; Dim; ++d)
+     offset += dom[d].first() * invariant_m.strides(d);
+   return offset;
+ }
+ 
+ template &lt;int Dim&gt;
+ template &lt;class Domain&gt;
+ inline int BrickViewBase&lt;Dim&gt;::
+ offset(const LoopInvariant_t&amp; li, const Domain &amp;dom) const
+ {
    CTAssert(Domain::dimensions == Dim);
!   int offset = dom[0].first() * li.strides(0);
    for (int d = 1; d &lt; Dim; ++d)
!     offset += dom[d].first() * li.strides(d);
    return offset;
  }
  
Index: src/Engine/BrickEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/BrickEngine.h,v
retrieving revision 1.131
diff -c -p -r1.131 BrickEngine.h
*** src/Engine/BrickEngine.h	2001/10/17 17:47:35	1.131
--- src/Engine/BrickEngine.h	2001/11/05 19:28:26
*************** public:
*** 147,152 ****
--- 147,153 ----
    typedef T                                Element_t;
    typedef T&amp;                               ElementRef_t;
    typedef Brick                            Tag_t;
+   typedef typename Base_t::LoopInvariant_t BaseLoopInvariant_t;
  
    enum { brick         = true  };
    enum { dimensions    = Dim   };
*************** public:
*** 155,160 ****
--- 156,182 ----
    enum { zeroBased     = false };
    enum { multiPatch    = false };
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t : public BaseLoopInvariant_t {
+   public:
+ 
+     LoopInvariant_t(const BaseLoopInvariant_t&amp; bli,
+ 		    T* data)
+       : BaseLoopInvariant_t(bli), data_m(data)
+     {}
+ 
+     inline
+     T* data() const { return data_m; }
+ 
+   private:
+ 
+     // This points to the same data as dataBlock_m but permits faster access.
+ 
+     T* data_m;
+   };
+ 
    //============================================================
    // Constructors and Factory Methods
    //============================================================
*************** public:
*** 224,230 ****
--- 246,255 ----
    // Element access via Loc.
  
    Element_t read(const Loc&lt;Dim&gt; &amp;) const;
+   Element_t read(const LoopInvariant_t&amp;, const Loc&lt;Dim&gt; &amp;) const;
+ 
    ElementRef_t operator()(const Loc&lt;Dim&gt; &amp;) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, const Loc&lt;Dim&gt; &amp;) const;
  
    // Element access via ints for speed.
  
*************** public:
*** 236,241 ****
--- 261,274 ----
    Element_t read(int, int, int, int, int, int) const;
    Element_t read(int, int, int, int, int, int, int) const;
  
+   Element_t read(const LoopInvariant_t&amp;, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    ElementRef_t operator()(int) const;
    ElementRef_t operator()(int, int) const;
    ElementRef_t operator()(int, int, int) const;
*************** public:
*** 244,249 ****
--- 277,290 ----
    ElementRef_t operator()(int, int, int, int, int, int) const;
    ElementRef_t operator()(int, int, int, int, int, int, int) const;
  
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    // Get a private copy of data viewed by this Engine.
  
    Engine_t &amp;makeOwnCopy();
*************** public:
*** 266,271 ****
--- 307,318 ----
    
    bool isShared() const { return dataBlock_m.isValid() &amp;&amp; dataBlock_m.count() &gt; 1; }
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   inline const LoopInvariant_t loopInvariant() const 
+     { return LoopInvariant_t(Base_t::loopInvariant(), data_m); }
+ 
  private:
  
    //============================================================
*************** public:
*** 324,329 ****
--- 371,377 ----
    typedef T                                         Element_t;
    typedef T&amp;                                        ElementRef_t;
    typedef BrickView                                 Tag_t;
+   typedef typename Base_t::LoopInvariant_t 	    BaseLoopInvariant_t;
  
    enum { dimensions    = Dim   };
    enum { hasDataObject = true  };
*************** public:
*** 331,336 ****
--- 379,400 ----
    enum { zeroBased     = true  };
    enum { multiPatch    = false };
    
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t : public BaseLoopInvariant_t {
+   public:
+ 
+     LoopInvariant_t(const BaseLoopInvariant_t&amp; bli,
+ 		    T*                         data)
+       : Base_t::LoopInvariant_t(bli), data_m(data) {}
+ 
+     T* data() const { return data_m; }
+ 
+   private:
+     T* data_m;
+   };
+ 
    //============================================================
    // Constructors
    //============================================================
*************** public:
*** 360,366 ****
    
    template &lt;class ETag, class DT&gt;
    Engine(const Engine&lt;Dim,T,ETag&gt; &amp;e, const Domain&lt;Dim, DT&gt; &amp;dom)
!   : Base_t(e, dom.unwrap()), dataBlock_m(e.dataBlock(), e.offset(dom.unwrap())),
      data_m(dataBlock_m.currentPointer())
    { 
      // The engine's data pointer should be at the beginning.
--- 424,430 ----
    
    template &lt;class ETag, class DT&gt;
    Engine(const Engine&lt;Dim,T,ETag&gt; &amp;e, const Domain&lt;Dim, DT&gt; &amp;dom)
!     : Base_t(e, dom.unwrap()), dataBlock_m(e.dataBlock(), e.offset(dom.unwrap())),
      data_m(dataBlock_m.currentPointer())
    { 
      // The engine's data pointer should be at the beginning.
*************** public:
*** 470,476 ****
--- 534,543 ----
    // Element access via Loc.
  
    Element_t read(const Loc&lt;Dim&gt; &amp;) const;
+   Element_t read(const LoopInvariant_t&amp;, const Loc&lt;Dim&gt; &amp;) const;
+ 
    ElementRef_t operator()(const Loc&lt;Dim&gt; &amp;) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, const Loc&lt;Dim&gt; &amp;) const;
  
    // Element access via ints for speed.
  
*************** public:
*** 482,487 ****
--- 549,562 ----
    Element_t read(int, int, int, int, int, int) const;
    Element_t read(int, int, int, int, int, int, int) const;
  
+   Element_t read(const LoopInvariant_t&amp;, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    ElementRef_t operator()(int) const;
    ElementRef_t operator()(int, int) const;
    ElementRef_t operator()(int, int, int) const;
*************** public:
*** 490,495 ****
--- 565,578 ----
    ElementRef_t operator()(int, int, int, int, int, int) const;
    ElementRef_t operator()(int, int, int, int, int, int, int) const;
  
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    // Return the DataBlockPtr. See comments in BrickEngine above.
    
    DataBlockPtr&lt;T&gt; dataBlock()              { return dataBlock_m; }
*************** public:
*** 501,506 ****
--- 584,593 ----
    inline 
    Pooma::DataObject_t *dataObject() const { return dataBlock_m.dataObject(); }
  
+   inline
+   const LoopInvariant_t loopInvariant() const 
+   { return LoopInvariant_t(Base_t::loopInvariant(), data_m); }
+ 
  private:
  
    //============================================================
*************** private:
*** 513,518 ****
--- 600,607 ----
    
    DataBlockPtr&lt;T&gt; dataBlock_m;
  
+   // This points to the same data as dataBlock_m but permits faster access.
+ 
    T *data_m;
  };
  
*************** read(int i1, int i2, int i3, int i4, int
*** 748,753 ****
--- 837,905 ----
  }
  
  template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,Brick&gt;::
+ read(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
+ {
+   return li.data()[offset(li, loc)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,Brick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1) const
+ {
+   PAssert(Dim == 1);
+   return li.data()[offset(li, i1)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,Brick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2) const
+ {
+   PAssert(Dim == 2);
+   return li.data()[offset(li,i1,i2)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,Brick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3) const
+ {
+   PAssert(Dim == 3);
+   return li.data()[offset(li, i1,i2,i3)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,Brick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4) const
+ {
+   PAssert(Dim == 4);
+   return li.data()[offset(li, i1,i2,i3,i4)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,Brick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5) const
+ {
+   PAssert(Dim == 5);
+   return li.data()[offset(li, i1,i2,i3,i4,i5)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,Brick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6) const
+ {
+   PAssert(Dim == 6);
+   return li.data()[offset(li, i1,i2,i3,i4,i5,i6)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,Brick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
+ {
+   PAssert(Dim == 7);
+   return li.data()[offset(li, i1,i2,i3,i4,i5,i6,i7)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
  inline T &amp; Engine&lt;Dim,T,Brick&gt;::
  operator()(const Loc&lt;Dim&gt; &amp;loc) const
  {
*************** operator()(int i1, int i2, int i3, int i
*** 810,815 ****
--- 962,1031 ----
    return data_m[offset(i1,i2,i3,i4,i5,i6,i7)];
  }
  
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,Brick&gt;::
+ operator()(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
+ {
+   return li.data()[offset(li, loc)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,Brick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1) const
+ {
+   PAssert(Dim == 1);
+   return li.data()[offset(li, i1)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,Brick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2) const
+ {
+   PAssert(Dim == 2);
+   return li.data()[offset(li, i1,i2)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,Brick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3) const
+ {
+   PAssert(Dim == 3);
+   return li.data()[offset(li, i1,i2,i3)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,Brick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4) const
+ {
+   PAssert(Dim == 4);
+   return li.data()[offset(li, i1,i2,i3,i4)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,Brick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5) const
+ {
+   PAssert(Dim == 5);
+   return li.data()[offset(li, i1,i2,i3,i4,i5)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,Brick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6) const
+ {
+   PAssert(Dim == 6);
+   return li.data()[offset(li, i1,i2,i3,i4,i5,i6)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,Brick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
+ {
+   PAssert(Dim == 7);
+   return li.data()[offset(li, i1,i2,i3,i4,i5,i6,i7)];
+ }
+ 
+ 
  //////////////////////////////////////////////////////////////////////
  //
  // Inline implementation of the functions for Engine&lt;D,T,BrickView&gt;
*************** read(int i1, int i2, int i3, int i4, int
*** 873,879 ****
    return data_m[offset(i1,i2,i3,i4,i5,i6)];
  }
  
- 
  template &lt;int Dim, class T&gt;
  inline T Engine&lt;Dim,T,BrickView&gt;::
  read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
--- 1089,1094 ----
*************** read(int i1, int i2, int i3, int i4, int
*** 883,888 ****
--- 1098,1166 ----
  }
  
  template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,BrickView&gt;::
+ read(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
+ {
+   return li.data()[offset(li, loc)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,BrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1) const
+ {
+   PAssert(Dim == 1);
+   return li.data()[offset(li, i1)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,BrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2) const
+ {
+   PAssert(Dim == 2);
+   return li.data()[offset(li, i1,i2)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,BrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3) const
+ {
+   PAssert(Dim == 3);
+   return li.data()[offset(li, i1,i2,i3)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,BrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4) const
+ {
+   PAssert(Dim == 4);
+   return li.data()[offset(li, i1,i2,i3,i4)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,BrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5) const
+ {
+   PAssert(Dim == 5);
+   return li.data()[offset(li, i1,i2,i3,i4,i5)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,BrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6) const
+ {
+   PAssert(Dim == 6);
+   return li.data()[offset(li, i1,i2,i3,i4,i5,i6)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,BrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
+ {
+   PAssert(Dim == 7);
+   return li.data()[offset(li, i1,i2,i3,i4,i5,i6,i7)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
  inline T &amp; Engine&lt;Dim,T,BrickView&gt;::
  operator()(const Loc&lt;Dim&gt; &amp;loc) const
  {
*************** operator()(int i1, int i2, int i3, int i
*** 944,949 ****
--- 1222,1291 ----
  {
    PAssert(Dim == 7);
    return data_m[offset(i1,i2,i3,i4,i5,i6,i7)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,BrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
+ {
+   return li.data()[offset(li, loc)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,BrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1) const
+ {
+   PAssert(Dim == 1);
+   return li.data()[offset(li, i1)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,BrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2) const
+ {
+   PAssert(Dim == 2);
+   return li.data()[offset(li, i1,i2)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,BrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3) const
+ {
+   PAssert(Dim == 3);
+   return li.data()[offset(li, i1,i2,i3)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,BrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4) const
+ {
+   PAssert(Dim == 4);
+   return li.data()[offset(li, i1,i2,i3,i4)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,BrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5) const
+ {
+   PAssert(Dim == 5);
+   return li.data()[offset(li, i1,i2,i3,i4,i5)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,BrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6) const
+ {
+   PAssert(Dim == 6);
+   return li.data()[offset(li, i1,i2,i3,i4,i5,i6)];
+ }
+ 
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,BrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
+ {
+   PAssert(Dim == 7);
+   return li.data()[offset(li, i1,i2,i3,i4,i5,i6,i7)];
  }
  
  // } // namespace Pooma
Index: src/Engine/CompressibleBrick.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/CompressibleBrick.cpp,v
retrieving revision 1.26
diff -c -p -r1.26 CompressibleBrick.cpp
*** src/Engine/CompressibleBrick.cpp	2001/05/23 21:13:30	1.26
--- src/Engine/CompressibleBrick.cpp	2001/11/05 19:28:26
*************** Engine(const Engine&lt;Dim,T,CompressibleBr
*** 112,118 ****
    
    cblock_m.lock();
    
!   data0_m = modelEngine.data0_m; // Must copy while locked.
    
    Base_t::operator=(modelEngine);
    
--- 112,118 ----
    
    cblock_m.lock();
    
!   data_m = modelEngine.data_m; // Must copy while locked.
    
    Base_t::operator=(modelEngine);
    
*************** operator=(const Engine&lt;Dim,T,Compressibl
*** 172,178 ****
         
        lock();
        
!       data0_m = modelEngine.data0_m;
  
        Base_t::operator=(modelEngine);
              
--- 172,178 ----
         
        lock();
        
!       data_m = modelEngine.data_m;
  
        Base_t::operator=(modelEngine);
              
*************** void Engine&lt;Dim,T,CompressibleBrick&gt;::in
*** 212,218 ****
  template &lt;int Dim, class T&gt;
  Engine&lt;Dim,T,CompressibleBrick&gt;::~Engine()
  {
!   if (data0_m)
      {
        cblock_m.lock();
        if (cblock_m.isControllerValidUnlocked())
--- 212,218 ----
  template &lt;int Dim, class T&gt;
  Engine&lt;Dim,T,CompressibleBrick&gt;::~Engine()
  {
!   if (data_m)
      {
        cblock_m.lock();
        if (cblock_m.isControllerValidUnlocked())
*************** Engine&lt;Dim,T,CompressibleBrick&gt; &amp;Engine&lt;
*** 254,260 ****
        cblock_m.makeOwnCopy();
        cblock_m.attach(this);
  
!       data0_m = cblock_m.data() + (cblock_m.compressed() ? 0 : baseOffset());
      }
  
    return *this;
--- 254,260 ----
        cblock_m.makeOwnCopy();
        cblock_m.attach(this);
  
!       data_m = cblock_m.data() + (cblock_m.compressed() ? 0 : baseOffset());
      }
  
    return *this;
*************** Engine&lt;Dim,T,CompressibleBrick&gt; &amp;Engine&lt;
*** 269,275 ****
  // The notification comes with a pointer to the new data.
  //  
  // Note: The CBC is locked when this is called, so we don't have to
! // worry about contention for changing strides_m/data0_m, but we
  // do need to make sure no one tries to make a copy of these data
  // while they are being changed. Thus we lock our mutex.
  //
--- 269,275 ----
  // The notification comes with a pointer to the new data.
  //  
  // Note: The CBC is locked when this is called, so we don't have to
! // worry about contention for changing strides_m/data_m, but we
  // do need to make sure no one tries to make a copy of these data
  // while they are being changed. Thus we lock our mutex.
  //
*************** notify(T* &amp;data, const ObserverEvent &amp;ev
*** 294,306 ****
      case CompressibleBlock&lt;T&gt;::notifyUncompress: 
        lock();
        restoreStrides();
!       data0_m = data + baseOffset();
        unlock();
        break;
      case CompressibleBlock&lt;T&gt;::notifyCompress:
        lock();
        zeroStrides();
!       data0_m = data;
        unlock();
        break;
      }
--- 294,306 ----
      case CompressibleBlock&lt;T&gt;::notifyUncompress: 
        lock();
        restoreStrides();
!       data_m = data + baseOffset();
        unlock();
        break;
      case CompressibleBlock&lt;T&gt;::notifyCompress:
        lock();
        zeroStrides();
!       data_m = data;
        unlock();
        break;
      }
*************** void Engine&lt;Dim,T,CompressibleBrick&gt;::re
*** 323,334 ****
    if (cblock_m.compressed())
      {
        zeroStrides();
!       data0_m = cblock_m.data();
      }
    else
      {
        restoreStrides();
!       data0_m = cblock_m.data() + baseOffset();
      }
  }
  
--- 323,334 ----
    if (cblock_m.compressed())
      {
        zeroStrides();
!       data_m = cblock_m.data();
      }
    else
      {
        restoreStrides();
!       data_m = cblock_m.data() + baseOffset();
      }
  }
  
*************** operator=(const Engine&lt;Dim,T,Compressibl
*** 432,438 ****
         
        lock();
        
!       data0_m  = modelEngine.data0_m;
        Base_t::operator=(modelEngine);
        
        unlock();
--- 432,438 ----
         
        lock();
        
!       data_m  = modelEngine.data_m;
        Base_t::operator=(modelEngine);
        
        unlock();
*************** Engine(const Engine&lt;Dim,T,CompressibleBr
*** 469,475 ****
    // This being a constructor, no-one else can try to use our strides
    // and data0 until we're done, so locking our mutex is unnecessary.
    
!   data0_m = modelEngine.data0_m;
    Base_t::operator=(modelEngine);
      
    if (cblock_m.isControllerValidUnlocked()) cblock_m.attach(this);
--- 469,475 ----
    // This being a constructor, no-one else can try to use our strides
    // and data0 until we're done, so locking our mutex is unnecessary.
    
!   data_m = modelEngine.data_m;
    Base_t::operator=(modelEngine);
      
    if (cblock_m.isControllerValidUnlocked()) cblock_m.attach(this);
*************** Engine(const Engine&lt;Dim,T,CompressibleBr
*** 491,497 ****
    // This being a constructor, no-one else can try to use our strides
    // and data0 until we're done, so locking our mutex is unnecessary.
    
!   data0_m = modelEngine.data0_m;
    Base_t::operator=(modelEngine);
      
    if (cblock_m.isControllerValidUnlocked()) cblock_m.attach(this);
--- 491,497 ----
    // This being a constructor, no-one else can try to use our strides
    // and data0 until we're done, so locking our mutex is unnecessary.
    
!   data_m = modelEngine.data_m;
    Base_t::operator=(modelEngine);
      
    if (cblock_m.isControllerValidUnlocked()) cblock_m.attach(this);
Index: src/Engine/CompressibleBrick.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/CompressibleBrick.h,v
retrieving revision 1.72
diff -c -p -r1.72 CompressibleBrick.h
*** src/Engine/CompressibleBrick.h	2001/09/13 20:55:03	1.72
--- src/Engine/CompressibleBrick.h	2001/11/05 19:28:26
*************** public:
*** 138,143 ****
--- 138,144 ----
    typedef T                                  Element_t;
    typedef T&amp;                                 ElementRef_t;
    typedef CompressibleBrick                  Tag_t;
+   typedef typename Base_t::LoopInvariant_t   BaseLoopInvariant_t;
  
    enum { brick         = true  };
    enum { dimensions    = Dim   };
*************** public:
*** 145,150 ****
--- 146,167 ----
    enum { dynamic       = false };
    enum { zeroBased     = false };
    enum { multiPatch    = false };
+ 
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t : public BaseLoopInvariant_t {
+   public:
+ 
+     LoopInvariant_t(const BaseLoopInvariant_t&amp; bli,
+ 		    T*                         data)
+       : Base_t::LoopInvariant_t(bli), data_m(data) {}
+ 
+     T* data() const { return data_m; }
+ 
+   private:
+     T* data_m;
+   };
    
    //============================================================
    // Constructors and Factory Methods
*************** public:
*** 153,159 ****
    // Default constructor. Creates a CompressibleBrick-Engine with no
    // data and an &quot;empty&quot; domain.
  
!   Engine() : data0_m(0) { }
  
    // Construct a CompressibleBrick-Engine representing a Dim-dimensional
    // brick (Fortran storage order) of elements of type T. The domain can
--- 170,176 ----
    // Default constructor. Creates a CompressibleBrick-Engine with no
    // data and an &quot;empty&quot; domain.
  
!   Engine() : data_m(0) { }
  
    // Construct a CompressibleBrick-Engine representing a Dim-dimensional
    // brick (Fortran storage order) of elements of type T. The domain can
*************** public:
*** 217,222 ****
--- 234,247 ----
    ElementRef_t operator()(int, int, int, int, int, int) const;
    ElementRef_t operator()(int, int, int, int, int, int, int) const;
  
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    // Read-only access.
    // Guaranteed to be fast since there's no if-test.
  
*************** public:
*** 228,237 ****
--- 253,272 ----
    Element_t read(int, int, int, int, int, int) const;
    Element_t read(int, int, int, int, int, int, int) const;
  
+   Element_t read(const LoopInvariant_t&amp;, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    // Element access via Loc.
  
    ElementRef_t operator()(const Loc&lt;Dim&gt; &amp;) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, const Loc&lt;Dim&gt; &amp;) const;
    Element_t read(const Loc&lt;Dim&gt; &amp;) const;
+   Element_t read(const LoopInvariant_t&amp;, const Loc&lt;Dim&gt; &amp;) const;
  
    //---------------------------------------------------------------------------
    // Return the domain and base domain.
*************** public:
*** 302,307 ****
--- 337,347 ----
    
    bool compressedBrickIsWholeView() const { return true; }
  
+   // Loop invariants.
+ 
+   inline const
+   LoopInvariant_t loopInvariant() const { return LoopInvariant_t(); }
+ 
  private:
  
    //============================================================
*************** private:
*** 317,326 ****
    // construction. If compressed, this simply points to the
    // compressed value.
  
!   T *data0_m;
  
    // Mutex protection for the CompressibleBricks.
!   // The strides_m and data0_m members can be changed asynchronously
    // by the notify method (when someone else compresses or uncompresses
    // a copy of the underlying CBC). Thus it is necessary to protect
    // most accesses to these members. Since Smarts will prevent an
--- 357,366 ----
    // construction. If compressed, this simply points to the
    // compressed value.
  
!   T *data_m;
  
    // Mutex protection for the CompressibleBricks.
!   // The strides_m and data_m members can be changed asynchronously
    // by the notify method (when someone else compresses or uncompresses
    // a copy of the underlying CBC). Thus it is necessary to protect
    // most accesses to these members. Since Smarts will prevent an
*************** private:
*** 344,350 ****
    // The notification comes with a pointer to the new data.
    
    // Note: The CBC is locked when this is called, so we don't have to
!   // worry about contention for changing strides_m/data0_m, but we
    // do need to make sure no one tries to make a copy of these data
    // while they are being changed. Thus we lock our mutex.
  
--- 384,390 ----
    // The notification comes with a pointer to the new data.
    
    // Note: The CBC is locked when this is called, so we don't have to
!   // worry about contention for changing strides_m/data_m, but we
    // do need to make sure no one tries to make a copy of these data
    // while they are being changed. Thus we lock our mutex.
  
*************** public:
*** 411,416 ****
--- 451,457 ----
    typedef T                                             Element_t;
    typedef T&amp;                                            ElementRef_t;
    typedef CompressibleBrickView                         Tag_t;
+   typedef typename Base_t::LoopInvariant_t 	        BaseLoopInvariant_t;
  
    enum { dimensions    = Dim   };
    enum { hasDataObject = true  };
*************** public:
*** 418,423 ****
--- 459,480 ----
    enum { zeroBased     = true  };
    enum { multiPatch    = false };
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t : public BaseLoopInvariant_t {
+   public:
+ 
+     LoopInvariant_t(const BaseLoopInvariant_t&amp; bli,
+ 		    T*                         data)
+       : Base_t::LoopInvariant_t(bli), data_m(data) {}
+ 
+     T* data() const { return data_m; }
+ 
+   private:
+     T* data_m;
+   };
+ 
    //============================================================
    // Constructors and Factory Methods
    //============================================================
*************** public:
*** 425,431 ****
    // Default constructor. Creates a CompressibleBrickView-Engine with no
    // data and an &quot;empty&quot; domain.
  
!   Engine() : data0_m(0) { }
  
    // Copy constructor performs a SHALLOW copy:
  
--- 482,488 ----
    // Default constructor. Creates a CompressibleBrickView-Engine with no
    // data and an &quot;empty&quot; domain.
  
!   Engine() : data_m(0) { }
  
    // Copy constructor performs a SHALLOW copy:
  
*************** public:
*** 550,555 ****
--- 607,620 ----
    ElementRef_t operator()(int, int, int, int, int, int) const;
    ElementRef_t operator()(int, int, int, int, int, int, int) const;
  
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    // Read-only access.
    // Guaranteed to be fast since there's no if-test.
  
*************** public:
*** 561,570 ****
--- 626,645 ----
    Element_t read(int, int, int, int, int, int) const;
    Element_t read(int, int, int, int, int, int, int) const;
  
+   Element_t read(const LoopInvariant_t&amp;, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    // Element access via Loc.
  
    ElementRef_t operator()(const Loc&lt;Dim&gt; &amp;) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, const Loc&lt;Dim&gt; &amp;) const;
    Element_t read(const Loc&lt;Dim&gt; &amp;) const;
+   Element_t read(const LoopInvariant_t&amp;, const Loc&lt;Dim&gt; &amp;) const;
    
    //---------------------------------------------------------------------------
    // Return the domain and base domain.
*************** public:
*** 614,619 ****
--- 689,699 ----
    
    long elementsCompressed() const;
  
+   // Loop invariants.
+ 
+   inline const LoopInvariant_t loopInvariant() const 
+   { return LoopInvariant_t(Base_t::loopInvariant(), data_m); }
+ 
  private:
  
    // Mutex functions
*************** private:
*** 627,633 ****
    // The notification comes with a pointer to the new data.
  
    // Note: The CBC is locked when this is called, so we don't have to
!   // worry about contention for changind strides_m/data0_m, but we
    // do need to make sure no one tries to make a copy of these data
    // while they are being changed. Thus we lock our mutex.
  
--- 707,713 ----
    // The notification comes with a pointer to the new data.
  
    // Note: The CBC is locked when this is called, so we don't have to
!   // worry about contention for changind strides_m/data_m, but we
    // do need to make sure no one tries to make a copy of these data
    // while they are being changed. Thus we lock our mutex.
  
*************** private:
*** 644,656 ****
        case CompressibleBlock&lt;T&gt;::notifyUncompress: 
          lock();
          restoreStrides();
! 	data0_m = data + baseOffset();
  	unlock();
  	break;
        case CompressibleBlock&lt;T&gt;::notifyCompress:
          lock();
          zeroStrides();
! 	data0_m = data;
  	unlock();
  	break;
        }
--- 724,736 ----
        case CompressibleBlock&lt;T&gt;::notifyUncompress: 
          lock();
          restoreStrides();
! 	data_m = data + baseOffset();
  	unlock();
  	break;
        case CompressibleBlock&lt;T&gt;::notifyCompress:
          lock();
          zeroStrides();
! 	data_m = data;
  	unlock();
  	break;
        }
*************** private:
*** 688,699 ****
      if (cblock_m.compressed())
        {
          zeroStrides();
! 	data0_m = cblock_m.data();
        }
      else
        {
          restoreStrides();
! 	data0_m = cblock_m.data() + baseOffset();
        }
    }
  
--- 768,779 ----
      if (cblock_m.compressed())
        {
          zeroStrides();
! 	data_m = cblock_m.data();
        }
      else
        {
          restoreStrides();
! 	data_m = cblock_m.data() + baseOffset();
        }
    }
  
*************** private:
*** 710,716 ****
    // construction. If compressed, this simply points to the
    // compressed value.
  
!   T *data0_m;
    
    // Flag that tells whether we're viewing the entire domain.
    
--- 790,796 ----
    // construction. If compressed, this simply points to the
    // compressed value.
  
!   T *data_m;
    
    // Flag that tells whether we're viewing the entire domain.
    
*************** private:
*** 719,725 ****
    // Mutex protection for the CompressibleBricks.
    // This must be locked when changes are made via a notify
    // method, which can happen asynchronously, and when 
!   // the items changed (strides_m and data0_m) are accessed.
    
    mutable Pooma::Mutex_t mutex_m;
  
--- 799,805 ----
    // Mutex protection for the CompressibleBricks.
    // This must be locked when changes are made via a notify
    // method, which can happen asynchronously, and when 
!   // the items changed (strides_m and data_m) are accessed.
    
    mutable Pooma::Mutex_t mutex_m;
  
*************** template &lt;int Dim, class T&gt;
*** 833,839 ****
  inline T Engine&lt;Dim,T,CompressibleBrick&gt;::
  read(const Loc&lt;Dim&gt; &amp;loc) const
  {
!   return data0_m[offsetC(loc)];
  }
  
  template &lt;int Dim, class T&gt;
--- 913,919 ----
  inline T Engine&lt;Dim,T,CompressibleBrick&gt;::
  read(const Loc&lt;Dim&gt; &amp;loc) const
  {
!   return data_m[offsetC(loc)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrick&gt;
*** 841,847 ****
  read(int i1) const
  {
    PAssert(Dim == 1);
!   return data0_m[offsetC(i1)];
  }
  
  template &lt;int Dim, class T&gt;
--- 921,927 ----
  read(int i1) const
  {
    PAssert(Dim == 1);
!   return data_m[offsetC(i1)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrick&gt;
*** 849,855 ****
  read(int i1, int i2) const
  {
    PAssert(Dim == 2);
!   return data0_m[offsetC(i1,i2)];
  }
  
  template &lt;int Dim, class T&gt;
--- 929,935 ----
  read(int i1, int i2) const
  {
    PAssert(Dim == 2);
!   return data_m[offsetC(i1,i2)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrick&gt;
*** 857,863 ****
  read(int i1, int i2, int i3) const
  {
    PAssert(Dim == 3);
!   return data0_m[offsetC(i1,i2,i3)];
  }
  
  template &lt;int Dim, class T&gt;
--- 937,943 ----
  read(int i1, int i2, int i3) const
  {
    PAssert(Dim == 3);
!   return data_m[offsetC(i1,i2,i3)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrick&gt;
*** 865,871 ****
  read(int i1, int i2, int i3, int i4) const
  {
    PAssert(Dim == 4);
!   return data0_m[offsetC(i1,i2,i3,i4)];
  }
  
  template &lt;int Dim, class T&gt;
--- 945,951 ----
  read(int i1, int i2, int i3, int i4) const
  {
    PAssert(Dim == 4);
!   return data_m[offsetC(i1,i2,i3,i4)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrick&gt;
*** 873,879 ****
  read(int i1, int i2, int i3, int i4, int i5) const
  {
    PAssert(Dim == 5);
!   return data0_m[offsetC(i1,i2,i3,i4,i5)];
  }
  
  template &lt;int Dim, class T&gt;
--- 953,959 ----
  read(int i1, int i2, int i3, int i4, int i5) const
  {
    PAssert(Dim == 5);
!   return data_m[offsetC(i1,i2,i3,i4,i5)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrick&gt;
*** 881,887 ****
  read(int i1, int i2, int i3, int i4, int i5, int i6) const
  {
    PAssert(Dim == 6);
!   return data0_m[offsetC(i1,i2,i3,i4,i5,i6)];
  }
  
  template &lt;int Dim, class T&gt;
--- 961,967 ----
  read(int i1, int i2, int i3, int i4, int i5, int i6) const
  {
    PAssert(Dim == 6);
!   return data_m[offsetC(i1,i2,i3,i4,i5,i6)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrick&gt;
*** 889,903 ****
  read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PAssert(Dim == 7);
!   return data0_m[offsetC(i1,i2,i3,i4,i5,i6,i7)];
  }
  
  template &lt;int Dim, class T&gt;
  inline T &amp; Engine&lt;Dim,T,CompressibleBrick&gt;::
  operator()(const Loc&lt;Dim&gt; &amp;loc) const
  {
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offsetC(loc)];
  }
  
  template &lt;int Dim, class T&gt;
--- 969,1046 ----
  read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PAssert(Dim == 7);
!   return data_m[offsetC(i1,i2,i3,i4,i5,i6,i7)];
! }
! 
! template &lt;int Dim, class T&gt;
! inline T Engine&lt;Dim,T,CompressibleBrick&gt;::
! read(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
! {
!   return li.data()[offsetC(li, loc)];
! }
! 
! template &lt;int Dim, class T&gt;
! inline T Engine&lt;Dim,T,CompressibleBrick&gt;::
! read(const LoopInvariant_t&amp; li, int i1) const
! {
!   PAssert(Dim == 1);
!   return li.data()[offsetC(li, i1)];
  }
  
  template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2) const
+ {
+   PAssert(Dim == 2);
+   return li.data()[offsetC(li, i1,i2)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3) const
+ {
+   PAssert(Dim == 3);
+   return li.data()[offsetC(li, i1,i2,i3)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4) const
+ {
+   PAssert(Dim == 4);
+   return li.data()[offsetC(li, i1,i2,i3,i4)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5) const
+ {
+   PAssert(Dim == 5);
+   return li.data()[offsetC(li, i1,i2,i3,i4,i5)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6) const
+ {
+   PAssert(Dim == 6);
+   return li.data()[offsetC(li, i1,i2,i3,i4,i5,i6)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrick&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
+ {
+   PAssert(Dim == 7);
+   return li.data()[offsetC(li, i1,i2,i3,i4,i5,i6,i7)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
  inline T &amp; Engine&lt;Dim,T,CompressibleBrick&gt;::
  operator()(const Loc&lt;Dim&gt; &amp;loc) const
  {
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offsetC(loc)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1) const
*** 906,912 ****
  {
    PAssert(Dim == 1);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offsetC(i1)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1049,1055 ----
  {
    PAssert(Dim == 1);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offsetC(i1)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1, int i2) const
*** 915,921 ****
  {
    PAssert(Dim == 2);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offsetC(i1,i2)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1058,1064 ----
  {
    PAssert(Dim == 2);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offsetC(i1,i2)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1, int i2, int i3) const
*** 924,930 ****
  {
    PAssert(Dim == 3);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offsetC(i1,i2,i3)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1067,1073 ----
  {
    PAssert(Dim == 3);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offsetC(i1,i2,i3)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1, int i2, int i3, int i
*** 933,939 ****
  {
    PAssert(Dim == 4);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offsetC(i1,i2,i3,i4)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1076,1082 ----
  {
    PAssert(Dim == 4);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offsetC(i1,i2,i3,i4)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1, int i2, int i3, int i
*** 942,948 ****
  {
    PAssert(Dim == 5);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offsetC(i1,i2,i3,i4,i5)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1085,1091 ----
  {
    PAssert(Dim == 5);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offsetC(i1,i2,i3,i4,i5)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1, int i2, int i3, int i
*** 951,957 ****
  {
    PAssert(Dim == 6);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offsetC(i1,i2,i3,i4,i5,i6)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1094,1100 ----
  {
    PAssert(Dim == 6);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offsetC(i1,i2,i3,i4,i5,i6)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T &amp; Engine&lt;Dim,T,CompressibleBric
*** 959,969 ****
  operator()(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PAssert(Dim == 7);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offsetC(i1,i2,i3,i4,i5,i6,i7)];
  }
  
  template &lt;int Dim, class T&gt;
  inline bool
  Engine&lt;Dim,T,CompressibleBrick&gt;::
  compressed() const
--- 1102,1184 ----
  operator()(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PAssert(Dim == 7);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return data_m[offsetC(i1,i2,i3,i4,i5,i6,i7)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrick&gt;::
+ operator()(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
+ {
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offsetC(li, loc)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1) const
+ {
+   PAssert(Dim == 1);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offsetC(li, i1)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2) const
+ {
+   PAssert(Dim == 2);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offsetC(li, i1,i2)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3) const
+ {
+   PAssert(Dim == 3);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offsetC(li, i1,i2,i3)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4) const
+ {
+   PAssert(Dim == 4);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offsetC(li, i1,i2,i3,i4)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5) const
+ {
+   PAssert(Dim == 5);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offsetC(li, i1,i2,i3,i4,i5)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6) const
+ {
+   PAssert(Dim == 6);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return li.data()[offsetC(li, i1,i2,i3,i4,i5,i6)];
  }
  
  template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrick&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
+ {
+   PAssert(Dim == 7);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offsetC(li, i1,i2,i3,i4,i5,i6,i7)];
+ }
+ 
+ 
+ template &lt;int Dim, class T&gt;
  inline bool
  Engine&lt;Dim,T,CompressibleBrick&gt;::
  compressed() const
*************** compressedRead() const 
*** 979,985 ****
  {
    PAssert(cblock_m.isControllerValidUnlocked());
    PAssert(cblock_m.compressed());
!   return *data0_m;
  }
  
  template &lt;int Dim, class T&gt;
--- 1194,1200 ----
  {
    PAssert(cblock_m.isControllerValidUnlocked());
    PAssert(cblock_m.compressed());
!   return *data_m;
  }
  
  template &lt;int Dim, class T&gt;
*************** compressedReadWrite() const
*** 989,995 ****
  {
    PAssert(cblock_m.isControllerValidUnlocked());
    PAssert(cblock_m.compressed());
!   return *data0_m;
  }
  
  
--- 1204,1210 ----
  {
    PAssert(cblock_m.isControllerValidUnlocked());
    PAssert(cblock_m.compressed());
!   return *data_m;
  }
  
  
*************** template &lt;int Dim, class T&gt;
*** 1033,1039 ****
  inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
  read(const Loc&lt;Dim&gt; &amp;loc) const
  {
!   return data0_m[offset(loc)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1248,1254 ----
  inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
  read(const Loc&lt;Dim&gt; &amp;loc) const
  {
!   return data_m[offset(loc)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrickV
*** 1041,1047 ****
  read(int i1) const
  {
    PAssert(Dim == 1);
!   return data0_m[offset(i1)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1256,1262 ----
  read(int i1) const
  {
    PAssert(Dim == 1);
!   return data_m[offset(i1)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrickV
*** 1049,1055 ****
  read(int i1, int i2) const
  {
    PAssert(Dim == 2);
!   return data0_m[offset(i1,i2)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1264,1270 ----
  read(int i1, int i2) const
  {
    PAssert(Dim == 2);
!   return data_m[offset(i1,i2)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrickV
*** 1057,1063 ****
  read(int i1, int i2, int i3) const
  {
    PAssert(Dim == 3);
!   return data0_m[offset(i1,i2,i3)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1272,1278 ----
  read(int i1, int i2, int i3) const
  {
    PAssert(Dim == 3);
!   return data_m[offset(i1,i2,i3)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrickV
*** 1065,1071 ****
  read(int i1, int i2, int i3, int i4) const
  {
    PAssert(Dim == 4);
!   return data0_m[offset(i1,i2,i3,i4)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1280,1286 ----
  read(int i1, int i2, int i3, int i4) const
  {
    PAssert(Dim == 4);
!   return data_m[offset(i1,i2,i3,i4)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrickV
*** 1073,1079 ****
  read(int i1, int i2, int i3, int i4, int i5) const
  {
    PAssert(Dim == 5);
!   return data0_m[offset(i1,i2,i3,i4,i5)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1288,1294 ----
  read(int i1, int i2, int i3, int i4, int i5) const
  {
    PAssert(Dim == 5);
!   return data_m[offset(i1,i2,i3,i4,i5)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T Engine&lt;Dim,T,CompressibleBrickV
*** 1081,1087 ****
  read(int i1, int i2, int i3, int i4, int i5, int i6) const
  {
    PAssert(Dim == 6);
!   return data0_m[offset(i1,i2,i3,i4,i5,i6)];
  }
  
  
--- 1296,1302 ----
  read(int i1, int i2, int i3, int i4, int i5, int i6) const
  {
    PAssert(Dim == 6);
!   return data_m[offset(i1,i2,i3,i4,i5,i6)];
  }
  
  
*************** template &lt;int Dim, class T&gt;
*** 1089,1104 ****
  inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
  read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PAssert(Dim == 7);
!   return data0_m[offset(i1,i2,i3,i4,i5,i6,i7)];
  }
  
  template &lt;int Dim, class T&gt;
  inline T &amp; Engine&lt;Dim,T,CompressibleBrickView&gt;::
  operator()(const Loc&lt;Dim&gt; &amp;loc) const
  {
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offset(loc)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1304,1384 ----
  inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
  read(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
+   PAssert(Dim == 7);
+   return data_m[offset(i1,i2,i3,i4,i5,i6,i7)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ read(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
+ {
+   return li.data()[offset(li, loc)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1) const
+ {
+   PAssert(Dim == 1);
+   return li.data()[offset(li, i1)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2) const
+ {
+   PAssert(Dim == 2);
+   return li.data()[offset(li, i1,i2)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3) const
+ {
+   PAssert(Dim == 3);
+   return li.data()[offset(li, i1,i2,i3)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4) const
+ {
+   PAssert(Dim == 4);
+   return li.data()[offset(li, i1,i2,i3,i4)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5) const
+ {
+   PAssert(Dim == 5);
+   return li.data()[offset(li, i1,i2,i3,i4,i5)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6) const
+ {
+   PAssert(Dim == 6);
+   return li.data()[offset(li, i1,i2,i3,i4,i5,i6)];
+ }
+ 
+ 
+ template &lt;int Dim, class T&gt;
+ inline T Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ read(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
+ {
    PAssert(Dim == 7);
!   return li.data()[offset(li, i1,i2,i3,i4,i5,i6,i7)];
  }
  
+ 
  template &lt;int Dim, class T&gt;
  inline T &amp; Engine&lt;Dim,T,CompressibleBrickView&gt;::
  operator()(const Loc&lt;Dim&gt; &amp;loc) const
  {
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offset(loc)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1) const
*** 1107,1113 ****
  {
    PAssert(Dim == 1);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offset(i1)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1387,1393 ----
  {
    PAssert(Dim == 1);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offset(i1)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1, int i2) const
*** 1116,1122 ****
  {
    PAssert(Dim == 2);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offset(i1,i2)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1396,1402 ----
  {
    PAssert(Dim == 2);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offset(i1,i2)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1, int i2, int i3) const
*** 1125,1131 ****
  {
    PAssert(Dim == 3);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offset(i1,i2,i3)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1405,1411 ----
  {
    PAssert(Dim == 3);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offset(i1,i2,i3)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1, int i2, int i3, int i
*** 1134,1140 ****
  {
    PAssert(Dim == 4);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offset(i1,i2,i3,i4)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1414,1420 ----
  {
    PAssert(Dim == 4);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offset(i1,i2,i3,i4)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1, int i2, int i3, int i
*** 1143,1149 ****
  {
    PAssert(Dim == 5);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offset(i1,i2,i3,i4,i5)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1423,1429 ----
  {
    PAssert(Dim == 5);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offset(i1,i2,i3,i4,i5)];
  }
  
  template &lt;int Dim, class T&gt;
*************** operator()(int i1, int i2, int i3, int i
*** 1152,1158 ****
  {
    PAssert(Dim == 6);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offset(i1,i2,i3,i4,i5,i6)];
  }
  
  template &lt;int Dim, class T&gt;
--- 1432,1438 ----
  {
    PAssert(Dim == 6);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data_m[offset(i1,i2,i3,i4,i5,i6)];
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T &amp; Engine&lt;Dim,T,CompressibleBric
*** 1160,1167 ****
  operator()(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PAssert(Dim == 7);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return data0_m[offset(i1,i2,i3,i4,i5,i6,i7)];
  }
  
  
--- 1440,1518 ----
  operator()(int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
  {
    PAssert(Dim == 7);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return data_m[offset(i1,i2,i3,i4,i5,i6,i7)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
+ {
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offset(li, loc)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1) const
+ {
+   PAssert(Dim == 1);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offset(li, i1)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2) const
+ {
+   PAssert(Dim == 2);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offset(li, i1,i2)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3) const
+ {
+   PAssert(Dim == 3);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offset(li, i1,i2,i3)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4) const
+ {
+   PAssert(Dim == 4);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offset(li, i1,i2,i3,i4)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5) const
+ {
+   PAssert(Dim == 5);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offset(li, i1,i2,i3,i4,i5)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6) const
+ {
+   PAssert(Dim == 6);
+   if (cblock_m.compressed()) cblock_m.uncompress();
+   return li.data()[offset(li, i1,i2,i3,i4,i5,i6)];
+ }
+ 
+ template &lt;int Dim, class T&gt;
+ inline T &amp; Engine&lt;Dim,T,CompressibleBrickView&gt;::
+ operator()(const LoopInvariant_t&amp; li, int i1, int i2, int i3, int i4, int i5, int i6, int i7) const
+ {
+   PAssert(Dim == 7);
    if (cblock_m.compressed()) cblock_m.uncompress();
!   return li.data()[offset(li, i1,i2,i3,i4,i5,i6,i7)];
  }
  
  
*************** inline T Engine&lt;Dim,T,CompressibleBrickV
*** 1170,1176 ****
  compressedRead() const 
  {
    PAssert(cblock_m.compressed());
!   return *data0_m;
  }
  
  template &lt;int Dim, class T&gt;
--- 1521,1527 ----
  compressedRead() const 
  {
    PAssert(cblock_m.compressed());
!   return *data_m;
  }
  
  template &lt;int Dim, class T&gt;
*************** inline T&amp; Engine&lt;Dim,T,CompressibleBrick
*** 1178,1184 ****
  compressedReadWrite() const 
  {
    PAssert(cblock_m.compressed());
!   return *data0_m;
  }
  
  //
--- 1529,1535 ----
  compressedReadWrite() const 
  {
    PAssert(cblock_m.compressed());
!   return *data_m;
  }
  
  //
Index: src/Engine/ConstantFunctionEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/ConstantFunctionEngine.h,v
retrieving revision 1.19
diff -c -p -r1.19 ConstantFunctionEngine.h
*** src/Engine/ConstantFunctionEngine.h	2001/09/26 00:14:40	1.19
--- src/Engine/ConstantFunctionEngine.h	2001/11/05 19:28:26
*************** public:
*** 98,103 ****
--- 98,115 ----
    enum { zeroBased = false };
    enum { multiPatch = false };
  
+   class LoopInvariant_t {
+   public:
+     LoopInvariant_t(T val) : val_m(val) {}
+ 
+     T val() const { return val_m; }
+ 
+     void setVal(T val) { val_m = val; }
+ 
+   private:
+     T val_m;
+   };
+ 
    //---------------------------------------------------------------------------
    // Default constructor.
  
*************** public:
*** 107,113 ****
    // Construct from a domain object.
  
    explicit Engine(const Domain_t &amp;domain, T val = T())
!   : val_m(val), domain_m(domain)
    { 
      for (int d = 0; d &lt; Dim; ++d)
        firsts_m[d] = domain[d].first();
--- 119,125 ----
    // Construct from a domain object.
  
    explicit Engine(const Domain_t &amp;domain, T val = T())
!   : invariant_m(val), domain_m(domain)
    { 
      for (int d = 0; d &lt; Dim; ++d)
        firsts_m[d] = domain[d].first();
*************** public:
*** 115,121 ****
  
    template&lt;class Layout&gt;
    explicit Engine(const Layout &amp;layout, T val = T())
!   : val_m(val), domain_m(layout.domain())
    { 
      for (int d = 0; d &lt; Dim; ++d)
        firsts_m[d] = domain_m[d].first();
--- 127,133 ----
  
    template&lt;class Layout&gt;
    explicit Engine(const Layout &amp;layout, T val = T())
!   : invariant_m(val), domain_m(layout.domain())
    { 
      for (int d = 0; d &lt; Dim; ++d)
        firsts_m[d] = domain_m[d].first();
*************** public:
*** 125,131 ****
    // Copy constructor.
  
    Engine(const Engine&lt;Dim, T, ConstantFunction&gt; &amp;model)
!   : val_m(model.constant()), domain_m(model.domain())
    {
      for (int d = 0; d &lt; Dim; ++d)
        {
--- 137,143 ----
    // Copy constructor.
  
    Engine(const Engine&lt;Dim, T, ConstantFunction&gt; &amp;model)
!   : invariant_m(model.constant()), domain_m(model.domain())
    {
      for (int d = 0; d &lt; Dim; ++d)
        {
*************** public:
*** 138,144 ****
  
    template&lt;class DT&gt;
    Engine(const Engine&lt;Dim, T, ConstantFunction&gt; &amp;e, const Domain&lt;Dim, DT&gt; &amp;dom)
!   : val_m(e.constant()), domain_m(Pooma::NoInit())
    {
      const typename DT::Domain_t &amp;domain = dom.unwrap();
      for (int d = 0; d &lt; Dim; ++d)
--- 150,156 ----
  
    template&lt;class DT&gt;
    Engine(const Engine&lt;Dim, T, ConstantFunction&gt; &amp;e, const Domain&lt;Dim, DT&gt; &amp;dom)
!   : invariant_m(e.constant()), domain_m(Pooma::NoInit())
    {
      const typename DT::Domain_t &amp;domain = dom.unwrap();
      for (int d = 0; d &lt; Dim; ++d)
*************** public:
*** 151,157 ****
    template&lt;int Dim2, class DT&gt;
    Engine(const Engine&lt;Dim2, T, ConstantFunction&gt; &amp;e, 
      const SliceDomain&lt;DT&gt; &amp;dom)
!   : val_m(e.constant()), domain_m(Pooma::NoInit())
    {
      // The domain's dimension should match ours.
      
--- 163,169 ----
    template&lt;int Dim2, class DT&gt;
    Engine(const Engine&lt;Dim2, T, ConstantFunction&gt; &amp;e, 
      const SliceDomain&lt;DT&gt; &amp;dom)
!   : invariant_m(e.constant()), domain_m(Pooma::NoInit())
    {
      // The domain's dimension should match ours.
      
*************** public:
*** 168,174 ****
  
    template&lt;class Domain&gt;
    Engine(const Engine&lt;Dim, T, ConstantFunction&gt; &amp;e, const Node&lt;Domain&gt; &amp;node)
!   : val_m(e.constant()), domain_m(Pooma::NoInit())
    {
      // The nodes's dimension should match ours.
      
--- 180,186 ----
  
    template&lt;class Domain&gt;
    Engine(const Engine&lt;Dim, T, ConstantFunction&gt; &amp;e, const Node&lt;Domain&gt; &amp;node)
!   : invariant_m(e.constant()), domain_m(Pooma::NoInit())
    {
      // The nodes's dimension should match ours.
      
*************** public:
*** 183,189 ****
    }
  
    Engine(const Engine&lt;Dim, T, ConstantFunction&gt; &amp;e, const INode&lt;Dim&gt; &amp;inode)
!   : val_m(e.constant()), domain_m(Pooma::NoInit())
    {
      const typename INode&lt;Dim&gt;::Domain_t &amp;domain = inode.domain();
      for (int d = 0; d &lt; Dim; ++d)
--- 195,201 ----
    }
  
    Engine(const Engine&lt;Dim, T, ConstantFunction&gt; &amp;e, const INode&lt;Dim&gt; &amp;inode)
!   : invariant_m(e.constant()), domain_m(Pooma::NoInit())
    {
      const typename INode&lt;Dim&gt;::Domain_t &amp;domain = inode.domain();
      for (int d = 0; d &lt; Dim; ++d)
*************** public:
*** 200,234 ****
  
    inline Element_t read(int) const 
      {
!       return val_m;
      }
    inline Element_t read(int, int) const 
      {
!       return val_m;
      }
    inline Element_t read(int, int, int) const 
      {
!       return val_m;
      }
    inline Element_t read(int, int, int, int) const 
      {
!       return val_m;
      }
    inline Element_t read(int, int, int, int, int) const 
      {
!       return val_m;
      }
    inline Element_t read(int, int, int, int, int, int) const 
      {
!       return val_m;
      }
    inline Element_t read(int, int, int, int, int, int, int) const 
      {
!       return val_m;
      }
    inline Element_t read(const Loc&lt;Dim&gt; &amp;) const
      {
!       return val_m;
      }
  
    //---------------------------------------------------------------------------
--- 212,279 ----
  
    inline Element_t read(int) const 
      {
!       return invariant_m.val();
      }
    inline Element_t read(int, int) const 
      {
!       return invariant_m.val();
      }
    inline Element_t read(int, int, int) const 
      {
!       return invariant_m.val();
      }
    inline Element_t read(int, int, int, int) const 
      {
!       return invariant_m.val();
      }
    inline Element_t read(int, int, int, int, int) const 
      {
!       return invariant_m.val();
      }
    inline Element_t read(int, int, int, int, int, int) const 
      {
!       return invariant_m.val();
      }
    inline Element_t read(int, int, int, int, int, int, int) const 
      {
!       return invariant_m.val();
      }
    inline Element_t read(const Loc&lt;Dim&gt; &amp;) const
+     {
+       return invariant_m.val();
+     }
+ 
+   inline Element_t read(const LoopInvariant_t&amp; li, int) const 
+     {
+       return li.val();
+     }
+   inline Element_t read(const LoopInvariant_t&amp; li, int, int) const 
+     {
+       return li.val();
+     }
+   inline Element_t read(const LoopInvariant_t&amp; li, int, int, int) const 
+     {
+       return li.val();
+     }
+   inline Element_t read(const LoopInvariant_t&amp; li, int, int, int, int) const 
+     {
+       return li.val();
+     }
+   inline Element_t read(const LoopInvariant_t&amp; li, int, int, int, int, int) const 
+     {
+       return li.val();
+     }
+   inline Element_t read(const LoopInvariant_t&amp; li, int, int, int, int, int, int) const 
+     {
+       return li.val();
+     }
+   inline Element_t read(const LoopInvariant_t&amp; li, int, int, int, int, int, int, int) const 
+     {
+       return li.val();
+     }
+   inline Element_t read(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;) const
      {
!       return li.val();
      }
  
    //---------------------------------------------------------------------------
*************** public:
*** 251,263 ****
  
    //---------------------------------------------------------------------------
    // Accessors/modifiers.
  
!   T constant() const { return val_m; }
!   void setConstant(T val) { val_m = val; }
  
  private:
  
!   T val_m;
    Domain_t domain_m;
    int firsts_m[Dim];
  };
--- 296,313 ----
  
    //---------------------------------------------------------------------------
    // Accessors/modifiers.
+ 
+   T constant() const { return invariant_m.val(); }
+   void setConstant(T val) { invariant_m.setVal(val); }
+ 
+   //---------------------------------------------------------------------------
+   // Loop invariants.
  
!   LoopInvariant_t loopInvariant() const { return invariant_m; }
  
  private:
  
!   LoopInvariant_t invariant_m;
    Domain_t domain_m;
    int firsts_m[Dim];
  };
Index: src/Engine/DynamicEngine.cpp
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/DynamicEngine.cpp,v
retrieving revision 1.14
diff -c -p -r1.14 DynamicEngine.cpp
*** src/Engine/DynamicEngine.cpp	2001/05/08 23:34:40	1.14
--- src/Engine/DynamicEngine.cpp	2001/11/05 19:28:26
*************** template &lt;class T&gt; Engine&lt;1,T,Dynamic&gt;::
*** 54,83 ****
  template &lt;class T&gt;
  Engine&lt;1,T,Dynamic&gt;::Engine(const Domain_t &amp;dom)
    : domain_m(dom),
!     data_m(dom.size()), 
      first_m(dom.first())
  { }
  
  template &lt;class T&gt;
  Engine&lt;1,T,Dynamic&gt;::Engine(const Node&lt;Domain_t&gt; &amp;node)
    : domain_m(node.allocated()),
!     data_m(node.allocated().size(), 
             node.affinity(), 
             DataBlockPtr&lt;T&gt;::WithAffinity_t()),
      first_m(node.allocated().first())
  { }
  
  template &lt;class T&gt;
  Engine&lt;1,T,Dynamic&gt;::Engine(const Layout_t &amp;layout)
    : domain_m(layout.domain()),
!     data_m(layout.domain().size()), 
      first_m(layout.domain().first())
  { }
  
  template &lt;class T&gt;
  Engine&lt;1,T,Dynamic&gt;::Engine(const Domain_t &amp;dom, const T&amp; model)
    : domain_m(dom),
!     data_m(dom.size(), model), 
      first_m(dom.first())
  { }
  
--- 54,86 ----
  template &lt;class T&gt;
  Engine&lt;1,T,Dynamic&gt;::Engine(const Domain_t &amp;dom)
    : domain_m(dom),
!     dataBlock_m(dom.size()),
!     data_m(dataBlock_m.currentPointer()),
      first_m(dom.first())
  { }
  
  template &lt;class T&gt;
  Engine&lt;1,T,Dynamic&gt;::Engine(const Node&lt;Domain_t&gt; &amp;node)
    : domain_m(node.allocated()),
!     dataBlock_m(node.allocated().size(), 
             node.affinity(), 
             DataBlockPtr&lt;T&gt;::WithAffinity_t()),
+     data_m(dataBlock_m.currentPointer()),
      first_m(node.allocated().first())
  { }
  
  template &lt;class T&gt;
  Engine&lt;1,T,Dynamic&gt;::Engine(const Layout_t &amp;layout)
    : domain_m(layout.domain()),
!     dataBlock_m(layout.domain().size()), 
!     data_m(dataBlock_m.currentPointer()),
      first_m(layout.domain().first())
  { }
  
  template &lt;class T&gt;
  Engine&lt;1,T,Dynamic&gt;::Engine(const Domain_t &amp;dom, const T&amp; model)
    : domain_m(dom),
!     dataBlock_m(dom.size(), model), 
      first_m(dom.first())
  { }
  
*************** template &lt;class T&gt;
*** 85,94 ****
  Engine&lt;1,T,Dynamic&gt;::
  Engine(const This_t &amp;modelEngine)
    : domain_m(modelEngine.domain_m),
!     data_m(modelEngine.data_m),
      first_m(modelEngine.first_m)
  {
!   PAssert(data_m.isAtBeginning());
  }
  
  //-----------------------------------------------------------------------------
--- 88,98 ----
  Engine&lt;1,T,Dynamic&gt;::
  Engine(const This_t &amp;modelEngine)
    : domain_m(modelEngine.domain_m),
!     dataBlock_m(modelEngine.dataBlock_m),
!     data_m(dataBlock_m.currentPointer()),
      first_m(modelEngine.first_m)
  {
!   PAssert(dataBlock_m.isAtBeginning());
  }
  
  //-----------------------------------------------------------------------------
*************** operator=(const This_t &amp;modelEngine)
*** 106,116 ****
  
    if (this != &amp;modelEngine)
      {
!       domain_m = modelEngine.domain_m;
!       data_m   = modelEngine.data_m;
!       first_m  = modelEngine.first_m;
  
!       PAssert(data_m.isAtBeginning());
      }
    return *this;
  }
--- 110,121 ----
  
    if (this != &amp;modelEngine)
      {
!       domain_m    = modelEngine.domain_m;
!       dataBlock_m = modelEngine.dataBlock_m;
!       data_m      = modelEngine.data_m;
!       first_m     = modelEngine.first_m;
  
!       PAssert(dataBlock_m.isAtBeginning());
      }
    return *this;
  }
*************** Engine&lt;1,T,Dynamic&gt; &amp;
*** 139,148 ****
  Engine&lt;1,T,Dynamic&gt;::
  makeOwnCopy()
  {
!   if (data_m.isValid() &amp;&amp; data_m.count() &gt; 1) 
      {
!       PAssert(data_m.isAtBeginning());
!       data_m.makeOwnCopy();
      }
  
    return *this;
--- 144,154 ----
  Engine&lt;1,T,Dynamic&gt;::
  makeOwnCopy()
  {
!   if (dataBlock_m.isValid() &amp;&amp; dataBlock_m.count() &gt; 1) 
      {
!       PAssert(dataBlock_m.isAtBeginning());
!       dataBlock_m.makeOwnCopy();
!       data_m = dataBlock_m.currentPointer();
      }
  
    return *this;
*************** create(CreateSize_t num)
*** 169,179 ****
    // take place inside iterates which means the engine is a copy of another
    // engine, so the data is shared.
    //
!   //  PAssert(!data_m.isShared());
    
    // Reallocate the storage
  
!   data_m.resizeAndCopy(domain_m.size() + num); // initialize new elements!
  
    // Reset the domain (in the layout) to the new size
  
--- 175,186 ----
    // take place inside iterates which means the engine is a copy of another
    // engine, so the data is shared.
    //
!   //  PAssert(!dataBlock_m.isShared());
    
    // Reallocate the storage
  
!   dataBlock_m.resizeAndCopy(domain_m.size() + num); // initialize new elements!
!   data_m = dataBlock_m.currentPointer();
  
    // Reset the domain (in the layout) to the new size
  
*************** template &lt;class T&gt;
*** 203,209 ****
  template &lt;class Dom&gt;
  void Engine&lt;1,T,Dynamic&gt;::destroy(const Dom &amp;killList)
  {
!   //  PAssert(!data_m.isShared());
    performDestroy(killList, BackFill(), false);
  }
  
--- 210,216 ----
  template &lt;class Dom&gt;
  void Engine&lt;1,T,Dynamic&gt;::destroy(const Dom &amp;killList)
  {
!   //  PAssert(!dataBlock_m.isShared());
    performDestroy(killList, BackFill(), false);
  }
  
*************** template &lt;class T&gt;
*** 211,217 ****
  template &lt;class Iter&gt;
  void Engine&lt;1,T,Dynamic&gt;::destroy(Iter begin, Iter end)
  {
!   //  PAssert(!data_m.isShared());
    performDestroy(begin, end, BackFill(), false);
  }
  
--- 218,224 ----
  template &lt;class Iter&gt;
  void Engine&lt;1,T,Dynamic&gt;::destroy(Iter begin, Iter end)
  {
!   //  PAssert(!dataBlock_m.isShared());
    performDestroy(begin, end, BackFill(), false);
  }
  
*************** template &lt;class Dom, class DeleteMethod&gt;
*** 220,226 ****
  void Engine&lt;1,T,Dynamic&gt;::
  destroy(const Dom &amp;killList, const DeleteMethod &amp;method, bool offsetFlag)
  {
!   //  PAssert(!data_m.isShared());
    performDestroy(killList, method, offsetFlag);
  }
  
--- 227,233 ----
  void Engine&lt;1,T,Dynamic&gt;::
  destroy(const Dom &amp;killList, const DeleteMethod &amp;method, bool offsetFlag)
  {
!   //  PAssert(!dataBlock_m.isShared());
    performDestroy(killList, method, offsetFlag);
  }
  
*************** template &lt;class Iter, class DeleteMethod
*** 229,235 ****
  void Engine&lt;1,T,Dynamic&gt;::
  destroy(Iter begin, Iter end, const DeleteMethod &amp;method, bool offsetFlag)
  {
!   //  PAssert(!data_m.isShared());
    performDestroy(begin, end, method, offsetFlag);
  }
  
--- 236,242 ----
  void Engine&lt;1,T,Dynamic&gt;::
  destroy(Iter begin, Iter end, const DeleteMethod &amp;method, bool offsetFlag)
  {
!   //  PAssert(!dataBlock_m.isShared());
    performDestroy(begin, end, method, offsetFlag);
  }
  
*************** performDestroy(const Iterator &amp;killBegin
*** 331,337 ****
    // Use the generic delete algorithm to do the work.
    
    int killed =
!     Pooma::Algorithms::delete_backfill(data_m.begin(), data_m.end(),
                                         killBegin, killEnd, koffset);
  
    // Update the domain.
--- 338,344 ----
    // Use the generic delete algorithm to do the work.
    
    int killed =
!     Pooma::Algorithms::delete_backfill(dataBlock_m.begin(), dataBlock_m.end(),
                                         killBegin, killEnd, koffset);
  
    // Update the domain.
*************** performDestroy(const Iterator &amp;killBegin
*** 349,355 ****
    
    // Resize the data block to the new domain size.
  
!   data_m.resize(domain().size(), DataBlockPtr&lt;T&gt;::NoInitTag());
  }
  
  // Now the version that takes a general domain. 
--- 356,363 ----
    
    // Resize the data block to the new domain size.
  
!   dataBlock_m.resize(domain().size(), DataBlockPtr&lt;T&gt;::NoInitTag());
!   data_m = dataBlock_m.currentPointer();
  }
  
  // Now the version that takes a general domain. 
*************** performDestroy(const Iterator &amp;killBegin
*** 409,415 ****
    int koffset = (offsetFlag ? 0 : first_m);
  
    int killed =
!     Pooma::Algorithms::delete_shiftup(data_m.begin(), data_m.end(),
                                        killBegin, killEnd, koffset);
  
    Interval&lt;1&gt; newdom;
--- 417,423 ----
    int koffset = (offsetFlag ? 0 : first_m);
  
    int killed =
!     Pooma::Algorithms::delete_shiftup(dataBlock_m.begin(), dataBlock_m.end(),
                                        killBegin, killEnd, koffset);
  
    Interval&lt;1&gt; newdom;
*************** performDestroy(const Iterator &amp;killBegin
*** 419,425 ****
  
    domain_m = newdom;
    
!   data_m.resize(domain().size(), DataBlockPtr&lt;T&gt;::NoInitTag());
  }
  
  template &lt;class T&gt; 
--- 427,434 ----
  
    domain_m = newdom;
    
!   dataBlock_m.resize(domain().size(), DataBlockPtr&lt;T&gt;::NoInitTag());
!   data_m = dataBlock_m.currentPointer();
  }
  
  template &lt;class T&gt; 
*************** performDestroy(const Domain &amp;killList, c
*** 453,459 ****
  //
  // void sync(Domain_t)
  //
! // modify the domain (but not the size) of this engine.
  //
  //-----------------------------------------------------------------------------
  
--- 462,468 ----
  //
  // void sync(Domain_t)
  //
! // Modify the domain (but not the size) of this engine.
  //
  //-----------------------------------------------------------------------------
  
*************** Engine&lt;1,T,Dynamic&gt;::sync(const Domain_t
*** 486,492 ****
  template &lt;class T&gt;
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const Engine&lt;1,T,Dynamic&gt; &amp;engine, const Interval&lt;1&gt; &amp;dom)
! : data_m(engine.dataBlock(), dom.first() - engine.domain().first()),
    domain_m(Interval&lt;1&gt;(dom.length())),
    stride_m(1)
  {    
--- 495,502 ----
  template &lt;class T&gt;
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const Engine&lt;1,T,Dynamic&gt; &amp;engine, const Interval&lt;1&gt; &amp;dom)
! : dataBlock_m(engine.dataBlock(), dom.first() - engine.domain().first()),
!   data_m(dataBlock_m.currentPointer()),
    domain_m(Interval&lt;1&gt;(dom.length())),
    stride_m(1)
  {    
*************** template &lt;class T&gt;
*** 498,504 ****
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const Engine&lt;1,T,Dynamic&gt; &amp;engine, const Range&lt;1&gt; &amp;dom)
  : domain_m(Interval&lt;1&gt;(dom.length())),
!   data_m(engine.dataBlock(), dom.first() - engine.domain().first()),
    stride_m(dom.stride())
  {    
    // The engine's data pointer should be at the beginning.
--- 508,515 ----
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const Engine&lt;1,T,Dynamic&gt; &amp;engine, const Range&lt;1&gt; &amp;dom)
  : domain_m(Interval&lt;1&gt;(dom.length())),
!   dataBlock_m(engine.dataBlock(), dom.first() - engine.domain().first()),
!   data_m(dataBlock_m.currentPointer()),
    stride_m(dom.stride())
  {    
    // The engine's data pointer should be at the beginning.
*************** template &lt;class T&gt;
*** 509,515 ****
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const This_t &amp;engine, const Interval&lt;1&gt; &amp;dom)
  : domain_m(Interval&lt;1&gt;(dom.length())),
!   data_m(engine.dataBlock(), engine.stride_m * dom.first()),
    stride_m(engine.stride_m)
  { }
  
--- 520,527 ----
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const This_t &amp;engine, const Interval&lt;1&gt; &amp;dom)
  : domain_m(Interval&lt;1&gt;(dom.length())),
!   dataBlock_m(engine.dataBlock(), engine.stride_m * dom.first()),
!   data_m(dataBlock_m.currentPointer()),
    stride_m(engine.stride_m)
  { }
  
*************** template &lt;class T&gt;
*** 517,523 ****
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const This_t &amp;engine, const Range&lt;1&gt; &amp;dom)
  : domain_m(Interval&lt;1&gt;(dom.length())),
!   data_m(engine.dataBlock(), engine.stride_m * dom.first()),
    stride_m(engine.stride_m*dom.stride())
  { }
  
--- 529,536 ----
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const This_t &amp;engine, const Range&lt;1&gt; &amp;dom)
  : domain_m(Interval&lt;1&gt;(dom.length())),
!   dataBlock_m(engine.dataBlock(), engine.stride_m * dom.first()),
!   data_m(dataBlock_m.currentPointer()),
    stride_m(engine.stride_m*dom.stride())
  { }
  
*************** template &lt;class T&gt;
*** 525,531 ****
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const Engine_t &amp;engine, const INode&lt;1&gt; &amp;inode)
  : domain_m(Interval&lt;1&gt;(inode.domain().length())),
!   data_m(engine.dataBlock(), engine.stride_m * inode.domain().first()),
    stride_m(engine.stride_m)
  { }
  
--- 538,545 ----
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const Engine_t &amp;engine, const INode&lt;1&gt; &amp;inode)
  : domain_m(Interval&lt;1&gt;(inode.domain().length())),
!   dataBlock_m(engine.dataBlock(), engine.stride_m * inode.domain().first()),
!   data_m(dataBlock_m.currentPointer()),
    stride_m(engine.stride_m)
  { }
  
*************** template &lt;class T&gt;
*** 542,548 ****
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const This_t &amp;modelEngine)
    : domain_m(modelEngine.domain_m),
!     data_m(modelEngine.data_m),
      stride_m(modelEngine.stride_m)
  { }
  
--- 556,563 ----
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const This_t &amp;modelEngine)
    : domain_m(modelEngine.domain_m),
!     dataBlock_m(modelEngine.dataBlock_m),
!     data_m(dataBlock_m.currentPointer()),
      stride_m(modelEngine.stride_m)
  { }
  
*************** template &lt;class T&gt;
*** 550,556 ****
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const This_t &amp;modelEngine, const EngineConstructTag &amp;)
    : domain_m(modelEngine.domain_m),
!     data_m(modelEngine.data_m),
      stride_m(modelEngine.stride_m)
  { }
  
--- 565,572 ----
  Engine&lt;1,T,DynamicView&gt;::
  Engine(const This_t &amp;modelEngine, const EngineConstructTag &amp;)
    : domain_m(modelEngine.domain_m),
!     dataBlock_m(modelEngine.dataBlock_m),
!     data_m(dataBlock_m.currentPointer()),
      stride_m(modelEngine.stride_m)
  { }
  
*************** operator=(const This_t &amp;modelEngine)
*** 580,585 ****
--- 596,602 ----
  {
    if (this != &amp;modelEngine)
      {
+       dataBlock_m  = modelEngine.dataBlock_m;
        data_m       = modelEngine.data_m;
        domain_m     = modelEngine.domain_m;
        stride_m     = modelEngine.stride_m;
Index: src/Engine/DynamicEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/DynamicEngine.h,v
retrieving revision 1.16
diff -c -p -r1.16 DynamicEngine.h
*** src/Engine/DynamicEngine.h	2001/04/09 21:34:27	1.16
--- src/Engine/DynamicEngine.h	2001/11/05 19:28:26
*************** public:
*** 154,159 ****
--- 154,188 ----
    enum { zeroBased     = false };
    enum { multiPatch    = false };
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t {
+   public:
+ 
+     LoopInvariant_t(T* data, int first)
+       : data_m(data), first_m(first)
+     {}
+ 
+     inline T* data() const { return data_m; }
+ 
+     inline int&amp; first() { return first_m; }
+     inline int first() const { return first_m; }
+ 
+   private:
+ 
+     // The domain could be added here, but it is not used anywhere so
+     // we defer adding it until the need to have it is shown.
+ 
+     // This points to the same data as dataBlock_m but permits faster access.
+ 
+     T* data_m;
+ 
+     // Index of the first point.
+   
+     int first_m;
+   };
+ 
    //============================================================
    // Constructors and Factory Methods
    //============================================================
*************** public:
*** 224,234 ****
--- 253,278 ----
    inline ElementRef_t operator()(const Loc&lt;1&gt; &amp;l) const 
    { return data_m[l.first() - first_m]; }
  
+   inline
+   Element_t read(const LoopInvariant_t &amp;li, const Loc&lt;1&gt; &amp;l) const 
+   { return li.data()[l.first() - li.first()]; }
+   
+   inline
+   ElementRef_t operator()(const LoopInvariant_t &amp;li, const Loc&lt;1&gt; &amp;l) const 
+   { return li.data()[l.first() - li.first()]; }
+ 
    // Element access via ints for speed.
  
    inline Element_t read(int i) const { return data_m[i - first_m]; };
    inline ElementRef_t operator()(int i) const { return data_m[i - first_m]; };
  
+   inline
+   Element_t read(const LoopInvariant_t &amp;li, int i) const
+   { return li.data()[i - li.first()]; };
+   inline
+   ElementRef_t operator()(const LoopInvariant_t &amp;li, int i) const
+   { return li.data()[i - li.first()]; };
+ 
    // Return the domain.
  
    inline const Domain_t &amp;domain() const { return domain_m; }
*************** public:
*** 239,245 ****
  
    // Return whether the block controlled by this engine is shared.
    
!   bool isShared() const { return data_m.isValid() &amp;&amp; data_m.count() &gt; 1; }
  
    // Get a private copy of data viewed by this Engine.
  
--- 283,289 ----
  
    // Return whether the block controlled by this engine is shared.
    
!   bool isShared() const { return dataBlock_m.isValid() &amp;&amp; dataBlock_m.count() &gt; 1; }
  
    // Get a private copy of data viewed by this Engine.
  
*************** public:
*** 247,260 ****
  
    // Provide access to the data object. 
  
!   Pooma::DataObject_t *dataObject() const { return data_m.dataObject(); }
  
    // Return access to our internal data block.  This is ref-counted,
    // so a copy is fine.  But you should really know what you're doing
    // if you call this method.
  
!   const DataBlockPtr&lt;T&gt; &amp; dataBlock() const { return data_m; }
!   DataBlockPtr&lt;T&gt;         dataBlock()       { return data_m; }
  
    //============================================================
    // Dynamic interface methods.
--- 291,304 ----
  
    // Provide access to the data object. 
  
!   Pooma::DataObject_t *dataObject() const { return dataBlock_m.dataObject(); }
  
    // Return access to our internal data block.  This is ref-counted,
    // so a copy is fine.  But you should really know what you're doing
    // if you call this method.
  
!   const DataBlockPtr&lt;T&gt; &amp; dataBlock() const { return dataBlock_m; }
!   DataBlockPtr&lt;T&gt;         dataBlock()       { return dataBlock_m; }
  
    //============================================================
    // Dynamic interface methods.
*************** public:
*** 338,343 ****
--- 382,393 ----
  
  #endif
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   inline const LoopInvariant_t loopInvariant() const 
+     { return LoopInvariant_t(data_m, first_m); }
+ 
  private:
  
    //============================================================
*************** private:
*** 395,402 ****
  
    // Smart-pointer to Block-controller that manages the data
    // and the Smarts DataObject. 
  
!   DataBlockPtr&lt;T&gt; data_m;
  
    // Index of the first point.
    
--- 445,456 ----
  
    // Smart-pointer to Block-controller that manages the data
    // and the Smarts DataObject. 
+ 
+   DataBlockPtr&lt;T&gt; dataBlock_m;
+ 
+   // This points to the same data as dataBlock_m but permits faster access.
  
!   T* data_m;
  
    // Index of the first point.
    
*************** public:
*** 445,451 ****
--- 499,534 ----
    enum { dynamic       = false };
    enum { zeroBased     = true  };
    enum { multiPatch    = false };
+ 
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t {
+   public:
+ 
+     LoopInvariant_t(T* data, int stride)
+       : data_m(data), stride_m(stride)
+     {}
+ 
+     inline T* data() const { return data_m; }
+ 
+     inline int&amp; stride() { return stride_m; }
+     inline int stride() const { return stride_m; }
+ 
+   private:
+ 
+     // The domain could be added here, but it is not used anywhere so
+     // we defer adding it until the need to have it is shown.
+ 
+     // This points to the same data as dataBlock_m but permits faster access.
+ 
+     T* data_m;
+ 
+     // Stride
    
+     int stride_m;
+   };
+ 
    //============================================================
    // Constructors
    //============================================================
*************** public:
*** 502,512 ****
--- 585,608 ----
    inline ElementRef_t operator()(const Loc&lt;1&gt; &amp;l) const
    { return data_m[l.first()*stride_m]; }
  
+   inline Element_t read(const LoopInvariant_t &amp;li, const Loc&lt;1&gt; &amp;l) const 
+   { return li.data()[l.first()*li.stride()]; }
+   
+   inline ElementRef_t operator()(const LoopInvariant_t &amp;li,
+ 				 const Loc&lt;1&gt; &amp;l) const
+   { return li.data()[l.first()*li.stride()]; }
+ 
    // Element access via ints for speed.
  
    inline Element_t read(int i)          const { return data_m[i*stride_m]; }
    inline ElementRef_t operator()(int i) const { return data_m[i*stride_m]; }
  
+   // HERE
+   inline Element_t read(const LoopInvariant_t &amp;li, int i) const
+   { return li.data()[i*li.stride()]; }
+   inline ElementRef_t operator()(const LoopInvariant_t &amp;li, int i) const
+   { return li.data()[i*li.stride()]; }
+ 
    // Return the domain:
  
    const Domain_t &amp;domain() const { return domain_m; }
*************** public:
*** 521,534 ****
    
    // Provide access to the data object. 
  
!   Pooma::DataObject_t *dataObject() const { return data_m.dataObject(); }
  
    // Return access to our internal data block.  This is ref-counted,
    // so a copy is fine.  But you should really know what you're doing
    // if you call this method.
  
!   const DataBlockPtr&lt;T&gt; &amp; dataBlock() const { return data_m; }
!   DataBlockPtr&lt;T&gt;         dataBlock()       { return data_m; }
  
  private:
  
--- 617,630 ----
    
    // Provide access to the data object. 
  
!   Pooma::DataObject_t *dataObject() const { return dataBlock_m.dataObject(); }
  
    // Return access to our internal data block.  This is ref-counted,
    // so a copy is fine.  But you should really know what you're doing
    // if you call this method.
  
!   const DataBlockPtr&lt;T&gt; &amp; dataBlock() const { return dataBlock_m; }
!   DataBlockPtr&lt;T&gt;         dataBlock()       { return dataBlock_m; }
  
  private:
  
*************** private:
*** 540,549 ****
  
    Domain_t domain_m;
  
- 
    // Copy of the Block-controller that manages the data.
  
!   DataBlockPtr&lt;T&gt; data_m;
  
    // Stride. 
  
--- 636,648 ----
  
    Domain_t domain_m;
  
    // Copy of the Block-controller that manages the data.
+ 
+   DataBlockPtr&lt;T&gt; dataBlock_m;
+ 
+   // This points to the same data as dataBlock_m but permits faster access.
  
!   T* data_m;
  
    // Stride. 
  
Index: src/Engine/EngineFunctor.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/EngineFunctor.h,v
retrieving revision 1.11
diff -c -p -r1.11 EngineFunctor.h
*** src/Engine/EngineFunctor.h	2001/10/12 18:52:40	1.11
--- src/Engine/EngineFunctor.h	2001/11/05 19:28:26
*************** template&lt;class Tag&gt;
*** 193,199 ****
  struct EngineView;
  
  //-----------------------------------------------------------------------------
! // LeafFunctor specializations for EngineView.
  //
  // Applying EngineView to a general node is an error.
  // Applying EngineView to a scalar just returns the scalar.
--- 193,199 ----
  struct EngineView;
  
  //-----------------------------------------------------------------------------
! // LeafFunctor specialization for EngineView.
  //
  // Applying EngineView to a general node is an error.
  // Applying EngineView to a scalar just returns the scalar.
*************** template&lt;class T, class Tag&gt;
*** 208,218 ****
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EngineView&lt;Tag&gt; &gt;
  {
    typedef Scalar&lt;T&gt; Type_t;
    static inline
!   Type_t apply(const Scalar&lt;T&gt; &amp;s, const EngineView&lt;Tag&gt; &amp;)
    {
      return s;
    }
  };
  
  //-----------------------------------------------------------------------------
--- 208,230 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EngineView&lt;Tag&gt; &gt;
  {
    typedef Scalar&lt;T&gt; Type_t;
+   typedef Scalar&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef EngineView&lt;Tag&gt; Tag_t;
+   
    static inline
!   Type_t apply(const Subject_t &amp;s, const Tag_t &amp;)
    {
      return s;
    }
+ 
+   static inline
+   Type_t apply(const Subject_t &amp;s,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;t)
+   {
+     return apply(s,t);
+   }
  };
  
  //-----------------------------------------------------------------------------
*************** struct LeafFunctor&lt;Scalar&lt;T&gt;, EngineView
*** 223,229 ****
  // result from attempting to provide the specializations:
  //
  // LeafFunctor&lt;ExpressionEngine, EngineView&lt;GeneralTag&gt;&gt;
- // LeafFunctor&lt;GeneralEngine, EngineView&lt;SpecificTag&gt;&gt;
  //-----------------------------------------------------------------------------
  
  template&lt;class Engine, class Tag&gt;
--- 235,240 ----
*************** template&lt;int Dim, class T, class E, clas
*** 233,247 ****
  struct LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, EngineView&lt;Tag&gt; &gt;
  {
    typedef Engine&lt;Dim, T, E&gt; Subject_t;
    typedef DefaultEngineView&lt;Subject_t, Tag&gt; EngineView_t;
    typedef typename EngineView_t::Type_t Type_t;
  
    static inline
    Type_t apply(const Subject_t &amp;engine,
! 	       const EngineView&lt;Tag&gt; &amp;tag)
    {
      return EngineView_t::apply(engine, tag);
    }
  };
  
  //-----------------------------------------------------------------------------
--- 244,268 ----
  struct LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, EngineView&lt;Tag&gt; &gt;
  {
    typedef Engine&lt;Dim, T, E&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef EngineView&lt;Tag&gt; Tag_t;
    typedef DefaultEngineView&lt;Subject_t, Tag&gt; EngineView_t;
    typedef typename EngineView_t::Type_t Type_t;
  
    static inline
    Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      return EngineView_t::apply(engine, tag);
    }
+ 
+   static inline
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return EngineView_t::apply(engine, li, tag);
+   }
  };
  
  //-----------------------------------------------------------------------------
*************** expressionApply(const A &amp;a, const Tag &amp;t
*** 277,283 ****
  }
  
  //-----------------------------------------------------------------------------
! // LeafFunctor specializations for ExpressionApply.
  //
  // Applying EngineView to a general node is an error.
  //-----------------------------------------------------------------------------
--- 298,305 ----
  }
  
  //-----------------------------------------------------------------------------
! // LeafFunctor and LeafFunctorLoopInvariant specializations for
! // ExpressionApply.
  //
  // Applying EngineView to a general node is an error.
  //-----------------------------------------------------------------------------
*************** template&lt;class T, class Tag&gt;
*** 291,301 ****
  struct LeafFunctor&lt;Scalar&lt;T&gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef int Type_t;
    static inline
!   Type_t apply(const Scalar&lt;T&gt; &amp;, const ExpressionApply&lt;Tag&gt; &amp;)
    {
      return 0;
    }
  };
  
  //-----------------------------------------------------------------------------
--- 313,335 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef int Type_t;
+   typedef Scalar&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef ExpressionApply&lt;Tag&gt; Tag_t;
+ 
    static inline
!   Type_t apply(const Subject_t &amp;, const Tag_t &amp;)
    {
      return 0;
    }
+ 
+   static inline
+   Type_t apply(const Subject_t &amp;s,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;t)
+   {
+     return apply(s,t);
+   }
  };
  
  //-----------------------------------------------------------------------------
*************** struct LeafFunctor&lt;Scalar&lt;T&gt;, Expression
*** 306,312 ****
  // result from attempting to provide the specializations:
  //
  // LeafFunctor&lt;ExpressionEngine, EngineView&lt;GeneralTag&gt;&gt;
! // LeafFunctor&lt;GeneralEngine, EngineView&lt;SpecificTag&gt;&gt;
  //-----------------------------------------------------------------------------
  
  template&lt;class Engine, class Tag&gt;
--- 340,346 ----
  // result from attempting to provide the specializations:
  //
  // LeafFunctor&lt;ExpressionEngine, EngineView&lt;GeneralTag&gt;&gt;
! // LeafFunctorLoopInvariant&lt;ExpressionEngine, LoopInvariant, EngineView&lt;GeneralTag&gt;&gt;
  //-----------------------------------------------------------------------------
  
  template&lt;class Engine, class Tag&gt;
*************** template&lt;int Dim, class T, class E, clas
*** 316,321 ****
--- 350,356 ----
  struct LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef Engine&lt;Dim, T, E&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
    typedef DefaultExpressionApply&lt;Subject_t, Tag&gt; ExpressionApply_t;
    typedef int Type_t;
  
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, Ex
*** 325,332 ****
    {
      return ExpressionApply_t::apply(engine, tag);
    }
- };
  
  
  //////////////////////////////////////////////////////////////////////
  
--- 360,374 ----
    {
      return ExpressionApply_t::apply(engine, tag);
    }
  
+   static inline
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const ExpressionApply&lt;Tag&gt; &amp;tag)
+   {
+     return ExpressionApply_t::apply(engine, li, tag);
+   }
+ };
  
  //////////////////////////////////////////////////////////////////////
  
Index: src/Engine/ExpressionEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/ExpressionEngine.h,v
retrieving revision 1.76
diff -c -p -r1.76 ExpressionEngine.h
*** src/Engine/ExpressionEngine.h	2001/09/26 00:14:40	1.76
--- src/Engine/ExpressionEngine.h	2001/11/05 19:28:26
***************
*** 29,39 ****
  //-----------------------------------------------------------------------------
  // Classes:
  //   DomainFunctorTag
! //   LeafFunctor&lt;DomainFunctorTag, T&gt;
  //   EvalLeaf
! //   LeafFunctor&lt;EvalLeaf&lt;Domain&gt;, Scalar&lt;T&gt; &gt;
  //   ViewFunctorTag
- //   LeafFunctor&lt; ViewFunctorTag&lt;Domain&gt;, Scalar&lt;T&gt; &gt;
  //   ExpressionTag&lt;Expr&gt;
  //   Engine&lt;Dim,T,ExpressionTag&gt;
  //   Combine2&lt;Domain1, Domain2, Op, DomainFunctorTag&gt;
--- 29,38 ----
  //-----------------------------------------------------------------------------
  // Classes:
  //   DomainFunctorTag
! //   LeafFunctor&lt;T, DomainFunctorTag&gt;
  //   EvalLeaf
! //   LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf&lt;Domain&gt; &gt;
  //   ViewFunctorTag
  //   ExpressionTag&lt;Expr&gt;
  //   Engine&lt;Dim,T,ExpressionTag&gt;
  //   Combine2&lt;Domain1, Domain2, Op, DomainFunctorTag&gt;
*************** template&lt;class T, int Dim&gt;
*** 84,94 ****
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf&lt;Dim&gt; &gt;
  {
    typedef T Type_t;
    inline static
!   Type_t apply(const Scalar&lt;T&gt; &amp;s, const EvalLeaf&lt;Dim&gt; &amp;) 
      {
        return s.value();
      }
  };
  
  //-----------------------------------------------------------------------------
--- 83,105 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf&lt;Dim&gt; &gt;
  {
    typedef T Type_t;
+   typedef Scalar&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef EvalLeaf&lt;Dim&gt; Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;s, const Tag_t &amp;) 
      {
        return s.value();
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;s, 
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;) 
+     {
+       return s.value(li);
+     }
  };
  
  //-----------------------------------------------------------------------------
*************** template&lt;int Dim, class T, class E&gt;
*** 100,111 ****
  struct LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, EvalLeaf&lt;Dim&gt; &gt;
  {
    typedef T Type_t;
  
    inline static
!   Type_t apply(const Engine&lt;Dim, T, E&gt; &amp;e, const EvalLeaf&lt;Dim&gt; &amp;t) 
    {
      return t.eval(e);
    }
  };
  
  template&lt;&gt;
--- 111,133 ----
  struct LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, EvalLeaf&lt;Dim&gt; &gt;
  {
    typedef T Type_t;
+   typedef Engine&lt;Dim, T, E&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef EvalLeaf&lt;Dim&gt; Tag_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;e, const Tag_t &amp;t) 
    {
      return t.eval(e);
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;e,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;t) 
+   {
+     return t.eval(li, e);
+   }
  };
  
  template&lt;&gt;
*************** struct EvalLeaf&lt;1&gt;
*** 128,133 ****
--- 150,162 ----
    {
      return e.read(val1());
    }
+ 
+   template&lt;class Engine&gt;
+   inline typename Engine::Element_t
+   eval(const Engine &amp;e, const typename Engine::LoopInvariant_t &amp;li) const
+   {
+     return e.read(li, val1());
+   }
  };
  
  template&lt;&gt;
*************** struct EvalLeaf&lt;2&gt;
*** 151,156 ****
--- 180,192 ----
    {
      return e.read(val1(), val2());
    }
+ 
+   template&lt;class Engine&gt;
+   inline typename Engine::Element_t
+   eval(const Engine &amp;e, const typename Engine::LoopInvariant_t &amp;li) const
+   {
+     return e.read(li, val1(), val2());
+   }
  };
  
  template&lt;&gt;
*************** struct EvalLeaf&lt;3&gt;
*** 175,180 ****
--- 211,223 ----
    {
      return e.read(val1(), val2(), val3());
    }
+ 
+   template&lt;class Engine&gt;
+   inline typename Engine::Element_t
+   eval(const Engine &amp;e, const typename Engine::LoopInvariant_t &amp;li) const
+   {
+     return e.read(li, val1(), val2(), val3());
+   }
  };
  
  template&lt;&gt;
*************** struct EvalLeaf&lt;4&gt;
*** 201,206 ****
--- 244,256 ----
    {
      return e.read(val1(), val2(), val3(), val4());
    }
+ 
+   template&lt;class Engine&gt;
+   inline typename Engine::Element_t
+   eval(const Engine &amp;e, const typename Engine::LoopInvariant_t &amp;li) const
+   {
+     return e.read(li, val1(), val2(), val3(), val4());
+   }
  };
  
  template&lt;&gt;
*************** struct EvalLeaf&lt;5&gt;
*** 228,233 ****
--- 278,290 ----
    {
      return e.read(val1(), val2(), val3(), val4(), val5());
    }
+ 
+   template&lt;class Engine&gt;
+   inline typename Engine::Element_t
+   eval(const Engine &amp;e, const typename Engine::LoopInvariant_t &amp;li) const
+   {
+     return e.read(li, val1(), val2(), val3(), val4(), val5());
+   }
  };
  
  template&lt;&gt;
*************** struct EvalLeaf&lt;6&gt;
*** 256,261 ****
--- 313,325 ----
    {
      return e.read(val1(), val2(), val3(), val4(), val5(), val6());
    }
+ 
+   template&lt;class Engine&gt;
+   inline typename Engine::Element_t
+   eval(const Engine &amp;e, const typename Engine::LoopInvariant_t &amp;li) const
+   {
+     return e.read(li, val1(), val2(), val3(), val4(), val5(), val6());
+   }
  };
  
  template&lt;&gt;
*************** struct EvalLeaf&lt;7&gt;
*** 286,291 ****
--- 350,362 ----
    {
      return e.read(val1(), val2(), val3(), val4(), val5(), val6(), val7());
    }
+ 
+   template&lt;class Engine&gt;
+   inline typename Engine::Element_t
+   eval(const Engine &amp;e, const typename Engine::LoopInvariant_t &amp;li) const
+   {
+     return e.read(li, val1(), val2(), val3(), val4(), val5(), val6(), val7());
+   }
  };
  
  //-----------------------------------------------------------------------------
*************** template&lt;class T, class Domain&gt;
*** 311,321 ****
  struct LeafFunctor&lt;Scalar&lt;T&gt;, ViewFunctorTag&lt;Domain&gt; &gt;
  {
    typedef Scalar&lt;T&gt; Type_t;
    inline static
!   Type_t apply(const Scalar&lt;T&gt; &amp;s, const ViewFunctorTag&lt;Domain&gt; &amp;) 
    {
      return s;
    }
  };
  
  
--- 382,404 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, ViewFunctorTag&lt;Domain&gt; &gt;
  {
    typedef Scalar&lt;T&gt; Type_t;
+   typedef Scalar&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef ViewFunctorTag&lt;Domain&gt; Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;s, const Tag_t &amp;) 
    {
      return s;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;s,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;t) 
+   {
+     return apply(s,t);
+   }
  };
  
  
*************** template&lt;class T&gt;
*** 331,349 ****
  struct LeafFunctor&lt;Scalar&lt;T&gt;, DomainFunctorTag&gt;
  {
    typedef NullDomain Type_t;
    inline static
!   Type_t apply(const Scalar&lt;T&gt; &amp;, const DomainFunctorTag &amp;) 
    {
      return NullDomain();
    }
  };
  
  template&lt;class T&gt;
  struct LeafFunctor&lt;T, DomainFunctorTag&gt;
  {
    typedef typename T::Domain_t Type_t;
    inline static
!   Type_t apply(const T &amp;leaf, const DomainFunctorTag &amp;) 
    {
      return leaf.domain();
    }
--- 414,456 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, DomainFunctorTag&gt;
  {
    typedef NullDomain Type_t;
+   typedef Scalar&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DomainFunctorTag Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;, const Tag_t &amp;) 
    {
      return NullDomain();
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;) 
+   {
+     return NullDomain();
+   }
  };
  
  template&lt;class T&gt;
  struct LeafFunctor&lt;T, DomainFunctorTag&gt;
  {
    typedef typename T::Domain_t Type_t;
+   typedef T Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DomainFunctorTag Tag_t;
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;leaf, const Tag_t &amp;) 
+   {
+     return leaf.domain();
+   }
+ 
    inline static
!   Type_t apply(const Subject_t &amp;leaf,
! 	       const LoopInvariant_t &amp;,
! 	       const Tag_t &amp;) 
    {
      return leaf.domain();
    }
*************** public:
*** 470,475 ****
--- 577,587 ----
    typedef Expr Expression_t;
    typedef DomainLayout&lt;Dim&gt;   Layout_t;
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   typedef typename Expr::LoopInvariant_t LoopInvariant_t;
+ 
    //---------------------------------------------------------------------------
    // Was enum { dimensions = Domain_t::dimensions };
    // It's possible for the dimension of an expression to be different from
*************** public:
*** 594,599 ****
--- 706,757 ----
      return forEach(expr_m, EvalLeaf&lt;Dim&gt;(loc), OpCombine());
    }
  
+   inline Element_t read(const LoopInvariant_t&amp; li, int i0) const 
+     {
+       return forEach(expr_m, li, EvalLeaf&lt;1&gt;(i0), OpCombine());
+     }
+ 
+   inline Element_t read(const LoopInvariant_t&amp; li, int i0, int i1) const 
+     {
+       return forEach(expr_m, li, EvalLeaf&lt;2&gt;(i0, i1), OpCombine());
+     }
+ 
+   inline Element_t read(const LoopInvariant_t&amp; li, int i0, int i1, int i2) const 
+     {
+       return forEach(expr_m, li, EvalLeaf&lt;3&gt;(i0, i1, i2), OpCombine());
+     }
+ 
+   inline Element_t read(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3) const 
+     {
+       return forEach(expr_m, li, EvalLeaf&lt;4&gt;(i0, i1, i2, i3), 
+         OpCombine());
+     }
+ 
+   inline Element_t read(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4) const 
+     {
+       return forEach(expr_m, li, EvalLeaf&lt;5&gt;(i0, i1, i2, i3, i4), 
+         OpCombine());
+     }
+ 
+   inline Element_t read(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5) const 
+     {
+       return forEach(expr_m, li, EvalLeaf&lt;6&gt;(i0, i1, i2, i3, i4, i5), 
+         OpCombine());
+     }
+ 
+   inline Element_t read(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5,
+     int i6) const 
+     {
+       return forEach(expr_m, li, EvalLeaf&lt;7&gt;(i0, i1, i2, i3, i4, i5, i6), 
+         OpCombine());
+     }
+ 
+   inline Element_t read(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const 
+   {
+     return forEach(expr_m, li, EvalLeaf&lt;Dim&gt;(loc), OpCombine());
+   }
+ 
+ 
    //---------------------------------------------------------------------------
    // Function to return the common domain. We recursively go through the
    // expression tree asking each node and leaf to return their domain and 
*************** public:
*** 633,638 ****
--- 791,800 ----
      return forEach(expr_m,Functor_t(f),Combine_t());
    }
   
+   inline
+   const LoopInvariant_t loopInvariant() const
+   { return expr_m.loopInvariant(); }
+ 
  private:
  
    // The expression is stored here.
*************** template&lt;class T, class Tag&gt;
*** 695,706 ****
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EngineFunctorTag&lt;Tag&gt; &gt;
  {
    typedef typename EngineFunctorScalar&lt;T,Tag&gt;::Type_t Type_t;
  
    inline static
!   Type_t apply(const Scalar&lt;T&gt; &amp;scalar,  const EngineFunctorTag&lt;Tag&gt; &amp;tag)
    {
      return EngineFunctorScalar&lt;T,Tag&gt;::apply(scalar.value(), tag.tag());
    }
  };
  
  //-----------------------------------------------------------------------------
--- 857,879 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EngineFunctorTag&lt;Tag&gt; &gt;
  {
    typedef typename EngineFunctorScalar&lt;T,Tag&gt;::Type_t Type_t;
+   typedef Scalar&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef EngineFunctorTag&lt;Tag&gt; Tag_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;scalar, const Tag_t &amp;tag)
    {
      return EngineFunctorScalar&lt;T,Tag&gt;::apply(scalar.value(), tag.tag());
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;scalar,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return EngineFunctorScalar&lt;T,Tag&gt;::apply(scalar.value(), li, tag.tag());
+   }
  };
  
  //-----------------------------------------------------------------------------
*************** template&lt;int Dim, class T, class E, clas
*** 711,724 ****
  struct LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, EngineFunctorTag&lt;Tag&gt; &gt;
  {
    typedef Engine&lt;Dim, T, E&gt; Engine_t;
    typedef typename EngineFunctor&lt;Engine_t, Tag&gt;::Type_t Type_t;
  
    inline static
!   Type_t apply(const Engine_t &amp;engine, 
! 	       const EngineFunctorTag&lt;Tag&gt; &amp;tag)
    {
      return EngineFunctor&lt;Engine_t, Tag&gt;::apply(engine, tag.tag());
    }
  };
  
  //---------------------------------------------------------------------------
--- 884,908 ----
  struct LeafFunctor&lt;Engine&lt;Dim, T, E&gt;, EngineFunctorTag&lt;Tag&gt; &gt;
  {
    typedef Engine&lt;Dim, T, E&gt; Engine_t;
+   typedef Engine_t Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
    typedef typename EngineFunctor&lt;Engine_t, Tag&gt;::Type_t Type_t;
+   typedef EngineFunctorTag&lt;Tag&gt; Tag_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      return EngineFunctor&lt;Engine_t, Tag&gt;::apply(engine, tag.tag());
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return EngineFunctor&lt;Engine_t, Tag&gt;::apply(engine, li, tag.tag());
+   }
  };
  
  //---------------------------------------------------------------------------
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, Expres
*** 773,787 ****
    typedef EngineView&lt;Tag&gt; Functor_t;
    typedef typename Functor_t::Combine_t Combine_t;
    typedef typename ForEach&lt;Expr, Functor_t, Combine_t&gt;::Type_t NewExpr_t;
  
    typedef Engine&lt;Dim, T, ExpressionTag&lt;NewExpr_t&gt; &gt; Type_t;
  
    inline static 
!   Type_t apply(const Engine&lt;Dim, T, ExpressionTag&lt;Expr&gt; &gt; &amp;engine,
! 	       const EngineView&lt;Tag&gt; &amp;tag)
    {
      return Type_t(forEach(engine.expression(), tag, Combine_t()));
    }
  };
  
  //---------------------------------------------------------------------------
--- 957,982 ----
    typedef EngineView&lt;Tag&gt; Functor_t;
    typedef typename Functor_t::Combine_t Combine_t;
    typedef typename ForEach&lt;Expr, Functor_t, Combine_t&gt;::Type_t NewExpr_t;
+   typedef Engine&lt;Dim, T, ExpressionTag&lt;Expr&gt; &gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef EngineView&lt;Tag&gt; Tag_t;
  
    typedef Engine&lt;Dim, T, ExpressionTag&lt;NewExpr_t&gt; &gt; Type_t;
  
    inline static 
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      return Type_t(forEach(engine.expression(), tag, Combine_t()));
    }
+ 
+   inline static 
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return Type_t(forEach(engine.expression(), li, tag, Combine_t()));
+   }
  };
  
  //---------------------------------------------------------------------------
*************** template&lt;int Dim, class T, class Expr, c
*** 792,803 ****
  struct LeafFunctor&lt;Engine&lt;Dim, T, ExpressionTag&lt;Expr&gt; &gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef int Type_t;
  
    inline static 
!   Type_t apply(const Engine&lt;Dim, T, ExpressionTag&lt;Expr&gt; &gt; &amp;engine,
! 	       const ExpressionApply&lt;Tag&gt; &amp;tag)
    {
      return forEach(engine.expression(), tag, NullCombine());
    }
  };
  
--- 987,1009 ----
  struct LeafFunctor&lt;Engine&lt;Dim, T, ExpressionTag&lt;Expr&gt; &gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef int Type_t;
+   typedef Engine&lt;Dim, T, ExpressionTag&lt;Expr&gt; &gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef ExpressionApply&lt;Tag&gt; Tag_t;
  
    inline static 
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      return forEach(engine.expression(), tag, NullCombine());
+   }
+ 
+   inline static 
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return forEach(engine.expression(), li, tag, NullCombine());
    }
  };
  
Index: src/Engine/ForwardingEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/ForwardingEngine.h,v
retrieving revision 1.44
diff -c -p -r1.44 ForwardingEngine.h
*** src/Engine/ForwardingEngine.h	2001/10/12 18:52:40	1.44
--- src/Engine/ForwardingEngine.h	2001/11/05 19:28:26
*************** public:
*** 108,113 ****
--- 108,118 ----
    enum { multiPatch = Eng::multiPatch };
  
    //---------------------------------------------------------------------------
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+   typedef typename ElemEngine_t::LoopInvariant_t LoopInvariant_t;
+ 
+   //---------------------------------------------------------------------------
    // Empty constructor required for containers of engines.
  
    Engine()
*************** public:
*** 249,255 ****
--- 254,314 ----
      return CompAccess_t::index(elemEngine().read(i1, i2, i3, i4, i5, i6, i7),
  			       components());
    }
+   // HERE
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			const Loc&lt;dimensions&gt; &amp;eloc) const
+   {
+     return CompAccess_t::index(elemEngine().read(li, eloc), components());
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i1) const
+   {
+     return CompAccess_t::index(elemEngine().read(li, i1), components());
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i1, int i2) const
+   {
+     return CompAccess_t::index(elemEngine().read(li, i1, i2), components());
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i1, int i2, int i3) const
+   {
+     return CompAccess_t::index(elemEngine().read(li, i1, i2, i3), 
+ 			       components());
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i1, int i2, int i3, int i4) const
+   {
+     return CompAccess_t::index(elemEngine().read(li, i1, i2, i3, i4),
+ 			       components());
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i1, int i2, int i3, int i4, int i5) const
+   {
+     return CompAccess_t::index(elemEngine().read(li, i1, i2, i3, i4, i5), 
+ 			       components());
+   }
  
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i1, int i2, int i3, int i4, int i5, int i6) const
+   {
+     return CompAccess_t::index(elemEngine().read(li, i1, i2, i3, i4, i5, i6), 
+ 			       components());
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i1, int i2, int i3, int i4, int i5,
+ 			int i6, int i7) const
+   {
+     return CompAccess_t::index(elemEngine().read(li, i1, i2, i3, i4, i5, i6, i7),
+ 			       components());
+   }
+ 
    //---------------------------------------------------------------------------
    // Returns the domain, which is acquired from the contained engine.
    
*************** public:
*** 274,286 ****
    }
    
    //---------------------------------------------------------------------------
!   // Assessor functions that return the engine and components.
    
    Eng &amp;elemEngine() { return engine_m; }
    const Eng &amp;elemEngine() const { return engine_m; }
    
    const Components &amp;components() const { return components_m; }
  
  private:
    
    Eng engine_m;
--- 333,352 ----
    }
    
    //---------------------------------------------------------------------------
!   // Accessor functions that return the engine and components.
    
    Eng &amp;elemEngine() { return engine_m; }
    const Eng &amp;elemEngine() const { return engine_m; }
    
    const Components &amp;components() const { return components_m; }
  
+   //---------------------------------------------------------------------------
+   // Access values that do not change during the evaluation of a single 
+   // data parallel statement.
+   inline
+   const LoopInvariant_t loopInvariant() const 
+   { return engine_m.loopInvariant(); }
+ 
  private:
    
    Eng engine_m;
*************** struct EngineFunctor&lt;Engine&lt;Dim, T, Comp
*** 310,318 ****
  {
    typedef typename EngineFunctor&lt;Eng, EFTag&gt;::Type_t Type_t;
  
!   static Type_t
!   apply(const Engine&lt;Dim, T, CompFwd&lt;Eng, Components&gt; &gt; &amp;engine,
! 	const EFTag &amp;tag)
    {
      return engineFunctor(engine.elemEngine(), tag);
    }
--- 376,384 ----
  {
    typedef typename EngineFunctor&lt;Eng, EFTag&gt;::Type_t Type_t;
  
!   inline static
!   Type_t apply(const Engine&lt;Dim, T, CompFwd&lt;Eng, Components&gt; &gt; &amp;engine,
! 	       const EFTag &amp;tag)
    {
      return engineFunctor(engine.elemEngine(), tag);
    }
*************** struct LeafFunctor&lt;Engine&lt;D, T, CompFwd&lt;
*** 324,337 ****
    typedef LeafFunctor&lt;E, EngineView&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t NewViewed_t;
    typedef Engine&lt;D, T, CompFwd&lt;NewViewed_t, Comp&gt; &gt; Type_t;
  
!   static
!   Type_t apply(const Engine&lt;D, T, CompFwd&lt;E, Comp&gt; &gt; &amp;engine,
  	       const EngineView&lt;Tag&gt; &amp;tag)
    {
      return Type_t(LeafFunctor_t::apply(engine.elemEngine(), tag),
  		  engine.components());
    }
  };
  
  template &lt;int D, class T, class E, class Comp, class Tag&gt;
--- 390,414 ----
    typedef LeafFunctor&lt;E, EngineView&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t NewViewed_t;
    typedef Engine&lt;D, T, CompFwd&lt;NewViewed_t, Comp&gt; &gt; Type_t;
+   typedef Engine&lt;D, T, CompFwd&lt;E, Comp&gt; &gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
  	       const EngineView&lt;Tag&gt; &amp;tag)
    {
      return Type_t(LeafFunctor_t::apply(engine.elemEngine(), tag),
  		  engine.components());
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const EngineView&lt;Tag&gt; &amp;tag)
+   {
+     return Type_t(LeafFunctor_t::apply(engine.elemEngine(), li, tag),
+ 		  engine.components());
+   }
  };
  
  template &lt;int D, class T, class E, class Comp, class Tag&gt;
*************** struct LeafFunctor&lt;Engine&lt;D, T, CompFwd&lt;
*** 339,352 ****
  {
    typedef LeafFunctor&lt;E, ExpressionApply&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef int Type_t;
  
!   static
!   Type_t apply(const Engine&lt;D, T, CompFwd&lt;E, Comp&gt; &gt; &amp;engine,
  	       const ExpressionApply&lt;Tag&gt; &amp;tag)
    {
      return LeafFunctor_t::apply(engine.elemEngine(), tag);
    }
  };
  
  //---------------------------------------------------------------------------
  // Tell contained engine that it's dirty.
--- 416,440 ----
  {
    typedef LeafFunctor&lt;E, ExpressionApply&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef int Type_t;
+   typedef Engine&lt;D, T, CompFwd&lt;E, Comp&gt; &gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
  	       const ExpressionApply&lt;Tag&gt; &amp;tag)
    {
      return LeafFunctor_t::apply(engine.elemEngine(), tag);
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const ExpressionApply&lt;Tag&gt; &amp;tag)
+   {
+     return LeafFunctor_t::apply(engine.elemEngine(), li, tag);
+   }
  };
+ 
  
  //---------------------------------------------------------------------------
  // Tell contained engine that it's dirty.
Index: src/Engine/IndexFunctionEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/IndexFunctionEngine.h,v
retrieving revision 1.23
diff -c -p -r1.23 IndexFunctionEngine.h
*** src/Engine/IndexFunctionEngine.h	2001/08/30 01:15:04	1.23
--- src/Engine/IndexFunctionEngine.h	2001/11/05 19:28:26
*************** public:
*** 106,111 ****
--- 106,112 ----
    typedef DomainLayout&lt;Dim&gt;                        Layout_t;
    typedef T                                        Element_t;
    typedef ErrorType                                ElementRef_t;
+   struct LoopInvariant_t {};
  
    enum { dimensions = Dim };
    enum { hasDataObject = false };
*************** public:
*** 225,230 ****
--- 226,294 ----
          loc[3].first(), loc[4].first(), loc[5].first(), loc[6].first());
      }
  
+   inline Element_t read(const LoopInvariant_t &amp;, int i0) const 
+     {
+       return funct_m(i0);
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, int i0, int i1) const 
+     {
+       return funct_m(i0, i1);
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, int i0, int i1, int i2) const 
+     {
+       return funct_m(i0, i1, i2);
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, int i0, int i1, int i2, int i3) const 
+     {
+       return funct_m(i0, i1, i2, i3);
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, int i0, int i1, int i2, int i3, int i4) const 
+     {
+       return funct_m(i0, i1, i2, i3, i4);
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, int i0, int i1, int i2, int i3, int i4, 
+     int i5) const 
+     {
+       return funct_m(i0, i1, i2, i3, i4, i5);
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, int i0, int i1, int i2, int i3, int i4, 
+     int i5, int i6) const 
+     {
+       return funct_m(i0, i1, i2, i3, i4, i5, i6);
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, const Loc&lt;1&gt; &amp;loc) const
+     {
+       return funct_m(loc[0].first());
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, const Loc&lt;2&gt; &amp;loc) const
+     {
+       return funct_m(loc[0].first(), loc[1].first());
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, const Loc&lt;3&gt; &amp;loc) const
+     {
+       return funct_m(loc[0].first(), loc[1].first(), loc[2].first());
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, const Loc&lt;4&gt; &amp;loc) const
+     {
+       return funct_m(loc[0].first(), loc[1].first(), loc[2].first(), 
+         loc[3].first());
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, const Loc&lt;5&gt; &amp;loc) const
+     {
+       return funct_m(loc[0].first(), loc[1].first(), loc[2].first(), 
+         loc[3].first(), loc[4].first());
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, const Loc&lt;6&gt; &amp;loc) const
+     {
+       return funct_m(loc[0].first(), loc[1].first(), loc[2].first(), 
+         loc[3].first(), loc[4].first(), loc[5].first());
+     }
+   inline Element_t read(const LoopInvariant_t &amp;, const Loc&lt;7&gt; &amp;loc) const
+     {
+       return funct_m(loc[0].first(), loc[1].first(), loc[2].first(), 
+         loc[3].first(), loc[4].first(), loc[5].first(), loc[6].first());
+     }
+ 
    //---------------------------------------------------------------------------
    // Return/set the domain. Also, return the base domain.
  
*************** public:
*** 245,250 ****
--- 309,319 ----
  
    const Functor &amp;functor() const { return funct_m; }
    void setFunctor(const Functor &amp;f) { funct_m = f; }
+ 
+   //---------------------------------------------------------------------------
+   // Loop invariants.
+ 
+   LoopInvariant_t loopInvariant() const { return LoopInvariant_t(); }
  
  private:
  
Index: src/Engine/IndirectionEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/IndirectionEngine.h,v
retrieving revision 1.24
diff -c -p -r1.24 IndirectionEngine.h
*** src/Engine/IndirectionEngine.h	2001/10/12 18:52:40	1.24
--- src/Engine/IndirectionEngine.h	2001/11/05 19:28:26
*************** public:
*** 94,99 ****
--- 94,101 ----
    typedef DomainLayout&lt;Dim&gt;                  Layout_t;
    typedef typename A1::Engine_t              Engine1_t;
    typedef typename A2::Engine_t              Engine2_t;
+   typedef typename Engine1_t::LoopInvariant_t Engine1LoopInvariant_t;
+   typedef typename Engine2_t::LoopInvariant_t Engine2LoopInvariant_t;
  
    enum { dimensions = Dim };
    enum { hasDataObject = Engine1_t::hasDataObject ||
*************** public:
*** 103,108 ****
--- 105,127 ----
    enum { dynamic = false };
    enum { zeroBased = Engine2_t::zeroBased };
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t {
+   public:
+     LoopInvariant_t(const Engine1LoopInvariant_t&amp; li1,
+ 		    const Engine2LoopInvariant_t&amp; li2)
+       : li1_m(li1), li2_m(li2) {}
+ 
+     Engine1LoopInvariant_t engine1() const { return li1_m; }
+     Engine2LoopInvariant_t engine2() const { return li2_m; }
+ 
+   private:
+     Engine1LoopInvariant_t li1_m;
+     Engine2LoopInvariant_t li2_m;
+   };
+ 
    //---------------------------------------------------------------------------
    // 
  
*************** public:
*** 196,201 ****
--- 215,270 ----
      return array1_m.read(array2_m.read(loc));
    }
  
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0));
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1));
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1,int i2) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1,i2));
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1,int i2,int i3) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1,i2,i3));
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1, int i2, int i3, int i4) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1,i2,i3,i4));
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1, int i2, int i3, int i4, int i5) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1,i2,i3,i4,i5));
+   }
+ 
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1, int i2, int i3, int i4, int i5,
+ 			int i6) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1,i2,i3,i4,i5,i6));
+   }
+ 
+   template&lt;class Domain&gt;
+   inline Element_t read(const LoopInvariant_t &amp;li, const Domain &amp;loc) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), loc));
+   }
+ 
    //---------------------------------------------------------------------------
    // Accessor functions for a specific element. Normally these have read-write
    // semantics. However, the notion of writing to an expression makes no sense
*************** public:
*** 244,249 ****
--- 313,377 ----
      return array1_m(array2_m.read(loc));
    }
  
+   inline ElementRef_t operator()(const LoopInvariant_t &amp;li,
+ 				 int i0) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0));
+   }
+ 
+   inline ElementRef_t operator()(const LoopInvariant_t &amp;li,
+ 				 int i0, int i1) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1));
+   }
+ 
+   inline ElementRef_t operator()(const LoopInvariant_t &amp;li,
+ 				 int i0, int i1,int i2) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1,i2));
+   }
+ 
+   inline ElementRef_t operator()(const LoopInvariant_t &amp;li,
+ 				 int i0, int i1,int i2,int i3) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1,i2,i3));
+   }
+ 
+   inline ElementRef_t operator()(const LoopInvariant_t &amp;li,
+ 				 int i0, int i1, int i2, int i3, int i4) const
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1,i2,i3,i4));
+   }
+ 
+   inline ElementRef_t operator()(const LoopInvariant_t &amp;li,
+ 				 int i0, int i1, int i2, int i3, int i4,
+ 				 int i5) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1,i2,i3,i4,i5));
+   }
+ 
+   inline ElementRef_t operator()(const LoopInvariant_t &amp;li,
+ 				 int i0, int i1, int i2, int i3, int i4,
+ 				 int i5, int i6) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), i0,i1,i2,i3,i4,i5,i6));
+   }
+ 
+   template&lt;class Domain&gt;
+   inline ElementRef_t operator()(const LoopInvariant_t &amp;li,
+ 				 const Domain &amp;loc) const 
+   {
+     return array1_m.read(li.engine1(),
+ 			 array2_m.read(li.engine2(), loc));
+   }
+ 
    //---------------------------------------------------------------------------
  
    inline Domain_t domain() const 
*************** public:
*** 259,271 ****
      return array2_m.first(i);
    }
    
  private:
  
    // The contained arrays are stored here.
  
    A1 array1_m;
    A2 array2_m;
- 
  };
  
  //-----------------------------------------------------------------------------
--- 387,408 ----
      return array2_m.first(i);
    }
    
+   //---------------------------------------------------------------------------
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   inline
+   const LoopInvariant_t loopInvariant() const 
+   { return LoopInvariant_t(array1().loopInvariant(),
+ 			   array2().loopInvariant());
+   }
+ 
  private:
  
    // The contained arrays are stored here.
  
    A1 array1_m;
    A2 array2_m;
  };
  
  //-----------------------------------------------------------------------------
Index: src/Engine/MultiPatchEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/MultiPatchEngine.h,v
retrieving revision 1.117
diff -c -p -r1.117 MultiPatchEngine.h
*** src/Engine/MultiPatchEngine.h	2001/04/09 21:35:47	1.117
--- src/Engine/MultiPatchEngine.h	2001/11/05 19:28:26
*************** public:
*** 456,462 ****
--- 456,467 ----
    enum { zeroBased = false };
    enum { multiPatch = true };
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
  
+   class LoopInvariant_t { };
+   // HERE
+ 
    //===========================================================================
    // Constructors and factory methods
    //===========================================================================
*************** public:
*** 502,508 ****
--- 507,516 ----
    // Element access via Loc.
  
    Element_t read(const Loc&lt;Dim&gt; &amp;) const;
+   Element_t read(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;) const;
+ 
    ElementRef_t operator()(const Loc&lt;Dim&gt; &amp;) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;) const;
  
    //---------------------------------------------------------------------------
    // Element access via ints for speed.
*************** public:
*** 515,520 ****
--- 523,536 ----
    Element_t read(int, int, int, int, int, int) const;
    Element_t read(int, int, int, int, int, int, int) const;
  
+   Element_t read(const LoopInvariant_t&amp;, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    ElementRef_t operator()(int) const;
    ElementRef_t operator()(int, int) const;
    ElementRef_t operator()(int, int, int) const;
*************** public:
*** 523,528 ****
--- 539,552 ----
    ElementRef_t operator()(int, int, int, int, int, int) const;
    ElementRef_t operator()(int, int, int, int, int, int, int) const;
  
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    //---------------------------------------------------------------------------
    // Return a patch given a Node or INode.
  
*************** public:
*** 662,667 ****
--- 686,698 ----
      return *pDirty_m;
    }
  
+   //---------------------------------------------------------------------------
+   // Return the loop invariant object.
+ 
+   inline
+   const LoopInvariant_t loopInvariant() const { return LoopInvariant_t(); }
+ 
+ 
    //============================================================
    // Observer methods
    //============================================================
*************** public:
*** 971,976 ****
--- 1002,1025 ----
    enum { zeroBased = true };
    enum { multiPatch = true };
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t { 
+   public:
+     typedef typename ViewedEngine_t::LoopInvariant_t ViewedLoopInvariant_t;
+ 
+     LoopInvariant_t(const ViewedLoopInvariant_t&amp; li)
+       : li_m(li) {}
+ 
+     inline
+     const LoopInvariant_t&amp; viewed() const { return li_m; }
+ 
+   private:
+     ViewedLoopInvariant_t li_m;
+   };
+ 
+ 
    //===========================================================================
    // Constructors and factory methods
    //===========================================================================
*************** public:
*** 1053,1059 ****
--- 1102,1111 ----
    // Element access via Loc.
  
    Element_t read(const Loc&lt;Dim&gt; &amp;) const;
+   Element_t read(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;) const;
+ 
    ElementRef_t operator()(const Loc&lt;Dim&gt; &amp;) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;) const;
  
    //---------------------------------------------------------------------------
    // Element access via ints for speed.
*************** public:
*** 1066,1071 ****
--- 1118,1131 ----
    Element_t read(int, int, int, int, int, int) const;
    Element_t read(int, int, int, int, int, int, int) const;
  
+   Element_t read(const LoopInvariant_t&amp;, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   Element_t read(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    ElementRef_t operator()(int) const;
    ElementRef_t operator()(int, int) const;
    ElementRef_t operator()(int, int, int) const;
*************** public:
*** 1074,1079 ****
--- 1134,1147 ----
    ElementRef_t operator()(int, int, int, int, int, int) const;
    ElementRef_t operator()(int, int, int, int, int, int, int) const;
  
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int) const;
+   ElementRef_t operator()(const LoopInvariant_t&amp;, int, int, int, int, int, int, int) const;
+ 
    //---------------------------------------------------------------------------
    // Return a patch given a Node or INode. This is different than in
    // MultiPatch because we really need to take a view here.
*************** public:
*** 1260,1265 ****
--- 1328,1341 ----
      return baseEngine_m;
    }
  
+   //---------------------------------------------------------------------------
+   // Return the loop invariant object.
+ 
+   inline
+   const LoopInvariant_t loopInvariant() const
+   { return LoopInvariant_t(baseEngine().loopInvariant()); }
+   // HERE
+ 
  private:
  
    //===========================================================================
*************** private:
*** 1270,1276 ****
  
    Layout_t layout_m;
  
!   // Shallow copy of the underyling engine.
    // We have to have this to support filling guard cells. There
    // is only a single dirty flag, so guard cell fill requests must
    // fill the guards for the entire engine, and we need a reference
--- 1346,1352 ----
  
    Layout_t layout_m;
  
!   // Shallow copy of the underlying engine.
    // We have to have this to support filling guard cells. There
    // is only a single dirty flag, so guard cell fill requests must
    // fill the guards for the entire engine, and we need a reference
*************** Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,Patc
*** 1358,1363 ****
--- 1434,1503 ----
      (i0, i1, i2, i3, i4, i5, i6);
  }
  
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::read(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
+ {
+   return data()[layout_m.globalID(loc)].read(li, loc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::read(const LoopInvariant_t&amp; li, int i0) const
+ {
+   return data()[layout_m.globalID(i0)].read(li, i0);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::read(const LoopInvariant_t&amp; li, int i0, int i1) const
+ {
+   return data()[layout_m.globalID(i0, i1)].read(li, i0, i1);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::read(const LoopInvariant_t&amp; li, int i0, int i1, int i2)
+ const
+ {
+   return data()[layout_m.globalID(i0, i1, i2)].read(li, i0, i1, i2);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::read(const LoopInvariant_t&amp; li, int i0, int i1, int i2,
+   int i3) const
+ {
+   return data()[layout_m.globalID(i0, i1, i2, i3)].read(li, i0, i1, i2, i3);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::read(const LoopInvariant_t&amp; li, int i0, int i1, int i2,
+   int i3, int i4) const
+ {
+   return data()[layout_m.globalID(i0, i1, i2, i3, i4)].read
+     (li, i0, i1, i2, i3, i4);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::read(const LoopInvariant_t&amp; li, int i0, int i1, int i2,
+   int i3, int i4, int i5) const
+ {
+   return data()[layout_m.globalID(i0, i1, i2, i3, i4, i5)].read
+     (li, i0, i1, i2, i3, i4, i5);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::read(const LoopInvariant_t&amp; li, int i0, int i1, int i2,
+   int i3, int i4, int i5, int i6) const
+ {
+   return data()[layout_m.globalID(i0, i1, i2, i3, i4, i5, i6)].read
+     (li, i0, i1, i2, i3, i4, i5, i6);
+ }
+ 
  // Operator()'s:
  
  template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
*************** Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,Patc
*** 1426,1431 ****
--- 1566,1638 ----
      (i0, i1, i2, i3, i4, i5, i6);
  }
  
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::operator()(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc)
+   const
+ {
+   return data()[layout_m.globalID(loc)](li, loc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::operator()(const LoopInvariant_t&amp; li, int i0) const
+ {
+   return data()[layout_m.globalID(i0)](li, i0);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::operator()(const LoopInvariant_t&amp; li, int i0, 
+   int i1) const
+ {
+   return data()[layout_m.globalID(i0, i1)](li, i0, i1);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::operator()(const LoopInvariant_t&amp; li, int i0, int i1, 
+   int i2) const
+ {
+   return data()[layout_m.globalID(i0, i1, i2)](li, i0, i1, i2);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::operator()(const LoopInvariant_t&amp; li, int i0, int i1, 
+   int i2, int i3) const
+ {
+   return data()[layout_m.globalID(i0, i1, i2, i3)](li, i0, i1, i2, i3);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::operator()(const LoopInvariant_t&amp; li, int i0, int i1,
+   int i2, int i3, int i4) const
+ {
+   return data()[layout_m.globalID(i0, i1, i2, i3, i4)]
+     (li, i0, i1, i2, i3, i4);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::operator()(const LoopInvariant_t&amp; li, int i0, int i1, 
+   int i2, int i3, int i4, int i5) const
+ {
+   return data()[layout_m.globalID(i0, i1, i2, i3, i4, i5)]
+     (li, i0, i1, i2, i3, i4, i5);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
+ inline typename Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatch&lt;LayoutTag,PatchTag&gt; &gt;::operator()(const LoopInvariant_t&amp; li, int i0, int i1, 
+   int i2, int i3, int i4, int i5, int i6) const
+ {
+   return data()[layout_m.globalID(i0, i1, i2, i3, i4, i5, i6)]
+     (li, i0, i1, i2, i3, i4, i5, i6);
+ }
+ 
  // Dynamic event handler for non-dynamic patch engines:
  
  template &lt;int Dim, class T, class LayoutTag, class PatchTag&gt;
*************** dynamicHandler(Observable_t &amp;, const Obs
*** 1437,1442 ****
--- 1644,1650 ----
  }
  
  
+ 
  ///////////////////////////////////////////////////////////////////////////////
  //
  // Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag,PatchTag,Dim2&gt; &gt; MEMBER FUNCTIONS
*************** read(int i0, int i1, int i2, int i3, int
*** 1585,1590 ****
--- 1793,1886 ----
    return data()[o].read(gloc);
  }
  
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline 
+ typename Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ read(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(loc, gloc);
+   return data()[o].read(li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline
+ typename Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::read(const LoopInvariant_t&amp; li, int i0) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, gloc);
+   return data()[o].read(li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline
+ typename Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ read(const LoopInvariant_t&amp; li, int i0, int i1) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, gloc);
+   return data()[o].read(li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline
+ typename Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ read(const LoopInvariant_t&amp; li, int i0, int i1, int i2) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, i2, gloc);
+   return data()[o].read(li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline
+ typename Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ read(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, i2, i3, gloc);
+   return data()[o].read(li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline
+ typename Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ read(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, i2, i3, i4, gloc);
+   return data()[o](li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline
+ typename Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ read(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, i2, i3, i4, i5, gloc);
+   return data()[o].read(li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline
+ typename Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::Element_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ read(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5, int i6) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, i2, i3, i4, i5, i6, gloc);
+   return data()[o].read(li, gloc);
+ }
+ 
+ 
  // Operator()'s:
  
  template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
*************** operator()(int i0, int i1, int i2, int i
*** 1675,1680 ****
--- 1971,2065 ----
    return data()[o](gloc);
  }
  
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline typename
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ operator()(const LoopInvariant_t&amp; li, const Loc&lt;Dim&gt; &amp;loc) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(loc, gloc);
+   return data()[o](li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline typename
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ operator()(const LoopInvariant_t&amp; li, int i0) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, gloc);
+   return data()[o](li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline typename
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ operator()(const LoopInvariant_t&amp; li, int i0, int i1) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, gloc);
+   return data()[o](li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline typename
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ operator()(const LoopInvariant_t&amp; li, int i0, int i1, int i2) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, i2, gloc);
+   return data()[o](li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline typename
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ operator()(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, i2, i3, gloc);
+   return data()[o](li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline typename
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ operator()(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, i2, i3, i4, gloc);
+   return data()[o](li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline typename
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ operator()(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, i2, i3, i4, i5, gloc);
+   return data()[o](li, gloc);
+ }
+ 
+ template&lt;int Dim, class T, class LayoutTag, class PatchTag, int Dim2&gt;
+ inline typename
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::ElementRef_t
+ Engine&lt;Dim, T, MultiPatchView&lt;LayoutTag, PatchTag, Dim2&gt; &gt;::
+ operator()(const LoopInvariant_t&amp; li, int i0, int i1, int i2, int i3, int i4, int i5, int i6) const
+ {
+   Loc&lt;Dim2&gt; gloc = Pooma::NoInit();
+   int o = layout_m.globalID(i0, i1, i2, i3, i4, i5, i6, gloc);
+   return data()[o](li, gloc);
+ }
+ 
+ 
  //---------------------------------------------------------------------------
  // Specialization of IntersectEngine because these engines contain multiple
  // patches.
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, MultiP
*** 1687,1696 ****
    ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &gt;
  {
    typedef int Type_t;
  
!   static Type_t
!   apply(const Engine&lt;Dim,T,MultiPatch&lt;LayoutTag,PatchTag&gt; &gt; &amp;engine,
! 	const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;tag)
    {
      bool useGuards =
        tag.tag().intersector_m.intersect(engine,
--- 2072,2083 ----
    ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &gt;
  {
    typedef int Type_t;
+   typedef Engine&lt;Dim,T,MultiPatch&lt;LayoutTag,PatchTag&gt; &gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;tag)
    {
      bool useGuards =
        tag.tag().intersector_m.intersect(engine,
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, MultiP
*** 1701,1706 ****
--- 2088,2101 ----
  
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;,
+ 	       const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;tag)
+   {
+     return apply(engine, tag);
+   }
  };
  
  template &lt;int Dim, class T, class LT, class PatchTag, int BD,
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, MultiP
*** 1709,1727 ****
    ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &gt;
  {
    typedef int Type_t;
  
!   static Type_t
!   apply(const Engine&lt;Dim,T,MultiPatchView&lt;LT,PatchTag,BD&gt; &gt; &amp;engine,
! 	const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;tag)
    {
      typedef typename MultiPatchLayoutTraits&lt;LT,Dim&gt;::Layout_t Layout_t;
      return applyHandler(engine, tag, WrappedInt&lt;Layout_t::supportsGuards&gt;());
    }
  
!   inline static Type_t
!   applyHandler(const Engine&lt;Dim,T,MultiPatchView&lt;LT,PatchTag,BD&gt; &gt; &amp;engine,
! 	       const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;tag,
! 	       const WrappedInt&lt;true&gt; &amp;)
    {
      bool useGuards =
        tag.tag().intersector_m.
--- 2104,2134 ----
    ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &gt;
  {
    typedef int Type_t;
+   typedef Engine&lt;Dim,T,MultiPatchView&lt;LT,PatchTag,BD&gt; &gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; Tag_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      typedef typename MultiPatchLayoutTraits&lt;LT,Dim&gt;::Layout_t Layout_t;
      return applyHandler(engine, tag, WrappedInt&lt;Layout_t::supportsGuards&gt;());
    }
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const LoopInvariant_t &amp;li,
! 	       const Tag_t &amp;tag)
!   {
!     typedef typename MultiPatchLayoutTraits&lt;LT,Dim&gt;::Layout_t Layout_t;
!     return applyHandler(engine, li, tag, WrappedInt&lt;Layout_t::supportsGuards&gt;());
!   }
! 
!   inline static
!   Type_t applyHandler(const Subject_t &amp;engine,
! 		      const Tag_t &amp;tag,
! 		      const WrappedInt&lt;true&gt; &amp;)
    {
      bool useGuards =
        tag.tag().intersector_m.
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, MultiP
*** 1734,1746 ****
      return 0;
    }
  
!   inline static Type_t
!   applyHandler(const Engine&lt;Dim,T,MultiPatchView&lt;LT,PatchTag,BD&gt; &gt; &amp;engine,
! 	       const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;tag,
! 	       const WrappedInt&lt;false&gt; &amp;)
    {
      tag.tag().intersector_m.intersect(engine, GuardLayers&lt;Dim&gt;()); 
      return 0;
    }
  };
  
--- 2141,2171 ----
      return 0;
    }
  
!   inline static
!   Type_t applyHandler(const Subject_t &amp;engine,
! 		      const LoopInvariant_t &amp;,
! 		      const Tag_t &amp;tag,
! 		      const WrappedInt&lt;true&gt; &amp;wi)
!   {
!     return applyHandler(engine, tag, wi);
!   }
! 
!   inline static
!   Type_t applyHandler(const Subject_t &amp;engine,
! 		      const Tag_t &amp;tag,
! 		      const WrappedInt&lt;false&gt; &amp;)
    {
      tag.tag().intersector_m.intersect(engine, GuardLayers&lt;Dim&gt;()); 
      return 0;
+   }
+ 
+   inline static
+   Type_t applyHandler(const Subject_t &amp;engine,
+ 		      const LoopInvariant_t &amp;,
+ 		      const Tag_t &amp;tag,
+ 		      const WrappedInt&lt;false&gt; &amp;wi)
+   {
+     return applyHandler(engine, tag, wi);
    }
  };
  
Index: src/Engine/RemoteDynamicEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/RemoteDynamicEngine.h,v
retrieving revision 1.16
diff -c -p -r1.16 RemoteDynamicEngine.h
*** src/Engine/RemoteDynamicEngine.h	2001/05/16 21:21:06	1.16
--- src/Engine/RemoteDynamicEngine.h	2001/11/05 19:28:26
*************** template&lt;class T&gt;
*** 710,721 ****
  struct LeafFunctor&lt;Engine&lt;1, T, Remote&lt;Dynamic&gt; &gt;, EngineView&lt;RemoteView&gt; &gt;
  {
    typedef Engine&lt;1, T, Remote&lt;Dynamic&gt; &gt; Subject_t;
  
    typedef Engine&lt;1, T, Dynamic&gt; Type_t;
  
!   static inline
    Type_t apply(const Subject_t &amp;engine,
! 	       const EngineView&lt;RemoteView&gt; &amp;)
    {
      if (engine.engineIsLocal())
      {
--- 710,723 ----
  struct LeafFunctor&lt;Engine&lt;1, T, Remote&lt;Dynamic&gt; &gt;, EngineView&lt;RemoteView&gt; &gt;
  {
    typedef Engine&lt;1, T, Remote&lt;Dynamic&gt; &gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef EngineView&lt;RemoteView&gt; View_t;
  
    typedef Engine&lt;1, T, Dynamic&gt; Type_t;
  
!   inline static
    Type_t apply(const Subject_t &amp;engine,
! 	       const View_t &amp;)
    {
      if (engine.engineIsLocal())
      {
*************** struct LeafFunctor&lt;Engine&lt;1, T, Remote&lt;D
*** 730,735 ****
--- 732,745 ----
        return local;
      }
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;,
+ 	       const View_t &amp;t)
+   {
+     return apply(engine,t);
+   }
  };
  
  template&lt;class T&gt;
*************** struct LeafFunctor&lt;Engine&lt;1, T, Remote&lt;D
*** 737,748 ****
    EngineView&lt;RemoteView&gt; &gt;
  {
    typedef Engine&lt;1, T, Remote&lt;DynamicView&gt; &gt; Subject_t;
  
    typedef Engine&lt;1, T, DynamicView&gt; Type_t;
  
!   static inline
    Type_t apply(const Subject_t &amp;engine,
! 	       const EngineView&lt;RemoteView&gt; &amp;)
    {
      if (engine.engineIsLocal())
      {
--- 747,760 ----
    EngineView&lt;RemoteView&gt; &gt;
  {
    typedef Engine&lt;1, T, Remote&lt;DynamicView&gt; &gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef EngineView&lt;RemoteView&gt; View_t;
  
    typedef Engine&lt;1, T, DynamicView&gt; Type_t;
  
!   inline static
    Type_t apply(const Subject_t &amp;engine,
! 	       const View_t &amp;)
    {
      if (engine.engineIsLocal())
      {
*************** struct LeafFunctor&lt;Engine&lt;1, T, Remote&lt;D
*** 757,762 ****
--- 769,782 ----
        PAssert(false);
        return engine.localEngine();  // (This will fail at run-time)
      }
+   }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;,
+ 	       const View_t &amp;v)
+   {
+     return apply(engine, v);
    }
  };
  
Index: src/Engine/RemoteEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/RemoteEngine.h,v
retrieving revision 1.34
diff -c -p -r1.34 RemoteEngine.h
*** src/Engine/RemoteEngine.h	2001/09/13 20:55:14	1.34
--- src/Engine/RemoteEngine.h	2001/11/05 19:28:26
*************** public:
*** 124,129 ****
--- 124,132 ----
    typedef RemoteProxy&lt;T&gt;                       ElementRef_t;
    typedef Remote&lt;Tag&gt;                          Tag_t;
    typedef DomainLayout&lt;Dim&gt;                    Layout_t;
+   typedef typename LocalEngine_t::LoopInvariant_t
+ 					       LoopInvariant_t;
+   // FIXME: Is this correct?  Do I need to modify the read() functions?
  
    enum { dimensions = Dim };
    enum { hasDataObject = true };
Index: src/Engine/Stencil.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/Stencil.h,v
retrieving revision 1.44
diff -c -p -r1.44 Stencil.h
*** src/Engine/Stencil.h	2001/09/14 22:37:56	1.44
--- src/Engine/Stencil.h	2001/11/05 19:28:26
*************** public:
*** 273,278 ****
--- 273,300 ----
    enum { multiPatch = ExprEngine_t::multiPatch };
    enum { zeroBased = true };
  
+   class LoopInvariant_t {
+   public:
+     typedef typename Expression::LoopInvariant_t ExpressionLoopInvariant_t;
+     
+     LoopInvariant_t(const ExpressionLoopInvariant_t&amp; eli,
+ 		    const int* offset)
+       : eli_m(eli) {
+       for (int i = 0; i &lt; D; ++i)
+ 	offset_m[i] = offset[i];
+     }
+ 
+     const ExpressionLoopInvariant_t&amp; exprLoopInvariant() const 
+       { return eli_m; }
+ 
+     const int* offset() const { return offset_m; }
+ 
+   private:
+     ExpressionLoopInvariant_t eli_m;
+     int                       offset_m[D]; 
+   };
+ 
+ 
    //============================================================
    // Construct from a Function object (effectively a stencil)
    // and an expression (effectively the input array), and
*************** public:
*** 378,383 ****
--- 400,444 ----
  		      loc[2].first() + offset_m[2]);
    }
  
+   inline Element_t read(const LoopInvariant_t&amp; li, int i) const 
+   {
+     // Input index `i + offset_m[0]' corresponds to output index `i'.
+     return function()(expression_m, li.exprLoopInvariant(),
+ 		      i + li.offset()[0]);
+   }
+   inline Element_t read(const LoopInvariant_t&amp; li, int i, int j) const 
+   {
+     return function()(expression_m, li.exprLoopInvariant(),
+ 		      i + li.offset()[0],
+ 		      j + li.offset()[1]);
+   }
+   inline Element_t read(const LoopInvariant_t&amp; li, int i, int j, int k) const 
+   {
+     return function()(expression_m, li.exprLoopInvariant(),
+ 		      i + li.offset()[0],
+ 		      j + li.offset()[1],
+ 		      k + li.offset()[2]);
+   }
+ 
+   inline Element_t read(const LoopInvariant_t&amp; li, const Loc&lt;1&gt; &amp;loc) const 
+   {
+     return function()(expression_m, li.exprLoopInvariant(),
+ 		      loc[0].first() + li.offset()[0]);
+   }
+   inline Element_t read(const LoopInvariant_t&amp; li, const Loc&lt;2&gt; &amp;loc) const 
+   {
+     return function()(expression_m, li.exprLoopInvariant(),
+ 		      loc[0].first() + li.offset()[0],
+ 		      loc[1].first() + li.offset()[1]);
+   }
+   inline Element_t read(const LoopInvariant_t&amp; li, const Loc&lt;3&gt; &amp;loc) const 
+   {
+     return function()(expression_m, li.exprLoopInvariant(),
+ 		      loc[0].first() + li.offset()[0],
+ 		      loc[1].first() + li.offset()[1],
+ 		      loc[2].first() + li.offset()[2]);
+   }
+ 
    //============================================================
    // operator() are provided since users typically write stencils
    // as x(i, j) + x(i, j - 1), so for stencils of stencils to work
*************** public:
*** 474,479 ****
--- 535,544 ----
    inline const Function   &amp;function() const   { return function_m; }
    inline const Expression &amp;expression() const { return expression_m; }
  
+   inline const LoopInvariant_t loopInvariant() const
+     { return LoopInvariant_t(expression_m.loopInvariant(),
+ 			     offset_m); }
+ 
  private:
  
    Function    function_m;
*************** struct LeafFunctor&lt;Engine&lt;D,T,StencilEng
*** 855,864 ****
    ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &gt;
  {
    typedef int Type_t;
! 
!   static
!   Type_t apply(const Engine&lt;D,T,StencilEngine&lt;S,E&gt; &gt; &amp;engine,
! 	       const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;tag)
    {
      typedef StencilIntersector&lt;D, Intersect&gt; NewIntersector_t;
      NewIntersector_t newIntersector(engine.intersectDomain(),
--- 920,932 ----
    ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &gt;
  {
    typedef int Type_t;
!   typedef Engine&lt;D,T,StencilEngine&lt;S,E&gt; &gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; Tag_t;
! 
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      typedef StencilIntersector&lt;D, Intersect&gt; NewIntersector_t;
      NewIntersector_t newIntersector(engine.intersectDomain(),
*************** struct LeafFunctor&lt;Engine&lt;D,T,StencilEng
*** 868,873 ****
--- 936,956 ----
  		    IntersectorTag&lt;NewIntersector_t&gt;(newIntersector));
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     typedef StencilIntersector&lt;D, Intersect&gt; NewIntersector_t;
+     NewIntersector_t newIntersector(engine.intersectDomain(),
+ 				    tag.tag().intersector_m);
+ 
+     // FIXME: Where is this defined?  Revise it.
+     expressionApply(engine.expression(), li,
+ 		    IntersectorTag&lt;NewIntersector_t&gt;(newIntersector));
+     return 0;
+   }
  };
  
  //---------------------------------------------------------------------------
*************** struct EngineFunctor&lt;Engine&lt;D, T, Stenci
*** 905,921 ****
  template &lt;int D, class T, class S, class E, class Tag&gt;
  struct LeafFunctor&lt;Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt;, EngineView&lt;Tag&gt; &gt;
  {
!   typedef LeafFunctor&lt;E, EngineView&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t NewViewed_t;
    typedef Engine&lt;D, T, StencilEngine&lt;S, NewViewed_t&gt; &gt; Type_t;
  
!   static
!   Type_t apply(const Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt; &amp;engine,
! 	       const EngineView&lt;Tag&gt; &amp;tag)
    {
      return Type_t(engine.function(), 
  		  LeafFunctor_t::apply(engine.expression(), tag));
    }
  };
  
  //-----------------------------------------------------------------------------
--- 988,1016 ----
  template &lt;int D, class T, class S, class E, class Tag&gt;
  struct LeafFunctor&lt;Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt;, EngineView&lt;Tag&gt; &gt;
  {
!   typedef Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef EngineView&lt;Tag&gt; Tag_t;
!   typedef LeafFunctor&lt;E, Tag_t &gt; LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t NewViewed_t;
    typedef Engine&lt;D, T, StencilEngine&lt;S, NewViewed_t&gt; &gt; Type_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      return Type_t(engine.function(), 
  		  LeafFunctor_t::apply(engine.expression(), tag));
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return Type_t(engine.function(), li,
+ 		  LeafFunctor_t::apply(engine.expression(), tag));
+   }
  };
  
  //-----------------------------------------------------------------------------
*************** struct LeafFunctor&lt;Engine&lt;D, T, StencilE
*** 928,941 ****
  template &lt;int D, class T, class S, class E, class Tag&gt;
  struct LeafFunctor&lt;Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
!   typedef LeafFunctor&lt;E, ExpressionApply&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef int Type_t;
  
!   static
!   Type_t apply(const Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt; &amp;engine,
! 	       const ExpressionApply&lt;Tag&gt; &amp;tag)
    {
      return LeafFunctor_t::apply(engine.expression(), tag);
    }
  };
  
--- 1023,1047 ----
  template &lt;int D, class T, class S, class E, class Tag&gt;
  struct LeafFunctor&lt;Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
!   typedef Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef ExpressionApply&lt;Tag&gt; Tag_t;
!   typedef LeafFunctor&lt;E, Tag_t&gt; LeafFunctor_t;
    typedef int Type_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      return LeafFunctor_t::apply(engine.expression(), tag);
+   }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return LeafFunctor_t::apply(engine.expression(), li, tag);
    }
  };
  
Index: src/Engine/UserFunction.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/UserFunction.h,v
retrieving revision 1.28
diff -c -p -r1.28 UserFunction.h
*** src/Engine/UserFunction.h	2001/09/14 22:37:57	1.28
--- src/Engine/UserFunction.h	2001/11/05 19:28:26
*************** public:
*** 142,147 ****
--- 142,153 ----
    typedef T                                  Element_t;
    typedef ErrorType                          ElementRef_t;
    typedef typename Expression::Engine_t      ExprEngine_t;
+ 
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   typedef typename Expression::LoopInvariant_t LoopInvariant_t;
+ 
    enum { dimensions = D };
    enum { hasDataObject = ExprEngine_t::hasDataObject };
    enum { dynamic = false };
*************** public:
*** 203,208 ****
--- 209,256 ----
      return userFunction_m(expression_m.read(i,j,k,l,m,n,o));
    }
  
+   // HERE
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			const Loc&lt;D&gt; &amp;loc) const 
+   {
+     return userFunction_m(expression_m.read(li, loc));
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i) const 
+   {
+     return userFunction_m(expression_m.read(li, i));
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i, int j) const 
+   {
+     return userFunction_m(expression_m.read(li, i,j));
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i, int j, int k) const 
+   {
+     return userFunction_m(expression_m.read(li, i,j,k));
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i, int j, int k, int l) const 
+   {
+     return userFunction_m(expression_m.read(li, i,j,k,l));
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i, int j, int k, int l,int m) const 
+   {
+     return userFunction_m(expression_m.read(li, i,j,k,l,m));
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i, int j, int k, int l,int m,int n) const 
+   {
+     return userFunction_m(expression_m.read(li, i,j,k,l,m,n));
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li,
+ 			int i, int j, int k, int l,int m,int n,int o) const 
+   {
+     return userFunction_m(expression_m.read(li, i,j,k,l,m,n,o));
+   }
+ 
    inline Element_t operator()(const Loc&lt;D&gt; &amp;loc) const 
    {
      return userFunction_m(expression_m(loc));
*************** public:
*** 271,276 ****
--- 319,333 ----
      return engineFunctor(expression_m.engine(),f);
    }
  
+   //---------------------------------------------------------------------------
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+   //---------------------------------------------------------------------------
+ 
+   inline
+   const LoopInvariant_t loopInvariant() const 
+   { return expression_m.loopInvariant(); }
+ 
  private:
    UserFunction userFunction_m;
    Expression expression_m;
*************** struct EngineFunctor&lt;Engine&lt;Dim, T, User
*** 447,453 ****
  {
    typedef typename EngineFunctor&lt;E, EFTag&gt;::Type_t Type_t;
  
!   static Type_t
    apply(const Engine&lt;Dim, T, UserFunctionEngine&lt;S, E&gt; &gt; &amp;engine,
  	const EFTag &amp;tag)
    {
--- 504,510 ----
  {
    typedef typename EngineFunctor&lt;E, EFTag&gt;::Type_t Type_t;
  
!   inline static Type_t
    apply(const Engine&lt;Dim, T, UserFunctionEngine&lt;S, E&gt; &gt; &amp;engine,
  	const EFTag &amp;tag)
    {
*************** template &lt;int D, class T, class Func, cl
*** 459,489 ****
  struct LeafFunctor&lt;Engine&lt;D, T, UserFunctionEngine&lt;Func, Expr&gt; &gt;,
    EngineView&lt;Tag&gt; &gt;
  {
!   typedef LeafFunctor&lt;Expr, EngineView&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t NewViewed_t;
    typedef Engine&lt;D, T, UserFunctionEngine&lt;Func, NewViewed_t&gt; &gt; Type_t;
  
!   static
!   Type_t apply(const Engine&lt;D, T, UserFunctionEngine&lt;Func, Expr&gt; &gt; &amp;engine,
! 	       const EngineView&lt;Tag&gt; &amp;tag)
    {
      return Type_t(engine.userFunction(),
  		  LeafFunctor_t::apply(engine.expression(), tag));
    }
  };
  
  template &lt;int D, class T, class Func, class Expr, class Tag&gt;
  struct LeafFunctor&lt;Engine&lt;D, T, UserFunctionEngine&lt;Func, Expr&gt; &gt;,
    ExpressionApply&lt;Tag&gt; &gt;
  {
!   typedef LeafFunctor&lt;Expr, ExpressionApply&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef int Type_t;
  
!   static
!   Type_t apply(const Engine&lt;D, T, UserFunctionEngine&lt;Func, Expr&gt; &gt; &amp;engine,
! 	       const ExpressionApply&lt;Tag&gt; &amp;tag)
    {
      return LeafFunctor_t::apply(engine.expression(), tag);
    }
  };
  
--- 516,569 ----
  struct LeafFunctor&lt;Engine&lt;D, T, UserFunctionEngine&lt;Func, Expr&gt; &gt;,
    EngineView&lt;Tag&gt; &gt;
  {
!   typedef Engine&lt;D, T, UserFunctionEngine&lt;Func, Expr&gt; &gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef EngineView&lt;Tag&gt; Tag_t;
!   typedef LeafFunctor&lt;Expr, Tag_t &gt; LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t NewViewed_t;
    typedef Engine&lt;D, T, UserFunctionEngine&lt;Func, NewViewed_t&gt; &gt; Type_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      return Type_t(engine.userFunction(),
  		  LeafFunctor_t::apply(engine.expression(), tag));
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return Type_t(engine.userFunction(), li,
+ 		  LeafFunctor_t::apply(engine.expression(), tag));
+   }
  };
  
  template &lt;int D, class T, class Func, class Expr, class Tag&gt;
  struct LeafFunctor&lt;Engine&lt;D, T, UserFunctionEngine&lt;Func, Expr&gt; &gt;,
    ExpressionApply&lt;Tag&gt; &gt;
  {
!   typedef Engine&lt;D, T, UserFunctionEngine&lt;Func, Expr&gt; &gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef ExpressionApply&lt;Tag&gt; Tag_t;
!   typedef LeafFunctor&lt;Expr, Tag_t&gt; LeafFunctor_t;
    typedef int Type_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      return LeafFunctor_t::apply(engine.expression(), tag);
+   }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return LeafFunctor_t::apply(engine.expression(), li, tag);
    }
  };
  
Index: src/Engine/ViewEngine.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/ViewEngine.h,v
retrieving revision 1.23
diff -c -p -r1.23 ViewEngine.h
*** src/Engine/ViewEngine.h	2001/08/30 01:15:04	1.23
--- src/Engine/ViewEngine.h	2001/11/05 19:28:26
*************** public:
*** 99,104 ****
--- 99,106 ----
    typedef DomainLayout&lt;Dim&gt;                        Layout_t;
    typedef T                                        Element_t;
    typedef ErrorType                                ElementRef_t;
+   typedef typename ViewedEngine_t::LoopInvariant_t LoopInvariant_t;
+   // FIXME: modify read()?
  
    enum { dimensions = Dim };
    enum { hasDataObject = ViewedEngine_t::hasDataObject };
*************** public:
*** 260,265 ****
--- 262,318 ----
      return eng_m.read(oloc);
    }
  
+   // HERE
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0) const 
+   {
+     Loc&lt;OriginalDim&gt; oloc;
+     indexer_m.translate(i0, oloc);
+     return eng_m.read(li, oloc);
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1) const 
+   {
+     Loc&lt;OriginalDim&gt; oloc;
+     indexer_m.translate(i0, i1, oloc);
+     return eng_m.read(li, oloc);
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1, int i2) const 
+   {
+     Loc&lt;OriginalDim&gt; oloc;
+     indexer_m.translate(i0, i1, i2, oloc);
+     return eng_m.read(li, oloc);
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1, int i2, int i3) const 
+   {
+     Loc&lt;OriginalDim&gt; oloc;
+     indexer_m.translate(i0, i1, i2, i3, oloc);
+     return eng_m.read(li, oloc);
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1, int i2, int i3, int i4) const 
+   {
+     Loc&lt;OriginalDim&gt; oloc;
+     indexer_m.translate(i0, i1, i2, i3, i4, oloc);
+     return eng_m.read(li, oloc);
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1, int i2, int i3, int i4, int i5) const 
+   {
+     Loc&lt;OriginalDim&gt; oloc;
+     indexer_m.translate(i0, i1, i2, i3, i4, i5, oloc);
+     return eng_m.read(li, oloc);
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li, int i0, int i1, int i2, int i3, int i4, 
+ 			int i5, int i6) const 
+   {
+     Loc&lt;OriginalDim&gt; oloc;
+     indexer_m.translate(i0, i1, i2, i3, i4, i5, i6, oloc);
+     return eng_m.read(li, oloc);
+   }
+   inline Element_t read(const LoopInvariant_t &amp;li, const Loc&lt;Dim&gt; &amp;loc) const
+   {
+     Loc&lt;OriginalDim&gt; oloc;
+     indexer_m.translate(loc, oloc);
+     return eng_m.read(li, oloc);
+   }
+ 
    //---------------------------------------------------------------------------
    // Return the domain.
  
*************** public:
*** 292,297 ****
--- 345,357 ----
      return eng_m.dataObjectRequest(f);
    }
  
+   //---------------------------------------------------------------------------
+   // Yield values that do not change during the evaluation of a single 
+   // data parallel statement.
+   inline
+   const LoopInvariant_t loopInvariant() const 
+   { return eng_m.loopInvariant(); }
+ 
  private:
  
    ViewedEngine_t eng_m;
*************** struct LeafFunctor&lt; Engine&lt;Dim, T, ViewE
*** 602,620 ****
  {
    typedef int Type_t;
    typedef Engine&lt;Dim, T, ViewEngine&lt;D2, ViewedTag&gt; &gt; Engine_t;
! 
!   static Type_t
!   apply(const Engine_t &amp;,
! 	const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;,
! 	const WrappedInt&lt;false&gt; &amp;)
    {
      return 0;
    }
  
!   static Type_t
!   apply(const Engine_t &amp;engine,
! 	const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;tag,
! 	const WrappedInt&lt;true&gt; &amp;)
    {
      enum { d1 = Intersect::dimensions };
      ViewIntersector&lt;d1, Dim, D2&gt; newIntersector(engine.indexer(),
--- 662,692 ----
  {
    typedef int Type_t;
    typedef Engine&lt;Dim, T, ViewEngine&lt;D2, ViewedTag&gt; &gt; Engine_t;
!   typedef Engine_t Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; Tag_t;
! 
!   inline static
!   Type_t apply(const Engine_t &amp;,
! 	       const Tag_t &amp;,
! 	       const WrappedInt&lt;false&gt; &amp;)
    {
      return 0;
    }
  
!   inline static
!   Type_t apply(const Engine_t &amp;e,
! 	       const LoopInvariant_t &amp;,
! 	       const Tag_t &amp;t,
! 	       const WrappedInt&lt;false&gt; &amp;wi)
!   {
!     return apply(e,t,wi);
!   }
! 
!   inline static
!   Type_t apply(const Engine_t &amp;engine,
! 	       const Tag_t &amp;tag,
! 	       const WrappedInt&lt;true&gt; &amp;)
    {
      enum { d1 = Intersect::dimensions };
      ViewIntersector&lt;d1, Dim, D2&gt; newIntersector(engine.indexer(),
*************** struct LeafFunctor&lt; Engine&lt;Dim, T, ViewE
*** 626,640 ****
      return 0;
    }
  
!   static Type_t
!   apply(const Engine_t &amp;engine,
! 	const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;tag)
    {
      enum { multiPatch =
  	   Engine&lt;Dim, T, ViewEngine&lt;D2, ViewedTag&gt; &gt;::multiPatch };
  
      return apply(engine, tag, WrappedInt&lt;multiPatch&gt;());
    }
  };
  
  //---------------------------------------------------------------------------
--- 698,739 ----
      return 0;
    }
  
!   inline static
!   Type_t apply(const Engine_t &amp;engine,
! 	       const LoopInvariant_t &amp;li,
! 	       const Tag_t &amp;tag,
! 	       const WrappedInt&lt;true&gt; &amp;)
    {
+     enum { d1 = Intersect::dimensions };
+     ViewIntersector&lt;d1, Dim, D2&gt; newIntersector(engine.indexer(),
+ 						tag.tag().intersector_m);
+     ExpressionApply&lt;IntersectorTag&lt;ViewIntersector&lt;d1, Dim, D2&gt; &gt; &gt;
+       newTag(newIntersector);
+     
+     forEach(engine.viewedEngine(), li, newTag, NullCombine());
+     return 0;
+   }
+ 
+   inline static
+   Type_t apply(const Engine_t &amp;engine,
+ 	       const Tag_t &amp;tag)
+   {
      enum { multiPatch =
  	   Engine&lt;Dim, T, ViewEngine&lt;D2, ViewedTag&gt; &gt;::multiPatch };
  
      return apply(engine, tag, WrappedInt&lt;multiPatch&gt;());
    }
+ 
+   inline static
+   Type_t apply(const Engine_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     enum { multiPatch =
+ 	   Engine&lt;Dim, T, ViewEngine&lt;D2, ViewedTag&gt; &gt;::multiPatch };
+ 
+     return apply(engine, li, tag, WrappedInt&lt;multiPatch&gt;());
+   }
  };
  
  //---------------------------------------------------------------------------
*************** template &lt;int D, class T, int D2, class 
*** 662,675 ****
  struct LeafFunctor&lt;Engine&lt;D, T, ViewEngine&lt;D2, E&gt; &gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef Engine&lt;D, T, ViewEngine&lt;D2, E&gt; &gt; Subject_t;
    typedef typename Subject_t::ViewedEngine_t Engine_t;
!   typedef LeafFunctor&lt;Engine_t, ExpressionApply&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef int Type_t;
  
!   static
!   Type_t apply(const Subject_t &amp;engine, const ExpressionApply&lt;Tag&gt; &amp;tag)
    {
      return LeafFunctor_t::apply(engine.viewedEngine(), tag);
    }
  };
  
--- 761,784 ----
  struct LeafFunctor&lt;Engine&lt;D, T, ViewEngine&lt;D2, E&gt; &gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef Engine&lt;D, T, ViewEngine&lt;D2, E&gt; &gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef ExpressionApply&lt;Tag&gt; Tag_t;
    typedef typename Subject_t::ViewedEngine_t Engine_t;
!   typedef LeafFunctor&lt;Engine_t, Tag_t&gt; LeafFunctor_t;
    typedef int Type_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine, const Tag_t &amp;tag)
    {
      return LeafFunctor_t::apply(engine.viewedEngine(), tag);
+   }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return LeafFunctor_t::apply(engine.viewedEngine(), li, tag);
    }
  };
  
Index: src/Evaluator/EvaluatorTags.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Evaluator/EvaluatorTags.h,v
retrieving revision 1.17
diff -c -p -r1.17 EvaluatorTags.h
*** src/Evaluator/EvaluatorTags.h	2000/03/28 23:30:39	1.17
--- src/Evaluator/EvaluatorTags.h	2001/11/05 19:28:26
*************** struct Combine2&lt;Eval1, Eval2, Op, Evalua
*** 266,272 ****
  //-----------------------------------------------------------------------------
  // EvaluatorTag&lt;Expr&gt;
  //
! // This struct computes the evaluator tag for a single expression..
  //-----------------------------------------------------------------------------
  
  template&lt;class Expr&gt;
--- 266,272 ----
  //-----------------------------------------------------------------------------
  // EvaluatorTag&lt;Expr&gt;
  //
! // This struct computes the evaluator tag for a single expression.
  //-----------------------------------------------------------------------------
  
  template&lt;class Expr&gt;
Index: src/Evaluator/InlineEvaluator.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Evaluator/InlineEvaluator.h,v
retrieving revision 1.26
diff -c -p -r1.26 InlineEvaluator.h
*** src/Evaluator/InlineEvaluator.h	2001/04/13 02:15:06	1.26
--- src/Evaluator/InlineEvaluator.h	2001/11/05 19:28:26
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 157,165 ****
    {
      CTAssert(Domain::unitStride);
      PAssert(domain[0].first() == 0);
      int e0 = domain[0].length();
      for (int i0=0; i0&lt;e0; ++i0)
!       op(lhs(i0),rhs.read(i0));
    }
  
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
--- 157,169 ----
    {
      CTAssert(Domain::unitStride);
      PAssert(domain[0].first() == 0);
+     // TMP typedef typename LHS::Engine_t::LoopInvariant_t LHSLoopInvariant_t;
+     typedef typename RHS::Engine_t::LoopInvariant_t RHSLoopInvariant_t;
+     // TMP const LHSLoopInvariant_t lli = lhs.loopInvariant();
+     const RHSLoopInvariant_t rli = rhs.loopInvariant();
      int e0 = domain[0].length();
      for (int i0=0; i0&lt;e0; ++i0)
!       op(lhs(i0),rhs.read(rli, i0));
    }
  
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 169,179 ****
      CTAssert(Domain::unitStride);
      PAssert(domain[0].first() == 0);
      PAssert(domain[1].first() == 0);
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      for (int i1=0; i1&lt;e1; ++i1)
        for (int i0=0; i0&lt;e0; ++i0)
! 	op(lhs(i0,i1),rhs.read(i0,i1));
    }
    
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
--- 173,187 ----
      CTAssert(Domain::unitStride);
      PAssert(domain[0].first() == 0);
      PAssert(domain[1].first() == 0);
+     // TMP typedef typename LHS::Engine_t::LoopInvariant_t LHSLoopInvariant_t;
+     typedef typename RHS::Engine_t::LoopInvariant_t RHSLoopInvariant_t;
+     // TMP const LHSLoopInvariant_t lli = lhs.loopInvariant();
+     const RHSLoopInvariant_t rli = rhs.loopInvariant();
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      for (int i1=0; i1&lt;e1; ++i1)
        for (int i0=0; i0&lt;e0; ++i0)
! 	op(lhs(i0,i1),rhs.read(rli, i0,i1));
    }
    
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 184,196 ****
      PAssert(domain[0].first() == 0);
      PAssert(domain[1].first() == 0);
      PAssert(domain[2].first() == 0);
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
      for (int i2=0; i2&lt;e2; ++i2)
        for (int i1=0; i1&lt;e1; ++i1)
  	for (int i0=0; i0&lt;e0; ++i0)
! 	  op(lhs(i0,i1,i2),rhs.read(i0,i1,i2));
    }
  
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
--- 192,208 ----
      PAssert(domain[0].first() == 0);
      PAssert(domain[1].first() == 0);
      PAssert(domain[2].first() == 0);
+     // TMP typedef typename LHS::Engine_t::LoopInvariant_t LHSLoopInvariant_t;
+     typedef typename RHS::Engine_t::LoopInvariant_t RHSLoopInvariant_t;
+     // TMP const LHSLoopInvariant_t lli = lhs.loopInvariant();
+     const RHSLoopInvariant_t rli = rhs.loopInvariant();
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
      for (int i2=0; i2&lt;e2; ++i2)
        for (int i1=0; i1&lt;e1; ++i1)
  	for (int i0=0; i0&lt;e0; ++i0)
! 	  op(lhs(i0,i1,i2),rhs.read(rli, i0,i1,i2));
    }
  
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 202,207 ****
--- 214,223 ----
      PAssert(domain[1].first() == 0);
      PAssert(domain[2].first() == 0);
      PAssert(domain[3].first() == 0);
+     // TMP typedef typename LHS::Engine_t::LoopInvariant_t LHSLoopInvariant_t;
+     typedef typename RHS::Engine_t::LoopInvariant_t RHSLoopInvariant_t;
+     // TMP const LHSLoopInvariant_t lli = lhs.loopInvariant();
+     const RHSLoopInvariant_t rli = rhs.loopInvariant();
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 210,216 ****
        for (int i2=0; i2&lt;e2; ++i2)
  	for (int i1=0; i1&lt;e1; ++i1)
  	  for (int i0=0; i0&lt;e0; ++i0)
! 	    op(lhs(i0,i1,i2,i3),rhs.read(i0,i1,i2,i3));
    }
  
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
--- 226,232 ----
        for (int i2=0; i2&lt;e2; ++i2)
  	for (int i1=0; i1&lt;e1; ++i1)
  	  for (int i0=0; i0&lt;e0; ++i0)
! 	    op(lhs(/*lli,*/ i0,i1,i2,i3),rhs.read(rli, i0,i1,i2,i3));
    }
  
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 223,228 ****
--- 239,248 ----
      PAssert(domain[2].first() == 0);
      PAssert(domain[3].first() == 0);
      PAssert(domain[4].first() == 0);
+     // TMP typedef typename LHS::Engine_t::LoopInvariant_t LHSLoopInvariant_t;
+     typedef typename RHS::Engine_t::LoopInvariant_t RHSLoopInvariant_t;
+     // TMP const LHSLoopInvariant_t lli = lhs.loopInvariant();
+     const RHSLoopInvariant_t rli = rhs.loopInvariant();
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 233,239 ****
  	for (int i2=0; i2&lt;e2; ++i2)
  	  for (int i1=0; i1&lt;e1; ++i1)
  	    for (int i0=0; i0&lt;e0; ++i0)
! 	      op(lhs(i0,i1,i2,i3,i4),rhs.read(i0,i1,i2,i3,i4));
    }
  
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
--- 253,259 ----
  	for (int i2=0; i2&lt;e2; ++i2)
  	  for (int i1=0; i1&lt;e1; ++i1)
  	    for (int i0=0; i0&lt;e0; ++i0)
! 	      op(lhs(/*lli,*/ i0,i1,i2,i3,i4),rhs.read(rli, i0,i1,i2,i3,i4));
    }
  
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 247,252 ****
--- 267,276 ----
      PAssert(domain[3].first() == 0);
      PAssert(domain[4].first() == 0);
      PAssert(domain[5].first() == 0);
+     // TMP typedef typename LHS::Engine_t::LoopInvariant_t LHSLoopInvariant_t;
+     typedef typename RHS::Engine_t::LoopInvariant_t RHSLoopInvariant_t;
+     // TMP const LHSLoopInvariant_t lli = lhs.loopInvariant();
+     const RHSLoopInvariant_t rli = rhs.loopInvariant();
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 259,266 ****
  	  for (int i2=0; i2&lt;e2; ++i2)
  	    for (int i1=0; i1&lt;e1; ++i1)
  	      for (int i0=0; i0&lt;e0; ++i0)
! 		op(lhs(i0,i1,i2,i3,i4,i5),
! 		   rhs.read(i0,i1,i2,i3,i4,i5));
    }
  
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
--- 283,290 ----
  	  for (int i2=0; i2&lt;e2; ++i2)
  	    for (int i1=0; i1&lt;e1; ++i1)
  	      for (int i0=0; i0&lt;e0; ++i0)
! 		op(lhs(/*lli,*/ i0,i1,i2,i3,i4,i5),
! 		   rhs.read(rli, i0,i1,i2,i3,i4,i5));
    }
  
    template&lt;class LHS,class Op,class RHS,class Domain&gt;
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 275,280 ****
--- 299,308 ----
      PAssert(domain[4].first() == 0);
      PAssert(domain[5].first() == 0);
      PAssert(domain[6].first() == 0);
+     // TMP typedef typename LHS::Engine_t::LoopInvariant_t LHSLoopInvariant_t;
+     typedef typename RHS::Engine_t::LoopInvariant_t RHSLoopInvariant_t;
+     // TMP const LHSLoopInvariant_t lli = lhs.loopInvariant();
+     const RHSLoopInvariant_t rli = rhs.loopInvariant();
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
*************** struct KernelEvaluator&lt;InlineKernelTag&gt;
*** 289,296 ****
  	    for (int i2=0; i2&lt;e2; ++i2)
  	      for (int i1=0; i1&lt;e1; ++i1)
  		for (int i0=0; i0&lt;e0; ++i0)
! 		  op(lhs(i0,i1,i2,i3,i4,i5,i6),
! 		     rhs.read(i0,i1,i2,i3,i4,i5,i6));
    }
  
  private:
--- 317,324 ----
  	    for (int i2=0; i2&lt;e2; ++i2)
  	      for (int i1=0; i1&lt;e1; ++i1)
  		for (int i0=0; i0&lt;e0; ++i0)
! 		  op(lhs(/*lli,*/ i0,i1,i2,i3,i4,i5,i6),
! 		     rhs.read(rli, i0,i1,i2,i3,i4,i5,i6));
    }
  
  private:
Index: src/Evaluator/MultiArgEvaluator.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Evaluator/MultiArgEvaluator.h,v
retrieving revision 1.10
diff -c -p -r1.10 MultiArgEvaluator.h
*** src/Evaluator/MultiArgEvaluator.h	2001/10/15 17:34:30	1.10
--- src/Evaluator/MultiArgEvaluator.h	2001/11/05 19:28:26
*************** template&lt;class A1, class Tag&gt;
*** 477,491 ****
  struct LeafFunctor&lt;MultiArg1&lt;A1&gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef int Type_t;
  
    inline static
!   Type_t apply(const MultiArg1&lt;A1&gt; &amp;multiarg,
! 	       const ExpressionApply&lt;Tag&gt; &amp;tag)
    {
      leafFunctor(multiarg.a1_m, tag);
      return 0;
    }
  };
  
  template&lt;class A1, class Tag&gt;
  struct LeafFunctor&lt;MultiArg1&lt;A1&gt;, EngineView&lt;Tag&gt; &gt;
--- 477,506 ----
  struct LeafFunctor&lt;MultiArg1&lt;A1&gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef int Type_t;
+   typedef MultiArg1&lt;A1&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef ExpressionApply&lt;Tag&gt; Tag_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;multiarg,
! 	       const Tag_t &amp;tag)
    {
      leafFunctor(multiarg.a1_m, tag);
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;multiarg,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     // FIXME: Do I use li or some data member inside it?
+     leafFunctor(multiarg.a1_m, li, tag);
+     return 0;
+   }
  };
+ 
+ // HERE FIXME: Fix below.
  
  template&lt;class A1, class Tag&gt;
  struct LeafFunctor&lt;MultiArg1&lt;A1&gt;, EngineView&lt;Tag&gt; &gt;
Index: src/Evaluator/OpMask.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Evaluator/OpMask.h,v
retrieving revision 1.19
diff -c -p -r1.19 OpMask.h
*** src/Evaluator/OpMask.h	2001/03/20 23:42:48	1.19
--- src/Evaluator/OpMask.h	2001/11/05 19:28:26
*************** struct ForEach&lt; BinaryNode&lt;WhereMask, A,
*** 217,227 ****
    // The return type for the expression.
    typedef MaskAssign&lt;TypeB_t&gt; Type_t;
  
    // How to evaluate the expression.
!   inline
!   static Type_t
!   apply(const BinaryNode&lt;WhereMask,A,B&gt;&amp; expr, 
! 	const FTag &amp;f, const OpCombine &amp;c) 
    {
      // Evaluate the left.
      bool mask = forEach(expr.left(), f, c);
--- 217,231 ----
    // The return type for the expression.
    typedef MaskAssign&lt;TypeB_t&gt; Type_t;
  
+   // Other useful typedefs.
+   typedef BinaryNode&lt;WhereMask,A,B&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef OpCombine CTag;
+ 
    // How to evaluate the expression.
!   inline static
!   Type_t apply(const Subject_t&amp; expr, 
! 	       const FTag &amp;f, const CTag &amp;c) 
    {
      // Evaluate the left.
      bool mask = forEach(expr.left(), f, c);
*************** struct ForEach&lt; BinaryNode&lt;WhereMask, A,
*** 229,234 ****
--- 233,256 ----
      if ( mask )
      {
        return Type_t(mask, forEach(expr.right(), f, c));
+     }
+     else
+     {
+       return Type_t(mask);
+     }
+   }
+ 
+   inline static
+   Type_t apply(const Subject_t&amp; expr,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const FTag &amp;f, const CTag &amp;c) 
+   {
+     // Evaluate the left.
+     bool mask = forEach(expr.left(), li.left(), f, c);
+ 
+     if ( mask )
+     {
+       return Type_t(mask, forEach(expr.right(), li.right(), f, c));
      }
      else
      {
Index: src/Evaluator/ReductionEvaluator.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Evaluator/ReductionEvaluator.h,v
retrieving revision 1.5
diff -c -p -r1.5 ReductionEvaluator.h
*** src/Evaluator/ReductionEvaluator.h	2001/09/13 19:27:58	1.5
--- src/Evaluator/ReductionEvaluator.h	2001/11/05 19:28:26
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 124,134 ****
    {
      CTAssert(Domain::unitStride);
      PAssert(domain[0].first() == 0);
-     int e0 = domain[0].length();
  
!     ret = e.read(0);
      for (int i0 = 1; i0 &lt; e0; ++i0)
!       op(ret, e.read(i0));
    }
  
    template&lt;class T, class Op, class Expr, class Domain&gt;
--- 124,138 ----
    {
      CTAssert(Domain::unitStride);
      PAssert(domain[0].first() == 0);
  
!     // TMP typedef typename T::Engine_t::LoopInvariant_t TLoopInvariant_t;
!     typedef typename Expr::Engine_t::LoopInvariant_t ExprLoopInvariant_t;
!     // TMP const TLoopInvariant_t lli = ret.loopInvariant();
!     const ExprLoopInvariant_t rli = e.loopInvariant();
!     int e0 = domain[0].length();
!     ret = e.read(/* TMP lli, */ 0);
      for (int i0 = 1; i0 &lt; e0; ++i0)
!       op(ret, e.read(rli, i0));
    }
  
    template&lt;class T, class Op, class Expr, class Domain&gt;
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 138,150 ****
      CTAssert(Domain::unitStride);
      PAssert(domain[0].first() == 0);
      PAssert(domain[1].first() == 0);
      int e0 = domain[0].length();
      int e1 = domain[1].length();
  
      int i00;
      bool firstLoop = true;
!     
!     ret = e.read(0, 0);
      for (int i1 = 0; i1 &lt; e1; ++i1)
        {
          if (firstLoop)
--- 142,160 ----
      CTAssert(Domain::unitStride);
      PAssert(domain[0].first() == 0);
      PAssert(domain[1].first() == 0);
+     
+     // TMP typedef typename T::Engine_t::LoopInvariant_t TLoopInvariant_t;
+     typedef typename Expr::Engine_t::LoopInvariant_t ExprLoopInvariant_t;
+     // TMP const TLoopInvariant_t lli = ret.loopInvariant();
+     const ExprLoopInvariant_t rli = e.loopInvariant();
+ 
      int e0 = domain[0].length();
      int e1 = domain[1].length();
  
      int i00;
      bool firstLoop = true;
! 
!     ret = e.read(/* TMP lli, */ 0, 0);
      for (int i1 = 0; i1 &lt; e1; ++i1)
        {
          if (firstLoop)
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 155,161 ****
          else
            i00 = 0;
          for (int i0 = i00; i0 &lt; e0; ++i0)
!           op(ret, e.read(i0, i1));
        }
    }
    
--- 165,171 ----
          else
            i00 = 0;
          for (int i0 = i00; i0 &lt; e0; ++i0)
!           op(ret, e.read(rli, i0, i1));
        }
    }
    
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 167,172 ****
--- 177,188 ----
      PAssert(domain[0].first() == 0);
      PAssert(domain[1].first() == 0);
      PAssert(domain[2].first() == 0);
+ 
+     // TMP typedef typename T::Engine_t::LoopInvariant_t TLoopInvariant_t;
+     typedef typename Expr::Engine_t::LoopInvariant_t ExprLoopInvariant_t;
+     // TMP const TLoopInvariant_t lli = ret.loopInvariant();
+     const ExprLoopInvariant_t rli = e.loopInvariant();
+ 
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 174,180 ****
      int i00;
      bool firstLoop = true;
      
!     ret = e.read(0, 0, 0);
      for (int i2 = 0; i2 &lt; e2; ++i2)
        for (int i1 = 0; i1 &lt; e1; ++i1)
          {
--- 190,196 ----
      int i00;
      bool firstLoop = true;
      
!     ret = e.read(/* TMP lli, */ 0, 0, 0);
      for (int i2 = 0; i2 &lt; e2; ++i2)
        for (int i1 = 0; i1 &lt; e1; ++i1)
          {
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 186,192 ****
            else
              i00 = 0;
            for (int i0 = i00; i0 &lt; e0; ++i0)
!             op(ret, e.read(i0, i1, i2));
          }
    }
  
--- 202,208 ----
            else
              i00 = 0;
            for (int i0 = i00; i0 &lt; e0; ++i0)
!             op(ret, e.read(rli, i0, i1, i2));
          }
    }
  
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 199,204 ****
--- 215,226 ----
      PAssert(domain[1].first() == 0);
      PAssert(domain[2].first() == 0);
      PAssert(domain[3].first() == 0);
+ 
+     // TMP typedef typename T::Engine_t::LoopInvariant_t TLoopInvariant_t;
+     typedef typename Expr::Engine_t::LoopInvariant_t ExprLoopInvariant_t;
+     // TMP const TLoopInvariant_t lli = ret.loopInvariant();
+     const ExprLoopInvariant_t rli = e.loopInvariant();
+ 
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 207,213 ****
      int i00;
      bool firstLoop = true;
      
!     ret = e.read(0, 0, 0, 0);
      for (int i3 = 0; i3 &lt; e3; ++i3)
        for (int i2 = 0; i2 &lt; e2; ++i2)
          for (int i1 = 0; i1 &lt; e1; ++i1)
--- 229,235 ----
      int i00;
      bool firstLoop = true;
      
!     ret = e.read(/* TMP lli, */ 0, 0, 0, 0);
      for (int i3 = 0; i3 &lt; e3; ++i3)
        for (int i2 = 0; i2 &lt; e2; ++i2)
          for (int i1 = 0; i1 &lt; e1; ++i1)
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 220,226 ****
              else
                i00 = 0;
              for (int i0 = i00; i0 &lt; e0; ++i0)
!               op(ret, e.read(i0, i1, i2, i3));
            }
    }
  
--- 242,248 ----
              else
                i00 = 0;
              for (int i0 = i00; i0 &lt; e0; ++i0)
!               op(ret, e.read(rli, i0, i1, i2, i3));
            }
    }
  
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 234,239 ****
--- 256,267 ----
      PAssert(domain[2].first() == 0);
      PAssert(domain[3].first() == 0);
      PAssert(domain[4].first() == 0);
+ 
+     // TMP typedef typename T::Engine_t::LoopInvariant_t TLoopInvariant_t;
+     typedef typename Expr::Engine_t::LoopInvariant_t ExprLoopInvariant_t;
+     // TMP const TLoopInvariant_t lli = ret.loopInvariant();
+     const ExprLoopInvariant_t rli = e.loopInvariant();
+ 
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 243,249 ****
      int i00;
      bool firstLoop = true;
      
!     ret = e.read(0, 0, 0, 0, 0);
      for (int i4 = 0; i4 &lt; e4; ++i4)
        for (int i3 = 0; i3 &lt; e3; ++i3)
          for (int i2 = 0; i2 &lt; e2; ++i2)
--- 271,277 ----
      int i00;
      bool firstLoop = true;
      
!     ret = e.read(/* TMP lli, */ 0, 0, 0, 0, 0);
      for (int i4 = 0; i4 &lt; e4; ++i4)
        for (int i3 = 0; i3 &lt; e3; ++i3)
          for (int i2 = 0; i2 &lt; e2; ++i2)
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 257,263 ****
                else
                  i00 = 0;
                for (int i0 = i00; i0 &lt; e0; ++i0)
!                 op(ret, e.read(i0, i1, i2, i3, i4));
              }
    }
  
--- 285,291 ----
                else
                  i00 = 0;
                for (int i0 = i00; i0 &lt; e0; ++i0)
!                 op(ret, e.read(rli, i0, i1, i2, i3, i4));
              }
    }
  
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 272,277 ****
--- 300,311 ----
      PAssert(domain[3].first() == 0);
      PAssert(domain[4].first() == 0);
      PAssert(domain[5].first() == 0);
+ 
+     // TMP typedef typename T::Engine_t::LoopInvariant_t TLoopInvariant_t;
+     typedef typename Expr::Engine_t::LoopInvariant_t ExprLoopInvariant_t;
+     // TMP const TLoopInvariant_t lli = ret.loopInvariant();
+     const ExprLoopInvariant_t rli = e.loopInvariant();
+ 
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 282,288 ****
      int i00;
      bool firstLoop = true;
      
!     ret = e.read(0, 0, 0, 0, 0, 0);
      for (int i5 = 0; i5 &lt; e5; ++i5)
        for (int i4 = 0; i4 &lt; e4; ++i4)
          for (int i3 = 0; i3 &lt; e3; ++i3)
--- 316,322 ----
      int i00;
      bool firstLoop = true;
      
!     ret = e.read(/* TMP lli, */ 0, 0, 0, 0, 0, 0);
      for (int i5 = 0; i5 &lt; e5; ++i5)
        for (int i4 = 0; i4 &lt; e4; ++i4)
          for (int i3 = 0; i3 &lt; e3; ++i3)
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 297,303 ****
                  else
                    i00 = 0;
                  for (int i0 = i00; i0 &lt; e0; ++i0)
!                   op(ret, e.read(i0, i1, i2, i3, i4, i5));
                }
    }
  
--- 331,337 ----
                  else
                    i00 = 0;
                  for (int i0 = i00; i0 &lt; e0; ++i0)
!                   op(ret, e.read(rli, i0, i1, i2, i3, i4, i5));
                }
    }
  
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 313,318 ****
--- 347,358 ----
      PAssert(domain[4].first() == 0);
      PAssert(domain[5].first() == 0);
      PAssert(domain[6].first() == 0);
+ 
+     // TMP typedef typename T::Engine_t::LoopInvariant_t TLoopInvariant_t;
+     typedef typename Expr::Engine_t::LoopInvariant_t ExprLoopInvariant_t;
+     // TMP const TLoopInvariant_t lli = ret.loopInvariant();
+     const ExprLoopInvariant_t rli = e.loopInvariant();
+ 
      int e0 = domain[0].length();
      int e1 = domain[1].length();
      int e2 = domain[2].length();
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 324,330 ****
      int i00;
      bool firstLoop = true;
      
!     ret = e.read(0, 0, 0, 0, 0, 0, 0);
      for (int i6 = 0; i6 &lt; e6; ++i6)
        for (int i5 = 0; i5 &lt; e5; ++i5)
          for (int i4 = 0; i4 &lt; e4; ++i4)
--- 364,370 ----
      int i00;
      bool firstLoop = true;
      
!     ret = e.read(/* TMP lli, */ 0, 0, 0, 0, 0, 0, 0);
      for (int i6 = 0; i6 &lt; e6; ++i6)
        for (int i5 = 0; i5 &lt; e5; ++i5)
          for (int i4 = 0; i4 &lt; e4; ++i4)
*************** struct ReductionEvaluator&lt;InlineKernelTa
*** 340,346 ****
                    else
                      i00 = 0;
                    for (int i0 = i00; i0 &lt; e0; ++i0)
!                     op(ret, e.read(i0, i1, i2, i3, i4, i5, i6));
                  }
    }
  };
--- 380,386 ----
                    else
                      i00 = 0;
                    for (int i0 = i00; i0 &lt; e0; ++i0)
!                     op(ret, e.read(rli, i0, i1, i2, i3, i4, i5, i6));
                  }
    }
  };
Index: src/Evaluator/SimpleIntersector.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Evaluator/SimpleIntersector.h,v
retrieving revision 1.3
diff -c -p -r1.3 SimpleIntersector.h
*** src/Evaluator/SimpleIntersector.h	2001/10/15 17:34:30	1.3
--- src/Evaluator/SimpleIntersector.h	2001/11/05 19:28:26
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, MultiP
*** 274,283 ****
    ExpressionApply&lt;SimpleIntersector&lt;D2&gt; &gt; &gt;
  {
    typedef int Type_t;
! 
!   static Type_t
!   apply(const Engine&lt;Dim,T,MultiPatch&lt;LayoutTag,PatchTag&gt; &gt; &amp;engine,
! 	const ExpressionApply&lt;SimpleIntersector&lt;D2&gt; &gt; &amp;apply)
    {
      apply.tag().intersect(engine);
  
--- 274,286 ----
    ExpressionApply&lt;SimpleIntersector&lt;D2&gt; &gt; &gt;
  {
    typedef int Type_t;
!   typedef Engine&lt;Dim,T,MultiPatch&lt;LayoutTag,PatchTag&gt; &gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef ExpressionApply&lt;SimpleIntersector&lt;D2&gt; &gt; Tag_t;
! 
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;apply)
    {
      apply.tag().intersect(engine);
  
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, MultiP
*** 286,291 ****
--- 289,302 ----
  
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;apply)
+   {
+     return apply(engine, apply);
+   }
  };
  
  template &lt;int Dim, class T, class LT, class PatchTag, int BD, int D2&gt;
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, MultiP
*** 293,302 ****
    ExpressionApply&lt;SimpleIntersector&lt;D2&gt; &gt; &gt;
  {
    typedef int Type_t;
! 
!   static Type_t
!   apply(const Engine&lt;Dim,T,MultiPatchView&lt;LT,PatchTag,BD&gt; &gt; &amp;engine,
! 	const ExpressionApply&lt;SimpleIntersector&lt;D2&gt; &gt; &amp;apply)
    {
      apply.tag().intersect(engine);
  
--- 304,316 ----
    ExpressionApply&lt;SimpleIntersector&lt;D2&gt; &gt; &gt;
  {
    typedef int Type_t;
!   typedef Engine&lt;Dim,T,MultiPatchView&lt;LT,PatchTag,BD&gt; &gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef ExpressionApply&lt;SimpleIntersector&lt;D2&gt; &gt; Tag_t;
! 
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;apply)
    {
      apply.tag().intersect(engine);
  
*************** struct LeafFunctor&lt;Engine&lt;Dim, T, MultiP
*** 304,309 ****
--- 318,331 ----
        engine.fillGuards();
  
      return 0;
+   }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;apply)
+   {
+     return apply(engine, apply);
    }
  };
  
Index: src/Field/Field.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Field/Field.h,v
retrieving revision 1.75
diff -c -p -r1.75 Field.h
*** src/Field/Field.h	2001/10/06 00:39:19	1.75
--- src/Field/Field.h	2001/11/05 19:28:26
*************** struct View1Implementation&lt;Field&lt;Mesh, T
*** 342,347 ****
--- 342,364 ----
        return f.engine().read(s);
      }
  
+   template&lt;class S1, class S2, class Combine&gt;
+   inline static 
+   ReadType_t makeRead(const Subject_t &amp;f,
+ 		      const typename Subject_t::LoopInvariant_t&amp; li,
+ 	      const S1 &amp;s1, const S2 &amp;s2,
+ 	      const Combine &amp;)
+     {
+       PAssert(f.numSubFields() == 0);
+       
+       Domain s(Combine::make(f, s1, s2));
+ #if POOMA_BOUNDS_CHECK
+       PInsist(contains(f.totalDomain(), s),
+         &quot;Field view bounds error.&quot;);
+ #endif
+       return f.engine().read(li, s);
+     }
+ 
    template&lt;class S1, class S2, class S3,
      class Combine&gt;
    inline static 
*************** struct View1Implementation&lt;Field&lt;Mesh, T
*** 470,475 ****
--- 487,502 ----
        return make(f, s1, s2, c);
      }
  
+   template&lt;class S1, class S2, class Combine&gt;
+   inline static 
+   Type_t makeRead(const Subject_t &amp;f,
+ 		  const typename Subject_t::LoopInvariant_t&amp; li,
+ 		  const S1 &amp;s1, const S2 &amp;s2,
+ 		  const Combine &amp;c)
+     {
+       return make(f, li, s1, s2, c);
+     }
+ 
    template&lt;class S1, class S2, class S3,
      class Combine&gt;
    inline static 
*************** struct View2&lt;Field&lt;Mesh, T, EngineTag&gt;, 
*** 743,748 ****
--- 770,782 ----
      {
        return Dispatch_t::makeRead(f, s1, s2, Combine_t());
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;f, const typename Subject_t::LoopInvariant_t&amp; li,
+ 		      const Sub1 &amp;s1, const Sub2 &amp;s2)
+     {
+       return Dispatch_t::makeRead(f, li, s1, s2, Combine_t());
+     }
  };
  
  
*************** struct View2&lt;Field&lt;Mesh, T, EngineTag&gt;, 
*** 788,793 ****
--- 822,842 ----
  #endif
        return f.engine().read(s1, s2);
      }
+ 
+   inline static
+   ReadType_t makeRead(const Subject_t &amp;f,
+ 		      const typename Subject_t::LoopInvariant_t&amp; li,
+ 		      int s1, int s2)
+     {
+       PAssert(f.numSubFields() == 0);
+       
+ #if POOMA_BOUNDS_CHECK
+       PInsist(contains(f.totalDomain(), Loc&lt;2&gt;(s1, s2)),
+         &quot;Field view bounds error.&quot;);
+ #endif
+       return f.engine().read(li, s1, s2);
+     }
+ 
  };
  
  
*************** public:
*** 1117,1130 ****
    
    typedef typename Engine_t::Layout_t Layout_t;
    
!   // The types of the our domains. 
  
    typedef typename Engine_t::Domain_t Domain_t;
  
!   // The types of the our centering.
  
    typedef Centering&lt;dimensions&gt; Centering_t;
  
    //---------------------------------------------------------------------------
    // User-callable constructors. These ctors are meant to be called by users.
  
--- 1166,1184 ----
    
    typedef typename Engine_t::Layout_t Layout_t;
    
!   // The types of our domains. 
  
    typedef typename Engine_t::Domain_t Domain_t;
  
!   // The types of our centering.
  
    typedef Centering&lt;dimensions&gt; Centering_t;
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   typedef typename Engine_t::LoopInvariant_t LoopInvariant_t;
+ 
    //---------------------------------------------------------------------------
    // User-callable constructors. These ctors are meant to be called by users.
  
*************** public:
*** 1330,1335 ****
--- 1384,1394 ----
    {
      return fieldEngine_m.engine().layout();
    }
+ 
+   inline LoopInvariant_t loopInvariant() const
+   {
+     return fieldEngine_m.engine().loopInvariant();
+   }
          
    //---------------------------------------------------------------------------
    // Instruct the field to make its own copy of its data.
*************** public:
*** 1415,1420 ****
--- 1474,1488 ----
        return Ret_t::makeRead(*this, s1, s2);
      }
  
+   template&lt;class Sub1, class Sub2&gt; 
+   inline typename View2&lt;This_t, Sub1, Sub2&gt;::ReadType_t 
+   read(const typename This_t::LoopInvariant_t&amp; li,
+        const Sub1 &amp;s1, const Sub2 &amp;s2) const
+     {
+       typedef View2&lt;This_t, Sub1, Sub2&gt; Ret_t;
+       return Ret_t::makeRead(*this, li, s1, s2);
+     }
+ 
    template&lt;class Sub1, class Sub2, class Sub3&gt; 
    inline typename View3&lt;This_t, Sub1, Sub2, Sub3&gt;::ReadType_t 
    read(const Sub1 &amp;s1, const Sub2 &amp;s2, const Sub3 &amp;s3) const
*************** template&lt;class Mesh, class T, class Engi
*** 1702,1723 ****
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, ConformTag&lt;Dim&gt; &gt;
  {
    typedef bool Type_t;
!   static Type_t apply1(const Interval&lt;Dim&gt; &amp;d, 
!     const ConformTag&lt;Dim&gt; &amp;ct)
      {
        return conforms(d, ct);
      }
    template&lt;int Dim2&gt;
!   static Type_t apply1(const Interval&lt;Dim2&gt; &amp;d, 
!     const ConformTag&lt;Dim&gt; &amp;ct)
      {
        return false;
      }
!   static Type_t apply(const Field&lt;Mesh, T, EngineTag&gt; &amp;f,
!     const ConformTag&lt;Dim&gt; &amp;ct)
      {
        return apply1(f.physicalDomain(), ct);
      }
  };
  
  
--- 1770,1808 ----
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, ConformTag&lt;Dim&gt; &gt;
  {
    typedef bool Type_t;
!   typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef ConformTag&lt;Dim&gt; Tag_t;
! 
!   inline static
!   Type_t apply1(const Interval&lt;Dim&gt; &amp;d, 
! 		const Tag_t &amp;ct)
      {
        return conforms(d, ct);
      }
+ 
    template&lt;int Dim2&gt;
!   inline static
!   Type_t apply1(const Interval&lt;Dim2&gt; &amp;d, 
! 		const Tag_t &amp;ct)
      {
        return false;
      }
! 
!   inline static
!   Type_t apply(const Subject_t &amp;f,
! 	       const Tag_t &amp;ct)
      {
        return apply1(f.physicalDomain(), ct);
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;f,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;ct)
+     {
+       return apply(f, ct);
+     }
  };
  
  
*************** struct LeafFunctor&lt;Field&lt;Mesh, T, Engine
*** 1733,1766 ****
    DataObjectRequest&lt;RequestType&gt; &gt;
  {
    typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
    typedef typename Subject_t::FieldEngine_t FieldEngine_t;
!   typedef LeafFunctor&lt;FieldEngine_t, DataObjectRequest&lt;RequestType&gt; &gt; 
!     LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t Type_t;
    enum { dataObject = LeafFunctor_t::dataObject };
    
    inline static
    Type_t apply(const Subject_t &amp;f,
! 	           const DataObjectRequest&lt;RequestType&gt; &amp;functor)
      {
        return LeafFunctor_t::apply(field.fieldEngine(), functor);
      }
  };
  
  template&lt;class Mesh, class T, class EngineTag, class RequestType&gt;
  struct LeafFunctor&lt;FieldEngine&lt;Mesh, T, EngineTag&gt;,
    DataObjectRequest&lt;RequestType&gt; &gt;
  {
    typedef typename FieldEngine&lt;Mesh, T, EngineTag&gt;::Engine_t 
      Engine_t;
    enum { dataObject = Engine_t::dataObject };
!   typedef typename DataObjectRequest&lt;RequestType&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const FieldEngine&lt;Mesh, T, EngineTag&gt; &amp;f,
! 	           const DataObjectRequest&lt;RequestType&gt; &amp;functor)
      {
        return DataObjectApply&lt;dataObject&gt;::apply(f.engine(), functor);
      }
  };
  
  
--- 1818,1872 ----
    DataObjectRequest&lt;RequestType&gt; &gt;
  {
    typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DataObjectRequest&lt;RequestType&gt; Tag_t;
    typedef typename Subject_t::FieldEngine_t FieldEngine_t;
!   typedef LeafFunctor&lt;FieldEngine_t, Tag_t&gt; LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t Type_t;
    enum { dataObject = LeafFunctor_t::dataObject };
    
    inline static
    Type_t apply(const Subject_t &amp;f,
! 	       const Tag_t &amp;functor)
      {
        return LeafFunctor_t::apply(field.fieldEngine(), functor);
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;f,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;functor)
+     {
+       return LeafFunctor_t::apply(field.fieldEngine(), li, functor);
+     }
  };
  
  template&lt;class Mesh, class T, class EngineTag, class RequestType&gt;
  struct LeafFunctor&lt;FieldEngine&lt;Mesh, T, EngineTag&gt;,
    DataObjectRequest&lt;RequestType&gt; &gt;
  {
+   typedef FieldEngine&lt;Mesh, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DataObjectRequest&lt;RequestType&gt; Tag_t;
    typedef typename FieldEngine&lt;Mesh, T, EngineTag&gt;::Engine_t 
      Engine_t;
    enum { dataObject = Engine_t::dataObject };
!   typedef typename Tag_t::Type_t Type_t;
! 
    inline static
!   Type_t apply(const Subject_t &amp;f,
! 	       const Tag_t &amp;functor)
      {
        return DataObjectApply&lt;dataObject&gt;::apply(f.engine(), functor);
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;f,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;functor)
+     {
+       return DataObjectApply&lt;dataObject&gt;::apply(f.engine(), li, functor);
+     }
  };
  
  
*************** struct LeafFunctor&lt;FieldEngine&lt;Mesh, T, 
*** 1772,1818 ****
  template&lt;class Mesh, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, DomainFunctorTag&gt;
  {
!   typedef typename Field&lt;Mesh, T, EngineTag&gt;::Domain_t Type_t;
  
!   inline static Type_t apply(const Field&lt;Mesh, T, EngineTag&gt; &amp;f, 
!     const DomainFunctorTag &amp;)
      {
        // Return zero-based domain.
        
        return f.physicalDomain() - f.physicalDomain().firsts();
      }
  };
  
  
  //-----------------------------------------------------------------------------
! // This specialization of LeafFunctor is used to pass the ExpressionApply
! // functor
! // down into the FieldEngine. The default behavior, given in the functor
! // below, is to just pass it on to the fieldEngine's engine.
  //-----------------------------------------------------------------------------
  
  template&lt;class Mesh, class T, class EngineTag, class Tag&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
    typedef typename Subject_t::FieldEngine_t FieldEngine_t;
!   typedef LeafFunctor&lt;FieldEngine_t, ExpressionApply&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef int Type_t;
  
    inline static
    Type_t apply(const Subject_t &amp;field, 
! 	       const ExpressionApply&lt;Tag&gt; &amp;tag)
      {
        return LeafFunctor_t::apply(field.fieldEngine(), tag);
      }
  };
  
  template&lt;class Mesh, class T, class EngineTag, class Tag&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, EngineView&lt;Tag&gt; &gt;
  {
    typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
    typedef typename Subject_t::Engine_t Engine_t;
!   typedef typename LeafFunctor&lt;Engine_t, EngineView&lt;Tag&gt; &gt;::Type_t NewEngine_t;
    typedef typename NewEngine_t::Tag_t NewEngineTag_t;
  
    // Don't bother computing NewGeometry tag yet.
--- 1878,1948 ----
  template&lt;class Mesh, class T, class EngineTag&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, DomainFunctorTag&gt;
  {
!   typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef DomainFunctorTag Tag_t;
!   typedef typename Subject_t::Domain_t Type_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;f, 
! 	       const Tag_t &amp;)
      {
        // Return zero-based domain.
        
        return f.physicalDomain() - f.physicalDomain().firsts();
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;f, 
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;t)
+     {
+       return apply(f,t);
+     }
  };
  
  
  //-----------------------------------------------------------------------------
! // This specialization of LeafFunctor is used to pass the
! // ExpressionApply functor down into the FieldEngine. The default
! // behavior, given in the functor below, is to just pass it on to the
! // fieldEngine's engine.
  //-----------------------------------------------------------------------------
  
  template&lt;class Mesh, class T, class EngineTag, class Tag&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
    typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
    typedef typename Subject_t::FieldEngine_t FieldEngine_t;
!   typedef ExpressionApply&lt;Tag&gt; Tag_t;
!   typedef LeafFunctor&lt;FieldEngine_t, Tag_t&gt; LeafFunctor_t;
    typedef int Type_t;
  
    inline static
    Type_t apply(const Subject_t &amp;field, 
! 	       const Tag_t &amp;tag)
      {
        return LeafFunctor_t::apply(field.fieldEngine(), tag);
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;field, 
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+     {
+       return LeafFunctor_t::apply(field.fieldEngine(), li, tag);
+     }
  };
  
  template&lt;class Mesh, class T, class EngineTag, class Tag&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, EngineView&lt;Tag&gt; &gt;
  {
    typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
    typedef typename Subject_t::Engine_t Engine_t;
!   typedef EngineView&lt;Tag&gt; Tag_t;
!   typedef typename LeafFunctor&lt;Engine_t, Tag_t&gt;::Type_t NewEngine_t;
    typedef typename NewEngine_t::Tag_t NewEngineTag_t;
  
    // Don't bother computing NewGeometry tag yet.
*************** struct LeafFunctor&lt;Field&lt;Mesh, T, Engine
*** 1822,1831 ****
  
    inline static
    Type_t apply(const Subject_t &amp;field,
! 	       const EngineView&lt;Tag&gt; &amp;tag)
    {
      return Type_t(field, tag);
    }
  };
  
  
--- 1952,1969 ----
  
    inline static
    Type_t apply(const Subject_t &amp;field,
! 	       const Tag_t &amp;tag)
    {
      return Type_t(field, tag);
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;field,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return Type_t(field, li, tag);
+   }
  };
  
  
*************** struct LeafFunctor&lt;Field&lt;Mesh, T, Engine
*** 1836,1849 ****
  template&lt;class Mesh, class T, class EngineTag, class Tag&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, EngineFunctorTag&lt;Tag&gt; &gt;
  {
!   typedef typename Field&lt;Mesh,T,EngineTag&gt;::Engine_t Engine_t;
    typedef typename EngineFunctor&lt;Engine_t,Tag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const Field&lt;Mesh, T, EngineTag&gt; &amp;field,
! 	       const EngineFunctorTag&lt;Tag&gt; &amp;tag)
    {
      return EngineFunctor&lt;Engine_t,Tag&gt;::apply(field.engine(), tag.tag());
    }
  };
  
  
--- 1974,1999 ----
  template&lt;class Mesh, class T, class EngineTag, class Tag&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, EngineFunctorTag&lt;Tag&gt; &gt;
  {
!   typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef typename Subject_t::Engine_t Engine_t;
!   typedef EngineFunctorTag&lt;Tag&gt; Tag_t;
    typedef typename EngineFunctor&lt;Engine_t,Tag&gt;::Type_t Type_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;field,
! 	       const Tag_t &amp;tag)
    {
      return EngineFunctor&lt;Engine_t,Tag&gt;::apply(field.engine(), tag.tag());
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;field,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return EngineFunctor&lt;Engine_t,Tag&gt;::apply(field.engine(), li, tag.tag());
+   }
  };
  
  
*************** struct EngineFunctor&lt;Field&lt;Mesh, T, Engi
*** 1874,1886 ****
  template&lt;class Mesh, class T, class EngineTag, int Dim&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, EvalLeaf&lt;Dim&gt; &gt;
  {
    typedef typename Field&lt;Mesh, T, EngineTag&gt;::Element_t Type_t;
    inline static
!   Type_t apply(const Field&lt;Mesh, T, EngineTag&gt; &amp;f, 
!     const EvalLeaf&lt;Dim&gt; &amp;t) 
      {
        return t.eval(f.engine());
      }
  };
  
  
--- 2024,2048 ----
  template&lt;class Mesh, class T, class EngineTag, int Dim&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, EvalLeaf&lt;Dim&gt; &gt;
  {
+   typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef EvalLeaf&lt;Dim&gt; Tag_t;
    typedef typename Field&lt;Mesh, T, EngineTag&gt;::Element_t Type_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;f,
! 	       const Tag_t &amp;t) 
      {
        return t.eval(f.engine());
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;f,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;t) 
+     {
+       return t.eval(f.engine(), li);
+     }
  };
  
  
*************** template&lt;class Node&gt;
*** 1910,1921 ****
  struct LeafFunctor&lt;Node, PerformUpdateTag&gt;
  {
    typedef int Type_t;
  
    inline static
!   Type_t apply(const Node &amp;, const PerformUpdateTag &amp;)
!     {
!       return 0;
!     }
  };
  
  
--- 2072,2094 ----
  struct LeafFunctor&lt;Node, PerformUpdateTag&gt;
  {
    typedef int Type_t;
+   typedef Node Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef PerformUpdateTag Tag_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;, const Tag_t &amp;)
!   {
!     return 0;
!   }
! 
!   inline static
!   Type_t apply(const Subject_t &amp;s,
! 	       const LoopInvariant_t &amp;,
! 	       const Tag_t &amp;t)
!   {
!     return apply(s,t);
!   }
  };
  
  
*************** template&lt;class Mesh, class T, class Engi
*** 1923,1950 ****
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, 
    PerformUpdateTag&gt;
  {
-   typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
    typedef int Type_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;f, const PerformUpdateTag &amp;)
      {
        f.applyRelations();
        return 0;
      }
  };
  
  template&lt;class Mesh, class T, class Expr&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, ExpressionTag&lt;Expr&gt; &gt;, 
    PerformUpdateTag&gt;
  {
-   typedef Field&lt;Mesh, T, ExpressionTag&lt;Expr&gt; &gt; Subject_t;
    typedef int Type_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;f, const PerformUpdateTag &amp;tag)
      {
        forEach(f.engine().expression(), tag, NullCombine());
        return 0;
      }
  };
--- 2096,2144 ----
  struct LeafFunctor&lt;Field&lt;Mesh, T, EngineTag&gt;, 
    PerformUpdateTag&gt;
  {
    typedef int Type_t;
+   typedef Field&lt;Mesh, T, EngineTag&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef PerformUpdateTag Tag_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;f, const Tag_t &amp;)
      {
        f.applyRelations();
        return 0;
      }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;s,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;t)
+   {
+     return apply(s,t);
+   }
  };
  
  template&lt;class Mesh, class T, class Expr&gt;
  struct LeafFunctor&lt;Field&lt;Mesh, T, ExpressionTag&lt;Expr&gt; &gt;, 
    PerformUpdateTag&gt;
  {
    typedef int Type_t;
+   typedef Field&lt;Mesh, T, ExpressionTag&lt;Expr&gt; &gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef PerformUpdateTag Tag_t;
  
    inline static
!   Type_t apply(const Subject_t &amp;f, const Tag_t &amp;tag)
      {
        forEach(f.engine().expression(), tag, NullCombine());
+       return 0;
+     }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;f,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+     {
+       forEach(f.engine().expression(), li, tag, NullCombine());
        return 0;
      }
  };
Index: src/PETE/ForEach.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/PETE/ForEach.h,v
retrieving revision 1.25
diff -c -p -r1.25 ForEach.h
*** src/PETE/ForEach.h	2000/12/04 21:19:37	1.25
--- src/PETE/ForEach.h	2001/11/05 19:28:26
*************** template&lt;class Expr, class FTag, class C
*** 75,85 ****
--- 75,95 ----
  struct ForEach
  {
    typedef typename LeafFunctor&lt;Expr, FTag&gt;::Type_t Type_t;
+   typedef typename Expr::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
    Type_t apply(const Expr &amp;expr, const FTag &amp;f, const CTag &amp;)
    {
      return LeafFunctor&lt;Expr, FTag&gt;::apply(expr, f);
    }
+ 
+   inline static
+   Type_t apply(const Expr &amp;expr,
+ 	       const typename Expr::LoopInvariant_t &amp;li,
+ 	       const FTag &amp;f, const CTag &amp;)
+   {
+     return LeafFunctor&lt;Expr, FTag&gt;::apply(expr, li, f);
+   }
  };
  
  template&lt;class Expr, class FTag, class CTag&gt;
*************** forEach(const Expr &amp;e, const FTag &amp;f, co
*** 89,106 ****
    return ForEach&lt;Expr, FTag, CTag&gt;::apply(e, f, c);
  }
  
  template&lt;class Op, class A, class FTag, class CTag&gt;
  struct ForEach&lt;UnaryNode&lt;Op, A&gt;, FTag, CTag&gt;
  {
    typedef typename ForEach&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
    typedef typename Combine1&lt;TypeA_t, Op, CTag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const UnaryNode&lt;Op, A&gt; &amp;expr, const FTag &amp;f, 
!     const CTag &amp;c) 
    {
      return Combine1&lt;TypeA_t, Op, CTag&gt;::
        combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.child(), f, c), c);
    }
  };
  
  template&lt;class Op, class A, class B, class FTag, class CTag&gt;
--- 99,136 ----
    return ForEach&lt;Expr, FTag, CTag&gt;::apply(e, f, c);
  }
  
+ template&lt;class Expr, class FTag, class CTag&gt;
+ inline typename ForEach&lt;Expr,FTag,CTag&gt;::Type_t
+ forEach(const Expr &amp;e, const typename Expr::LoopInvariant_t &amp;li,
+ 	const FTag &amp;f, const CTag &amp;c)
+ {
+   return ForEach&lt;Expr, FTag, CTag&gt;::apply(e, li, f, c);
+ }
+ 
  template&lt;class Op, class A, class FTag, class CTag&gt;
  struct ForEach&lt;UnaryNode&lt;Op, A&gt;, FTag, CTag&gt;
  {
    typedef typename ForEach&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
    typedef typename Combine1&lt;TypeA_t, Op, CTag&gt;::Type_t Type_t;
+   typedef UnaryNode&lt;Op, A&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;expr, const FTag &amp;f, 
! 	       const CTag &amp;c) 
    {
      return Combine1&lt;TypeA_t, Op, CTag&gt;::
        combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.child(), f, c), c);
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;expr,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const FTag &amp;f, const CTag &amp;c) 
+   {
+     return Combine1&lt;TypeA_t, Op, CTag&gt;::
+       combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.child(), li.child(), f, c), c);
+   }
  };
  
  template&lt;class Op, class A, class B, class FTag, class CTag&gt;
*************** struct ForEach&lt;BinaryNode&lt;Op, A, B&gt;, FTa
*** 109,123 ****
    typedef typename ForEach&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
    typedef typename ForEach&lt;B, FTag, CTag&gt;::Type_t TypeB_t;
    typedef typename Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const BinaryNode&lt;Op, A, B&gt; &amp;expr, const FTag &amp;f,
! 	       const CTag &amp;c) 
    {
      return Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::
        combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.left(), f, c),
                ForEach&lt;B, FTag, CTag&gt;::apply(expr.right(), f, c),
  	      c);
    }
  };
  
  template&lt;class Op, class A, class B, class C, class FTag, class CTag&gt;
--- 139,167 ----
    typedef typename ForEach&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
    typedef typename ForEach&lt;B, FTag, CTag&gt;::Type_t TypeB_t;
    typedef typename Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::Type_t Type_t;
+   typedef BinaryNode&lt;Op, A, B&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;expr,
! 	       const FTag &amp;f, const CTag &amp;c) 
    {
      return Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::
        combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.left(), f, c),
                ForEach&lt;B, FTag, CTag&gt;::apply(expr.right(), f, c),
  	      c);
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;expr,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const FTag &amp;f, const CTag &amp;c) 
+   {
+     return Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::
+       combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.left(), li.left(), f, c),
+               ForEach&lt;B, FTag, CTag&gt;::apply(expr.right(), li.right(), f, c),
+ 	      c);
+   }
  };
  
  template&lt;class Op, class A, class B, class C, class FTag, class CTag&gt;
*************** struct ForEach&lt;TrinaryNode&lt;Op, A, B, C&gt;,
*** 128,136 ****
    typedef typename ForEach&lt;C, FTag, CTag&gt;::Type_t TypeC_t;
    typedef typename Combine3&lt;TypeA_t, TypeB_t, TypeC_t, Op, CTag&gt;::Type_t 
      Type_t;
    inline static
!   Type_t apply(const TrinaryNode&lt;Op, A, B, C&gt; &amp;expr, const FTag &amp;f,
! 	       const CTag &amp;c) 
    {
      return Combine3&lt;TypeA_t, TypeB_t, TypeC_t, Op, CTag&gt;::
        combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.left(), f, c),
--- 172,183 ----
    typedef typename ForEach&lt;C, FTag, CTag&gt;::Type_t TypeC_t;
    typedef typename Combine3&lt;TypeA_t, TypeB_t, TypeC_t, Op, CTag&gt;::Type_t 
      Type_t;
+   typedef TrinaryNode&lt;Op, A, B, C&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   Type_t apply(const Subject_t&amp;expr,
! 	       const FTag &amp;f, const CTag &amp;c) 
    {
      return Combine3&lt;TypeA_t, TypeB_t, TypeC_t, Op, CTag&gt;::
        combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.left(), f, c),
*************** struct ForEach&lt;TrinaryNode&lt;Op, A, B, C&gt;,
*** 138,143 ****
--- 185,202 ----
  	      ForEach&lt;C, FTag, CTag&gt;::apply(expr.right(), f, c),
  	      c);
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;expr,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const FTag &amp;f, const CTag &amp;c) 
+   {
+     return Combine3&lt;TypeA_t, TypeB_t, TypeC_t, Op, CTag&gt;::
+       combine(ForEach&lt;A, FTag, CTag&gt;::apply(expr.left(), li.left(), f, c),
+ 	      ForEach&lt;B, FTag, CTag&gt;::apply(expr.middle(), li.middle(), f, c),
+ 	      ForEach&lt;C, FTag, CTag&gt;::apply(expr.right(), li.right(), f, c),
+ 	      c);
+   }
  };
  
  #ifndef PETE_USER_DEFINED_EXPRESSION
*************** template&lt;class T, class FTag, class CTag
*** 148,159 ****
  struct ForEach&lt;Expression&lt;T&gt;, FTag, CTag&gt;
  {
    typedef typename ForEach&lt;T, FTag, CTag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const Expression&lt;T&gt; &amp;expr, const FTag &amp;f, 
! 	       const CTag &amp;c) 
    {
      return ForEach&lt;T, FTag, CTag&gt;::apply(expr.expression(), f, c);
    }
  };
  
  #endif // !PETE_USER_DEFINED_EXPRESSION
--- 207,229 ----
  struct ForEach&lt;Expression&lt;T&gt;, FTag, CTag&gt;
  {
    typedef typename ForEach&lt;T, FTag, CTag&gt;::Type_t Type_t;
+   typedef Expression&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;expr,
! 	       const FTag &amp;f, const CTag &amp;c) 
    {
      return ForEach&lt;T, FTag, CTag&gt;::apply(expr.expression(), f, c);
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;expr,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const FTag &amp;f, const CTag &amp;c) 
+   {
+     return ForEach&lt;T, FTag, CTag&gt;::apply(expr.expression(), li, f, c);
+   }
  };
  
  #endif // !PETE_USER_DEFINED_EXPRESSION
*************** template&lt;class T, class FTag, class CTag
*** 164,174 ****
  struct ForEach&lt;Reference&lt;T&gt;, FTag, CTag&gt;
  {
    typedef typename ForEach&lt;T, FTag, CTag&gt;::Type_t Type_t;
    inline static
!   Type_t apply(const Reference&lt;T&gt; &amp;ref, const FTag &amp;f, 
! 	       const CTag &amp;c) 
    {
      return ForEach&lt;T, FTag, CTag&gt;::apply(ref.reference(), f, c);
    }
  };
  
--- 234,255 ----
  struct ForEach&lt;Reference&lt;T&gt;, FTag, CTag&gt;
  {
    typedef typename ForEach&lt;T, FTag, CTag&gt;::Type_t Type_t;
+   typedef Reference&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;ref,
! 	       const FTag &amp;f, const CTag &amp;c) 
    {
      return ForEach&lt;T, FTag, CTag&gt;::apply(ref.reference(), f, c);
+   }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;ref,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const FTag &amp;f, const CTag &amp;c) 
+   {
+     return ForEach&lt;T, FTag, CTag&gt;::apply(ref.reference(), li, f, c);
    }
  };
  
Index: src/PETE/Functors.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/PETE/Functors.h,v
retrieving revision 1.8
diff -c -p -r1.8 Functors.h
*** src/PETE/Functors.h	2001/04/10 23:13:25	1.8
--- src/PETE/Functors.h	2001/11/05 19:28:26
*************** leafFunctor(const LeafType &amp;leaf, const 
*** 82,87 ****
--- 82,97 ----
    return LeafFunctor&lt;LeafType, LeafTag&gt;::apply(leaf, tag);
  }
  
+ template&lt;class LeafType, class LeafTag&gt;
+ inline
+ typename LeafFunctor&lt;LeafType, LeafTag&gt;::Type_t
+ leafFunctor(const LeafType &amp;leaf,
+ 	    const typename LeafType::LoopInvariant_t &amp;li,
+ 	    const LeafTag &amp;tag)
+ {
+   return LeafFunctor&lt;LeafType, LeafTag&gt;::apply(leaf, li, tag);
+ }
+ 
  //-----------------------------------------------------------------------------
  //
  // CLASS NAMES
*************** template&lt;class T&gt;
*** 107,117 ****
--- 117,136 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf1&gt;
  {
    typedef T Type_t;
+   typedef typename Scalar&lt;T&gt;::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
    const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const EvalLeaf1 &amp;) 
    {
      return s.value();
    }
+ 
+   inline static
+   const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const LoopInvariant_t &amp;li,
+ 		      const EvalLeaf1 &amp;) 
+   {
+     return s.value(li);
+   }
  };
  
  // 2D
*************** template&lt;class T&gt;
*** 128,138 ****
--- 147,166 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf2&gt;
  {
    typedef T Type_t;
+   typedef typename Scalar&lt;T&gt;::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
    const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const EvalLeaf2 &amp;) 
    {
      return s.value();
    }
+ 
+   inline static
+   const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const LoopInvariant_t &amp;li,
+ 		      const EvalLeaf2 &amp;) 
+   {
+     return s.value(li);
+   }
  };
  
  // 3D
*************** template&lt;class T&gt;
*** 151,161 ****
--- 179,198 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf3&gt;
  {
    typedef T Type_t;
+   typedef typename Scalar&lt;T&gt;::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
    const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const EvalLeaf3 &amp;) 
    {
      return s.value();
    }
+ 
+   inline static
+   const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const LoopInvariant_t &amp;li,
+ 		      const EvalLeaf3 &amp;) 
+   {
+     return s.value(li);
+   }
  };
  
  // 4D
*************** template&lt;class T&gt;
*** 175,185 ****
--- 212,231 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf4&gt;
  {
    typedef T Type_t;
+   typedef typename Scalar&lt;T&gt;::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
    const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const EvalLeaf4 &amp;) 
    {
      return s.value();
    }
+ 
+   inline static
+   const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const LoopInvariant_t &amp;li,
+ 		      const EvalLeaf4 &amp;) 
+   {
+     return s.value(li);
+   }
  };
  
  // 5D
*************** template&lt;class T&gt;
*** 200,210 ****
--- 246,265 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf5&gt;
  {
    typedef T Type_t;
+   typedef typename Scalar&lt;T&gt;::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
    const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const EvalLeaf5 &amp;)
    {
      return s.value();
    }
+ 
+   inline static
+   const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const LoopInvariant_t &amp;li,
+ 		      const EvalLeaf5 &amp;)
+   {
+     return s.value(li);
+   }
  };
  
  // 6D
*************** template&lt;class T&gt;
*** 226,236 ****
--- 281,300 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf6&gt;
  {
    typedef T Type_t;
+   typedef typename Scalar&lt;T&gt;::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
    const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const EvalLeaf6 &amp;) 
    {
      return s.value();
    }
+ 
+   inline static
+   const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const LoopInvariant_t &amp;li,
+ 		      const EvalLeaf6 &amp;) 
+   {
+     return s.value(li);
+   }
  };
  
  // 7D
*************** template&lt;class T&gt;
*** 254,264 ****
--- 318,337 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, EvalLeaf7&gt;
  {
    typedef T Type_t;
+   typedef typename Scalar&lt;T&gt;::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
    const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const EvalLeaf7 &amp;) 
    {
      return s.value();
    }
+ 
+   inline static
+   const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const LoopInvariant_t &amp;li,
+ 		      const EvalLeaf7 &amp;) 
+   {
+     return s.value(li);
+   }
  };
  
  
*************** template&lt;class T&gt;
*** 280,292 ****
  struct LeafFunctor&lt;T, IncrementLeaf&gt;
  {
    typedef int Type_t;
    inline static
!   Type_t apply(const T &amp;cl, const IncrementLeaf &amp;) 
    {
      T &amp;l = const_cast&lt;T &amp;&gt;(cl);
      ++l;
      return 0;
    }
  };
  
  #if defined(__MWERKS__)
--- 353,377 ----
  struct LeafFunctor&lt;T, IncrementLeaf&gt;
  {
    typedef int Type_t;
+   typedef T Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef IncrementLeaf Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;cl, const Tag_t &amp;) 
    {
      T &amp;l = const_cast&lt;T &amp;&gt;(cl);
      ++l;
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;cl,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;lf) 
+   {
+     return apply(cl, lf);
+   }
  };
  
  #if defined(__MWERKS__)
*************** template &lt;class T&gt;
*** 297,309 ****
  struct LeafFunctor&lt;const T*, IncrementLeaf&gt; 
  {
    typedef int Type_t;
    inline static
!   Type_t apply(const T* &amp; const ci, const IncrementLeaf &amp;)
    {
      T* &amp;i = const_cast&lt;T* &amp;&gt;(ci);
      ++i;
      return 0;
    }
  };
  
  #endif
--- 382,406 ----
  struct LeafFunctor&lt;const T*, IncrementLeaf&gt; 
  {
    typedef int Type_t;
+   typedef T Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef IncrementLeaf Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t* &amp; const ci, const Tag_t &amp;)
    {
      T* &amp;i = const_cast&lt;T* &amp;&gt;(ci);
      ++i;
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t* &amp; const ci,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;lf)
+   {
+     return apply(ci, lf);
+   }
  };
  
  #endif
*************** template&lt;class T&gt;
*** 312,322 ****
  struct LeafFunctor&lt;Scalar&lt;T&gt;, IncrementLeaf&gt;
  {
    typedef int Type_t;
    inline static
!   Type_t apply(const Scalar&lt;T&gt; &amp;, const IncrementLeaf &amp;) 
    {
      return 0;
    }
  };
  
  
--- 409,431 ----
  struct LeafFunctor&lt;Scalar&lt;T&gt;, IncrementLeaf&gt;
  {
    typedef int Type_t;
+   typedef Scalar&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef IncrementLeaf Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;, const Tag_t &amp;) 
    {
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;s,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;lf) 
+   {
+     return apply(s, lf);
+   }
  };
  
  
*************** template&lt;class T&gt;
*** 338,350 ****
  struct LeafFunctor&lt;T, DecrementLeaf&gt;
  {
    typedef int Type_t;
    inline static
!   Type_t apply(const T &amp;cl, const DecrementLeaf &amp;) 
    {
      T &amp;l = const_cast&lt;T &amp;&gt;(cl);
      --l;
      return 0;
    }
  };
  
  #if defined(__MWERKS__)
--- 447,471 ----
  struct LeafFunctor&lt;T, DecrementLeaf&gt;
  {
    typedef int Type_t;
+   typedef T Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DecrementLeaf Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;cl, const Tag_t &amp;)
    {
      T &amp;l = const_cast&lt;T &amp;&gt;(cl);
      --l;
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;cl,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;lf)
+   {
+     return apply(cl, lf);
+   }
  };
  
  #if defined(__MWERKS__)
*************** template &lt;class T&gt;
*** 353,377 ****
  struct LeafFunctor&lt;const T*, DecrementLeaf&gt; 
  {
    typedef int Type_t;
    inline static
!   Type_t apply(const T* &amp; const ci, const IncrementLeaf &amp;)
    {
      T* &amp;i = const_cast&lt;T* &amp;&gt;(ci);
      --i;
      return 0;
    }
  };
  #endif
    
  template&lt;class T&gt;
  struct LeafFunctor&lt;Scalar&lt;T&gt;, DecrementLeaf&gt;
  {
    typedef int Type_t;
    inline static
!   Type_t apply(const Scalar&lt;T&gt; &amp;, const DecrementLeaf &amp;) 
    {
      return 0;
    }
  };
  
  //-----------------------------------------------------------------------------
--- 474,524 ----
  struct LeafFunctor&lt;const T*, DecrementLeaf&gt; 
  {
    typedef int Type_t;
+   typedef T Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DecrementLeaf Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t* &amp; const ci,
! 	       const Tag_t &amp;)
    {
      T* &amp;i = const_cast&lt;T* &amp;&gt;(ci);
      --i;
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t* &amp;i,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;lf)
+   {
+     return apply(i, lf);
+   }
  };
+ 
  #endif
    
  template&lt;class T&gt;
  struct LeafFunctor&lt;Scalar&lt;T&gt;, DecrementLeaf&gt;
  {
    typedef int Type_t;
+   typedef Scalar&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DecrementLeaf Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;, const Tag_t &amp;) 
    {
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;s,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;lf) 
+   {
+     return apply(s, lf);
+   }
  };
  
  //-----------------------------------------------------------------------------
*************** template&lt;class ForwardIterator&gt;
*** 392,402 ****
  struct LeafFunctor&lt;ForwardIterator, DereferenceLeaf&gt;
  {
    typedef typename std::iterator_traits&lt;ForwardIterator&gt;::value_type Type_t;
    inline static
!   Type_t apply(const ForwardIterator &amp;i, const DereferenceLeaf &amp;)
    {
      return *i;
    }
  };
  
  #if defined(__MWERKS__)
--- 539,561 ----
  struct LeafFunctor&lt;ForwardIterator, DereferenceLeaf&gt;
  {
    typedef typename std::iterator_traits&lt;ForwardIterator&gt;::value_type Type_t;
+   typedef ForwardIterator Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DereferenceLeaf Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t &amp;i, const Tag_t &amp;)
    {
      return *i;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;i,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;lf)
+   {
+     return apply(i, lf);
+   }
  };
  
  #if defined(__MWERKS__)
*************** template &lt;class T&gt;
*** 405,429 ****
  struct LeafFunctor&lt;const T*, DereferenceLeaf&gt; 
  {
    typedef T Type_t;
    inline static
!   Type_t apply(const T *i, const DereferenceLeaf &amp;)
    {
      return *i;
    }
  };
  #endif
    
  template&lt;class T&gt;
  struct LeafFunctor&lt;Scalar&lt;T&gt;, DereferenceLeaf&gt;
  {
    typedef T Type_t;
    inline static
!   const Type_t &amp;apply(const Scalar&lt;T&gt; &amp;s, const DereferenceLeaf &amp;) 
    {
      return s.value();
    }
- };
  
  
  #endif // PETE_PETE_FUNCTORS_H
  
--- 564,612 ----
  struct LeafFunctor&lt;const T*, DereferenceLeaf&gt; 
  {
    typedef T Type_t;
+   typedef T Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DereferenceLeaf Tag_t;
+ 
    inline static
!   Type_t apply(const Subject_t *i, const Tag_t &amp;)
    {
      return *i;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t *i,
+ 	       const LoopInvariant_t &amp;,
+ 	       const Tag_t &amp;lf)
+   {
+     return apply(i, lf);
+   }
  };
+ 
  #endif
    
  template&lt;class T&gt;
  struct LeafFunctor&lt;Scalar&lt;T&gt;, DereferenceLeaf&gt;
  {
    typedef T Type_t;
+   typedef Scalar&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+   typedef DereferenceLeaf Tag_t;
+ 
    inline static
!   const Type_t &amp;apply(const Subject_t &amp;s, const Tag_t &amp;) 
    {
      return s.value();
    }
  
+   inline static
+   const Type_t &amp;apply(const Subject_t &amp;s,
+ 		      const LoopInvariant_t &amp;li,
+ 		      const Tag_t &amp;) 
+   {
+     return s.value(li);
+   }
+ };
  
  #endif // PETE_PETE_FUNCTORS_H
  
Index: src/PETE/PoomaPETE.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/PETE/PoomaPETE.h,v
retrieving revision 1.3
diff -c -p -r1.3 PoomaPETE.h
*** src/PETE/PoomaPETE.h	2001/10/15 17:34:31	1.3
--- src/PETE/PoomaPETE.h	2001/11/05 19:28:26
*************** template&lt;class Expr, class FTag, class C
*** 67,77 ****
--- 67,86 ----
  struct ForEachRef
  {
    typedef typename LeafFunctor&lt;Expr, FTag&gt;::Type_t Type_t;
+   typedef typename Expr::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
    const Type_t &amp;apply(const Expr &amp;expr, const FTag &amp;f, const CTag &amp;)
      {
        return LeafFunctor&lt;Expr, FTag&gt;::apply(expr, f);
      }
+ 
+   inline static
+   const Type_t &amp;apply(const Expr &amp;expr, const LoopInvariant_t &amp;li,
+ 		      const FTag &amp;f, const CTag &amp;)
+     {
+       return LeafFunctor&lt;Expr, FTag&gt;::apply(expr, li, f);
+     }
  };
  
  template&lt;class Expr, class FTag, class CTag&gt;
*************** forEachRef(const Expr &amp;e, const FTag &amp;f,
*** 81,99 ****
    return ForEachRef&lt;Expr, FTag, CTag&gt;::apply(e, f, c);
  }
  
  template&lt;class Op, class A, class FTag, class CTag&gt;
  struct ForEachRef&lt;UnaryNode&lt;Op, A&gt;, FTag, CTag&gt;
  {
    typedef typename ForEachRef&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
    typedef typename Combine1&lt;TypeA_t, Op, CTag&gt;::Type_t Type_t;
    inline static
!   const Type_t &amp;apply(const UnaryNode&lt;Op, A&gt; &amp;expr, const FTag &amp;f, 
!     const CTag &amp;c) 
      {
        return Combine1&lt;TypeA_t, Op, CTag&gt;::
          combine(ForEachRef&lt;A, FTag, CTag&gt;::apply(expr.child(), f, c),
                  c);
      }
  };
  
  template&lt;class Op, class A, class B, class FTag, class CTag&gt;
--- 90,129 ----
    return ForEachRef&lt;Expr, FTag, CTag&gt;::apply(e, f, c);
  }
  
+ template&lt;class Expr, class FTag, class CTag&gt;
+ inline const typename ForEachRef&lt;Expr,FTag,CTag&gt;::Type_t &amp;
+ forEachRef(const Expr &amp;e, const typename Expr::LoopInvariant_t &amp;li,
+ 	   const FTag &amp;f, const CTag &amp;c)
+ {
+   return ForEachRef&lt;Expr, FTag, CTag&gt;::apply(e, li, f, c);
+ }
+ 
  template&lt;class Op, class A, class FTag, class CTag&gt;
  struct ForEachRef&lt;UnaryNode&lt;Op, A&gt;, FTag, CTag&gt;
  {
    typedef typename ForEachRef&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
    typedef typename Combine1&lt;TypeA_t, Op, CTag&gt;::Type_t Type_t;
+   typedef UnaryNode&lt;Op, A&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   const Type_t &amp;apply(const Subject_t &amp;expr,
! 		      const FTag &amp;f, const CTag &amp;c) 
      {
        return Combine1&lt;TypeA_t, Op, CTag&gt;::
          combine(ForEachRef&lt;A, FTag, CTag&gt;::apply(expr.child(), f, c),
                  c);
      }
+ 
+   inline static
+   const Type_t &amp;apply(const Subject_t &amp;expr,
+ 		      const LoopInvariant_t &amp;li,
+ 		      const FTag &amp;f, const CTag &amp;c) 
+     {
+       return Combine1&lt;TypeA_t, Op, CTag&gt;::
+         combine(ForEachRef&lt;A, FTag, CTag&gt;::apply(expr.child(), li.child(), f, c),
+                 c);
+     }
  };
  
  template&lt;class Op, class A, class B, class FTag, class CTag&gt;
*************** struct ForEachRef&lt;BinaryNode&lt;Op, A, B&gt;, 
*** 102,116 ****
    typedef typename ForEachRef&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
    typedef typename ForEachRef&lt;B, FTag, CTag&gt;::Type_t TypeB_t;
    typedef typename Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::Type_t Type_t;
    inline static
!   const Type_t &amp;apply(const BinaryNode&lt;Op, A, B&gt; &amp;expr, const FTag &amp;f,
! 	                  const CTag &amp;c) 
      {
        return Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::
          combine(ForEachRef&lt;A, FTag, CTag&gt;::apply(expr.left(), f, c),
                  ForEachRef&lt;B, FTag, CTag&gt;::apply(expr.right(), f, c),
  	        c);
      }
  };
  
  template&lt;class Op, class A, class B, class C, class FTag, class CTag&gt;
--- 132,159 ----
    typedef typename ForEachRef&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
    typedef typename ForEachRef&lt;B, FTag, CTag&gt;::Type_t TypeB_t;
    typedef typename Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::Type_t Type_t;
+   typedef BinaryNode&lt;Op, A, B&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   const Type_t &amp;apply(const Subject_t &amp;expr,
! 		      const FTag &amp;f, const CTag &amp;c) 
      {
        return Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::
          combine(ForEachRef&lt;A, FTag, CTag&gt;::apply(expr.left(), f, c),
                  ForEachRef&lt;B, FTag, CTag&gt;::apply(expr.right(), f, c),
  	        c);
      }
+ 
+   const Type_t &amp;apply(const Subject_t &amp;expr,
+ 		      const LoopInvariant_t &amp;li,
+ 		      const FTag &amp;f, const CTag &amp;c) 
+     {
+       return Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::
+         combine(ForEachRef&lt;A, FTag, CTag&gt;::apply(expr.left(), li.left(), f, c),
+                 ForEachRef&lt;B, FTag, CTag&gt;::apply(expr.right(), li.right(), f, c),
+ 	        c);
+     }
  };
  
  template&lt;class Op, class A, class B, class C, class FTag, class CTag&gt;
*************** struct ForEachRef&lt;TrinaryNode&lt;Op, A, B, 
*** 121,129 ****
    typedef typename ForEachRef&lt;C, FTag, CTag&gt;::Type_t TypeC_t;
    typedef typename Combine3&lt;TypeA_t, TypeB_t, TypeC_t, Op, CTag&gt;::Type_t 
      Type_t;
    inline static
!   const Type_t &amp;apply(const TrinaryNode&lt;Op, A, B, C&gt; &amp;expr, const FTag &amp;f,
! 	                  const CTag &amp;c) 
      {
        return Combine3&lt;TypeA_t, TypeB_t, TypeC_t, Op, CTag&gt;::
          combine(ForEachRef&lt;A, FTag, CTag&gt;::apply(expr.left(), f, c),
--- 164,175 ----
    typedef typename ForEachRef&lt;C, FTag, CTag&gt;::Type_t TypeC_t;
    typedef typename Combine3&lt;TypeA_t, TypeB_t, TypeC_t, Op, CTag&gt;::Type_t 
      Type_t;
+   typedef TrinaryNode&lt;Op, A, B, C&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   const Type_t &amp;apply(const Subject_t &amp;expr,
! 		      const FTag &amp;f, const CTag &amp;c) 
      {
        return Combine3&lt;TypeA_t, TypeB_t, TypeC_t, Op, CTag&gt;::
          combine(ForEachRef&lt;A, FTag, CTag&gt;::apply(expr.left(), f, c),
*************** struct ForEachRef&lt;TrinaryNode&lt;Op, A, B, 
*** 131,159 ****
  	        ForEachRef&lt;C, FTag, CTag&gt;::apply(expr.right(), f, c),
  	        c);
      }
  };
  
  template&lt;class T, class FTag, class CTag&gt;
  struct ForEachRef&lt;Expression&lt;T&gt;, FTag, CTag&gt;
  {
    typedef typename ForEachRef&lt;T, FTag, CTag&gt;::Type_t Type_t;
    inline static
!   const Type_t &amp;apply(const Expression&lt;T&gt; &amp;expr, const FTag &amp;f, 
! 	                  const CTag &amp;c) 
      {
        return ForEachRef&lt;T, FTag, CTag&gt;::apply(expr.expression(), f, c);
      }
  };
  
  template&lt;class T, class FTag, class CTag&gt;
  struct ForEachRef&lt;Reference&lt;T&gt;, FTag, CTag&gt;
  {
    typedef typename ForEachRef&lt;T, FTag, CTag&gt;::Type_t Type_t;
    inline static
!   const Type_t &amp;apply(const Reference&lt;T&gt; &amp;ref, const FTag &amp;f, 
! 	                  const CTag &amp;c) 
      {
        return ForEachRef&lt;T, FTag, CTag&gt;::apply(ref.reference(), f, c);
      }
  };
  
--- 177,239 ----
  	        ForEachRef&lt;C, FTag, CTag&gt;::apply(expr.right(), f, c),
  	        c);
      }
+ 
+   inline static
+   const Type_t &amp;apply(const Subject_t &amp;expr,
+ 		      const LoopInvariant_t &amp;li,
+ 		      const FTag &amp;f, const CTag &amp;c) 
+     {
+       return Combine3&lt;TypeA_t, TypeB_t, TypeC_t, Op, CTag&gt;::
+         combine(ForEachRef&lt;A, FTag, CTag&gt;::apply(expr.left(), li.left(), f, c),
+ 	        ForEachRef&lt;B, FTag, CTag&gt;::apply(expr.middle(), li.middle(), f, c),
+ 	        ForEachRef&lt;C, FTag, CTag&gt;::apply(expr.right(), li.right(), f, c),
+ 	        c);
+     }
  };
  
  template&lt;class T, class FTag, class CTag&gt;
  struct ForEachRef&lt;Expression&lt;T&gt;, FTag, CTag&gt;
  {
    typedef typename ForEachRef&lt;T, FTag, CTag&gt;::Type_t Type_t;
+   typedef Expression&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   const Type_t &amp;apply(const Subject_t &amp;expr,
! 		      const FTag &amp;f, const CTag &amp;c) 
      {
        return ForEachRef&lt;T, FTag, CTag&gt;::apply(expr.expression(), f, c);
      }
+ 
+   inline static
+   const Type_t &amp;apply(const Subject_t &amp;expr,
+ 		      const LoopInvariant_t &amp;li,
+ 		      const FTag &amp;f, const CTag &amp;c) 
+     {
+       return ForEachRef&lt;T, FTag, CTag&gt;::apply(expr.expression(), li, f, c);
+     }
  };
  
  template&lt;class T, class FTag, class CTag&gt;
  struct ForEachRef&lt;Reference&lt;T&gt;, FTag, CTag&gt;
  {
    typedef typename ForEachRef&lt;T, FTag, CTag&gt;::Type_t Type_t;
+   typedef Reference&lt;T&gt; Subject_t;
+   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
+ 
    inline static
!   const Type_t &amp;apply(const Subject_t &amp;ref,
! 		      const FTag &amp;f, const CTag &amp;c) 
      {
        return ForEachRef&lt;T, FTag, CTag&gt;::apply(ref.reference(), f, c);
+     }
+ 
+   inline static
+   const Type_t &amp;apply(const Subject_t &amp;ref,
+ 		      const LoopInvariant_t &amp;li,
+ 		      const FTag &amp;f, const CTag &amp;c) 
+     {
+       return ForEachRef&lt;T, FTag, CTag&gt;::apply(ref.reference(), li, f, c);
      }
  };
  
Index: src/PETE/Scalar.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/PETE/Scalar.h,v
retrieving revision 1.7
diff -c -p -r1.7 Scalar.h
*** src/PETE/Scalar.h	2000/05/24 17:32:56	1.7
--- src/PETE/Scalar.h	2001/11/05 19:28:26
*************** class Scalar
*** 50,55 ****
--- 50,74 ----
  {
  public: 
  
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t {
+   public:
+ 
+     LoopInvariant_t(const T &amp;t) : scalar_m(t) {}
+ 
+     inline T&amp; scalar() { return scalar_m; }
+     inline const T scalar() const { return scalar_m; }
+ 
+   private:
+ 
+     //---------------------------------------------------------------------------
+     // The scalar value is stored here.
+ 
+     T scalar_m;
+   };
+ 
    //---------------------------------------------------------------------------
    // Default constructor takes no action.
  
*************** public: 
*** 60,70 ****
    // Constructor from a single value.
  
    inline
!   Scalar(const T &amp;t) : scalar_m(t) { }
  
    template&lt;class T1&gt;
    inline
!   explicit Scalar(const T1 &amp;t) : scalar_m(t) { }
  
    //---------------------------------------------------------------------------
    // Constructor with arbitary second/third arguments, which is/are ignored.
--- 79,89 ----
    // Constructor from a single value.
  
    inline
!   Scalar(const T &amp;t) : invariant_m(t) { }
  
    template&lt;class T1&gt;
    inline
!   explicit Scalar(const T1 &amp;t) : invariant_m(t) { }
  
    //---------------------------------------------------------------------------
    // Constructor with arbitary second/third arguments, which is/are ignored.
*************** public: 
*** 74,105 ****
    template&lt;class Arg&gt;
    inline
    Scalar(const Scalar&lt;T&gt; &amp;s, const Arg &amp;)
!     : scalar_m(s.scalar_m) { }
  
    template&lt;class Arg1, class Arg2&gt;
    inline
    Scalar(const Scalar&lt;T&gt; &amp;s, const Arg1 &amp;, const Arg2 &amp;)
!     : scalar_m(s.scalar_m) { }
  
    //---------------------------------------------------------------------------
    // Copy constructor
  
    inline
!   Scalar(const Scalar&lt;T&gt; &amp;s) : scalar_m(s.scalar_m) { }
    
    //---------------------------------------------------------------------------
    // Return value.
  
    inline
!   const T &amp;value() const { return scalar_m; }
  
    //---------------------------------------------------------------------------
    // Assignment operators.
  
    inline
    Scalar&lt;T&gt; &amp;operator=(const Scalar&lt;T&gt; &amp;rhs)
    {
!     scalar_m = rhs.scalar_m;
      
      return *this;
    }
--- 93,127 ----
    template&lt;class Arg&gt;
    inline
    Scalar(const Scalar&lt;T&gt; &amp;s, const Arg &amp;)
!     : invariant_m(s.value()) { }
  
    template&lt;class Arg1, class Arg2&gt;
    inline
    Scalar(const Scalar&lt;T&gt; &amp;s, const Arg1 &amp;, const Arg2 &amp;)
!     : invariant_m(s.value()) { }
  
    //---------------------------------------------------------------------------
    // Copy constructor
  
    inline
!   Scalar(const Scalar&lt;T&gt; &amp;s) : invariant_m(s.value()) { }
    
    //---------------------------------------------------------------------------
    // Return value.
  
    inline
!   const T value() const { return invariant_m.scalar(); }
  
+   inline
+   const T value(const LoopInvariant_t &amp;li) const { return li.scalar(); }
+ 
    //---------------------------------------------------------------------------
    // Assignment operators.
  
    inline
    Scalar&lt;T&gt; &amp;operator=(const Scalar&lt;T&gt; &amp;rhs)
    {
!     invariant_m.scalar() = rhs.value();
      
      return *this;
    }
*************** public: 
*** 107,123 ****
    inline
    Scalar&lt;T&gt; &amp;operator=(const T &amp;rhs)
    {
!     scalar_m = rhs;
      
      return *this;
    }
!   
  private:
  
!   //---------------------------------------------------------------------------
!   // The scalar value is stored here.
  
!   T scalar_m;
  };
  
  
--- 129,150 ----
    inline
    Scalar&lt;T&gt; &amp;operator=(const T &amp;rhs)
    {
!     invariant_m.scalar() = rhs;
      
      return *this;
    }
! 
!   // Values that do not change during the evaluation of a single 
!   // data parallel statement.
! 
!   LoopInvariant_t loopInvariant() const { return invariant_m; }
! 
  private:
  
!   // Values that do not change during the evaluation of a single 
!   // data parallel statement.
  
!   LoopInvariant_t invariant_m;
  };
  
  
Index: src/PETE/TreeNodes.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/PETE/TreeNodes.h,v
retrieving revision 1.14
diff -c -p -r1.14 TreeNodes.h
*** src/PETE/TreeNodes.h	2000/12/04 21:19:37	1.14
--- src/PETE/TreeNodes.h	2001/11/05 19:28:26
***************
*** 50,55 ****
--- 50,71 ----
  template&lt;class T&gt;
  struct Reference
  {
+   // Values that do not change during the evaluation of a single 
+   // data parallel statement.
+ 
+   class LoopInvariant_t {
+   public:
+ 
+     LoopInvariant_t(const T &amp;t) : reference_m(t) {}
+ 
+     inline T&amp; reference() { return reference_m; }
+     inline const T&amp; reference() const { return reference_m; }
+ 
+   private:
+ 
+     const T &amp;reference_m;
+   };
+ 
    //---------------------------------------------------------------------------
    // Export the type of thing we're referencing.
  
*************** struct Reference
*** 60,66 ****
  
    inline
    Reference(const T &amp;reference)
!     : reference_m(reference)
    { }
  
    //---------------------------------------------------------------------------
--- 76,82 ----
  
    inline
    Reference(const T &amp;reference)
!     : invariant_m(reference)
    { }
  
    //---------------------------------------------------------------------------
*************** struct Reference
*** 68,74 ****
  
    inline
    Reference(const Reference&lt;T&gt; &amp;model)
!     : reference_m(model.reference())
    { }
  
    //---------------------------------------------------------------------------
--- 84,90 ----
  
    inline
    Reference(const Reference&lt;T&gt; &amp;model)
!     : invariant_m(model.reference())
    { }
  
    //---------------------------------------------------------------------------
*************** struct Reference
*** 77,92 ****
    inline
    const T &amp;reference() const
    {
!     return reference_m;
    }
  
    //---------------------------------------------------------------------------
    // Conversion operators.
  
!   operator const T&amp; () const { return reference_m; }
!   operator T&amp; () const { return const_cast&lt;T&amp;&gt;(reference_m); }
!   
!   const T &amp;reference_m;
  };
  
  //-----------------------------------------------------------------------------
--- 93,120 ----
    inline
    const T &amp;reference() const
    {
!     return invariant_m.reference();
    }
  
+   inline
+   const T &amp;reference(const LoopInvariant_t &amp;li) const
+   {
+     return li.reference();
+   }
+ 
    //---------------------------------------------------------------------------
    // Conversion operators.
  
!   operator const T&amp; () const { return invariant_m.reference(); }
!   operator T&amp; () const { return const_cast&lt;T&amp;&gt;(invariant_m.reference()); }
! 
!   LoopInvariant_t loopInvariant() const { return invariant_m; }
! 
! private:  
!   // Values that do not change during the evaluation of a single 
!   // data parallel statement.
! 
!   LoopInvariant_t invariant_m;
  };
  
  //-----------------------------------------------------------------------------
*************** class UnaryNode
*** 136,141 ****
--- 164,183 ----
  {
  public:
  
+   class LoopInvariant_t {
+   public:
+     typedef typename Child::LoopInvariant_t ChildLoopInvariant_t;
+ 
+     LoopInvariant_t(const ChildLoopInvariant_t&amp; li)
+       : li_m(li) {}
+ 
+     inline
+     const ChildLoopInvariant_t&amp; child() const { return li_m; }
+ 
+   private:
+     ChildLoopInvariant_t li_m;
+   };
+ 
    inline
    typename DeReference&lt;Child&gt;::Return_t
    child() const { return DeReference&lt;Child&gt;::apply(child_m); }
*************** public:
*** 176,182 ****
      : child_m(t.child(), a) { }
  
    //---------------------------------------------------------------------------
!   // Constructor using a BinaryNode with a different Child and
    // two arbitrary arguments.
    // Note: for this to work, a Child  must be constructable
    // from an OtherChild and an Arg1 &amp; Arg2.
--- 218,224 ----
      : child_m(t.child(), a) { }
  
    //---------------------------------------------------------------------------
!   // Constructor using a UnaryNode with a different Child and
    // two arbitrary arguments.
    // Note: for this to work, a Child  must be constructable
    // from an OtherChild and an Arg1 &amp; Arg2.
*************** public:
*** 188,193 ****
--- 230,240 ----
      : child_m(t.child(), a1, a2)
      { }
  
+   inline
+   LoopInvariant_t loopInvariant() const {
+     return LoopInvariant_t(child_m.loopInvariant());
+   }
+ 
  private:
  
    Child child_m;
*************** class BinaryNode
*** 214,219 ****
--- 261,286 ----
  {
  public:
  
+   class LoopInvariant_t {
+   public:
+     typedef typename Left::LoopInvariant_t LeftLoopInvariant_t;
+     typedef typename Right::LoopInvariant_t RightLoopInvariant_t;
+ 
+     LoopInvariant_t(const LeftLoopInvariant_t&amp; l, 
+ 		    const RightLoopInvariant_t&amp; r)
+       : l_m(l), r_m(r) {}
+ 
+     inline
+     const LeftLoopInvariant_t&amp; left() const { return l_m; }
+ 
+     inline
+     const RightLoopInvariant_t&amp; right() const { return r_m; }
+ 
+   private:
+     LeftLoopInvariant_t l_m;
+     RightLoopInvariant_t r_m;
+   };
+ 
    inline
    typename DeReference&lt;Left&gt;::Return_t
    left() const { return DeReference&lt;Left&gt;::apply(left_m); }
*************** public:
*** 275,280 ****
--- 342,352 ----
      : left_m(t.left(), a1, a2), right_m(t.right(), a1, a2) 
    { }
  
+   inline
+   LoopInvariant_t loopInvariant() const {
+     return LoopInvariant_t(left_m.loopInvariant(), right_m.loopInvariant());
+   }
+ 
  private:
  
    //---------------------------------------------------------------------------
*************** class TrinaryNode
*** 308,313 ****
--- 380,411 ----
  {
  public:
  
+   class LoopInvariant_t {
+   public:
+     typedef typename Left::LoopInvariant_t LeftLoopInvariant_t;
+     typedef typename Middle::LoopInvariant_t MiddleLoopInvariant_t;
+     typedef typename Right::LoopInvariant_t RightLoopInvariant_t;
+ 
+     LoopInvariant_t(const LeftLoopInvariant_t&amp; l,
+ 		    const MiddleLoopInvariant_t&amp; m,
+ 		    const RightLoopInvariant_t&amp; r)
+       : l_m(l), m_m(m), r_m(r) {}
+ 
+     inline
+     const LeftLoopInvariant_t&amp; left() const { return l_m; }
+ 
+     inline
+     const MiddleLoopInvariant_t&amp; middle() const { return m_m; }
+ 
+     inline
+     const RightLoopInvariant_t&amp; right() const { return r_m; }
+ 
+   private:
+     LeftLoopInvariant_t l_m;
+     MiddleLoopInvariant_t m_m;
+     RightLoopInvariant_t r_m;
+   };
+ 
    inline
    typename DeReference&lt;Left&gt;::Return_t
    left() const { return DeReference&lt;Left&gt;::apply(left_m); }
*************** public:
*** 374,379 ****
--- 472,484 ----
      : left_m(t.left(), a1, a2), 
        middle_m(t.middle(), a1, a2) , right_m(t.right(), a1, a2) 
    { }
+ 
+   inline
+   LoopInvariant_t loopInvariant() const {
+     return LoopInvariant_t(left_m.loopInvariant(),
+ 			   middle_m.loopInvariant(),
+ 			   right_m.loopInvariant());
+   }
  
  private:
  
-------------- next part --------------
Index: Stencil.h
===================================================================
RCS file: /home/pooma/Repository/r2/src/Engine/Stencil.h,v
retrieving revision 1.44
diff -c -p -r1.44 Stencil.h
*** Stencil.h	2001/09/14 22:37:56	1.44
--- Stencil.h	2001/10/31 16:36:03
*************** public:
*** 273,278 ****
--- 273,352 ----
    enum { multiPatch = ExprEngine_t::multiPatch };
    enum { zeroBased = true };
  
+   class LoopInvariant_t {
+   public:
+     typedef typename Expression::LoopInvariant_t ExpressionLoopInvariant_t; 
+    
+     LoopInvariant_t(const ExpressionLoopInvariant_t&amp; eli,
+ 		    const int* offset)
+       : eli_m(eli) {
+       for (int i = 0; i &lt; D; ++i)
+ 	offset_m[i] = offset[i];
+     }
+ 
+     const ExpressionLoopInvariant_t&amp; exprLoopInvariant() const 
+       { return eli_m; }
+ 
+     const int* offset() const { return offset_m; }
+ 
+   private:
+     ExpressionLoopInvariant_t eli_m;
+     int                       offset_m[D]; 
+   };
+ 
+   class ExpressionProxy
+   {
+   public:
+     typedef Element_t Element_t;
+     typedef typename Expression::LoopInvariant_t ExpressionLoopInvariant_t;
+     typedef typename Expression::Element_t Ret_t;
+ 
+     ExpressionProxy(const Expression &amp;expression, const ExpressionLoopInvariant_t &amp;eli)
+       : expression_m(expression), eli_m(eli)
+     {
+     }
+ 
+     inline Ret_t
+     operator()(int i) const
+     {
+       return expression_m.read(eli_m, i);
+     }
+ 
+     inline Ret_t
+     operator()(int i, int j) const
+     {
+       return expression_m.read(eli_m, i, j);
+     }
+ 
+     inline Ret_t
+     operator()(int i, int j, int k) const
+     {
+       return expression_m.read(eli_m, i, j, k);
+     }
+ 
+     inline Ret_t
+     read(int i) const
+     {
+       return expression_m.read(eli_m, i);
+     }
+ 
+     inline Ret_t
+     read(int i, int j) const
+     {
+       return expression_m.read(eli_m, i, j);
+     }
+ 
+     inline Ret_t
+     read(int i, int j, int k) const
+     {
+       return expression_m.read(eli_m, i, j, k);
+     }
+ 
+     const Expression &amp;expression_m;
+     const ExpressionLoopInvariant_t &amp;eli_m;
+   };
+ 
+ 
    //============================================================
    // Construct from a Function object (effectively a stencil)
    // and an expression (effectively the input array), and
*************** public:
*** 378,383 ****
--- 452,502 ----
  		      loc[2].first() + offset_m[2]);
    }
  
+   inline Element_t read(const LoopInvariant_t&amp; li, int i) const 
+   {
+     // Input index `i + offset_m[0]' corresponds to output index `i'.
+     ExpressionProxy expressionProxy(expression_m, li.exprLoopInvariant());
+     return function()(expressionProxy,
+ 		      i + li.offset()[0]);
+   }
+   inline Element_t read(const LoopInvariant_t&amp; li, int i, int j) const 
+   {
+     ExpressionProxy expressionProxy(expression_m, li.exprLoopInvariant());
+     return function()(expressionProxy,
+ 		      i + li.offset()[0],
+ 		      j + li.offset()[1]);
+   }
+   inline Element_t read(const LoopInvariant_t&amp; li, int i, int j, int k) const 
+   { 
+     ExpressionProxy expressionProxy(expression_m, li.exprLoopInvariant());
+     return function()(expressionProxy,
+ 		      i + li.offset()[0],
+ 		      j + li.offset()[1],
+ 		      k + li.offset()[2]);
+   }
+ 
+   inline Element_t read(const LoopInvariant_t&amp; li, const Loc&lt;1&gt; &amp;loc) const 
+   {
+     ExpressionProxy expressionProxy(expression_m, li.exprLoopInvariant());
+     return function()(expressionProxy,
+ 		      loc[0].first() + li.offset()[0]);
+   }
+   inline Element_t read(const LoopInvariant_t&amp; li, const Loc&lt;2&gt; &amp;loc) const 
+   {
+     ExpressionProxy expressionProxy(expression_m, li.exprLoopInvariant());
+     return function()(expressionProxy,
+ 		      loc[0].first() + li.offset()[0],
+ 		      loc[1].first() + li.offset()[1]);
+   }
+   inline Element_t read(const LoopInvariant_t&amp; li, const Loc&lt;3&gt; &amp;loc) const 
+   { 
+     ExpressionProxy expressionProxy(expression_m, li.exprLoopInvariant());
+     return function()(expressionProxy,
+ 		      loc[0].first() + li.offset()[0],
+ 		      loc[1].first() + li.offset()[1],
+ 		      loc[2].first() + li.offset()[2]);
+   }
+ 
    //============================================================
    // operator() are provided since users typically write stencils
    // as x(i, j) + x(i, j - 1), so for stencils of stencils to work
*************** public:
*** 474,479 ****
--- 593,602 ----
    inline const Function   &amp;function() const   { return function_m; }
    inline const Expression &amp;expression() const { return expression_m; }
  
+   inline const LoopInvariant_t loopInvariant() const
+     { return LoopInvariant_t(expression_m.loopInvariant(),
+ 			     offset_m); }
+ 
  private:
  
    Function    function_m;
*************** struct LeafFunctor&lt;Engine&lt;D,T,StencilEng
*** 855,864 ****
    ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &gt;
  {
    typedef int Type_t;
! 
!   static
!   Type_t apply(const Engine&lt;D,T,StencilEngine&lt;S,E&gt; &gt; &amp;engine,
! 	       const ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &amp;tag)
    {
      typedef StencilIntersector&lt;D, Intersect&gt; NewIntersector_t;
      NewIntersector_t newIntersector(engine.intersectDomain(),
--- 978,990 ----
    ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; &gt;
  {
    typedef int Type_t;
!   typedef Engine&lt;D,T,StencilEngine&lt;S,E&gt; &gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef ExpressionApply&lt;IntersectorTag&lt;Intersect&gt; &gt; Tag_t;
! 
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      typedef StencilIntersector&lt;D, Intersect&gt; NewIntersector_t;
      NewIntersector_t newIntersector(engine.intersectDomain(),
*************** struct LeafFunctor&lt;Engine&lt;D,T,StencilEng
*** 868,873 ****
--- 994,1014 ----
  		    IntersectorTag&lt;NewIntersector_t&gt;(newIntersector));
      return 0;
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     typedef StencilIntersector&lt;D, Intersect&gt; NewIntersector_t;
+     NewIntersector_t newIntersector(engine.intersectDomain(),
+ 				    tag.tag().intersector_m);
+ 
+     // FIXME: Where is this defined?  Revise it.
+     expressionApply(engine.expression(), li,
+ 		    IntersectorTag&lt;NewIntersector_t&gt;(newIntersector));
+     return 0;
+   }
  };
  
  //---------------------------------------------------------------------------
*************** struct EngineFunctor&lt;Engine&lt;D, T, Stenci
*** 905,921 ****
  template &lt;int D, class T, class S, class E, class Tag&gt;
  struct LeafFunctor&lt;Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt;, EngineView&lt;Tag&gt; &gt;
  {
!   typedef LeafFunctor&lt;E, EngineView&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t NewViewed_t;
    typedef Engine&lt;D, T, StencilEngine&lt;S, NewViewed_t&gt; &gt; Type_t;
  
!   static
!   Type_t apply(const Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt; &amp;engine,
! 	       const EngineView&lt;Tag&gt; &amp;tag)
    {
      return Type_t(engine.function(), 
  		  LeafFunctor_t::apply(engine.expression(), tag));
    }
  };
  
  //-----------------------------------------------------------------------------
--- 1046,1074 ----
  template &lt;int D, class T, class S, class E, class Tag&gt;
  struct LeafFunctor&lt;Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt;, EngineView&lt;Tag&gt; &gt;
  {
!   typedef Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef EngineView&lt;Tag&gt; Tag_t;
!   typedef LeafFunctor&lt;E, Tag_t &gt; LeafFunctor_t;
    typedef typename LeafFunctor_t::Type_t NewViewed_t;
    typedef Engine&lt;D, T, StencilEngine&lt;S, NewViewed_t&gt; &gt; Type_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      return Type_t(engine.function(), 
  		  LeafFunctor_t::apply(engine.expression(), tag));
    }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return Type_t(engine.function(), li,
+ 		  LeafFunctor_t::apply(engine.expression(), tag));
+   }
  };
  
  //-----------------------------------------------------------------------------
*************** struct LeafFunctor&lt;Engine&lt;D, T, StencilE
*** 928,941 ****
  template &lt;int D, class T, class S, class E, class Tag&gt;
  struct LeafFunctor&lt;Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
!   typedef LeafFunctor&lt;E, ExpressionApply&lt;Tag&gt; &gt; LeafFunctor_t;
    typedef int Type_t;
  
!   static
!   Type_t apply(const Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt; &amp;engine,
! 	       const ExpressionApply&lt;Tag&gt; &amp;tag)
    {
      return LeafFunctor_t::apply(engine.expression(), tag);
    }
  };
  
--- 1081,1105 ----
  template &lt;int D, class T, class S, class E, class Tag&gt;
  struct LeafFunctor&lt;Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt;, ExpressionApply&lt;Tag&gt; &gt;
  {
!   typedef Engine&lt;D, T, StencilEngine&lt;S, E&gt; &gt; Subject_t;
!   typedef typename Subject_t::LoopInvariant_t LoopInvariant_t;
!   typedef ExpressionApply&lt;Tag&gt; Tag_t;
!   typedef LeafFunctor&lt;E, Tag_t&gt; LeafFunctor_t;
    typedef int Type_t;
  
!   inline static
!   Type_t apply(const Subject_t &amp;engine,
! 	       const Tag_t &amp;tag)
    {
      return LeafFunctor_t::apply(engine.expression(), tag);
+   }
+ 
+   inline static
+   Type_t apply(const Subject_t &amp;engine,
+ 	       const LoopInvariant_t &amp;li,
+ 	       const Tag_t &amp;tag)
+   {
+     return LeafFunctor_t::apply(engine.expression(), li, tag);
    }
  };
  
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000858.html">Reminder to Submit Timesheets
</A></li>
	<LI>Next message: <A HREF="000860.html">Patch: Fix Typographical Error
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#859">[ date ]</a>
              <a href="thread.html#859">[ thread ]</a>
              <a href="subject.html#859">[ subject ]</a>
              <a href="author.html#859">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/pooma-dev">More information about the pooma-dev
mailing list</a><br>
</body></html>
