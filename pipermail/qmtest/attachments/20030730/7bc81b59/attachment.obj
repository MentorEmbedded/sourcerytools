2003-07-30  Mark Mitchell  <mark@codesourcery.com>

	* NEWS: Recommend Mozilla, even on Windows.  Mention use of
	line-ending independent comparisons in "command" test classes.
	* qm/fields.py (IntegerField.FormatValueAsHtml): Insert space before
	tag closing.
	(TextField.FormatValueAsHtml): Likewise.
	(TextField.ParseFormValue): Correct typo in comment.
	(TupleField.FormatValueAsHtml): Pretty-print.
	(SetField.FormatValueAsHtml): Likewise.
	(AttachmentField.FormatValueAsHtml): Insert space before
	tag closing.
	(EnumerationField): Derive from ChoiceField.
	* qm/web.py (DtmlPage.GenerateXMLHeader): Change encoding field to
	match that used in generated HTML.
	(make_select): Remove.
	* qm/test/classes/command.py (ExecTestBase.Run): Use __CompareText.
	(ExecTestBase.__CompareText): New method.
	* qm/test/share/dtml/navigation-bar.dtml: Use "javascript:
	void(0)" as a go-nowhere URL.
	* qm/test/share/dtml/show.dtml: Embed the id as a hidden field.
	* qm/test/web/web.py (ShowItemPage.MakeSubmitUrl): Do not encode
	the id in the URL.

Index: NEWS
===================================================================
RCS file: /home/qm/Repository/qm/NEWS,v
retrieving revision 1.23
diff -c -5 -p -r1.23 NEWS
*** NEWS	14 Apr 2003 06:06:40 -0000	1.23
--- NEWS	30 Jul 2003 21:19:08 -0000
*************** NEWS
*** 4,22 ****
  This file describes user visible changes to QM.
  
  QM 2.1 (Not Yet Released)
  =========================
  
! QM 2.1 requires Python 2.2 or greater.
  
  There is now a "qmtest create" command-line option that can be used to
  create extension instances (such as tests, resources, or databases)
  programmatically.  The "--class" option to the qmtest create-tdb"
  command now supports the same descriptor syntax as "qmtest create".
  
! There is a new executable.TimeoutExecutable class that can be used to
! run a child process with a timeout.  The "command" test classes now
  make use of this functionality to support running child processes with
  a timeout.
  
  There is now a "-O" or "--outcomes" option for setting the expected
  outcomes, even when working within in the GUI.
--- 4,28 ----
  This file describes user visible changes to QM.
  
  QM 2.1 (Not Yet Released)
  =========================
  
! QMTest requires Python 2.2 or greater.
! 
! On Windows, we recommend that Mozilla be used with QMTest.  Internet
! Explorer appears to handle some forms that QMTest creates incorrectly.
! CodeSourcery has validated the HTML using automated and manual
! methods, and believes that the problems like with Internet Explorer
! and not with QMTest.
  
  There is now a "qmtest create" command-line option that can be used to
  create extension instances (such as tests, resources, or databases)
  programmatically.  The "--class" option to the qmtest create-tdb"
  command now supports the same descriptor syntax as "qmtest create".
  
! There is a new "executable.TimeoutExecutable" class that can be used
! to run a child process with a timeout.  The "command" test classes now
  make use of this functionality to support running child processes with
  a timeout.
  
  There is now a "-O" or "--outcomes" option for setting the expected
  outcomes, even when working within in the GUI.
*************** outcomes, even when working within in th
*** 24,33 ****
--- 30,44 ----
  There is a new "--result-stream" option to "qmtest run" and "qmtest
  summarize" that allows users to specify custom result streams.
  
  A defect that could cause a multi-threaded or multi-process tests run
  to hang if a resource could not be set up has been corrected.
+ 
+ Comparisions between the expected standard output and actual standard
+ output done by test classes in the "command" module now ignore line
+ endings.  This change facilitates moving tests between operating
+ systems.
  
  QM 2.0.4 (Not Yet Released)
  ===========================
  
  A defect that could cause crashes in the RSHTarget class has been
Index: qm/fields.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/fields.py,v
retrieving revision 1.76
diff -c -5 -p -r1.76 fields.py
*** qm/fields.py	29 Jul 2003 20:22:43 -0000	1.76
--- qm/fields.py	30 Jul 2003 21:19:09 -0000
*************** class IntegerField(Field):
*** 410,425 ****
          # Use the default field form field name if requested.
          if name is None:
              name = self.GetHtmlFormFieldName()
  
          if style == "new" or style == "edit":
!             return '<input type="text" size="8" name="%s" value="%d"/>' \
                     % (name, value)
          elif style == "full" or style == "brief":
              return '<tt>%d</tt>' % value
          elif style == "hidden":
!             return '<input type="hidden" name="%s" value="%d"/>' \
                     % (name, value)            
          else:
              assert None
  
  
--- 410,425 ----
          # Use the default field form field name if requested.
          if name is None:
              name = self.GetHtmlFormFieldName()
  
          if style == "new" or style == "edit":
!             return '<input type="text" size="8" name="%s" value="%d" />' \
                     % (name, value)
          elif style == "full" or style == "brief":
              return '<tt>%d</tt>' % value
          elif style == "hidden":
!             return '<input type="hidden" name="%s" value="%d" />' \
                     % (name, value)            
          else:
              assert None
  
  
*************** class TextField(Field):
*** 552,562 ****
                  result = '<textarea cols="64" rows="8" name="%s">' \
                           '%s</textarea>' \
                           % (name, web.escape(value))
              else:
                  result = \
!                     '<input type="text" size="40" name="%s" value="%s"/>' \
                      % (name, web.escape(value))
              # If this is a structured text field, add a note to that
              # effect, so users aren't surprised.
              if self.__structured:
                  result = result \
--- 552,562 ----
                  result = '<textarea cols="64" rows="8" name="%s">' \
                           '%s</textarea>' \
                           % (name, web.escape(value))
              else:
                  result = \
!                     '<input type="text" size="40" name="%s" value="%s" />' \
                      % (name, web.escape(value))
              # If this is a structured text field, add a note to that
              # effect, so users aren't surprised.
              if self.__structured:
                  result = result \
*************** class TextField(Field):
*** 566,576 ****
                      "structured text") \
                  + 'field.</font>'
              return result
  
          elif style == "hidden":
!             return '<input type="hidden" name="%s" value="%s"/>' \
                     % (name, web.escape(value))            
  
          elif style == "brief":
              if self.__structured:
                  # Use only the first line of text.
--- 566,576 ----
                      "structured text") \
                  + 'field.</font>'
              return result
  
          elif style == "hidden":
!             return '<input type="hidden" name="%s" value="%s" />' \
                     % (name, web.escape(value))            
  
          elif style == "brief":
              if self.__structured:
                  # Use only the first line of text.
*************** class TextField(Field):
*** 654,664 ****
          return value
  
  
      def ParseFormValue(self, request, name, attachment_store):
  
!         # HTTP specifies text encodints are CR/LF delimited; convert to
          # the One True Text Format (TM).
          return (self.ParseTextValue(qm.convert_from_dos_text(request[name])),
                  0)
      
  
--- 654,664 ----
          return value
  
  
      def ParseFormValue(self, request, name, attachment_store):
  
!         # HTTP specifies text encodings are CR/LF delimited; convert to
          # the One True Text Format (TM).
          return (self.ParseTextValue(qm.convert_from_dos_text(request[name])),
                  0)
      
  
*************** class TupleField(Field):
*** 727,744 ****
          # Use the default name if none is specified.
          if name is None:
              name = self.GetHtmlFormFieldName()
              
          # Format the field as a multi-column table.
!         html = '<table border="0" cellpadding="0"><tr>'
          for f, v in map(None, self.__fields, value):
              element_name = name + "_" + f.GetName()
!             html += "<td><b>" + f.GetTitle() + "</b>:</td>"
!             html += ("<td>" 
                       + f.FormatValueAsHtml(server, v, style, element_name)
!                      + "</td>")
!         html += "</tr></table>"
  
          return html
  
  
      def MakeDomNodeForValue(self, value, document):
--- 727,744 ----
          # Use the default name if none is specified.
          if name is None:
              name = self.GetHtmlFormFieldName()
              
          # Format the field as a multi-column table.
!         html = '<table border="0" cellpadding="0">\n <tr>\n'
          for f, v in map(None, self.__fields, value):
              element_name = name + "_" + f.GetName()
!             html += "  <td><b>" + f.GetTitle() + "</b>:</td>\n"
!             html += ("  <td>\n" 
                       + f.FormatValueAsHtml(server, v, style, element_name)
!                      + "  </td>\n")
!         html += " </tr>\n</table>\n"
  
          return html
  
  
      def MakeDomNodeForValue(self, value, document):
*************** class SetField(Field):
*** 901,957 ****
                  separator = "<br>\n"
              return string.join(formatted, separator)
  
          elif style in ["new", "edit", "hidden"]:
              html = ""
!             # Create a table to represent the set -- but only if the set is
! 	    # non-empty.  A table with no body is invalid HTML.
! 	    if value:
! 		html += '''<table border="0" cellpadding="0" cellspacing="0">
! 			    <tbody>\n'''
! 		element_number = 0
! 		for element in value:
! 		    html += "<tr><td>"
! 		    element_name = name + "_%d" % element_number
! 		    checkbox_name = element_name + "_remove"
! 		    if style == "edit":
! 			html += \
! 			   ('''<input type="checkbox" name="%s" /></td><td>'''
! 			    % checkbox_name)
! 		    html += contained_field.FormatValueAsHtml(server,
! 							      element,
! 							      style,
! 							      element_name)
! 		    html += "</td></tr>\n"
! 		    element_number += 1
! 		html += "</tbody></table>\n"
!             if style == "edit":
!                 # The action field is used to keep track of whether the
!                 # "Add" or "Remove" button has been pushed.  It would be
!                 # much nice if we could use JavaScript to update the
!                 # table, but Netscape 4, and even Mozilla 1.0, do not
!                 # permit that.  Therefore, we have to go back to the server.
!                 action_field \
!                     = '''<input type="hidden" name="%s" value="" />''' % name
!                 count_field \
!                     = ('<input type="hidden" name="%s_count" value="%d" />'
! 	               % (name, len(value)))
!                 add_button \
!                     = '''<input type="button" value="Add Another"
!                             onclick="%s.value = 'add'; submit();" />''' \
!                       % name
!                 remove_button \
!                     = '''<input type="button" value="Remove Selected"
!                             onclick="%s.value = 'remove'; submit();" />''' \
!                       % name
!                 button_table \
!                     = ('''<table border="0" cellpadding="0" cellspacing="0">
!                             <tbody>\n'''
!                        + " <tr><td>" + add_button + "</td></tr>\n"
!                        + " <tr><td>" + remove_button + "</td></tr>\n"
!                        + "</tbody></table>")
!                 html += action_field + "\n" + count_field + "\n" + button_table
              return html
  
  
      def MakeDomNodeForValue(self, value, document):
  
--- 901,956 ----
                  separator = "<br>\n"
              return string.join(formatted, separator)
  
          elif style in ["new", "edit", "hidden"]:
              html = ""
!             if value:
!                 # Create a table to represent the set -- but only if the set is
!                 # non-empty.  A table with no body is invalid HTML.
!                 html += ('<table border="0" cellpadding="0" cellspacing="0">'
!                          "\n <tbody>\n")
!                 element_number = 0
!                 for element in value:
!                     html += "  <tr>\n   <td>"
!                     element_name = name + "_%d" % element_number
!                     checkbox_name = element_name + "_remove"
!                     if style == "edit":
!                         html += \
!                            ('<input type="checkbox" name="%s" /></td>\n'
!                             '   <td>\n'
!                             % checkbox_name)
!                     html += contained_field.FormatValueAsHtml(server,
!                                                               element,
!                                                               style,
!                                                               element_name)
!                     html += "   </td>\n  </tr>\n"
!                     element_number += 1
!                 html += " </tbody>\n</table>\n"
!             # The action field is used to keep track of whether the
!             # "Add" or "Remove" button has been pushed.  It would be
!             # much nice if we could use JavaScript to update the
!             # table, but Netscape 4, and even Mozilla 1.0, do not
!             # permit that.  Therefore, we have to go back to the server.
!             html += '<input type="hidden" name="%s" value="" />' % name
!             html += ('<input type="hidden" name="%s_count" value="%d" />'
!                      % (name, len(value)))
!             if style != "hidden":
!                 html += ('<table border="0" cellpadding="0" cellspacing="0">\n'
!                          ' <tbody>\n'
!                          '  <tr>\n'
!                          '   <td><input type="button" name="%s_add" '
!                          'value="Add Another" '
!                          '''onclick="%s.value = 'add'; submit();" />'''
!                          '</td>\n'
!                          '   <td><input type="button" name="%s_remove"'
!                          'value="Remove Selected" '
!                          '''onclick="%s.value = 'remove'; submit();" />'''
!                          '</td>\n'
!                          '  </tr>'
!                          ' </tbody>'
!                          '</table>'
!                          % (name, name, name, name))
              return html
  
  
      def MakeDomNodeForValue(self, value, document):
  
*************** class AttachmentField(Field):
*** 1292,1302 ****
              <input type="button"
                     size="20"
                     value=" Clear "
                     name="_clear_%s"
                     onclick="document.form.%s.value = 'None';
!                             document.form.%s.value = '';"/>
              ''' % (field_name, summary_field_name, name)
              # A hidden control for the encoded attachment value.  The
              # popup upload form fills in this control.
              hidden_control = '''
              <input type="hidden"
--- 1291,1301 ----
              <input type="button"
                     size="20"
                     value=" Clear "
                     name="_clear_%s"
                     onclick="document.form.%s.value = 'None';
!                             document.form.%s.value = '';" />
              ''' % (field_name, summary_field_name, name)
              # A hidden control for the encoded attachment value.  The
              # popup upload form fills in this control.
              hidden_control = '''
              <input type="hidden"
*************** class AttachmentField(Field):
*** 1377,1387 ****
          return self.Validate(attachment.from_dom_node(node, attachment_store))
  
  
  ########################################################################
  
! class EnumerationField(TextField):
      """A field that contains an enumeral value.
  
      The enumeral value is selected from an enumerated set of values.
      An enumeral field uses the following properties:
  
--- 1376,1441 ----
          return self.Validate(attachment.from_dom_node(node, attachment_store))
  
  
  ########################################################################
  
! class ChoiceField(TextField):
!     """A 'ChoiceField' allows choosing one of several values.
! 
!     The set of acceptable values can be determined when the field is
!     created or dynamically.  The empty string is used as the "no
!     choice" value, and cannot therefore be one of the permitted
!     values."""
! 
!     def GetItems(self):
!         """Return the options from which to choose.
! 
!         returns -- A sequence of strings, each of which will be
!         presented as a choice for the user."""
! 
!         raise NotImplementedError
! 
! 
!     def FormatValueAsHtml(self, server, value, style, name = None):
! 
!         if style not in ("new", "edit"):
!             return qm.fields.TextField.FormatValueAsHtml(self, server,
!                                                          value,
!                                                          style, name)
! 
!         # For an editable field, give the user a choice of available
!         # resources.
!         items = self.GetItems()
!         result = "<select"
!         if name:
!             result += ' name="%s"' % name
!         result += ">\n"
!         # HTML does not permit a "select" tag with no contained "option"
!         # tags.  Therefore, we ensure that there is always one option to
!         # choose from.
!         result += ' <option value="">--Select--</option>\n'
!         # Add the choices for the ordinary options.
!         for r in self.GetItems():
!             result += ' <option value="%s"' % r
!             if r == value:
!                 result += ' selected="selected"'
!             result += '>%s</option>\n' % r
!         result += "</select>\n"
! 
!         return result
!     
! 
!     def Validate(self, value):
! 
!         value = super(ChoiceField, self).Validate(value)
!         if value == "":
!             raise ValueError, "No choice specified for %s." % self.GetTitle()
!         return value
! 
!         
!         
! class EnumerationField(ChoiceField):
      """A field that contains an enumeral value.
  
      The enumeral value is selected from an enumerated set of values.
      An enumeral field uses the following properties:
  
*************** class EnumerationField(TextField):
*** 1409,1438 ****
              enumerals = string.split(enumerals, ",")
          # Make sure the default value is legitimate.
          if not default_value in enumerals and len(enumerals) > 0:
              default_value = enumerals[0]
          # Perform base class initialization.
!         apply(TextField.__init__, (self, name, default_value), properties)
          # Remember the enumerals.
!         self.__enumerals = string.join(enumerals, ",")
  
  
!     def GetEnumerals(self):
          """Return a sequence of enumerals.
  
          returns -- A sequence consisting of string enumerals objects, in
          the appropriate order."""
  
!         enumerals = self.__enumerals
!         if enumerals == "":
!             return []
!         else:
!             return string.split(enumerals, ",")
  
  
      def GetHelp(self):
!         enumerals = self.GetEnumerals()
          help = """
          An enumeration field.  The value of this field must be one of a
          preselected set of enumerals.  The enumerals for this field are,
  
          """
--- 1463,1489 ----
              enumerals = string.split(enumerals, ",")
          # Make sure the default value is legitimate.
          if not default_value in enumerals and len(enumerals) > 0:
              default_value = enumerals[0]
          # Perform base class initialization.
! 	super(EnumerationField, self).__init__(name, default_value, 
! 					       **properties)
          # Remember the enumerals.
!         self.__enumerals = enumerals
  
  
!     def GetItems(self):
          """Return a sequence of enumerals.
  
          returns -- A sequence consisting of string enumerals objects, in
          the appropriate order."""
  
!         return self.__enumerals
  
  
      def GetHelp(self):
!         enumerals = self.GetItems()
          help = """
          An enumeration field.  The value of this field must be one of a
          preselected set of enumerals.  The enumerals for this field are,
  
          """
*************** class EnumerationField(TextField):
*** 1444,1505 ****
          ''' % str(self.GetDefaultValue())
          return help
  
      ### Output methods.
      
-     def FormatValueAsHtml(self, server, value, style, name=None):
- 
-         # Use default value if requested.
-         if value is None:
-             value = self.GetDefaultValue()
-         # Use the default field form field name if requested.
-         if name is None:
-             name = self.GetHtmlFormFieldName()
- 
-         if style == "new" or style == "edit":
-             enumerals = self.GetEnumerals()
-             if len(enumerals) == 0:
-                 # No available enumerals.  Don't let the user change
-                 # anything. 
-                 self.FormatValueAsHtml(server, value, "brief", name)
-             else:
-                 return qm.web.make_select(name, enumerals, value, str, str)
- 
-         elif style == "hidden":
-             return '<input type="hidden" name="%s" value="%s"/>' \
-                    % (name, value) 
- 
-         elif style == "full" or style == "brief":
-             return value
- 
-         else:
-             raise ValueError, style
- 
- 
      def MakeDomNodeForValue(self, value, document):
          # Store the name of the enumeral.
!         return xmlutil.create_dom_text_element(
!             document, "enumeral", str(value))
  
  
      ### Input methods.
      
-     def Validate(self, value):
- 
-         super(EnumerationField, self).Validate(value)
-         enumerals = self.GetEnumerals()
-         if value in enumerals:
-             return value
-         else:
-             values = map(lambda (k, v): "%s (%d)" % (k, v), enumerals)
-             raise ValueError, \
-                   qm.error("invalid enum value",
-                            value=value,
-                            field_title=self.GetTitle(),
-                            values=string.join(values, ", "))
- 
- 
      def GetValueFromDomNode(self, node, attachment_store):
  
          # Make sure 'node' is an '<enumeral>' element.
          if node.nodeType != xml.dom.Node.ELEMENT_NODE \
             or node.tagName != "enumeral":
--- 1495,1513 ----
          ''' % str(self.GetDefaultValue())
          return help
  
      ### Output methods.
      
      def MakeDomNodeForValue(self, value, document):
+ 
          # Store the name of the enumeral.
!         return xmlutil.create_dom_text_element(document, "enumeral", 
! 	                                       str(value))
  
  
      ### Input methods.
      
      def GetValueFromDomNode(self, node, attachment_store):
  
          # Make sure 'node' is an '<enumeral>' element.
          if node.nodeType != xml.dom.Node.ELEMENT_NODE \
             or node.tagName != "enumeral":
*************** class BooleanField(EnumerationField):
*** 1524,1587 ****
          EnumerationField.__init__(self, name, default_value,
                                    ["true", "false"], **properties)
  
          
  
- class ChoiceField(TextField):
-     """A 'ChoiceField' allows choosing one of several values.
- 
-     A 'ChoiceField' is similar to an 'EnumerationField' -- but the
-     choices for an 'ChoiceField' are computed dynamically, rather than
-     chosen statically."""
- 
-     def FormatValueAsHtml(self, server, value, style, name = None):
- 
-         if style not in ("new", "edit"):
-             return qm.fields.TextField.FormatValueAsHtml(self, server,
-                                                          value,
-                                                          style, name)
- 
-         # For an editable field, give the user a choice of available
-         # resources.
-         items = self.GetItems()
-         result = "<select"
-         if name:
-             result += ' name="%s"' % name
-         result += ">"
-         # HTML does not permit a "select" tag with no contained "option"
-         # tags.  Therefore, we ensure that there is always one option to
-         # choose from.
-         result += '<option value="">--Select--</option>'
-         # Add the choices for the ordinary options.
-         for r in self.GetItems():
-             result += '<option value="%s"' % r
-             if r == value:
-                 result += ' selected="1"'
-             result += '>%s</option>' % r
-         result += "</select>"
- 
-         return result
-     
- 
-     def GetItems(self):
-         """Return the options from which to choose.
- 
-         returns -- A sequence of strings, each of which will be
-         presented as a choice for the user."""
- 
-         raise NotImplementedError
- 
- 
-     def Validate(self, value):
- 
-         value = super(ChoiceField, self).Validate(value)
-         if value == "":
-             raise ValueError, "No choice specified for %s." % self.GetTitle()
-         return value
- 
-         
-         
  ########################################################################
  
  class TimeField(IntegerField):
      """A field containing a date and time.
  
--- 1532,1541 ----
*************** class TimeField(IntegerField):
*** 1640,1661 ****
      def FormatValueAsHtml(self, server, value, style, name=None):
  
          value = self.FormatValueAsText(value)
  
          if style == "new" or style == "edit":
!             return '<input type="text" size="8" name="%s" value="%s"/>' \
                     % (name, value)
          elif style == "full" or style == "brief":
              # The time is formatted in three parts: the date, the time,
              # and the time zone.  Replace the space between the time and
              # the time zone with a non-breaking space, so that if the
              # time is broken onto two lines, it is broken between the
              # date and the time.
              date, time, time_zone = string.split(value, " ")
              return date + " " + time + "&nbsp;" + time_zone
          elif style == "hidden":
!             return '<input type="hidden" name="%s" value="%s"/>' \
                     % (name, value)
          else:
              raise ValueError, style
  
      ### Input methods.
--- 1594,1615 ----
      def FormatValueAsHtml(self, server, value, style, name=None):
  
          value = self.FormatValueAsText(value)
  
          if style == "new" or style == "edit":
!             return '<input type="text" size="8" name="%s" value="%s" />' \
                     % (name, value)
          elif style == "full" or style == "brief":
              # The time is formatted in three parts: the date, the time,
              # and the time zone.  Replace the space between the time and
              # the time zone with a non-breaking space, so that if the
              # time is broken onto two lines, it is broken between the
              # date and the time.
              date, time, time_zone = string.split(value, " ")
              return date + " " + time + "&nbsp;" + time_zone
          elif style == "hidden":
!             return '<input type="hidden" name="%s" value="%s" />' \
                     % (name, value)
          else:
              raise ValueError, style
  
      ### Input methods.
Index: qm/web.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/web.py,v
retrieving revision 1.74
diff -c -5 -p -r1.74 web.py
*** qm/web.py	29 Jul 2003 20:22:43 -0000	1.74
--- qm/web.py	30 Jul 2003 21:19:11 -0000
*************** class DtmlPage:
*** 185,195 ****
  
      def GenerateXMLHeader(self):
          """Return the XML header for the document."""
  
          return \
!             '''<?xml version="1.0" encoding="UTF-8"?>
                 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
                 <html xmlns="http://www.w3.org/1999/xhtml">'''
      
  
--- 185,195 ----
  
      def GenerateXMLHeader(self):
          """Return the XML header for the document."""
  
          return \
!             '''<?xml version="1.0" encoding="iso-8859-1"?>
                 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
                 <html xmlns="http://www.w3.org/1999/xhtml">'''
      
  
*************** class WebServer(HTTPServer):
*** 791,801 ****
  
          For example, if you register
  
            web_server.RegisterPathTranslation('/images', '/path/to/pictures')
  
!         the the URL 'http://my.server.com/images/big/tree.gif' will be
          mapped to the file path '/path/to/pictures/big/tree.gif'."""
  
          self.__translations[url_path] = file_path
  
  
--- 791,801 ----
  
          For example, if you register
  
            web_server.RegisterPathTranslation('/images', '/path/to/pictures')
  
!         the URL 'http://my.server.com/images/big/tree.gif' will be
          mapped to the file path '/path/to/pictures/big/tree.gif'."""
  
          self.__translations[url_path] = file_path
  
  
*************** def make_popup_page(message, buttons, ti
*** 2212,2291 ****
       </body>
      </html>
      '''
      return page
  
- 
- def make_select(field_name,
-                 items,
-                 default_value,
-                 item_to_text=str,
-                 item_to_value=str,
-                 form_name="form",
-                 update_external_field=0):
-     """Construct HTML controls for selecting an item from a list.
- 
-     'field_name' -- The name of the form control which will contain the
-     currently-selected item.  This is a hidden control; the actual HTML
-     select control is given a different name.
- 
-     'items' -- A sequence of items.  The items may be of any type.
- 
-     'default_value' -- The item which should initially be selected.  The
-     value must appear in 'items'.
- 
-     'item_to_text' -- A function that returns the text representation of
-     an item.
- 
-     'item_to_value' -- A function that returns the value representation
-     of an item.
- 
-     'form_name' -- The name of the form that will contain the returned
-     controls. 
- 
-     'update_external_field' -- If true, update a field named
-     'field_name' when the selection changes.  If false, a hidden field
-     named 'field_name' is included, and updated when selection changes.
- 
-     returns -- The HTML text for the controls.  
- 
-     For each item, 'item_to_text' and 'item_to_value' are used to
-     construct the text and value attributes for the corresponding HTML
-     select option."""
- 
-     assert default_value in items
- 
-     select_name = "_select_" + field_name
-     # Add a hidden control with the specified field name.  This
-     # input will contain the value of the currently-selected
-     # UID.
-     if update_external_field:
-         result = ''
-     else:
-         result = '<input type="hidden" name="%s" value="%s"/>' \
-                  % (field_name, item_to_value(default_value))
-     # Write the handler to update the hidden control when the
-     # selection changes in the select control.
-     on_change = "update_from_select(document.%s.%s, " \
-                 "document.%s.%s)" \
-                 % (form_name, select_name, form_name, field_name)
-     # Generate a '<select>' control droplist.
-     result = result + '<select name="%s" onchange="%s">\n' \
-              % (select_name, on_change)
-     # Generate an '<option>' element for each item.
-     for item in items:
-         # Specify the 'select' attribute if this item represents the
-         # default value.
-         if item == default_value:
-             is_selected = 'selected="selected"'
-         else:
-             is_selected = ""
-         result = result + '<option value="%s" %s>%s</option>\n' \
-                  % (item_to_value(item), is_selected, item_to_text(item))
-     result = result + '</select>\n'
-     return result
-     
  
  def make_choose_control(field_name,
                          included_label,
                          included_items,
                          excluded_label,
--- 2212,2221 ----
Index: qm/test/classes/command.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/command.py,v
retrieving revision 1.35
diff -c -5 -p -r1.35 command.py
*** qm/test/classes/command.py	9 May 2003 22:17:44 -0000	1.35
--- qm/test/classes/command.py	30 Jul 2003 21:19:11 -0000
*************** class ExecTestBase(Test):
*** 197,213 ****
                  causes.append("exit_code")
                  result["ExecTest.expected_exit_code"] \
                      = str(self.exit_code)
                  result["ExecTest.exit_code"] = str(exit_code)
              # Check to see if the standard output matches.
!             if stdout != self.stdout:
                  causes.append("standard output")
                  result["ExecTest.stdout"] = "<pre>" + stdout + "</pre>"
                  result["ExecTest.expected_stdout"] \
                      = "<pre>" + self.stdout + "</pre>"
              # Check to see that the standard error matches.
!             if stderr != self.stderr:
                  causes.append("standard error")
                  result["ExecTest.stderr"] = "<pre>" + stderr + "</pre>"
                  result["ExecTest.expected_stderr"] \
                      = "<pre>" + self.stderr + "</pre>"
              # If anything went wrong, the test failed.
--- 197,213 ----
                  causes.append("exit_code")
                  result["ExecTest.expected_exit_code"] \
                      = str(self.exit_code)
                  result["ExecTest.exit_code"] = str(exit_code)
              # Check to see if the standard output matches.
!             if not self.__CompareText(stdout, self.stdout):
                  causes.append("standard output")
                  result["ExecTest.stdout"] = "<pre>" + stdout + "</pre>"
                  result["ExecTest.expected_stdout"] \
                      = "<pre>" + self.stdout + "</pre>"
              # Check to see that the standard error matches.
!             if not self.__CompareText(stderr, self.stderr):
                  causes.append("standard error")
                  result["ExecTest.stderr"] = "<pre>" + stderr + "</pre>"
                  result["ExecTest.expected_stderr"] \
                      = "<pre>" + self.stderr + "</pre>"
              # If anything went wrong, the test failed.
*************** class ExecTestBase(Test):
*** 227,236 ****
--- 227,251 ----
              result["ExecTest.signal_number"] = signal_number
          else:
              # The target program terminated abnormally in some other
              # manner.  (This shouldn't normally happen...)
              result.Fail("Program did not terminate normally.")
+ 
+ 
+     def __CompareText(self, s1, s2):
+         """Compare 's1' and 's2', ignoring line endings.
+ 
+         's1' -- A string.
+ 
+         's2' -- A string.
+ 
+         returns -- True if 's1' and 's2' are the same, ignoring
+         differences in line endings."""
+ 
+         # The "splitlines" works independently of the line ending
+         # convention involved.
+         return s1.splitlines() == s2.splitlines()
  
          
      
  class ExecTest(ExecTestBase):
      """Check a program's output and exit code.
Index: qm/test/share/dtml/navigation-bar.dtml
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/share/dtml/navigation-bar.dtml,v
retrieving revision 1.6
diff -c -5 -p -r1.6 navigation-bar.dtml
*** qm/test/share/dtml/navigation-bar.dtml	25 Feb 2003 00:21:09 -0000	1.6
--- qm/test/share/dtml/navigation-bar.dtml	30 Jul 2003 21:19:11 -0000
***************
*** 35,51 ****
     <dtml-let name=sequence-item
               base="name + '_base'"
               menu="name + '_menu'">
      <td width="20%" class="menu_bar">
       <dtml-if click_menus>
!       <a href=""
           id="<dtml-var base>"
           onclick="show_menu(event, '<dtml-var menu>'); return false;"
           onmouseout="hide_active_menu(event);"
           class="menu_bar"><dtml-var name capitalize></a>
       <dtml-else>
!       <a href=""
           id="<dtml-var base>"
           onmouseover="show_menu(event, '<dtml-var menu>');"
           onmouseout="hide_active_menu(event);"
           onclick="return false;"
           class="menu_bar"><dtml-var name capitalize></a>
--- 35,51 ----
     <dtml-let name=sequence-item
               base="name + '_base'"
               menu="name + '_menu'">
      <td width="20%" class="menu_bar">
       <dtml-if click_menus>
!       <a href="javascript: void(0)"
           id="<dtml-var base>"
           onclick="show_menu(event, '<dtml-var menu>'); return false;"
           onmouseout="hide_active_menu(event);"
           class="menu_bar"><dtml-var name capitalize></a>
       <dtml-else>
!       <a href="javascript: void(0)"
           id="<dtml-var base>"
           onmouseover="show_menu(event, '<dtml-var menu>');"
           onmouseout="hide_active_menu(event);"
           onclick="return false;"
           class="menu_bar"><dtml-var name capitalize></a>
Index: qm/test/share/dtml/show.dtml
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/share/dtml/show.dtml,v
retrieving revision 1.4
diff -c -5 -p -r1.4 show.dtml
*** qm/test/share/dtml/show.dtml	18 Jun 2003 17:14:01 -0000	1.4
--- qm/test/share/dtml/show.dtml	30 Jul 2003 21:19:11 -0000
***************
*** 62,72 ****
           action="<dtml-var expr="MakeSubmitUrl()">"
           enctype="multipart/form-data">
  
     <input type="hidden" 
            name="class"
!           value="<dtml-var expr="item.GetClassName()">"/>
    </dtml-if>
  
    <table border="0"
           cellpadding="4"
           cellspacing="4"
--- 62,75 ----
           action="<dtml-var expr="MakeSubmitUrl()">"
           enctype="multipart/form-data">
  
     <input type="hidden" 
            name="class"
!           value="<dtml-var expr="item.GetClassName()">" />
!    <input type="hidden" 
!           name="id"
!           value="<dtml-var expr="item.GetId()">" />
    </dtml-if>
  
    <table border="0"
           cellpadding="4"
           cellspacing="4"
Index: qm/test/web/web.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/web/web.py,v
retrieving revision 1.75
diff -c -5 -p -r1.75 web.py
*** qm/test/web/web.py	29 Jul 2003 20:22:43 -0000	1.75
--- qm/test/web/web.py	30 Jul 2003 21:19:12 -0000
*************** class ShowItemPage(QMTestPage):
*** 1065,1075 ****
  
  
      def MakeSubmitUrl(self):
          """Return the URL for submitting edits."""
  
!         return self.request.copy("submit-" + self.type).AsUrl()
  
  
      def MakeDeleteScript(self):
          """Make a script to confirm deletion of the test or resource.
  
--- 1065,1076 ----
  
  
      def MakeSubmitUrl(self):
          """Return the URL for submitting edits."""
  
!         return qm.web.WebRequest("submit-" + self.type,
!                                  base=self.request).AsUrl()
  
  
      def MakeDeleteScript(self):
          """Make a script to confirm deletion of the test or resource.
  
