Index: qm/test/result.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/result.py,v
retrieving revision 1.28
diff -u -r1.28 result.py
--- qm/test/result.py	24 Oct 2005 05:46:16 -0000	1.28
+++ qm/test/result.py	26 Oct 2005 02:46:56 -0000
@@ -19,7 +19,7 @@
 
 import qm
 from   qm.test.context import ContextException
-import sys
+import sys, os
 import types
 import cgi
 
@@ -328,6 +328,51 @@
             = self.Quote(qm.format_traceback(exc_info))
 
         
+    def CheckExitStatus(self, prefix, desc, status, non_zero_exit_ok = 0):
+        """Check the exit status from a command.
+
+        'result' -- The 'Result' object to update.
+
+        'prefix' -- The prefix that should be used when creating
+        result annotations.
+
+        'desc' -- A description of the executing program.
+        
+        'status' -- The exit status, as returned by 'waitpid'.
+
+        'non_zero_exit_ok' -- True if a non-zero exit code is not
+        considered failure.
+
+        returns -- False if the test failed, true otherwise."""
+
+        if sys.platform == "win32" or os.WIFEXITED(status):
+            # Obtain the exit code.
+            if sys.platform == "win32":
+                exit_code = status
+            else:
+                exit_code = os.WEXITSTATUS(status)
+            # If the exit code is non-zero, the test fails.
+            if exit_code != 0 and not non_zero_exit_ok:
+                result.Fail("%s failed with exit code %d." % (desc, exit_code))
+                # Record the exit code in the result.
+                result[prefix + "exit_code"] = str(exit_code)
+                return False
+        
+        elif os.WIFSIGNALED(status):
+            # Obtain the signal number.
+            signal = os.WTERMSIG(status)
+            # If the program gets a fatal signal, the test fails .
+            result.Fail("%s received fatal signal %d." % (desc, signal))
+            result[prefix + "signal"] = str(signal)
+            return False
+        else:
+            # A process should only be able to stop by exiting, or
+            # by being terminated with a signal.
+            assert None
+
+        return True
+
+
     def MakeDomNode(self, document):
         """Generate a DOM element node for this result.
 
Index: qm/test/classes/classes.qmc
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/classes.qmc,v
retrieving revision 1.21
diff -u -r1.21 classes.qmc
--- qm/test/classes/classes.qmc	14 Sep 2005 13:24:46 -0000	1.21
+++ qm/test/classes/classes.qmc	26 Oct 2005 02:46:56 -0000
@@ -12,6 +12,7 @@
  <class kind="result_stream" name="tet_stream.TETStream"/>
  <class kind="resource" name="temporary.TempDirectoryResource"/>
  <class kind="resource" name="compiler_table.CompilerTable"/>
+ <class kind="resource" name="compilation_test.SimpleCompiledResource"/>
  <class kind="target" name="process_target.ProcessTarget"/>
  <class kind="target" name="rsh_target.RSHTarget"/>
  <class kind="target" name="serial_target.SerialTarget"/>
@@ -25,6 +26,7 @@
  <class kind="test" name="python.ExceptionTest"/>
  <class kind="test" name="python.ExecTest"/>
  <class kind="test" name="python.StringExceptionTest"/>
+ <class kind="test" name="compilation_test.SimpleCompilationTest"/>
  <class kind="label" name="file_label.FileLabel"/>
  <class kind="label" name="python_label.PythonLabel"/>
  <class kind="suite" name="explicit_suite.ExplicitSuite"/>
Index: qm/test/classes/command.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/command.py,v
retrieving revision 1.48
diff -u -r1.48 command.py
--- qm/test/classes/command.py	19 Jul 2005 17:19:34 -0000	1.48
+++ qm/test/classes/command.py	26 Oct 2005 02:46:57 -0000
@@ -218,53 +218,23 @@
             timeout = -2
         e = qm.executable.Filter(self.stdin, timeout)
         # Run it.
-        exit_status = e.Run(arguments, environment, path = program)
+        status = e.Run(arguments, environment, path = program)
 
-        # If the process terminated normally, check the outputs.
-        if sys.platform == "win32" or os.WIFEXITED(exit_status):
-            # There are no causes of failure yet.
-            causes = []
-            # The target program terminated normally.  Extract the
-            # exit code, if this test checks it.
-            if self.exit_code is None:
-                exit_code = None
-            elif sys.platform == "win32":
-                exit_code = exit_status
-            else:
-                exit_code = os.WEXITSTATUS(exit_status)
-            # Get the output generated by the program.
-            stdout = e.stdout
-            stderr = e.stderr
-            # Record the results.
-            result["ExecTest.exit_code"] = str(exit_code)
-            result["ExecTest.stdout"] = result.Quote(stdout)
-            result["ExecTest.stderr"] = result.Quote(stderr)
-            # Check to see if the exit code matches.
-            if exit_code != self.exit_code:
-                causes.append("exit_code")
-                result["ExecTest.expected_exit_code"] \
-                    = str(self.exit_code)
-            # Validate the output.
-            causes += self.ValidateOutput(stdout, stderr, result)
-            # If anything went wrong, the test failed.
-            if causes:
-                result.Fail("Unexpected %s." % string.join(causes, ", ")) 
-        elif os.WIFSIGNALED(exit_status):
-            # The target program terminated with a signal.  Construe
-            # that as a test failure.
-            signal_number = str(os.WTERMSIG(exit_status))
-            result.Fail("Program terminated by signal.")
-            result["ExecTest.signal_number"] = signal_number
-        elif os.WIFSTOPPED(exit_status):
-            # The target program was stopped.  Construe that as a
-            # test failure.
-            signal_number = str(os.WSTOPSIG(exit_status))
-            result.Fail("Program stopped by signal.")
-            result["ExecTest.signal_number"] = signal_number
-        else:
-            # The target program terminated abnormally in some other
-            # manner.  (This shouldn't normally happen...)
-            result.Fail("Program did not terminate normally.")
+        causes = []
+        # Validate the exit status.
+        if not result.CheckExitStatus('ExecTest.', 'Program',
+                                      status, self.exit_code):
+            causes.append("exit_code")
+            result["ExecTest.expected_exit_code"] = str(self.exit_code)
+
+        result["ExecTest.stdout"] = result.Quote(e.stdout)
+        result["ExecTest.stderr"] = result.Quote(e.stderr)
+
+        # Validate the output.
+        causes += self.ValidateOutput(e.stdout, e.stderr, result)
+        # If anything went wrong, the test failed.
+        if causes:
+            result.Fail("Unexpected %s." % string.join(causes, ", ")) 
 
 
     def __CompareText(self, s1, s2):
Index: qm/test/classes/compilation_test.py
===================================================================
RCS file: qm/test/classes/compilation_test.py
diff -N qm/test/classes/compilation_test.py
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ qm/test/classes/compilation_test.py	26 Oct 2005 02:46:57 -0000
@@ -0,0 +1,107 @@
+########################################################################
+#
+# File:   compilation_test.py
+# Author: Stefan Seefeld
+# Date:   2005-10-17
+#
+# Contents:
+#   SimpleCompilationTest
+#   SimpleCompiledResource
+#
+# Copyright (c) 2005 by CodeSourcery, LLC.  All rights reserved. 
+#
+# For license terms see the file COPYING.
+#
+########################################################################
+
+from compiler_test import CompilationStep, CompilerTest
+from   qm.fields import *
+from   qm.test.result import *
+from   qm.test.test import *
+from   qm.test.resource import *
+from   compiler import Compiler
+from   local_host import LocalHost
+
+########################################################################
+# Classes
+########################################################################
+
+class SimpleCompilationTest(CompilerTest):
+    """A SimpleCompilationTest compiles source files and optionally runs the
+    generated executable."""
+
+    options = SetField(TextField(description="""Test-specific options to pass to the compiler."""))
+    source_files = SetField(TextField(description="Source files to be compiled."))
+    executable = TextField(description="The name of the executable to be compiled.")
+    execute = BooleanField(default_value = True,
+        description="Whether or not to run the compiled executable.")
+    
+
+    def Run(self, context, result):
+
+        self._MakeDirectory(context)
+        CompilerTest.Run(self, context, result)
+        self._RemoveDirectory(context, result)
+
+
+    def _GetCompiler(self, context):
+        """The name of the compiler executable is taken from the context variable
+        'SimpleCompileTest.compiler_path'."""
+
+        name = context["SimpleCompilationTest.compiler_path"]
+        options = context.get("SimpleCompilationTest.compiler_options", [])
+        return Compiler(name, options)
+
+
+    def _GetCompilationSteps(self, context):
+
+        # Compile the executable in a single step so we can apply all
+        # options at once.
+        return [CompilationStep(Compiler.MODE_LINK, self.source_files,
+                                self.options, self.executable, [])]
+
+
+    def _IsExecutionRequired(self):
+
+        return self.execute
+
+
+    def _GetTarget(self, context):
+
+        # Run the executable locally.
+        return LocalHost({})
+        
+
+    def _CheckOutput(self, context, result, prefix, output, diagnostics):
+
+        if output:
+            result[prefix + "output"] = result.Quote(output)
+
+        return True
+
+
+class SimpleCompiledResource(Resource):
+    """A SimpleCompiledResource compiles source files into an executable which then
+    is available for execution to dependent test instances."""
+
+    options = SetField(TextField(description="Resource-specific options to pass to the compiler."))
+    source_files = SetField(TextField(description="Source files to be compiled."))
+    executable = TextField(description="The name of the executable to be compiled.")
+
+
+    def SetUp(self, context, result):
+
+        compiler = SimpleCompilationTest({'options':self.options,
+                                          'source_files':self.source_files,
+                                          'executable':self.executable,
+                                          'execute':False})
+        
+        compiler.Run(self, context, result)
+        context['SimpleCompiledResource.executable'] = self.executable
+        
+
+    def CleanUp(self, result):
+
+        # Whether or not to clean up (i.e. remove the executable) is best
+        # expressed via the context.
+        pass
Index: qm/test/classes/compiler_test.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/compiler_test.py,v
retrieving revision 1.2
diff -u -r1.2 compiler_test.py
--- qm/test/classes/compiler_test.py	10 Jun 2005 21:23:21 -0000	1.2
+++ qm/test/classes/compiler_test.py	26 Oct 2005 02:46:57 -0000
@@ -14,10 +14,9 @@
 ########################################################################
 
 from   compiler import *
-import errno
 from   qm.test.result import *
 from   qm.test.test import *
-import string
+import os, string
 
 ########################################################################
 # Classes
@@ -52,51 +51,6 @@
 class CompilerBase:
     """A 'CompilerBase' is used by compilation test and resource clases."""
 
-    def _CheckStatus(self, result, prefix, desc, status,
-                     non_zero_exit_ok = 0):
-        """Check the exit status from a command.
-
-        'result' -- The 'Result' object to update.
-
-        'prefix' -- The prefix that should be used when creating
-        result annotations.
-
-        'desc' -- A description of the executing program.
-        
-        'status' -- The exit status, as returned by 'waitpid'.
-
-        'non_zero_exit_ok' -- True if a non-zero exit code is not
-        considered failure.
-
-        returns -- False is the test failed, true otherwise."""
-
-        if sys.platform == "win32" or os.WIFEXITED(status):
-            # Obtain the exit code.
-            if sys.platform == "win32":
-                exit_code = status
-            else:
-                exit_code = os.WEXITSTATUS(status)
-            # If the exit code is non-zero, the test fails.
-            if exit_code != 0 and not non_zero_exit_ok:
-                result.Fail("%s failed with exit code %d." % (desc, exit_code))
-                # Record the exit code in the result.
-                result[prefix + "exit_code"] = str(exit_code)
-                return 0
-        elif os.WIFSIGNALED(status):
-            # Obtain the signal number.
-            signal = os.WTERMSIG(status)
-            # If the program gets a fatal signal, the test fails .
-            result.Fail("%s received fatal signal %d." % (desc, signal))
-            result[prefix + "signal"] = str(signal)
-            return 0
-        else:
-            # A process should only be able to stop by exiting, or
-            # by being terminated with a signal.
-            assert None
-
-        return 1
-    
-
     def _GetDirectory(self, context):
         """Get the name of the directory in which to run.
 
@@ -113,27 +67,6 @@
             return os.path.join(".", "build", self.GetId())
     
         
-    def _MakeDirectoryRecursively(self, directory):
-        """Create 'directory' and its parents.
-
-        'directory' -- The name of the directory to create.  It must
-        be a relative path"""
-
-        (parent, base) = os.path.split(directory)
-        # Make sure the parent directory exists.
-        if parent and not os.path.isdir(parent):
-            self._MakeDirectoryRecursively(parent)
-        # Create the final directory.
-        try:
-            os.mkdir(directory)
-        except EnvironmentError, e:
-            # It's OK if the directory already exists.
-            if e.errno == errno.EEXIST:
-                pass
-            else:
-                raise
-            
-            
     def _MakeDirectory(self, context):
         """Create a directory in which to place generated files.
 
@@ -145,7 +78,7 @@
         # Get the directory name.
         directory = self._GetDirectory(context)
         # Create it.
-        self._MakeDirectoryRecursively(directory)
+        os.makedirs(directory)
 
         return directory
 
@@ -161,7 +94,7 @@
         if result.GetOutcome() == Result.PASS:
             try:
                 dir = self._GetDirectory(context)
-                qm.common.rmdir_recursively(dir)
+                os.removedirs(directory)
             except:
                 # If the directory cannot be removed, that is no
                 # reason for the test to fail.
@@ -245,8 +178,10 @@
                 desc = "Link"
             else:
                 desc = "Compilation"
-            if not self._CheckStatus(result, prefix, desc, status,
-                                     step.diagnostics):
+            # If step.diagnostics is non-empty, a non-zero status
+            # is not considered a failure.
+            if not result.CheckExitStatus(prefix, desc, status,
+                                          step.diagnostics):
                 return
 
             # If this compilation generated an executable, remember
@@ -282,6 +217,16 @@
         raise NotImplementedError
 
 
+    def _GetTarget(self, context):
+        """Returns a target for the executable to be run on.
+
+        'context' -- The Context in which this test is being executed.
+
+        returns -- A Host to run the executable on."""
+
+        raise NotImplementedError
+
+
     def _IsExecutionRequired(self):
         """Returns true if the generated executable should be run.
 
@@ -347,7 +292,7 @@
             # Use the default values.
             environment = None
 
-        target = context["CompilerTable.target"]
+        target = self._GetTarget(context)
         timeout = context.get("CompilerTest.execution_timeout", -1)
         status, output = target.UploadAndRun(path,
                                              [],
@@ -357,7 +302,7 @@
         # Record the output.
         result[prefix + "output"] = result.Quote(output)
         # Check the output status.
-        self._CheckStatus(result, prefix, "Executable", status)
+        result.CheckExitStatus(prefix, "Executable", status)
 
 
     def _CheckOutput(self, context, result, prefix, output, diagnostics):
