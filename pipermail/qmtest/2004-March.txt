From mark at codesourcery.com  Tue Mar  2 03:30:27 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 01 Mar 2004 19:30:27 -0800
Subject: [qmtest] exceptions.TypeError: All dictionary items must be strings,
 or all must be unicode
In-Reply-To: <000401c3fca0$9e8ea020$7588229b@meriadoc>
References: <000401c3fca0$9e8ea020$7588229b@meriadoc>
Message-ID: <4043FFD3.6080103@codesourcery.com>

Andrew Funk wrote:

>Hi Mark,
>
>Yes, that was it.  The keys are sensitive too, so I actually had to
>change the line to this:
>
>environment[str(variable)] = str(value)
>  
>
Thanks for testing that change!

I researched this problem a little more and made the attached change 
instead.

I've checked this in on the mainline and on the 2.1 branch, but it would 
be great if you could test it out and confirm that it works for you.

Thanks,

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com

-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: diffs
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040301/3f3eaf7b/attachment.ksh>

From mark at codesourcery.com  Tue Mar  2 03:27:27 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 01 Mar 2004 19:27:27 -0800
Subject: [qmtest] qmtest gui under Windows
In-Reply-To: <000001c3fae5$cbe4f360$7588229b@meriadoc>
References: <000001c3fae5$cbe4f360$7588229b@meriadoc>
Message-ID: <4043FF1F.6080708@codesourcery.com>

Andrew Funk wrote:

>Hi,
>
>I am having trouble with the qmtest gui under Windows.  The same thing
>happens with the stable release or the cvs version.  It could be a
>problem with my proxy settings, although I am able to view directories
>and run tests.  However, when I try to edit a test, for example by
>clicking Environment->Add Another, it takes me to the URL
>http://127.0.0.1:1046/test/submit-test and I get an error saying the
>page cannot be displayed.
>
I wasn't able to reproduce this setting.

I can't think of what could be going wrong here, other than either 
firewalling or a botched installation that caused you to be missing the 
template for submit-test -- but even then, I would expect you to get a 
Python traceback in your browser.

Are you still having this problem?

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com



From afunk at ll.mit.edu  Tue Mar  2 19:17:58 2004
From: afunk at ll.mit.edu (Andrew Funk)
Date: Tue, 2 Mar 2004 14:17:58 -0500
Subject: [qmtest] exceptions.TypeError: All dictionary items must be strings, or all must be unicode
In-Reply-To: <4043FFD3.6080103@codesourcery.com>
Message-ID: <000e01c4008b$1322fa10$7588229b@meriadoc>

Yes, this fixes the problem I was having.

Thanks!
Andy

-----Original Message-----
From: Mark Mitchell [mailto:mark at codesourcery.com] 
Sent: Monday, March 01, 2004 10:30 PM
To: Andrew Funk
Cc: qmtest at codesourcery.com
Subject: Re: [qmtest] exceptions.TypeError: All dictionary items must be
strings, or all must be unicode


Andrew Funk wrote:

>Hi Mark,
>
>Yes, that was it.  The keys are sensitive too, so I actually had to 
>change the line to this:
>
>environment[str(variable)] = str(value)
>  
>
Thanks for testing that change!

I researched this problem a little more and made the attached change 
instead.

I've checked this in on the mainline and on the 2.1 branch, but it would

be great if you could test it out and confirm that it works for you.

Thanks,

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com




From afunk at ll.mit.edu  Tue Mar  2 19:49:07 2004
From: afunk at ll.mit.edu (Andrew Funk)
Date: Tue, 2 Mar 2004 14:49:07 -0500
Subject: [qmtest] qmtest gui under Windows
In-Reply-To: <4043FF1F.6080708@codesourcery.com>
Message-ID: <000f01c4008f$6c65f100$7588229b@meriadoc>

Hi Mark,

I am investigating the possibility that I am not building the Windows
installation correctly.  I have been doing that by running "python
./setup.py bdist_wininst" under Linux, and then running the resultant
.exe file under Windows.  So I think the first thing I need to do is
make sure I am building under Linux correctly.

[as an aside, could you describe to me how you build the windows
installation of the CVS code?  I would like to duplicate that and see
what happens]

I have installed Python 2.3 in my user space under Linux, and I'm pretty
sure that was working with the release version of QMTest.  However, when
I specify this python interpreter when building the cvs code, the
resulting qmtest script won't run.

Example:

./configure --with-python=/home/afunk/Python-2.3/python
--prefix=/home/afunk/qm
make
make install

The resultant qmtest script has the following first line:

#!/usr/local/bin/python

My system has no python interpreter at this location.  I can still run
the qmtest script by running "python ./qmtest", but this is not
desirable and I wonder what the problem is.

There is a python 2.2 interpreter in my default path, and I have been
allowing qmtest to use it by not specifying a --with-python parameter to
configure.  When I do this the resultant qmtest script will run.
However I wonder if I am running into some compatibility problems
between 2.2 and 2.3, or between Linux and Windows....

As usual I have asked a lot of questions so hopefully you can sort
through it all!

Thanks,
Andy

-----Original Message-----
From: Mark Mitchell [mailto:mark at codesourcery.com] 
Sent: Monday, March 01, 2004 10:27 PM
To: Andrew Funk
Cc: 'QMTest List'
Subject: Re: [qmtest] qmtest gui under Windows


Andrew Funk wrote:

>Hi,
>
>I am having trouble with the qmtest gui under Windows.  The same thing
>happens with the stable release or the cvs version.  It could be a 
>problem with my proxy settings, although I am able to view directories 
>and run tests.  However, when I try to edit a test, for example by 
>clicking Environment->Add Another, it takes me to the URL 
>http://127.0.0.1:1046/test/submit-test and I get an error saying the 
>page cannot be displayed.
>
I wasn't able to reproduce this setting.

I can't think of what could be going wrong here, other than either 
firewalling or a botched installation that caused you to be missing the 
template for submit-test -- but even then, I would expect you to get a 
Python traceback in your browser.

Are you still having this problem?

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com




From njs at pobox.com  Wed Mar  3 05:13:51 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Tue, 2 Mar 2004 21:13:51 -0800
Subject: [PATCH] Typo in explicit_suite argument description
Message-ID: <20040303051350.GA32705@njs.ddts.net>

Applied.

-- Nathaniel

-- 
Civil rights were not compatible with European unification. But I'm much
happier now that all our strawberries are the same size.   -- dark
-------------- next part --------------
? results.qmr
? qm/external/__init__.pyc
? tests/regress/QMTest/regression_database.pyc
? tests/regress/QMTest/selftest.pyc
? tests/regress/tuple1/QMTest/tuple_test.pyc
? tests/results_files/QMTest/results_file_database.pyc
? tests/results_files/QMTest/results_file_test.pyc
Index: ChangeLog
===================================================================
RCS file: /home/qm/Repository/qm/ChangeLog,v
retrieving revision 1.610
diff -u -r1.610 ChangeLog
--- ChangeLog	2 Mar 2004 03:24:41 -0000	1.610
+++ ChangeLog	3 Mar 2004 05:12:45 -0000
@@ -1,3 +1,8 @@
+2004-03-02  Nathaniel Smith  <njs at codesourcery.com>
+
+	* qm/test/classes/explicit_suite.py (arguments): Fix formatting
+	of description for 'is_implicit'.
+
 2004-03-01  Mark Mitchell  <mark at codesourcery.com>
 
 	* qm/executable.py (Executable.Spawn): Under Windows, convert all
Index: qm/test/classes/explicit_suite.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/explicit_suite.py,v
retrieving revision 1.2
diff -u -r1.2 explicit_suite.py
--- qm/test/classes/explicit_suite.py	28 Jan 2004 19:50:51 -0000	1.2
+++ qm/test/classes/explicit_suite.py	3 Mar 2004 05:12:45 -0000
@@ -40,7 +40,7 @@
                 description = """The the suites contained in this suite.""")),
         BooleanField(name = "is_implicit",
                      title = "Implicit?",
-                     description = """,
+                     description = """\
                      True if this test is implicitly generated by QMTest.""",
                      default_value = "false"),
         ]

From njs at pobox.com  Wed Mar  3 05:39:50 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Tue, 2 Mar 2004 21:39:50 -0800
Subject: [PATCH] Several fixes to dg_test.py
Message-ID: <20040303053950.GB32705@njs.ddts.net>

This is a docstring fix, plus some tweaks to improve DejaGNU
compatibility in output.

-- Nathaniel

-- 
"Lull'd in the countless chambers of the brain,
Our thoughts are link'd by many a hidden chain:
Awake but one, and lo! what myriads rise!
Each stamps its image as the other flies"
  -- Ann Ward Radcliffe, The Mysteries of Udolpho
-------------- next part --------------
? results.qmr
? qm/external/__init__.pyc
? tests/regress/QMTest/regression_database.pyc
? tests/regress/QMTest/selftest.pyc
? tests/regress/tuple1/QMTest/tuple_test.pyc
? tests/results_files/QMTest/results_file_database.pyc
? tests/results_files/QMTest/results_file_test.pyc
Index: ChangeLog
===================================================================
RCS file: /home/qm/Repository/qm/ChangeLog,v
retrieving revision 1.611
diff -u -r1.611 ChangeLog
--- ChangeLog	3 Mar 2004 05:12:58 -0000	1.611
+++ ChangeLog	3 Mar 2004 05:39:41 -0000
@@ -1,3 +1,11 @@
+2004-01-14  Nathaniel Smith  <njs at codesourcery.com>
+
+	* qm/test/classes/dg_test.py (DGTest._RunDGTest): Fix formatting
+	of paths to match DejaGNU.
+	(DGTest._DGBogus): Fix copy/paste error in docstring.
+	(DGTest.__ExpectDiagnostic): Use "" rather than 'None' to denote
+	empty comment, to match DejaGNU.
+
 2004-03-02  Nathaniel Smith  <njs at codesourcery.com>
 
 	* qm/test/classes/explicit_suite.py (arguments): Fix formatting
Index: qm/test/classes/dg_test.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/dg_test.py,v
retrieving revision 1.3
diff -u -r1.3 dg_test.py
--- qm/test/classes/dg_test.py	23 Jun 2003 06:46:47 -0000	1.3
+++ qm/test/classes/dg_test.py	3 Mar 2004 05:39:41 -0000
@@ -127,7 +127,8 @@
         if path.startswith(root):
             self._name = path[len(root) + 1:]
         else:
-            self._name = os.path.basename(path)
+            # We prepend "./" for compatibility with DejaGNU.
+            self._name = os.path.join(".", os.path.basename(path))
         for l in open(path).xreadlines():
             line_num += 1
             m = self.__dg_command_regexp.search(l)
@@ -345,7 +346,7 @@
 
 
     def _DGbogus(self, line_num, args, context):
-        """Emulate the 'dg-warning' command.
+        """Emulate the 'dg-bogus' command.
 
         'line_num' -- The number at which the command was found.
 
@@ -417,7 +418,7 @@
         if len(args) >= 2:
             comment = args[1]
         else:
-            comment = None
+            comment = ""
             
         self._diagnostics.append((line_num, kind, expectation,
                                   args[0], comment))

From mark at codesourcery.com  Wed Mar  3 05:41:31 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 02 Mar 2004 21:41:31 -0800
Subject: [qmtest] [PATCH] Several fixes to dg_test.py
In-Reply-To: <20040303053950.GB32705@njs.ddts.net>
References: <20040303053950.GB32705@njs.ddts.net>
Message-ID: <4045700B.4010307@codesourcery.com>

Nathaniel Smith wrote:

> This is a docstring fix, plus some tweaks to improve DejaGNU
> compatibility in output.

Looks good.

Thanks!

-- 
Mark Mitchell
CodeSourcery, LLC
mark at codesourcery.com


From mark at codesourcery.com  Wed Mar  3 07:11:50 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 02 Mar 2004 23:11:50 -0800
Subject: [qmtest] qmtest gui under Windows
In-Reply-To: <000f01c4008f$6c65f100$7588229b@meriadoc>
References: <000f01c4008f$6c65f100$7588229b@meriadoc>
Message-ID: <40458536.80301@codesourcery.com>

Andrew Funk wrote:

> Hi Mark,
> 
> I am investigating the possibility that I am not building the Windows
> installation correctly.  I have been doing that by running "python
> ./setup.py bdist_wininst" under Linux, and then running the resultant
> .exe file under Windows.  So I think the first thing I need to do is
> make sure I am building under Linux correctly.

That's how I do it when I want to test under Windows.

I don't ever build directly under Windows.

But, just for kicks, I did just now.

The following *should* work:

   c:\Python23\python setup.py build
   c:\Python23\python setup.py install --prefix ..\..\install

(Note that --prefix cannot take an absolute path on Windows.)

It turns out that there was a glitch in some of the packaging goo that 
got us in that mode, which is fixed with the attached patch, now 
committed to both the mainline and the 2.1 branch.

> Example:
> 
> ./configure --with-python=/home/afunk/Python-2.3/python
> --prefix=/home/afunk/qm
> make
> make install
> 
> The resultant qmtest script has the following first line:

That sounds like a bug in your installation of Python.  If you start 
/home/afunk/Python-2.3/python, and do:

   import sys
   print sys.executable

what does it show you?

Would you send everything that shows up in your terminal when you do the 
commands shown above?

-- 
Mark Mitchell
CodeSourcery, LLC
mark at codesourcery.com
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: diffs
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040302/12ff5d1d/attachment.ksh>

From afunk at ll.mit.edu  Wed Mar  3 14:49:44 2004
From: afunk at ll.mit.edu (Andrew Funk)
Date: Wed, 3 Mar 2004 09:49:44 -0500
Subject: [qmtest] qmtest gui under Windows
In-Reply-To: <40458536.80301@codesourcery.com>
Message-ID: <001101c4012e$c44a3ee0$7588229b@meriadoc>

> -----Original Message-----
> From: Mark Mitchell [mailto:mark at codesourcery.com] 
> Sent: Wednesday, March 03, 2004 2:12 AM
> To: Andrew Funk
> Cc: 'QMTest List'
> Subject: Re: [qmtest] qmtest gui under Windows
> 
> That sounds like a bug in your installation of Python.  If you start 
> /home/afunk/Python-2.3/python, and do:
> 
>    import sys
>    print sys.executable
> 
> what does it show you?

[afunk at dn01 ~]$ python
Python 2.3 (#1, Aug 19 2003, 15:21:20) 
[GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-110)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> sys.executable
'/home/afunk/Python-2.3/python'
>>> 



> Would you send everything that shows up in your terminal when 
> you do the 
> commands shown above?

[afunk at dn01 ~]$ cd archives/cvs/qm
[afunk at dn01 qm]$ ./configure --with-python=/home/afunk/Python-2.3/python
--prefi
x=/home/afunk/qm
checking for /home/afunk/Python-2.3/python... yes
checking Python version... 2.3
checking Python platform... linux-i686
checking for happydoc... no
configure: WARNING: Documentation is only built with
--enable-maintainer-mode.
configure: creating ./config.status
config.status: creating GNUmakefile



[afunk at dn01 qm]$ make
PYTHONPATH=. /home/afunk/Python-2.3/python -O ./setup.py build
running build
running build_py
copying qm/test/qmtest.py -> build/lib/qm/test
running build_scripts
copying and adjusting qm/test/qmtest.py -> build/scripts-2.3



[afunk at dn01 qm]$ make install
PYTHONPATH=. /home/afunk/Python-2.3/python -O ./setup.py build
running build
running build_py
copying qm/test/qmtest.py -> build/lib/qm/test
running build_scripts
copying and adjusting qm/test/qmtest.py -> build/scripts-2.3
PYTHONPATH=. /home/afunk/Python-2.3/python -O ./setup.py install -O1 \
        --prefix="/home/afunk/qm" \
        --install-data="/home/afunk/qm/share" \
        --install-lib="/home/afunk/qm/lib" \
        --install-scripts="/home/afunk/qm/bin"
running install
running build
running build_py
copying qm/test/qmtest.py -> build/lib/qm/test
running build_scripts
running install_lib
creating /home/afunk/qm
creating /home/afunk/qm/lib
creating /home/afunk/qm/lib/qm
copying build/lib/qm/__init__.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/__version.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/attachment.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/cmdline.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/common.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/db.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/diagnostic.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/executable.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/extension.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/fields.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/label.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/lock.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/platform.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/platform_unix.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/platform_win32.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/queue.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/setup.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/structured_text.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/trace.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/user.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/temporary_directory.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/web.py -> /home/afunk/qm/lib/qm
copying build/lib/qm/xmlutil.py -> /home/afunk/qm/lib/qm
creating /home/afunk/qm/lib/qm/external
copying build/lib/qm/external/__init__.py ->
/home/afunk/qm/lib/qm/external
creating /home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_Raise.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_HTML.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_If.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_In.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_InSV.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_Let.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DocumentTemplate.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_Return.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_String.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_Try.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_UI.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_Util.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_Var.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DT_With.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DTtest.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DTtestExpr.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/DTtest_basicIn.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/VSEval.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/__init__.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/gparse.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/gparse_test.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/pDocumentTemplate.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/setup.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
copying build/lib/qm/external/DocumentTemplate/ts_regex.py ->
/home/afunk/qm/lib/qm/external/DocumentTemplate
creating /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/__init__.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/base.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/cmdline.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/context.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/resource.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/command_thread.py ->
/home/afunk/qm/lib/qm/test
copying build/lib/qm/test/database.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/directory_suite.py ->
/home/afunk/qm/lib/qm/test
copying build/lib/qm/test/execution_engine.py ->
/home/afunk/qm/lib/qm/test
copying build/lib/qm/test/execution_thread.py ->
/home/afunk/qm/lib/qm/test
copying build/lib/qm/test/file_database.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/file_result_reader.py ->
/home/afunk/qm/lib/qm/test
copying build/lib/qm/test/file_result_stream.py ->
/home/afunk/qm/lib/qm/test
copying build/lib/qm/test/result_stream.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/result.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/result_reader.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/runnable.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/suite.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/target.py -> /home/afunk/qm/lib/qm/test
copying build/lib/qm/test/test.py -> /home/afunk/qm/lib/qm/test
creating /home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/__init__.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/pickle_result_stream.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/command.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/dejagnu_base.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/dejagnu_stream.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/dejagnu_test.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/dg_test.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/explicit_suite.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/file.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/file_label.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/mount_database.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/process_target.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/python.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/python_label.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/rsh_target.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/serial_target.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/sql_result_stream.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/temporary.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/tet_stream.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/classes.qmc ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/text_result_stream.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/thread_target.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/xml_database.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/classes/xml_result_stream.py ->
/home/afunk/qm/lib/qm/test/classes
copying build/lib/qm/test/qmtest.py -> /home/afunk/qm/lib/qm/test
creating /home/afunk/qm/lib/qm/test/web
copying build/lib/qm/test/web/__init__.py ->
/home/afunk/qm/lib/qm/test/web
copying build/lib/qm/test/web/web.py -> /home/afunk/qm/lib/qm/test/web
writing byte-compilation script '/tmp/tmpsPwG_w.py'
/home/afunk/Python-2.3/python /tmp/tmpsPwG_w.py
removing /tmp/tmpsPwG_w.py
writing byte-compilation script '/tmp/tmp4h4wid.py'
/home/afunk/Python-2.3/python -O /tmp/tmp4h4wid.py
removing /tmp/tmp4h4wid.py
running install_scripts
creating /home/afunk/qm/bin
copying build/scripts-2.3/qmtest -> /home/afunk/qm/bin
copying build/scripts-2.3/qmtest.py -> /home/afunk/qm/bin
changing mode of /home/afunk/qm/bin/qmtest to 755
changing mode of /home/afunk/qm/bin/qmtest.py to 755
running install_data
creating /home/afunk/qm/share
creating /home/afunk/qm/share/qm
creating /home/afunk/qm/share/qm/messages
creating /home/afunk/qm/share/qm/messages/test
copying qm/test/share/messages/help.txt ->
/home/afunk/qm/share/qm/messages/test
copying qm/test/share/messages/diagnostics.txt ->
/home/afunk/qm/share/qm/messages/test
creating /home/afunk/qm/share/qm/dtml
creating /home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/expectations.dtml ->
/home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/context.dtml ->
/home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/dir.dtml -> /home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/new-suite.dtml ->
/home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/load.dtml ->
/home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/navigation-bar.dtml ->
/home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/new.dtml -> /home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/result.dtml ->
/home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/results.dtml ->
/home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/set-expectation.dtml ->
/home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/show.dtml ->
/home/afunk/qm/share/qm/dtml/test
copying qm/test/share/dtml/suite.dtml ->
/home/afunk/qm/share/qm/dtml/test
creating /home/afunk/qm/share/qm/doc
copying README -> /home/afunk/qm/share/qm/doc
copying COPYING -> /home/afunk/qm/share/qm/doc
creating /home/afunk/qm/share/qm/doc/test
creating /home/afunk/qm/share/qm/doc/test/html
creating /home/afunk/qm/share/qm/doc/test/print
creating /home/afunk/qm/share/qm/tutorial
creating /home/afunk/qm/share/qm/tutorial/test
creating /home/afunk/qm/share/qm/tutorial/test/tdb
copying qm/test/share/tutorial/tdb/exec0.qmt ->
/home/afunk/qm/share/qm/tutorial/test/tdb
copying qm/test/share/tutorial/tdb/exec1.qmt ->
/home/afunk/qm/share/qm/tutorial/test/tdb
copying qm/test/share/tutorial/tdb/exec2.qmt ->
/home/afunk/qm/share/qm/tutorial/test/tdb
creating /home/afunk/qm/share/qm/tutorial/test/tdb/QMTest
copying qm/test/share/tutorial/tdb/QMTest/configuration ->
/home/afunk/qm/share/qm/tutorial/test/tdb/QMTest
creating /home/afunk/qm/share/qm/xml
copying share/xml/fields.mod -> /home/afunk/qm/share/qm/xml
creating /home/afunk/qm/share/qm/web
creating /home/afunk/qm/share/qm/web/images
copying share/web/images/left-arrow.gif ->
/home/afunk/qm/share/qm/web/images
copying share/web/images/clear.gif -> /home/afunk/qm/share/qm/web/images
copying share/web/images/right-arrow.gif ->
/home/afunk/qm/share/qm/web/images
copying share/web/images/logo.gif -> /home/afunk/qm/share/qm/web/images
copying share/dtml/add-enumeral.dtml -> /home/afunk/qm/share/qm/dtml
copying share/dtml/attachment.dtml -> /home/afunk/qm/share/qm/dtml
copying share/dtml/error.dtml -> /home/afunk/qm/share/qm/dtml
copying share/dtml/exception.dtml -> /home/afunk/qm/share/qm/dtml
copying share/dtml/field.dtml -> /home/afunk/qm/share/qm/dtml
copying share/dtml/help.dtml -> /home/afunk/qm/share/qm/dtml
copying share/dtml/login_form.dtml -> /home/afunk/qm/share/qm/dtml
copying share/dtml/problems.dtml -> /home/afunk/qm/share/qm/dtml
copying share/dtml/set.dtml -> /home/afunk/qm/share/qm/dtml
copying share/dtml/user.dtml -> /home/afunk/qm/share/qm/dtml
copying share/web/common.js -> /home/afunk/qm/share/qm/web
creating /home/afunk/qm/share/qm/web/stylesheets
copying share/web/stylesheets/qm.css ->
/home/afunk/qm/share/qm/web/stylesheets
creating /home/afunk/qm/share/qm/diagnostics
copying share/diagnostics/common-help.txt ->
/home/afunk/qm/share/qm/diagnostics
copying share/diagnostics/common.txt ->
/home/afunk/qm/share/qm/diagnostics
[afunk at dn01 qm]$ 



[afunk at dn01 ~]$ which qmtest
/home/afunk/qm/bin/qmtest
[afunk at dn01 ~]$ qmtest
qmtest: Command not found.
[afunk at dn01 ~]$ cd qm/bin
[afunk at dn01 bin]$ ./qmtest
./qmtest: Command not found.
[afunk at dn01 bin]$ cat qmtest
#!/usr/local/bin/python



From mark at codesourcery.com  Thu Mar  4 02:40:30 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 03 Mar 2004 18:40:30 -0800
Subject: [qmtest] qmtest gui under Windows
In-Reply-To: <001101c4012e$c44a3ee0$7588229b@meriadoc>
References: <001101c4012e$c44a3ee0$7588229b@meriadoc>
Message-ID: <4046971E.9010107@codesourcery.com>

Andrew Funk wrote:

>>-----Original Message-----
>>From: Mark Mitchell [mailto:mark at codesourcery.com] 
>>Sent: Wednesday, March 03, 2004 2:12 AM
>>To: Andrew Funk
>>Cc: 'QMTest List'
>>Subject: Re: [qmtest] qmtest gui under Windows
>>
>>That sounds like a bug in your installation of Python.  If you start 
>>/home/afunk/Python-2.3/python, and do:
>>
>>   import sys
>>   print sys.executable
>>
>>what does it show you?
>>    
>>
>
>[afunk at dn01 ~]$ python
>Python 2.3 (#1, Aug 19 2003, 15:21:20) 
>[GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-110)] on linux2
>Type "help", "copyright", "credits" or "license" for more information.
>  
>
Andy --

This is very strange.

When I do the exact same thing, it works fine for me; I get the correct path to the Python interpreter embedded in the qmtest script.  The code that does this is in distutils/commands/build_scripts.py in the Python distribution.  The best thing I can think of is that maybe the Python you have was originally installed in /usr/local -- or built with a --prefix=/usr/local, and that it was then copied into your home directory, and that therefore the compiled version of build_scripts.pyc contains bogus data somehow.

I'm sorry not to be more help: I think you'll have to debug through your local distutils to figure out what's going wrong.

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com



From slowrey at nextone.com  Sat Mar  6 18:42:32 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Sat, 06 Mar 2004 13:42:32 -0500
Subject: Location of Extensions?
Message-ID: <404A1B98.1040605@nextone.com>

An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040306/985cc986/attachment.html>

From mark at codesourcery.com  Sun Mar  7 18:14:10 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 07 Mar 2004 10:14:10 -0800
Subject: [qmtest] Location of Extensions?
In-Reply-To: <404A1B98.1040605@nextone.com>
References: <404A1B98.1040605@nextone.com>
Message-ID: <404B6672.7020200@codesourcery.com>

Scott Lowrey wrote:


> The standalone directory is what I'm leaning towards, for no other 
> reason than to keep the qm and python library trees relatively clean.

That would be my choice as well.

-- 
Mark Mitchell
CodeSourcery, LLC
mark at codesourcery.com


From afunk at ll.mit.edu  Wed Mar 10 15:39:19 2004
From: afunk at ll.mit.edu (Andrew Funk)
Date: Wed, 10 Mar 2004 10:39:19 -0500
Subject: result.dtd
Message-ID: <003f01c406b5$da7c6850$7588229b@meriadoc>

Hi,

I am encountering a problem that I had last September.

When I try to read the output created with XMLResultStream my browser
can't find this resource:

http://www.codesourcery.com/qm/dtds/2.2/qmtest/result.dtd

Is this really not available, or is it something else wrong with my
configuration?

I know from past experience there is a result.dtd included with the
distribution that I can use instead.  Maybe it would be better to have
the XML point to a local copy of the result.dtd?

Thanks,
Andy



From webnetcn at tom.com  Sat Mar 13 00:35:51 2004
From: webnetcn at tom.com (=?GB2312?B?uuPL2bTv?=)
Date: Sat, 13 Mar 2004 08:35:51 +0800
Subject: =?GB2312?B?uuPL2bTv0OnE4tb3u/q827jxtffV+82o1qqjoQ==?=
Message-ID: <mailman.0.1331165133.19722.qmtest@codesourcery.com>

An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040313/14916e52/attachment.html>

From njs at pobox.com  Mon Mar 15 21:09:07 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Mon, 15 Mar 2004 13:09:07 -0800
Subject: [PATCH] Misc. fixes for DejaGNU and TET emulation
Message-ID: <20040315210907.GA15514@njs.ddts.net>

- Fixes a number of bugs in DejaGNU and TET emulation.
- Improves error reporting for resource extensions that fail to load.

-- Nathaniel

-- 
"But suppose I am not willing to claim that.  For in fact pianos
are heavy, and very few persons can carry a piano all by themselves."
-------------- next part --------------
? results.qmr
? qm/external/__init__.pyc
? tests/regress/QMTest/regression_database.pyc
? tests/regress/QMTest/selftest.pyc
? tests/regress/tuple1/QMTest/tuple_test.pyc
? tests/results_files/QMTest/results_file_database.pyc
? tests/results_files/QMTest/results_file_test.pyc
Index: ChangeLog
===================================================================
RCS file: /home/qm/Repository/qm/ChangeLog,v
retrieving revision 1.613
diff -u -r1.613 ChangeLog
--- ChangeLog	3 Mar 2004 07:12:12 -0000	1.613
+++ ChangeLog	15 Mar 2004 21:02:45 -0000
@@ -1,3 +1,29 @@
+2004-03-15  Nathaniel Smith  <njs at codesourcery.com>
+
+	* qm/test/base.py (CouldNotLoadExtensionError.__init__): Save
+	'exc_info' value for later use.
+	* qm/test/target.py (qm.test.base): Import it.
+	(Target._SetUpResource): Check for
+	'CouldNotLoadExtensionError'.
+
+	* qm/test/classes/dg_test.py (DGTest._RunDGTest): Clarify
+	comment.
+	Convert to pass tool arguments as a list, not a string.
+	Support 'dg-excess-errors'.
+	(DGTest._RunTool): Convert docstring to describe new argument
+	passing conventions.
+	(DGTest._DGoptions): Convert options immediately from string to
+	list.
+	(DGTest._DGexcess_errors): New method.
+	
+	* qm/test/classes/tet_stream.py (TETStream): Add detailed
+	description of TET/LSB and DejaGNU result codes.  Fix mapping
+	between them.
+	
+	* qm/test/classes/dejagnu_test.py
+	(DejaGNUTest.TargetExecutable._StdinPipe): Don't override.
+	(DejaGNUTest.BuildExecutable._StdinPipe): Don't override.
+
 2004-03-02  Mark Mitchell  <mark at codesourcery.com>
 
 	* qmdist/command/install_scripts.py (install_scripts.run): Handle
Index: qm/test/base.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/base.py,v
retrieving revision 1.96
diff -u -r1.96 base.py
--- qm/test/base.py	3 Jan 2004 04:02:59 -0000	1.96
+++ qm/test/base.py	15 Mar 2004 21:02:45 -0000
@@ -47,6 +47,7 @@
 
         'exc_info' -- An exception tuple, as returned by 'sys.exc_info'."""
         
+        self.exc_info = exc_info
         message = qm.common.format_exception(exc_info)
         message += "\n" + qm.error("could not load extension class",
                                    class_name = class_name)
Index: qm/test/target.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/target.py,v
retrieving revision 1.24
diff -u -r1.24 target.py
--- qm/test/target.py	20 Feb 2004 10:08:52 -0000	1.24
+++ qm/test/target.py	15 Mar 2004 21:02:45 -0000
@@ -21,6 +21,7 @@
 import qm.common
 import qm.extension
 import qm.platform
+import qm.test.base
 from   qm.test.context import *
 from   qm.test.result import *
 from   qm.test.database import NoSuchResourceError
@@ -390,6 +391,9 @@
             result.NoteException(cause="Resource is missing from the database.")
             self._RecordResult(result)
             return (None, result, None)
+        except qm.base.CouldNotLoadExtensionError, e:
+            result.NoteException(e.exc_info,
+                                 cause = "Could not load extension class")
         except KeyboardInterrupt:
             result.NoteException()
             # We received a KeyboardInterrupt, indicating that the
Index: qm/test/classes/dejagnu_test.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/dejagnu_test.py,v
retrieving revision 1.3
diff -u -r1.3 dejagnu_test.py
--- qm/test/classes/dejagnu_test.py	4 Jun 2003 15:57:59 -0000	1.3
+++ qm/test/classes/dejagnu_test.py	15 Mar 2004 21:02:45 -0000
@@ -88,12 +88,6 @@
         Classes derived from 'DejaGNUTest' may provide derived
         versions of this class."""
 
-        def _StdinPipe(self):
-
-            # No input is provided to the program.
-            return None
-
-        
         def _StderrPipe(self):
 
             # Combine stdout/stderr into a single stream.
@@ -106,12 +100,6 @@
         Classes derived from 'DejaGNUTest' may provide derived
         versions of this class."""
 
-        def _StdinPipe(self):
-
-            # No input is provided to the program.
-            return None
-
-        
         def _StderrPipe(self):
 
             # Combine stdout/stderr into a single stream.
Index: qm/test/classes/dg_test.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/dg_test.py,v
retrieving revision 1.4
diff -u -r1.4 dg_test.py
--- qm/test/classes/dg_test.py	3 Mar 2004 05:42:54 -0000	1.4
+++ qm/test/classes/dg_test.py	15 Mar 2004 21:02:45 -0000
@@ -87,13 +87,13 @@
                    keep_output = 0):
         """Run a 'dg' test.
 
-        'tool_flags' -- A string giving a set of options to be
+        'tool_flags' -- A list of strings giving a set of options to be
         provided to the tool being tested.
         
-        'default_options' -- A string giving a default set of options
-        to be provided to the tool being tested.  These options can be
-        overridden by an embedded 'dg-options' command in the test
-        itself.
+        'default_options' -- A list of strings giving a default set of
+        options to be provided to the tool being tested.  These options
+        can be overridden by an embedded 'dg-options' command in the
+        test itself.
         
         'context' -- The 'Context' in which this test is running.
 
@@ -116,8 +116,9 @@
         self._kind = default_kind
         self._selected = None
         self._expectation = None
-        self._options = default_options
+        self._options = list(default_options)
         self._diagnostics = []
+        self._excess_errors_expected = False
         self._final_commands = []
         # Iterate through the test looking for embedded commands.
         line_num = 0
@@ -127,7 +128,7 @@
         if path.startswith(root):
             self._name = path[len(root) + 1:]
         else:
-            # We prepend "./" for compatibility with DejaGNU.
+            # We prepend "./" for output compatibility with DejaGNU.
             self._name = os.path.join(".", os.path.basename(path))
         for l in open(path).xreadlines():
             line_num += 1
@@ -147,7 +148,7 @@
 
         # Run the tool being tested.
         output, file = self._RunTool(path, self._kind,
-                                     tool_flags + " " + self._options,
+                                     tool_flags + self._options,
                                      context,
                                      result)
 
@@ -191,11 +192,17 @@
         output = re.sub(r"\n+", "", output)
         # If there's any output left, the test fails.
         message = self._name + " (test for excess errors)"
+        if self._excess_errors_expected:
+            expected = self.FAIL
+        else:
+            expected = self.PASS
         if output != "":
-            self._RecordDejaGNUOutcome(result, self.FAIL, message)
+            self._RecordDejaGNUOutcome(result, self.FAIL,
+                                       message, expected)
             result["DGTest.excess_errors"] = "<pre>" + output + "</pre>"
         else:
-            self._RecordDejaGNUOutcome(result, self.PASS, message)
+            self._RecordDejaGNUOutcome(result, self.PASS,
+                                       message, expected)
 
         # Run the generated program.
         if self._kind == "run":
@@ -258,8 +265,8 @@
         
         'kind' -- The kind of test to perform.
 
-        'options' -- A string giving command-line options to provide
-        to the tool.
+        'options' -- A list of strings giving command-line options to
+        provide to the tool.
 
         'context' -- The 'Context' for the test execution.
 
@@ -338,11 +345,11 @@
         if len(args) >= 2:
             code = self._ParseTargetSelector(args[1], context)
             if code == "S":
-                self._options = args[0]
+                self._options = self._ParseTclWords(args[0])
             elif code != "N":
                 self._Error("'dg-options': 'xfail' not allowed here")
         else:
-            self._options = args[0]
+            self._options = self._ParseTclWords(args[0])
 
 
     def _DGbogus(self, line_num, args, context):
@@ -382,6 +389,27 @@
         'context' -- The 'Context' in which the test is running."""
 
         self.__ExpectDiagnostic(self.__DIAG_ERROR, line_num, args, context)
+
+
+    def _DGexcess_errors(self, line_num, args, context):
+        """Emulate the 'dg-excess-errors' command.
+
+        'line_num' -- The line number at which the command was found.
+
+        'args' -- The arguments to the command, as a list of
+        strings.
+
+        'context' -- The 'Context' in which the test is running."""
+
+        if len(args) > 2:
+            self._Error("'dg-excess-errors': too many arguments")
+
+        if len(args) >= 2:
+            code = self._ParseTargetSelector(args[1], context)
+            if code in ("F", "S"):
+                self._excess_errors_expected = True
+        else:
+            self._excess_errors_expected = True
 
 
     def __ExpectDiagnostic(self, kind, line_num, args, context):
Index: qm/test/classes/tet_stream.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/tet_stream.py,v
retrieving revision 1.2
diff -u -r1.2 tet_stream.py
--- qm/test/classes/tet_stream.py	20 Feb 2004 10:08:52 -0000	1.2
+++ qm/test/classes/tet_stream.py	15 Mar 2004 21:02:45 -0000
@@ -30,24 +30,102 @@
 
 class TETStream(FileResultStream):
     """A 'TETStream' formats results as a TET journal.
-
-    Provides special handling for 'DejaGNUTest' results.
     
+    Provides special handling for 'DejaGNUTest' results.
+
     TET: http://tetworks.opengroup.org/
     TET journal format: see appendix C and D of
        http://tetworks.opengroup.org/documents/3.7/uguide.pdf
 
-    """
+    For the meaning of TET result codes, we use as guidelines the LSB
+    test faq, question Q1.11:
+        * PASS - a test result belonging to this group is considered to
+          be a pass for compliance testing purposes:
+              o Pass - the test has been executed correctly and to
+                completion without any kind of problem
+              o Warning - the functionality is acceptable, but you
+                should be aware that later revisions of the relevant
+                standards or specification may change the requirements
+                in this area.
+              o FIP - additional information is provided which needs to
+                be checked manually.
+              o Unsupported - an optional feature is not available or
+                not supported in the implementation under test.
+              o Not in Use - some tests may not be required in certain
+                test modes or when an interface can be implemented by a
+                macro or function and there are two versions of the test
+                only one is used.
+              o Untested - no test written to check a particular feature
+                or an optional facility needed to perform a test is not
+                available on the system.
+          [There are also "notimp" and "unapproved" cases mentioned in
+          the LSB-FHS README, but they are otherwise undocumented, and
+          don't correspond to any DejaGNU or QMTest outcomes anyway.]
+        * FAIL - a test result belonging to this group is considered to
+          be a fail for compliance testing purposes (unless the failure
+          has been waived by an agreed Problem Report in the
+          Certification Problem Reporting database):
+              o Fail - the interface did not behave as expected.
+              o Uninitiated - the particular test in question did not
+                start to execute.
+              o Unresolved - the test started but did not reach the
+                point where the test was able to report success or
+                failure.
+              o Unreported - a major error occurred during the testset
+                execution.  (The TET manual calls this NORESULT.)
+    (From http://www.linuxbase.org/test/lsb-runtime-test-faq.html )
+    
+    DejaGNU test results are described as:
+        * PASS - A test has succeeded.
+        * FAIL - A test has produced the bug it was intended to
+          capture.
+        * WARNING - Declares detection of a minor error in the test case
+          itself.  Use WARNING rather than ERROR for cases (such as
+          communication failure to be followed by a retry) where the
+          test case can recover from the error.  Note that sufficient
+          warnings will cause a test to go from PASS/FAIL to
+          UNRESOLVED.
+        * ERROR - Declares a severe error in the testing framework
+          itself.  An ERROR also causes a test to go from PASS/FAIL to
+          UNRESOLVED.
+        * UNRESOLVED - A test produced indeterminate results.  Usually,
+          this means the test executed in an unexpected fashion; this
+          outcome requires that a human being go over results, to
+          determine if the test should have passed or failed.  This
+          message is also used for any test that requires human
+          intervention because it is beyond the abilities of the testing
+          framework.  Any unresolved test should be resolved to PASS or
+          FAIL before a test run can be considered finished.
+
+          Examples:
+              - a test's execution is interrupted
+              - a test does not produce a clear result (because of
+                WARNING or ERROR messages)
+              - a test depends on a previous test case which failed
+        * UNTESTED - a test case that isn't run for some technical
+          reason.  (E.g., a dummy test created as a placeholder for a
+          test that is not yet written.)
+        * UNSUPPORTED - Declares that a test case depends on some
+          facility that does not exist in the testing environment; the
+          test is simply meaningless.
+    (From a combination of DejaGNU manual sections "Core Internal
+    Procedures", "C Unit Testing API", and "A POSIX conforming test
+    framework".)
 
+    """
+    
     # TET result codes:
     PASS = (0, "PASS")
-    FAIL = (1, "FAIL")
-    UNRESOLVED = (2, "UNRESOLVED")
-    NOTINUSE = (3, "NOTINUSE")
+    WARNING = (101, "WARNING")
+    FIP = (102, "FIP")
     UNSUPPORTED = (4, "UNSUPPORTED")
+    NOTINUSE = (3, "NOTINUSE")
     UNTESTED = (5, "UNTESTED")
+
+    FAIL = (1, "FAIL")
     UNINITIATED = (6, "UNINITIATED")
-    NORESULT = (7, "NORESULT")
+    UNRESOLVED = (2, "UNRESOLVED")
+    UNREPORTED = (7, "UNREPORTED")
 
 
     def __init__(self, arguments):
@@ -238,25 +316,6 @@
                             "%i %i %s"
                             % (self._tcc_number, purpose, start_time),
                             "")
-            outcome_num, outcome_name \
-                         = { DejaGNUTest.PASS: self.PASS,
-                             DejaGNUTest.XPASS: self.PASS,
-                             DejaGNUTest.FAIL: self.FAIL,
-                             DejaGNUTest.XFAIL: self.FAIL,
-                             DejaGNUTest.WARNING: self.NORESULT,
-                             DejaGNUTest.ERROR: self.NORESULT,
-                             DejaGNUTest.UNTESTED: self.UNTESTED,
-                             DejaGNUTest.UNRESOLVED: self.UNRESOLVED,
-                             DejaGNUTest.UNSUPPORTED: self.UNSUPPORTED,
-                           }[outcome]
-            # Test purpose result
-            # 220 | activity_number tp_number result time | result-name
-            data = "%i %i %i %s" % (self._tcc_number,
-                                    purpose,
-                                    outcome_num,
-                                    end_time)
-            self._WriteLine(220, data, outcome_name)
-            
             if outcome == DejaGNUTest.WARNING:
                 # Test case information
                 # 520 | activity_num tp_num context block sequence | text
@@ -265,16 +324,37 @@
                                 "%i %i 0 1 1" % (self._tcc_number,
                                                  purpose),
                                 "WARNING")
-            if outcome == DejaGNUTest.ERROR:
-                # Test case controller message
-                # 50 || text describing problem
+            elif outcome == DejaGNUTest.ERROR:
+                # Test case information
+                # 520 | activity_num tp_num context block sequence | text
                 # (see _WriteResultAnnotations for details)
                 self._WriteLine(520,
                                 "%i %i 0 1 1" % (self._tcc_number,
                                                  purpose),
                                 "ERROR")
+            else:
+                outcome_num, outcome_name \
+                    = { DejaGNUTest.PASS: self.PASS,
+                        DejaGNUTest.XPASS: self.PASS,
+                        DejaGNUTest.FAIL: self.FAIL,
+                        DejaGNUTest.XFAIL: self.FAIL,
+                        DejaGNUTest.UNTESTED: self.UNTESTED,
+                        DejaGNUTest.UNRESOLVED: self.UNRESOLVED,
+                        # TET's UNSUPPORTED is like a FAIL for tests
+                        # that check for optional features; UNTESTED is
+                        # the correct correspondent for DejaGNU's
+                        # UNSUPPORTED.
+                        DejaGNUTest.UNSUPPORTED: self.UNTESTED,
+                        }[outcome]
+                # Test purpose result
+                # 220 | activity_number tp_number result time | result-name
+                data = "%i %i %i %s" % (self._tcc_number,
+                                        purpose,
+                                        outcome_num,
+                                        end_time)
+                self._WriteLine(220, data, outcome_name)
 
-            purpose += 1
+                purpose += 1
             
         # Test case end
         # 80 | activity_number completion_status time | text
@@ -297,8 +377,8 @@
 
         outcome_num, outcome_name = { Result.FAIL: self.FAIL,
                                       Result.PASS: self.PASS,
-                                      Result.UNTESTED: self.UNTESTED,
-                                      Result.ERROR: self.NORESULT,
+                                      Result.UNTESTED: self.UNINITIATED,
+                                      Result.ERROR: self.UNREPORTED,
                                     }[result.GetOutcome()]
         # Test purpose result
         # 220 | activity_number tp_number result time | result-name
@@ -307,8 +387,8 @@
         self._WriteLine(220, data, outcome_name)
 
         if result.GetOutcome() == Result.ERROR:
-            # Test case controller message
-            # 50 || text describing problem
+            # Test case information
+            # 520 | activity_num tp_num context block sequence | text
             # (see _WriteResultAnnotations for details)
             self._WriteLine(520,
                             "%i 0 0 1 1" % self._tcc_number,

From mark at codesourcery.com  Mon Mar 15 22:28:13 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 15 Mar 2004 14:28:13 -0800
Subject: [qmtest] [PATCH] Misc. fixes for DejaGNU and TET emulation
In-Reply-To: <20040315210907.GA15514@njs.ddts.net>
References: <20040315210907.GA15514@njs.ddts.net>
Message-ID: <40562DFD.1010803@codesourcery.com>

Nathaniel Smith wrote:

> - Fixes a number of bugs in DejaGNU and TET emulation.
> - Improves error reporting for resource extensions that fail to load.

Yay.

This all looks good.

I was slightly perturbed to see that you had used "False" because I 
thought that was a Python 2.3 feature, but apparently it is in 2.2 as 
well, so that's OK.

Please check in!

-- 
Mark Mitchell
CodeSourcery, LLC
mark at codesourcery.com


From njs at pobox.com  Tue Mar 16 05:12:27 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Mon, 15 Mar 2004 21:12:27 -0800
Subject: [Submitted patch] Typo in previous commit
Message-ID: <20040316051227.GA18870@njs.ddts.net>

-- Nathaniel

-- 
Eternity is very long, especially towards the end.
  -- Woody Allen
-------------- next part --------------
? results.qmr
? qm/external/__init__.pyc
? tests/regress/QMTest/regression_database.pyc
? tests/regress/QMTest/selftest.pyc
? tests/regress/tuple1/QMTest/tuple_test.pyc
? tests/results_files/QMTest/results_file_database.pyc
? tests/results_files/QMTest/results_file_test.pyc
Index: ChangeLog
===================================================================
RCS file: /home/qm/Repository/qm/ChangeLog,v
retrieving revision 1.614
diff -u -r1.614 ChangeLog
--- ChangeLog	15 Mar 2004 23:31:35 -0000	1.614
+++ ChangeLog	16 Mar 2004 05:10:44 -0000
@@ -1,4 +1,9 @@
 2004-03-15  Nathaniel Smith  <njs at codesourcery.com>
+	
+	* qm/test/target.py (Target._SetUpResource): Fix typo from
+	previous commit.
+	
+2004-03-15  Nathaniel Smith  <njs at codesourcery.com>
 
 	* qm/test/base.py (CouldNotLoadExtensionError.__init__): Save
 	'exc_info' value for later use.
Index: qm/test/target.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/target.py,v
retrieving revision 1.25
diff -u -r1.25 target.py
--- qm/test/target.py	15 Mar 2004 23:31:36 -0000	1.25
+++ qm/test/target.py	16 Mar 2004 05:10:44 -0000
@@ -391,7 +391,7 @@
             result.NoteException(cause="Resource is missing from the database.")
             self._RecordResult(result)
             return (None, result, None)
-        except qm.base.CouldNotLoadExtensionError, e:
+        except qm.test.base.CouldNotLoadExtensionError, e:
             result.NoteException(e.exc_info,
                                  cause = "Could not load extension class")
         except KeyboardInterrupt:

From mark at codesourcery.com  Tue Mar 16 06:02:09 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 15 Mar 2004 22:02:09 -0800
Subject: [qmtest] [Submitted patch] Typo in previous commit
In-Reply-To: <20040316051227.GA18870@njs.ddts.net>
References: <20040316051227.GA18870@njs.ddts.net>
Message-ID: <40569861.1030802@codesourcery.com>

\Nathaniel Smith wrote:

>-- Nathaniel
>
>  
>
>------------------------------------------------------------------------
>
>? results.qmr
>? qm/external/__init__.pyc
>? tests/regress/QMTest/regression_database.pyc
>? tests/regress/QMTest/selftest.pyc
>? tests/regress/tuple1/QMTest/tuple_test.pyc
>? tests/results_files/QMTest/results_file_database.pyc
>? tests/results_files/QMTest/results_file_test.pyc
>Index: ChangeLog
>===================================================================
>RCS file: /home/qm/Repository/qm/ChangeLog,v
>retrieving revision 1.614
>diff -u -r1.614 ChangeLog
>--- ChangeLog	15 Mar 2004 23:31:35 -0000	1.614
>+++ ChangeLog	16 Mar 2004 05:10:44 -0000
>@@ -1,4 +1,9 @@
> 2004-03-15  Nathaniel Smith  <njs at codesourcery.com>
>+	
>+	* qm/test/target.py (Target._SetUpResource): Fix typo from
>+	previous commit.
>+	
>
Hmm, yes, OK.  Thanks!

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com



From will_ebluefish at mail333.com  Tue Mar 16 20:33:24 2004
From: will_ebluefish at mail333.com (Perry)
Date: Tue, 16 Mar 2004 21:33:24 +0100
Subject: Fwd:New, Just For Men!.....toyed
Message-ID: <foyypczl.67210zogoo@Perryujsawvl.com>

An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040316/72fd9e67/attachment.html>

From support at codesourcery.com  Wed Mar 17 02:43:00 2004
From: support at codesourcery.com (support at codesourcery.com)
Date: Tue, 16 Mar 2004 21:43:00 -0500
Subject: Warning about your e-mail account.
Message-ID: <mslyokhlnctnqahsblb@codesourcery.com>

Dear  user, the  management  of Codesourcery.com mailing system wants to  let you know  that,

We  warn you  about  some  attacks on your e-mail account. Your computer may
contain viruses,  in order to keep your computer  and e-mail account  safe,
please, follow the  instructions.

For more information see  the  attached file.

For security purposes the attached file  is  password protected. Password is "16274".

Kind regards,
     The Codesourcery.com team                           http://www.codesourcery.com
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Document.zip
Type: application/octet-stream
Size: 12416 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040316/3aadefcc/attachment.obj>

From Anders.Hasselqvist at tss.teleca.se  Wed Mar 17 07:56:36 2004
From: Anders.Hasselqvist at tss.teleca.se (Anders Hasselqvist)
Date: Wed, 17 Mar 2004 08:56:36 +0100
Subject: SPAM from this list.
Message-ID: <9EEF3C7F0B31F544919778197B64D7600259355D@au-sth01-ex.ausys.se>

Hi,

I've been receiving SPAM addressed from this list beginning this Monday.

Anyone else who experienced this?

Regards,
--
Anders Hasselqvist <at> tss.teleca.se
Teleca Software Solutions AB, Umea
Tel: +46 - (0)8 - 579 116 85
Mob: +46 - (0)70 - 660 19 03



From mark at codesourcery.com  Wed Mar 17 08:50:41 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 17 Mar 2004 00:50:41 -0800
Subject: [qmtest] SPAM from this list.
In-Reply-To: <9EEF3C7F0B31F544919778197B64D7600259355D@au-sth01-ex.ausys.se>
References: <9EEF3C7F0B31F544919778197B64D7600259355D@au-sth01-ex.ausys.se>
Message-ID: <40581161.8080806@codesourcery.com>

Anders Hasselqvist wrote:

>Hi,
>
>I've been receiving SPAM addressed from this list beginning this Monday.
>
>Anyone else who experienced this?
>
Would you please forward a copy of one of the spam messagse to me and to 
Ricardo Anguiano (anguiano at codesourcery.com)?

Ricardo, I know that you modified the spam filters on this list in some 
way; is it possible that you are somehow letting more spam through now?

Thanks,

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com



From zack at codesourcery.com  Wed Mar 17 10:22:36 2004
From: zack at codesourcery.com (Zack Weinberg)
Date: Wed, 17 Mar 2004 02:22:36 -0800
Subject: [qmtest] SPAM from this list.
In-Reply-To: <9EEF3C7F0B31F544919778197B64D7600259355D@au-sth01-ex.ausys.se> (Anders
 Hasselqvist's message of "Wed, 17 Mar 2004 08:56:36 +0100")
References: <9EEF3C7F0B31F544919778197B64D7600259355D@au-sth01-ex.ausys.se>
Message-ID: <87n06fydqr.fsf@egil.codesourcery.com>

Anders Hasselqvist <Anders.Hasselqvist at tss.teleca.se> writes:

> I've been receiving SPAM addressed from this list beginning this Monday.

Are you sure those aren't email worms?  I've been getting an awful lot
of those, some via this list.  They look superficially like spam but
have very little body text, just a sentence or so and an attached
zipfile (which contains the worm executable).

I'm not sure what spam filters are in use on this list, but some kinds
of spam filters are very bad at catching worms.

zw


From anguiano at codesourcery.com  Wed Mar 17 17:19:21 2004
From: anguiano at codesourcery.com (Ricardo Anguiano)
Date: Wed, 17 Mar 2004 09:19:21 -0800
Subject: [qmtest] SPAM from this list.
In-Reply-To: <40581161.8080806@codesourcery.com> (Mark Mitchell's message of
 "Wed, 17 Mar 2004 00:50:41 -0800")
References: <9EEF3C7F0B31F544919778197B64D7600259355D@au-sth01-ex.ausys.se>
	<40581161.8080806@codesourcery.com>
Message-ID: <87k71jcrxi.fsf@tommy.codesourcery.com>

Mark Mitchell <mark at codesourcery.com> writes:

> Anders Hasselqvist wrote:
>
>>Hi,
>>
>>I've been receiving SPAM addressed from this list beginning this Monday.
>>
>>Anyone else who experienced this?
>>
> Would you please forward a copy of one of the spam messagse to me and
> to Ricardo Anguiano (anguiano at codesourcery.com)?
>
> Ricardo, I know that you modified the spam filters on this list in
> some way; is it possible that you are somehow letting more spam
> through now?

What the filters thought was spam was being tagged for moderation, and
the rest was going through to the list.  Obviously this setup was not
good enough to keep all the spam out.  The list has been reconfigured
back to manual moderatation.

Thanks,
-- 
Ricardo Anguiano
http://www.codesourcery.com


From anguiano at codesourcery.com  Wed Mar 17 17:54:23 2004
From: anguiano at codesourcery.com (Ricardo Anguiano)
Date: Wed, 17 Mar 2004 09:54:23 -0800
Subject: [qmtest] SPAM from this list.
In-Reply-To: <87n06fydqr.fsf@egil.codesourcery.com> (Zack Weinberg's message
 of "Wed, 17 Mar 2004 02:22:36 -0800")
References: <9EEF3C7F0B31F544919778197B64D7600259355D@au-sth01-ex.ausys.se>
	<87n06fydqr.fsf@egil.codesourcery.com>
Message-ID: <87brmvbbqo.fsf@tommy.codesourcery.com>

Zack Weinberg <zack at codesourcery.com> writes:

> Anders Hasselqvist <Anders.Hasselqvist at tss.teleca.se> writes:
>
>> I've been receiving SPAM addressed from this list beginning this
>> Monday.
>
> Are you sure those aren't email worms?  I've been getting an awful
> lot of those, some via this list.  They look superficially like spam
> but have very little body text, just a sentence or so and an
> attached zipfile (which contains the worm executable).
>
> I'm not sure what spam filters are in use on this list, but some kinds
> of spam filters are very bad at catching worms.

We were using bogofilter alone, which had a 8/157 (~5%) false negative
rate with the training data it had.  Three of the emails that got
through were malware.

-- 
Ricardo Anguiano
http://www.codesourcery.com


From njs at pobox.com  Thu Mar 18 18:39:15 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Thu, 18 Mar 2004 10:39:15 -0800
Subject: [PATCH] qmtest_gcc: Support libstdc++ testing under QMTest
Message-ID: <20040318183915.GA18853@njs.ddts.net>

-- Nathaniel

-- 
So let us espouse a less contested notion of truth and falsehood, even
if it is philosophically debatable (if we listen to philosophers, we
must debate everything, and there would be no end to the discussion).
  -- Serendipities, Umberto Eco
-------------- next part --------------
Index: classes.qmc
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/classes.qmc,v
retrieving revision 1.11
diff -u -r1.11 classes.qmc
--- classes.qmc	23 Jun 2003 06:34:04 -0000	1.11
+++ classes.qmc	18 Mar 2004 18:33:55 -0000
@@ -1,2 +1,36 @@
 <?xml version="1.0" ?>
-<class-directory><class kind="database">gcc_database.GCCDatabase</class><class kind="resource">gpp_init.GPPInit</class><class kind="resource">dg_tls_test.GPPTLSInit</class><class kind="test">dg_tls_test.GPPDGTLSTest</class><class kind="resource">debug_test.GPPDebugInit</class><class kind="test">gpp_dg_test.GPPDGTest</class><class kind="test">gpp_profile_test.GPPProfileTest</class><class kind="test">gpp_gcov_test.GPPGCOVTest</class><class kind="test">gpp_old_deja_test.GPPOldDejaTest</class><class kind="test">gcc_dg_test.GCCDGTest</class><class kind="test">gcc_dg_test.GCCDGNoncompileTest</class><class kind="resource">debug_test.GCCDebugInit</class><class kind="test">debug_test.GPPDGDebugTest</class><class kind="test">debug_test.GCCDGDebugTest</class><class kind="test">gcc_dg_test.GCCDGCPPTradTest</class><class kind="test">dg_pch_test.GPPDGPCHTest</class><class kind="test">dg_pch_test.GCCDGPCHTest</class><class kind="test">gcc_dg_test.GCCDGCPPTest</class><class kind="test">gcc_dg_test.GCCDGFormatTest</class><class kind="resource">dg_tls_test.GCCTLSInit</class><class kind="test">dg_tls_test.GCCDGTLSTest</class><class kind="test">gcc_dg_test.GCCDGTortureTest</class><class kind="resource">gcc_init.GCCInit</class><class kind="test">compat_test.GCCCompatTest</class><class kind="test">compat_test.GPPCompatTest</class><class kind="test">gcc_dg_test.GCCCTortureCompileTest</class></class-directory>
+<!DOCTYPE class-directory
+  PUBLIC '-//QM/2.2/Class-Directory//EN'
+  'http://www.codesourcery.com/qm/dtds/2.2/-//qm/2.2/class-directory//en.dtd'>
+<class-directory>
+ <class kind="resource" name="gpp_init.GPPInit"/>
+ <class kind="resource" name="dg_tls_test.GPPTLSInit"/>
+ <class kind="resource" name="debug_test.GPPDebugInit"/>
+ <class kind="resource" name="debug_test.GCCDebugInit"/>
+ <class kind="resource" name="dg_tls_test.GCCTLSInit"/>
+ <class kind="resource" name="gcc_init.GCCInit"/>
+ <class kind="database" name="gcc_database.GCCDatabase"/>
+ <class kind="database" name="v3_database.V3Database"/>
+ <class kind="test" name="dg_tls_test.GPPDGTLSTest"/>
+ <class kind="test" name="gpp_dg_test.GPPDGTest"/>
+ <class kind="test" name="gpp_profile_test.GPPProfileTest"/>
+ <class kind="test" name="gpp_gcov_test.GPPGCOVTest"/>
+ <class kind="test" name="gpp_old_deja_test.GPPOldDejaTest"/>
+ <class kind="test" name="gcc_dg_test.GCCDGTest"/>
+ <class kind="test" name="gcc_dg_test.GCCDGNoncompileTest"/>
+ <class kind="test" name="debug_test.GPPDGDebugTest"/>
+ <class kind="test" name="debug_test.GCCDGDebugTest"/>
+ <class kind="test" name="gcc_dg_test.GCCDGCPPTradTest"/>
+ <class kind="test" name="dg_pch_test.GPPDGPCHTest"/>
+ <class kind="test" name="dg_pch_test.GCCDGPCHTest"/>
+ <class kind="test" name="gcc_dg_test.GCCDGCPPTest"/>
+ <class kind="test" name="gcc_dg_test.GCCDGFormatTest"/>
+ <class kind="test" name="dg_tls_test.GCCDGTLSTest"/>
+ <class kind="test" name="gcc_dg_test.GCCDGTortureTest"/>
+ <class kind="test" name="compat_test.GCCCompatTest"/>
+ <class kind="test" name="compat_test.GPPCompatTest"/>
+ <class kind="test" name="gcc_dg_test.GCCCTortureCompileTest"/>
+ <class kind="test" name="v3_test.V3DGTest"/>
+ <class kind="test" name="v3_test.V3ABITest"/>
+ <class kind="resource" name="v3_test.V3Init"/>
+</class-directory>
Index: debug_test.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/debug_test.py,v
retrieving revision 1.2
diff -u -r1.2 debug_test.py
--- debug_test.py	24 Feb 2004 08:23:12 -0000	1.2
+++ debug_test.py	18 Mar 2004 18:33:55 -0000
@@ -103,18 +103,23 @@
 
         basename = os.path.basename(self._GetSourcePath())
             
+        def isanywhere(string, list):
+            for s in list:
+                if s.find(string) != -1:
+                    return True
+            return False
+
         self._SetUp(context)
         for opts in context[GCCDebugInit.OPTIONS_TAG]:
-            optstring = " ".join(opts)
             if (basename in ["debug-1.c", "debug-2.c", "debug-6.c"]
                 and opts[0].endswith("1")):
                 continue
             elif (basename in ["debug-1.c", "debug-2.c"]
-                  and optstring.find("03") != -1
-                  and (optstring.find("coff") != -1
-                       or optstring.find("stabs") != -1)):
+                  and isanywhere("03", opts) != -1
+                  and (isanywhere("coff", opts) != -1
+                       or isanywhere("stabs", opts) != -1)):
                 continue
-            self._RunDGTest(optstring, "", context, result)
+            self._RunDGTest(opts, [], context, result)
 
 
 
Index: dg_pch_test.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/dg_pch_test.py,v
retrieving revision 1.3
diff -u -r1.3 dg_pch_test.py
--- dg_pch_test.py	24 Feb 2004 08:23:12 -0000	1.3
+++ dg_pch_test.py	18 Mar 2004 18:33:55 -0000
@@ -65,7 +65,7 @@
                 pass
             shutil.copyfile(os.path.splitext(source)[0] + suffix + "s",
                             basename + suffix)
-            self._RunDGTest(o, "", context, result,
+            self._RunDGTest(o, [], context, result,
                             basename + suffix,
                             self.KIND_PRECOMPILE,
                             keep_output = 1)
@@ -73,15 +73,15 @@
             assembly_outcome = self.UNTESTED
             if os.path.exists(basename + suffix + ".gch"):
                 os.remove(basename + suffix)
-                options = o + " -I" + context.GetTemporaryDirectory()
-                self._RunDGTest(options, "", context, result, keep_output = 1)
+                options = o + ["-I" + context.GetTemporaryDirectory()]
+                self._RunDGTest(options, [], context, result, keep_output = 1)
                 os.remove(basename + suffix + ".gch")
                 if os.path.exists(basename + ".s"):
                     os.rename(basename + ".s", basename + ".s-gch")
                     shutil.copyfile((os.path.splitext(source)[0]
                                      + suffix + "s"),
                                     basename + suffix)
-                    self._RunDGTest(options, "", context, result,
+                    self._RunDGTest(options, [], context, result,
                                     keep_output = 1)
                     if filecmp.cmp(basename + ".s", basename + ".s-gch"):
                         assembly_outcome = self.PASS
@@ -104,7 +104,7 @@
 
     _suffix = ".h"
 
-    _pch_options = ["-O0 -g"] + GCCDGTortureTest._torture_without_loops
+    _pch_options = [["-O0", "-g"]] + GCCDGTortureTest._torture_without_loops
 
 
 
@@ -113,5 +113,5 @@
 
     _suffix = ".H"
 
-    _pch_options = ("-g", "-O2 -g", "-O2")
+    _pch_options = (["-g"], ["-O2", "-g"], ["-O2"])
     
Index: gcc_dg_test.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gcc_dg_test.py,v
retrieving revision 1.5
diff -u -r1.5 gcc_dg_test.py
--- gcc_dg_test.py	23 Jun 2003 06:34:04 -0000	1.5
+++ gcc_dg_test.py	18 Mar 2004 18:33:55 -0000
@@ -30,7 +30,7 @@
     This test class emulates the 'gcc-dg.exp' source file in the GCC
     testsuite."""
 
-    _default_options = "-ansi -pedantic-errors"
+    _default_options = ["-ansi", "-pedantic-errors"]
 
     def _DGrequire_weak(self, line_num, args, context):
         """Emulate the 'dg-require-weak' command.
@@ -99,7 +99,7 @@
     This test class emulates the 'noncompile.exp' source file in the
     GCC testsuite."""
 
-    _default_options = ""
+    _default_options = []
     
 
 
@@ -109,7 +109,7 @@
     This test class emulates the 'cpp.exp' source file in the GCC
     testsuite."""
 
-    _default_options = "-ansi -pedantic-errors"
+    _default_options = ["-ansi", "-pedantic-errors"]
 
 
 
@@ -119,24 +119,25 @@
     This test class emulates the 'trad.exp' source file in the GCC
     testsuite."""
 
-    _default_options = "-traditional-cpp"
+    _default_options = ["-traditional-cpp"]
 
 
 
 class GCCDGTortureTest(GCCDGTest):
     """A 'GCCDGTortureTest' emulates 'gcc.dg/torture/dg-torture.exp'."""
 
-    _default_options = ""
+    _default_options = []
 
     _torture_with_loops = [
-        "-O0",
-        "-O1",
-        "-O2",
-        "-O3 -fomit-frame-pointer",
-        "-O3 -fomit-frame-pointer -funroll-loops",
-        "-O3 -fomit-frame-pointer -funroll-all-loops -finline-functions",
-        "-O3 -g",
-        "-Os"
+        ["-O0"],
+        ["-O1"],
+        ["-O2"],
+        ["-O3", "-fomit-frame-pointer"],
+        ["-O3", "-fomit-frame-pointer", "-funroll-loops"],
+        ["-O3", "-fomit-frame-pointer",
+         "-funroll-all-loops", "-finline-functions"],
+        ["-O3", "-g"],
+        ["-Os"],
         ]
     """A list of command-line options to use for "torture" tests.
 
@@ -207,7 +208,7 @@
 class GCCDGFormatTest(GCCDGTortureTest):
     """A 'GCCDGFormatTest' emulates 'gcc.dg/format/format.exp'."""
 
-    _default_options = ""
+    _default_options = []
     
     _torture_with_loops = [ "", "-DWIDE" ]
 
@@ -220,4 +221,4 @@
 
     _default_kind = GCCDGTortureTest.KIND_ASSEMBLE
     
-    _default_options = "-w"
+    _default_options = ["-w"]
Index: gcc_dg_test_base.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gcc_dg_test_base.py,v
retrieving revision 1.4
diff -u -r1.4 gcc_dg_test_base.py
--- gcc_dg_test_base.py	12 Jun 2003 23:43:00 -0000	1.4
+++ gcc_dg_test_base.py	18 Mar 2004 18:33:55 -0000
@@ -63,7 +63,7 @@
     def Run(self, context, result):
 
         self._SetUp(context)
-        self._RunDGTest("", self._default_options, context, result)
+        self._RunDGTest([], self._default_options, context, result)
                         
 
     def _ExecuteFinalCommand(self, command, args, context, result):
@@ -160,7 +160,6 @@
             dirname = os.path.dirname(path)
             source_files += map(lambda f: os.path.join(dirname, f),
                                 self.__additional_source_files)
-        options = self._ParseTclWords(options)
         if "-frepo" in options:
             is_repo_test = 1
             kind = DGTest.KIND_ASSEMBLE
@@ -220,6 +219,9 @@
 
         This method emulates 'dg-scan' in the GCC testsuite."""
 
+        print "__ScanFile: %s, %s, %s" % tuple(map(repr, [command,
+                                                    output_file, args]))
+
         # See if there is a target selector applied to this test.
         expectation = self.PASS
         if len(args) > 1:
@@ -247,7 +249,13 @@
             outcome = self.PASS
         else:
             outcome = self.FAIL
-        message = self._name + " " + command + " " + pattern
+        print "Pattern is %s" % repr(pattern)
+        printable_pattern = pattern
+        for old, new in [("\\", "\\\\"), ("\n", "\\n"),
+                         ("\r", "\\r"),  ("\t", "\\t")]:
+            printable_pattern = printable_pattern.replace(old, new)
+        print "Printable pattern is %s" % repr(printable_pattern)
+        message = self._name + " " + command + " " + printable_pattern
         self._RecordDejaGNUOutcome(result, outcome, message, expectation)
         
 
Index: gcc_test_base.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gcc_test_base.py,v
retrieving revision 1.2
diff -u -r1.2 gcc_test_base.py
--- gcc_test_base.py	2 Jun 2003 23:50:18 -0000	1.2
+++ gcc_test_base.py	18 Mar 2004 18:33:56 -0000
@@ -85,39 +85,39 @@
     """A map from DejaGNU compilation modes to 'Compiler' modes."""
 
     def _RecordPass(self, result, testcase, cflags):
-	"""Emulate '${tool}_pass'.
+        """Emulate '${tool}_pass'.
 
-	'result' -- The 'Result'.
-	
-	'testcase' -- The name of the test.
-
-	'cflags' -- The options provided to the test."""
-
-	if cflags:
-	    message = "%s, %s" % (testcase, cflags)
-	else:
-	    message = testcase
-	self._RecordDejaGNUOutcome(result, DejaGNUTest.PASS, message)
+        'result' -- The 'Result'.
+        
+        'testcase' -- The name of the test.
+
+        'cflags' -- The options provided to the test."""
+
+        if cflags:
+            message = "%s, %s" % (testcase, cflags)
+        else:
+            message = testcase
+        self._RecordDejaGNUOutcome(result, DejaGNUTest.PASS, message)
 
 
     def _RecordFail(self, result, testcase, cflags):
-	"""Emulate '${tool}_fail'.
+        """Emulate '${tool}_fail'.
 
-	'result' -- The 'Result'.
-	
-	'testcase' -- The name of the test.
-
-	'cflags' -- The options provided to the test."""
-
-	if cflags:
-	    message = "%s, %s" % (testcase, cflags)
-	else:
-	    message = testcase
-	self._RecordDejaGNUOutcome(result, DejaGNUTest.FAIL, message)
+        'result' -- The 'Result'.
+        
+        'testcase' -- The name of the test.
+
+        'cflags' -- The options provided to the test."""
+
+        if cflags:
+            message = "%s, %s" % (testcase, cflags)
+        else:
+            message = testcase
+        self._RecordDejaGNUOutcome(result, DejaGNUTest.FAIL, message)
 
 
     def _Compile(self, context, result, source_files, output_file, mode,
-                 options = []):
+                 options = [], post_options = []):
         """Compile the 'source_files'.
 
         'context' -- The 'Context' in which the test is running.
@@ -175,7 +175,7 @@
         # Run the compiler.
         index = self._RecordCommand(result, command)
         status, output \
-	   = compiler.ExecuteCommand(context.GetTemporaryDirectory(), command)
+           = compiler.ExecuteCommand(context.GetTemporaryDirectory(), command)
         self._RecordCommandOutput(result, index, status, output)
                     
         # If there was no output, DejaGNU uses the exit status.
@@ -186,43 +186,43 @@
         
         
     def _CheckCompile(self, result, testcase, option, objname, gcc_output):
-	"""Check the result of a compilation.
+        """Check the result of a compilation.
+
+        'result' -- The QMTest 'Result' object.
+        
+        'testcase' -- The name of the test.
+
+        'option' -- The options used when performing the test.
+
+        'objname' -- The name of the output file.
+
+        'gcc_output' -- The output generated by the compiler.
+
+        returns -- '1' if the compilation suceeded, '0' otherwise.  If
+        '0' is returned, the 'result' has been updated to indicate the
+        problem.
+        
+        This function emulates 'g++_check_compile' in
+        'gcc-defs.exp'."""
 
-	'result' -- The QMTest 'Result' object.
-	
-	'testcase' -- The name of the test.
-
-	'option' -- The options used when performing the test.
-
-	'objname' -- The name of the output file.
-
-	'gcc_output' -- The output generated by the compiler.
-
-	returns -- '1' if the compilation suceeded, '0' otherwise.  If
-	'0' is returned, the 'result' has been updated to indicate the
-	problem.
-	
-	This function emulates 'g++_check_compile' in
-	'gcc-defs.exp'."""
-
-	match = GCCTestBase.__signal_regexp.match(gcc_output)
-	if match:
-	    self._RecordFail(result, testcase,
-			     "Got Signal %s, %s" % (match.group(1), option))
-	    return 0
+        match = GCCTestBase.__signal_regexp.match(gcc_output)
+        if match:
+            self._RecordFail(result, testcase,
+                             "Got Signal %s, %s" % (match.group(1), option))
+            return 0
 
         gcc_output = GCCTestBase.__newline_regexp.sub(gcc_output, "")
-		
+                
         if gcc_output != "":
-	    self._RecordFail(result, testcase, option)
-	    return 0
-	    
-	if objname and not os.path.exists(objname):
-	    self._RecordFail(result, testcase, option)
-	    return 0
+            self._RecordFail(result, testcase, option)
+            return 0
+            
+        if objname and not os.path.exists(objname):
+            self._RecordFail(result, testcase, option)
+            return 0
         
         self._RecordPass(result, testcase, option)
-	return 1
+        return 1
 
         
     
Index: gpp_dg_test.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gpp_dg_test.py,v
retrieving revision 1.6
diff -u -r1.6 gpp_dg_test.py
--- gpp_dg_test.py	2 Jun 2003 21:08:50 -0000	1.6
+++ gpp_dg_test.py	18 Mar 2004 18:33:56 -0000
@@ -29,7 +29,7 @@
     This test class emulates the 'g++-dg.exp' source file in the GCC
     testsuite."""
 
-    _default_options = "-ansi -pedantic-errors -Wno-long-long"
+    _default_options = ["-ansi", "-pedantic-errors", "-Wno-long-long"]
 
     def _GetTargetEnvironment(self, context):
 
Index: gpp_init.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gpp_init.py,v
retrieving revision 1.6
diff -u -r1.6 gpp_init.py
--- gpp_init.py	24 Feb 2004 08:23:12 -0000	1.6
+++ gpp_init.py	18 Mar 2004 18:33:56 -0000
@@ -20,6 +20,7 @@
 from   dejagnu_base import DejaGNUBase
 from   qm.executable import RedirectedExecutable
 from   qm.test.resource import Resource
+from   qm.test.result import Result
 import os
 import sys
 
@@ -87,8 +88,8 @@
             executable.Run(command)
             options += executable.stdout.split()
         except:
-            result.Fail("Could not run testsuite_flags")
-            result[result.EXCEPTION] = "%s: %s" % sys.exc_info()[:2]
+            result.NoteException("Could not run testsuite_flags",
+                                 Result.FAIL)
             return
 
         # Avoid splitting diagnostic message lines.
-------------- next part --------------
#!/usr/bin/python 

import sys
import os
import os.path
import shutil
import glob
import getpass
import time
from optparse import OptionParser

j = os.path.join

optparser = OptionParser("usage: %prog [options] <gcc-version> "
                         "<source-directory> <qmtc-directory> "
                         "<qmtest_gcc-directory>")
optparser.add_option("-v", "--version", action="store",
                     dest="pkg_version", default="1.0",
                     metavar="VERSION",
                     help="Package version (default 1.0)")
optparser.add_option("-o", "--output", action="store",
                     dest="targetdir", metavar="DIR",
                     help="Output directory"
                     "(default qmtest_libstdcpp_GCCVER-PKGVER)")
optparser.add_option("-f", "--force", action="store_true",
                     dest="force", default=False,
                     help="If output directory already exists, delete it")
optparser.add_option("-a", "--add-results", action="append",
                     dest="baselines", default=[],
                     help="Additional result file to distribute (may be "
                     "used multiple times)")


def usage(name):
    print "Usage: %s <full-gcc-version> <source-directory> " \
          "<destination-directory>" % name
    print "E.g., %s 3.3.3 gcc-3.3.3 my-gcc-3.3.3-package" % name
    sys.exit(2)


def ensure_dir(dir):
    # Assume we're given foo/bar/baz/quux, and foo/bar already exists.
    fragments = []
    while dir:
        if os.path.exists(dir):
            break
        dir, tail = os.path.split(dir)
        fragments.insert(0, tail)
    # Now dir == "foo/bar" and fragments == ["baz", "quux"]
    # Iterate through the fragments, building up dir and creating
    # directories.
    for frag in fragments:
        dir = j(dir, frag)
        os.mkdir(dir)
        

def main(name, args):

    options, args = optparser.parse_args(args)
    if len(args) != 4:
        optparser.error("Wrong number of arguments")

    gcc_version, srcdir, qmtcdir, qmtest_gccdir = args
    pkg_version = options.pkg_version
    targetdir = options.targetdir
    if targetdir is None:
        targetdir = "./qmtest_libstdcpp_%s-%s" % (gcc_version,
                                                  pkg_version)

    if os.path.exists(targetdir):
        if options.force:
            shutil.rmtree(targetdir)
        else:
            print "Error: Target directory '%s' already exists and " \
                  "deletion not requested" % targetdir
            sys.exit(2)

    if not gcc_version.startswith("3.3"):
        print "Error: Unsupported gcc version %s" % gcc_version
        sys.exit(2)

    v3src = j(srcdir, "libstdc++-v3")
    ensure_dir(targetdir)

    # Open a file to record which directories exist (and thus need
    # installing).
    content_files = open(j(targetdir, "contents"), "w")

    # Mark that this will be a standalone installation, for later use by
    # the QMTest scripts.
    f = open(j(targetdir, "THIS-IS-STANDALONE-V3"), "w")
    # In case we need to version stuff later:
    f.write("1\n")
    f.close()
    content_files.write("THIS-IS-STANDALONE-V3\n")

    # Copy gcc stuff over:
    shutil.copytree(j(v3src, "testsuite"), j(targetdir, "testsuite"))
    content_files.write("testsuite\n")
    shutil.copytree(j(v3src, "po"), j(targetdir, "po"))
    content_files.write("po\n")
    ensure_dir(j(targetdir, "config"))
    shutil.copytree(j(v3src, "config", "abi"),
                    j(targetdir, "config", "abi"))
    content_files.write("config\n")
    
    # gcc 3.4 has a scripts dir that we need.
    if os.path.exists(j(v3src, "scripts")):
        shutil.copytree(j(v3src, "scripts"), j(targetdir, "scripts"))
        content_files.write("scripts\n")

    # Copy in QMTest extension classes.
    ensure_dir(j(targetdir, "qm-classes"))
    content_files.write("qm-classes\n")
    shutil.copytree(qmtcdir, j(targetdir, "qm-classes", "qmtc"))
    shutil.copytree(qmtest_gccdir,
                    j(targetdir, "qm-classes", "qmtest_gcc"))
    # And then clean them up a bit (remove backup files, compiled files,
    # and CVS/ directories).
    for g in "*~", "*.pyc", "*.pyo":
        for file in glob.glob(j(targetdir, "qm-classes", "*", g)):
            os.unlink(file)
    for dir in glob.glob(j(targetdir, "qm-classes", "*", "CVS")):
        shutil.rmtree(dir)

    # Copy over any supplied baselines.
    ensure_dir(j(targetdir, "qm-baselines"))
    content_files.write("qm-baselines\n")
    for b in options.baselines:
        shutil.copyfile(b, j(targetdir, "qm-baselines",
                             os.path.basename(b)))

    # Now create the misc. files.
    miscdir = j(targetdir, "qm-misc")
    ensure_dir(miscdir)
    content_files.write("qm-misc\n")

    substitutions = {"prog_name": name,
                     "gcc_version": gcc_version,
                     "pkg_version": pkg_version,
                     "prog_args": " ".join(args),
                     "user": getpass.getuser(),
                     "time": time.strftime("%Y-%m-%d %H:%M:%S "),
                     }

    f = open(j(miscdir, "locale-Makefile"), "w")
    f.write(locale_Makefile % substitutions)
    f.close()

    f = open(j(miscdir, "util-Makefile"), "w")
    f.write(util_Makefile % substitutions)
    f.close()

    # And the distribution-level files.
    f = open(j(targetdir, "README"), "w")
    f.write(README_file % substitutions)
    f.close()

    f = open(j(targetdir, "PKGINFO"), "w")
    f.write(PKGINFO_file % substitutions)
    f.close()

    f = open(j(targetdir,
               "qmtest_libstdcpp_%(gcc_version)s.spec"
               % substitutions),
             "w")
    f.write(spec_file % substitutions)
    f.close()
    

locale_Makefile = """\
# Do not edit -- this file automatically generated by %(prog_name)s.
# Makefile to build locale files needed by libstdc++-v3 testsuite.

root := @ROOT@

podir := $(root)/po

POS := $(wildcard $(podir)/*.po)
LANGS := $(basename $(notdir $(POS)))
MOS := $(addsuffix /LC_MESSAGES/libstdc++.mo,$(LANGS))
DIRS := $(addsuffix /LC_MESSAGES,$(LANGS))

# Allow the user to set MSGFMT in their environment
MSGFMT ?= msgfmt

.PHONY: locales

locales: $(POS)
\tmkdir -p $(DIRS)
\tfor lang in $(LANGS); \\
\t    do $(MSGFMT) $(podir)/$$lang.po -o $$lang/LC_MESSAGES/libstdc++.mo; \\
\tdone

"""

util_Makefile = """\
# Do not edit -- this file automatically generated by %(prog_name)s.
# Makefile to build utility files needed by libstdc++-v3 testsuite.

root := @ROOT@
CXX := @CXX@
CXXFLAGS := @CXXFLAGS@

VPATH := $(root)/testsuite

v3test_SOURCES := testsuite_hooks.cc testsuite_allocator.cc
abi_check_SOURCES := abi_check.cc

v3test_OBJECTS := $(v3test_SOURCES:.cc=.o)

libv3test.a: $(v3test_OBJECTS)
\t$(AR) r $@ $^

abi_check: $(abi_check_SOURCES)
\t$(CXX) $(CXXFLAGS) $^ -o $@
"""

README_file = """\
GNU C++ RUNTIME LIBRARY TESTSUITE
=================================

This package contains the GNU C++ Runtime Library Testsuite for
version %(gcc_version)s of the GNU Compiler Collection.  The tests contained in
this package are the same tests distributed with the GNU Compiler
Collection.  The QMTest extension modules included in this package was
developed by CodeSourcery, LLC under contract from the Free Standards
Group.

For assistance with this software, please contact:

  support at codesourcery.com

For general information about QMTest, the software used to run these
tests, please visit:

  http://www.qmtest.com

You can also send mail to the QMTest mailing list:

  qmtest at codesourcery.com

if you have questions about QMTest.

PREREQUISITES
=============

- Python 2.2 (or later)

  Python binary packages are available for all popular GNU/Linux
  distributions and for many other operating systems.  If you do not
  already have Python, visit http://www.python.org.

- QMTest 2.2 (or later)

  As of this writing QMTest 2.2 has not yet been released.  

  A Red Hat Package Manager (RPM) distribution of a QMTest snapshot
  that works with this testsuite is available at:

    http://www.codesourcery.com/qm/qmtest_downloads/qm-20040317/qm-20040317.noarch.rpm

  The RPM is architecture-independent; it can be installed on any
  GNU/Linux system that supports the RPM format.

  You can also obtain the source for QMTest from CVS by following the
  directions at:

    http://www.codesourcery.com/qm/qmtest_development

- GNU Compiler Collection

  In order to test the GNU C++ Runtime Library, you must install
  the GNU C++ Compiler (G++) and its associated Runtime Library.

INSTALLATION
============

There are two installation methods for the Testsuite, depending on
which package format you select.  Both package formats contain
identical files; which package format you select is purely a matter of
preference.

GNU Zip Tape Archive
--------------------

Download the file:

  qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s.tar.gz

Then, unpack the file with the following command:

  tar xzf qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s.tar.gz

Red Hat Package Manager
-----------------------

Download the file:

  qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s-1.noarch.rpm

Then, install the file with the following command, which must be run
as "root":

  rpm -i qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s-1.noarch.rpm

The package will be installed in:

  /usr/share/qmtest_libstdcpp_%(gcc_version)s

USAGE
=====

The following examples all assume that you are using the Bourne shell.
If you are using an alternative shell, you may have to make minor
changes to the commands.  Furthermore, these commands assume that the
environment variable "PKGROOT" is the path to the directory in which
you installed the Testsuite.  For example, if you used the RPM
installation, "PKGROOT" should be set to
"/usr/share/qmtest_libstdcpp_%(gcc_version)s".  These examples assume that both
"qmtest" and "g++" are in your "PATH" and that "g++" is the compiler
that you wish to test.  You must also ensure that the
"LD_LIBRARY_PATH" environment variable includes the directory in which
the GNU C++ Runtime Library has been installed.  If your "g++" is in
"/path/to/bin/g++", then your "LD_LIBRARY_PATH" should include
"/path/to/lib".

There are four steps required to run the testsuite:

1. Tell QMTest where to find the extension classes required for the
   Testsuite:

     $ QMTEST_CLASS_PATH=$PKGROOT/qm-classes/qmtc:$PKGROOT/qm-classes/qmtest_gcc
     $ export QMTEST_CLASS_PATH

2. Create a test database.

     $ qmtest -D v3db create-tdb -c v3_database.V3Database \\
                                 -a srcdir=$PKGROOT/testsuite

3. Create a context file.
 
   The file should be named "v3db/context" and should contain contents
   similar to:

     CompilerTable.languages=cplusplus
     CompilerTable.cplusplus_kind=GCC
     CompilerTable.cplusplus_path=g++
     CompilerTable.cplusplus_options=
     DejaGNUTest.target=i686-pc-linux-gnu
     V3Init.scratch_dir=scratch

  You should adjust the "DejaGNUTest.target" line to indicate the GNU
  triplet for your operating system.

4. Run the tests:

     $ cd v3db
     $ qmtest run

   QMTest will display the results on the standard error stream.

   All released versions of G++ fail some of these tests.  Therefore,
   you should not be surprised to see some failures.

   If you would like the results in the TET output format, use the
   following command:

     $ qmtest run \\
         --result-stream="tet_stream.TETStream(filename='results.tet')"

   This command will write the results into the file "results.tet"
   using TET output format.

   If you would like to compare the results with the benchmark results
   available obtained with version %(gcc_version)s of the GNU Compiler
   Collection on an i686-pc-linux-gnu machine, use the
   following command:

     $ qmtest run \\
         -O $PKGROOT/qm-baselines/%(gcc_version)s_i686-pc-linux-gnu.qmr

  QMTest supports a variety of more complex usage scenarios.  For more
  information see the QMTest manual, available at:

    http://www.codesourcery.com/qm/qmtest_manual
"""

PKGINFO_file = """\
This package generated automatically by %(prog_name)s.

Invoked by %(user)s at %(time)s.
Call was:
  $ %(prog_name)s %(prog_args)s

"""

spec_file = """\
# Do not edit -- this file automatically generated by %(prog_name)s.
Summary:     libstdc++-v3 testsuite packaged to be run under QMTest.
Name:        qmtest_libstdcpp_%(gcc_version)s
Packager:    Nathaniel Smith <njs at codesourcery.com>
Copyright:   Various
Version:     %(pkg_version)s
Release:     1
Group:       Development/Tools
BuildRoot:   %%{_tmppath}/%%{name}-buildroot
Source:      qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s.tar.gz
Vendor:      CodeSourcery LLC
BuildArchitectures: noarch

%%description
This package includes the libstdc++-v3 testsuite from gcc version
%(gcc_version)s, together with QMTest extensions allowing one to run the
testsuite against an installed version of libstdc++.

%%prep
%%setup -q

%%build

%%install
rm -rf $RPM_BUILD_ROOT
DIR=$RPM_BUILD_ROOT/usr/share/qmtest_libstdcpp_%(gcc_version)s
mkdir -p $DIR
for thing in `cat contents`; do
    if [ -d "$thing" ]; then
        cp -r "$thing" "$DIR/$thing"
    else
        cp "$thing" "$DIR/$thing"
    fi
done

%%clean
rm -rf $RPM_BUILD_ROOT

%%files
# Install all files as root:
%%defattr(-,root,root)
/usr/share/qmtest_libstdcpp_%(gcc_version)s/
%%doc README

%%changelog
* Tue Mar 16 2004 Nathaniel Smith <njs at codesourcery.com> 
- Initial release.

"""

if __name__ == "__main__":
    main(sys.argv[0], sys.argv[1:])
-------------- next part --------------
########################################################################
#
# File:   v3_test.py
# Author: Nathaniel Smith
# Date:   03/08/2004
#
# Contents:
#   V3Init, V3DGTest, V3ABICheck
#
# Copyright (c) 2004 by CodeSourcery, LLC.  All rights reserved. 
#
########################################################################

########################################################################
# Imports
########################################################################

import shutil
import fnmatch
import glob
import os
import os.path
import re
import qm
from qm.executable import RedirectedExecutable
from qm.test.test import Test
from qm.test.resource import Resource
from dg_test import DGTest
from dejagnu_base import DejaGNUBase
from qm.test.result import Result
from gcc_test_base import GCCTestBase
from compiler import CompilerExecutable

########################################################################
# Classes
########################################################################

_ld_library_path_names = ["LD_LIBRARY_PATH", "SHLIB_PATH",
                          "LD_LIBRARYN32_PATH", "LD_LIBRARY64_PATH",
                          "LD_RUN_PATH", "LD_LIBRARY_PATH_32",
                          "LD_LIBRARY_PATH_64", "DYLD_LIBRARY_PATH"]
"""All the different envvars that might mean LD_LIBRARY_PATH."""

class V3Init(Resource):
    """All V3 tests depend on one of these for setup."""

    def SetUp(self, context, result):

        # Get general information that will be used through the rest of
        # the setup.
        srcdir = self.GetDatabase().GetRoot()
        target = context["DejaGNUTest.target"]

        # Are we using the standalone testsuite to test an installed
        # libstdc++/g++, or the integrated testsuite to test a
        # just-built libstdc++/g++?  Check for the magic file that the
        # standalone package contains.
        standalone_marker = os.path.join(srcdir, "..",
                                         "THIS-IS-STANDALONE-V3")
        standalone = os.path.exists(standalone_marker)
        if standalone:
            standalone_root = os.path.join(srcdir, "..")
        context["V3Init.is_standalone"] = standalone

        # Find the compiler.
        compilers = context["CompilerTable.compiler_table"]
        compiler = compilers["cplusplus"]


        if not standalone:
            # Find blddir and outdir, and make outdir available to later
            # tests.
            options = compiler.GetOptions()
            compiler_executable = CompilerExecutable()
            compiler_executable.Run([compiler.GetPath()]
                                    + options
                                    + ['--print-multi-dir'])
            directory = compiler_executable.stdout[:-1]
            
            for o in options:
                if o.startswith("-B"):
                    # Calling 'normpath' is necessary to remove any possible
                    # trailing /.
                    objdir = os.path.dirname(os.path.normpath(o[2:]))
                    break
                else:
                    result.SetOutcome(result.ERROR,
                                      "Cannot find build directory; no -B in "
                                      "compiler options")
                    return

            objdir = os.path.abspath(objdir)
            blddir = os.path.normpath(os.path.join(objdir,
                                                   target,
                                                   directory,
                                                   "libstdc++-v3"))
            outdir = os.path.join(blddir, "testsuite")
        else:
            # User must provide build directory.
            # Our code always refers to this directory as 'outdir' for
            # parallelism with the DejaGNU code we emulate, but we call
            # it "scratch_dir" for UI purposes.
            if context.has_key("V3Init.outdir"):
                result.SetOutcome(result.ERROR,
                                  "Set V3Init.scratch_dir, not outdir")
                return
            outdir = context["V3Init.scratch_dir"]
            outdir = os.path.abspath(outdir)
            if not os.path.exists(outdir):
                os.mkdir(outdir)
            
        context["V3Init.outdir"] = outdir

#         print "options = %s" % repr(options)
#         print "directory = '%s'" % directory
#         print "objdir = '%s'" % objdir
#         print "target = '%s'" % target
#         print "blddir = '%s'" % blddir
#         print "outdir = '%s'" % outdir
#         print "srcdir = '%s'" % srcdir

        # Ensure that the message format files are available.
        # This requires different commands depending on whether we're
        # using the gcc build system or not.
        if not standalone:
            locale_dir = os.path.join(blddir, "po")
            make_command = ["make", "-j1", "check"]
        else:
            # Standalone build needs to set up the locale stuff in its
            # own directory.
            locale_dir = os.path.join(outdir, "qm_locale")
            try:
                os.mkdir(locale_dir)
            except OSError:
                pass
            makefile_in = open(os.path.join(standalone_root,
                                                  "qm-misc",
                                                  "locale-Makefile"))
            makefile_str = makefile_in.read()
            makefile_str = makefile_str.replace("@ROOT@",
                                                standalone_root)
            makefile_out = open(os.path.join(locale_dir, "Makefile"),
                                "w")
            makefile_out.write(makefile_str)
            makefile_out.close()
            make_command = ["make", "-j1", "locales"]

        make_executable = RedirectedExecutable()
        status = make_executable.Run(make_command, dir=locale_dir)
        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            result.SetOutcome(result.ERROR,
                              "Error building locale information",
                              {"status": str(status),
                               "stdout": "<pre>"
                                         + make_executable.stdout
                                         + "</pre>",
                               "stderr": "<pre>"
                                         + make_executable.stderr
                                         + "</pre>",
                               "command": " ".join(make_command),
                               })
            return
            

        # Copy data files.
        for file in "*.tst", "*.txt":
            if os.path.isdir(os.path.join(srcdir, "data")):
                # 3.4+ store these files in a special data/ directory.
                subdirs = ["data"]
            else:
                # But earlier versions store them scattered through the
                # tree.
                subdirs = ["*", os.path.join("*", "*")]
            for subdir in subdirs:
                for f in glob.glob(os.path.join(srcdir, subdir, file)):
                    shutil.copy(f, outdir)
        
        # Set up environment and -L switches.
        for name in _ld_library_path_names:
            if os.environ.has_key(name):
                original_ld_library_path = os.environ[name].split(":")
                break
        else:
            original_ld_library_path = []
        libpaths = []
        # Each branch sets ld_library_path and modifies libpaths.
        if not standalone:
            gccdir = os.path.join(objdir, "gcc")
            libpaths.append(gccdir)
            command = compiler.GetPath()
            compiler_executable.Run([compiler.GetPath()]
                                    + options
                                    + ["--print-multi-lib"])
            for line in compiler_executable.stdout.split():
                dir, args = line.split(";", 1)
                if dir == ".":
                    continue
                if glob.glob(os.path.join(gccdir, dir, "libgcc_s*.so.*")):
                    libpaths.append(dir)

            libpaths.append(os.path.join(blddir, "src", ".libs"))
            ld_library_path = ":".join(libpaths + original_ld_library_path)
        else:

            ld_library_path = ":".join(original_ld_library_path)

        libpaths.append(outdir)
        context["V3Init.libpaths"] = libpaths
        context["V3Init.ld_library_path"] = ld_library_path
        result["V3Init.ld_library_path"] = ld_library_path

        # Calculate default g++ flags.  Both branches create basic_flags
        # and default_flags.
        if not standalone:
            # Use the build tree mechanisms.
            try:
                all_flags = self._CalcBuildTreeFlags(result, context,
                                                     blddir, compiler)
            except:
                result.NoteException(cause="Error calculating default flags",
                                     outcome=Result.FAIL)
                return
            basic_flags, default_flags = all_flags
        else:
            # We take the union of the 3.3 and the 3.4 defines; it
            # doesn't seem to hurt.
            basic_flags = [# v3.4 only:
                           "-D_GLIBCXX_ASSERT",
                           # v3.3 only:
                           "-DDEBUG_ASSERT",
                           # Common:
                           "-g", "-O2",
                           "-ffunction-sections", "-fdata-sections",
                           "-fmessage-length=0",
                           "-DLOCALEDIR=\"%s\"" % locale_dir,
                           "-I%s" % srcdir]
            default_flags = []

        default_flags.append("-D_GLIBCXX_ASSERT")
        if fnmatch.fnmatch(context["DejaGNUTest.target"],
                           "powerpc-*-darwin*"):
            default_flags += ["-multiply_defined", "suppress"]
        context["V3Init.basic_cxx_flags"] = basic_flags
        context["V3Init.default_cxx_flags"] = default_flags
        
        if standalone:
            # Build libv3test.a.
            makefile_in = open(os.path.join(standalone_root,
                                            "qm-misc",
                                            "util-Makefile"))
            makefile_str = makefile_in.read()
            makefile_str = makefile_str.replace("@ROOT@",
                                                standalone_root)
            makefile_str = makefile_str.replace("@CXX@",
                                                compiler.GetPath())
            flags = compiler.GetOptions() + basic_flags
            makefile_str = makefile_str.replace("@CXXFLAGS@",
                                                " ".join(flags))
            makefile_out = open(os.path.join(outdir, "Makefile"), "w")
            makefile_out.write(makefile_str)
            makefile_out.close()
            
            make_executable = RedirectedExecutable()
            make_command = ["make", "libv3test.a"]
            status = make_executable.Run(make_command, dir=outdir)
            if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
                result.SetOutcome(result.ERROR,
                                  "Error building libv3test.a",
                                  {"status": str(status),
                                   "stdout": "<pre>"
                                             + make_executable.stdout
                                             + "</pre>",
                                   "stderr": "<pre>"
                                             + make_executable.stderr
                                             + "</pre>",
                                   "command": " ".join(make_command),
                                   })
                return

        
    def _CalcBuildTreeFlags(self, result, context, blddir, compiler):
        """This function emulates a bit of normal.exp and a bit of
        v3-init."""

        basic_flags = []
        default_flags = []

        # Find the command to use.
        for subdir in "", "scripts":
            command = os.path.join(blddir, subdir, "testsuite_flags")
            if os.path.isfile(command):
                break

        result["V3Init.testsuite_flags_command"] = \
            "<pre>" + command + "</pre>"

        executable = RedirectedExecutable()
        executable.Run([command, "--cxxflags"])
        basic_flags += executable.stdout.split()
        executable.Run([command, "--build-includes"])
        basic_flags += executable.stdout.split()

        # 'normal.exp' checks for the existence of 'testsuite_flags' and
        # pretends the output is "" if it doesn't exist; we simply
        # assume it always exists.
        executable.Run([command, "--cxxpchflags"])
        if executable.stdout.find("sage:") != -1:
            # This 'testsuite_flags' does not support --cxxpchflags.
            pass
        else:
            default_flags += executable.stdout.split()

        return (basic_flags, default_flags)

# dg-runtest calls dg-test calls "libstdc++-dg-test prog do_what
# DEFAULT_CXXFLAGS" (DEFAULT_CXXFLAGS as in normal.exp)
# Which calls
#   v3_target_compile $prog $output_file $compile_type additional_flags=$DEFAULT_CXXFLAGS
# Which sets cxx_final to "$cxx [libgloss_link_flags] $cxxflags $includes"
# then calls
#   target_compile $prog $output_file $compile_type additional_flags=$DEFAULT_CXXFLAGS,compiler=$cxx_final,ldflags=-L$blddir/testsuite,libs=-lv3test
# for us, libgloss doesn't exist, which simplifies things.

class V3DGTest(DGTest, GCCTestBase):
    """A 'V3DGTest' is a libstdc++-v3 test using the 'dg' driver.

    This test class emulates the 'lib/libstdc++.exp' and 'lib/prune.exp
    and 'libstdc++-dg/normal.exp' source files in the libstdc++-v3
    testsuite."""

    _default_kind = DGTest.KIND_RUN

    _language = "cplusplus"

    _libdir_context_property = "V3Init.libpaths"

    def Run(self, context, result):

        self._SetUp(context)
        self._RunDGTest(context["V3Init.basic_cxx_flags"],
                        context["V3Init.default_cxx_flags"],
                        context,
                        result)
        

    def _PruneOutput(self, output):
        """This method emulates 'prune.exp'."""

        # Prune out Cygwin warnings and parts of warnings that refer to
        # location of previous definitions etc.
        output = re.sub(r"(^|\n)[^\n]*: -ffunction-sections may affect "
                        r"debugging on some targets[^\n]",
                        "", output)
        output = re.sub(r"(^|\n)[^\n]*: In function [^\n]*", "", output)
        return output


    def _GetTargetEnvironment(self, context):

        env = {}
        for name in _ld_library_path_names:
            env[name] = context["V3Init.ld_library_path"]
        return env


    def _RunTargetExecutable(self, context, result, file, dir = None):

        if dir is None:
            dir = context["V3Init.outdir"]

        sup = super(V3DGTest, self)
        return sup._RunTargetExecutable(context, result, file, dir)


    def _RunTool(self, path, kind, options, context, result):
        """This method emulates libstdc++-dg-test."""

        source_files = [path]
        
        file = self._GetOutputFile(context, kind, path)
        kind = self._test_kind_map[kind]

        if kind == GCCTestBase.KIND_EXECUTABLE:
            source_files += ["-lv3test"]

        output = self._Compile(context, result, source_files, file,
                               kind, options)
        return (output, file)


    def _GetOutputFile(self, context, kind, path):

        base = os.path.basename(path)
        if kind != self.KIND_PRECOMPILE:
            base = os.path.splitext(base)[0]
        base += { DGTest.KIND_PREPROCESS : ".i",
                  DGTest.KIND_COMPILE : ".s",
                  DGTest.KIND_ASSEMBLE : ".o",
                  DGTest.KIND_LINK: ".exe",
                  DGTest.KIND_RUN : ".exe",
                  GCCTestBase.KIND_PRECOMPILE : ".gch",
                  }[kind]

        return os.path.join(context.GetTemporaryDirectory(), base)


    def _DGrequire_iconv(self, line_num, args, context):
        """Emulate the 'dg-require-iconv' command.

        Emulates code from 'libstdc++-v3/testsuite/lib/dg-options.exp'
        and 'gcc/testsuite/lib/target-supports.exp'.
        
        'line_num' -- The number at which the command was found.

        'args' -- The arguments to the command, as a list of
        strings.

        'context' -- The 'Context' in which the test is running."""

        # Parse arguments.
        if len(args) != 1:
            self._Error("dg-require-iconv: wrong number of arguments")
            return

        charset = args[0]

        # Check to see if iconv does exist and work.
        # First by creating and compiling a test program...
        tmpdir = context.GetTemporaryDirectory()
        tmpc = os.path.join(tmpdir, "tmp.c")
        tmpx = os.path.join(tmpdir, "tmp.x")
        f = open(tmpc, "w")
        f.write("""\
#include <iconv.h>
int main (void)
{
    iconv_t cd;
    cd = iconv_open("%(charset)s", "UTF-8");
    if (cd == (iconv_t) -1)
        return 1;
    return 0;
}
"""
                % {"charset": charset})
        f.close()

        compiler = context["CompilerTable.compiler_table"][self._language]
        options = []

        options += context["V3Init.basic_cxx_flags"]
        options += context["V3Init.default_cxx_flags"]
        libpaths = context["V3Init.libpaths"]
        options += ["-L" + p for p in libpaths]

        if context.has_key("GCCTest.libiconv"):
            libiconv_opts = context["GCCTest.libiconv"].split()
        else:
            libiconv_opts = []
        
        (status, output) = compiler.Compile(compiler.MODE_LINK,
                                            [tmpc] + libiconv_opts,
                                            tmpdir, options, tmpx)
        if output == "":
            # ...and then running it, if there are no errors.
            executable = self.TargetExecutable(self.executable_timeout)
            command = [tmpx]
            environment = self._GetTargetEnvironment(context)
            status = executable.Run(command, environment, tmpdir)
            if os.WIFEXITED(status) and os.WEXITSTATUS(status) == 0:
                # We have working libiconv.  Continue as normal.
                return

        # Something went wrong somewhere -- libiconv is not available.
        # Turn off the test.
        self._selected = 0
        # Not clear that setting the expectation here serves any
        # purpose, but it's what 'dg-options.exp' does, so we do too.
        self._expectation = Result.PASS



# check-abi first builds
#    abi_check
#    baseline_symbols
#    current_symbols.txt
# then does
#    ./abi_check --check(-verbose) ./current_symbols.txt ${baseline_file}
#
# abi_check is built by automake as a program.
# baseline_symbols just checks to see if a baseline file exists
# current_symbols.txt depends on ${extract_symvers} ../src/.libs/libstdc++.so
#
#
# new-abi-baseline is what actually generates a new baseline.
# it does it with ${extract_symvers} ../src/.libs/libstdc++.so ${baseline_file}
# baseline_file = ${baseline_dir}/baseline_symbols.txt
# baseline_dir is set by autoconf to some mad thing...
#    $glibcxx_srcdir/config/abi/${abi_baseline_pair}\$(MULTISUBDIR)"
# abi_baseline_pair is set by autoconf to host_cpu-host_os by default.
# but there are some special cases, in particular:
#    x86_64-*-linux*     -> x86_64-linux-gnu
#    alpha*-*-freebsd5*  -> alpha-freebsd5
#    i*86-*-freebsd4*    -> i386-freebsd4
#    i*86-*-freebsd5*    -> i386-freebsd5
#    sparc*-*-freebsd5*  -> sparc-freebsd5
#
# extract_symvers = $(glibcxx_srcdir)/scripts/extract_symvers
# extract_symvers is actually just a shell script
        
class V3ABITest(Test):
    """A 'V3ABITest' checks the ABI of libstdc++ against a baseline.

    Depends on context variable 'V3Test.abi_baseline_file'."""

    def Run(self, context, result):

        # Some variables we'll need throughout.
        executable = RedirectedExecutable()
        tmpdir = context.GetTemporaryDirectory()
        outdir = context["V3Init.outdir"]
        srcdir = self.GetDatabase().GetRoot()

        # First we make sure that the abi_check program exists.
        abi_check = os.path.join(outdir, "abi_check")
        status = executable.Run(["make", "abi_check"], dir=outdir)
        result["make_abi_check_stdout"] = ("<pre>" + executable.stdout
                                           + "</pre>")
        result["make_abi_check_stderr"] = ("<pre>" + executable.stderr
                                           + "</pre>")
        result["make_abi_check_status"] = str(status)
        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            result.SetOutcome(result.ERROR, "Error building abi_check")
            return
        if not os.path.isfile(abi_check):
            result.SetOutcome(result.ERROR,
                              "No abi_check program '%s'" % abi_check)
            return

        # Now make sure the baseline file exists.
        baseline_type = self._GetAbiName(context["DejaGNUTest.target"])
        baseline_file = os.path.join(srcdir, "..", "config", "abi",
                                     baseline_type,
                                     "baseline_symbols.txt")
        result["baseline_file"] = baseline_file
        if not os.path.isfile(baseline_file):
            result.SetOutcome(result.ERROR,
                              "No baseline file '%s'" % baseline_file)
            return

        # Check that we have the 'extract_symvers' script.
        # 3.4+ stores it in scripts; 3.3 stores it in config/abi.
        subdirs = ["scripts", os.path.join("config", "abi")]
        for subdir in subdirs:
            extract_symvers = os.path.join(srcdir, "..",
                                           subdir,
                                           "extract_symvers")
            if os.path.isfile(extract_symvers):
                break
        else:
            result.SetOutcome(result.ERROR,
                              "Can't find extract_symvers")
            return

        # Extract the current symbols.
        # First use ldd to find the libstdc++ in use.
        status = executable.Run(["ldd", "abi_check"], dir=outdir)
        result["ldd_stdout"] = ("<pre>" + executable.stdout
                                            + "</pre>")
        result["ldd_stderr"] = ("<pre>" + executable.stderr
                                            + "</pre>")
        result["ldd_status"] = str(status)
        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            result.SetOutcome(result.ERROR,
                              "Error running ldd to find libstdc++")
            return
        for token in executable.stdout.split():
            if os.sep in token and token.find("libstdc++") != -1:
                libstdcpp = token
                break
        else:
            result.SetOutcome(result.ERROR,
                              "Could not find path to libstdc++ in "
                              "ldd output")
            return
#         libstdcpp = os.path.join(outdir, "..", "src", ".libs",
#                                  "libstdc++.so")
        result["libstdcpp_path"] = libstdcpp

        curr_symbols = os.path.join(tmpdir, "current_symbols.txt")
        status = executable.Run([extract_symvers,
                                 libstdcpp,
                                 curr_symbols])
        result["extract_symvers_stdout"] = ("<pre>" + executable.stdout
                                            + "</pre>")
        result["extract_symvers_stderr"] = ("<pre>" + executable.stderr
                                            + "</pre>")
        result["extract_symvers_status"] = str(status)
        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            result.SetOutcome(result.ERROR, "Error extracting symbols")
            return
        if not os.path.isfile(curr_symbols):
            result.SetOutcome(result.ERROR, "No symbols extracted")
            return

        # We have the checker program, we have the baseline, we have the
        # current symbols.  Now we use the former to compare the
        # latter.
        status = executable.Run([abi_check, "--check-verbose",
                                 curr_symbols, baseline_file])
        result["comparison_stdout"] = ("<pre>" + executable.stdout
                                            + "</pre>")
        result["comparison_stderr"] = ("<pre>" + executable.stderr
                                            + "</pre>")
        result["comparison_status"] = str(status)
        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            result.SetOutcome(result.ERROR,
                              "Error comparing symbols to baseline")
            return

        # Parse the output.
        for line in executable.stdout.split("\n"):
            if line.startswith("# of "):
                num_changes_str = line.split(":", 1)[1].strip()
                num_changes = int(num_changes_str)
                if num_changes != 0:
                    result.Fail("Changes against ABI baseline detected")
                    result["failing_line"] = line.strip()
                    return


    def _GetAbiName(self, host):
        """Map a target triple to a abi directory name.

        Emulates 'configure.host'."""

        cpu, vendor, os = host.split("-", 2)
        m = fnmatch.fnmatch
        if m(cpu, "alpha*"):
            cpu = "alpha"
        elif m(cpu, "i[567]86") or m(cpu, "x86_64"):
            cpu = "i486"
        elif m(cpu, "hppa*"):
            cpu = "hppa"
        elif m(cpu, "powerpc*") or m(cpu, "rs6000"):
            cpu = "powerpc"
        elif m(cpu, "s390x"):
            cpu = "s390"
        elif m(cpu, "sparc*") or m(cpu, "ultrasparc"):
            cpu = "sparc"

        return "%s-%s" % (cpu, os)
            
-------------- next part --------------
########################################################################
#
# File:   v3_database.py
# Author: Nathaniel Smith
# Date:   03/01/2004
#
# Contents:
#   V3Database
#
# Copyright (c) 2004 by CodeSourcery, LLC.  All rights reserved. 
#
########################################################################

########################################################################
# Imports
########################################################################

import fnmatch
import os
import qm
import qm.test.base
from   qm.attachment import Attachment, FileAttachmentStore
from   qm.test.database import ResourceDescriptor, TestDescriptor
from   qm.test.file_database import FileDatabase
from   qm.test.runnable import Runnable

########################################################################
# Classes
########################################################################

class V3Database(FileDatabase):
    """A 'V3Database' stores the libstc++-v3 regression tests."""

    arguments = [
        qm.fields.TextField(
            name = "srcdir",
            title = "Source Directory",
            description ="""The root of the libstdc++-v3 test source directory.

            This directory is the one named 'testsuite'."""),
        # The libstdc++ database uses filenames as labels.
        qm.fields.TextField(
            name = "label_class",
            default_value = "file_label.FileLabel",
            computed = "true"
            ),
        # The libstdc++ database cannot be modified programmatically.
        qm.fields.BooleanField(
            name = "modifiable",
            default_value = "false",
            computed = "true",
            ),
        ]
    
    def __init__(self, path, arguments):

        # Initialize the base class.
        super(V3Database, self).__init__(path, arguments)
        # Create an attachment store.
        self.__store = FileAttachmentStore()

        
    def GetResource(self, resource_id):

        if resource_id == "compiler_table":
            return ResourceDescriptor(self, resource_id,
                                      "compiler_table.CompilerTable",
                                      {})
        elif resource_id == "v3_init":
            return ResourceDescriptor(self, resource_id,
                                      "v3_test.V3Init",
                                      { Runnable.RESOURCE_FIELD_ID :
                                        ["compiler_table"] })

        raise self.NoSuchResourceError, resource_id
        
        
    def GetRoot(self):

        return self.srcdir


    def GetAttachmentStore(self):

        return self.__store


    def GetTestIds(self, directory="", scan_subdirs=1):

        result = super(V3Database, self).GetTestIds(directory,
                                                    scan_subdirs)
        if directory == "":
            return result + ["v3_abi_test"]
        else:
            return result


    def GetTest(self, test_id):

        if test_id == "v3_abi_test":
            return TestDescriptor(self, test_id,
                                  "v3_test.V3ABITest",
                                  { Runnable.RESOURCE_FIELD_ID:
                                    ["v3_init"]})
        else:
            return super(V3Database, self).GetTest(test_id)
        

    def _GetTestFromPath(self, test_id, path):

        # Construct the attachment representing the primary source
        # file.
        basename = os.path.basename(path)
        attachment = Attachment("text/plain", basename,
                                basename, path,
                                self.GetAttachmentStore())

        # Create the test descriptor.
        resources = ["v3_init"]
        descriptor = TestDescriptor(self, test_id,
                                    "v3_test.V3DGTest",
                                    { 'source_file' : attachment,
                                      Runnable.RESOURCE_FIELD_ID :
                                        resources })

        return descriptor
        
                

    def _IsResourceFile(self, path):

        # No resources are stored in files.
        return False

        
    def _IsSuiteFile(self, path):

        # All directories are suites.
        return os.path.isdir(path)

        
    def _IsTestFile(self, path):
        """This function emulates scripts/create_testsuite_files."""

        assert path.startswith(self.GetRoot() + os.sep)

        rel_path = path[len(self.GetRoot()) + 1:]
        if os.sep not in rel_path:
            return False

        if not rel_path.endswith(".cc"):
            return False

        forbidden_substrings = ["_xin", "performance"]
        # FIXME: create_testsuite_files checks to see if wchar_t support
        # is enabled (by checking for the existence of
        # $outdir/testsuite_wchar_t), and if it isn't, then "wchar_t" is
        # added to the forbidden list.  The right way to handle this in
        # QMTest is not obvious, so for now we ignore this.
        for f in forbidden_substrings:
            if rel_path.find(f) != -1:
                return False

        return True

From njs at pobox.com  Thu Mar 18 18:43:25 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Thu, 18 Mar 2004 10:43:25 -0800
Subject: [PATCH] Small bug introduced by previous change
Message-ID: <20040318184325.GA19004@njs.ddts.net>

Already committed.

-- Nathaniel

-- 
"The problem...is that sets have a very limited range of
activities -- they can't carry pianos, for example, nor drink
beer."


From mark at codesourcery.com  Thu Mar 18 18:53:39 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 18 Mar 2004 10:53:39 -0800
Subject: [qmtest] [PATCH] qmtest_gcc: Support libstdc++ testing under
 QMTest
In-Reply-To: <20040318183915.GA18853@njs.ddts.net>
References: <20040318183915.GA18853@njs.ddts.net>
Message-ID: <4059F033.70400@codesourcery.com>

Nathaniel --

>#         print "options = %s" % repr(options)
>#         print "directory = '%s'" % directory
>#         print "objdir = '%s'" % objdir
>#         print "target = '%s'" % target
>#         print "blddir = '%s'" % blddir
>#         print "outdir = '%s'" % outdir
>#         print "srcdir = '%s'" % srcdir
>
>  
>
Let's lose those....

>#         libstdcpp = os.path.join(outdir, "..", "src", ".libs",
>#                                  "libstdc++.so")
>  
>
Similarly.

Thanks,

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com



From mark at codesourcery.com  Thu Mar 18 18:54:05 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 18 Mar 2004 10:54:05 -0800
Subject: [qmtest] [PATCH] Small bug introduced by previous change
In-Reply-To: <20040318184325.GA19004@njs.ddts.net>
References: <20040318184325.GA19004@njs.ddts.net>
Message-ID: <4059F04D.70000@codesourcery.com>

Nathaniel Smith wrote:

>Already committed.
>
>-- Nathaniel
>
>  
>
What was already commited?  Was there supposed to be a patch here?

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com



From njs at pobox.com  Thu Mar 18 22:26:19 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Thu, 18 Mar 2004 14:26:19 -0800
Subject: [qmtest] [PATCH] qmtest_gcc: Support libstdc++ testing under QMTest
In-Reply-To: <4059F033.70400@codesourcery.com>
References: <20040318183915.GA18853@njs.ddts.net> <4059F033.70400@codesourcery.com>
Message-ID: <20040318222619.GA31899@njs.ddts.net>

On Thu, Mar 18, 2004 at 10:53:39AM -0800, Mark Mitchell wrote:
> >#         print "options = %s" % repr(options)
> >#         print "directory = '%s'" % directory
> >#         print "objdir = '%s'" % objdir
> >#         print "target = '%s'" % target
> >#         print "blddir = '%s'" % blddir
> >#         print "outdir = '%s'" % outdir
> >#         print "srcdir = '%s'" % srcdir
> >
> Let's lose those....
> 
> >#         libstdcpp = os.path.join(outdir, "..", "src", ".libs",
> >#                                  "libstdc++.so")
> >
> Similarly.

Good point.  Committed.

-- Nathaniel

-- 
Details are all that matters; God dwells there, and you never get to
see Him if you don't struggle to get them right. -- Stephen Jay Gould


From njs at pobox.com  Tue Mar 30 18:27:14 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Tue, 30 Mar 2004 10:27:14 -0800
Subject: [PATCH] qmtest_gcc updates
Message-ID: <20040330182714.GA21725@njs.ddts.net>

- Rework V3 testsuite to handle the no-compiler scenario.
- Use new Result.Quote method.

-- Nathaniel

-- 
"...All of this suggests that if we wished to find a modern-day model
for British and American speech of the late eighteenth century, we could
probably do no better than Yosemite Sam."
-------------- next part --------------
Index: build_v3_dist
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/build_v3_dist,v
retrieving revision 1.1
diff -u -r1.1 build_v3_dist
--- build_v3_dist	18 Mar 2004 18:34:30 -0000	1.1
+++ build_v3_dist	30 Mar 2004 18:09:13 -0000
@@ -1,4 +1,6 @@
-#!/usr/bin/python 
+#!/usr/bin/env python 
+
+# Note that this script must be run with Python 2.3.
 
 import sys
 import os
@@ -20,8 +22,8 @@
                      help="Package version (default 1.0)")
 optparser.add_option("-o", "--output", action="store",
                      dest="targetdir", metavar="DIR",
-                     help="Output directory"
-                     "(default qmtest_libstdcpp_GCCVER-PKGVER)")
+                     help="Output directory "
+                     "(default: qmtest_libstdcpp_GCCVER-PKGVER)")
 optparser.add_option("-f", "--force", action="store_true",
                      dest="force", default=False,
                      help="If output directory already exists, delete it")
@@ -29,13 +31,10 @@
                      dest="baselines", default=[],
                      help="Additional result file to distribute (may be "
                      "used multiple times)")
-
-
-def usage(name):
-    print "Usage: %s <full-gcc-version> <source-directory> " \
-          "<destination-directory>" % name
-    print "E.g., %s 3.3.3 gcc-3.3.3 my-gcc-3.3.3-package" % name
-    sys.exit(2)
+optparser.add_option("-c", "--config-guess", action="store",
+                     dest="config_guess", metavar="FILE",
+                     help="Path to config.guess "
+                     "(default: search in /usr/share/)")
 
 
 def ensure_dir(dir):
@@ -54,8 +53,36 @@
         os.mkdir(dir)
         
 
-def main(name, args):
+def add(source_file_or_dir, *target_path):
+    dest = os.path.join(*target_path)
+    ensure_dir(os.path.dirname(dest))
+    if os.path.isfile(source_file_or_dir):
+        shutil.copy(source_file_or_dir, dest)
+    elif os.path.isdir(source_file_or_dir):
+        shutil.copytree(source_file_or_dir, dest)
+    else:
+        assert 0, "add() must be given a file or directory"
+
+
+def generate(source_string, substitutions, *target_path):
+    dest = os.path.join(*target_path)
+    ensure_dir(os.path.dirname(dest))
+    f = open(dest, "w")
+    f.write(source_string % substitutions)
+    f.close()
+
 
+class InstallRecorder(object):
+    def __init__(self, file_to_record_in):
+        ensure_dir(os.path.dirname(file_to_record_in))
+        self._file = open(file_to_record_in, "w")
+    def __call__(self, path):
+        self._file.write("%s\n" % path)
+
+
+def main(fullname, args):
+
+    name = os.path.basename(fullname)
     options, args = optparser.parse_args(args)
     if len(args) != 4:
         optparser.error("Wrong number of arguments")
@@ -80,41 +107,46 @@
         sys.exit(2)
 
     v3src = j(srcdir, "libstdc++-v3")
-    ensure_dir(targetdir)
 
     # Open a file to record which directories exist (and thus need
     # installing).
-    content_files = open(j(targetdir, "contents"), "w")
+    install = InstallRecorder(j(targetdir, "share-contents"))
 
-    # Mark that this will be a standalone installation, for later use by
-    # the QMTest scripts.
-    f = open(j(targetdir, "THIS-IS-STANDALONE-V3"), "w")
-    # In case we need to version stuff later:
-    f.write("1\n")
-    f.close()
-    content_files.write("THIS-IS-STANDALONE-V3\n")
+    # Put 'config.guess' in.
+    if options.config_guess is None:
+        config_guesses = glob.glob("/usr/share/*/config.guess")
+        if not config_guesses:
+            optparser.error("Cannot find config.guess, use "
+                            "--config-guess") 
+        config_guess = config_guesses[0]
+    else:
+        config_guess = options.config_guess
+    add(config_guess, targetdir, "config.guess")
+
+    # Mark that this will be a standalone installation, for later
+    # detection by the QMTest harness.  We write the numeral '1' in case
+    # we need versioning information later.
+    generate("1\n", {}, targetdir, "THIS-IS-STANDALONE-V3")
+    install("THIS-IS-STANDALONE-V3")
 
     # Copy gcc stuff over:
-    shutil.copytree(j(v3src, "testsuite"), j(targetdir, "testsuite"))
-    content_files.write("testsuite\n")
-    shutil.copytree(j(v3src, "po"), j(targetdir, "po"))
-    content_files.write("po\n")
+    add(j(v3src, "testsuite"), targetdir, "testsuite")
+    install("testsuite")
+    add(j(v3src, "po"), targetdir, "po")
+    install("po")
     ensure_dir(j(targetdir, "config"))
-    shutil.copytree(j(v3src, "config", "abi"),
-                    j(targetdir, "config", "abi"))
-    content_files.write("config\n")
+    add(j(v3src, "config", "abi"), targetdir, "config", "abi")
+    install("config")
     
     # gcc 3.4 has a scripts dir that we need.
     if os.path.exists(j(v3src, "scripts")):
-        shutil.copytree(j(v3src, "scripts"), j(targetdir, "scripts"))
-        content_files.write("scripts\n")
+        add(j(v3src, "scripts"), targetdir, "scripts")
+        install("scripts")
 
     # Copy in QMTest extension classes.
-    ensure_dir(j(targetdir, "qm-classes"))
-    content_files.write("qm-classes\n")
-    shutil.copytree(qmtcdir, j(targetdir, "qm-classes", "qmtc"))
-    shutil.copytree(qmtest_gccdir,
-                    j(targetdir, "qm-classes", "qmtest_gcc"))
+    add(qmtcdir, targetdir, "qm-classes", "qmtc")
+    add(qmtest_gccdir, targetdir, "qm-classes", "qmtest_gcc")
+    install("qm-classes")
     # And then clean them up a bit (remove backup files, compiled files,
     # and CVS/ directories).
     for g in "*~", "*.pyc", "*.pyo":
@@ -125,49 +157,51 @@
 
     # Copy over any supplied baselines.
     ensure_dir(j(targetdir, "qm-baselines"))
-    content_files.write("qm-baselines\n")
+    install("qm-baselines")
     for b in options.baselines:
-        shutil.copyfile(b, j(targetdir, "qm-baselines",
-                             os.path.basename(b)))
+        add(b, targetdir, "qm-baselines", os.path.basename(b))
 
-    # Now create the misc. files.
-    miscdir = j(targetdir, "qm-misc")
-    ensure_dir(miscdir)
-    content_files.write("qm-misc\n")
+    # Copy this script into the package.
+    add(__file__, targetdir, "build_v3_dist")
 
+    # Set up the substitutions dict used by all our templates.
     substitutions = {"prog_name": name,
+                     "prog_fullname": fullname,
                      "gcc_version": gcc_version,
                      "pkg_version": pkg_version,
                      "prog_args": " ".join(args),
                      "user": getpass.getuser(),
-                     "time": time.strftime("%Y-%m-%d %H:%M:%S "),
+                     "time": time.strftime("%Y-%m-%d %H:%M:%S"),
                      }
 
-    f = open(j(miscdir, "locale-Makefile"), "w")
-    f.write(locale_Makefile % substitutions)
-    f.close()
-
-    f = open(j(miscdir, "util-Makefile"), "w")
-    f.write(util_Makefile % substitutions)
+    # Munge testsuite_hooks.h to make testsuite executables
+    # relocatable.
+    f = open(j(targetdir, "testsuite", "testsuite_hooks.h"), "a")
+    f.write(testsuite_hooks_addendum % substitutions)
     f.close()
+    
+    # Now create the misc. files.
+    miscdir = j(targetdir, "qm-misc")
+    ensure_dir(miscdir)
+    install("qm-misc")
 
-    # And the distribution-level files.
-    f = open(j(targetdir, "README"), "w")
-    f.write(README_file % substitutions)
-    f.close()
+    generate(locale_Makefile, substitutions, miscdir, "locale-Makefile")
 
-    f = open(j(targetdir, "PKGINFO"), "w")
-    f.write(PKGINFO_file % substitutions)
-    f.close()
+    generate(util_Makefile, substitutions, miscdir, "util-Makefile")
 
-    f = open(j(targetdir,
-               "qmtest_libstdcpp_%(gcc_version)s.spec"
-               % substitutions),
-             "w")
-    f.write(spec_file % substitutions)
-    f.close()
+    # And the distribution-level files.
+    generate(README_file, substitutions, targetdir, "README")
+    generate(PKGINFO_file, substitutions, targetdir, "PKGINFO")
+    generate(spec_file, substitutions,
+             targetdir, "qmtest_libstdcpp_%(gcc_version)s.spec"
+                        % substitutions)
+    generate(build_binary_testsuite_file, substitutions,
+             targetdir, "build_binary_testsuite")
+    os.chmod(j(targetdir, "build_binary_testsuite"), 0755)
     
 
+## All the templates for generated files:
+
 locale_Makefile = """\
 # Do not edit -- this file automatically generated by %(prog_name)s.
 # Makefile to build locale files needed by libstdc++-v3 testsuite.
@@ -348,7 +382,7 @@
      CompilerTable.cplusplus_path=g++
      CompilerTable.cplusplus_options=
      DejaGNUTest.target=i686-pc-linux-gnu
-     V3Init.scratch_dir=scratch
+     V3Test.scratch_dir=scratch
 
   You should adjust the "DejaGNUTest.target" line to indicate the GNU
   triplet for your operating system.
@@ -386,12 +420,23 @@
     http://www.codesourcery.com/qm/qmtest_manual
 """
 
+testsuite_hooks_addendum = """
+
+// Following added automatically by %(prog_name)s:
+#ifdef LOCALEDIR
+#error "LOCALEDIR should not be defined for standalone testing; \
+set environment variable V3_LOCALEDIR instead"
+#endif
+#include <cstdlib>
+#define LOCALEDIR (std::getenv("V3_LOCALEDIR"))
+"""
+
 PKGINFO_file = """\
 This package generated automatically by %(prog_name)s.
 
 Invoked by %(user)s at %(time)s.
 Call was:
-  $ %(prog_name)s %(prog_args)s
+  $ %(prog_fullname)s %(prog_args)s
 
 """
 
@@ -407,7 +452,10 @@
 BuildRoot:   %%{_tmppath}/%%{name}-buildroot
 Source:      qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s.tar.gz
 Vendor:      CodeSourcery LLC
-BuildArchitectures: noarch
+# If we let RPM detect dependencies, it will get the idea that this
+# package requires a specific version of libstdc++.so, and that is
+# unhelpful:
+AutoReqProv: no
 
 %%description
 This package includes the libstdc++-v3 testsuite from gcc version
@@ -421,16 +469,26 @@
 
 %%install
 rm -rf $RPM_BUILD_ROOT
-DIR=$RPM_BUILD_ROOT/usr/share/qmtest_libstdcpp_%(gcc_version)s
-mkdir -p $DIR
-for thing in `cat contents`; do
+
+# We do the building first, because some of the files generated will be
+# installed later.
+LIBDIR=$RPM_BUILD_ROOT/usr/lib/qmtest_libstdcpp_%(gcc_version)s
+mkdir -p `dirname $LIBDIR`
+./build_binary_testsuite $LIBDIR 2>&1 | tee BUILD-DETAILS
+
+SHAREDIR=$RPM_BUILD_ROOT/usr/share/qmtest_libstdcpp_%(gcc_version)s
+mkdir -p $SHAREDIR
+for thing in `cat share-contents`; do
     if [ -d "$thing" ]; then
-        cp -r "$thing" "$DIR/$thing"
+        cp -r "$thing" "$SHAREDIR/$thing"
     else
-        cp "$thing" "$DIR/$thing"
+        cp "$thing" "$SHAREDIR/$thing"
     fi
 done
 
+find $LIBDIR -name '*.pyc' -o -name '*.pyo' -print0 | xargs -0 rm -f
+find $SHAREDIR -name '*.pyc' -o -name '*.pyo' -print0 | xargs -0 rm -f
+
 %%clean
 rm -rf $RPM_BUILD_ROOT
 
@@ -438,13 +496,239 @@
 # Install all files as root:
 %%defattr(-,root,root)
 /usr/share/qmtest_libstdcpp_%(gcc_version)s/
+/usr/lib/qmtest_libstdcpp_%(gcc_version)s/
 %%doc README
+%%doc PKGINFO
+%%doc BUILD-DETAILS
+%%doc executable-gen.qmr
+%%doc build_v3_dist
+%%doc build_binary_testsuite
 
 %%changelog
+* Mon Mar 29 2004 Nathaniel Smith <njs at codesourcery.com> 
+- Rework for no-compiler version of testsuite.
+
 * Tue Mar 16 2004 Nathaniel Smith <njs at codesourcery.com> 
 - Initial release.
 
 """
 
+
+build_binary_testsuite_file = """\
+#!/usr/bin/env python
+
+# This script builds the executables needed for testing libstdc++
+# without a compiler, and then runs the tests to generate a baseline.
+# You should ensure that a canonical version of g++ is in your PATH, and
+# a canonical version of libstdc++ in your LD_LIBRARY_PATH, before
+# running this script; they will be taken as the gold standard against
+# which tested versions will be compared.
+#
+# It must be run from the directory that contains the standalone V3
+# distribution.
+
+usage = \"\"\"\\
+Usage:
+    %%(progname)s [executable-output-directory] [g++ to use] \\\\
+       [directory containing libstdc++ to use]
+If the first argument is not given, it defaults to "qm-executables".  If
+the last two arguments are not given, defaults will be found in
+PATH/LD_LIBRARY_PATH.
+\"\"\"
+
+import sys
+import os
+import os.path
+import tempfile
+import shutil
+import atexit
+import glob
+
+def error(*msgs):
+    sys.stderr.write("ERROR: " + "".join(msgs) + "\\n")
+    sys.stderr.flush()
+
+def log(*msgs):
+    prefix = "%%s: " %% progname
+    sys.stdout.write(prefix  + "".join(msgs) + "\\n")
+    sys.stdout.flush()
+
+def run_and_log(cmdline, failure_ok=False):
+    log("Running command: %%s" %% cmdline)
+    log("Output:")
+    status = os.system(cmdline)
+    if status != 0 and not failure_ok:
+        error("Command did not complete successfully.")
+        error("Exit status: %%i" %% status)
+        sys.exit(1)
+    log("Execution complete, status = %%i." %% status)
+    return status
+
+def resolve_executable(name):
+    if os.path.isabs(name):
+        return name
+    if os.sep in name:
+        return os.path.abspath(name)
+    log("Searching PATH for %%s." %% name)
+    path = os.environ.get("PATH", "").split(os.pathsep)
+    for dir in path:
+        candidate = os.path.join(dir, name)
+        if os.path.exists(candidate):
+            return os.path.abspath(candidate)
+    error("Cannot find executable %%s." %% name)
+    sys.exit(1)
+
+if not os.path.exists("THIS-IS-STANDALONE-V3"):
+    error("must run from root of standalone libstdc++ test "
+          "distribution.")
+    sys.exit(2)
+
+# This global variable is used directly by log().
+full_progname = sys.argv[0]
+progname = os.path.basename(full_progname)
+args = sys.argv[1:]
+
+log("Called as: %%s %%s" %% (full_progname, " ".join(args)))
+
+## Process arguments.
+if not 0 <= len(args) <= 3:
+    error("bad command line.")
+    sys.stderr.write(usage %% {"progname": progname})
+    sys.exit(2)
+
+## Find compiler output directory.
+if args:
+    compiler_output_dir = args.pop(0)
+else:
+    compiler_output_dir = "qm-executables"
+
+## Find g++.
+if args:
+    gpp_path = args.pop(0)
+else:
+    gpp_path = "g++"
+gpp_path = resolve_executable(gpp_path)
+
+log("Using g++: %%s" %% gpp_path)
+run_and_log("%%s --version" %% gpp_path)
+log()
+
+## Find libstdc++.
+if args:
+    libstdcpp_path = args.pop(0)
+    curr = os.environ.get("LD_LIBRARY_PATH", "")
+    new = "%%s:%%s" %% (libstdcpp_path, curr)
+    os.environ["LD_LIBRARY_PATH"] = new
+
+log('Using LD_LIBRARY_PATH="%%s".'
+    %% os.environ.get("LD_LIBRARY_PATH", ""))
+log()
+
+## Find qmtest.
+qmtest_path = resolve_executable("qmtest")
+log("Using qmtest: %%s" %% qmtest_path)
+run_and_log("%%s --version" %% qmtest_path)
+log()
+
+## Set up the compiler output directory.
+if os.path.exists(compiler_output_dir):
+    error("output directory %%s already exists." %% compiler_output_dir)
+    sys.exit(1)
+
+os.mkdir(compiler_output_dir)
+
+## Create the temporary scratch directory.
+if hasattr(tempfile, "mkdtemp"):
+    tmpdir = tempfile.mkdtemp()
+else:
+    tmpdir = tempfile.mktemp()
+    os.mkdir(tmpdir)
+atexit.register(shutil.rmtree, tmpdir)
+
+## Find the target triplet.
+(config_guess_in, config_guess_out) = os.popen4("./config.guess")
+config_guess_in.close()
+target_triplet = config_guess_out.read()
+target_triplet = target_triplet.strip()
+assert "-" in target_triplet, "Bad target triplet"
+log("Using target triplet: %%s" %% target_triplet)
+log()
+
+## Create the basic context to use.
+log("Creating V3 context file.")
+context_path = os.path.join(tmpdir, "__v3_context__")
+f = open(context_path, "w")
+f.write(\"\"\"\\
+CompilerTable.languages=cplusplus
+CompilerTable.cplusplus_kind=GCC
+CompilerTable.cplusplus_options=
+CompilerTable.cplusplus_path=%%(gpp_path)s
+DejaGNUTest.target=%%(target_triplet)s
+V3Test.scratch_dir=%%(tmpdir)s
+V3Test.compiler_output_dir=%%(compiler_output_dir)s
+\"\"\" %% locals())
+f.close()
+
+## Set up QMTest environment variables.
+class_paths = [os.path.abspath(os.path.join("qm-classes", pkg))
+               for pkg in "qmtc", "qmtest_gcc"]
+qmtest_class_path = os.pathsep.join(class_paths)
+os.environ["QMTEST_CLASS_PATH"] = qmtest_class_path
+log('Using QMTEST_CLASS_PATH="%%s"' %% qmtest_class_path)
+log()
+
+## Create the test database we use.
+log("Creating V3 test database.")
+dbpath = os.path.join(tmpdir, "__v3_db__")
+srcdir = os.path.abspath("testsuite")
+run_and_log("qmtest -D %%(dbpath)s create-tdb "
+                     "-c v3_database.V3Database "
+                     "-a srcdir=%%(srcdir)s" %% locals())
+log()
+
+## Okay, we're ready to run the tests for the first time.
+log("Running QMTest to generate executables.")
+log("Results stored in executable-gen.qmr")
+status = run_and_log("qmtest -D %%(dbpath)s run "
+                     "-C %%(context_path)s --format=brief "
+                     "-o executable-gen.qmr"
+                     %% locals(),
+                     failure_ok=True)
+if status == 0 or (os.WIFEXITED(status) and os.WEXITSTATUS(status) == 1):
+    log("Acceptable output status.")
+else:
+    error("qmtest exited unsuccessfully.")
+    sys.exit(1)
+
+## Clean the irrelevant non-executable output files; they take up a lot of
+## space.
+log("Cleaning up executable directory.")
+for junk in glob.glob(os.path.join(compiler_output_dir, "*.[sio]")):
+    os.unlink(junk)
+    log("    Deleted: %%s" %% junk)
+
+## We have the executables; all is well.  Now we'll run it again to
+## generate the baseline result file.
+log("Running QMTest again to generate baseline results.")
+baseline_basename = "%%s.qmr" %% target_triplet
+baseline = os.path.abspath(os.path.join("qm-baselines",
+                                        baseline_basename))
+log("Results stored in %%s" %% baseline)
+run_and_log("qmtest -D %%(dbpath)s run "
+            "-C %%(context_path)s --format=brief "
+            "-c V3Test.have_compiler=no "
+            "-o %%(baseline)s"
+            %% locals(),
+            failure_ok=True)
+if status == 0 or (os.WIFEXITED(status) and os.WEXITSTATUS(status) == 1):
+    log("Acceptable output status.")
+else:
+    error("qmtest exited unsuccessfully.")
+    sys.exit(1)
+
+## All done.
+log("All done.")
+"""
+        
 if __name__ == "__main__":
     main(sys.argv[0], sys.argv[1:])
Index: gpp_init.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gpp_init.py,v
retrieving revision 1.8
diff -u -r1.8 gpp_init.py
--- gpp_init.py	18 Mar 2004 18:42:17 -0000	1.8
+++ gpp_init.py	30 Mar 2004 18:09:13 -0000
@@ -82,7 +82,7 @@
                                 "testsuite_flags"),
                    "--build-includes"]
         result["GPPInit.testsuite_flags_command"] \
-            = "<pre>" + " ".join(command) + "</pre>"
+            = result.Quote(" ".join(command))
         try:
             executable = RedirectedExecutable()
             executable.Run(command)
Index: v3_test.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/v3_test.py,v
retrieving revision 1.2
diff -u -r1.2 v3_test.py
--- v3_test.py	18 Mar 2004 22:26:11 -0000	1.2
+++ v3_test.py	30 Mar 2004 18:09:13 -0000
@@ -41,7 +41,22 @@
                           "LD_LIBRARY_PATH_64", "DYLD_LIBRARY_PATH"]
 """All the different envvars that might mean LD_LIBRARY_PATH."""
 
-class V3Init(Resource):
+class V3Base(object):
+    """Methods required by all V3 classes."""
+
+    def _HaveCompiler(self, context):
+        """Returns true if we have a compiler."""
+
+        if not context.has_key("V3Test.have_compiler"):
+            # By default we assume there is a compiler.
+            return True
+        
+        # But if there is a context key, we trust it.
+        return qm.parse_boolean(context["V3Test.have_compiler"])
+
+
+
+class V3Init(Resource, V3Base):
     """All V3 tests depend on one of these for setup."""
 
     def SetUp(self, context, result):
@@ -51,6 +66,24 @@
         srcdir = self.GetDatabase().GetRoot()
         target = context["DejaGNUTest.target"]
 
+        # If there is a compiler output directory given, ensure the path
+        # is absolute, and ensure it exists.
+        if context.has_key("V3Test.compiler_output_dir"):
+            compiler_outdir = context["V3Test.compiler_output_dir"]
+            compiler_outdir = os.path.abspath(compiler_outdir)
+            context["V3Test.compiler_output_dir"] = compiler_outdir
+            if not os.path.exists(compiler_outdir):
+                os.mkdir(compiler_outdir)
+        else:
+            compiler_outdir = None
+                
+        if not self._HaveCompiler(context) and compiler_outdir is None:
+            result.SetOutcome(result.ERROR,
+                              "If have_compiler is false, then "
+                              "V3Test.compiler_output_dir must be "
+                              "provided")
+            return
+
         # Are we using the standalone testsuite to test an installed
         # libstdc++/g++, or the integrated testsuite to test a
         # just-built libstdc++/g++?  Check for the magic file that the
@@ -60,11 +93,12 @@
         standalone = os.path.exists(standalone_marker)
         if standalone:
             standalone_root = os.path.join(srcdir, "..")
-        context["V3Init.is_standalone"] = standalone
+        context["V3Test.is_standalone"] = standalone
 
         # Find the compiler.
-        compilers = context["CompilerTable.compiler_table"]
-        compiler = compilers["cplusplus"]
+        if self._HaveCompiler(context):
+            compilers = context["CompilerTable.compiler_table"]
+            compiler = compilers["cplusplus"]
 
 
         if not standalone:
@@ -100,16 +134,16 @@
             # Our code always refers to this directory as 'outdir' for
             # parallelism with the DejaGNU code we emulate, but we call
             # it "scratch_dir" for UI purposes.
-            if context.has_key("V3Init.outdir"):
+            if context.has_key("V3Test.outdir"):
                 result.SetOutcome(result.ERROR,
-                                  "Set V3Init.scratch_dir, not outdir")
+                                  "Set V3Test.scratch_dir, not outdir")
                 return
-            outdir = context["V3Init.scratch_dir"]
+            outdir = context["V3Test.scratch_dir"]
             outdir = os.path.abspath(outdir)
             if not os.path.exists(outdir):
                 os.mkdir(outdir)
             
-        context["V3Init.outdir"] = outdir
+        context["V3Test.outdir"] = outdir
 
         # Ensure that the message format files are available.
         # This requires different commands depending on whether we're
@@ -118,40 +152,55 @@
             locale_dir = os.path.join(blddir, "po")
             make_command = ["make", "-j1", "check"]
         else:
-            # Standalone build needs to set up the locale stuff in its
-            # own directory.
-            locale_dir = os.path.join(outdir, "qm_locale")
-            try:
-                os.mkdir(locale_dir)
-            except OSError:
-                pass
-            makefile_in = open(os.path.join(standalone_root,
-                                                  "qm-misc",
-                                                  "locale-Makefile"))
-            makefile_str = makefile_in.read()
-            makefile_str = makefile_str.replace("@ROOT@",
-                                                standalone_root)
-            makefile_out = open(os.path.join(locale_dir, "Makefile"),
-                                "w")
-            makefile_out.write(makefile_str)
-            makefile_out.close()
-            make_command = ["make", "-j1", "locales"]
+            if self._HaveCompiler(context):
+                # Standalone build needs to set up the locale stuff in its
+                # own directory.
+                locale_dir = os.path.join(outdir, "qm_locale")
+                try:
+                    os.mkdir(locale_dir)
+                except OSError:
+                    pass
+                makefile_in = open(os.path.join(standalone_root,
+                                                "qm-misc",
+                                                "locale-Makefile"))
+                makefile_str = makefile_in.read()
+                makefile_str = makefile_str.replace("@ROOT@",
+                                                    standalone_root)
+                makefile_out = open(os.path.join(locale_dir,
+                                                 "Makefile"),
+                                    "w")
+                makefile_out.write(makefile_str)
+                makefile_out.close()
+                make_command = ["make", "-j1", "locales"]
+            else:
+                # We're standalone without a compiler; we'll use the
+                # locale dir in the compiler output directory directly.
+                locale_dir = os.path.join(compiler_outdir, "qm_locale")
+            # Either way, we need to provide the locale directory as an
+            # environment variable, _not_ as a #define.
+            context["V3Init.env_V3_LOCALEDIR"] = locale_dir
 
-        make_executable = RedirectedExecutable()
-        status = make_executable.Run(make_command, dir=locale_dir)
-        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
-            result.SetOutcome(result.ERROR,
-                              "Error building locale information",
-                              {"status": str(status),
-                               "stdout": "<pre>"
-                                         + make_executable.stdout
-                                         + "</pre>",
-                               "stderr": "<pre>"
-                                         + make_executable.stderr
-                                         + "</pre>",
-                               "command": " ".join(make_command),
-                               })
-            return
+        # Now do the actual compiling, if possible.
+        if self._HaveCompiler(context):
+            make_executable = RedirectedExecutable()
+            status = make_executable.Run(make_command, dir=locale_dir)
+            if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
+                q_stdout = result.Quote(make_executable.stdout)
+                q_stderr = result.Quote(make_executable.stderr)
+                result.SetOutcome(result.ERROR,
+                                  "Error building locale information",
+                                  {"status": str(status),
+                                   "stdout": q_stdout,
+                                   "stderr": q_stderr,
+                                   "command": " ".join(make_command),
+                                   })
+                return
+
+            if compiler_outdir is not None:
+                co_ld = os.path.join(compiler_outdir, "qm_locale")
+                if os.path.exists(co_ld):
+                    shutil.rmtree(co_ld, ignore_errors=True)
+                shutil.copytree(locale_dir, co_ld)
             
 
         # Copy data files.
@@ -197,9 +246,9 @@
             ld_library_path = ":".join(original_ld_library_path)
 
         libpaths.append(outdir)
-        context["V3Init.libpaths"] = libpaths
-        context["V3Init.ld_library_path"] = ld_library_path
-        result["V3Init.ld_library_path"] = ld_library_path
+        context["V3Test.libpaths"] = libpaths
+        context["V3Test.ld_library_path"] = ld_library_path
+        result["V3Test.ld_library_path"] = ld_library_path
 
         # Calculate default g++ flags.  Both branches create basic_flags
         # and default_flags.
@@ -215,7 +264,11 @@
             basic_flags, default_flags = all_flags
         else:
             # We take the union of the 3.3 and the 3.4 defines; it
-            # doesn't seem to hurt.
+            # doesn't seem to hurt.  Only exception is that we
+            # purposefully leave out -DLOCALEDIR when doing standalone
+            # testing, so that it will be picked up from the environment
+            # instead.  This ensures that binary-only tests can be moved
+            # after being compiled.
             basic_flags = [# v3.4 only:
                            "-D_GLIBCXX_ASSERT",
                            # v3.3 only:
@@ -224,50 +277,65 @@
                            "-g", "-O2",
                            "-ffunction-sections", "-fdata-sections",
                            "-fmessage-length=0",
-                           "-DLOCALEDIR=\"%s\"" % locale_dir,
                            "-I%s" % srcdir]
             default_flags = []
+            
 
         default_flags.append("-D_GLIBCXX_ASSERT")
         if fnmatch.fnmatch(context["DejaGNUTest.target"],
                            "powerpc-*-darwin*"):
             default_flags += ["-multiply_defined", "suppress"]
-        context["V3Init.basic_cxx_flags"] = basic_flags
-        context["V3Init.default_cxx_flags"] = default_flags
+        context["V3Test.basic_cxx_flags"] = basic_flags
+        context["V3Test.default_cxx_flags"] = default_flags
         
         if standalone:
-            # Build libv3test.a.
-            makefile_in = open(os.path.join(standalone_root,
-                                            "qm-misc",
-                                            "util-Makefile"))
-            makefile_str = makefile_in.read()
-            makefile_str = makefile_str.replace("@ROOT@",
-                                                standalone_root)
-            makefile_str = makefile_str.replace("@CXX@",
-                                                compiler.GetPath())
-            flags = compiler.GetOptions() + basic_flags
-            makefile_str = makefile_str.replace("@CXXFLAGS@",
-                                                " ".join(flags))
-            makefile_out = open(os.path.join(outdir, "Makefile"), "w")
-            makefile_out.write(makefile_str)
-            makefile_out.close()
-            
-            make_executable = RedirectedExecutable()
-            make_command = ["make", "libv3test.a"]
-            status = make_executable.Run(make_command, dir=outdir)
-            if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
-                result.SetOutcome(result.ERROR,
-                                  "Error building libv3test.a",
-                                  {"status": str(status),
-                                   "stdout": "<pre>"
-                                             + make_executable.stdout
-                                             + "</pre>",
-                                   "stderr": "<pre>"
-                                             + make_executable.stderr
-                                             + "</pre>",
-                                   "command": " ".join(make_command),
-                                   })
-                return
+            # Ensure libv3test.a exists in 'outdir'.
+            if self._HaveCompiler(context):
+                # Build libv3test.a.
+                makefile_in = open(os.path.join(standalone_root,
+                                                "qm-misc",
+                                                "util-Makefile"))
+                makefile_str = makefile_in.read()
+                makefile_str = makefile_str.replace("@ROOT@",
+                                                    standalone_root)
+                makefile_str = makefile_str.replace("@CXX@",
+                                                    compiler.GetPath())
+                flags = compiler.GetOptions() + basic_flags
+                makefile_str = makefile_str.replace("@CXXFLAGS@",
+                                                    " ".join(flags))
+                makefile_out = open(os.path.join(outdir, "Makefile"),
+                                    "w")
+                makefile_out.write(makefile_str)
+                makefile_out.close()
+
+                make_executable = RedirectedExecutable()
+                make_command = ["make", "libv3test.a"]
+                status = make_executable.Run(make_command, dir=outdir)
+                if (not os.WIFEXITED(status)
+                    or os.WEXITSTATUS(status) != 0):
+                    q_stdout = result.Quote(make_executable.stdout)
+                    q_stderr = result.Quote(make_executable.stderr)
+                    command_str = " ".join(make_command),
+                    result.SetOutcome(result.ERROR,
+                                      "Error building libv3test.a",
+                                      {"status": str(status),
+                                       "stdout": q_stdout,
+                                       "stderr": q_stderr,
+                                       "command": command_str,
+                                       })
+                    return
+
+                # If we have an compiler output dir, use it.
+                if compiler_outdir is not None:
+                    shutil.copy(os.path.join(outdir, "libv3test.a"),
+                                os.path.join(compiler_outdir,
+                                             "libv3test.a"))
+            else:
+                # No compiler, so we just copy it out of the compiler
+                # output dir.
+                shutil.copy(os.path.join(compiler_outdir,
+                                         "libv3test.a"),
+                            os.path.join(outdir, "libv3test.a"))
 
         
     def _CalcBuildTreeFlags(self, result, context, blddir, compiler):
@@ -283,8 +351,7 @@
             if os.path.isfile(command):
                 break
 
-        result["V3Init.testsuite_flags_command"] = \
-            "<pre>" + command + "</pre>"
+        result["V3Test.testsuite_flags_command"] = result.Quote(command)
 
         executable = RedirectedExecutable()
         executable.Run([command, "--cxxflags"])
@@ -304,6 +371,8 @@
 
         return (basic_flags, default_flags)
 
+# How DejaGNU does this, for reference:
+#
 # dg-runtest calls dg-test calls "libstdc++-dg-test prog do_what
 # DEFAULT_CXXFLAGS" (DEFAULT_CXXFLAGS as in normal.exp)
 # Which calls
@@ -313,7 +382,7 @@
 #   target_compile $prog $output_file $compile_type additional_flags=$DEFAULT_CXXFLAGS,compiler=$cxx_final,ldflags=-L$blddir/testsuite,libs=-lv3test
 # for us, libgloss doesn't exist, which simplifies things.
 
-class V3DGTest(DGTest, GCCTestBase):
+class V3DGTest(DGTest, GCCTestBase, V3Base):
     """A 'V3DGTest' is a libstdc++-v3 test using the 'dg' driver.
 
     This test class emulates the 'lib/libstdc++.exp' and 'lib/prune.exp
@@ -324,15 +393,23 @@
 
     _language = "cplusplus"
 
-    _libdir_context_property = "V3Init.libpaths"
+    _libdir_context_property = "V3Test.libpaths"
 
     def Run(self, context, result):
 
         self._SetUp(context)
-        self._RunDGTest(context["V3Init.basic_cxx_flags"],
-                        context["V3Init.default_cxx_flags"],
+
+        if context.has_key("V3Test.compiler_output_dir"):
+            # When using a special output directory, we always save the
+            # executables.
+            keep_output = 1
+        else:
+            keep_output = 0
+        self._RunDGTest(context["V3Test.basic_cxx_flags"],
+                        context["V3Test.default_cxx_flags"],
                         context,
-                        result)
+                        result,
+                        keep_output=keep_output)
         
 
     def _PruneOutput(self, output):
@@ -351,14 +428,16 @@
 
         env = {}
         for name in _ld_library_path_names:
-            env[name] = context["V3Init.ld_library_path"]
+            env[name] = context["V3Test.ld_library_path"]
+        if context.has_key("V3Init.env_V3_LOCALEDIR"):
+            env["V3_LOCALEDIR"] = context["V3Init.env_V3_LOCALEDIR"]
         return env
 
 
     def _RunTargetExecutable(self, context, result, file, dir = None):
 
         if dir is None:
-            dir = context["V3Init.outdir"]
+            dir = context["V3Test.outdir"]
 
         sup = super(V3DGTest, self)
         return sup._RunTargetExecutable(context, result, file, dir)
@@ -380,9 +459,52 @@
         return (output, file)
 
 
+    def _RunDGToolPortion(self, path, tool_flags, context, result):
+        """Don't run the compiler if in pre-compiled mode."""
+
+        if not self._HaveCompiler(context):
+            # Don't run the compiler, just pretend we did.
+            return self._GetOutputFile(context, self._kind, path)
+            
+        return super(V3DGTest, self)._RunDGToolPortion(path, tool_flags,
+                                                       context, result)
+            
+
+    def _RunDGExecutePortion(self, file, context, result):
+        """Emit an UNTESTED result if not compiling and not running."""
+
+        if (not self._HaveCompiler(context)
+            and self._kind != DGTest.KIND_RUN):
+            # We didn't run the compiler, and we're not going to run the
+            # executable; we'd better emit something here because we're
+            # not doing it anywhere else.
+            result["V3DGTest.explanation_1"] = (
+                "This is a compiler test, and we are running in no "
+                "compiler mode.  Skipped.")
+            # Magic marker for the TET output stream to pick up on:
+            result["test_not_relevant_to_testing_mode"] = "true"
+            self._RecordDejaGNUOutcome(result,
+                                       self.UNTESTED, self._name)
+            return
+                
+        super(V3DGTest, self)._RunDGExecutePortion(file,
+                                                   context, result)
+
+
     def _GetOutputFile(self, context, kind, path):
 
-        base = os.path.basename(path)
+        if context.has_key("V3Test.compiler_output_dir"):
+            dir = context["V3Test.compiler_output_dir"]
+            srcdir = self.GetDatabase().GetRoot()
+            path = os.path.normpath(path)
+            srcdir = os.path.normpath(srcdir)
+            assert path.startswith(srcdir)
+            base = path[len(srcdir):]
+            base = base.replace("/", "_")
+        else:
+            dir = context.GetTemporaryDirectory()
+            base = os.path.basename(path)
+
         if kind != self.KIND_PRECOMPILE:
             base = os.path.splitext(base)[0]
         base += { DGTest.KIND_PREPROCESS : ".i",
@@ -393,7 +515,7 @@
                   GCCTestBase.KIND_PRECOMPILE : ".gch",
                   }[kind]
 
-        return os.path.join(context.GetTemporaryDirectory(), base)
+        return os.path.join(dir, base)
 
 
     def _DGrequire_iconv(self, line_num, args, context):
@@ -416,6 +538,16 @@
 
         charset = args[0]
 
+        # First check to see if we have a compiler.  We can't do
+        # anything useful without one.
+        if not self._HaveCompiler(context):
+            # No compiler; we'll go ahead and hope for the best.
+            # Better would be to save the test programs to the output
+            # directory, but this is difficult; on the other hand, not
+            # doing so may cause spurious failures if a character set is
+            # not in fact supported by our local libiconv...
+            return
+
         # Check to see if iconv does exist and work.
         # First by creating and compiling a test program...
         tmpdir = context.GetTemporaryDirectory()
@@ -439,9 +571,9 @@
         compiler = context["CompilerTable.compiler_table"][self._language]
         options = []
 
-        options += context["V3Init.basic_cxx_flags"]
-        options += context["V3Init.default_cxx_flags"]
-        libpaths = context["V3Init.libpaths"]
+        options += context["V3Test.basic_cxx_flags"]
+        options += context["V3Test.default_cxx_flags"]
+        libpaths = context["V3Test.libpaths"]
         options += ["-L" + p for p in libpaths]
 
         if context.has_key("GCCTest.libiconv"):
@@ -471,6 +603,7 @@
 
 
 
+# How the real GCC tree does things:
 # check-abi first builds
 #    abi_check
 #    baseline_symbols
@@ -484,12 +617,12 @@
 #
 #
 # new-abi-baseline is what actually generates a new baseline.
-# it does it with ${extract_symvers} ../src/.libs/libstdc++.so ${baseline_file}
+# It does it with ${extract_symvers} ../src/.libs/libstdc++.so ${baseline_file}
 # baseline_file = ${baseline_dir}/baseline_symbols.txt
 # baseline_dir is set by autoconf to some mad thing...
 #    $glibcxx_srcdir/config/abi/${abi_baseline_pair}\$(MULTISUBDIR)"
 # abi_baseline_pair is set by autoconf to host_cpu-host_os by default.
-# but there are some special cases, in particular:
+# But there are some special cases, in particular:
 #    x86_64-*-linux*     -> x86_64-linux-gnu
 #    alpha*-*-freebsd5*  -> alpha-freebsd5
 #    i*86-*-freebsd4*    -> i386-freebsd4
@@ -497,9 +630,10 @@
 #    sparc*-*-freebsd5*  -> sparc-freebsd5
 #
 # extract_symvers = $(glibcxx_srcdir)/scripts/extract_symvers
-# extract_symvers is actually just a shell script
+# extract_symvers is actually just a shell script; we don't need to
+# compile it.
         
-class V3ABITest(Test):
+class V3ABITest(Test, V3Base):
     """A 'V3ABITest' checks the ABI of libstdc++ against a baseline.
 
     Depends on context variable 'V3Test.abi_baseline_file'."""
@@ -509,25 +643,48 @@
         # Some variables we'll need throughout.
         executable = RedirectedExecutable()
         tmpdir = context.GetTemporaryDirectory()
-        outdir = context["V3Init.outdir"]
+        outdir = context["V3Test.outdir"]
         srcdir = self.GetDatabase().GetRoot()
+        if context.has_key("V3Test.compiler_output_dir"):
+            compiler_outdir = context["V3Test.compiler_output_dir"]
+        else:
+            compiler_outdir = None
 
         # First we make sure that the abi_check program exists.
-        abi_check = os.path.join(outdir, "abi_check")
-        status = executable.Run(["make", "abi_check"], dir=outdir)
-        result["make_abi_check_stdout"] = ("<pre>" + executable.stdout
-                                           + "</pre>")
-        result["make_abi_check_stderr"] = ("<pre>" + executable.stderr
-                                           + "</pre>")
-        result["make_abi_check_status"] = str(status)
-        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
-            result.SetOutcome(result.ERROR, "Error building abi_check")
-            return
+        if not self._HaveCompiler(context):
+            # If we have no compiler, we must find it in the compiler
+            # output dir.
+            if compiler_outdir is None:
+                result.SetOutcome(result.ERROR,
+                                  "No compiler output dir, "
+                                  "but no compiler either.")
+                return
+            abi_check = os.path.join(compiler_outdir, "abi_check")
+        else:
+            # Otherwise, we have to try building it.
+            abi_check = os.path.join(outdir, "abi_check")
+            status = executable.Run(["make", "abi_check"], dir=outdir)
+            quote = result.Quote
+            result["make_abi_check_stdout"] = quote(executable.stdout)
+            result["make_abi_check_stderr"] = quote(executable.stderr)
+            result["make_abi_check_status"] = str(status)
+            if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
+                result.SetOutcome(result.ERROR,
+                                  "Error building abi_check")
+                return
+            # Ensure that the abi_check program does end up in the
+            # compiler output dir, if necessary.
+            if compiler_outdir is not None:
+                shutil.copy(abi_check,
+                            os.path.join(compiler_outdir, "abi_check"))
+        
         if not os.path.isfile(abi_check):
             result.SetOutcome(result.ERROR,
-                              "No abi_check program '%s'" % abi_check)
+                              "No abi_check program '%s'"
+                              % abi_check)
             return
 
+
         # Now make sure the baseline file exists.
         baseline_type = self._GetAbiName(context["DejaGNUTest.target"])
         baseline_file = os.path.join(srcdir, "..", "config", "abi",
@@ -554,12 +711,12 @@
             return
 
         # Extract the current symbols.
-        # First use ldd to find the libstdc++ in use.
-        status = executable.Run(["ldd", "abi_check"], dir=outdir)
-        result["ldd_stdout"] = ("<pre>" + executable.stdout
-                                            + "</pre>")
-        result["ldd_stderr"] = ("<pre>" + executable.stderr
-                                            + "</pre>")
+        # First use ldd to find the libstdc++ in use.  'abi_check' is a
+        # handy C++ program; we'll check which library it's linked
+        # against.
+        status = executable.Run(["ldd", abi_check], dir=outdir)
+        result["ldd_stdout"] = result.Quote(executable.stdout)
+        result["ldd_stderr"] = result.Quote(executable.stderr)
         result["ldd_status"] = str(status)
         if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
             result.SetOutcome(result.ERROR,
@@ -580,10 +737,9 @@
         status = executable.Run([extract_symvers,
                                  libstdcpp,
                                  curr_symbols])
-        result["extract_symvers_stdout"] = ("<pre>" + executable.stdout
-                                            + "</pre>")
-        result["extract_symvers_stderr"] = ("<pre>" + executable.stderr
-                                            + "</pre>")
+        quote = result.Quote
+        result["extract_symvers_stdout"] = quote(executable.stdout)
+        result["extract_symvers_stderr"] = quote(executable.stderr)
         result["extract_symvers_status"] = str(status)
         if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
             result.SetOutcome(result.ERROR, "Error extracting symbols")
@@ -597,10 +753,9 @@
         # latter.
         status = executable.Run([abi_check, "--check-verbose",
                                  curr_symbols, baseline_file])
-        result["comparison_stdout"] = ("<pre>" + executable.stdout
-                                            + "</pre>")
-        result["comparison_stderr"] = ("<pre>" + executable.stderr
-                                            + "</pre>")
+        quote = result.Quote
+        result["comparison_stdout"] = quote(executable.stdout)
+        result["comparison_stderr"] = quote(executable.stderr)
         result["comparison_status"] = str(status)
         if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
             result.SetOutcome(result.ERROR,

From njs at pobox.com  Tue Mar 30 18:33:38 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Tue, 30 Mar 2004 10:33:38 -0800
Subject: [PATCH] qmtest updates
Message-ID: <20040330183338.GB21725@njs.ddts.net>

- Rationalize quoting of result annotations.  New method Result.Quote,
  new function qm.common.html_to_text, used uniformly to convert pure
  text to and from the HTML used by result annotations.
- Update TET stream to fix many bugs.
- Refactor DGTest to allow finer-grained overriding of behavior in
  subclasses.
- Have the PickleResultStream check the types on run annotations; this
  bit me...
- Add more run annotations containing the command line and userid of
  the person invoking qmtest.

-- Nathaniel

-- 
The Universe may  /  Be as large as they say
But it wouldn't be missed  /  If it didn't exist.
  -- Piet Hein
-------------- next part --------------
? results.qmr
? qm/external/__init__.pyc
? qm/test/classes/csl-notes
? tests/regress/QMTest/regression_database.pyc
? tests/regress/QMTest/selftest.pyc
? tests/regress/tuple1/QMTest/tuple_test.pyc
? tests/results_files/QMTest/results_file_database.pyc
? tests/results_files/QMTest/results_file_test.pyc
Index: ChangeLog
===================================================================
RCS file: /home/qm/Repository/qm/ChangeLog,v
retrieving revision 1.615
diff -u -r1.615 ChangeLog
--- ChangeLog	16 Mar 2004 05:10:55 -0000	1.615
+++ ChangeLog	30 Mar 2004 18:27:05 -0000
@@ -1,3 +1,49 @@
+2004-03-30  Nathaniel Smith  <njs at codesourcery.com>
+
+	* qm/common.py (htmllib): Import it.
+	(StringIO): Likewise.
+	(formatter): Likewise.
+	(html_to_text): New function.
+	* qm/test/classes/text_result_stream.py
+	(TextResultStream._DisplayAnnotations): Use it.
+	(formatter): Don't import it.
+	(htmllib): Likewise.
+	(StringIO): Likewise.
+	(qm.common): Import it.
+	(qm.fields): Likewise.
+	
+	* qm/test/result.py (cgi): Import it.
+	(Result.Quote): New function.
+	(Result.NoteException): Use it.
+	* qm/test/classes/dg_test.py (DGTest._RunDGTest): Likewise.
+	* qm/test/classes/command.py (ExecTestBase.RunProgram):
+	Likewise.
+	* qm/test/classes/dejagnu_base.py
+	(DejaGNUBase._RecordCommandOutput): Likewise.
+	(DejaGNUBase._RecordCommand): Likewise.
+	* tests/regress/QMTest/selftest.py (RegTest.Run): Likewise.
+	* tests/results_files/QMTest/results_file_test.py
+	(ResultsFileTest.Run): Likewise.
+
+	* qm/test/classes/tet_stream.py (TETStream): Many output
+	enhancements.
+
+	* qm/test/classes/dg_test.py (DGTest._RunDGTest): Refactor,
+	(DGTest._RunDGToolPortion): ...creating this.
+	(DGTest._RunDGExecutePortion): ...and this.
+
+	* qm/test/classes/pickle_result_stream.py (types): Import it.
+	(PickleResultStream.WriteAnnotation): Check that annotations are
+	strings.
+
+	* qm/common.py (get_username): Expand docstring.
+	(get_userid): New function.
+	* qm/test/execution_engine.py
+	(ExecutionEngine._WriteInitialAnnotations): Use it.
+	Disambiguate old "qmtest.run.user" annotation by renaming to
+	"qmtest.run.username".
+	Add "qmtest.run.command_line" annotation.
+	
 2004-03-15  Nathaniel Smith  <njs at codesourcery.com>
 	
 	* qm/test/target.py (Target._SetUpResource): Fix typo from
Index: qm/common.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/common.py,v
retrieving revision 1.86
diff -u -r1.86 common.py
--- qm/common.py	20 Feb 2004 10:08:51 -0000	1.86
+++ qm/common.py	30 Mar 2004 18:27:05 -0000
@@ -32,6 +32,9 @@
 import traceback
 import types
 import getpass
+import StringIO
+import htmllib
+import formatter
 if sys.platform != "win32":
     import fcntl
     
@@ -780,6 +783,10 @@
 def get_username():
     """Returns the current username as a string.
 
+    This is our best guess as to the username of the user who is
+    actually logged in, as opposed to the effective user id used for
+    running tests.
+
     If the username cannot be found, raises a 'QMException'."""
 
     # First try using the 'getpass' module.
@@ -803,6 +810,41 @@
 
     # And if none of that worked, give up.
     raise QMException, "Cannot determine user name."
+
+
+def get_userid():
+    """Returns the current user id as an integer.
+
+    This is the real user id, not the effective user id, to better track
+    who is actually running the tests.
+
+    If the user id cannot be found or is not defined, raises a
+    'QMException'."""
+
+    try:
+        uid = os.getuid()
+    except AttributeError:
+        raise QMException, "User ids not supported on this system."
+    return uid
+    
+
+def html_to_text(html, width=72):
+    """Renders HTML to text in a simple way.
+
+    'html' -- A string containing the HTML code to be rendered.
+
+    'width' -- Column at which to word-wrap.  Default 72.
+
+    returns -- A string containing a plain text rendering of the
+    HTML."""
+
+    s = StringIO.StringIO()
+    w = formatter.DumbWriter(s, width)
+    f = formatter.AbstractFormatter(w)
+    p = htmllib.HTMLParser(f)
+    p.feed(html)
+    p.close()
+    return s.getvalue()
 
 
 ########################################################################
Index: qm/test/execution_engine.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/execution_engine.py,v
retrieving revision 1.27
diff -u -r1.27 execution_engine.py
--- qm/test/execution_engine.py	20 Feb 2004 10:08:52 -0000	1.27
+++ qm/test/execution_engine.py	30 Mar 2004 18:27:05 -0000
@@ -825,15 +825,24 @@
             uname = " ".join(os.uname())
         except:
             uname = None
+        try:
+            userid = str(qm.common.get_userid())
+        except:
+            userid = None
+
+        args_str = " ".join(sys.argv)
 
         # Write them.
         for rs in self.__result_streams:
             rs.WriteAllAnnotations(self.__context)
             rs.WriteAnnotation("qmtest.run.start_time", start_time_str)
             if username is not None:
-                rs.WriteAnnotation("qmtest.run.user", username)
+                rs.WriteAnnotation("qmtest.run.username", username)
+            if userid is not None:
+                rs.WriteAnnotation("qmtest.run.userid", userid)
             rs.WriteAnnotation("qmtest.run.version", qm.version)
             rs.WriteAnnotation("qmtest.run.uname", uname)
+            rs.WriteAnnotation("qmtest.run.command_line", args_str)
 
 
 ########################################################################
Index: qm/test/result.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/result.py,v
retrieving revision 1.25
diff -u -r1.25 result.py
--- qm/test/result.py	20 Feb 2004 10:08:52 -0000	1.25
+++ qm/test/result.py	30 Mar 2004 18:27:05 -0000
@@ -21,6 +21,7 @@
 from   qm.test.context import ContextException
 import sys
 import types
+import cgi
 
 ########################################################################
 # Classes
@@ -261,6 +262,20 @@
             return ""
     
         
+    def Quote(self, string):
+        """Return a version of string suitable for an annotation value.
+
+        Performs appropriate quoting for a string that should be taken
+        verbatim; this includes HTML entity escaping, and addition of
+        <pre> tags.
+
+        'string' -- The verbatim string to be quoted.
+
+        returns -- The quoted string."""
+
+        return "<pre>%s</pre>" % cgi.escape(string)
+
+
     def NoteException(self,
                       exc_info = None,
                       cause = None,
@@ -301,7 +316,7 @@
         self[Result.CAUSE] = cause
         self[Result.EXCEPTION] = "%s: %s" % exc_info[:2]
         self[Result.TRACEBACK] \
-            = "<pre>" + qm.format_traceback(exc_info) + "</pre>"
+            = self.Quote(qm.format_traceback(exc_info))
 
         
     def MakeDomNode(self, document):
Index: qm/test/classes/command.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/command.py,v
retrieving revision 1.44
diff -u -r1.44 command.py
--- qm/test/classes/command.py	16 Feb 2004 01:23:59 -0000	1.44
+++ qm/test/classes/command.py	30 Mar 2004 18:27:05 -0000
@@ -203,8 +203,8 @@
             stderr = e.stderr
             # Record the results.
             result["ExecTest.exit_code"] = str(exit_code)
-            result["ExecTest.stdout"] = "<pre>" + stdout + "</pre>"
-            result["ExecTest.stderr"] = "<pre>" + stderr + "</pre>"
+            result["ExecTest.stdout"] = result.Quote(stdout)
+            result["ExecTest.stderr"] = result.Quote(stderr)
             # Check to see if the exit code matches.
             if exit_code != self.exit_code:
                 causes.append("exit_code")
@@ -214,12 +214,12 @@
             if not self.__CompareText(stdout, self.stdout):
                 causes.append("standard output")
                 result["ExecTest.expected_stdout"] \
-                    = "<pre>" + self.stdout + "</pre>"
+                    = result.Quote(self.stdout)
             # Check to see that the standard error matches.
             if not self.__CompareText(stderr, self.stderr):
                 causes.append("standard error")
                 result["ExecTest.expected_stderr"] \
-                    = "<pre>" + self.stderr + "</pre>"
+                    = result.Quote(self.stderr)
             # If anything went wrong, the test failed.
             if causes:
                 result.Fail("Unexpected %s." % string.join(causes, ", ")) 
Index: qm/test/classes/dejagnu_base.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/dejagnu_base.py,v
retrieving revision 1.1
diff -u -r1.1 dejagnu_base.py
--- qm/test/classes/dejagnu_base.py	2 Jun 2003 15:56:13 -0000	1.1
+++ qm/test/classes/dejagnu_base.py	30 Mar 2004 18:27:05 -0000
@@ -32,7 +32,7 @@
 
         index = self.__next_command
         key = "DejaGNUTest.command_%d" % index
-        result[key] = "<tt><pre>" + " ".join(command) + "</tt></pre>"
+        result[key] = result.Quote(" ".join(command))
         self.__next_command += 1
 
         return index
@@ -57,7 +57,7 @@
             result["DejaGNUTest.command_status_%d" % index] = str(status)
         if output:
             result["DejaGNUTest.command_output_%d" % index] \
-              = "<tt><pre>" + output + "</pre></tt>"
+              = result.Quote(output)
 
 
     def _SetUp(self, context):
Index: qm/test/classes/dg_test.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/dg_test.py,v
retrieving revision 1.5
diff -u -r1.5 dg_test.py
--- qm/test/classes/dg_test.py	15 Mar 2004 23:31:36 -0000	1.5
+++ qm/test/classes/dg_test.py	30 Mar 2004 18:27:05 -0000
@@ -146,6 +146,31 @@
                                        self._name)
             return
 
+        # Run the tool being tested and process its output.
+        file = self._RunDGToolPortion(path, tool_flags, context, result)
+
+        # Run the executable generated (if applicable).
+        self._RunDGExecutePortion(file, context, result)
+
+        # Run dg-final tests.
+        for c, a in self._final_commands:
+            self._ExecuteFinalCommand(c, a, context, result)
+
+        # Remove the output file.
+        if not keep_output:
+            try:
+                os.remove(file)
+            except:
+                pass
+                
+
+    def _RunDGToolPortion(self, path, tool_flags, context, result):
+        """Perform the tool-running portions of a DG test.
+
+        Calls '_RunTool' and processes its output.
+
+        returns -- The filename of the generated file."""
+
         # Run the tool being tested.
         output, file = self._RunTool(path, self._kind,
                                      tool_flags + self._options,
@@ -199,11 +224,20 @@
         if output != "":
             self._RecordDejaGNUOutcome(result, self.FAIL,
                                        message, expected)
-            result["DGTest.excess_errors"] = "<pre>" + output + "</pre>"
+            result["DGTest.excess_errors"] = result.Quote(output)
         else:
             self._RecordDejaGNUOutcome(result, self.PASS,
                                        message, expected)
 
+        return file
+
+
+    def _RunDGExecutePortion(self, file, context, result):
+        """Perform the executable-running portions of a DG test.
+
+        If this is a "run" test, runs the executable generated by the
+        tool and checks its output."""
+
         # Run the generated program.
         if self._kind == "run":
             if not os.path.exists(file):
@@ -217,17 +251,6 @@
                 self._RecordDejaGNUOutcome(result, outcome, message,
                                            self._expectation)
 
-        # Run dg-final tests.
-        for c, a in self._final_commands:
-            self._ExecuteFinalCommand(c, a, context, result)
-
-        # Remove the output file.
-        if not keep_output:
-            try:
-                os.remove(file)
-            except:
-                pass
-                
 
     def _ExecuteFinalCommand(self, command, args, context, result):
         """Run a command specified with 'dg-final'.
Index: qm/test/classes/pickle_result_stream.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/pickle_result_stream.py,v
retrieving revision 1.7
diff -u -r1.7 pickle_result_stream.py
--- qm/test/classes/pickle_result_stream.py	24 Nov 2003 06:35:01 -0000	1.7
+++ qm/test/classes/pickle_result_stream.py	30 Mar 2004 18:27:05 -0000
@@ -15,6 +15,7 @@
 # Imports
 ########################################################################
 
+import types
 import cPickle
 import struct
 import qm.fields
@@ -152,6 +153,8 @@
 
     def WriteAnnotation(self, key, value):
 
+        assert isinstance(key, types.StringTypes)
+        assert isinstance(value, types.StringTypes)
         self.__pickler.dump(_annotation_sentinel)
         self._WriteAnnotationPtr()
         self.__pickler.dump(("annotation", key, value))
Index: qm/test/classes/tet_stream.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/tet_stream.py,v
retrieving revision 1.3
diff -u -r1.3 tet_stream.py
--- qm/test/classes/tet_stream.py	15 Mar 2004 23:31:36 -0000	1.3
+++ qm/test/classes/tet_stream.py	30 Mar 2004 18:27:08 -0000
@@ -135,9 +135,11 @@
         self._start_time = "<unknown_start_time>"
         self._finish_time = "<unknown_finish_time>"
         self._aborted = False
-        self._user = "<unknown_user>"
+        self._username = "<unknown_user>"
+        self._userid = "<unknown_user>"
         self._version = "<unknown_version>"
         self._uname = "<unknown_uname>"
+        self._cmdline = "<unknown_command_line>"
         self._settings = {}
 
         self._tcc_number = 0
@@ -190,12 +192,16 @@
                                = self._TETFormatTime(value)
         elif key == "qmtest.run.aborted" and value == "true":
             self._aborted = True
-        elif key == "qmtest.run.user":
-            self._user = value
+        elif key == "qmtest.run.username":
+            self._username = value
+        elif key == "qmtest.run.userid":
+            self._userid = value
         elif key == "qmtest.run.version":
             self._version = "qmtest-" + value
         elif key == "qmtest.run.uname":
             self._uname = value
+        elif key == "qmtest.run.command_line":
+            self._cmdline = value
         else:
             self._settings[key] = value
 
@@ -210,11 +216,15 @@
 
         # Test case controller start
         # 0 | version time date | who
-        self._WriteLine(0,
-                        "%s %s %s" % (self._version,
-                                      self._start_time,
-                                      self._start_date),
-                        "User: " + qm.common.get_username())
+        # who is
+        # "User: <username> (<numeric-id>) TCC Start, Command line: <cmdline>"
+        data = "%s %s %s" % (self._version,
+                             self._start_time,
+                             self._start_date)
+        who = "User: %s (%s) TCC Start, Command line: %s" \
+              % (self._username, self._userid, self._cmdline)
+
+        self._WriteLine(0, data, who)
         # Local system information
         # 5 | sysname nodename release version machine | text
         self._WriteLine(5, self._uname, "")
@@ -252,11 +262,14 @@
         # Test case start
         # 10 | activity_number testcase_path time | invocable_components
         started = self._ExtractTime(result, Result.START_TIME)
-        data = "%i %s %s" % (self._tcc_number, result.GetId(), started)
-        self._WriteLine(10, data, "")
+        data = "%i %s %s" % (self._tcc_number,
+                             "/" + result.GetId(),
+                             started)
+        self._WriteLine(10, data, "TC Start")
 
 
-    def _WriteResultAnnotations(self, result, seq_start=1):
+    def _WriteResultAnnotations(self, result, purpose,
+                                num_restrict=None, seq_start=1):
         """Writes out annotations for a 'result' in TET format.
 
         Annotations are represented as (sequences of) "test case
@@ -264,12 +277,28 @@
 
         'result' -- The 'Result' whose annotations should be written.
 
+        'num_restrict' -- Only write out annotations that end with this
+        number.  If the number is '1', also writes out all results that
+        don't end in any number, with "INFO: " prefixed.  If 'None',
+        writes out all annotations.
+
         'seq_start' -- The TET test case information sequence number to
         start with."""
 
         seqnum = seq_start
-        for key, value in result.items():
-            for line in value.split("\n"):
+        keys = result.keys()
+        keys.sort()
+        for key in keys:
+            value = result[key]
+            prefix = ""
+            if num_restrict is not None:
+                if num_restrict == 1 and key[-1] not in "0123456789":
+                    prefix = "INFO: "
+                elif not key.endswith("_%i" % num_restrict):
+                    continue
+                    
+            text = qm.common.html_to_text(value)
+            for line in text.split("\n"):
                 # Test case information
                 # 520 | activity_num tp_num context block sequence | text
                 #
@@ -285,8 +314,10 @@
                 # 'sequence' appears to be incremented for each line
                 #   within a single test purpose and context.
                 self._WriteLine(520,
-                                "%i 0 0 1 %i" % (self._tcc_number, seqnum),
-                                "%s: %s" % (key, line))
+                                "%i %i 0 1 %i" % (self._tcc_number,
+                                                  purpose,
+                                                  seqnum),
+                                "%s%s: %s" % (prefix, key, line))
                 seqnum += 1
 
 
@@ -301,8 +332,6 @@
         keys.sort(lambda k1, k2: cmp(int(k1[len(DejaGNUTest.RESULT_PREFIX):]),
                                      int(k2[len(DejaGNUTest.RESULT_PREFIX):])))
 
-        self._WriteResultAnnotations(result)
-                
         start_time = self._ExtractTime(result, Result.START_TIME)
         end_time = self._ExtractTime(result, Result.END_TIME)
 
@@ -315,46 +344,40 @@
             self._WriteLine(200,
                             "%i %i %s"
                             % (self._tcc_number, purpose, start_time),
-                            "")
-            if outcome == DejaGNUTest.WARNING:
-                # Test case information
-                # 520 | activity_num tp_num context block sequence | text
-                # (see _WriteResultAnnotations for details)
-                self._WriteLine(520,
-                                "%i %i 0 1 1" % (self._tcc_number,
-                                                 purpose),
-                                "WARNING")
-            elif outcome == DejaGNUTest.ERROR:
-                # Test case information
-                # 520 | activity_num tp_num context block sequence | text
-                # (see _WriteResultAnnotations for details)
-                self._WriteLine(520,
-                                "%i %i 0 1 1" % (self._tcc_number,
-                                                 purpose),
-                                "ERROR")
-            else:
-                outcome_num, outcome_name \
-                    = { DejaGNUTest.PASS: self.PASS,
-                        DejaGNUTest.XPASS: self.PASS,
-                        DejaGNUTest.FAIL: self.FAIL,
-                        DejaGNUTest.XFAIL: self.FAIL,
-                        DejaGNUTest.UNTESTED: self.UNTESTED,
-                        DejaGNUTest.UNRESOLVED: self.UNRESOLVED,
-                        # TET's UNSUPPORTED is like a FAIL for tests
-                        # that check for optional features; UNTESTED is
-                        # the correct correspondent for DejaGNU's
-                        # UNSUPPORTED.
-                        DejaGNUTest.UNSUPPORTED: self.UNTESTED,
-                        }[outcome]
-                # Test purpose result
-                # 220 | activity_number tp_number result time | result-name
-                data = "%i %i %i %s" % (self._tcc_number,
-                                        purpose,
-                                        outcome_num,
-                                        end_time)
-                self._WriteLine(220, data, outcome_name)
+                            "TP Start")
+
+            outcome_num, outcome_name \
+                = { DejaGNUTest.PASS: self.PASS,
+                    DejaGNUTest.XPASS: self.PASS,
+                    DejaGNUTest.FAIL: self.FAIL,
+                    DejaGNUTest.XFAIL: self.FAIL,
+                    DejaGNUTest.UNTESTED: self.UNTESTED,
+                    DejaGNUTest.UNRESOLVED: self.UNRESOLVED,
+                    DejaGNUTest.ERROR: self.UNRESOLVED,
+                    DejaGNUTest.WARNING: self.WARNING,
+                    # TET's UNSUPPORTED is like a FAIL for tests
+                    # that check for optional features; UNTESTED is
+                    # the correct correspondent for DejaGNU's
+                    # UNSUPPORTED.
+                    DejaGNUTest.UNSUPPORTED: self.UNTESTED,
+                    }[outcome]
+            # As a special case, check for magic annotation.
+            if result.has_key("test_not_relevant_to_testing_mode"):
+                outcome_num, outcome_name = self.NOTINUSE
+
+            # Write per-purpose annotations:
+            self._WriteResultAnnotations(result, purpose,
+                                         num_restrict=purpose)
+
+            # Test purpose result
+            # 220 | activity_number tp_number result time | result-name
+            data = "%i %i %i %s" % (self._tcc_number,
+                                    purpose,
+                                    outcome_num,
+                                    end_time)
+            self._WriteLine(220, data, outcome_name)
 
-                purpose += 1
+            purpose += 1
             
         # Test case end
         # 80 | activity_number completion_status time | text
@@ -362,7 +385,7 @@
         # the documented examples.
         self._WriteLine(80,
                         "%i 0 %s" % (self._tcc_number, end_time),
-                        "")
+                        "TC End")
 
             
     def _WriteTestResult(self, result):
@@ -372,30 +395,30 @@
         # Test purpose start
         # 200 | activity_number test_purpose_number time | text
         start_time = self._ExtractTime(result, Result.START_TIME)
-        data = "%i 0 %s" % (self._tcc_number, start_time)
-        self._WriteLine(200, data, "")
+        data = "%i 1 %s" % (self._tcc_number, start_time)
+        self._WriteLine(200, data, "TP Start")
 
         outcome_num, outcome_name = { Result.FAIL: self.FAIL,
                                       Result.PASS: self.PASS,
                                       Result.UNTESTED: self.UNINITIATED,
                                       Result.ERROR: self.UNREPORTED,
                                     }[result.GetOutcome()]
-        # Test purpose result
-        # 220 | activity_number tp_number result time | result-name
-        end_time = self._ExtractTime(result, Result.END_TIME)
-        data = "%i 0 %i %s" % (self._tcc_number, outcome_num, end_time)
-        self._WriteLine(220, data, outcome_name)
-
         if result.GetOutcome() == Result.ERROR:
             # Test case information
             # 520 | activity_num tp_num context block sequence | text
             # (see _WriteResultAnnotations for details)
             self._WriteLine(520,
-                            "%i 0 0 1 1" % self._tcc_number,
-                            "ERROR in test " + result.GetId())
-            self._WriteResultAnnotations(result, 2)
+                            "%i 1 0 1 1" % self._tcc_number,
+                            "QMTest ERROR in test " + result.GetId())
+            self._WriteResultAnnotations(result, 1, seq_start=2)
         else:
-            self._WriteResultAnnotations(result)
+            self._WriteResultAnnotations(result, 1)
+
+        # Test purpose result
+        # 220 | activity_number tp_number result time | result-name
+        end_time = self._ExtractTime(result, Result.END_TIME)
+        data = "%i 1 %i %s" % (self._tcc_number, outcome_num, end_time)
+        self._WriteLine(220, data, outcome_name)
 
         # Test case end
         # 80 | activity_number completion_status time | text
@@ -403,7 +426,7 @@
         # the documented examples.
         self._WriteLine(80,
                         "%i 0 %s" % (self._tcc_number, end_time),
-                        "")
+                        "TC End")
 
 
     def _WriteResourceResult(self, result):
Index: qm/test/classes/text_result_stream.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/text_result_stream.py,v
retrieving revision 1.7
diff -u -r1.7 text_result_stream.py
--- qm/test/classes/text_result_stream.py	10 Nov 2003 22:33:42 -0000	1.7
+++ qm/test/classes/text_result_stream.py	30 Mar 2004 18:27:09 -0000
@@ -17,9 +17,8 @@
 # imports
 ########################################################################
 
-import formatter
-import htmllib
-import StringIO
+import qm.common
+import qm.fields
 from   qm.test.base import *
 from   qm.test.result import *
 from   qm.test.file_result_stream import FileResultStream
@@ -190,8 +189,8 @@
             self._DisplayHeading("TEST RESULTS")
             self.__first_test = 0
         
-	# Display the result.
-	self._DisplayResult(result, self.format)
+        # Display the result.
+        self._DisplayResult(result, self.format)
 
         # Display annotations associated with the test.
         if (self.format == "full"
@@ -350,27 +349,27 @@
             return
 
         # Generate them.
-	for result in results:
+        for result in results:
             self._DisplayResult(result, self.format)
 
 
     def _DisplayResult(self, result, format):
-	"""Display 'result'.
+        """Display 'result'.
 
-	'result' -- The 'Result' of a test or resource execution.
+        'result' -- The 'Result' of a test or resource execution.
 
         'format' -- The format to use when displaying results."""
 
-	id_ = result.GetId()
+        id_ = result.GetId()
         kind = result.GetKind()
-	outcome = result.GetOutcome()
+        outcome = result.GetOutcome()
 
-	# Print the ID and outcome.
-	if self.expected_outcomes:
-	    # If expected outcomes were specified, print the expected
-	    # outcome too.
-	    expected_outcome = \
-	        self.expected_outcomes.get(id_, Result.PASS)
+        # Print the ID and outcome.
+        if self.expected_outcomes:
+            # If expected outcomes were specified, print the expected
+            # outcome too.
+            expected_outcome = \
+                self.expected_outcomes.get(id_, Result.PASS)
             if (outcome == Result.PASS
                 and expected_outcome == Result.FAIL):
                 self._WriteOutcome(id_, kind, "XPASS")
@@ -381,7 +380,7 @@
                 self._WriteOutcome(id_, kind, outcome, expected_outcome)
             else:
                 self._WriteOutcome(id_, kind, outcome)
-	else:
+        else:
             self._WriteOutcome(id_, kind, outcome)
 
         # Print the cause of the failure.
@@ -406,15 +405,10 @@
             self.file.write("    %s:\n" % name)
 
             # Convert the HTML to text.
-            s = StringIO.StringIO()
-            w = formatter.DumbWriter(s)
-            f = formatter.AbstractFormatter(w)
-            p = htmllib.HTMLParser(f)
-            p.feed(result[name])
-            p.close()
+            text = qm.common.html_to_text(result[name])
 
             # Write out the text.
-            for l in s.getvalue().splitlines():
+            for l in text.splitlines():
                 self.file.write("      " + l + "\n")
             self.file.write("\n")
         
@@ -436,10 +430,10 @@
             name = "Cleanup " + name
         
         if expected_outcome:
-	    self.file.write("  %-46s: %-8s, expected %-8s\n"
+            self.file.write("  %-46s: %-8s, expected %-8s\n"
                             % (name, outcome, expected_outcome))
-	else:
-	    self.file.write("  %-46s: %-8s\n" % (name, outcome))
+        else:
+            self.file.write("  %-46s: %-8s\n" % (name, outcome))
 
             
     def _DisplayHeading(self, heading):
Index: tests/regress/QMTest/selftest.py
===================================================================
RCS file: /home/qm/Repository/qm/tests/regress/QMTest/selftest.py,v
retrieving revision 1.3
diff -u -r1.3 selftest.py
--- tests/regress/QMTest/selftest.py	11 Aug 2003 20:04:11 -0000	1.3
+++ tests/regress/QMTest/selftest.py	30 Mar 2004 18:27:09 -0000
@@ -93,10 +93,10 @@
         stderr = e.stderr
 
         result.Annotate({
-            "selftest.RegTest.cmdline"  : ' '.join(argv),
+            "selftest.RegTest.cmdline"  : result.Quote(' '.join(argv)),
             "selftest.RegTest.exitcode" : ("%d" % status),
-            "selftest.RegTest.stdout"   : '<pre>' + stdout + '</pre>',
-            "selftest.RegTest.stderr"   : '<pre>' + stderr + '</pre>'
+            "selftest.RegTest.stdout"   : result.Quote(stdout),
+            "selftest.RegTest.stderr"   : result.Quote(stderr),
             })
 
         if stderr != '':
Index: tests/results_files/QMTest/results_file_test.py
===================================================================
RCS file: /home/qm/Repository/qm/tests/results_files/QMTest/results_file_test.py,v
retrieving revision 1.1
diff -u -r1.1 results_file_test.py
--- tests/results_files/QMTest/results_file_test.py	9 Aug 2003 05:15:02 -0000	1.1
+++ tests/results_files/QMTest/results_file_test.py	30 Mar 2004 18:27:09 -0000
@@ -69,8 +69,8 @@
         result.Annotate({
             "selftest.RegTest.cmdline"  : ' '.join(argv),
             "selftest.RegTest.exitcode" : ("%d" % status),
-            "selftest.RegTest.stdout"   : '<pre>' + e.stdout + '</pre>',
-            "selftest.RegTest.stderr"   : '<pre>' + e.stderr + '</pre>',
+            "selftest.RegTest.stdout"   : result.Quote(e.stdout),
+            "selftest.RegTest.stderr"   : result.Quote(e.stderr),
             })
 
         if e.stderr != '':

From mark at codesourcery.com  Tue Mar 30 19:10:02 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 30 Mar 2004 11:10:02 -0800
Subject: [qmtest] [PATCH] qmtest updates
In-Reply-To: <20040330183338.GB21725@njs.ddts.net>
References: <20040330183338.GB21725@njs.ddts.net>
Message-ID: <4069C60A.6040304@codesourcery.com>

Nathaniel Smith wrote:

>- Rationalize quoting of result annotations.  New method Result.Quote,
>  new function qm.common.html_to_text, used uniformly to convert pure
>  text to and from the HTML used by result annotations.
>- Update TET stream to fix many bugs.
>- Refactor DGTest to allow finer-grained overriding of behavior in
>  subclasses.
>- Have the PickleResultStream check the types on run annotations; this
>  bit me...
>- Add more run annotations containing the command line and userid of
>  the person invoking qmtest.
>
>-- Nathaniel
>
Both this patch and the other one you posted earlier look perfectly 
sensible to me.

The Result.Quote bit is definitely a very nice improvement.

Thanks,

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com



From njs at pobox.com  Wed Mar 31 20:23:33 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Wed, 31 Mar 2004 12:23:33 -0800
Subject: [PATCH] Use Result.Quote in qmtc extensions
Message-ID: <20040331202333.GA22666@njs.ddts.net>

Already committed.

-- Nathaniel

-- 
"...All of this suggests that if we wished to find a modern-day model
for British and American speech of the late eighteenth century, we could
probably do no better than Yosemite Sam."
-------------- next part --------------
Index: ChangeLog
===================================================================
RCS file: /home/qm/Repository/qmtc/ChangeLog,v
retrieving revision 1.24
diff -u -r1.24 ChangeLog
--- ChangeLog	7 Nov 2003 00:16:10 -0000	1.24
+++ ChangeLog	31 Mar 2004 20:22:33 -0000
@@ -1,3 +1,10 @@
+2004-03-31  Nathaniel Smith  <njs at codesourcery.com>
+
+	* compiler_test.py (CompilerBase._QuoteForHTML): Remove.
+	(CompilerTest._RunExecutable): Use 'Result.Quote'.
+	(CompilerTest._CheckOutput): Use 'Result.Quote'.
+	(CompilerTest._DiagnosticsToString): Use 'Result.Quote'.
+
 2003-11-06  Mark Mitchell  <mark at codesourcery.com>
 
 	* compiler_test.py (CompilerTest._RunExecutable): Add support for
Index: compiler_test.py
===================================================================
RCS file: /home/qm/Repository/qmtc/compiler_test.py,v
retrieving revision 1.20
diff -u -r1.20 compiler_test.py
--- compiler_test.py	7 Nov 2003 00:16:02 -0000	1.20
+++ compiler_test.py	31 Mar 2004 20:22:33 -0000
@@ -186,18 +186,6 @@
         return os.path.splitext(basename)[0] + object_extension
     
 
-    def _QuoteForHTML(self, text):
-
-        for t, h in (('&', '&amp;'),
-                     ('<', '&lt;'),
-                     ('>', '&gt;'),
-                     ('"', "&quot;")):
-            if text.find(t) >= 0:
-                text = h.join(text.split(t))
-
-        return text
-    
-
 
 class CompilerTest(Test, CompilerBase):
     """A 'CompilerTest' tests a compiler."""
@@ -374,8 +362,8 @@
                                 environment = environment,
                                 dir = self._GetDirectory())
         # Remember the output streams.
-        result[prefix + "stdout"] = "<pre>" + executable.stdout + "</pre>"
-        result[prefix + "stderr"] = "<pre>" + executable.stderr + "</pre>"
+        result[prefix + "stdout"] = result.Quote(executable.stdout)
+        result[prefix + "stderr"] = result.Quote(executable.stderr)
         # Check the output status.
         self._CheckStatus(result, prefix, "Executable", status)
 
@@ -402,7 +390,7 @@
         # Annotate the result with the output.
         if output:
             result[prefix + "output"] \
-                = "<pre>" + self._QuoteForHTML(output) + "</pre>"
+                = result.Quote(output)
 
         # Get the compiler to use to parse the output.
         compiler = self._GetCompiler(context)
@@ -519,4 +507,4 @@
         # Compute the string representation of each diagnostic.
         diagnostic_strings = map(str, diagnostics)
         # Insert a newline between each string.
-        return "<pre>" + string.join(diagnostic_strings, '\n') + "</pre>"
+        return Result.Quote("\n".join(diagnostic_strings))

