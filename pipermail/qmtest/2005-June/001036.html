<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> PATCH: RemoteHost support
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:qmtest%40codesourcery.com?Subject=Re%3A%20PATCH%3A%20RemoteHost%20support&In-Reply-To=%3C200506102130.j5ALUi1Q004761%40sethra.codesourcery.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001035.html">
   <LINK REL="Next"  HREF="001037.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>PATCH: RemoteHost support</H1>
    <B>Mark Mitchell</B> 
    <A HREF="mailto:qmtest%40codesourcery.com?Subject=Re%3A%20PATCH%3A%20RemoteHost%20support&In-Reply-To=%3C200506102130.j5ALUi1Q004761%40sethra.codesourcery.com%3E"
       TITLE="PATCH: RemoteHost support">mark at codesourcery.com
       </A><BR>
    <I>Fri Jun 10 21:30:44 UTC 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001035.html">PATCH: Remove minor code duplication
</A></li>
        <LI>Next message: <A HREF="001037.html">[qmtest] PATCH: RemoteHost support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1036">[ date ]</a>
              <a href="thread.html#1036">[ thread ]</a>
              <a href="subject.html#1036">[ subject ]</a>
              <a href="author.html#1036">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
This patch adds a new abstraction (called RemoteHost) that can be used
for running programs remotely.  (This facility is in contrast to the
QMTest &quot;Target&quot; abstraction, which allows you to run *tests* remotely;
this facility allows a test running on one machine to run a program on
another.)

The basic facilities provided by a RemoteHost are the abilitiies to
run programs remotely, as well as copy files back and forth between
the local and remove hosts.  There are presently three incarnations:

* LocalHost, which is the special case of a RemoteHost that happens to
  the machine on which QMTest is running

* SSHHost, which is a host accessible by &quot;ssh&quot; or &quot;rsh&quot;

* Simulator, which is a semi-hosted simulator, using the same
  filesystem as the local host, but with a simulator used to run
  programs.

These facilities are tied into CompilerTable/CompilerTest, so that you
can now set a context variable to run your tests remotely.

For example, we have a PowerPC machine called &quot;knight&quot;.  I created a
remote host file for &quot;knight&quot; like so:

  qmtest create --attribute host_name=knight remote_host ssh_host.SSHHost 
    &gt; knight

Then, I created a context file like so:

  CompilerTable.languages=cplusplus
  CompilerTable.cplusplus_kind=GCC
  CompilerTable.cplusplus_path=powerpc-none-linux-gnu-g++
  CompilerTable.target=knight

Then, &quot;qmtest run&quot; (in an appropriate database, on another machine)
automatically runs the programs created by the cross-compiler on
knight, using SSH.

--
Mark Mitchell
CodeSourcery, LLC
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">mark at codesourcery.com</A>

2005-06-10  Mark Mitchell  &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">mark at codesourcery.com</A>&gt;

	* qm/remote_host.py: New file.
	* qm/test/base.py (__extension_bases): Add &quot;remote_host&quot;.
	(extension_kinds): Derive automatically from __extension_base.
	* qm/test/classes/classes.qmc: Add local_host.LocalHost,
	ssh_host.SSHHost, ssh_host.RSHHost, and simulator.Simulator.
	* qm/test/classes/compiler.py (Compiler.GetExecutableExtension):
	New method.
	(Compiler.GetObjectExtension): Likewise.
	* qm/test/classes/compiler_table.py (CompilerTable.Setup): Fix
	typos and thinkos.  Set up CompilerTable.target.
	* qm/test/classes/compiler_test.py (CompiledExecutable): Remove.
	(CompilerTest._GetObjectFileName): Fix typo in comment.
	(CompilerTest.Run): Save the compiler.
	(CompilerTest._RunExecutable): Use the RemoteHost provided by the
	compiler table.
	* qm/test/classes/local_host.py: New file.
	* qm/test/classes/simulator.py: Likewise.
	* qm/test/classes/ssh_host.py: Likewise.

Index: qm/remote_host.py
===================================================================
RCS file: qm/remote_host.py
diff -N qm/remote_host.py
*** /dev/null	1 Jan 1970 00:00:00 -0000
--- qm/remote_host.py	10 Jun 2005 21:21:05 -0000
***************
*** 0 ****
--- 1,159 ----
+ ########################################################################
+ #
+ # File:   remote_host.py
+ # Author: Mark Mitchell
+ # Date:   2005-06-03
+ #
+ # Contents:
+ #   RemoteHost
+ #
+ # Copyright (c) 2005 by CodeSourcery, LLC.  All rights reserved. 
+ #
+ ########################################################################
+ 
+ ########################################################################
+ # Imports
+ #######################################################################
+ 
+ from   qm.executable import RedirectedExecutable
+ from   qm.extension import Extension
+ import os.path
+ 
+ ########################################################################
+ # Classes
+ #######################################################################
+ 
+ class RemoteHost(Extension):
+     &quot;&quot;&quot;A 'RemoteHost' is a logical machine.
+ 
+     Each logical machine has a default directory.  When a file is
+     uploaded to or downloaded from the machine, and a relative patch
+     is specified, the patch is relative to the default directory.
+     Similarly, when a program is run on the remote machine, its
+     initial working directory is the default directory.
+ 
+     The interface presented by 'RemoteHost' is a lowest common
+     denominator.  The objective is not to expose all the functionality
+     of any host; rather it is to provide an interface that can be used
+     on many hosts.&quot;&quot;&quot;
+ 
+     kind = &quot;remote_host&quot;
+     
+     class Executable(RedirectedExecutable):
+         &quot;&quot;&quot;An 'Executable' is a simple redirected executable.
+ 
+         The standard error and standard output streams are combined
+         into a single stream.
+ 
+         The standard input is not closed before
+         invoking the program because SSH hangs if its standard input
+         is closed before it is invoked.  For example, running:
+ 
+            ssh machine echo hi &lt;&amp;-
+ 
+         will hang with some versions of SSH.&quot;&quot;&quot;     
+ 
+         def _StderrPipe(self):
+ 
+             return None
+ 
+ 
+ 
+     def Run(self, arguments, environment = None, timeout = -1):
+         &quot;&quot;&quot;Run a program on the remote host.
+ 
+         'path' -- The name of the program to run, on the remote host.
+         If 'path' is an absolute path or contains no directory
+         separators it is used unmodified; otherwise (i.e., if it is a
+         relative path containing at least one separator) it is
+         interpreted relative to the default directory.
+         
+         'arguments' -- The sequence of arguments that should be passed
+         to the program.
+ 
+         'environment' -- If not 'None', a dictionary of pairs of
+         strings to add to the environment of the running program.
+         
+         'timeout' -- The number of seconds the program is permitted
+         to execute.  After the 'timeout' expires, the program will be
+         terminated.  However, in some cases (such as when using 'rsh')
+         it will be the local side of the connection that is closed.
+         The remote side of the connection may or may not continue to
+         operate, depending on the vagaries of the remote operating
+         system.
+         
+         returns -- A pair '(status, output)'.  The 'status' is the
+         exit status returned by the program, or 'None' if the exit
+         status is not available.  The 'output' is a string giving the
+         combined standard output and standard error output from the
+         program.&quot;&quot;&quot; 
+ 
+         raise NotImplementedError
+ 
+ 
+     def UploadFile(self, local_file, remote_file = None):
+         &quot;&quot;&quot;Copy 'local_file' to 'remote_file'.
+ 
+         'local_file' -- The name of the file on the local machine.
+ 
+         'remote_file' -- The name of the file on the remote machine.
+         The 'remote_file' must be a relative path.  It is interpreted
+         relative to the default directory.  If 'None', the
+         'remote_file' is placed in the default directory using the
+         basename of the 'local_file'.
+ 
+         If the 'local_file' and 'remote_file' are the same, then this
+         function succeeds, but takes no action.&quot;&quot;&quot;
+ 
+         raise NotImplementedError
+ 
+ 
+     def DownloadFile(self, remote_file, local_file):
+         &quot;&quot;&quot;Copy 'remote_file' to 'local_file'.
+ 
+         'remote_file' -- The name of the file on the remote machine.
+         The 'remote_file' must be a relative path.  It is interpreted
+         relative to the default directory.
+ 
+         'local_file' -- The name of the file on the local machine.  If
+         'None', the 'local_file' is placed in the current directory
+         using the basename of the 'remote_file'.
+ 
+         If the 'local_file' and 'remote_file' are the same, then this
+         function succeeds, but takes no action.&quot;&quot;&quot;
+ 
+         raise NotImplementedError
+ 
+ 
+     def UploadAndRun(self, path, arguments, environment = None,
+                      timeout = -1):
+         &quot;&quot;&quot;Run a program on the remote host.
+ 
+         'path' -- The name of the program to run, as a path on the
+         local machine.
+ 
+         'arguments' -- As for 'Run'.
+ 
+         'environment' -- As for 'Run'.
+         
+         'timeout' -- As for 'Run'.
+ 
+         returns -- As for 'Run'.
+ 
+         The program is uploaded to the default directory on the remote
+         host.&quot;&quot;&quot; 
+         
+         self.UploadFile(path)
+         return self.Run(os.path.join(os.path.curdir,
+                                      os.path.basename(path)),
+                         arguments,
+                         environment,
+                         timeout)
+         
+         
+     def DeleteFile(self, remote_file):
+         &quot;&quot;&quot;Delete the 'remote_file'.
+ 
+         'remote_file' -- A relative path to the file to be deleted.&quot;&quot;&quot;
+ 
+         raise NotImplementedError
Index: qm/test/base.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/base.py,v
retrieving revision 1.98
diff -c -5 -p -r1.98 base.py
*** qm/test/base.py	25 Aug 2004 10:11:38 -0000	1.98
--- qm/test/base.py	10 Jun 2005 21:21:05 -0000
*************** def _result_from_dom(node):
*** 384,425 ****
  
  ########################################################################
  # variables
  ########################################################################
  
- extension_kinds = [ 'database',
-                     'label',
-                     'resource',
-                     'result_reader',
-                     'result_stream',
-                     'suite',
-                     'target',
-                     'test', ]
- &quot;&quot;&quot;Names of different kinds of QMTest extension classes.&quot;&quot;&quot;
- 
- __class_caches = {}
- &quot;&quot;&quot;A dictionary of loaded class caches.
- 
- The keys are the kinds in 'extension_kinds'.  The associated value
- is itself a dictionary mapping class names to class objects.&quot;&quot;&quot;
- 
- # Initialize the caches.
- for kind in extension_kinds:
-     __class_caches[kind] = {}
- 
  import qm.test.database
  import qm.label
  import qm.test.resource
  import qm.test.result_reader
  import qm.test.result_stream
  import qm.test.suite
  import qm.test.target
  import qm.test.test
  
  __extension_bases = {
      'database' : qm.test.database.Database,
      'label' : qm.label.Label,
      'resource' : qm.test.resource.Resource,
      'result_reader' : qm.test.result_reader.ResultReader,
      'result_stream' : qm.test.result_stream.ResultStream,
      'suite' : qm.test.suite.Suite,
      'target' : qm.test.target.Target,
--- 384,407 ----
  
  ########################################################################
  # variables
  ########################################################################
  
  import qm.test.database
  import qm.label
+ import qm.remote_host
  import qm.test.resource
  import qm.test.result_reader
  import qm.test.result_stream
  import qm.test.suite
  import qm.test.target
  import qm.test.test
  
  __extension_bases = {
      'database' : qm.test.database.Database,
      'label' : qm.label.Label,
+     'remote_host' : qm.remote_host.RemoteHost,
      'resource' : qm.test.resource.Resource,
      'result_reader' : qm.test.result_reader.ResultReader,
      'result_stream' : qm.test.result_stream.ResultStream,
      'suite' : qm.test.suite.Suite,
      'target' : qm.test.target.Target,
*************** __extension_bases = {
*** 427,436 ****
--- 409,432 ----
      }
  &quot;&quot;&quot;A map from extension class kinds to base classes.
  
  An extension class of a particular 'kind' must be derived from
  'extension_bases[kind]'.&quot;&quot;&quot;
+ 
+ extension_kinds = __extension_bases.keys()
+ &quot;&quot;&quot;Names of different kinds of QMTest extension classes.&quot;&quot;&quot;
+ extension_kinds.sort()
+ 
+ __class_caches = {}
+ &quot;&quot;&quot;A dictionary of loaded class caches.
+ 
+ The keys are the kinds in 'extension_kinds'.  The associated value
+ is itself a dictionary mapping class names to class objects.&quot;&quot;&quot;
+ 
+ # Initialize the caches.
+ for kind in extension_kinds:
+     __class_caches[kind] = {}
  
  ########################################################################
  # Local Variables:
  # mode: python
  # indent-tabs-mode: nil
Index: qm/test/classes/classes.qmc
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/classes.qmc,v
retrieving revision 1.17
diff -c -5 -p -r1.17 classes.qmc
*** qm/test/classes/classes.qmc	14 Apr 2005 21:40:01 -0000	1.17
--- qm/test/classes/classes.qmc	10 Jun 2005 21:21:05 -0000
***************
*** 25,30 ****
--- 25,34 ----
   &lt;class kind=&quot;test&quot; name=&quot;python.ExecTest&quot;/&gt;
   &lt;class kind=&quot;test&quot; name=&quot;python.StringExceptionTest&quot;/&gt;
   &lt;class kind=&quot;label&quot; name=&quot;file_label.FileLabel&quot;/&gt;
   &lt;class kind=&quot;label&quot; name=&quot;python_label.PythonLabel&quot;/&gt;
   &lt;class kind=&quot;suite&quot; name=&quot;explicit_suite.ExplicitSuite&quot;/&gt;
+  &lt;class kind=&quot;remote_host&quot; name=&quot;local_host.LocalHost&quot;/&gt;
+  &lt;class kind=&quot;remote_host&quot; name=&quot;ssh_host.SSHHost&quot;/&gt;
+  &lt;class kind=&quot;remote_host&quot; name=&quot;ssh_host.RSHHost&quot;/&gt;
+  &lt;class kind=&quot;remote_host&quot; name=&quot;simulator.Simulator&quot;/&gt;
  &lt;/class-directory&gt;
Index: qm/test/classes/compiler.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/compiler.py,v
retrieving revision 1.3
diff -c -5 -p -r1.3 compiler.py
*** qm/test/classes/compiler.py	6 Jun 2005 19:00:49 -0000	1.3
--- qm/test/classes/compiler.py	10 Jun 2005 21:21:06 -0000
*************** class Compiler:
*** 269,279 ****
--- 269,303 ----
          'ldflags' -- A list of strings indicating options to the
          linker, or 'None' if there are no flags.&quot;&quot;&quot;
  
          self._ldflags = ldflags
  
+ 
+     def GetExecutableExtension(self):
+         &quot;&quot;&quot;Return the extension for executables.
+ 
+         returns -- The extension (including leading '.', if
+         applicable) for executable files created by this compiler.&quot;&quot;&quot;
+ 
+         if sys.platform == &quot;win32&quot;:
+             return &quot;.exe&quot;
+         else:
+             return &quot;&quot;
+ 
          
+     def GetObjectExtension(self):
+         &quot;&quot;&quot;Return the extension for object files.
+ 
+         returns -- The extension (including leading '.', if
+         applicable) for object files created by this compiler.&quot;&quot;&quot;
+ 
+         if sys.platform == &quot;win32&quot;:
+             return &quot;.obj&quot;
+         else:
+             return &quot;.o&quot;
+         
+     
      def _GetModeSwitches(self, mode):
          &quot;&quot;&quot;Return the compilation switches for the compilation 'mode'.
  
          'mode' -- The compilation mode (one of 'Compiler.modes').
  
Index: qm/test/classes/compiler_table.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/compiler_table.py,v
retrieving revision 1.2
diff -c -5 -p -r1.2 compiler_table.py
*** qm/test/classes/compiler_table.py	16 Apr 2005 00:06:03 -0000	1.2
--- qm/test/classes/compiler_table.py	10 Jun 2005 21:21:06 -0000
*************** based on context variables provided by t
*** 20,30 ****
--- 20,32 ----
  ########################################################################
  # Imports
  ########################################################################
  
  import compiler
+ import qm
  from   qm.test.resource import Resource
+ from   local_host import LocalHost
  
  ########################################################################
  # Classes
  ########################################################################
  
*************** class CompilerTable(Resource):
*** 62,77 ****
        are run with these options, followed by any test-specific
        options.  For example, if the user wants to test the compiler
        when run with '-O2', the user would put '-O2' in the 'l_options'
        context variable.
  
!     The 'CompilerTable' resource provides a context variable called
!     'CompilerTable.compilers' to all tests that depend upon the
!     resource.  The 'compilers' variable is a map from language names
!     to instances of 'Compiler'.  Test classes should obtain the
!     'Compiler' to use when compiling source files by using this
!     map.&quot;&quot;&quot;
  
      def SetUp(self, context, result):
  
          # There are no compilers yet.
          compilers = {}
--- 64,87 ----
        are run with these options, followed by any test-specific
        options.  For example, if the user wants to test the compiler
        when run with '-O2', the user would put '-O2' in the 'l_options'
        context variable.
  
!     The 'CompilerTable' resource provides the following context
!     variables to all tests that depend upon the resource:
! 
!     - 'CompilerTable.compilers'
! 
!        The 'compilers' variable is a map from language names to
!        instances of 'Compiler'.  Test classes should obtain the
!        'Compiler' to use when compiling source files by using this
!        map.
! 
!     - 'CompilerTable.target'
! 
!        An instance of 'RemoteHost' that can be used to run compiler
!        programs.&quot;&quot;&quot;
  
      def SetUp(self, context, result):
  
          # There are no compilers yet.
          compilers = {}
*************** class CompilerTable(Resource):
*** 83,99 ****
          for l in languages:
              # Retrieve information from the context.
              kind = context[&quot;CompilerTable.&quot; + l + &quot;_kind&quot;].strip()
              path = context[&quot;CompilerTable.&quot; + l + &quot;_path&quot;].strip()
              # Look for (optional) command-line options.
!             opts = context.get(&quot;CompilerTable.&quot; + l + &quot;_options&quot;, []).split()
!             ldflags = context.get(&quot;CompilerTable.&quot; + l + &quot;_ldflags&quot;, []).split()
              # Find the Python class corresponding to this compiler.
              compiler_class = compiler.__dict__[kind]
              # Instantiate the compiler.
              c = compiler_class(path, opts)
              c.SetLDFlags(ldflags)
              # Store it in the compilers map.
              compilers[l] = c
              
          # Make the table available to tests.
!         context[&quot;CompilerTable.compiler_table&quot;] = compilers
--- 93,132 ----
          for l in languages:
              # Retrieve information from the context.
              kind = context[&quot;CompilerTable.&quot; + l + &quot;_kind&quot;].strip()
              path = context[&quot;CompilerTable.&quot; + l + &quot;_path&quot;].strip()
              # Look for (optional) command-line options.
!             opts = context.get(&quot;CompilerTable.&quot; + l + &quot;_options&quot;,
!                                &quot;&quot;).split()
!             ldflags = context.get(&quot;CompilerTable.&quot; + l + &quot;_ldflags&quot;,
!                                   &quot;&quot;).split()
              # Find the Python class corresponding to this compiler.
              compiler_class = compiler.__dict__[kind]
              # Instantiate the compiler.
              c = compiler_class(path, opts)
              c.SetLDFlags(ldflags)
              # Store it in the compilers map.
              compilers[l] = c
              
          # Make the table available to tests.
!         context[&quot;CompilerTable.compilers&quot;] = compilers
! 
!         # For backwards compatibility, we recognize this old
!         # context variable here.
!         interpreter = context.get(&quot;CompilerTest.interpreter&quot;)
!         if interpreter:
!             interpreter = interpreter.split()
!             arguments = { simulator : interpreter[0],
!                           simulator_args : interpreter[1:] }
!             target = qm.test.classes.Simulator(arguments)
!         else:
!             target_desc = context.get(&quot;CompilerTable.target&quot;)
!             if target_desc is None:
!                 target = LocalHost({})
!             else:
!                 f = lambda n: qm.test.base.get_extension_class(n,
!                                                                &quot;remote_host&quot;,
!                                                                None)
!                 host_class, arguments \
!                     = qm.extension.parse_descriptor(target_desc, f)
!                 target = host_class(arguments)
!         context[&quot;CompilerTable.target&quot;] = target
Index: qm/test/classes/compiler_test.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/compiler_test.py,v
retrieving revision 1.1
diff -c -5 -p -r1.1 compiler_test.py
*** qm/test/classes/compiler_test.py	14 Apr 2005 21:40:01 -0000	1.1
--- qm/test/classes/compiler_test.py	10 Jun 2005 21:21:06 -0000
*************** import string
*** 21,44 ****
  
  ########################################################################
  # Classes
  ########################################################################
  
- class CompiledExecutable(TimeoutRedirectedExecutable):
-     &quot;&quot;&quot;A 'CompiledExecutable' is one generated by a compiler.&quot;&quot;&quot;
- 
-     def _StdinPipe(self):
-         &quot;&quot;&quot;Return a pipe to which to redirect the standard input.
- 
-         returns -- A pipe, or 'None' if the standard input should be
-         closed in the child.&quot;&quot;&quot;
- 
-         # There is no input available for the child.
-         return None
- 
- 
-             
  class CompilationStep:
      &quot;&quot;&quot;A single compilation step.&quot;&quot;&quot;
  
      def __init__(self, mode, files, options, output, diagnostics):
          &quot;&quot;&quot;Construct a new 'CompilationStep'.
--- 21,30 ----
*************** class CompilerBase:
*** 181,191 ****
                  # reason for the test to fail.
                  pass
  
  
      def _GetObjectFileName(self, source_file_name, object_extension):
!         &quot;&quot;&quot;Return the default object file name for 'soruce_file_name'.
  
          'source_file_name' -- A string giving the name of a source
          file.
  
          'object_extension' -- The extension used for object files.
--- 167,177 ----
                  # reason for the test to fail.
                  pass
  
  
      def _GetObjectFileName(self, source_file_name, object_extension):
!         &quot;&quot;&quot;Return the default object file name for 'source_file_name'.
  
          'source_file_name' -- A string giving the name of a source
          file.
  
          'object_extension' -- The extension used for object files.
*************** class CompilerTest(Test, CompilerBase):
*** 215,225 ****
          modified by this method to indicate outcomes other than
          'Result.PASS' or to add annotations.&quot;&quot;&quot;
  
          # Get the compiler to use for this test.
          compiler = self._GetCompiler(context)
! 
          # If an executable is generated, executable_path will contain
          # the generated path.
          executable_path = None
          # See what we need to run this test.
          steps = self._GetCompilationSteps(context)
--- 201,212 ----
          modified by this method to indicate outcomes other than
          'Result.PASS' or to add annotations.&quot;&quot;&quot;
  
          # Get the compiler to use for this test.
          compiler = self._GetCompiler(context)
!         self._compiler = compiler
!         
          # If an executable is generated, executable_path will contain
          # the generated path.
          executable_path = None
          # See what we need to run this test.
          steps = self._GetCompilationSteps(context)
*************** class CompilerTest(Test, CompilerBase):
*** 334,361 ****
          'result' -- A 'Result' object.  The outcome will be
          'Result.PASS' when this method is called.  The 'result' may be
          modified by this method to indicate outcomes other than
          'Result.PASS' or to add annotations.&quot;&quot;&quot;
  
-         # Create an object representing the executable.
-         timeout = context.get(&quot;CompilerTest.execution_timeout&quot;, -1)
-         executable = CompiledExecutable(timeout)
-         # Compute the command line for the executable.
-         interpreter = context.get(&quot;CompilerTest.interpreter&quot;)
-         if interpreter:
-             arguments = interpreter.split() + [path]
-         else:
-             arguments = [path]
          # Compute the result annotation prefix.
          prefix = self._GetAnnotationPrefix() + &quot;execution_&quot;
          # Record the command line.
!         result[prefix + &quot;command&quot;] = \
!             &quot;&lt;tt&gt;&quot; + string.join(arguments) + &quot;&lt;/tt&gt;&quot;
          # Compute the environment.
          library_dirs = self._GetLibraryDirectories(context)
          if library_dirs:
-             environment = os.environ.copy()
              # Update LD_LIBRARY_PATH.  On IRIX 6, this variable
              # goes by other names, so we update them too.  It is
              # harmless to do this on other systems.
              for variable in ['LD_LIBRARY_PATH',
                               'LD_LIBRARYN32_PATH',
--- 321,339 ----
          'result' -- A 'Result' object.  The outcome will be
          'Result.PASS' when this method is called.  The 'result' may be
          modified by this method to indicate outcomes other than
          'Result.PASS' or to add annotations.&quot;&quot;&quot;
  
          # Compute the result annotation prefix.
          prefix = self._GetAnnotationPrefix() + &quot;execution_&quot;
          # Record the command line.
!         path = os.path.join(self._GetDirectory(context), path)
!         result[prefix + &quot;command&quot;] = &quot;&lt;tt&gt;&quot; + path + &quot;&lt;/tt&gt;&quot;
! 
          # Compute the environment.
          library_dirs = self._GetLibraryDirectories(context)
          if library_dirs:
              # Update LD_LIBRARY_PATH.  On IRIX 6, this variable
              # goes by other names, so we update them too.  It is
              # harmless to do this on other systems.
              for variable in ['LD_LIBRARY_PATH',
                               'LD_LIBRARYN32_PATH',
*************** class CompilerTest(Test, CompilerBase):
*** 367,382 ****
              environment[variable] = new_path
          else:
              # Use the default values.
              environment = None
  
!         status = executable.Run(arguments,
!                                 environment = environment,
!                                 dir = self._GetDirectory(context))
!         # Remember the output streams.
!         result[prefix + &quot;stdout&quot;] = result.Quote(executable.stdout)
!         result[prefix + &quot;stderr&quot;] = result.Quote(executable.stderr)
          # Check the output status.
          self._CheckStatus(result, prefix, &quot;Executable&quot;, status)
  
  
      def _CheckOutput(self, context, result, prefix, output, diagnostics):
--- 345,363 ----
              environment[variable] = new_path
          else:
              # Use the default values.
              environment = None
  
!         target = context[&quot;CompilerTable.target&quot;]
!         timeout = context.get(&quot;CompilerTest.execution_timeout&quot;, -1)
!         status, output = target.UploadAndRun(path,
!                                              [],
!                                              environment,
!                                              timeout)
!         target.DeleteFile(path)
!         # Record the output.
!         result[prefix + &quot;output&quot;] = result.Quote(output)
          # Check the output status.
          self._CheckStatus(result, prefix, &quot;Executable&quot;, status)
  
  
      def _CheckOutput(self, context, result, prefix, output, diagnostics):
Index: qm/test/classes/local_host.py
===================================================================
RCS file: qm/test/classes/local_host.py
diff -N qm/test/classes/local_host.py
*** /dev/null	1 Jan 1970 00:00:00 -0000
--- qm/test/classes/local_host.py	10 Jun 2005 21:21:06 -0000
***************
*** 0 ****
--- 1,75 ----
+ ########################################################################
+ #
+ # File:   local_host.py
+ # Author: Mark Mitchell
+ # Date:   2005-06-03
+ #
+ # Contents:
+ #   LocalHost
+ #
+ # Copyright (c) 2005 by CodeSourcery, LLC.  All rights reserved. 
+ #
+ ########################################################################
+ 
+ ########################################################################
+ # Imports
+ #######################################################################
+ 
+ import os
+ import os.path
+ from   qm.remote_host import RemoteHost
+ import shutil
+ 
+ ########################################################################
+ # Classes
+ #######################################################################
+ 
+ class LocalHost(RemoteHost):
+     &quot;&quot;&quot;A 'LocalHost' is the machine on which Python is running.
+ 
+     The default directory for a 'LocalHost' is the current working
+     directory for this Python process.&quot;&quot;&quot;
+ 
+     def Run(self, path, arguments, environment = None, timeout = -1):
+ 
+         # Compute the full environment for the child.
+         if environment is not None:
+             new_environment = os.environ.copy()
+             new_environment.update(environment)
+             environment = new_environment
+         executable = self.Executable(timeout)
+         status = executable.Run([path] + arguments, environment)
+         return (status, executable.stdout)
+ 
+ 
+     def UploadFile(self, local_file, remote_file = None):
+ 
+         if remote_file is None:
+             remote_file = os.path.basename(local_file)
+         # Do not copy the files if they are the same.
+         if not self._SameFile(local_file, remote_file):
+             shutil.copy(local_file, remote_file)
+ 
+ 
+     def DownloadFile(self, remote_file, local_file = None):
+ 
+         return self.UploadFile(remote_file, local_file)
+ 
+ 
+     def _SameFile(self, file1, file2):
+         &quot;&quot;&quot;Return true iff 'file1' and 'file2' are the same file.
+ 
+         returns -- True iff 'file1' and 'file2' are the same file,
+         even if they have different names.&quot;&quot;&quot;
+ 
+         if not os.path.exists(file1) or not os.path.exists(file2):
+             return False
+         if hasattr(os.path, &quot;samefile&quot;):
+             return os.path.samefile(file1, file2)
+         return (os.path.normcase(os.path.abspath(file1))
+                 == os.path.normcase(os.path.abspath(file2)))
+ 
+ 
+     def DeleteFile(self, remote_file):
+ 
+         os.remove(remote_file)
Index: qm/test/classes/simulator.py
===================================================================
RCS file: qm/test/classes/simulator.py
diff -N qm/test/classes/simulator.py
*** /dev/null	1 Jan 1970 00:00:00 -0000
--- qm/test/classes/simulator.py	10 Jun 2005 21:21:06 -0000
***************
*** 0 ****
--- 1,45 ----
+ ########################################################################
+ #
+ # File:   simulator.py
+ # Author: Mark Mitchell
+ # Date:   2005-06-03
+ #
+ # Contents:
+ #   Simulator
+ #
+ # Copyright (c) 2005 by CodeSourcery, LLC.  All rights reserved. 
+ #
+ ########################################################################
+ 
+ ########################################################################
+ # Imports
+ #######################################################################
+ 
+ from local_host import LocalHost
+ from qm.fields import TextField, SetField
+ 
+ ########################################################################
+ # Classes
+ #######################################################################
+ 
+ class Simulator(LocalHost):
+     &quot;&quot;&quot;A 'Simulator' is a semi-hosted simulation environment.
+ 
+     The local file system is shared with the simulated machine.  A
+     simulator is used to execute programs.&quot;&quot;&quot;
+ 
+     simulator = TextField(
+         description = &quot;&quot;&quot;The simulation program.&quot;&quot;&quot;
+         )
+ 
+     # Any arguments that must be provided to the simulator.
+     simulator_args = SetField(
+         TextField(description = &quot;&quot;&quot;Arguments to the simulation program.&quot;&quot;&quot;))
+     
+     def Run(self, path, arguments, environment = None, timeout = -1):
+ 
+         arguments = self.simulator_args + [path] + arguments
+         return super(Simulator, self.Run(self.simulator,
+                                          arguments,
+                                          environment,
+                                          timeout))
Index: qm/test/classes/ssh_host.py
===================================================================
RCS file: qm/test/classes/ssh_host.py
diff -N qm/test/classes/ssh_host.py
*** /dev/null	1 Jan 1970 00:00:00 -0000
--- qm/test/classes/ssh_host.py	10 Jun 2005 21:21:06 -0000
***************
*** 0 ****
--- 1,211 ----
+ ########################################################################
+ #
+ # File:   ssh_host.py
+ # Author: Mark Mitchell
+ # Date:   2005-06-03
+ #
+ # Contents:
+ #   SSHHost, RSHHost
+ #
+ # Copyright (c) 2005 by CodeSourcery, LLC.  All rights reserved. 
+ #
+ ########################################################################
+ 
+ ########################################################################
+ # Imports
+ #######################################################################
+ 
+ from   local_host import LocalHost
+ import os
+ import os.path
+ from   qm.fields import TextField, SetField
+ import qm.common
+ import sys
+ 
+ ########################################################################
+ # Classes
+ #######################################################################
+ 
+ class SSHHost(LocalHost):
+     &quot;&quot;&quot;An 'SSHHost' is accessible via 'ssh' or a similar program.&quot;&quot;&quot;
+ 
+     # If not empty, the name of the remote host. 
+     host_name = TextField()
+     # The path to &quot;ssh&quot;.
+     ssh_program = TextField(
+         default_value = &quot;ssh&quot;,
+         description = &quot;&quot;&quot;The path to the remote shell program.&quot;&quot;&quot;
+         )
+     # Any arguments that must be provided to &quot;ssh&quot;. 
+     ssh_args = SetField(
+         TextField(description =
+                   &quot;&quot;&quot;The arguments to the remote shell program.&quot;&quot;&quot;))
+     # The path to &quot;scp&quot;.
+     scp_program = TextField(
+         default_value = &quot;scp&quot;,
+         description = &quot;&quot;&quot;The path to the remote copy program.&quot;&quot;&quot;
+         )
+     # Any arguments that must be provided to &quot;scp&quot;.
+     scp_args = SetField(
+         TextField(description =
+                   &quot;&quot;&quot;The arguments to the remote copy program.&quot;&quot;&quot;))
+     # The default directory on the remote system.
+     default_dir = TextField(
+         description = &quot;&quot;&quot;The default directory on the remote system.&quot;&quot;&quot;
+         )
+ 
+     nfs_dir = TextField(
+         description = &quot;&quot;&quot;The default directory, as seen from the local host.
+     
+         If not empty, 'nfs_dir' is a directory on the local machine
+         that is equivalent to the default directory on the remote
+         machine.  In that case, files will be copied to and from this
+         directory on the local machine, rather than by using
+         'scp'.&quot;&quot;&quot;
+         )
+ 
+     user_name = TextField(
+         description = &quot;&quot;&quot;The user name on the remote host.
+ 
+         If not empty, the user name that should be used when
+         connecting to the remote host.&quot;&quot;&quot;
+         )
+     
+     def Run(self, path, arguments, environment = None, timeout = -1):
+ 
+         if self.default_dir and not os.path.isabs(path):
+             if (path.find(os.path.sep) != -1
+                 or (os.path.altsep
+                     and path.find(os.path.altsep) != -1)):
+                 path = os.path.join(self.default_dir, path)
+         path, arguments = self._FormSSHCommandLine(path, arguments,
+                                                    environment)
+         return super(SSHHost, self).Run(path, arguments, None, timeout)
+ 
+ 
+     def UploadFile(self, local_file, remote_file = None):
+ 
+         if remote_file is None:
+             remote_file = os.path.basename(local_file)
+         if self.nfs_dir:
+             remote_file = os.path.join(self.nfs_dir, remote_file)
+             super(SSHHost, self).UploadFile(local_file, remote_file)
+         else:    
+             if self.default_dir:
+                 remote_file = os.path.join(self.default_dir, remote_file)
+             command = self._FormSCPCommandLine(True, local_file,
+                                                remote_file)
+             executable = self.Executable()
+             status = executable.Run(command)
+             if ((sys.platform != &quot;win32&quot;
+                  and (not os.WIFEXITED(status)
+                       or os.WEXITSTATUS(status) != 0))
+                 or (sys.platform == &quot;win32&quot; and status != 0)):
+                 raise qm.common.QMException(&quot;could not upload file&quot;)
+         
+ 
+     def DownloadFile(self, remote_file, local_file = None):
+ 
+         if local_file is None:
+             local_file = os.path.basename(remote_file)
+         if self.nfs_dir:
+             remote_file = os.path.join(self.nfs_dir, remote_file)
+             super(SSHHost, self).DownloadFile(remote_file, local_file)
+         else:
+             if self.default_dir:
+                 remote_file = os.path.join(self.default_dir, remote_file)
+             command = self._FormSCPCommandLine(False, local_file,
+                                                remote_file)
+             executable = self.Executable()
+             executable.Run(command)
+ 
+ 
+     def DeleteFile(self, remote_file):
+ 
+         if self.default_dir:
+             remote_file = os.path.join(self.default_dir, remote_file)
+         return self.Run(&quot;rm&quot;, [remote_file])
+ 
+         
+     def _FormSSHCommandLine(self, path, arguments, environment = None):
+         &quot;&quot;&quot;Form the 'ssh' command line.
+ 
+         'path' -- The remote command, in the same format expected by
+         'Run'. 
+         
+         'arguments' -- The arguments to the remote command.
+ 
+         'environment' -- As for 'Run'.
+ 
+         returns -- A pair '(path, arguments)' describing the command
+         to run on the local machine that will execute the remote
+         command.&quot;&quot;&quot;
+ 
+         command = self.ssh_args + [self.host_name]
+         if self.user_name:
+             command += [&quot;-l&quot;, self.user_name]
+         if environment is not None:
+             command.append(&quot;env&quot;)
+             for (k, v) in environment.iteritems():
+                 command.append(&quot;%s=%s&quot; % (k, v))
+         command.append(path)
+         command += arguments
+ 
+         return self.ssh_program, command
+ 
+ 
+     def _FormSCPCommandLine(self, upload, local_file, remote_file):
+         &quot;&quot;&quot;Form the 'scp' command line.
+ 
+         'upload' -- True iff the 'local_file' should be copied to the
+         remote host.
+ 
+         'local_file' -- The path to the local file.
+ 
+         'remote_file' -- The path to the remote file.
+ 
+         returns -- The list of arguments for a command to run on the
+         local machine that will perform the file copy.&quot;&quot;&quot;
+ 
+         if self.default_dir:
+             remote_file = os.path.join(self.default_dir, remote_file)
+         remote_file = self.host_name + &quot;:&quot; + remote_file
+         if self.user_name:
+             remote_file = self.user_name + &quot;@&quot; + remote_file
+         command = [self.scp_program] + self.scp_args
+         if upload:
+             command += [local_file, remote_file]
+         else:
+             command += [remote_file, local_file]
+ 
+         return command    
+ 
+ 
+ 
+ class RSHHost(SSHHost):
+     &quot;&quot;&quot;An 'RSHHost' is an 'SSHHost' that uses 'rsh' instead of 'ssh'.
+ 
+     The reason that 'RSHHost' is a separate class is that (a) that
+     makes it easier for users to construct an 'SSHHost', and (b) 'rsh'
+     does not return the exit code of the remote program, so 'Run'
+     requires adjustment.&quot;&quot;&quot;
+ 
+     # Override the default values.
+     ssh_program = TextField(
+         default_value = &quot;rsh&quot;,
+         description = &quot;&quot;&quot;The path to the remote shell program.&quot;&quot;&quot;
+         )
+     scp_program = TextField(
+         default_value = &quot;rcp&quot;,
+         description = &quot;&quot;&quot;The path to the remote copy program.&quot;&quot;&quot;
+         )
+ 
+     def Run(self, path, arguments, environment = None, timeout = -1):
+ 
+         status, output = \
+                 super(RSHHost, self).Run(path, arguments,
+                                          environment, timeout)
+         # The exit status of 'rsh' is not the exit status of the
+         # remote program.  The exit status of the remote program is
+         # unavailable. 
+         return (None, output)

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001035.html">PATCH: Remove minor code duplication
</A></li>
	<LI>Next message: <A HREF="001037.html">[qmtest] PATCH: RemoteHost support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1036">[ date ]</a>
              <a href="thread.html#1036">[ thread ]</a>
              <a href="subject.html#1036">[ subject ]</a>
              <a href="author.html#1036">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">More information about the qmtest
mailing list</a><br>
</body></html>
