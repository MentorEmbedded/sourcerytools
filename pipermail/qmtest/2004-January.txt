From mark at codesourcery.com  Fri Jan  2 21:51:36 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 02 Jan 2004 13:51:36 -0800
Subject: [qmtest] Patch 2.0.3 or use latest CVS?
In-Reply-To: <3FF1F139.5090502@nextone.com>
References: <3FF1F139.5090502@nextone.com>
Message-ID: <1073080296.4068.19.camel@minax.codesourcery.com>


>  File "/opt/nextest/lib/qm/qm/test/qmtest.py", line 78, in ?
>     exit_code = command.Execute()
>   File "/lib/qm/qm/test/cmdline.py", line 569, in Execute
>   File "/lib/qm/qm/test/cmdline.py", line 1099, in __ExecuteRemote
>   File "/opt/nextest/lib/python2.3/copy_reg.py", line 50, in
> _reconstructor
>     obj = base.__new__(cls, state)
> TypeError: ('dict.__new__(X): X is not a type object (classobj)',
> <function _reconstructor at 0x81827d4>, (<class
> qm.test.context.Context at 0x833477c>, <type 'dict'>, {}))

That's a very strange error and backtrace.

What operating system are you running on?

> Should I go with 2.0.3 for production use and apply the patches?  
> Are there any glaring deficiencies in 2.0.3?  

I would currently recommend the CVS version, simply because 2.0.3 has
gotten fairly out of date at this point.  The CVS version should be
quite stable, despite your experience above.

> On a related note, should I send documentation errors and bugs to this
> list?

Yes, this is the right list for documentation errors and bugs.

Thanks,

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From mark at codesourcery.com  Fri Jan  2 22:07:36 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 02 Jan 2004 14:07:36 -0800
Subject: [qmtest] Upgrading tests
In-Reply-To: <200312241224.46048.ghost@cs.msu.su>
References: <200312151106.23686.ghost@cs.msu.su>
	 <1071505475.17592.3.camel@doubledemon.codesourcery.com>
	 <200312241224.46048.ghost@cs.msu.su>
Message-ID: <1073081256.4068.27.camel@minax.codesourcery.com>


> The upgrade logic is
> 1. Old test is loaded
> 2. Instance of new test class is created
> 3. Method 'Upgrade' on the new instance is called with the old class instance
> 4. The test is saved.

That seems like a good plan.

> I'd be happy to send the patch, if there's interest, but there are two things 
> I don't like and would prefer to cleanup -- and that requires some 
> discussion.
> 
> First, problem is that database can't save tests, only instances of 
> TestDescriptor. I'm thinking that either database should be able to save 
> tests, too, or there should be a method in  Test which return TestDescriptor. 

That's a valid objection.  Zack has been complaining about
non-orthogonalities in Database for some time; I will see if I can work
on the issue that you raise.  I think I know how to clean this up in a
relatively nice way.

> The biggest problem is that it's hard to create default-initialized instance 
> of new test class. I can pass empty mapping for arguments, but 
> Runnable.__init__ expects 'extra' keyword arguments. I can work around this, 
> too, by passing what Runnable expects, but this starts to be rather messy. 
> E.g., if Runnable is changes to require another extra keyword argument, my 
> code will break. Is there some way I can cleanly create default-initialized 
> test instance?

In the short term, I suggest that we change Runnable to simply set __id
and __database to "None" if no corresponding value is foundin extras. 
Then, you can just ignore the "extras" argument.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From slowrey at nextone.com  Fri Jan  2 22:10:43 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Fri, 02 Jan 2004 17:10:43 -0500
Subject: [qmtest] Patch 2.0.3 or use latest CVS?
In-Reply-To: <1073080296.4068.19.camel@minax.codesourcery.com>
References: <3FF1F139.5090502@nextone.com> <1073080296.4068.19.camel@minax.codesourcery.com>
Message-ID: <3FF5EC63.3060207@nextone.com>

Thanks, Mark.  The OS is Red Hat 9 with Python 2.3.3.

I'll try to be more precise in providing bug information next time in 
hopes that you can reproduce.  Are there any specific bits of debug info 
you'd like?

Mark Mitchell wrote:

>> File "/opt/nextest/lib/qm/qm/test/qmtest.py", line 78, in ?
>>    exit_code = command.Execute()
>>  File "/lib/qm/qm/test/cmdline.py", line 569, in Execute
>>  File "/lib/qm/qm/test/cmdline.py", line 1099, in __ExecuteRemote
>>  File "/opt/nextest/lib/python2.3/copy_reg.py", line 50, in
>>_reconstructor
>>    obj = base.__new__(cls, state)
>>TypeError: ('dict.__new__(X): X is not a type object (classobj)',
>><function _reconstructor at 0x81827d4>, (<class
>>qm.test.context.Context at 0x833477c>, <type 'dict'>, {}))
>>    
>>
>
>That's a very strange error and backtrace.
>
>What operating system are you running on?
>
>  
>
>>Should I go with 2.0.3 for production use and apply the patches?  
>>Are there any glaring deficiencies in 2.0.3?  
>>    
>>
>
>I would currently recommend the CVS version, simply because 2.0.3 has
>gotten fairly out of date at this point.  The CVS version should be
>quite stable, despite your experience above.
>
>  
>
>>On a related note, should I send documentation errors and bugs to this
>>list?
>>    
>>
>
>Yes, this is the right list for documentation errors and bugs.
>
>Thanks,
>
>  
>

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040102/a1aa4c87/attachment.html>

From mark at codesourcery.com  Fri Jan  2 22:24:49 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 02 Jan 2004 14:24:49 -0800
Subject: [qmtest] Patch 2.0.3 or use latest CVS?
In-Reply-To: <3FF5EC63.3060207@nextone.com>
References: <3FF1F139.5090502@nextone.com>
	 <1073080296.4068.19.camel@minax.codesourcery.com>
	 <3FF5EC63.3060207@nextone.com>
Message-ID: <1073082289.4068.45.camel@minax.codesourcery.com>

On Fri, 2004-01-02 at 14:10, Scott Lowrey wrote:
> Thanks, Mark.  The OS is Red Hat 9 with Python 2.3.3.
> 
> I'll try to be more precise in providing bug information next time in
> hopes that you can reproduce.  Are there any specific bits of debug
> info you'd like?

It's often difficult to debug this kind of thing without actually
accessing your system, unfortunately.  I'd certainly like to know the
command-line you used.  If, you can create a small test database (with a
single test) that can reproduce the problem you can send that to me.

Thanks,

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From njs at pobox.com  Sat Jan  3 02:42:41 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Fri, 2 Jan 2004 18:42:41 -0800
Subject: [qmtest] Patch 2.0.3 or use latest CVS?
In-Reply-To: <3FF1F139.5090502@nextone.com>
References: <3FF1F139.5090502@nextone.com>
Message-ID: <20040103024240.GA15675@njs.dhis.org>

On Tue, Dec 30, 2003 at 04:42:17PM -0500, Scott Lowrey wrote:
>    In running 2.0.3 from the website, I came across a small bug that shows up
>    during a simple test on a remote target.  The bug is in
>    qm/test/classes/rsh_target.py.  I was able to hack it and get the test to
>    work.
> 
>    Today, I built a version of QMTest from the CVS repository and it blew up
>    a bit more violently for the same test:
> 
>     File "/opt/nextest/lib/qm/qm/test/qmtest.py", line 78, in ?
>        exit_code = command.Execute()
>      File "/lib/qm/qm/test/cmdline.py", line 569, in Execute
>      File "/lib/qm/qm/test/cmdline.py", line 1099, in __ExecuteRemote
>      File "/opt/nextest/lib/python2.3/copy_reg.py", line 50, in
>    _reconstructor
>        obj = base.__new__(cls, state)
>    TypeError: ('dict.__new__(X): X is not a type object (classobj)',
>    <function _reconstructor at 0x81827d4>, (<class qm.test.context.Context at
>    0x833477c>, <type 'dict'>, {}))

I think QMTest is talking to an old version of itself on the remote
host; you need to install CVS QMTest on the remote host as well.  (Or
if the problem is that CVS QMTest is installed at different locations
on the local and remote hosts, then you should set the 'qmtest'
attribute of your remote target to the full path to an appropriate
qmtest executable on the remote host.)

Evidence?  There were incompatible changes to the Context object, and
this should cause exactly this problem when the local host tries to
send a pickled Context across to the remote host.  Also, the line
numbers in the exception are wrong for any CVS version from at least
the past 6 months.

-- Nathaniel

-- 
.i dei jitfa fanmo xatra


From mark at codesourcery.com  Sat Jan  3 03:10:00 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 02 Jan 2004 19:10:00 -0800
Subject: [qmtest] Patch 2.0.3 or use latest CVS?
In-Reply-To: <20040103024240.GA15675@njs.dhis.org>
References: <3FF1F139.5090502@nextone.com>
	 <20040103024240.GA15675@njs.dhis.org>
Message-ID: <1073099400.3915.2.camel@minax.codesourcery.com>


> Evidence?  There were incompatible changes to the Context object, and
> this should cause exactly this problem when the local host tries to
> send a pickled Context across to the remote host.  Also, the line
> numbers in the exception are wrong for any CVS version from at least
> the past 6 months.

Excellent deduction.  

As the author of the Context changes, it makes sense that you would be
able to figure that out. :-)

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From slowrey at nextone.com  Sat Jan  3 03:46:02 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Fri, 02 Jan 2004 22:46:02 -0500
Subject: [qmtest] Patch 2.0.3 or use latest CVS?
In-Reply-To: <1073099400.3915.2.camel@minax.codesourcery.com>
References: <3FF1F139.5090502@nextone.com>	 <20040103024240.GA15675@njs.dhis.org> <1073099400.3915.2.camel@minax.codesourcery.com>
Message-ID: <3FF63AFA.8080601@nextone.com>

Mark Mitchell wrote:

>>Evidence?  There were incompatible changes to the Context object, and
>>this should cause exactly this problem when the local host tries to
>>send a pickled Context across to the remote host.  Also, the line
>>numbers in the exception are wrong for any CVS version from at least
>>the past 6 months.
>>    
>>
>
>Excellent deduction.  
>
>As the author of the Context changes, it makes sense that you would be
>able to figure that out. :-)
>
>  
>
Thanks, this sounds like a good possibility.  Although I was careful to 
copy the *database* over to the remote, I don't recall reinstalling the 
newer QMTest.  I'll give it a whirl...



From mark at codesourcery.com  Sat Jan  3 04:05:33 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 02 Jan 2004 20:05:33 -0800
Subject: [qmtest] Upgrading tests
In-Reply-To: <1073081256.4068.27.camel@minax.codesourcery.com>
References: <200312151106.23686.ghost@cs.msu.su>
	 <1071505475.17592.3.camel@doubledemon.codesourcery.com>
	 <200312241224.46048.ghost@cs.msu.su>
	 <1073081256.4068.27.camel@minax.codesourcery.com>
Message-ID: <1073102733.3915.14.camel@minax.codesourcery.com>


> That's a valid objection.  Zack has been complaining about
> non-orthogonalities in Database for some time; I will see if I can work
> on the issue that you raise.  I think I know how to clean this up in a
> relatively nice way.

This patch makes Database take an Extension instance as an argument to
WriteExtension and eliminates the separate
WriteTest/WriteResource/WriteSuite methods.  That provides more
generality in Database and should make your upgrade code simpler.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC
-------------- next part --------------
2004-01-02  Mark Mitchell  <mark at codesourcery.com>

	* qm/extension.py (Extension.MakeDomElement): New method.
	(Extension.MakeDomDocument): Likewise.
	(Extension.Write): Likewise.
	* qm/test/base.py (extension_kinds): Add "suite".
	(qm.test.suite): Import it.
	(__extension_bases): Mention "suite".
	* qm/test/datbase.py (Database.WriteTest): Remove.
	(Database.RemoveTest): Likewise.
	(Database.WriteResource): Likewise.
	(Database.RemoveResource): Likewise.
	(Database.WriteSuite): Likewise.
	(Database.RemoveSuite): Likewise.
	(Database.IsModifiable): Adjust comment.
	(Database.RemoveExtension): New method.
	(Database.WriteExtension): Likewise.
	* qm/test/directory_suite.py (DirectorySuite.__init__): Adjust for
	the fact that 'Suite' is now an 'Extension.
	(DirectorySuite.IsImplicit): New method.
	* qm/test/file_database.py (FileDatabase.RemoveTest): Remove.
	(FileDatabase.RemoveResource): Likewise.
	(FileDatabase.RemoveSuite): Likewise.
	(FileDatabase._GetPath): New method.
	(FileDatabase._RemoveEntity): Remove.
	(FileDatabase.RemoveExtension): New test.
	* qm/test/suite.py (Suite): Derive from Extension.
	* qm/test/classes/explicit_suite.py: New file.
	* qm/test/classes/classes.qmc: Regenerate.
	* qm/test/classes/mount_database.py (MountedSuite.__init__):
	Adjust for the fact that 'Suite' is now an 'Extension.
	(MountedSuite.IsImplicit): New method.
	* qm/test/clasess/xml_database.py (XMLDatabase.WriteTest): Remove.
	(XMLDatabase.WriteResource): Likewise.
	(XMLDatabase.WriteSuite): Likewise.
	(XMLDatabase.__StoreAdjustments): Rework to adjust for the fact
	that actual extension instances are provided.
	(XMLDatabase._GetSuiteFromPath): Deal with old and new suite
	formats.
	(XMLDatabse.WriteExtension): New method.
	* qm/test/doc/reference.xml: Do not mention WriteTest or
	RemoveTest.
	* qm/test/web/web.py (QMTestServer.HandleCreateSuite): Adjust for
	changes above.
	(QMTestServer.HandleDeleteItem): Likewise.
	(QMTestServer.HandleDeleteSuite): Likewise.
	(QMTestServer.HandleSubmitItem): Likewise.

Index: qm/extension.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/extension.py,v
retrieving revision 1.13
diff -c -5 -p -r1.13 extension.py
*** qm/extension.py	15 Sep 2003 20:26:40 -0000	1.13
--- qm/extension.py	3 Jan 2004 04:01:30 -0000
*************** class Extension(object):
*** 110,119 ****
--- 110,181 ----
          # Perhaps a default value for a class argument should be used.
          field = get_class_arguments_as_dictionary(self.__class__).get(name)
          if field is None:
              raise AttributeError, name
          return field.GetDefaultValue()
+ 
+ 
+     def MakeDomElement(self, document, element = None):
+         """Create a DOM node for 'self'.
+ 
+         'document' -- The DOM document that will contain the new
+         element.
+         
+         'element' -- If not 'None' the extension element to which items
+         will be added.  Otherwise, a new element will be created by this
+         function.
+         
+         returns -- A new DOM element corresponding to an instance of the
+         extension class.  The caller is responsible for attaching it to
+         the 'document'."""
+ 
+         # Get all of the arguments.
+         arguments = get_class_arguments_as_dictionary(self.__class__)
+         import sys
+         print >> sys.stderr, arguments
+         # Determine which subset of the 'arguments' have been set
+         # explicitly.
+         explicit_arguments = {}
+         for name, field in arguments.items():
+             # Do not record computed fields.
+             if field.IsComputed():
+                 continue
+             print >> sys.stderr, name
+             if self.__dict__.has_key(name):
+                 explicit_arguments[name] = self.__dict__[name]
+ 
+         return make_dom_element(self.__class__, explicit_arguments,
+                                 document, element)
+ 
+ 
+     def MakeDomDocument(self):
+         """Create a DOM document for 'self'.
+ 
+         'extension_class' -- A class derived from 'Extension'.
+ 
+         'arguments' -- The arguments to the extension class.
+         
+         returns -- A new DOM document corresponding to an instance of the
+         extension class."""
+         
+         document = qm.xmlutil.create_dom_document(
+             public_id = "Extension",
+             document_element_tag = "extension"
+             )
+         self.MakeDomElement(document, document.documentElement)
+         return document
+ 
+ 
+     def Write(self, file):
+         """Write an XML description of 'self' to a file.
+         
+         'file' -- A file object to which the data should be written."""
+         
+         document = self.MakeDomDocument()
+         document.writexml(file)
+                                 
+         
                  
  ########################################################################
  # Functions
  ########################################################################
  
Index: qm/test/base.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/base.py,v
retrieving revision 1.95
diff -c -5 -p -r1.95 base.py
*** qm/test/base.py	24 Nov 2003 00:52:57 -0000	1.95
--- qm/test/base.py	3 Jan 2004 04:01:30 -0000
*************** def _result_from_dom(node):
*** 395,404 ****
--- 395,405 ----
  extension_kinds = [ 'database',
                      'label',
                      'resource',
                      'result_reader',
                      'result_stream',
+                     'suite',
                      'target',
                      'test', ]
  """Names of different kinds of QMTest extension classes."""
  
  __class_caches = {}
*************** for kind in extension_kinds:
*** 414,432 ****
--- 415,435 ----
  import qm.test.database
  import qm.label
  import qm.test.resource
  import qm.test.result_reader
  import qm.test.result_stream
+ import qm.test.suite
  import qm.test.target
  import qm.test.test
  
  __extension_bases = {
      'database' : qm.test.database.Database,
      'label' : qm.label.Label,
      'resource' : qm.test.resource.Resource,
      'result_reader' : qm.test.result_reader.ResultReader,
      'result_stream' : qm.test.result_stream.ResultStream,
+     'suite' : qm.test.suite.Suite,
      'target' : qm.test.target.Target,
      'test' : qm.test.test.Test
      }
  """A map from extension class kinds to base classes.
  
Index: qm/test/database.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/database.py,v
retrieving revision 1.39
diff -c -5 -p -r1.39 database.py
*** qm/test/database.py	22 Sep 2003 04:53:47 -0000	1.39
--- qm/test/database.py	3 Jan 2004 04:01:30 -0000
*************** class Database(qm.extension.Extension):
*** 596,645 ****
          named 'test_id'."""
  
          raise NoSuchTestError(test_id)
  
  
-     def WriteTest(self, test):
-         """Store 'test' in the database.
- 
-         'test' -- A 'TestDescriptor' indicating the test that should
-         be stored.
- 
-         'Attachment's associated with 'test' may be located in the
-         'AttachmentStore' associated with this database, or in some
-         other 'AttachmentStore'.  In the case that they are stored
-         elsewhere, they must be copied into the 'AttachmentStore'
-         associated with this database by use of the
-         'AttachmentStore.Store' method.  The caller, not this method,
-         is responsible for removing the original version of the
-         attachment, if necessary.
-          
-         The 'test' may be new, or it may be a new version of an existing
-         test.  If it is a new version of an existing test, the database
-         may wish to clear out any storage associated with the existing
-         test.  However, it is possible that 'Attachment's associated
-         with the existing test are still present in 'test', in which
-         case it would be a mistake to remove them.
- 
-         Derived classes must override this method."""
- 
-         raise NotImplementedError
- 
- 
-     def RemoveTest(self, test_id):
-         """Remove the test named 'test_id' from the database.
- 
-         'test_id' -- A label naming the test that should be removed.
- 
-         raises -- 'NoSuchTestError' if there is no test in the database
-         named 'test_id'.
- 
-         Derived classes must override this method."""
- 
-         raise NotImplementedError
- 
- 
      def HasTest(self, test_id):
          """Check whether or not the database has a test named 'test_id'.
  
          'test_id' -- A label naming the test.
  
--- 596,605 ----
*************** class Database(qm.extension.Extension):
*** 698,739 ****
              return DirectorySuite(self, "")
  
          raise NoSuchSuiteError(suite_id)
  
  
-     def WriteSuite(self, suite):
-         """Store 'suite' in the database.
- 
-         'suite' -- An instance of 'Suite' (or a derived class of
-         'Suite') that should be stored.  The 'suite' will not be
-         implicit.
- 
-         The 'suite' may be new, or it may be a new version of an
-         existing testsuite.  If 'suite' is a new version of an existing
-         suite, it may name fewer tests than the existing version.
-         However, this method should not remove any of the tests
-         themselves.
- 
-         Derived classes must override this method."""
- 
-         raise NotImplementedError
- 
- 
-     def RemoveSuite(self, suite_id):
-         """Remove the suite named 'suite_id' from the database.
- 
-         'suite_id' -- A label naming the suite that should be removed.
-         The suite will not be implicit.
-           
-         raises -- 'NoSuchSuiteError' if there is no suite in the
-         database named 'test_id'.
- 
-         Derived classes must override this method."""
- 
-         raise NotImplementedError
- 
- 
      def HasSuite(self, suite_id):
          """Check whether or not the database has a suite named 'suite_id'.
  
          'suite_id' -- A label naming the suite.
  
--- 658,667 ----
*************** class Database(qm.extension.Extension):
*** 789,826 ****
          database named 'resource_id'."""
  
          raise NoSuchResourceError(resource_id)
  
  
-     def WriteResource(self, resource):
-         """Store 'resource' in the database.
- 
-         'resource' -- A 'ResourceDescriptor' indicating the resource that
-         should be stored.
- 
-         The 'resource' may be new, or it may be a new version of an
-         existing resource.
- 
-         Derived classes must override this method."""
- 
-         raise NotImplementedError
- 
- 
-     def RemoveResource(self, resource_id):
-         """Remove the resource named 'resource_id' from the database.
- 
-         'resource_id' -- A label naming the resource that should be
-         removed.
- 
-         raises -- 'NoSuchResourceError' if there is no resource in the
-         database named 'resource_id'.
- 
-         Derived classes must override this method."""
- 
-         raise NotImplementedError
- 
- 
      def HasResource(self, resource_id):
          """Check whether or not the database has a resource named
          'resource_id'.
  
          'resource_id' -- A label naming the resource.
--- 717,726 ----
*************** class Database(qm.extension.Extension):
*** 1041,1055 ****
  
          # Convert the maps to sequences.
          return test_ids.keys(), suite_ids.keys()
  
  
      def IsModifiable(self):
          """Returns true iff this database is modifiable.
  
          returns -- True iff this database is modifiable.  If the
!         database is modifiable, it supports operations like 'WriteTest'
          that make changes to the structure of the databaes itself.
          Otherwise, the contents of the database may be viewed, but not
          modified."""
  
          return self.modifiable == "true"
--- 941,986 ----
  
          # Convert the maps to sequences.
          return test_ids.keys(), suite_ids.keys()
  
  
+     def RemoveExtension(self, id, kind):
+         """Remove the extension 'id' from the database.
+ 
+         'id' -- A label for the 'Extension' instance stored in the
+         database.
+ 
+         'kind' -- The kind of 'Extension' stored with the given 'id'.
+         Some databases store different kinds of 'Extension' in different
+         namespaces so that it is possible for there to be more than one
+         'Extension' with the same 'id' in a single database."""
+ 
+         raise NotImplementedError
+         
+         
+     def WriteExtension(self, id, extension):
+         """Store 'extension' in the database, using the name 'id'.
+ 
+         'id' -- A label for the 'extension'.
+         
+         'extension' -- An instance of 'Extension'.
+ 
+         The 'extension' is stored in the database.  If there is a
+         previous item in the database with the same id', it is removed
+         and replaced with 'extension'.  Some databases may not be able
+         to store all 'Extension' instances; those database must throw an
+         exception when an attempt is made to store such an
+         'extension'."""
+ 
+         raise NotImplementedError
+         
+         
      def IsModifiable(self):
          """Returns true iff this database is modifiable.
  
          returns -- True iff this database is modifiable.  If the
!         database is modifiable, it supports operatings like 'Write'
          that make changes to the structure of the databaes itself.
          Otherwise, the contents of the database may be viewed, but not
          modified."""
  
          return self.modifiable == "true"
Index: qm/test/directory_suite.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/directory_suite.py,v
retrieving revision 1.4
diff -c -5 -p -r1.4 directory_suite.py
*** qm/test/directory_suite.py	28 May 2002 01:37:55 -0000	1.4
--- qm/test/directory_suite.py	3 Jan 2004 04:01:30 -0000
*************** class DirectorySuite(Suite):
*** 38,73 ****
  
          'directory' -- A label giving the directory corresponding to
          this suite."""
  
          # Construct the base class.
!         Suite.__init__(self, database, directory, implicit=1)
!         # Remember the database.
!         self.__database = database
  
  
      def GetTestIds(self):
          """Return the tests contained in this suite.
          
          returns -- A sequence of labels corresponding to the tests
          contained in this suite.  Tests that are contained in this suite
          only because they are contained in a suite which is itself
          contained in this suite are not returned."""
  
!         return self.__database.GetTestIds(self.GetId(), scan_subdirs=0)
      
  
      def GetSuiteIds(self):
          """Return the suites contained in this suite.
          
          returns -- A sequence of labels corresponding to the suites
          contained in this suite.  Suites that are contained in this
          suite only because they are contained in a suite which is itself
          contained in this suite are not returned."""
  
!         return self.__database.GetSuiteIds(self.GetId(), scan_subdirs=0)
  
  ########################################################################
  # Local Variables:
  # mode: python
  # indent-tabs-mode: nil
  # fill-column: 72
--- 38,78 ----
  
          'directory' -- A label giving the directory corresponding to
          this suite."""
  
          # Construct the base class.
!         super(DirectorySuite, self).__init__({},
!                                              qmtest_id = directory,
!                                              qmtest_database = database)
  
  
      def GetTestIds(self):
          """Return the tests contained in this suite.
          
          returns -- A sequence of labels corresponding to the tests
          contained in this suite.  Tests that are contained in this suite
          only because they are contained in a suite which is itself
          contained in this suite are not returned."""
  
!         return self.GetDatabase().GetTestIds(self.GetId(), scan_subdirs=0)
      
  
      def GetSuiteIds(self):
          """Return the suites contained in this suite.
          
          returns -- A sequence of labels corresponding to the suites
          contained in this suite.  Suites that are contained in this
          suite only because they are contained in a suite which is itself
          contained in this suite are not returned."""
  
!         return self.GetDatabase().GetSuiteIds(self.GetId(), scan_subdirs=0)
  
+ 
+     def IsImplicit(self):
+ 
+         return 1
+     
  ########################################################################
  # Local Variables:
  # mode: python
  # indent-tabs-mode: nil
  # fill-column: 72
Index: qm/test/file_database.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/file_database.py,v
retrieving revision 1.20
diff -c -5 -p -r1.20 file_database.py
*** qm/test/file_database.py	28 Nov 2003 20:34:58 -0000	1.20
--- qm/test/file_database.py	3 Jan 2004 04:01:30 -0000
*************** class FileDatabase(Database):
*** 56,79 ****
              raise NoSuchTestError, test_id
  
          return self._GetTestFromPath(test_id, os.path.normpath(path))
  
  
-     def RemoveTest(self, test_id):
-         """Remove the test named 'test_id' from the database.
- 
-         'test_id' -- A label naming the test that should be removed.
- 
-         raises -- 'NoSuchTestError' if there is no test in the database
-         named 'test_id'.
- 
-         Derived classes may override this method if they need to remove
-         additional information from the database."""
- 
-         self.__RemoveEntity(self.GetTestPath(test_id), NoSuchTestError)
- 
- 
      def GetTestPath(self, test_id):
          """Return the file containing 'test_id'.
  
          'test_id' -- The name of a test.
  
--- 56,65 ----
*************** class FileDatabase(Database):
*** 122,146 ****
              return DirectorySuite(self, suite_id)
          else:
              return self._GetSuiteFromPath(suite_id, os.path.normpath(path))
  
          
-     def RemoveSuite(self, suite_id):
-         """Remove the suite named 'suite_id' from the database.
- 
-         'suite_id' -- A label naming the suite that should be removed.
-         The suite will not be implicit.
-         
-         raises -- 'NoSuchSuiteError' if there is no suite in the database
-         named 'suite_id'.
- 
-         Derived classes may override this method if they need to remove
-         additional information from the database."""
- 
-         self.__RemoveEntity(self.GetSuitePath(suite_id), NoSuchSuiteError)
- 
- 
      def GetSuitePath(self, suite_id):
          """Return the file containing 'suite_id'.
  
          'suite_id' -- The name of a suite.
  
--- 108,117 ----
*************** class FileDatabase(Database):
*** 189,213 ****
              raise NoSuchResourceError, resource_id
  
          return self._GetResourceFromPath(resource_id, os.path.normpath(path))
  
  
-     def RemoveResource(self, resource_id):
-         """Remove the resource named 'resource_id' from the database.
- 
-         'resource_id' -- A label naming the resource that should be removed.
- 
-         raises -- 'NoSuchResourceError' if there is no resource in the database
-         named 'resource_id'.
- 
-         Derived classes may override this method if they need to remove
-         additional information from the database."""
- 
-         self.__RemoveEntity(self.GetResourcePath(resource_id),
-                             NoSuchResourceError)
- 
- 
      def GetResourcePath(self, resource_id):
          """Return the file containing 'resource_id'.
  
          'resource_id' -- The name of a resource.
  
--- 160,169 ----
*************** class FileDatabase(Database):
*** 279,288 ****
--- 235,258 ----
          # Get all the files of the appropriate kind.
          return self._GetLabels(file_dir, scan_subdirs, directory,
                                 lambda p: self._IsFile(kind, p))
  
  
+     def _GetPath(self, kind, id):
+         """Returns the file system path corresponding to 'id'.
+ 
+         'kind' -- An extension kind.
+ 
+         'id' -- The name of the entity.
+ 
+         returns -- The path in which the entity is stored."""
+ 
+         return { Database.RESOURCE : self.GetResourcePath,
+                  Database.TEST : self.GetTestPath,
+                  Database.SUITE : self.GetSuitePath } [kind] (id)
+         
+         
      def _IsFile(self, kind, path):
          """Returns true if 'path' is a file of the indicated 'kind'.
  
          'kind' -- One of 'Database.ITEM_KINDS'.
  
*************** class FileDatabase(Database):
*** 411,431 ****
                                                                entry_label),
                                                predicate))
  
          return labels
          
-         
-     def __RemoveEntity(self, path, exception):
-         """Remove an entity.
- 
-         'path' -- The name of the file containing the entity.
  
!         'exception' -- The type of exception to raise if the file
!         is not present."""
  
          if not os.path.isfile(path):
!             raise exception, entity_id
  
          os.remove(path)
  
  
      def _AreLabelsPaths(self):
--- 381,398 ----
                                                                entry_label),
                                                predicate))
  
          return labels
          
  
!     def RemoveExtension(self, id, kind):
  
+         path = self._GetPath(kind, id)
          if not os.path.isfile(path):
!             raise { Database.RESOURCE : NoSuchResourceError,
!                     Database.TEST: NoSuchTestError,
!                     Database.SUITE: NoSuchSuiteError }[kind], id
  
          os.remove(path)
  
  
      def _AreLabelsPaths(self):
Index: qm/test/suite.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/suite.py,v
retrieving revision 1.3
diff -c -5 -p -r1.3 suite.py
*** qm/test/suite.py	28 May 2002 01:37:55 -0000	1.3
--- qm/test/suite.py	3 Jan 2004 04:01:30 -0000
***************
*** 12,132 ****
  # For license terms see the file COPYING.
  #
  ########################################################################
  
  ########################################################################
! # classes
  ########################################################################
  
! class Suite:
!    """A collection of tests.
  
!    A test suite is a collection of tests.  The suite may contain other
!    suites by reference as well; all tests contained in these contained
!    suites are considered contained in the containing suite as well."""
! 
!    def __init__(self,
!                 database,
!                 suite_id,
!                 implicit=0,
!                 test_ids=[],
!                 suite_ids=[]):
!        """Create a new test suite instance.
! 
!        'database' -- The database in which this suite is located.
!        
!        'suite_id' -- The ID of the new suite.
! 
!        'implicit' -- If true, this is an implicit suite, generated
!        automatically by QMTest.
! 
!        'test_ids' -- A sequence of IDs of tests contained in the suite.
! 
!        'suite_ids' -- A sequence of IDs of suites contained in the
!        suite."""
! 
!        self.__database = database
!        self.__id = suite_id
!        self.__implicit = implicit
!        self.__test_ids = list(test_ids)
!        self.__suite_ids = list(suite_ids)
! 
! 
!    def GetDatabase(self):
!        """Return the 'Database' that contains this suite.
! 
!        returns -- The 'Database' that contains this suite."""
! 
!        return self.__database
! 
!    
!    def GetId(self):
!        """Return the ID of this test suite."""
! 
!        return self.__id
! 
! 
!    def IsImplicit(self):
!        """Return true if this is an implicit test suite.
! 
!        Implicit test suites cannot be edited."""
  
!        return self.__implicit
  
  
!    def GetTestIds(self):
!        """Return the tests contained in this suite.
         
-        returns -- A sequence of labels corresponding to the tests
-        contained in this suite.  Tests that are contained in this suite
-        only because they are contained in a suite which is itself
-        contained in this suite are not returned."""
- 
-        return self.__test_ids
- 
-    
-    def GetSuiteIds(self):
-        """Return the suites contained in this suite.
         
-        returns -- A sequence of labels corresponding to the suites
-        contained in this suite.  Suites that are contained in this suite
-        only because they are contained in a suite which is itself
-        contained in this suite are not returned."""
- 
-        return self.__suite_ids
- 
- 
-    def GetAllTestAndSuiteIds(self):
-        """Return the tests/suites contained in this suite and its subsuites.
  
-        returns -- A pair '(test_ids, suite_ids)'.  The 'test_ids' and
-        'suite_ids' elements are both sequences of labels.  The values
-        returned include all tests and suites that are contained in this
-        suite and its subsuites, recursively."""
- 
-        suite = self
-        
-        test_ids = []
-        suite_ids = []
- 
-        # Maintain a work list of suites to process.
-        work_list = [suite]
-        # Process until the work list is empty.
-        while len(work_list) > 0:
-            suite = work_list.pop(0)
-            # Accumulate test and resource IDs in the suite.
-            test_ids.extend(suite.GetTestIds())
-            # Find sub suites in the suite.
-            sub_suite_ids = suite.GetSuiteIds()
-            # Accumulate them.
-            suite_ids.extend(sub_suite_ids)
-            # Retrieve the 'Suite' objects.
-            sub_suites = map(self.GetDatabase().GetSuite, sub_suite_ids)
-            # Don't expand ordinary suites contained in implicit suites.
-            if suite.IsImplicit():
-                sub_suites = filter(lambda s: s.IsImplicit(), sub_suites)
-            # Add contained suites to the work list.
-            work_list.extend(sub_suites)
- 
-        return test_ids, suite_ids
-        
-        
--- 12,147 ----
  # For license terms see the file COPYING.
  #
  ########################################################################
  
  ########################################################################
! # Imports
  ########################################################################
  
! import qm
! import qm.extension
  
! ########################################################################
! # Classes
! ########################################################################
  
! class Suite(qm.extension.Extension):
!     """A collection of tests.
  
+      A test suite is a collection of tests.  The suite may contain other
+     suites by reference as well; all tests contained in these contained
+     suites are considered contained in the containing suite as well."""
+ 
+     arguments = [
+        ]
+ 
+     kind = "suite"
+ 
+     EXTRA_ID = "qmtest_id"
+     """The name of the extra keyword argument to '__init__' that
+     specifies the name of the test or resource."""
+ 
+     EXTRA_DATABASE = "qmtest_database"
+     """The name of the extra keyword argument to '__init__' that
+     specifies the database containing the test or resource."""
+ 
+ 
+     def __init__(self, arguments, **extras):
+         """Construct a new 'Runnable'.
+         
+         'arguments' -- As for 'Extension.__init__'.
+         
+         'extras' -- Extra keyword arguments provided by QMTest.
+         Derived classes must pass along any unrecognized keyword
+         arguments to this method.  All extra keyword arguments
+         provided by QMTest will begin with 'qmtest_'.  These arguments
+         are provided as keyword arguments so that additional arguments
+         can be added in the future without necessitating changes to
+         test or resource classes.  Derived classes should not rely in
+         any way on the contents of 'extras'."""
+         
+         qm.extension.Extension.__init__(self, arguments)
+         
+         self.__id = extras[self.EXTRA_ID]
+         self.__database = extras[self.EXTRA_DATABASE]
+         
+         
+     def GetDatabase(self):
+         """Return the 'Database' that contains this suite.
+         
+         returns -- The 'Database' that contains this suite."""
+         
+         return self.__database
+     
+ 
+     def GetId(self):
+         """Return the ID of this test suite."""
+         
+         return self.__id
+ 
+ 
+     def GetTestIds(self):
+         """Return the tests contained in this suite.
+         
+         returns -- A sequence of labels corresponding to the tests
+         contained in this suite.  Tests that are contained in this suite
+         only because they are contained in a suite which is itself
+         contained in this suite are not returned."""
+         
+         return []
+ 
+ 
+     def GetSuiteIds(self):
+         """Return the suites contained in this suite.
+         
+         returns -- A sequence of labels corresponding to the suites
+         contained in this suite.  Suites that are contained in this suite
+         only because they are contained in a suite which is itself
+         contained in this suite are not returned."""
+         
+         return []
+ 
+ 
+     def IsImplicit(self):
+         """Return true if this is an implicit test suite.
+         
+         Implicit test suites cannot be edited."""
+         
+         raise NotImplementedError
+     
+ 
+     def GetAllTestAndSuiteIds(self):
+         """Return the tests/suites contained in this suite and its subsuites.
+         
+         returns -- A pair '(test_ids, suite_ids)'.  The 'test_ids' and
+         'suite_ids' elements are both sequences of labels.  The values
+         returned include all tests and suites that are contained in this
+         suite and its subsuites, recursively."""
+         
+         suite = self
+         
+         test_ids = []
+         suite_ids = []
+         
+         # Maintain a work list of suites to process.
+         work_list = [suite]
+         # Process until the work list is empty.
+         while len(work_list) > 0:
+             suite = work_list.pop(0)
+             # Accumulate test and resource IDs in the suite.
+             test_ids.extend(suite.GetTestIds())
+             # Find sub suites in the suite.
+             sub_suite_ids = suite.GetSuiteIds()
+             # Accumulate them.
+             suite_ids.extend(sub_suite_ids)
+             # Retrieve the 'Suite' objects.
+             sub_suites = map(self.GetDatabase().GetSuite, sub_suite_ids)
+             # Don't expand ordinary suites contained in implicit suites.
+             if suite.IsImplicit():
+                 sub_suites = filter(lambda s: s.IsImplicit(), sub_suites)
+             # Add contained suites to the work list.
+             work_list.extend(sub_suites)
  
!         return test_ids, suite_ids
         
         
  
Index: qm/test/classes/classes.qmc
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/classes.qmc,v
retrieving revision 1.14
diff -c -5 -p -r1.14 classes.qmc
*** qm/test/classes/classes.qmc	22 Sep 2003 04:53:48 -0000	1.14
--- qm/test/classes/classes.qmc	3 Jan 2004 04:01:30 -0000
***************
*** 12,27 ****
   <class kind="target" name="process_target.ProcessTarget"/>
   <class kind="target" name="rsh_target.RSHTarget"/>
   <class kind="target" name="serial_target.SerialTarget"/>
   <class kind="target" name="thread_target.ThreadTarget"/>
   <class kind="database" name="mount_database.MountDatabase"/>
   <class kind="test" name="command.ExecTest"/>
   <class kind="test" name="command.ShellCommandTest"/>
   <class kind="test" name="command.ShellScriptTest"/>
   <class kind="test" name="file.FileContentsTest"/>
   <class kind="test" name="python.ExceptionTest"/>
   <class kind="test" name="python.ExecTest"/>
   <class kind="test" name="python.StringExceptionTest"/>
   <class kind="label" name="file_label.FileLabel"/>
   <class kind="label" name="python_label.PythonLabel"/>
!  <class kind="database" name="xml_database.XMLDatabase"/>
  </class-directory>
--- 12,28 ----
   <class kind="target" name="process_target.ProcessTarget"/>
   <class kind="target" name="rsh_target.RSHTarget"/>
   <class kind="target" name="serial_target.SerialTarget"/>
   <class kind="target" name="thread_target.ThreadTarget"/>
   <class kind="database" name="mount_database.MountDatabase"/>
+  <class kind="database" name="xml_database.XMLDatabase"/>
   <class kind="test" name="command.ExecTest"/>
   <class kind="test" name="command.ShellCommandTest"/>
   <class kind="test" name="command.ShellScriptTest"/>
   <class kind="test" name="file.FileContentsTest"/>
   <class kind="test" name="python.ExceptionTest"/>
   <class kind="test" name="python.ExecTest"/>
   <class kind="test" name="python.StringExceptionTest"/>
   <class kind="label" name="file_label.FileLabel"/>
   <class kind="label" name="python_label.PythonLabel"/>
!  <class kind="suite" name="explicit_suite.ExplicitSuite"/>
  </class-directory>
Index: qm/test/classes/explicit_suite.py
===================================================================
RCS file: qm/test/classes/explicit_suite.py
diff -N qm/test/classes/explicit_suite.py
*** /dev/null	1 Jan 1970 00:00:00 -0000
--- qm/test/classes/explicit_suite.py	3 Jan 2004 04:01:30 -0000
***************
*** 0 ****
--- 1,59 ----
+ ########################################################################
+ #
+ # File:   suite.py
+ # Author: Mark Mitchell
+ # Date:   1/02/2004
+ #
+ # Contents:
+ #   QMTest ExplicitSuite class
+ #
+ # Copyright (c) 2004 by CodeSourcery, LLC.  All rights reserved. 
+ #
+ # For license terms see the file COPYING.
+ #
+ ########################################################################
+ 
+ ########################################################################
+ # Imports
+ ########################################################################
+ 
+ from   qm.fields import BooleanField, SetField, TextField
+ import qm.test.suite
+ 
+ ########################################################################
+ # Classes
+ ########################################################################
+ 
+ class ExplicitSuite(qm.test.suite.Suite):
+     """An 'ExplicitSuite' stores all of the test and suite ids explicitly."""
+ 
+     arguments = [
+         SetField(
+             TextField(
+                 name = "test_ids",
+                 title = "Test Names",
+                 description = """The the tests contained in this suite.""")),
+         SetField(
+             TextField(
+                 name = "suite_ids",
+                 title = "Suite Names",
+                 description = """The the suites contained in this suite.""")),
+         BooleanField(name = "is_implicit",
+                      title = "Implicit?",
+                      description = """,
+                      True if this test is implicitly generated by QMTest."""),
+         ]
+     
+     def IsImplicit(self):
+ 
+         return self.is_implicit
+    
+ 
+     def GetTestIds(self):
+       
+         return self.test_ids
+ 
+    
+     def GetSuiteIds(self):
+       
+         return self.suite_ids
Index: qm/test/classes/mount_database.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/mount_database.py,v
retrieving revision 1.3
diff -c -5 -p -r1.3 mount_database.py
*** qm/test/classes/mount_database.py	20 Aug 2003 18:46:57 -0000	1.3
--- qm/test/classes/mount_database.py	3 Jan 2004 04:01:30 -0000
*************** class MountDatabase(Database):
*** 41,55 ****
      class MountedSuite(Suite):
          """A 'MountedSuite' is a suite from a mounted database."""
  
          def __init__(self, database, suite_id, joiner, suite):
  
!             Suite.__init__(self, database, suite_id, suite.IsImplicit())
              self.__suite = suite
              self.__joiner = joiner
  
  
          def GetTestIds(self):
  
              return map(self.__joiner, self.__suite.GetTestIds())
                                                           
  
--- 41,63 ----
      class MountedSuite(Suite):
          """A 'MountedSuite' is a suite from a mounted database."""
  
          def __init__(self, database, suite_id, joiner, suite):
  
!             super(MountDatabase.MountedSuite, self).\
!                 __init__({},
!                          qmtest_id = suite_id,
!                          qmtest_database = database)
              self.__suite = suite
              self.__joiner = joiner
  
  
+         def IsImplicit(self):
+ 
+             return self.__suite.IsImplicit()
+ 
+         
          def GetTestIds(self):
  
              return map(self.__joiner, self.__suite.GetTestIds())
                                                           
  
Index: qm/test/classes/xml_database.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/xml_database.py,v
retrieving revision 1.16
diff -c -5 -p -r1.16 xml_database.py
*** qm/test/classes/xml_database.py	15 Sep 2003 20:26:41 -0000	1.16
--- qm/test/classes/xml_database.py	3 Jan 2004 04:01:30 -0000
***************
*** 17,33 ****
--- 17,35 ----
  # imports
  ########################################################################
  
  import os
  import qm.common
+ from   qm.extension import get_class_arguments
  import qm.fields
  import qm.label
  import qm.structured_text
  import qm.test.base
  from   qm.test.database import *
  from   qm.test.file_database import *
  from   qm.test.suite import *
+ from   qm.test.classes.explicit_suite import ExplicitSuite
  import qm.xmlutil
  import shutil
  import string
  import xml
  import xml.dom
*************** class XMLDatabase(ExtensionDatabase):
*** 65,90 ****
                                 test_id=test_id,
                                 message=str(exception))
              raise TestFileError, message
          
  
-     def WriteTest(self, test):
- 
-         self.__StoreAttachments(test)
-                                 
-         # Find the file system path for the test file.
-         test_path = self.GetTestPath(test.GetId())
-         # If the file is in a new subdirectory, create it.
-         containing_directory = os.path.dirname(test_path)
-         if not os.path.isdir(containing_directory):
-             os.makedirs(containing_directory)
-         # Write out the test.
-         qm.extension.write_extension_file(test.GetClass(),
-                                           test.GetArguments(),
-                                           open(test_path, "w"))
- 
- 
      def _GetResourceFromPath(self, resource_id, resource_path):
          try:
              return self.__LoadItem(resource_id, resource_path,
                                     self.__ParseResourceDocument)
          except Exception, exception:
--- 67,76 ----
*************** class XMLDatabase(ExtensionDatabase):
*** 92,169 ****
              message = qm.error("error loading xml resource",
                                 resource_id=resource_id,
                                 message=str(exception))
              raise TestFileError, message
          
- 
-     def WriteResource(self, resource):
- 
-         self.__StoreAttachments(resource)
- 
-         # Find the file system path for the resource file.
-         resource_path = self.GetResourcePath(resource.GetId())
-         # If the file is in a new subdirectory, create it.
-         containing_directory = os.path.dirname(resource_path)
-         if not os.path.isdir(containing_directory):
-             os.makedirs(containing_directory)
-         # Write out the resource.
-         qm.extension.write_extension_file(resource.GetClass(),
-                                           resource.GetArguments(),
-                                           open(resource_path, "w"))
- 
- 
-     def WriteSuite(self, suite):
-         """Write 'suite' to the database as a suite file."""
- 
-         # Don't write directory suites to suite file.
-         assert not suite.IsImplicit()
- 
-         # Generate the document and document type for XML suite files.
-         document = qm.xmlutil.create_dom_document(
-             public_id="QMTest/Suite",
-             document_element_tag="suite"
-             )
-         # Construct the suite element node by adding children for test
-         # IDs and suite IDs.  Use the raw test and suite IDs, i.e. don't
-         # expand suites to their contained tests. 
-         suite_element = document.documentElement
-         for test_id in suite.GetTestIds():
-             test_id_element = qm.xmlutil.create_dom_text_element(
-                 document, "test_id", test_id)
-             suite_element.appendChild(test_id_element)
-         for suite_id in suite.GetSuiteIds():
-             suite_id_element = qm.xmlutil.create_dom_text_element(
-                 document, "suite_id", suite_id)
-             suite_element.appendChild(suite_id_element)
-         # Find the file system path for the suite file.
-         suite_path = self.GetSuitePath(suite.GetId())
-         # If the file is in a new subdirectory, create it.
-         containing_directory = os.path.dirname(suite_path)
-         if not os.path.isdir(containing_directory):
-             os.makedirs(containing_directory)
-         # Write out the suite.
-         document.writexml(open(suite_path, "w"))
- 
      # Helper functions.
  
      def __StoreAttachments(self, item):
          """Store all attachments in 'item' in the attachment store.
  
!         'item' -- A 'TestDescriptor' or 'ResourceDescriptor'.  If any of
!         its fields contain attachments, add them to the
!         'AttachmentStore'."""
             
!         for field in item.GetClassArguments():
              if isinstance(field, qm.fields.AttachmentField):
!                 attachment = item.GetArguments()[field.GetName()]
                  if (attachment is not None
                      and attachment.GetStore() != self.__store):
                      location = \
                          self.__MakeDataFilePath(item.GetId(),
                                                  attachment.GetFileName())
!                     item.GetArguments()[field.GetName()] = \
!                          self.__store.Store(attachment, location)
  
           
      def __MakeDataFilePath(self, item_id, file_name):
          """Construct the path to an attachment data file.
  
--- 78,105 ----
              message = qm.error("error loading xml resource",
                                 resource_id=resource_id,
                                 message=str(exception))
              raise TestFileError, message
          
      # Helper functions.
  
      def __StoreAttachments(self, item):
          """Store all attachments in 'item' in the attachment store.
  
!         'item' -- A 'Test' or 'Resource'.  If any of its fields contain
!         attachments, add them to the 'AttachmentStore'."""
             
!         for field in get_class_arguments(item.__class__):
              if isinstance(field, qm.fields.AttachmentField):
!                 attachment = getattr(item, field.GetName())
                  if (attachment is not None
                      and attachment.GetStore() != self.__store):
                      location = \
                          self.__MakeDataFilePath(item.GetId(),
                                                  attachment.GetFileName())
!                     setattr(item, field.GetName(),
!                             self.__store.Store(attachment, location))
  
           
      def __MakeDataFilePath(self, item_id, file_name):
          """Construct the path to an attachment data file.
  
*************** class XMLDatabase(ExtensionDatabase):
*** 290,313 ****
          # Make sure there is a file by that name.
          if not os.path.isfile(path):
              raise NoSuchSuiteError, "no suite file %s" % path
          # Load and parse the suite file.
          document = qm.xmlutil.load_xml_file(path)
          suite = document.documentElement
!         assert suite.tagName == "suite"
!         # Extract the test and suite IDs.
!         test_ids = qm.xmlutil.get_child_texts(suite, "test_id")
!         suite_ids = qm.xmlutil.get_child_texts(suite, "suite_id")
!         # Make sure they're all valid.
!         for id_ in test_ids + suite_ids:
!             if not self.IsValidLabel(id_, is_component = 0):
!                 raise RuntimeError, qm.error("invalid id", id=id_)
!         # Construct the suite.
!         return Suite(self, suite_id, implicit=0,
!                      test_ids=test_ids, suite_ids=suite_ids)
! 
! 
      def GetAttachmentStore(self):
          """Returns the 'AttachmentStore' associated with the database.
  
          returns -- The 'AttachmentStore' containing the attachments
          associated with tests and resources in this database."""
--- 226,280 ----
          # Make sure there is a file by that name.
          if not os.path.isfile(path):
              raise NoSuchSuiteError, "no suite file %s" % path
          # Load and parse the suite file.
          document = qm.xmlutil.load_xml_file(path)
+         # For backwards compatibility, handle XML files using the
+         # "suite" tag.  New databases will have Suite files using the
+         # "extension" tag.
          suite = document.documentElement
!         if suite.tagName == "suite":
!             assert suite.tagName == "suite"
!             # Extract the test and suite IDs.
!             test_ids = qm.xmlutil.get_child_texts(suite, "test_id")
!             suite_ids = qm.xmlutil.get_child_texts(suite, "suite_id")
!             # Make sure they're all valid.
!             for id_ in test_ids + suite_ids:
!                 if not self.IsValidLabel(id_, is_component = 0):
!                     raise RuntimeError, qm.error("invalid id", id=id_)
!             # Construct the suite.
!             return ExplicitSuite({ "is_implicit" : 0,
!                                    "test_ids" : test_ids,
!                                    "suite_ids" : suite_ids },
!                                  self, suite_id)
!         else:
!             # Load the extension.
!             extension_class, arguments = \
!                 qm.extension.parse_dom_element(
!                     suite,
!                     lambda n: get_extension_class(n, "suite", self),
!                     self.GetAttachmentStore())
!             # Construct the actual instance.
!             extras = { extension_class.EXTRA_ID : suite_id,
!                        extension_class.EXTRA_DATABASE : self }
!             return extension_class(arguments, **extras)
! 
! 
!     def WriteExtension(self, id, extension):
! 
!         kind = extension.kind
!         if kind in ("resource", "test"):
!             self.__StoreAttachments(extension)
!         # Figure out what path should be used to store the test.
!         path = self._GetPath(kind, id)
!         # If the file is in a new subdirectory, create it.
!         containing_directory = os.path.dirname(path)
!         if not os.path.isdir(containing_directory):
!             os.makedirs(containing_directory)
!         extension.Write(open(path, "w"))
!         
!                  
      def GetAttachmentStore(self):
          """Returns the 'AttachmentStore' associated with the database.
  
          returns -- The 'AttachmentStore' containing the attachments
          associated with tests and resources in this database."""
Index: qm/test/doc/reference.xml
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/doc/reference.xml,v
retrieving revision 1.35
diff -c -5 -p -r1.35 reference.xml
*** qm/test/doc/reference.xml	20 Nov 2003 02:45:45 -0000	1.35
--- qm/test/doc/reference.xml	3 Jan 2004 04:01:30 -0000
***************
*** 1120,1133 ****
      directories it would search when running tests, including those
      given by the environment variable
      <envar>QMTEST_CLASS_PATH</envar>.</para>
  
      <para>The <replaceable>kind</replaceable> argument tells QMTest
!     what kind of extension class you are registering.  The
!     <replaceable>kind</replaceable> must be one of
!     <literal>test</literal>, <literal>resource</literal>,
!     <literal>target</literal>, or <literal>database</literal>.</para>
  
      <para>The <replaceable>class-name</replaceable> argument gives the
      name of the class in the form
      <classname>module.Class</classname>.  QMTest will look for a file
      whose basename is the module name and whose extension is either
--- 1120,1132 ----
      directories it would search when running tests, including those
      given by the environment variable
      <envar>QMTEST_CLASS_PATH</envar>.</para>
  
      <para>The <replaceable>kind</replaceable> argument tells QMTest
!     what kind of extension class you are registering.  If you invoke 
!     <command&qmtest-cmd; register</command> with no arguments it will
!     provide you with a list of the available extension kinds.</para>
  
      <para>The <replaceable>class-name</replaceable> argument gives the
      name of the class in the form
      <classname>module.Class</classname>.  QMTest will look for a file
      whose basename is the module name and whose extension is either
***************
*** 2372,2389 ****
    <classname>TestDescriptor</classname> indicates the test class, and
    the arguments to that test class.  QMTest uses that information to
    instantiate an instance of the test class itself as
    appropriate.</para>
  
!   <para>The <function>WriteTest</function> is the inverse of
    <function>GetTest</function>.  The test database is responsible for
!   storing the <classname>TestDescriptor</classname> provided to
!   <function>WriteTest</function>.  The name of test can be obtained
!   by calling <function>TestDescriptor.GetId</function>.  When the
!   <function>RemoveTest</function> function is called the database is
!   responsible for removing the test named by the
!   <parameter>test_id</parameter> parameter.</para>
  
    <para>The functions that handle resources are analogous to those
    for tests.  For exmaple, <function>GetResource</function> plays the
    same role for resources as <function>GetTest</function> does for
    tests.</para>
--- 2371,2387 ----
    <classname>TestDescriptor</classname> indicates the test class, and
    the arguments to that test class.  QMTest uses that information to
    instantiate an instance of the test class itself as
    appropriate.</para>
  
!   <para>The <function>Write</function> function is the inverse of
    <function>GetTest</function>.  The test database is responsible for
!   storing the <classname>Test</classname> provided.  The name of test
!   can be obtained by calling <function>GetId</function> on the
!   <classname>Test</classname>.  When the <function>Remove</function>
!   function is called the database is responsible for removing the test
!   named by the <parameter>id</parameter> parameter.</para>
  
    <para>The functions that handle resources are analogous to those
    for tests.  For exmaple, <function>GetResource</function> plays the
    same role for resources as <function>GetTest</function> does for
    tests.</para>
Index: qm/test/web/web.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/web/web.py,v
retrieving revision 1.78
diff -c -5 -p -r1.78 web.py
*** qm/test/web/web.py	29 Sep 2003 07:03:04 -0000	1.78
--- qm/test/web/web.py	3 Jan 2004 04:01:30 -0000
*************** class QMTestServer(qm.web.WebServer):
*** 1693,1703 ****
              # Yes.  Instead of showing the page for editing the suite,
              # redisplay the new suite page with error messages.
              return NewSuitePage(self, suite_id, field_errors)(request)
          else:
              # Everything looks good.  Make an empty suite.
!             suite = Suite(self.__database, suite_id)
              # Show the editing page.
              return ShowSuitePage(self, suite, edit=1, is_new_suite=1)(request)
  
  
      def HandleDeleteItem(self, request):
--- 1693,1709 ----
              # Yes.  Instead of showing the page for editing the suite,
              # redisplay the new suite page with error messages.
              return NewSuitePage(self, suite_id, field_errors)(request)
          else:
              # Everything looks good.  Make an empty suite.
!             suite_class = qm.test.base.get_extension_class(
!                "explicit_suite.ExplicitSuite",
!                "suite",
!                self.GetDatabase())
!             extras = { suite_class.EXTRA_DATABASE : self.GetDatabase(),
!                        suite_class.EXTRA_ID : suite_id }
!             suite = suite_class({}, **extras)
              # Show the editing page.
              return ShowSuitePage(self, suite, edit=1, is_new_suite=1)(request)
  
  
      def HandleDeleteItem(self, request):
*************** class QMTestServer(qm.web.WebServer):
*** 1716,1728 ****
          item_id = request["id"]
          # The script name determines whether we're deleting a test or an
          # resource. 
          script_name = request.GetScriptName()
          if script_name == "delete-test":
!             database.RemoveTest(item_id)
          elif script_name == "delete-resource":
!             database.RemoveResource(item_id)
          else:
              raise RuntimeError, "unrecognized script name"
          # Redirect to the main page.
          request = qm.web.WebRequest("dir", base=request)
          raise qm.web.HttpRedirect, request
--- 1722,1734 ----
          item_id = request["id"]
          # The script name determines whether we're deleting a test or an
          # resource. 
          script_name = request.GetScriptName()
          if script_name == "delete-test":
!             database.RemoveExtension(item_id, database.TEST)
          elif script_name == "delete-resource":
!             database.RemoveExtension(item_id, database.RESOURCE)
          else:
              raise RuntimeError, "unrecognized script name"
          # Redirect to the main page.
          request = qm.web.WebRequest("dir", base=request)
          raise qm.web.HttpRedirect, request
*************** class QMTestServer(qm.web.WebServer):
*** 1737,1747 ****
          request."""
  
          database = self.__database
          # Extract the suite ID.
          suite_id = request["id"]
!         database.RemoveSuite(suite_id)
          # Redirect to the main page.
          raise qm.web.HttpRedirect, qm.web.WebRequest("dir", base=request)
  
  
      def HandleDir(self, request):
--- 1743,1753 ----
          request."""
  
          database = self.__database
          # Extract the suite ID.
          suite_id = request["id"]
!         database.RemoveExtension(suite_id, database.SUITE)
          # Redirect to the main page.
          raise qm.web.HttpRedirect, qm.web.WebRequest("dir", base=request)
  
  
      def HandleDir(self, request):
*************** class QMTestServer(qm.web.WebServer):
*** 2302,2315 ****
  	    request = qm.web.WebRequest("edit-" + type, base=request, 
                                          id=item_id)
  	    return ShowItemPage(self, item, 1, 0, type, field_errors)(request)
  
          # Store it in the database.
!         if type is "test":
!             database.WriteTest(item)
!         elif type is "resource":
!             database.WriteResource(item)
  
          # Remove any attachments located in the temporary store as they
          # have now been copied to the store associated with the
          # database.
          temporary_store = self.__temporary_store
--- 2308,2318 ----
  	    request = qm.web.WebRequest("edit-" + type, base=request, 
                                          id=item_id)
  	    return ShowItemPage(self, item, 1, 0, type, field_errors)(request)
  
          # Store it in the database.
!         database.WriteExtension(item_id, item.GetItem())
  
          # Remove any attachments located in the temporary store as they
          # have now been copied to the store associated with the
          # database.
          temporary_store = self.__temporary_store
*************** class QMTestServer(qm.web.WebServer):
*** 2385,2397 ****
          if string.strip(suite_ids) == "":
              suite_ids = []
          else:
              suite_ids = string.split(suite_ids, ",")
          # Construct a new suite.
!         suite = Suite(self, suite_id, test_ids=test_ids, suite_ids=suite_ids)
          # Store it.
!         database.WriteSuite(suite)
          # Redirect to a page that displays the newly-edited item.
          raise qm.web.HttpRedirect, \
                qm.web.WebRequest("show-suite", base=request, id=suite_id)
  
  
--- 2388,2408 ----
          if string.strip(suite_ids) == "":
              suite_ids = []
          else:
              suite_ids = string.split(suite_ids, ",")
          # Construct a new suite.
!         suite_class = qm.test.base.get_extension_class(
!             "explicit_suite.ExplicitSuite",
!             "suite",
!             self.GetDatabase())
!         extras = { suite_class.EXTRA_DATABASE : self.GetDatabase(),
!                    suite_class.EXTRA_ID : suite_id }
!         suite = suite_class({ "test_ids" : test_ids,
!                               "suite_ids" : suite_ids },
!                             **extras)
          # Store it.
!         database.WriteExtension(suite_id, suite)
          # Redirect to a page that displays the newly-edited item.
          raise qm.web.HttpRedirect, \
                qm.web.WebRequest("show-suite", base=request, id=suite_id)
  
  

From slowrey at nextone.com  Wed Jan  7 21:52:06 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Wed, 07 Jan 2004 16:52:06 -0500
Subject: SSH Password Dialog Box?
Message-ID: <3FFC7F86.2030305@nextone.com>

(By the way, thanks for the tip on using the latest QMTest on both local 
and target systems - it worked.)

The following may seem stupid since QMTest is capable of running tests 
on remote systems, but I have a serious need to work with systems that I 
cannot install QMTest on.  Please humor me for a moment...

I'm seeing an OpenSSH dialog box when running a simple python.ExecTest 
in QMTest and I can't figure out where it's coming from.

I wrote a small Python class that handles ssh connections and is geared 
toward password-free logins.  In other words, if a password is required, 
my implementation raises an exception.  No prompting the user.  I use 
Pexpect to handle the interaction with ssh.

The ssh class works fine.  Unit tests have proven it to be successful in 
a variety of situations, including raising my own ssh.SSHError exception 
if a password prompt is encountered.  To demonstrate, here's a snippet 
from an interactive session that tries to connect to a host that 
requires a password:

 >>> import ssh
 >>> loc = ssh.Location("user","host")
 >>> try:
...     c = ssh.Conn(loc)
... except ssh.SSHError:
...     print "error"
...
error

If I run the exact same script in QMTest as a python.ExecTest, a small 
dialog box pops up asking me the password for "user at host".  Why?  I'm 
raising an exception and catching it in my script!  Is there something 
else going on here?

- oh wait.  Let me guess: there's no pseudo-terminal associated with the 
process, so OpenSSH is talking to KDE or something like that?  I know 
some apps write directly to /dev/tty if they can - is that somehow 
circumventing Pexpect and causing the underlying ssh process to try to 
talk to the window manager?

If that's the case, I can live with it but my ssh class becomes less 
effective when used with QMTest.  Any ideas?  Should I pester the Python 
or SSH people instead?

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040107/77f9f4e3/attachment.html>

From njs at pobox.com  Wed Jan  7 23:49:40 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Wed, 7 Jan 2004 15:49:40 -0800
Subject: [qmtest] SSH Password Dialog Box?
In-Reply-To: <3FFC7F86.2030305@nextone.com>
References: <3FFC7F86.2030305@nextone.com>
Message-ID: <20040107234940.GB30055@njs.dhis.org>

On Wed, Jan 07, 2004 at 04:52:06PM -0500, Scott Lowrey wrote:
>    If I run the exact same script in QMTest as a python.ExecTest, a small
>    dialog box pops up asking me the password for "user at host".  Why?  I'm
>    raising an exception and catching it in my script!  Is there something
>    else going on here?

Are you sure you're raising an exception and catching it?  I would
hazard a guess that something different about your environment is
causing ssh to not even both prompting for a password directly.

>    - oh wait.  Let me guess: there's no pseudo-terminal associated with the
>    process, so OpenSSH is talking to KDE or something like that?  I know some
>    apps write directly to /dev/tty if they can - is that somehow
>    circumventing Pexpect and causing the underlying ssh process to try to
>    talk to the window manager?

ssh(1):

  If ssh needs a passphrase, it will read the passphrase from the
  current terminal if it was run from a terminal.  If ssh does not
  have a terminal associated with it but DISPLAY and SSH_ASKPASS are
  set, it will execute the program specified by SSH_ASKPASS and open
  an X11 window to read the passphrase.

I would hazard a guess that yeah, somehow ssh is not hooked up to a
terminal, and that's triggering the above check.  I have no idea _why_
ssh wouldn't be hooked up to a terminal -- shouldn't pexpect be taking
care of that? -- but that's probably what's going on.  I certainly
don't know what QMTest would be doing to break pexpect.

-- Nathaniel

-- 
Details are all that matters; God dwells there, and you never get to
see Him if you don't struggle to get them right. -- Stephen Jay Gould


From mark at codesourcery.com  Thu Jan  8 01:21:02 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 07 Jan 2004 17:21:02 -0800
Subject: [qmtest] SSH Password Dialog Box?
In-Reply-To: <20040107234940.GB30055@njs.dhis.org>
References: <3FFC7F86.2030305@nextone.com>
	 <20040107234940.GB30055@njs.dhis.org>
Message-ID: <1073524862.4547.53.camel@minax.codesourcery.com>

> I would hazard a guess that yeah, somehow ssh is not hooked up to a
> terminal, and that's triggering the above check.  I have no idea _why_
> ssh wouldn't be hooked up to a terminal -- shouldn't pexpect be taking
> care of that? -- but that's probably what's going on.  I certainly
> don't know what QMTest would be doing to break pexpect.

Like Nathaniel, I would very much expect that pexpect should be creating
a pseudo-terminal for your SSH process to run under.  If not, that's
what should be done.  I don't believe that QMTest does anything with
pseudo-terminals.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From slowrey at nextone.com  Thu Jan  8 03:34:47 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Wed, 07 Jan 2004 22:34:47 -0500
Subject: [qmtest] SSH Password Dialog Box?
In-Reply-To: <1073524862.4547.53.camel@minax.codesourcery.com>
References: <3FFC7F86.2030305@nextone.com>	 <20040107234940.GB30055@njs.dhis.org> <1073524862.4547.53.camel@minax.codesourcery.com>
Message-ID: <3FFCCFD7.4000902@nextone.com>



Mark Mitchell wrote:

>>I would hazard a guess that yeah, somehow ssh is not hooked up to a
>>terminal, and that's triggering the above check.  I have no idea _why_
>>ssh wouldn't be hooked up to a terminal -- shouldn't pexpect be taking
>>care of that? -- but that's probably what's going on.  I certainly
>>don't know what QMTest would be doing to break pexpect.
>>    
>>
>
>Like Nathaniel, I would very much expect that pexpect should be creating
>a pseudo-terminal for your SSH process to run under.  If not, that's
>what should be done.  I don't believe that QMTest does anything with
>pseudo-terminals.
>
>  
>
Right.  And I think Nathaniel identified the problem.  A colleague 
suggested that ssh-agent might have something to do with it but I don't 
typically run the agent so that wasn't it.  The DISPLAY and SSH_ASKPASS 
environment variables are set, though, so it all adds up.

Regardless of all that, Pexpect should be starting ssh in pty-friendly 
way.  I'll check it out when I get the chance but for now since it's not 
a show-stopper.  If the SSH public keys (or the agent) are set up 
properly then I'm good to go.  Thanks for the pointers.



From slowrey at nextone.com  Thu Jan  8 15:57:09 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Thu, 08 Jan 2004 10:57:09 -0500
Subject: Doc Build Error
Message-ID: <3FFD7DD5.9040309@nextone.com>

Building the latest QMTest from CVS, I'm getting a jade error while 
compiling the documentation.  The only thing I know about Jade is that 
exists on my system.  Any pointers?

[slowrey at moondog qm]$ ./configure --prefix=/opt/test 
--with-python=/opt/test/bin/python --enable-maintainer-mode
checking for /opt/test/bin/python... yes
checking Python version... 2.3
checking Python platform... linux-i686
checking for happydoc... /usr/bin/happydoc
configure: creating ./config.status
config.status: creating GNUmakefile
[slowrey at moondog qm]$ make
PYTHONPATH=. /opt/test/bin/python -O ./setup.py build
running build
running build_py
creating build
creating build/lib
creating build/lib/qm
copying qm/__init__.py -> build/lib/qm
copying qm/__version.py -> build/lib/qm
copying qm/attachment.py -> build/lib/qm
copying qm/cmdline.py -> build/lib/qm
copying qm/common.py -> build/lib/qm
copying qm/db.py -> build/lib/qm
copying qm/diagnostic.py -> build/lib/qm
copying qm/executable.py -> build/lib/qm
copying qm/extension.py -> build/lib/qm
copying qm/fields.py -> build/lib/qm
copying qm/label.py -> build/lib/qm
copying qm/lock.py -> build/lib/qm
copying qm/platform.py -> build/lib/qm
copying qm/platform_unix.py -> build/lib/qm
copying qm/platform_win32.py -> build/lib/qm
copying qm/queue.py -> build/lib/qm
copying qm/setup.py -> build/lib/qm
copying qm/structured_text.py -> build/lib/qm
copying qm/temporary_directory.py -> build/lib/qm
copying qm/trace.py -> build/lib/qm
copying qm/user.py -> build/lib/qm
copying qm/web.py -> build/lib/qm
copying qm/xmlutil.py -> build/lib/qm
creating build/lib/qm/external
copying qm/external/__init__.py -> build/lib/qm/external
creating build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_HTML.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_If.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_In.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_InSV.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_Let.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_Raise.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_Return.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_String.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_Try.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_UI.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_Util.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_Var.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DT_With.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DTtest.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DTtestExpr.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DTtest_basicIn.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/DocumentTemplate.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/VSEval.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/__init__.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/gparse.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/gparse_test.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/pDocumentTemplate.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/setup.py -> 
build/lib/qm/external/DocumentTemplate
copying qm/external/DocumentTemplate/ts_regex.py -> 
build/lib/qm/external/DocumentTemplate
creating build/lib/qm/test
copying qm/test/__init__.py -> build/lib/qm/test
copying qm/test/base.py -> build/lib/qm/test
copying qm/test/cmdline.py -> build/lib/qm/test
copying qm/test/command_thread.py -> build/lib/qm/test
copying qm/test/context.py -> build/lib/qm/test
copying qm/test/database.py -> build/lib/qm/test
copying qm/test/directory_suite.py -> build/lib/qm/test
copying qm/test/execution_engine.py -> build/lib/qm/test
copying qm/test/execution_thread.py -> build/lib/qm/test
copying qm/test/file_database.py -> build/lib/qm/test
copying qm/test/file_result_reader.py -> build/lib/qm/test
copying qm/test/file_result_stream.py -> build/lib/qm/test
copying qm/test/resource.py -> build/lib/qm/test
copying qm/test/result.py -> build/lib/qm/test
copying qm/test/result_reader.py -> build/lib/qm/test
copying qm/test/result_stream.py -> build/lib/qm/test
copying qm/test/runnable.py -> build/lib/qm/test
copying qm/test/suite.py -> build/lib/qm/test
copying qm/test/target.py -> build/lib/qm/test
copying qm/test/test.py -> build/lib/qm/test
creating build/lib/qm/test/classes
copying qm/test/classes/__init__.py -> build/lib/qm/test/classes
copying qm/test/classes/command.py -> build/lib/qm/test/classes
copying qm/test/classes/dejagnu_base.py -> build/lib/qm/test/classes
copying qm/test/classes/dejagnu_stream.py -> build/lib/qm/test/classes
copying qm/test/classes/dejagnu_test.py -> build/lib/qm/test/classes
copying qm/test/classes/dg_test.py -> build/lib/qm/test/classes
copying qm/test/classes/file.py -> build/lib/qm/test/classes
copying qm/test/classes/file_label.py -> build/lib/qm/test/classes
copying qm/test/classes/mount_database.py -> build/lib/qm/test/classes
copying qm/test/classes/pickle_result_stream.py -> build/lib/qm/test/classes
copying qm/test/classes/process_target.py -> build/lib/qm/test/classes
copying qm/test/classes/python.py -> build/lib/qm/test/classes
copying qm/test/classes/python_label.py -> build/lib/qm/test/classes
copying qm/test/classes/rsh_target.py -> build/lib/qm/test/classes
copying qm/test/classes/serial_target.py -> build/lib/qm/test/classes
copying qm/test/classes/sql_result_stream.py -> build/lib/qm/test/classes
copying qm/test/classes/temporary.py -> build/lib/qm/test/classes
copying qm/test/classes/text_result_stream.py -> build/lib/qm/test/classes
copying qm/test/classes/thread_target.py -> build/lib/qm/test/classes
copying qm/test/classes/xml_database.py -> build/lib/qm/test/classes
copying qm/test/classes/xml_result_stream.py -> build/lib/qm/test/classes
copying qm/test/classes/explicit_suite.py -> build/lib/qm/test/classes
creating build/lib/qm/test/web
copying qm/test/web/__init__.py -> build/lib/qm/test/web
copying qm/test/web/web.py -> build/lib/qm/test/web
running build_scripts
creating build/scripts-2.3
copying and adjusting qm/test/qmtest -> build/scripts-2.3
changing mode of build/scripts-2.3/qmtest from 664 to 775
copying qm/test/classes/classes.qmc -> build/lib/qm/test/classes
PYTHONPATH=. /opt/test/bin/python -O ./setup.py build_doc
running build_doc
creating /home/slowrey/pkg/build/qm/qm/test/doc/html
/usr/bin/jade -D/usr/share/sgml/docbook 
-D/usr/share/sgml/docbook/dsssl-stylesheets -t sgml -d 
/home/slowrey/pkg/build/qm/doc/qm-sgml.dsl 
/usr/share/doc/openjade-1.3.1/pubtext/xml.dcl 
/home/slowrey/pkg/build/qm/qm/test/doc/manual.xml
/usr/bin/jade:/home/slowrey/pkg/build/qm/qm/test/doc/reference.xml:1126:12:E: 
character "&" not allowed in attribute specification list
error: command '/usr/bin/jade' failed with exit status 1
make: *** [doc] Error 1

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040108/140a30e9/attachment.html>

From slowrey at nextone.com  Thu Jan  8 17:06:57 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Thu, 08 Jan 2004 12:06:57 -0500
Subject: BUG? create-tdb overwrites existing database
Message-ID: <3FFD8E31.9080204@nextone.com>

I'm wondering if the 'qmtest create-tdb' command should prompt before 
creating a database where one lives already.  Although the existing 
database hierarchy is not afftected, the QMTest/configuration file is 
overwritten.  Wouldn't this be potentially damaging?

I mistakenly executed create-tdb in a fresh directory, forgetting that 
QMTEST_DB_PATH was defined to point to a working database.  The command 
worked without complaint and the modification time of 
QMTest/configuration changed.

A simple check would suffice: if there is a QMTest directory in the 
target location (working directory or QMTEST_DB_PATH), then ask for 
confirmation before proceeding.

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040108/e790e6ac/attachment.html>

From slowrey at nextone.com  Thu Jan  8 17:32:05 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Thu, 08 Jan 2004 12:32:05 -0500
Subject: BUG? error retrieving argument of user-defined exception
Message-ID: <3FFD9415.7000803@nextone.com>

(Sorry if this is an inappropriate format but I want people to be able 
to just plug the test into their database and run it.)

The following exception test - using a builtin exception - works fine:

<?xml version="1.0"?>
<extension class="python.ExceptionTest" kind="test">
  <argument name="exception_class">
    <text>AssertionError</text>
  </argument>
  <argument name="exception_argument">
    <text>'this is the arg'</text>
  </argument>
  <argument name="source">
    <text>raise AssertionError('this is the arg')
</text>
  </argument>
  <argument name="prerequisites">
    <set/>
  </argument>
  <argument name="target_group">
    <text>.*</text>
  </argument>
  <argument name="resources">
    <set/>
  </argument>
</extension>

This one - using a user-defined exception - fails to find the exception 
value:

<?xml version="1.0"?>
<extension class="python.ExceptionTest" kind="test">
  <argument name="exception_class">
    <text>MyExc</text>
  </argument>
  <argument name="exception_argument">
    <text>'this is the arg'</text>
  </argument>
  <argument name="source">
    <text>class MyExc(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

raise MyExc('this is the arg')
</text>
  </argument>
  <argument name="prerequisites">
    <set/>
  </argument>
  <argument name="target_group">
    <text>.*</text>
  </argument>
  <argument name="resources">
    <set/>
  </argument>
</extension>

The error from QMTest is:

[slowrey at moondog tmp]$ qmtest run myexc.exc1
--- TEST RESULTS 
-------------------------------------------------------------

  myexc.exc1                                    : ERROR
    An exception occurred.

    qmtest.exception:
      exceptions.AttributeError: MyExc instance has no attribute 'args'

    qmtest.target:
      local

    qmtest.traceback:

        File "/opt/test/lib/qm/test/target.py", line 215, in RunTest
          descriptor.Run(context, result)

        File "/opt/test/lib/qm/test/database.py", line 246, in Run
          self._Execute(context, result, "Run")

        File "/opt/test/lib/qm/test/database.py", line 168, in _Execute
          eval("item.%s(context, result)" % method)

        File "", line 0, in ?

        File "/opt/test/lib/qm/test/classes/python.py", line 164, in Run
          self.CheckArgument(exc_info, result)

        File "/opt/test/lib/qm/test/classes/python.py", line 245, in 
CheckArgument
          argument = exc_info[1].args



-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>


From slowrey at nextone.com  Fri Jan  9 02:22:13 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Thu, 08 Jan 2004 21:22:13 -0500
Subject: FIXED: [qmtest] Doc Build Error
In-Reply-To: <3FFD7DD5.9040309@nextone.com>
References: <3FFD7DD5.9040309@nextone.com>
Message-ID: <3FFE1055.1060603@nextone.com>

Scott Lowrey wrote:

> Building the latest QMTest from CVS, I'm getting a jade error while 
> compiling the documentation.  The only thing I know about Jade is that 
> exists on my system.  Any pointers?

I should have looked closer at this before posting.  The offending line 
1126 in qm/test/doc/reference.xml,

 <command&qmtest-cmd; register</command> with no arguments it will [...]

can be fixed by replacing the first ampersand with a closing angle 
bracket.  After doing this, make continues on.

-Scott



From seefeld at sympatico.ca  Fri Jan  9 06:20:02 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Fri, 09 Jan 2004 01:20:02 -0500
Subject: [qmtest] FIXED: [qmtest] Doc Build Error
In-Reply-To: <3FFE1055.1060603@nextone.com>
References: <3FFD7DD5.9040309@nextone.com> <3FFE1055.1060603@nextone.com>
Message-ID: <3FFE4812.70008@sympatico.ca>

Scott Lowrey wrote:

> I should have looked closer at this before posting.  The offending line 
> 1126 in qm/test/doc/reference.xml,
> 
> <command&qmtest-cmd; register</command> with no arguments it will [...]
> 
> can be fixed by replacing the first ampersand with a closing angle 
> bracket.  After doing this, make continues on.



hmm, I think '&qmtest-cmd;' should be left intact, as it refers to
a defined entity. You are right in that a '>' is missing though.

Regards,
		Stefan




From mark at codesourcery.com  Fri Jan  9 07:43:46 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 08 Jan 2004 23:43:46 -0800
Subject: [qmtest] FIXED: [qmtest] Doc Build Error
In-Reply-To: <3FFE4812.70008@sympatico.ca>
References: <3FFD7DD5.9040309@nextone.com> <3FFE1055.1060603@nextone.com>
	 <3FFE4812.70008@sympatico.ca>
Message-ID: <1073634225.3712.15.camel@minax.codesourcery.com>

On Thu, 2004-01-08 at 22:20, Stefan Seefeld wrote:
> Scott Lowrey wrote:
> 
> > I should have looked closer at this before posting.  The offending line 
> > 1126 in qm/test/doc/reference.xml,
> > 
> > <command&qmtest-cmd; register</command> with no arguments it will [...]
> > 
> > can be fixed by replacing the first ampersand with a closing angle 
> > bracket.  After doing this, make continues on.
> 
> 
> 
> hmm, I think '&qmtest-cmd;' should be left intact, as it refers to
> a defined entity. You are right in that a '>' is missing though.

Indeed.

I checked in the attached patch.

Thanks to both you and Scott.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC
-------------- next part --------------
2004-01-08  Mark Mitchell  <mark at codesourcery.com>

	* qm/test/doc/reference.xml: Fix typo.

Index: qm/test/doc/reference.xml
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/doc/reference.xml,v
retrieving revision 1.36
diff -c -5 -p -r1.36 reference.xml
*** qm/test/doc/reference.xml	3 Jan 2004 04:02:59 -0000	1.36
--- qm/test/doc/reference.xml	9 Jan 2004 07:40:48 -0000
***************
*** 1121,1131 ****
      given by the environment variable
      <envar>QMTEST_CLASS_PATH</envar>.</para>
  
      <para>The <replaceable>kind</replaceable> argument tells QMTest
      what kind of extension class you are registering.  If you invoke 
!     <command&qmtest-cmd; register</command> with no arguments it will
      provide you with a list of the available extension kinds.</para>
  
      <para>The <replaceable>class-name</replaceable> argument gives the
      name of the class in the form
      <classname>module.Class</classname>.  QMTest will look for a file
--- 1121,1131 ----
      given by the environment variable
      <envar>QMTEST_CLASS_PATH</envar>.</para>
  
      <para>The <replaceable>kind</replaceable> argument tells QMTest
      what kind of extension class you are registering.  If you invoke 
!     <command>&qmtest-cmd; register</command> with no arguments it will
      provide you with a list of the available extension kinds.</para>
  
      <para>The <replaceable>class-name</replaceable> argument gives the
      name of the class in the form
      <classname>module.Class</classname>.  QMTest will look for a file

From slowrey at nextone.com  Fri Jan  9 15:13:22 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Fri, 09 Jan 2004 10:13:22 -0500
Subject: Jade
Message-ID: <3FFEC512.80301@nextone.com>


Although I was able to get the QMTest docs to build at home (albeit with 
a zillion warnings and messages about files being skipped because of 
their MIME types), my Red Hat 9 system at work is choking because it 
can't find Jade.  In pursuing that, I find that Jim Clark's Jade (if 
that's the correct one) is old and doesn't even compile.  I sent a bug 
report to the email listed at the web site. 

As a litmus test, I searched for jade at rpmfind.net.  There is no 
package for anything past Red Hat 6.2, so I'm wondering if I'm barking 
up the wrong tree here.  Has jade been absorbed into some other package?

More to the point, why didn't autoconf set things up so that 
documentation tasks that rely on Jade are skipped if Jade isn't there? 

Thanks and sorry for all the noise.

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040109/c0dcd061/attachment.html>

From mark at codesourcery.com  Fri Jan  9 19:43:19 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 09 Jan 2004 11:43:19 -0800
Subject: [qmtest] BUG? error retrieving argument of user-defined
	exception
In-Reply-To: <3FFD9415.7000803@nextone.com>
References: <3FFD9415.7000803@nextone.com>
Message-ID: <1073677399.3497.15.camel@minax.codesourcery.com>

On Thu, 2004-01-08 at 09:32, Scott Lowrey wrote:
> (Sorry if this is an inappropriate format but I want people to be able 
> to just plug the test into their database and run it.)

That's great, actually.

Yes, that's a bug.  We're working on a fix.

Thanks,

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From slowrey at nextone.com  Fri Jan  9 22:02:48 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Fri, 09 Jan 2004 17:02:48 -0500
Subject: BUG: cancel during test creation causes error
Message-ID: <3FFF2508.1000307@nextone.com>

I think this is a bug.  Pretty minor and probably too obscure to give 
much priority to. 


Follow this recipe and see if you get the same results.

(Version = latest CVS)

1. With no particular database, run qmtest gui
2. Create a new test, any name.  I used "blarg" in this example.
3. Select class command.ExecTest
3. Click OK
4. Enter anything for program name
5. Click "Add Another" button in Resources section
6. Click Cancel

I would expect to be sent back to the main screen.  Instead:


*Exception type:* qm.test.database.NoSuchTestError

*Exception value:* There is no test with the ID "blarg".

*Stack trace:*

  File "/opt/test/lib/qm/web.py", line 476, in __HandleScriptRequest
    script_output = self.server.ProcessScript(request)

  File "/opt/test/lib/qm/web.py", line 815, in ProcessScript
    return self.__scripts[request.GetUrl()](request)

  File "/opt/test/lib/qm/test/web/web.py", line 2064, in HandleShowItem
    item = database.GetTest(item_id)

  File "/opt/test/lib/qm/test/file_database.py", line 56, in GetTest
    raise NoSuchTestError, test_id

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040109/a5d09ea1/attachment.html>

From seefeld at sympatico.ca  Mon Jan 12 15:02:21 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Mon, 12 Jan 2004 10:02:21 -0500
Subject: [qmtest] writing composite tests
References: <df0ae448092121a7ae641e1d8a644d1d3f5cb214@Orthosoft.ca> <1063042113.24169.10.camel@doubledemon.codesourcery.com>
Message-ID: <9fc08065334b7dd35c8f3af449e782774002b4ed@Orthosoft.ca>

Hi Mark,

given that I have no idea what your plans are for the next release,
which new features to expect etc., may I come back to an old
thread here...

Mark Mitchell wrote:

> On Mon, 2003-09-08 at 09:54, Stefan Seefeld wrote:

>>I have a couple of tests that consist of various steps
>>such as compiling, linking, executing, result (output)
>>analysis.
>>
>>Each of these steps may be considered a test in itself,
>>depending on the earlier steps. As such, I would model
>>the situation as a 'composite test'.
> 
> 
> We've actually got some pretty nice test/database classes for
> compiling/linking/executing programs.  We should probably get those into
> QMTest proper, but we've never had the time to check over the interfaces
> as much as we'd like, and I'd like to avoid changing them after they go
> into QMTest.
> 
> You can get them out of the "qtmc" module in the same repository as
> QMTest.

I believe having such classes would be a huge win in usability, if only
due to the self-documentation that would add (people could see how to
set up their own code that does similar things).

How much work would you expect such a merge to be ? What ramifications
would that have for existing qmtest users ?

And again, I believe a set of example test databases / test classes
that demonstrate all this functionality would greatly help to make
people proficient with qmtest.

I'd volunteer to work on the integration (with a little guidance from
you). Please let me know whether you are interested, and what timeframe
you have in mind (pre- or post- 2.1 release ?).

Kind regards,
		Stefan



From mark at codesourcery.com  Mon Jan 12 21:42:04 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 12 Jan 2004 13:42:04 -0800
Subject: [qmtest] Jade
In-Reply-To: <3FFEC512.80301@nextone.com>
References: <3FFEC512.80301@nextone.com>
Message-ID: <1073943724.3458.95.camel@minax.codesourcery.com>

On Fri, 2004-01-09 at 07:13, Scott Lowrey wrote:
> Although I was able to get the QMTest docs to build at home (albeit
> with a zillion warnings and messages about files being skipped because
> of their MIME types), my Red Hat 9 system at work is choking because
> it can't find Jade.  In pursuing that, I find that Jim Clark's Jade
> (if that's the correct one) is old and doesn't even compile.  I sent a
> bug report to the email listed at the web site.  

Red Hat provided an "openjade" RPM for Red Hat 8, and I believe, Red Hat
9.  That is what we use.

Thanks,

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From slowrey at nextone.com  Mon Jan 12 21:48:16 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Mon, 12 Jan 2004 16:48:16 -0500
Subject: Annotating Expectations?
Message-ID: <40031620.3020807@nextone.com>

Wondering if anybody would be interested in annotated expectations.  The 
way I see it working is that a text box would be added to the "Set 
Expectation" dialog box.  The text would be saved in the expectations 
file (?).  This would allow the user to comment on the reason for the 
expected outcome.

I'd use this, say, to enter some background on why one of my tests is 
expected to have an "Error" outcome.  The test is broken but I can't fix 
it right now and I'd like to comment on the reason for the breakage.   
Later (weeks/months/years), I can run the tests, load the expectations, 
see that everything is normal, and then click on the broken test's 
expectation to find out what the heck I was thinking when I decided an 
Error was OK.

Thoughts?

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040112/06d5d1f9/attachment.html>

From mark at codesourcery.com  Mon Jan 12 21:56:58 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 12 Jan 2004 13:56:58 -0800
Subject: [qmtest] Annotating Expectations?
In-Reply-To: <40031620.3020807@nextone.com>
References: <40031620.3020807@nextone.com>
Message-ID: <1073944618.3458.100.camel@minax.codesourcery.com>

On Mon, 2004-01-12 at 13:48, Scott Lowrey wrote:
> Wondering if anybody would be interested in annotated expectations. 
> The way I see it working is that a text box would be added to the "Set
> Expectation" dialog box.  The text would be saved in the expectations
> file (?).  This would allow the user to comment on the reason for the
> expected outcome. 

I think that's a nice idea.

Note that the format for expectations and results is identical.

So, one way to implement the storage side of this would be to use a
special result annotation, which would never be generated by running a
test, of course.

You'd need to enhance the GUI to show that information, of course.

We'll not implement this ourselves, but if there were a patch to do it,
I'd happily review it.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From mark at codesourcery.com  Mon Jan 12 21:59:46 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 12 Jan 2004 13:59:46 -0800
Subject: [qmtest] BUG? error retrieving argument of user-defined
	exception
In-Reply-To: <3FFD9415.7000803@nextone.com>
References: <3FFD9415.7000803@nextone.com>
Message-ID: <1073944786.3458.103.camel@minax.codesourcery.com>

On Thu, 2004-01-08 at 09:32, Scott Lowrey wrote:
> (Sorry if this is an inappropriate format but I want people to be able 
> to just plug the test into their database and run it.)

This patch fixes that problem.

The root of the problem is that MyExc doesn't honor the ".args"
interface provided by the Exception base class.  This patch makes QMTest
notice that fact and issue a sensible FAIL message, rather than the
ERROR message emitted before.

Patch applied.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From mark at codesourcery.com  Mon Jan 12 22:27:30 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 12 Jan 2004 14:27:30 -0800
Subject: [qmtest] BUG: cancel during test creation causes error
In-Reply-To: <3FFF2508.1000307@nextone.com>
References: <3FFF2508.1000307@nextone.com>
Message-ID: <1073946450.3458.106.camel@minax.codesourcery.com>

On Fri, 2004-01-09 at 14:02, Scott Lowrey wrote:
> I think this is a bug.  Pretty minor and probably too obscure to give
> much priority to.  
> 

But easily fixed with the following patch.

Applied.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC
-------------- next part --------------
2004-01-12  Mark Mitchell  <mark at codesourcery.com>

	* qm/test/share/dtml/show.dtml: Add is_new field to form.
	* qm/test/web/web.py (QMTestServer.HandleShowItem): Pass a correct
	value for "new" to ShowItemPage.

Index: qm/test/share/dtml/show.dtml
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/share/dtml/show.dtml,v
retrieving revision 1.5
diff -c -5 -p -r1.5 show.dtml
*** qm/test/share/dtml/show.dtml	30 Jul 2003 21:25:31 -0000	1.5
--- qm/test/share/dtml/show.dtml	12 Jan 2004 22:23:52 -0000
***************
*** 66,75 ****
--- 66,78 ----
            name="class"
            value="<dtml-var expr="item.GetClassName()">" />
     <input type="hidden" 
            name="id"
            value="<dtml-var expr="item.GetId()">" />
+    <input type="hidden"
+           name="is_new"
+           value="<dtml-var new>" />
    </dtml-if>
  
    <table border="0"
           cellpadding="4"
           cellspacing="4"
Index: qm/test/web/web.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/web/web.py,v
retrieving revision 1.79
diff -c -5 -p -r1.79 web.py
*** qm/test/web/web.py	3 Jan 2004 04:02:59 -0000	1.79
--- qm/test/web/web.py	12 Jan 2004 22:23:52 -0000
*************** class QMTestServer(qm.web.WebServer):
*** 2041,2051 ****
                                     item_id=item_id,
                                     class_name=class_name,
                                     field_errors=field_errors)
                  return page(request)
  
!             # Construct an test with default argument values, as the
              # starting point for editing.
              if type is "resource":
                  item = self.MakeNewResource(class_name, item_id)
              elif type is "test":
                  item = self.MakeNewTest(class_name, item_id)
--- 2041,2051 ----
                                     item_id=item_id,
                                     class_name=class_name,
                                     field_errors=field_errors)
                  return page(request)
  
!             # Construct a test with default argument values, as the
              # starting point for editing.
              if type is "resource":
                  item = self.MakeNewResource(class_name, item_id)
              elif type is "test":
                  item = self.MakeNewTest(class_name, item_id)
*************** class QMTestServer(qm.web.WebServer):
*** 2255,2264 ****
--- 2255,2268 ----
          except KeyError:
              message = qm.error("no id for submit")
              return qm.web.generate_error_page(request, message)
  
          database = self.__database
+         # Learn whether or not this is a new item.
+         is_new = int(request["is_new"])
+         import sys
+         print >> sys.stderr, is_new
          # Extract the class and field specification.
          item_class_name = request["class"]
          item_class = qm.test.base.get_extension_class(item_class_name,
                                                        type,
                                                        self.GetDatabase())
*************** class QMTestServer(qm.web.WebServer):
*** 2305,2315 ****
  
          # If necessary, redisplay the form.
          if redisplay:
  	    request = qm.web.WebRequest("edit-" + type, base=request, 
                                          id=item_id)
! 	    return ShowItemPage(self, item, 1, 0, type, field_errors)(request)
  
          # Store it in the database.
          database.WriteExtension(item_id, item.GetItem())
  
          # Remove any attachments located in the temporary store as they
--- 2309,2320 ----
  
          # If necessary, redisplay the form.
          if redisplay:
  	    request = qm.web.WebRequest("edit-" + type, base=request, 
                                          id=item_id)
! 	    return ShowItemPage(self, item, 1, is_new, type,
!                                 field_errors)(request)
  
          # Store it in the database.
          database.WriteExtension(item_id, item.GetItem())
  
          # Remove any attachments located in the temporary store as they

From slowrey at nextone.com  Mon Jan 12 22:30:17 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Mon, 12 Jan 2004 17:30:17 -0500
Subject: [qmtest] Annotating Expectations?
In-Reply-To: <1073944618.3458.100.camel@minax.codesourcery.com>
References: <40031620.3020807@nextone.com> <1073944618.3458.100.camel@minax.codesourcery.com>
Message-ID: <40031FF9.1040806@nextone.com>

Mark Mitchell wrote:

>On Mon, 2004-01-12 at 13:48, Scott Lowrey wrote:
>  
>
>>Wondering if anybody would be interested in annotated expectations. 
>>The way I see it working is that a text box would be added to the "Set
>>Expectation" dialog box.  The text would be saved in the expectations
>>file (?).  This would allow the user to comment on the reason for the
>>expected outcome. 
>>    
>>
>
>I think that's a nice idea.
>
>Note that the format for expectations and results is identical.
>
>  
>
Great, I'll take a crack at it.

As an aside, I was trying to grasp the difference between "Save/Load 
Expectations" and "Save/Load Results".  It's a bit confusing.  Since the 
file formats are the same, do the two concepts exist simply for semantic 
reasons?  I suppose I could save twelve result sets for twelve different 
runs and then have one expectations file that contains the desired 
result set.... but I could use either operation to do so, right?

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040112/0ce13db0/attachment.html>

From mark at codesourcery.com  Mon Jan 12 22:30:31 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 12 Jan 2004 14:30:31 -0800
Subject: [qmtest] writing composite tests
In-Reply-To: <9fc08065334b7dd35c8f3af449e782774002b4ed@Orthosoft.ca>
References: <df0ae448092121a7ae641e1d8a644d1d3f5cb214@Orthosoft.ca>
	 <1063042113.24169.10.camel@doubledemon.codesourcery.com>
	 <9fc08065334b7dd35c8f3af449e782774002b4ed@Orthosoft.ca>
Message-ID: <1073946631.3458.109.camel@minax.codesourcery.com>


> I believe having such classes would be a huge win in usability, if only
> due to the self-documentation that would add (people could see how to
> set up their own code that does similar things).
> 
> How much work would you expect such a merge to be ? What ramifications
> would that have for existing qmtest users ?

I don't think it would be a whole lot of work; it's just that we would
have to audit those classes and write better documentation.

> I'd volunteer to work on the integration (with a little guidance from
> you). Please let me know whether you are interested, and what timeframe
> you have in mind (pre- or post- 2.1 release ?).

I think post-2.1 release.

I hope to get a beta release of 2.1 out in the next couple of days, with
accumulated fixes to date.  The biggest one outstanding is the problem
with attachments that Vladimir posted, and I'm not sure how easy it will
be to fix that one.

Thanks,

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From mark at codesourcery.com  Mon Jan 12 22:33:26 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 12 Jan 2004 14:33:26 -0800
Subject: [qmtest] Annotating Expectations?
In-Reply-To: <40031FF9.1040806@nextone.com>
References: <40031620.3020807@nextone.com>
	 <1073944618.3458.100.camel@minax.codesourcery.com>
	 <40031FF9.1040806@nextone.com>
Message-ID: <1073946806.3458.113.camel@minax.codesourcery.com>


> As an aside, I was trying to grasp the difference between "Save/Load
> Expectations" and "Save/Load Results".  It's a bit confusing.  Since
> the file formats are the same, do the two concepts exist simply for
> semantic reasons?  

Loading results is different from loading expectations; QMTest has to
know for what purpose you want to use the data.

On the saving side, the GUI will only save the expectations you have
explicitly created when you choose "Save Expectations"; when you save
results its saves the results obtained from running the tests.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From mark at codesourcery.com  Mon Jan 12 22:35:35 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 12 Jan 2004 14:35:35 -0800
Subject: [qmtest] BUG? create-tdb overwrites existing database
In-Reply-To: <3FFD8E31.9080204@nextone.com>
References: <3FFD8E31.9080204@nextone.com>
Message-ID: <1073946935.3458.116.camel@minax.codesourcery.com>

On Thu, 2004-01-08 at 09:06, Scott Lowrey wrote:
> I'm wondering if the 'qmtest create-tdb' command should prompt before
> creating a database where one lives already.  Although the existing
> database hierarchy is not afftected, the QMTest/configuration file is
> overwritten.  Wouldn't this be potentially damaging?

Yes -- but it's also the mechanism for updating an existing database.

The command-line version of QMTest never prompts for anything, although
maybe it should.  Clearly, it should do that only when the standard
input is a TTY, and I don't know how to figure that out under Windows. 
Does anybody here know that, by chance?

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From seefeld at sympatico.ca  Mon Jan 12 22:36:14 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Mon, 12 Jan 2004 17:36:14 -0500
Subject: [qmtest] Annotating Expectations?
References: <40031620.3020807@nextone.com> <1073944618.3458.100.camel@minax.codesourcery.com> <40031FF9.1040806@nextone.com>
Message-ID: <ddbda706ffda17ca8e70c2f043a4fc2540031f54@Orthosoft.ca>

Scott Lowrey wrote:

> As an aside, I was trying to grasp the difference between "Save/Load 
> Expectations" and "Save/Load Results".  It's a bit confusing.  Since the 
> file formats are the same, do the two concepts exist simply for semantic 
> reasons?  I suppose I could save twelve result sets for twelve different 
> runs and then have one expectations file that contains the desired 
> result set.... but I could use either operation to do so, right?

I believe the idea is really that you create a 'result' once, make sure
that it is what you expect, then persist it for the next runs as the
'expectation'. That makes it simple to compare actual results against
your expectations...

Regards,
		Stefan



From seefeld at sympatico.ca  Mon Jan 12 22:41:16 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Mon, 12 Jan 2004 17:41:16 -0500
Subject: [qmtest] writing composite tests
References: <df0ae448092121a7ae641e1d8a644d1d3f5cb214@Orthosoft.ca>	 <1063042113.24169.10.camel@doubledemon.codesourcery.com>	 <9fc08065334b7dd35c8f3af449e782774002b4ed@Orthosoft.ca> <1073946631.3458.109.camel@minax.codesourcery.com>
Message-ID: <03c5c8cb318f731c9da3739d71cbed7940032083@Orthosoft.ca>

Mark Mitchell wrote:
>>I believe having such classes would be a huge win in usability, if only
>>due to the self-documentation that would add (people could see how to
>>set up their own code that does similar things).
>>
>>How much work would you expect such a merge to be ? What ramifications
>>would that have for existing qmtest users ?
> 
> 
> I don't think it would be a whole lot of work; it's just that we would
> have to audit those classes and write better documentation.

ok, sounds like a plan. Please let me know when you are ready for such
a task. I'd be very interested in working on this stuff (and generally
the API side of things, refactoring, cleanup, documentation :-)

Kind regards,
		Stefan




From mark at codesourcery.com  Tue Jan 13 00:02:11 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 12 Jan 2004 16:02:11 -0800
Subject: [qmtest] bug in file_database.FileDatabase
In-Reply-To: <3FEF2B18.9090002@sympatico.ca>
References: <14c89b584e950e889421345cfdbad6333fc7af16@Orthosoft.ca>
	 <3FEF2B18.9090002@sympatico.ca>
Message-ID: <1073952131.3458.173.camel@minax.codesourcery.com>

On Sun, 2003-12-28 at 11:12, Stefan Seefeld wrote:
> Hi there,
> 
> could somebody please review the patch attached to the original mail ?

That patch is OK.  Please apply it!

The reason for labels is that it is reasonable to map tests into storage
domains other than the file system, like, say, a relational database. 
Those domains may have different rules about how you spell paths and
such than the UNIX file system.

Nathaniel and Zack and I talked about this a lot this past summer, and
couldn't really come up with a cleaner model.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From seefeld at sympatico.ca  Tue Jan 13 05:21:04 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Tue, 13 Jan 2004 00:21:04 -0500
Subject: [qmtest] bug in file_database.FileDatabase
In-Reply-To: <1073952131.3458.173.camel@minax.codesourcery.com>
References: <14c89b584e950e889421345cfdbad6333fc7af16@Orthosoft.ca>	 <3FEF2B18.9090002@sympatico.ca> <1073952131.3458.173.camel@minax.codesourcery.com>
Message-ID: <40038040.3070709@sympatico.ca>

Mark Mitchell wrote:

> The reason for labels is that it is reasonable to map tests into storage
> domains other than the file system, like, say, a relational database. 
> Those domains may have different rules about how you spell paths and
> such than the UNIX file system.

I agree about the differing needs. But why should qmtest care about them ?
If some users have to bind qmtest to tools with incompatible requirements
as to test naming conventions, they can always use a little adapter.
But is that a reason to add another abstraction (with the implied complexity)
*into* qmtest ?

> Nathaniel and Zack and I talked about this a lot this past summer, and
> couldn't really come up with a cleaner model.

Ok, no need to reopen this thread then. Still it would be good to have
the rationales documented somewhere so people can look them up before
making enhancement requests :-)

Kind regards,
		Stefan



From Anders.Hasselqvist at tss.teleca.se  Tue Jan 13 14:12:18 2004
From: Anders.Hasselqvist at tss.teleca.se (Anders Hasselqvist)
Date: Tue, 13 Jan 2004 15:12:18 +0100
Subject: [qmtest] BUG? create-tdb overwrites existing database
Message-ID: <9EEF3C7F0B31F544919778197B64D760025934DB@au-sth01-ex.ausys.se>

Hi,

I guess the answer sys.stdin.isatty() is too simple to be the solution.

Regards,
--
Anders Hasselqvist

 

> -----Original Message-----
> From: Mark Mitchell [mailto:mark at codesourcery.com]
> Sent: den 12 januari 2004 23:36
> To: Scott Lowrey
> Cc: QMTest List
> Subject: Re: [qmtest] BUG? create-tdb overwrites existing database
>
> The command-line version of QMTest never prompts for
> anything, although maybe it should.  Clearly, it should do 
> that only when the standard input is a TTY, and I don't know 
> how to figure that out under Windows. 
> Does anybody here know that, by chance?
> 
> --
> Mark Mitchell <mark at codesourcery.com>
> CodeSourcery, LLC
> 


From seefeld at sympatico.ca  Tue Jan 13 14:56:59 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Tue, 13 Jan 2004 09:56:59 -0500
Subject: instantiating suites
Message-ID: <f658c92ed06a6df9a09324a4ee63f5734004054a@Orthosoft.ca>

hi there,

I just realized that some code of mine implementing a test database
doesn't work any more with a fresh update as the 'Suite' class has
changed (i.e. has become an extension).

What is the suggested way to instantiate a suite as was possible
up to the end of last year, i.e. via

Suite(self, id, implicit = 1, test_ids = tests, suite_ids = suites)

? I notice an 'explicit suite' class now available as an extension,
i.e. in the 'classes' directory. How can I access / instantiate that
directly ?

Is there any documentation available explaining why the extension
mechanism works the way it does (and, in fact, what extensions are
designed for, which classes should be extensions etc.; I'm a bit
astonished to see Suite becoming an extension...)

Thanks a lot,
		Stefan



From mark at codesourcery.com  Wed Jan 14 06:47:19 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 13 Jan 2004 22:47:19 -0800
Subject: [qmtest] BUG? create-tdb overwrites existing database
References: <9EEF3C7F0B31F544919778197B64D760025934DB@au-sth01-ex.ausys.se>
Message-ID: <01d101c3da6a$41d013d0$c00111ac@minax>

The Python docs say that "isatty" only works under UNIX.

Thanks,

--
Mark Mitchell
CodeSourcery, LLC
mark at codesourcery.com
----- Original Message ----- 
From: "Anders Hasselqvist" <Anders.Hasselqvist at tss.teleca.se>
To: "QMTest List" <qmtest at codesourcery.com>
Sent: Tuesday, January 13, 2004 6:12 AM
Subject: RE: [qmtest] BUG? create-tdb overwrites existing database


> Hi,
> 
> I guess the answer sys.stdin.isatty() is too simple to be the solution.
> 
> Regards,
> --
> Anders Hasselqvist
> 
>  
> 
> > -----Original Message-----
> > From: Mark Mitchell [mailto:mark at codesourcery.com]
> > Sent: den 12 januari 2004 23:36
> > To: Scott Lowrey
> > Cc: QMTest List
> > Subject: Re: [qmtest] BUG? create-tdb overwrites existing database
> >
> > The command-line version of QMTest never prompts for
> > anything, although maybe it should.  Clearly, it should do 
> > that only when the standard input is a TTY, and I don't know 
> > how to figure that out under Windows. 
> > Does anybody here know that, by chance?
> > 
> > --
> > Mark Mitchell <mark at codesourcery.com>
> > CodeSourcery, LLC
> > 
> 


From Anders.Hasselqvist at tss.teleca.se  Wed Jan 14 07:41:34 2004
From: Anders.Hasselqvist at tss.teleca.se (Anders Hasselqvist)
Date: Wed, 14 Jan 2004 08:41:34 +0100
Subject: [qmtest] BUG? create-tdb overwrites existing database
Message-ID: <9EEF3C7F0B31F544919778197B64D760025934DD@au-sth01-ex.ausys.se>

Hi,

I did a simple test:
--
import sys
print sys.stdout.isatty()
--

When run normaly without redirection the output is True.
When I redirect stdout to file the output is False.


http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/
_crt__isatty.asp


Regards,
--
Anders Hasselqvist
070-5952539

> -----Original Message-----
> From: Mark Mitchell [mailto:mark at codesourcery.com]
> Sent: den 14 januari 2004 07:47
> To: Anders Hasselqvist; QMTest List
> Subject: Re: [qmtest] BUG? create-tdb overwrites existing database
> 
> 
> The Python docs say that "isatty" only works under UNIX.
> 
> Thanks,
> 
> --
> Mark Mitchell
> CodeSourcery, LLC
> mark at codesourcery.com
> 


From njs at pobox.com  Wed Jan 14 09:48:56 2004
From: njs at pobox.com (Nathaniel Smith)
Date: Wed, 14 Jan 2004 01:48:56 -0800
Subject: Small bugs in explicit_suite.py
Message-ID: <20040114094856.GA19320@njs.ddts.net>

Patch attached.

-- Nathaniel

-- 
"On arrival in my ward I was immediately served with lunch. `This is
what you ordered yesterday.' I pointed out that I had just arrived,
only to be told: `This is what your bed ordered.'"
  -- Letter to the Editor, The Times, September 2000
-------------- next part --------------
? results.qmr
? qm/external/__init__.pyc
? tests/regress/QMTest/regression_database.pyc
? tests/regress/QMTest/selftest.pyc
? tests/regress/tuple1/QMTest/tuple_test.pyc
? tests/results_files/QMTest/results_file_database.pyc
? tests/results_files/QMTest/results_file_test.pyc
Index: ChangeLog
===================================================================
RCS file: /home/qm/Repository/qm/ChangeLog,v
retrieving revision 1.591
diff -u -r1.591 ChangeLog
--- ChangeLog	13 Jan 2004 14:46:28 -0000	1.591
+++ ChangeLog	14 Jan 2004 09:44:45 -0000
@@ -1,3 +1,10 @@
+2004-01-14  Nathaniel Smith  <njs at codesourcery.com>
+
+	* qm/test/classes/explicit_suite.py (arguments): Fix formatting
+	of description for 'is_implicit'.
+	(ExplicitSuite.IsImplicit): Compare 'BooleanField' value to
+	string "true".
+
 2004-01-13  Stefan Seefeld  <seefeld at sympatico.ca>
 
 	* qm/test/file_database.py: Fix little bug.
Index: qm/test/classes/explicit_suite.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/explicit_suite.py,v
retrieving revision 1.1
diff -u -r1.1 explicit_suite.py
--- qm/test/classes/explicit_suite.py	3 Jan 2004 04:02:59 -0000	1.1
+++ qm/test/classes/explicit_suite.py	14 Jan 2004 09:44:45 -0000
@@ -40,13 +40,13 @@
                 description = """The the suites contained in this suite.""")),
         BooleanField(name = "is_implicit",
                      title = "Implicit?",
-                     description = """,
+                     description = """\
                      True if this test is implicitly generated by QMTest."""),
         ]
     
     def IsImplicit(self):
 
-        return self.is_implicit
+        return self.is_implicit == "true"
    
 
     def GetTestIds(self):

From mark at codesourcery.com  Wed Jan 14 16:53:05 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 14 Jan 2004 08:53:05 -0800
Subject: [qmtest] Small bugs in explicit_suite.py
References: <20040114094856.GA19320@njs.ddts.net>
Message-ID: <00b701c3dabe$e7a8b2e0$c00111ac@minax>

Eek, yes, these are OK.

Thanks,

--
Mark Mitchell
CodeSourcery, LLC
mark at codesourcery.com
----- Original Message ----- 
From: "Nathaniel Smith" <njs at pobox.com>
To: "QMTest List" <qmtest at codesourcery.com>
Sent: Wednesday, January 14, 2004 1:48 AM
Subject: [qmtest] Small bugs in explicit_suite.py


> Patch attached.
> 
> -- Nathaniel
> 
> -- 
> "On arrival in my ward I was immediately served with lunch. `This is
> what you ordered yesterday.' I pointed out that I had just arrived,
> only to be told: `This is what your bed ordered.'"
>   -- Letter to the Editor, The Times, September 2000
> 


From mark at codesourcery.com  Thu Jan 15 06:11:25 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 14 Jan 2004 22:11:25 -0800
Subject: [qmtest] Bug with editing attachments
In-Reply-To: <200311201509.38719.ghost@cs.msu.su>
References: <200311201509.38719.ghost@cs.msu.su>
Message-ID: <1074147085.11633.5.camel@minax.codesourcery.com>

On Thu, 2003-11-20 at 04:09, Vladimir Prus wrote:
> Hello,
> using CVS HEAD of QMTest, I have problems with attachments.

Volodya --

I've (finally!) gotten around to fixing this problem, I think.

Here's a patch which cleans up the Attachment abstractions
substantially.  I've checked in the patch, but I'd appreciate it if you
would try it out and let me know if it works for you.

Thanks!

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC
-------------- next part --------------
2004-01-14  Mark Mitchell  <mark at codesourcery.com>

	* qm/attachment.py (Attachment.Move): New method.
	(AttachmentStore.Store): Do not return a value.
	(TemporaryAttachmentStore.Store): Do not check
	is_temporary_location.
	(is_temporary_location): Remove.
	(make_dom_node): Do not check is_temporary_location.
	* qm/extension.py (Extension.MakeDomElement): Remove debugging
	code.
	* qm/fields.py (Field.GetSubfields): New method.
	(Field.ParseFormValue): Take a dictionary of attachment stores as
	a parameter, not a single attachment store.
	(TextField.ParseFormValue): Likewise.
	(TupleField.GetSubfields): New method.
	(TupleField.ParseFormValue): Take a dictionary of attachment
	stores as a parameter, not a single attachment store.
	(SetField.GetContainedField): Remove.
	(SetField.GetHelp): Adjust.
	(SetField.GetSubfields): New method.
	(SetField.MakeDomNodeForValue): Do not use GetContainedField.
	(SetField.ParseFormValue): Likewise.  Take a dictionary of attachment
	stores as a parameter, not a single attachment store.
	(UploadAttachmentPage.__next_temporary_location): Remove.
	(UploadAttachmentPage.__init__): Add attachment_store parameter.
	(AttachmentField.FormatValueAsHTML): Encode the attachment store.
	(AttachmentField.ParseFormValue): Decode it.
	* qm/web.py (WebServer.__init__): Create a temporary attachment
	store.
	(WebServer.GetTemporaryAttachmentStore): New method.
	* qm/test/runnable.py (Runnable.GetAttachments): New method.
	(Runnable.__GetAttachments): Likewise.
	* qm/test/classes/xml_database.py
	(XMLDatabase.__StoreAttachments): Rewrite.
	* qm/test/web/web.py (QMTestServer.__init__): Do not create a
	temporary attachment store.
	(QMTestServer.HandleSubmitItem): Pass all available attachment
	stores to ParseFormValue.  Do not try to remove unused attachments
	here.
	* share/dtml/attachment.dtml: Encode the attachment store id.

Index: qm/attachment.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/attachment.py,v
retrieving revision 1.20
diff -c -5 -p -r1.20 attachment.py
*** qm/attachment.py	21 Jul 2003 19:38:28 -0000	1.20
--- qm/attachment.py	15 Jan 2004 05:59:28 -0000
*************** class Attachment:
*** 154,163 ****
--- 154,183 ----
  
          returns -- The 'AttachmentStore' that contains this attachment."""
  
          return self.__store
  
+ 
+     def Move(self, store, location):
+         """Move the 'Attachment' to a new location.
+ 
+         'store' -- The 'AttachmentStore' that will contain the
+         attachment.
+ 
+         'location' -- The location of the attachment within its current
+         store."""
+ 
+         # Store this attachment in its new location.  That must be done
+         # before removing it from its current location as that step will
+         # destroy the data contained in the attachment.
+         store.Store(self, location)
+         # Now, remove the attachment from its current location.
+         self.__store.Remove(self.__location)
+         # Finally, update the information associated with the attachment.
+         self.__store = store
+         self.__location = location
+ 
      
      def __str__(self):
          return '<Attachment "%s" (%s)>' \
                 % (self.GetDescription(), self.GetMimeType())
  
*************** class AttachmentStore(object):
*** 236,249 ****
      def Store(self, attachment, location):
          """Add an attachment to the store.
  
          'attachment' -- The 'Attachment' to store.
  
!         'location' -- The location in which to store the 'attachment'.
! 
!         returns -- A new 'Attachment' whose 'AttachmentStore' is
!         'self'."""
  
          raise NotImplementedError
          
  
  
--- 256,266 ----
      def Store(self, attachment, location):
          """Add an attachment to the store.
  
          'attachment' -- The 'Attachment' to store.
  
!         'location' -- The location in which to store the 'attachment'."""
  
          raise NotImplementedError
          
  
  
*************** class FileAttachmentStore(AttachmentStor
*** 295,310 ****
          # Write the data.
          file.write(attachment.GetData())
          # Close the file.
          file.close()
  
-         return Attachment(attachment.GetMimeType(),
-                           attachment.GetDescription(),
-                           attachment.GetFileName(),
-                           location,
-                           self)
- 
  
      def Remove(self, location):
          """Remove an attachment.
  
          'location' -- The location whose data should be removed."""
--- 312,321 ----
*************** class TemporaryAttachmentStore(FileAttac
*** 348,360 ****
  
          returns -- HTML text of a page that instructs the browser window
          to close."""
  
          location = request["location"]
-         # Because this data is in the temporary attachment store, the
-         # location should be a temporary location.
-         assert is_temporary_location(location)
          # Create the file.
          file = open(self.GetDataFile(location), "w")
          # Write the data.
          file.write(request["file_data"])
          # Close the file.
--- 359,368 ----
*************** _temporary_location_prefix = "_temporary
*** 379,394 ****
  def make_temporary_location():
      """Return a unique location for temporary attachment data."""
  
      return _temporary_location_prefix + common.make_unique_tag()
  
-         
- def is_temporary_location(location):
-     """Return true if 'location' is a temporary attachment location."""
- 
-     return location.startswith(_temporary_location_prefix)
- 
  
  def make_dom_node(attachment, document):
      """Create a DOM element node for this attachment.
  
      'document' -- A DOM document node in which to create the
--- 387,396 ----
*************** def make_dom_node(attachment, document):
*** 418,432 ****
          document, "filename", attachment.GetFileName())
      node.appendChild(child)
      # Create a location element, to include attachment data by
      # reference.
      location = attachment.GetLocation()
!     # Attchments whose data is in the temporary store should not be
!     # externalized. 
!     assert not is_temporary_location(location)
!     child = xmlutil.create_dom_text_element(
!         document, "location", location)
  
      node.appendChild(child)
      return node
  
  
--- 420,430 ----
          document, "filename", attachment.GetFileName())
      node.appendChild(child)
      # Create a location element, to include attachment data by
      # reference.
      location = attachment.GetLocation()
!     child = xmlutil.create_dom_text_element(document, "location", location)
  
      node.appendChild(child)
      return node
  
  
Index: qm/extension.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/extension.py,v
retrieving revision 1.14
diff -c -5 -p -r1.14 extension.py
*** qm/extension.py	3 Jan 2004 04:02:59 -0000	1.14
--- qm/extension.py	15 Jan 2004 05:59:29 -0000
*************** class Extension(object):
*** 128,147 ****
          extension class.  The caller is responsible for attaching it to
          the 'document'."""
  
          # Get all of the arguments.
          arguments = get_class_arguments_as_dictionary(self.__class__)
-         import sys
-         print >> sys.stderr, arguments
          # Determine which subset of the 'arguments' have been set
          # explicitly.
          explicit_arguments = {}
          for name, field in arguments.items():
              # Do not record computed fields.
              if field.IsComputed():
                  continue
-             print >> sys.stderr, name
              if self.__dict__.has_key(name):
                  explicit_arguments[name] = self.__dict__[name]
  
          return make_dom_element(self.__class__, explicit_arguments,
                                  document, element)
--- 128,144 ----
Index: qm/fields.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/fields.py,v
retrieving revision 1.80
diff -c -5 -p -r1.80 fields.py
*** qm/fields.py	13 Nov 2003 03:08:01 -0000	1.80
--- qm/fields.py	15 Jan 2004 05:59:29 -0000
*************** import xmlutil
*** 66,76 ****
  class Field(object):
      """A 'Field' is a named, typed component of a data structure."""
  
      form_field_prefix = "_field_"
      
- 
      def __init__(self,
                   name,
                   default_value,
                   title = "",
                   description = "",
--- 66,75 ----
*************** class Field(object):
*** 188,197 ****
--- 187,205 ----
          <hr noshade size="2">
          <p>Refer to this field as <tt>%s</tt> in Python expressions.</p>
          ''' % (self.GetTitle(), description, help, self.GetName(), )
  
  
+     def GetSubfields(self):
+         """Returns the sequence of subfields contained in this field.
+ 
+         returns -- The sequence of subfields contained in this field.
+         If there are no subfields, an empty sequence is returned."""
+ 
+         return ()
+ 
+         
      def IsComputed(self):
          """Returns true if this field is computed automatically.
  
          returns -- True if this field is computed automatically.  A
          computed field is never displayed to users and is not stored
*************** class Field(object):
*** 315,334 ****
          before it is returned."""
  
          raise NotImplemented
      
          
!     def ParseFormValue(self, request, name, attachment_store):
          """Convert a value submitted from an HTML form.
  
          'request' -- The 'WebRequest' containing a value corresponding
          to this field.
  
          'name' -- The name corresponding to this field in the 'request'.
  
!         'attachment_store' -- The 'AttachmentStore' into which new
!         attachments should be placed.
          
          returns -- A pair '(value, redisplay)'.  'value' is the value
          for this field, as indicated in 'request'.  'redisplay' is true
          if and only if the form should be redisplayed, rather than
          committed.  If an error occurs, an exception is thrown."""
--- 323,343 ----
          before it is returned."""
  
          raise NotImplemented
      
          
!     def ParseFormValue(self, request, name, attachment_stores):
          """Convert a value submitted from an HTML form.
  
          'request' -- The 'WebRequest' containing a value corresponding
          to this field.
  
          'name' -- The name corresponding to this field in the 'request'.
  
!         'attachment_stores' -- A dictionary mapping 'AttachmentStore' ids
!         (in the sense of Python's 'id' built-in) to the
!         'AttachmentStore's themselves.
          
          returns -- A pair '(value, redisplay)'.  'value' is the value
          for this field, as indicated in 'request'.  'redisplay' is true
          if and only if the form should be redisplayed, rather than
          committed.  If an error occurs, an exception is thrown."""
*************** class TextField(Field):
*** 655,665 ****
          if not self.__multiline:
              value = re.sub(" *\n+ *", " ", value)
          return value
  
  
!     def ParseFormValue(self, request, name, attachment_store):
  
          # HTTP specifies text encodings are CR/LF delimited; convert to
          # the One True Text Format (TM).
          return (self.ParseTextValue(qm.convert_from_dos_text(request[name])),
                  0)
--- 664,674 ----
          if not self.__multiline:
              value = re.sub(" *\n+ *", " ", value)
          return value
  
  
!     def ParseFormValue(self, request, name, attachment_stores):
  
          # HTTP specifies text encodings are CR/LF delimited; convert to
          # the One True Text Format (TM).
          return (self.ParseTextValue(qm.convert_from_dos_text(request[name])),
                  0)
*************** class TupleField(Field):
*** 721,730 ****
--- 730,745 ----
              help += "** " + f.GetTitle() + " **\n\n"
              help += f.GetHelp()
  
          return help
  
+ 
+     def GetSubfields(self):
+ 
+         return self.__fields
+ 
+     
      ### Output methods.
  
      def FormatValueAsHtml(self, server, value, style, name = None):
  
          # Use the default name if none is specified.
*************** class TupleField(Field):
*** 759,775 ****
          assert len(value) == len(self.__fields)
          return map(lambda f, v: f.Validate(v),
                     self.__fields, value)
  
  
!     def ParseFormValue(self, request, name, attachment_store):
  
          value = []
          redisplay = 0
          for f in self.__fields:
              v, r = f.ParseFormValue(request, name + "_" + f.GetName(),
!                                     attachment_store)
              value.append(v)
              if r:
                  redisplay = 1
  
          # Now that we've computed the value of the entire tuple, make
--- 774,790 ----
          assert len(value) == len(self.__fields)
          return map(lambda f, v: f.Validate(v),
                     self.__fields, value)
  
  
!     def ParseFormValue(self, request, name, attachment_stores):
  
          value = []
          redisplay = 0
          for f in self.__fields:
              v, r = f.ParseFormValue(request, name + "_" + f.GetName(),
!                                     attachment_stores)
              value.append(v)
              if r:
                  redisplay = 1
  
          # Now that we've computed the value of the entire tuple, make
*************** class SetField(Field):
*** 828,851 ****
          # Remeber the contained field type.
          self.__contained = contained
          self.__not_empty_set = not_empty_set == "true"
  
  
-     def GetContainedField(self):
-         """Returns the field instance of the contents of the set."""
- 
-         return self.__contained
- 
- 
      def GetHelp(self):
          return """
          A set field.  A set contains zero or more elements, all of the
          same type.  The elements of the set are described below:
  
!         """ + self.GetContainedField().GetHelp()
  
  
      def GetHtmlHelp(self, edit=0):
          help = Field.GetHtmlHelp(self)
          if edit:
              # In addition to the standard generated help, include
              # additional instructions about using the HTML controls.
--- 843,865 ----
          # Remeber the contained field type.
          self.__contained = contained
          self.__not_empty_set = not_empty_set == "true"
  
  
      def GetHelp(self):
          return """
          A set field.  A set contains zero or more elements, all of the
          same type.  The elements of the set are described below:
  
!         """ + self.__contained.GetHelp()
  
  
+     def GetSubfields(self):
+ 
+         return (self.__contained,)
+     
+ 
      def GetHtmlHelp(self, edit=0):
          help = Field.GetHtmlHelp(self)
          if edit:
              # In addition to the standard generated help, include
              # additional instructions about using the HTML controls.
*************** class SetField(Field):
*** 867,877 ****
          # If the set is empty, indicate this specially.
          if len(value) == 0:
              return "None"
          # Format each element of the set, and join them into a
          # comma-separated list. 
!         contained_field = self.GetContainedField()
          formatted_items = []
          for item in value:
              formatted_item = contained_field.FormatValueAsText(item, columns)
              formatted_items.append(repr(formatted_item))
          result = "[ " + string.join(formatted_items, ", ") + " ]"
--- 881,891 ----
          # If the set is empty, indicate this specially.
          if len(value) == 0:
              return "None"
          # Format each element of the set, and join them into a
          # comma-separated list. 
!         contained_field = self.__contained
          formatted_items = []
          for item in value:
              formatted_item = contained_field.FormatValueAsText(item, columns)
              formatted_items.append(repr(formatted_item))
          result = "[ " + string.join(formatted_items, ", ") + " ]"
*************** class SetField(Field):
*** 884,894 ****
              value = []
          # Use the default field form field name if requested.
          if name is None:
              name = self.GetHtmlFormFieldName()
  
!         contained_field = self.GetContainedField()
  
          if style == "brief" or style == "full":
              if len(value) == 0:
                  # An empty set.
                  return "None"
--- 898,908 ----
              value = []
          # Use the default field form field name if requested.
          if name is None:
              name = self.GetHtmlFormFieldName()
  
!         contained_field = self.__contained
  
          if style == "brief" or style == "full":
              if len(value) == 0:
                  # An empty set.
                  return "None"
*************** class SetField(Field):
*** 958,968 ****
      def MakeDomNodeForValue(self, value, document):
  
          # Create a set element.
          element = document.createElement("set")
          # Add a child node for each item in the set.
!         contained_field = self.GetContainedField()
          for item in value:
              # The contained field knows how to make a DOM node for each
              # item in the set.
              item_node = contained_field.MakeDomNodeForValue(item, document)
              element.appendChild(item_node)
--- 972,982 ----
      def MakeDomNodeForValue(self, value, document):
  
          # Create a set element.
          element = document.createElement("set")
          # Add a child node for each item in the set.
!         contained_field = self.__contained
          for item in value:
              # The contained field knows how to make a DOM node for each
              # item in the set.
              item_node = contained_field.MakeDomNodeForValue(item, document)
              element.appendChild(item_node)
*************** class SetField(Field):
*** 1025,1062 ****
              # The next token should be a string constant.
              if tok[0] != tokenize.STRING:
                  invalid(tok)
              # Parse the string constant.
              v = eval(tok[1])
!             elements.append(self.GetContainedField().ParseTextValue(v))
  
          # There should not be any tokens left over.
          tok = g.next()
          if not tokenize.ISEOF(tok[0]):
              invalid(tok)
  
          return self.Validate(elements)
          
                         
!     def ParseFormValue(self, request, name, attachment_store):
  
          values = []
          redisplay = 0
          
          # See if the user wants to add or remove elements from the set.
          action = request[name]
          # Loop over the entries for each of the elements, adding them to
          # the set.
!         contained_field = self.GetContainedField()
          element = 0
  	for element in xrange(int(request[name + "_count"])):
              element_name = name + "_%d" % element
              if not (action == "remove"
                      and request.get(element_name + "_remove") == "on"):
                  v, r = contained_field.ParseFormValue(request,
                                                        element_name,
!                                                       attachment_store)
                  values.append(v)
                  if r:
                      redisplay = 1
              element += 1
  	
--- 1039,1076 ----
              # The next token should be a string constant.
              if tok[0] != tokenize.STRING:
                  invalid(tok)
              # Parse the string constant.
              v = eval(tok[1])
!             elements.append(self.__contained.ParseTextValue(v))
  
          # There should not be any tokens left over.
          tok = g.next()
          if not tokenize.ISEOF(tok[0]):
              invalid(tok)
  
          return self.Validate(elements)
          
                         
!     def ParseFormValue(self, request, name, attachment_stores):
  
          values = []
          redisplay = 0
          
          # See if the user wants to add or remove elements from the set.
          action = request[name]
          # Loop over the entries for each of the elements, adding them to
          # the set.
!         contained_field = self.__contained
          element = 0
  	for element in xrange(int(request[name + "_count"])):
              element_name = name + "_%d" % element
              if not (action == "remove"
                      and request.get(element_name + "_remove") == "on"):
                  v, r = contained_field.ParseFormValue(request,
                                                        element_name,
!                                                       attachment_stores)
                  values.append(v)
                  if r:
                      redisplay = 1
              element += 1
  	
*************** class SetField(Field):
*** 1097,1107 ****
                             name=self.GetName(),
                             right_tag="set",
                             wrong_tag=node.tagName)
          # Use the contained field to extract values for the children of
          # this node, which are the set elements.
!         contained_field = self.GetContainedField()
          fn = lambda n, f=contained_field, s=attachment_store: \
               f.GetValueFromDomNode(n, s)
          values = map(fn,
                       filter(lambda n: n.nodeType == xml.dom.Node.ELEMENT_NODE,
                              node.childNodes))
--- 1111,1121 ----
                             name=self.GetName(),
                             right_tag="set",
                             wrong_tag=node.tagName)
          # Use the contained field to extract values for the children of
          # this node, which are the set elements.
!         contained_field = self.__contained
          fn = lambda n, f=contained_field, s=attachment_store: \
               f.GetValueFromDomNode(n, s)
          values = map(fn,
                       filter(lambda n: n.nodeType == xml.dom.Node.ELEMENT_NODE,
                              node.childNodes))
*************** class SetField(Field):
*** 1112,1130 ****
  ########################################################################
  
  class UploadAttachmentPage(web.DtmlPage):
      """DTML context for generating upload-attachment.dtml."""
  
!     __next_temporary_location = 0
! 
!     def __init__(self, 
                   field_name,
                   encoding_name,
                   summary_field_name,
                   in_set=0):
          """Create a new page object.
  
          'field_name' -- The user-visible name of the field for which an
          attachment is being uploaded.
  
          'encoding_name' -- The name of the HTML input that should
          contain the encoded attachment.
--- 1126,1146 ----
  ########################################################################
  
  class UploadAttachmentPage(web.DtmlPage):
      """DTML context for generating upload-attachment.dtml."""
  
!     def __init__(self,
!                  attachment_store,
                   field_name,
                   encoding_name,
                   summary_field_name,
                   in_set=0):
          """Create a new page object.
  
+         'attachment_store' -- The AttachmentStore in which the new
+         attachment will be placed.
+         
          'field_name' -- The user-visible name of the field for which an
          attachment is being uploaded.
  
          'encoding_name' -- The name of the HTML input that should
          contain the encoded attachment.
*************** class UploadAttachmentPage(web.DtmlPage)
*** 1137,1146 ****
--- 1153,1163 ----
  
          web.DtmlPage.__init__(self, "attachment.dtml")
          # Use a brand-new location for the attachment data.
          self.location = attachment.make_temporary_location()
          # Set up properties.
+         self.attachment_store_id = id(attachment_store)
          self.field_name = field_name
          self.encoding_name = encoding_name
          self.summary_field_name = summary_field_name
          self.in_set = in_set
  
*************** class AttachmentField(Field):
*** 1300,1325 ****
              summary_value = 'value="%s"' % self._FormatSummary(value)
              if value is None:
                  field_value = ""
              else:
                  # We'll encode all the relevant information.
!                 parts = (
!                     value.GetDescription(),
!                     value.GetMimeType(),
!                     value.GetLocation(),
!                     value.GetFileName(),
!                     )
                  # Each part is URL-encoded.
                  parts = map(urllib.quote, parts)
                  # The parts are joined into a semicolon-delimited list.
                  field_value = string.join(parts, ";")
              field_value = 'value="%s"' % field_value
  
              # Generate the popup upload page.
!             upload_page = UploadAttachmentPage(self.GetTitle(),
!                                                name,
!                                                summary_field_name)()
              
              # Generate controls for this form.
              
              # A text control for the user-visible summary of the
              # attachment.  The "readonly" property isn't supported in
--- 1317,1340 ----
              summary_value = 'value="%s"' % self._FormatSummary(value)
              if value is None:
                  field_value = ""
              else:
                  # We'll encode all the relevant information.
!                 parts = (description, mime_type, location, file_name,
!                          str(id(value.GetStore())))
                  # Each part is URL-encoded.
                  parts = map(urllib.quote, parts)
                  # The parts are joined into a semicolon-delimited list.
                  field_value = string.join(parts, ";")
              field_value = 'value="%s"' % field_value
  
              # Generate the popup upload page.
!             upload_page = \
!                 UploadAttachmentPage(server.GetTemporaryAttachmentStore(),
!                                      self.GetTitle(),
!                                      name,
!                                      summary_field_name)()
              
              # Generate controls for this form.
              
              # A text control for the user-visible summary of the
              # attachment.  The "readonly" property isn't supported in
*************** class AttachmentField(Field):
*** 1394,1404 ****
              raise ValueError, \
                    "the value of an attachment field must be an 'Attachment'"
          return value
  
  
!     def ParseFormValue(self, request, name, attachment_store):
  
          encoding = request[name]
          # An empty string represnts a missing attachment, which is OK.
          if string.strip(encoding) == "":
              return None
--- 1409,1419 ----
              raise ValueError, \
                    "the value of an attachment field must be an 'Attachment'"
          return value
  
  
!     def ParseFormValue(self, request, name, attachment_stores):
  
          encoding = request[name]
          # An empty string represnts a missing attachment, which is OK.
          if string.strip(encoding) == "":
              return None
*************** class AttachmentField(Field):
*** 1406,1420 ****
          # relevant information about the attachment.
          parts = string.split(encoding, ";")
          # Undo the URL encoding of each component.
          parts = map(urllib.unquote, parts)
          # Unpack the results.
!         description, mime_type, location, file_name = parts
          # Create the attachment.
          value = attachment.Attachment(mime_type, description,
                                        file_name, location,
!                                       attachment_store)
          return (self.Validate(value), 0)
  
  
      def GetValueFromDomNode(self, node, attachment_store):
  
--- 1421,1438 ----
          # relevant information about the attachment.
          parts = string.split(encoding, ";")
          # Undo the URL encoding of each component.
          parts = map(urllib.unquote, parts)
          # Unpack the results.
!         description, mime_type, location, file_name, store_id = parts
!         # Figure out which AttachmentStore corresponds to the id
!         # provided.
!         store = attachment_stores[int(store_id)]
          # Create the attachment.
          value = attachment.Attachment(mime_type, description,
                                        file_name, location,
!                                       store)
          return (self.Validate(value), 0)
  
  
      def GetValueFromDomNode(self, node, attachment_store):
  
Index: qm/web.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/web.py,v
retrieving revision 1.76
diff -c -5 -p -r1.76 web.py
*** qm/web.py	29 Sep 2003 07:03:04 -0000	1.76
--- qm/web.py	15 Jan 2004 05:59:31 -0000
*************** class WebServer(HTTPServer):
*** 745,754 ****
--- 745,760 ----
  
          self.__cache_dir = temporary_directory.TemporaryDirectory()
          self.__cache_path = self.__cache_dir.GetPath()
          os.mkdir(os.path.join(self.__cache_path, "sessions"), 0700)
  
+         # Create a temporary attachment store to process attachment data
+         # uploads.
+         self.__temporary_store = qm.attachment.TemporaryAttachmentStore()
+         self.RegisterScript(qm.fields.AttachmentField.upload_url,
+                             self.__temporary_store.HandleUploadRequest)
+ 
          # Don't call the base class __init__ here, since we don't want
          # to create the web server just yet.  Instead, we'll call it
          # when it's time to run the server.
  
  
*************** class WebServer(HTTPServer):
*** 921,930 ****
--- 927,944 ----
          returns -- A pair '(hostname, port)'."""
  
          return (self.server_name, self.server_port)
  
  
+     def GetTemporaryAttachmentStore(self):
+         """Return the 'AttachmentStore' used for new 'Attachment's.
+ 
+         returns -- The 'AttachmentStore' used for new 'Attachment's."""
+ 
+         return self.__temporary_store
+     
+         
      def MakeButtonForCachedPopup(self,
                                   label,
                                   html_text,
                                   request=None,
                                   window_width=480,
Index: qm/test/runnable.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/runnable.py,v
retrieving revision 1.3
diff -c -5 -p -r1.3 runnable.py
*** qm/test/runnable.py	20 Mar 2003 16:55:17 -0000	1.3
--- qm/test/runnable.py	15 Jan 2004 05:59:31 -0000
***************
*** 17,26 ****
--- 17,27 ----
  # Imports
  ########################################################################
  
  import qm
  import qm.extension
+ from   qm.fields import AttachmentField, TupleField, SetField
  
  ########################################################################
  # Classes
  ########################################################################
  
*************** class Runnable(qm.extension.Extension):
*** 103,107 ****
--- 104,150 ----
  
          returns -- The 'Database' in which this test or resource is
          stored."""
  
          return self.__database
+ 
+ 
+     def GetAttachments(self):
+         """Return the 'Attachment's to this 'Runnable'.
+ 
+         returns -- A sequence consisting of the 'Attachment' objects
+         associated with this runnable."""
+ 
+         attachments = []
+         for f in qm.extension.get_class_arguments(self.__class__):
+             self.__GetAttachments(f,
+                                   getattr(self, f.GetName()),
+                                   attachments)
+         return attachments
+ 
+ 
+     def __GetAttachments(self, field, value, attachments):
+         """Return the 'Attachments' that are part of 'field'.
+ 
+         'field' -- The 'Field' being examined.
+ 
+         'value' -- The value of that 'Field' in 'self'.
+ 
+         'attachments' -- A sequence consisting of the attachments
+         found so far.  Additional 'Attachment's are appended to this
+         sequence by this function."""
+ 
+         if isinstance(field, AttachmentField):
+             attachments.append(getattr(self, field.GetName()))
+         elif isinstance(field, TupleField):
+             subfields = field.GetSubfields()
+             for i in xrange(len(subfields)):
+                 self.__GetAttachments(subfields[i], value[i],
+                                       attachments)
+         elif isinstance(field, SetField):
+             subfield = field.GetSubfields()[0]
+             for i in xrange(len(value)):
+                 self.__GetAttachments(subfield, value[i],
+                                       attachments)
+ 
+         return
+                 
Index: qm/test/classes/xml_database.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/xml_database.py,v
retrieving revision 1.17
diff -c -5 -p -r1.17 xml_database.py
*** qm/test/classes/xml_database.py	3 Jan 2004 04:02:59 -0000	1.17
--- qm/test/classes/xml_database.py	15 Jan 2004 05:59:31 -0000
*************** class XMLDatabase(ExtensionDatabase):
*** 85,105 ****
      def __StoreAttachments(self, item):
          """Store all attachments in 'item' in the attachment store.
  
          'item' -- A 'Test' or 'Resource'.  If any of its fields contain
          attachments, add them to the 'AttachmentStore'."""
!            
!         for field in get_class_arguments(item.__class__):
!             if isinstance(field, qm.fields.AttachmentField):
!                 attachment = getattr(item, field.GetName())
!                 if (attachment is not None
!                     and attachment.GetStore() != self.__store):
!                     location = \
!                         self.__MakeDataFilePath(item.GetId(),
!                                                 attachment.GetFileName())
!                     setattr(item, field.GetName(),
!                             self.__store.Store(attachment, location))
  
           
      def __MakeDataFilePath(self, item_id, file_name):
          """Construct the path to an attachment data file.
  
--- 85,123 ----
      def __StoreAttachments(self, item):
          """Store all attachments in 'item' in the attachment store.
  
          'item' -- A 'Test' or 'Resource'.  If any of its fields contain
          attachments, add them to the 'AttachmentStore'."""
! 
!         # Get all of the attachments associated with the new item.
!         new_attachments = item.GetAttachments()
! 
!         # Remove old attachments that are not also among the new
!         # attachments.
!         store = self.GetAttachmentStore()
!         try:
!             old_item = self.GetItem(item.kind, item.GetId())
!         except:
!             old_item = None
!         if old_item:
!             old_attachments = old_item.GetItem().GetAttachments()
!             for o in old_attachments:
!                 found = 0
!                 for n in new_attachments:
!                     if (n.GetStore() == store
!                         and n.GetFileName() == o.GetFileName()):
!                         found = 1
!                         break
!                 if not found:
!                     store.Remove(o.GetLocation())
! 
!         # Put any new attachments into the attachment store.
!         for a in new_attachments:
!             if a.GetStore() != store:
!                 location = self.__MakeDataFilePath(item.GetId(),
!                                                    a.GetFileName())
!                 a.Move(store, location)
  
           
      def __MakeDataFilePath(self, item_id, file_name):
          """Construct the path to an attachment data file.
  
Index: qm/test/web/web.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/web/web.py,v
retrieving revision 1.80
diff -c -5 -p -r1.80 web.py
*** qm/test/web/web.py	12 Jan 2004 22:27:08 -0000	1.80
--- qm/test/web/web.py	15 Jan 2004 05:59:32 -0000
*************** class QMTestServer(qm.web.WebServer):
*** 1573,1587 ****
              "/static", qm.get_share_directory("web", "static"))
          # Register the QM manual.
          self.RegisterPathTranslation(
              "/manual", qm.get_doc_directory("test", "html"))
  
-         # Create a temporary attachment store to process attachment data
-         # uploads.
-         self.__temporary_store = qm.attachment.TemporaryAttachmentStore()
-         self.RegisterScript(qm.fields.AttachmentField.upload_url,
-                             self.__temporary_store.HandleUploadRequest)
          # The DB's attachment store processes download requests for
          # attachment data.
          attachment_store = database.GetAttachmentStore()
          if attachment_store:
              self.RegisterScript(qm.fields.AttachmentField.download_url,
--- 1573,1582 ----
*************** class QMTestServer(qm.web.WebServer):
*** 2021,2031 ****
                          field_errors["_id"] = qm.error("test already exists",
                                                         test_id=item_id)
              # Check that the class exists.
              try:
                  qm.test.base.get_extension_class(class_name, type,
!                                                  self.GetDatabase())
              except ValueError:
                  # The class name was incorrectly specified.
                  field_errors["_class"] = qm.error("invalid class name",
                                                    class_name=class_name)
              except:
--- 2016,2026 ----
                          field_errors["_id"] = qm.error("test already exists",
                                                         test_id=item_id)
              # Check that the class exists.
              try:
                  qm.test.base.get_extension_class(class_name, type,
!                                                  database)
              except ValueError:
                  # The class name was incorrectly specified.
                  field_errors["_class"] = qm.error("invalid class name",
                                                    class_name=class_name)
              except:
*************** class QMTestServer(qm.web.WebServer):
*** 2261,2289 ****
          is_new = int(request["is_new"])
          # Extract the class and field specification.
          item_class_name = request["class"]
          item_class = qm.test.base.get_extension_class(item_class_name,
                                                        type,
!                                                       self.GetDatabase())
          fields = get_class_arguments(item_class)
  
          # We'll perform various kinds of validation as we extract form
          # fields.  Errors are placed into this map.
          field_errors = {}
          redisplay = 0
          
          # Loop over fields of the class, looking for arguments in the
          # submitted request.
          arguments = {}
          for field in fields:
              # Construct the name we expect for the corresponding argument.
              field_name = field.GetName()
              form_field_name = field.GetHtmlFormFieldName()
              # Parse the value for this field.
              try:
                  value, r = field.ParseFormValue(request, form_field_name,
!                                                 self.__temporary_store)
                  if r:
                      redisplay = 1
                  arguments[field_name] = value
              except:
                  # Something went wrong parsing the value.  Associate an
--- 2256,2288 ----
          is_new = int(request["is_new"])
          # Extract the class and field specification.
          item_class_name = request["class"]
          item_class = qm.test.base.get_extension_class(item_class_name,
                                                        type,
!                                                       database)
          fields = get_class_arguments(item_class)
  
          # We'll perform various kinds of validation as we extract form
          # fields.  Errors are placed into this map.
          field_errors = {}
          redisplay = 0
          
          # Loop over fields of the class, looking for arguments in the
          # submitted request.
          arguments = {}
+         temporary_store = self.GetTemporaryAttachmentStore()
+         main_store = database.GetAttachmentStore()
+         attachment_stores = { id(temporary_store): temporary_store,
+                               id(main_store): main_store }
          for field in fields:
              # Construct the name we expect for the corresponding argument.
              field_name = field.GetName()
              form_field_name = field.GetHtmlFormFieldName()
              # Parse the value for this field.
              try:
                  value, r = field.ParseFormValue(request, form_field_name,
!                                                 attachment_stores)
                  if r:
                      redisplay = 1
                  arguments[field_name] = value
              except:
                  # Something went wrong parsing the value.  Associate an
*************** class QMTestServer(qm.web.WebServer):
*** 2293,2339 ****
                  redisplay = 1
  
          if type is "test":
              # Create a new test.
              item = TestDescriptor(
!                     self.GetDatabase(),
                      test_id=item_id,
                      test_class_name=item_class_name,
                      arguments=arguments)
  
          elif type is "resource":
              # Create a new resource.
!             item = ResourceDescriptor(self.GetDatabase(),
!                                       item_id, item_class_name, arguments)
  
          # If necessary, redisplay the form.
          if redisplay:
  	    request = qm.web.WebRequest("edit-" + type, base=request, 
                                          id=item_id)
  	    return ShowItemPage(self, item, 1, is_new, type,
                                  field_errors)(request)
  
          # Store it in the database.
          database.WriteExtension(item_id, item.GetItem())
- 
-         # Remove any attachments located in the temporary store as they
-         # have now been copied to the store associated with the
-         # database.
-         temporary_store = self.__temporary_store
-         for field in fields:
-             if isinstance(field, qm.fields.AttachmentField):
-                 attachment = arguments[field.GetName()]
-                 if attachment is not None \
-                    and attachment.GetStore() is temporary_store:
-                     temporary_store.Remove(attachment.GetLocation())
-             elif isinstance(field, qm.fields.SetField) \
-                  and isinstance(field.GetContainedField(),
-                                 qm.fields.AttachmentField):
-                 for attachment in arguments[field.GetName()]:
-                     if attachment is not None \
-                        and attachment.GetStore() is temporary_store:
-                         temporary_store.Remove(attachment.GetLocation())
  
          # Redirect to a page that displays the newly-edited item.
          request = qm.web.WebRequest("show-" + type, base=request, id=item_id)
          raise qm.web.HttpRedirect, request
  
--- 2292,2320 ----
                  redisplay = 1
  
          if type is "test":
              # Create a new test.
              item = TestDescriptor(
!                     database,
                      test_id=item_id,
                      test_class_name=item_class_name,
                      arguments=arguments)
  
          elif type is "resource":
              # Create a new resource.
!             item = ResourceDescriptor(database, item_id,
!                                       item_class_name, arguments)
  
          # If necessary, redisplay the form.
          if redisplay:
  	    request = qm.web.WebRequest("edit-" + type, base=request, 
                                          id=item_id)
  	    return ShowItemPage(self, item, 1, is_new, type,
                                  field_errors)(request)
  
          # Store it in the database.
          database.WriteExtension(item_id, item.GetItem())
  
          # Redirect to a page that displays the newly-edited item.
          request = qm.web.WebRequest("show-" + type, base=request, id=item_id)
          raise qm.web.HttpRedirect, request
  
Index: share/dtml/attachment.dtml
===================================================================
RCS file: /home/qm/Repository/qm/share/dtml/attachment.dtml,v
retrieving revision 1.8
diff -c -5 -p -r1.8 attachment.dtml
*** share/dtml/attachment.dtml	9 May 2003 22:17:44 -0000	1.8
--- share/dtml/attachment.dtml	15 Jan 2004 05:59:32 -0000
***************
*** 149,159 ****
       mime_type = document.upload_form.mime_type.value;
  
     encoding = escape(description) + ";"
                + escape(mime_type) + ";"
                + escape(location) + ";"
!               + escape(file_name);
  
     summary = description + " (" + file_name
     if(document.upload_form.detect_mime_type[1].checked)
       summary +=  "; " + mime_type;
     summary = summary + ")"
--- 149,160 ----
       mime_type = document.upload_form.mime_type.value;
  
     encoding = escape(description) + ";"
                + escape(mime_type) + ";"
                + escape(location) + ";"
!               + escape(file_name) + ";"
!               + escape("<dtml-var expr="attachment_store_id">");
  
     summary = description + " (" + file_name
     if(document.upload_form.detect_mime_type[1].checked)
       summary +=  "; " + mime_type;
     summary = summary + ")"

From ghost at cs.msu.su  Thu Jan 15 07:38:57 2004
From: ghost at cs.msu.su (Vladimir Prus)
Date: Thu, 15 Jan 2004 10:38:57 +0300
Subject: [qmtest] Bug with editing attachments
In-Reply-To: <1074147085.11633.5.camel@minax.codesourcery.com>
References: <200311201509.38719.ghost@cs.msu.su> <1074147085.11633.5.camel@minax.codesourcery.com>
Message-ID: <200401151038.57256.ghost@cs.msu.su>

Hi Mark,

> > Hello,
> > using CVS HEAD of QMTest, I have problems with attachments.
>
> Volodya --
>
> I've (finally!) gotten around to fixing this problem, I think.
>
> Here's a patch which cleans up the Attachment abstractions
> substantially.  I've checked in the patch, but I'd appreciate it if you
> would try it out and let me know if it works for you.

Oh... looks like a big patch! But as I see, the essense is that now attachment 
rendered in HTML knows which store it comes from. That's great -- I myself 
did not know how to implement this in right way.

The problems with editing test that has an attachment are now gone. 

However, the other problem is still there. If I create a new test with 
attachment, the location is like this:

   <location>/home/ghost/Work/Module/nm_model/tdb/history.qms/nightly.sh</location>

Which would make test break if I ever decide to move my working copy -- of if 
tests are run on a different machine. I'd still say that the 
__MakeDataFilePath in xml_database is not right. It would be better to use 
methods of AttachmentStore, rather than checking for file existance via 
"os.path.exists" -- as it stands, it depends on the exact way 
FileAttachmentStore works.

I would have tried to write a patch for this, but alas, I still can't quite 
finish my patch for using separate color for failed and unexpected results,
so prefer not to promise anything until I'm done ;-)


- Volodya




From slowrey at nextone.com  Thu Jan 15 20:57:55 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Thu, 15 Jan 2004 15:57:55 -0500
Subject: Accessing "global" context
Message-ID: <4006FED3.8090206@nextone.com>

After digging thru the archive and poring over the manual, I can't 
figure out how to get a test class to recognize context variables that 
are created in the "Edit Context" screen (or specified on the command 
line by the -C and -c run options). 

Accessing context created by resources is no problem - these are visible 
in the context dictionary passed to the Run() method.  But I haven't 
discovered where the "other" context information is loaded; the book 
doesn't clarify this beyond implying that the two contexts are the same 
and that they are visible to the test classes.

I'd like to be able to set up session-specific context that doesn't 
require the user to go in and edit a bunch of resources.  For example, 
my tests are all network oriented; they need IP addresses fed to them 
that vary with each user.  I can do this easily via a resource, but if 
then the (context-specific) IP addresses are stored in the database with 
the resource.  That doesn't seem right - now the resources need to be 
edited between users and, in the case of a shared database, would cause 
all kinds of headaches.

What am I missing?
-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040115/01ac53d2/attachment.html>

From mark at codesourcery.com  Fri Jan 16 06:55:29 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 15 Jan 2004 22:55:29 -0800
Subject: [qmtest] Accessing "global" context
In-Reply-To: <4006FED3.8090206@nextone.com>
References: <4006FED3.8090206@nextone.com>
Message-ID: <1074236129.3464.3.camel@minax.codesourcery.com>

On Thu, 2004-01-15 at 12:57, Scott Lowrey wrote:
> After digging thru the archive and poring over the manual, I can't
> figure out how to get a test class to recognize context variables that
> are created in the "Edit Context" screen (or specified on the command
> line by the -C and -c run options).  

They will be available in the "context" parameter to a test's "Run"
method.

Yours,

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From slowrey at nextone.com  Fri Jan 16 14:12:46 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Fri, 16 Jan 2004 09:12:46 -0500
Subject: [qmtest] Accessing "global" context
In-Reply-To: <1074236129.3464.3.camel@minax.codesourcery.com>
References: <4006FED3.8090206@nextone.com> <1074236129.3464.3.camel@minax.codesourcery.com>
Message-ID: <4007F15E.4080106@nextone.com>

Mark Mitchell wrote:

>On Thu, 2004-01-15 at 12:57, Scott Lowrey wrote:
>  
>
>>After digging thru the archive and poring over the manual, I can't
>>figure out how to get a test class to recognize context variables that
>>are created in the "Edit Context" screen (or specified on the command
>>line by the -C and -c run options).  
>>    
>>
>
>They will be available in the "context" parameter to a test's "Run"
>method.
>
>  
>
I fooled myself (easily done) by doing a "print context" in my test 
class to examine context, which only shows "qmtest.xx" keys.  I see now 
that the Context class is more than a simple dictionary.

Out of curiosity, why do I only see the qmtest keys when passing the 
context to "print"?


From seefeld at sympatico.ca  Fri Jan 16 14:27:35 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Fri, 16 Jan 2004 09:27:35 -0500
Subject: [qmtest] Accessing "global" context
References: <4006FED3.8090206@nextone.com> <1074236129.3464.3.camel@minax.codesourcery.com> <4007F15E.4080106@nextone.com>
Message-ID: <0f7189f63f2f031121dbfca09f2efaa54007f112@Orthosoft.ca>

Scott Lowrey wrote:

> Out of curiosity, why do I only see the qmtest keys when passing the 
> context to "print"?

objects are printable in python if they provide a special method
__str__ (or __repr__) that generates a stringified representation of
self: http://www.python.org/doc/current/ref/customization.html#l2h-182


  The 'Context' class derives from 'types.DictType', which provides
that, and as the derived class doesn't override it (adding its own
state) you only get to see the keys.

Regards,
		Stefan




From mark at codesourcery.com  Fri Jan 16 15:26:30 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 16 Jan 2004 07:26:30 -0800
Subject: [qmtest] Accessing "global" context
In-Reply-To: <0f7189f63f2f031121dbfca09f2efaa54007f112@Orthosoft.ca>
References: <4006FED3.8090206@nextone.com>
	 <1074236129.3464.3.camel@minax.codesourcery.com>
	 <4007F15E.4080106@nextone.com>
	 <0f7189f63f2f031121dbfca09f2efaa54007f112@Orthosoft.ca>
Message-ID: <1074266790.3464.16.camel@minax.codesourcery.com>


>   The 'Context' class derives from 'types.DictType', which provides
> that, and as the derived class doesn't override it (adding its own
> state) you only get to see the keys.

Obviously, it Would Be Nice if that were improved -- but it's not very
high on my list.

Thanks,

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From slowrey at nextone.com  Fri Jan 16 15:29:36 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Fri, 16 Jan 2004 10:29:36 -0500
Subject: [qmtest] Jade
In-Reply-To: <1073943724.3458.95.camel@minax.codesourcery.com>
References: <3FFEC512.80301@nextone.com> <1073943724.3458.95.camel@minax.codesourcery.com>
Message-ID: <40080360.2020500@nextone.com>

Mark Mitchell wrote:

>On Fri, 2004-01-09 at 07:13, Scott Lowrey wrote:
>  
>
>>Although I was able to get the QMTest docs to build at home (albeit
>>with a zillion warnings and messages about files being skipped because
>>of their MIME types), my Red Hat 9 system at work is choking because
>>it can't find Jade.  In pursuing that, I find that Jim Clark's Jade
>>(if that's the correct one) is old and doesn't even compile.  I sent a
>>bug report to the email listed at the web site.  
>>    
>>
>
>Red Hat provided an "openjade" RPM for Red Hat 8, and I believe, Red Hat
>9.  That is what we use.
>
>Thanks,
>
>  
>
Just to follow up, I ran redhat-config-packages and installed all the 
tools listed in the Authoring and Publishing category.  That fixed the 
problem: I now have openjade, jadetex, etc.   Make ran to completion 
with --enable-maintainer-mode in the config. 

Thanks.

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040116/007ee882/attachment.html>

From seefeld at sympatico.ca  Fri Jan 16 18:31:47 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Fri, 16 Jan 2004 13:31:47 -0500
Subject: RFE concerning 'Extension' class
Message-ID: <62a6a4d44852e87f6024fa0efd32642040082a54@Orthosoft.ca>

hi there,

I'd like to suggest some enhancements to the Extension class which (IMO) 
makes its use a bit cleaner.

Right now each Extension class derivative has to declare its arguments
within the class variable 'arguments', being a list of 'Fields'. These
Fields are self-documenting, as they contain their name, description,
and default value.

In the Extension constructor this list is mapped to actual instance 
variables for convenient use, and the values are (possibly) overridden
by arguments passed to the constructor.

I'd suggest to create a metaclass for the 'Extension' type that handles
this mapping in its '__init__' method.

However, instead of scanning the content of the 'arguments' variable,
it could scan the whole dictionary (of class variables) for variables
of type 'Field'. That would avoid the potential naming collisions
between class variables and fields, as fields *are* class variables.

It would also be more natural to write

class MyExtension(Extension):

   my_arg = TextField('hello', 'world')

instead of

class MyExtension(Extension):

   arguments = [TextField('my_arg', 'hello', 'world')]

Depending on the constraints on the design, such a change could be
implemented to be backward compatible to various degrees.
What do you think ?

Regards,
		Stefan

PS: the current implementation of the 'get_class_arguments' function
     contains a little bug: The given class' '__mro__' list is scanned
     for an 'arguments' variable which is interpreted as a list of
     Fields.
     However, as __mro__ may contain mixin classes not deriving from
     'Extension', there is a potential for a conflict where the class
     has such a variable but with a totally unrelated type / meaning.



From zack at codesourcery.com  Fri Jan 16 22:21:31 2004
From: zack at codesourcery.com (Zack Weinberg)
Date: Fri, 16 Jan 2004 14:21:31 -0800
Subject: [qmtest] RFE concerning 'Extension' class
In-Reply-To: <62a6a4d44852e87f6024fa0efd32642040082a54@Orthosoft.ca> (Stefan
 Seefeld's message of "Fri, 16 Jan 2004 13:31:47 -0500")
References: <62a6a4d44852e87f6024fa0efd32642040082a54@Orthosoft.ca>
Message-ID: <87u12vk00k.fsf@codesourcery.com>

Stefan Seefeld <seefeld at sympatico.ca> writes:

> hi there,
>
> I'd like to suggest some enhancements to the Extension class which
> (IMO) makes its use a bit cleaner.
>
> Right now each Extension class derivative has to declare its arguments
> within the class variable 'arguments', being a list of 'Fields'. These
> Fields are self-documenting, as they contain their name, description,
> and default value.
>
> In the Extension constructor this list is mapped to actual instance
> variables for convenient use, and the values are (possibly) overridden
> by arguments passed to the constructor.
>
> I'd suggest to create a metaclass for the 'Extension' type that handles
> this mapping in its '__init__' method.

This is a good idea.  The present design of Extension was laid down
when QMTest still supported Python 1.5.2 so we couldn't use
metaclasses.  There's several other places that could benefit from use
of metaclasses and other features of new-style objects; we just
haven't gotten round to doing the conversion.

> However, instead of scanning the content of the 'arguments' variable,
> it could scan the whole dictionary (of class variables) for variables
> of type 'Field'. That would avoid the potential naming collisions
> between class variables and fields, as fields *are* class variables.

I would like to see complete worked examples of this before I could
decide whether it was good or not.

zw


From mark at codesourcery.com  Sat Jan 17 02:55:22 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 16 Jan 2004 18:55:22 -0800
Subject: [qmtest] RFE concerning 'Extension' class
In-Reply-To: <87u12vk00k.fsf@codesourcery.com>
References: <62a6a4d44852e87f6024fa0efd32642040082a54@Orthosoft.ca>
	 <87u12vk00k.fsf@codesourcery.com>
Message-ID: <1074308122.3501.2.camel@minax.codesourcery.com>

On Fri, 2004-01-16 at 14:21, Zack Weinberg wrote:
> Stefan Seefeld <seefeld at sympatico.ca> writes:
> 
> > hi there,
> >
> > I'd like to suggest some enhancements to the Extension class which
> > (IMO) makes its use a bit cleaner.
> >
> > Right now each Extension class derivative has to declare its arguments
> > within the class variable 'arguments', being a list of 'Fields'. These
> > Fields are self-documenting, as they contain their name, description,
> > and default value.
> >
> > In the Extension constructor this list is mapped to actual instance
> > variables for convenient use, and the values are (possibly) overridden
> > by arguments passed to the constructor.
> >
> > I'd suggest to create a metaclass for the 'Extension' type that handles
> > this mapping in its '__init__' method.
> 
> This is a good idea. 

I think it's an elegant design, and if we could do it from scratch now,
it would be a good approach.

That said, I'm not sure yet if it merits a redesigning this working
interface, though.  

Is this the most valuable thing we could do to QMTest right now?

I suspect that we would be better off by adding new useful test classes,
or by making documentation improvements, as several have suggested. 
Yes, a more elegant system would be easier to document -- but would it
be *that* much easier to document?  And what about having to keep the
backwards-compatibility code around for the indefinite future?

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From seefeld at sympatico.ca  Sat Jan 17 04:01:34 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Fri, 16 Jan 2004 23:01:34 -0500
Subject: [qmtest] RFE concerning 'Extension' class
In-Reply-To: <1074308122.3501.2.camel@minax.codesourcery.com>
References: <62a6a4d44852e87f6024fa0efd32642040082a54@Orthosoft.ca>	 <87u12vk00k.fsf@codesourcery.com> <1074308122.3501.2.camel@minax.codesourcery.com>
Message-ID: <4008B39E.30001@sympatico.ca>

Mark Mitchell wrote:

> I suspect that we would be better off by adding new useful test classes,
> or by making documentation improvements, as several have suggested. 
> Yes, a more elegant system would be easier to document -- but would it
> be *that* much easier to document?  And what about having to keep the
> backwards-compatibility code around for the indefinite future?

Yes, I think that's the critical point: how much backward compatibility
do you need / want ? If all has to remain as it is now (in particular
the convention about a 'arguments' variable holding a list of Field
instances) a new implementation using a metaclass would indeed not
contribute much.
So I reply with a question: Do you think it is feasable to migrate
(at whatever pace is possible for you) from the current convention
to the one I suggest ?

Regards,
		Stefan

PS: I'll try anyways to reimplement the current Extension API using
     a metaclass, just to see how it would look...





From mark at codesourcery.com  Sat Jan 17 03:10:31 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 16 Jan 2004 19:10:31 -0800
Subject: [qmtest] RFE concerning 'Extension' class
In-Reply-To: <4008B39E.30001@sympatico.ca>
References: <62a6a4d44852e87f6024fa0efd32642040082a54@Orthosoft.ca>
	 <87u12vk00k.fsf@codesourcery.com>
	 <1074308122.3501.2.camel@minax.codesourcery.com>
	 <4008B39E.30001@sympatico.ca>
Message-ID: <1074309031.3501.14.camel@minax.codesourcery.com>


> So I reply with a question: Do you think it is feasable to migrate
> (at whatever pace is possible for you) from the current convention
> to the one I suggest ?

Excellent question!

I think that migration is going to be hard.

We actually have a not-insignificant body of test classes out there in
the wild at this point.  Things like the Database API are a little less
hard to change, but the basic test class API, including the "arguments"
variable, are going to be tricky to change.

I'm actually hoping that we're getting very close to the point of
completely freezing the API, i.e., of adding new functionality but not
breaking existing code ever again.  I don't (yet!) see your suggested
improvement as providing enough leverage to make it worth breaking
stuff.

If you've got spare cycles that you're willing to donate to QMTest,
working on documentation would be great.  You understand the system well
at this point, and if you wanted to update the parts of the manual that
talk about how to write extension classes, I'd be very honored to review
and comment on them.  I keep meaning to do this myself, but I'm not
getting there very quickly. :-(

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From seefeld at sympatico.ca  Sat Jan 17 04:32:52 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Fri, 16 Jan 2004 23:32:52 -0500
Subject: [qmtest] RFE concerning 'Extension' class
In-Reply-To: <1074309031.3501.14.camel@minax.codesourcery.com>
References: <62a6a4d44852e87f6024fa0efd32642040082a54@Orthosoft.ca>	 <87u12vk00k.fsf@codesourcery.com>	 <1074308122.3501.2.camel@minax.codesourcery.com>	 <4008B39E.30001@sympatico.ca> <1074309031.3501.14.camel@minax.codesourcery.com>
Message-ID: <4008BAF4.2050707@sympatico.ca>

Mark Mitchell wrote:

> We actually have a not-insignificant body of test classes out there in
> the wild at this point.  Things like the Database API are a little less
> hard to change, but the basic test class API, including the "arguments"
> variable, are going to be tricky to change.

ok, fair enough. But migrating existing code is only half of the story.
The other half is allowing a more elegant way to deal with arguments
for new code (extensions) to be written.
In other words: the question is not how to continuously support classes
that contain an 'arguments' class variable, but how to make it possible
to avoid such classes in the future.

> I'm actually hoping that we're getting very close to the point of
> completely freezing the API, i.e., of adding new functionality but not
> breaking existing code ever again.  I don't (yet!) see your suggested
> improvement as providing enough leverage to make it worth breaking
> stuff.

What started me thinking about this was the moment I realized that
classes as low level as 'Suite' had become an Extension, and I wondered
how to mitigate the consequences such a decision has (no direct loading
of these classes, non-intuitive API conventions such as the above, etc.)

As Zack points out, there are other interesting things we could do with
metaclasses. For example, using the very same technique I suggest, it
is possible to record all available extensions from their 'type constructor',
meaning even if extensions would be layed out as ordinary modules, it's
still possible to locate them and list all available extensions of a given
'kind', meaning you *can* have both, direct loading via import of an
extension class *and* all the metadata stuff you want (querying of data
about available extensions, serialization, etc.)

Regards,
		Stefan



From mark at codesourcery.com  Sat Jan 17 03:52:32 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 16 Jan 2004 19:52:32 -0800
Subject: [qmtest] RFE concerning 'Extension' class
In-Reply-To: <4008BAF4.2050707@sympatico.ca>
References: <62a6a4d44852e87f6024fa0efd32642040082a54@Orthosoft.ca>
	 <87u12vk00k.fsf@codesourcery.com>
	 <1074308122.3501.2.camel@minax.codesourcery.com>
	 <4008B39E.30001@sympatico.ca>
	 <1074309031.3501.14.camel@minax.codesourcery.com>
	 <4008BAF4.2050707@sympatico.ca>
Message-ID: <1074311551.3501.32.camel@minax.codesourcery.com>


> In other words: the question is not how to continuously support classes
> that contain an 'arguments' class variable, but how to make it possible
> to avoid such classes in the future.

Assuming that's a major problem...

I fully understand why this stuff is cool -- but I'm not quite sure what
problem it's solving.

Backing up, let me be very clear about our agenda here, which may of
course not be the same as yours. :-)

(1) Do not break things for existing customers and users -- they *hate*
that and we hate life when customers hate us. :-)

(2) Enlarge the total QMTest user-base.

I understand that (2) is helped by making things easier and cleaner to
program.  I totally get that.

However, I believe that the key thing that we could for (2) would be to
enhance the directly user-visible functionality.  For example, if we
provided a test class that made it very easy to test web applications,
maybe that would drive adoption into the web application area.  Or,
maybe -- as you suggested -- polishing up our compiler testing test
classes.  Or, GUI enhancements, such as creating a directory/file style
dialog box for selecting tests and resources and for creating new test
directories.

The truth is that if you write some cool code that makes the guts of
QMTest cleaner, I'm probably going to review it and we're probably going
to incorporate it.  That's all well and good.

But, really, I'd like to stay out of the guts as much as possible,
except for bug-fixing.  I'm much more excited about user-visible changes
that I am about tweaking the internal API.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From mark at codesourcery.com  Sat Jan 17 04:05:55 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 16 Jan 2004 20:05:55 -0800
Subject: [qmtest] Bug with editing attachments
In-Reply-To: <200401151038.57256.ghost@cs.msu.su>
References: <200311201509.38719.ghost@cs.msu.su>
	 <1074147085.11633.5.camel@minax.codesourcery.com>
	 <200401151038.57256.ghost@cs.msu.su>
Message-ID: <1074312355.3501.35.camel@minax.codesourcery.com>


> The problems with editing test that has an attachment are now gone. 

Yay!

> However, the other problem is still there. If I create a new test with 
> attachment, the location is like this:
> 
>    <location>/home/ghost/Work/Module/nm_model/tdb/history.qms/nightly.sh</location>

Oh, now I understand what you were saying!

> tests are run on a different machine. I'd still say that the 
> __MakeDataFilePath in xml_database is not right.

I think I agree in theory.  But, in practice, we can fix the bug with
this patch, so I've checked this in.

Thanks,

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC
-------------- next part --------------
2004-01-15  Mark Mitchell  <mark at codesourcery.com>

	* qm/test/classes/xml_database.py
	(XMLDatabase.__MakeDataFilePath): Use a relative, rather than
	absolute, path for the file location.

Index: qm/attachment.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/attachment.py,v
retrieving revision 1.21
diff -c -5 -p -r1.21 attachment.py
*** qm/attachment.py	15 Jan 2004 06:11:46 -0000	1.21
--- qm/attachment.py	17 Jan 2004 04:03:15 -0000
*************** class FileAttachmentStore(AttachmentStor
*** 293,302 ****
--- 293,307 ----
  
  
      def GetDataFile(self, location):
  
          if self.__root is not None:
+             # It might seem sensible to assert that the location be a
+             # relative path, but that would break backwards
+             # compatibility with older versions fo QMTest.  In those
+             # older versions, the XMLDatabase sometimes used an absolute
+             # path for attachment locations.
              return os.path.join(self.__root, location)
          else:
              return location
  
  
Index: qm/test/classes/xml_database.py
===================================================================
RCS file: /home/qm/Repository/qm/qm/test/classes/xml_database.py,v
retrieving revision 1.18
diff -c -5 -p -r1.18 xml_database.py
*** qm/test/classes/xml_database.py	15 Jan 2004 06:11:46 -0000	1.18
--- qm/test/classes/xml_database.py	17 Jan 2004 04:03:15 -0000
*************** class XMLDatabase(ExtensionDatabase):
*** 127,164 ****
          'file_name' -- The file name specified for the attachment."""
          
          # Convert the item's containing suite to a path.
          parent_suite_path \
              = os.path.dirname(self._GetPathFromLabel(item_id))
          
          # Construct a file name free of suspicious characters.
          base, extension = os.path.splitext(file_name)
          safe_file_name = qm.label.thunk(base) + extension
  
          data_file_path = os.path.join(parent_suite_path, safe_file_name)
-         full_data_file_path = os.path.join(self.GetRoot(), data_file_path)
          # Is the file name by itself OK in this directory?  It must not
          # have a file extension used by the XML database itself, and
          # there must be no other file with the same name there.
          if extension not in [self.GetTestExtension(),
                               self.GetSuiteExtension(),
                               self.GetResourceExtension()] \
!            and not os.path.exists(full_data_file_path):
!             return data_file_path
  
          # No good.  Construct alternate names by appending numbers
          # incrementally.
          index = 0
          while 1:
!             data_file_path = os.path.join(parent_suite_path, safe_file_name) \
!                              + ".%d" % index
!             full_data_file_path = os.path.join(self.GetRoot(), data_file_path)
!             if os.path.exists(full_data_file_path):
!                 index = index + 1
!                 continue
!             else:
!                 return data_file_path
  
  
      def __LoadItem(self, item_id, path, document_parser):
          """Load an item (a test or resource) from an XML file.
  
--- 127,164 ----
          'file_name' -- The file name specified for the attachment."""
          
          # Convert the item's containing suite to a path.
          parent_suite_path \
              = os.path.dirname(self._GetPathFromLabel(item_id))
+         # The relative part of the eventual full file name will be
+         # the part after the parent_suite_path and the directory
+         # name separator character(s).
+         abs_len = len(parent_suite_path) + len(os.sep)
          
          # Construct a file name free of suspicious characters.
          base, extension = os.path.splitext(file_name)
          safe_file_name = qm.label.thunk(base) + extension
  
          data_file_path = os.path.join(parent_suite_path, safe_file_name)
          # Is the file name by itself OK in this directory?  It must not
          # have a file extension used by the XML database itself, and
          # there must be no other file with the same name there.
          if extension not in [self.GetTestExtension(),
                               self.GetSuiteExtension(),
                               self.GetResourceExtension()] \
!            and not os.path.exists(data_file_path):
!             return data_file_path[abs_len:]
  
          # No good.  Construct alternate names by appending numbers
          # incrementally.
          index = 0
          while 1:
!             data_file_path = os.path.join(parent_suite_path,
!                                           safe_file_name + ".%d" % index)
!             if not os.path.exists(data_file_path):
!                 return data_file_path[abs_len:]
!             index = index + 1
  
  
      def __LoadItem(self, item_id, path, document_parser):
          """Load an item (a test or resource) from an XML file.
  

From mark at codesourcery.com  Mon Jan 19 00:00:33 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 18 Jan 2004 16:00:33 -0800
Subject: [qmtest] [repost] "reload extensions" command
In-Reply-To: <200311251823.32741.ghost@cs.msu.su>
References: <200311251823.32741.ghost@cs.msu.su>
Message-ID: <1074470433.4034.22.camel@minax.codesourcery.com>

On Tue, 2003-11-25 at 07:23, Vladimir Prus wrote:
> Hello,
> some time ago I've posted the attached message, which contained a patch to add 
> "reload extensions" functionality to the GUI. I don't think there was any 
> response to it, so I assume the message got lost.

Hah.  And, then, it was ignored for two more months, so you may have
thought that our mail server rejected emails with the exact MD5 checksum
of your message. :-)

> Is there any chance that patch will be accepted into mainline? I've just had 
> to restart QMTest GUI after changing extension module and that's not nice ;-)

I've very nervous about this patch because module-reloading is a
dangerous thing, in general.  Supporting this would, in general, mean
that both QMTest and extension-writers need to play by very careful
rules about what modules can and cannot do.

I think I'd be happier about a "Restart QMTest" option.  I've thought
about that before, because it would not only allow reloading modules but
also would allow easier experimentation with changes to QMTest itself. 
This option would just re-exec the QMTest executable, with roughly the
same command-line options it had before, but with the HTTP server
address/port set explicitly.

What do you think of that idea?

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From mark at codesourcery.com  Mon Jan 19 00:02:56 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 18 Jan 2004 16:02:56 -0800
Subject: [qmtest] instantiating suites
In-Reply-To: <f658c92ed06a6df9a09324a4ee63f5734004054a@Orthosoft.ca>
References: <f658c92ed06a6df9a09324a4ee63f5734004054a@Orthosoft.ca>
Message-ID: <1074470576.4034.26.camel@minax.codesourcery.com>

On Tue, 2004-01-13 at 06:56, Stefan Seefeld wrote:
> hi there,
> 
> I just realized that some code of mine implementing a test database
> doesn't work any more with a fresh update as the 'Suite' class has
> changed (i.e. has become an extension).
> 
> What is the suggested way to instantiate a suite as was possible
> up to the end of last year, i.e. via
> 
> Suite(self, id, implicit = 1, test_ids = tests, suite_ids = suites)
> 
> ? I notice an 'explicit suite' class now available as an extension,
> i.e. in the 'classes' directory. How can I access / instantiate that
> directly ?

Use:

 from explicit_suite import ExplicitSuite

> Is there any documentation available explaining why the extension
> mechanism works the way it does (and, in fact, what extensions are
> designed for, which classes should be extensions etc.; I'm a bit
> astonished to see Suite becoming an extension...)

We've wanted for a while to make it so that databases only store
extensions; that's a much more uniform model, and will permit some new
database features in future.

You've got all the documentation that exists at this point. :-(

The basic idea of extensions are that anything that test developers
(i.e., the people who take QMTest and create testsuites for end-users to
run) develop should be a subclass of Extension.

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From seefeld at sympatico.ca  Mon Jan 19 05:45:17 2004
From: seefeld at sympatico.ca (Stefan Seefeld)
Date: Mon, 19 Jan 2004 00:45:17 -0500
Subject: [qmtest] RFE concerning 'Extension' class
In-Reply-To: <87u12vk00k.fsf@codesourcery.com>
References: <62a6a4d44852e87f6024fa0efd32642040082a54@Orthosoft.ca> <87u12vk00k.fsf@codesourcery.com>
Message-ID: <400B6EED.4000406@sympatico.ca>

Zack Weinberg wrote:

> I would like to see complete worked examples of this before I could
> decide whether it was good or not.

Attached is a patch that implements my suggestion: The
Extension.Type now maps the 'Field' instances to class variables.

The way this is done right now changes the order of the arguments
in the _argument_list variable, so I adjusted the xmldb.api.test.derived
test accordingly. (I run 'python setup.py check --serial' to test my
changes and the other 'serial' tests pass).

It's certainly possible to preserve the old argument order, but since
I didn't want to use the _mro_ list (which would imply a lot of duplicate
work, as the merge is done for all classes in the inheritance hierarchy
anyways) I didn't spend any time figuring out how to get the ordering
right.

Having to modify the above 'derived' test, I added a 'b' argument,
just to illustrate the new syntax my patch makes possible. (The Field
constructors should be modified to make all arguments optional, so any
'new style' argument declarations don't need to repeat the name in the
Field.)

Regards,
		Stefan
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: metaclass_patch
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040119/9f6b12d7/attachment.ksh>

From mark at codesourcery.com  Mon Jan 19 07:57:03 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: 18 Jan 2004 23:57:03 -0800
Subject: QMTest 2.1 Beta Release
Message-ID: <1074499023.4034.44.camel@minax.codesourcery.com>

The beta release of QMTest 2.1 is now available at:

  http://www.codesourcery.com/qm/qmtest_downloads/qm-2.1-20040118

There are RPM and Windows packages, as well as a source tarball.

We would appreciate reports of problems with any of the packages, or
other bugs in QMTest that people think should delay the 2.1 release.

If there are no showstoppers, we expect to make the final 2.1 release
within a week or two.

Thanks,

-- 
Mark Mitchell <mark at codesourcery.com>
CodeSourcery, LLC



From slowrey at nextone.com  Sat Jan 24 15:35:24 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Sat, 24 Jan 2004 10:35:24 -0500
Subject: Suite Resource?
Message-ID: <401290BC.2080903@nextone.com>

I have a large suite of tests that I'd like to run twice, with my 
device-under-test configured a different way each time.

Seems there are three ways to set this up in QMTest:

1. Use a resource for each device configuration.

2. Use a prerequisite test for each device configuration.

3. Copy all the tests and embed the server config code in each.

Options 1 and 2 require that the tests in each suite be dependent on a 
different thing (either a resource or a prereq).  Doesn't that imply 
duplication of all tests?

Would it be better to define a "suite resource": a resource that applies 
to all tests in a suite but doesn't require me to go in an change the 
resource for every test?

Is there a better way to approach this?  Some creative use of resources 
and context, maybe?  The main goal is to keep my test definitions 
exactly as they are and to be able to easily say, "Run that suite again, 
but do this first.  Undo the change at the end of the suite."  To me, 
that sounds like a "suite resource" but I don't see that concept in the 
documentation.

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040124/e30cb61c/attachment.html>

From slowrey at nextone.com  Sat Jan 24 17:01:27 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Sat, 24 Jan 2004 12:01:27 -0500
Subject: Where Are My Suites?
Message-ID: <4012A4E7.7020200@nextone.com>

Before I fire off yet another rookie question, I have to say this:  I'm 
extremely impressed with QMTest so far.  The design is well-thought and 
the construction is professional.  Thanks!

OK, to preface my question: I've read the docs and scanned the email 
archive.  I've also run tried running 2.1 alongside my head-of-tree 
build but the question remains....

I've created an explicit test suite (using the File -> New Suite option) 
and added some tests from several implicit suites.  But the new suite 
doesn't show up in the GUI directory as I expected it to.  I can see the 
.qms file in the database and I can see it as an available suite in the 
"New Suite" screen, but I can't see a way to run just that suite in the 
GUI (it's runnable from the command line).

Am I missing something?
-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040124/43c64391/attachment.html>

From mark at codesourcery.com  Sun Jan 25 20:00:31 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 25 Jan 2004 12:00:31 -0800
Subject: [qmtest] Suite Resource?
In-Reply-To: <401290BC.2080903@nextone.com>
References: <401290BC.2080903@nextone.com>
Message-ID: <4014205F.4080906@codesourcery.com>

Scott Lowrey wrote:

> I have a large suite of tests that I'd like to run twice, with my 
> device-under-test configured a different way each time.

The way that QMTest is designed to handle that situation is via use of a custom test database.

The custom test database looks at all of the tests, and then creates the duplicates itself, programmatically, so that you do not have to do so.  That is similar to what
MountDatabase does (see classes/mount_database.py) but not precisely the same.  You would want to look at each included test and make two copies, probably in different implicit logical directories, and set different context variables for the two different sets of tests.

We've written code that does that duplication several times, but never in a way that was sufficiently general to merit inclusion in QMTest itself.  I'll add that to our list of requested enhancements.  

For the time being (assuming you don't want to hire us to write the code for you!), I'd suggest looking at MountDatabase and seeing if you can figure out how to do that
yourself.  Alternatively, as a quicky-and-dirty hack, you could use XML processing to simply duplicate the tests you've got, programmatically, before running the tests.  We use XML as a storage format precisely to make this kind of thing possible.

Yours,

-- 
Mark Mitchell
CodeSourcery, LLC
mark at codesourcery.com



From slowrey at nextone.com  Mon Jan 26 17:37:40 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Mon, 26 Jan 2004 12:37:40 -0500
Subject: Test Completion With Running Processes
Message-ID: <40155064.9000705@nextone.com>

I've noticed a discrepancy in the behavior between running tests on the 
command line and running them via the GUI.

Scenario:

Test code spawns several subprocesses.  Exception occurs while executing 
test code.  Bug in the test class (mine) leaves one process outstanding.

Result:

If this test is run via the command line ('qmtest run'), the exception 
is properly noted and the test ends with an ERROR result.  The 
outstanding process remains as an orphan.

If this test is run via the GUI, the browser loops waiting for the test 
to end.

Obviously, QMTest is waiting for all processes associated with it to end 
before declaring the test complete.  That is a Good Thing, I think.  But 
why does the command-line test come back as soon as the exception 
occurs, in spite of the outstanding process?

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040126/9d8e157d/attachment.html>

From mark at codesourcery.com  Wed Jan 28 19:54:24 2004
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 28 Jan 2004 11:54:24 -0800
Subject: QM
In-Reply-To: <4012A4E7.7020200@nextone.com>
References: <4012A4E7.7020200@nextone.com>
Message-ID: <40181370.4040109@codesourcery.com>


> I've created an explicit test suite (using the File -> New Suite 
> option) and added some tests from several implicit suites.  But the 
> new suite doesn't show up in the GUI directory as I expected it to.  I 
> can see the .qms file in the database and I can see it as an available 
> suite in the "New Suite" screen, but I can't see a way to run just 
> that suite in the GUI (it's runnable from the command line).
>
> Am I missing something?

No, that's a bug in QMTest, recently introduced when I made the Suite 
into an Extension.

Thanks for the report!

Fixed with the attached patch, which has been checked into CVS.

-- 
Mark Mitchell
CodeSourcery, LLC
(916) 791-8304
mark at codesourcery.com

-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: diffs
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040128/5552b705/attachment.ksh>

From slowrey at nextone.com  Wed Jan 28 21:59:06 2004
From: slowrey at nextone.com (Scott Lowrey)
Date: Wed, 28 Jan 2004 16:59:06 -0500
Subject: [qmtest] QMtest Suites
In-Reply-To: <40181370.4040109@codesourcery.com>
References: <4012A4E7.7020200@nextone.com> <40181370.4040109@codesourcery.com>
Message-ID: <401830AA.1070108@nextone.com>

Mark Mitchell wrote:

> Fixed with the attached patch, which has been checked into CVS.
>

Works great with one nit: Edit -> Delete Suite does nothing.

Whine whine whine.  :)

-- 
*Scott Lowrey*
NexTone Communications
Germantown, Maryland

/(240)912-1369/
www.nextone.com <http://www.nextone.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/qmtest/attachments/20040128/7a48ebb6/attachment.html>

