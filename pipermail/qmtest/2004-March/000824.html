<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] qmtest_gcc updates
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:qmtest%40codesourcery.com?Subject=Re%3A%20%5BPATCH%5D%20qmtest_gcc%20updates&In-Reply-To=%3C20040330182714.GA21725%40njs.ddts.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000822.html">
   <LINK REL="Next"  HREF="000825.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] qmtest_gcc updates</H1>
    <B>Nathaniel Smith</B> 
    <A HREF="mailto:qmtest%40codesourcery.com?Subject=Re%3A%20%5BPATCH%5D%20qmtest_gcc%20updates&In-Reply-To=%3C20040330182714.GA21725%40njs.ddts.net%3E"
       TITLE="[PATCH] qmtest_gcc updates">njs at pobox.com
       </A><BR>
    <I>Tue Mar 30 18:27:14 UTC 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000822.html">[qmtest] [PATCH] Small bug introduced by previous change
</A></li>
        <LI>Next message: <A HREF="000825.html">[PATCH] qmtest updates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#824">[ date ]</a>
              <a href="thread.html#824">[ thread ]</a>
              <a href="subject.html#824">[ subject ]</a>
              <a href="author.html#824">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>- Rework V3 testsuite to handle the no-compiler scenario.
- Use new Result.Quote method.

-- Nathaniel

-- 
&quot;...All of this suggests that if we wished to find a modern-day model
for British and American speech of the late eighteenth century, we could
probably do no better than Yosemite Sam.&quot;
-------------- next part --------------
Index: build_v3_dist
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/build_v3_dist,v
retrieving revision 1.1
diff -u -r1.1 build_v3_dist
--- build_v3_dist	18 Mar 2004 18:34:30 -0000	1.1
+++ build_v3_dist	30 Mar 2004 18:09:13 -0000
@@ -1,4 +1,6 @@
-#!/usr/bin/python 
+#!/usr/bin/env python 
+
+# Note that this script must be run with Python 2.3.
 
 import sys
 import os
@@ -20,8 +22,8 @@
                      help=&quot;Package version (default 1.0)&quot;)
 optparser.add_option(&quot;-o&quot;, &quot;--output&quot;, action=&quot;store&quot;,
                      dest=&quot;targetdir&quot;, metavar=&quot;DIR&quot;,
-                     help=&quot;Output directory&quot;
-                     &quot;(default qmtest_libstdcpp_GCCVER-PKGVER)&quot;)
+                     help=&quot;Output directory &quot;
+                     &quot;(default: qmtest_libstdcpp_GCCVER-PKGVER)&quot;)
 optparser.add_option(&quot;-f&quot;, &quot;--force&quot;, action=&quot;store_true&quot;,
                      dest=&quot;force&quot;, default=False,
                      help=&quot;If output directory already exists, delete it&quot;)
@@ -29,13 +31,10 @@
                      dest=&quot;baselines&quot;, default=[],
                      help=&quot;Additional result file to distribute (may be &quot;
                      &quot;used multiple times)&quot;)
-
-
-def usage(name):
-    print &quot;Usage: %s &lt;full-gcc-version&gt; &lt;source-directory&gt; &quot; \
-          &quot;&lt;destination-directory&gt;&quot; % name
-    print &quot;E.g., %s 3.3.3 gcc-3.3.3 my-gcc-3.3.3-package&quot; % name
-    sys.exit(2)
+optparser.add_option(&quot;-c&quot;, &quot;--config-guess&quot;, action=&quot;store&quot;,
+                     dest=&quot;config_guess&quot;, metavar=&quot;FILE&quot;,
+                     help=&quot;Path to config.guess &quot;
+                     &quot;(default: search in /usr/share/)&quot;)
 
 
 def ensure_dir(dir):
@@ -54,8 +53,36 @@
         os.mkdir(dir)
         
 
-def main(name, args):
+def add(source_file_or_dir, *target_path):
+    dest = os.path.join(*target_path)
+    ensure_dir(os.path.dirname(dest))
+    if os.path.isfile(source_file_or_dir):
+        shutil.copy(source_file_or_dir, dest)
+    elif os.path.isdir(source_file_or_dir):
+        shutil.copytree(source_file_or_dir, dest)
+    else:
+        assert 0, &quot;add() must be given a file or directory&quot;
+
+
+def generate(source_string, substitutions, *target_path):
+    dest = os.path.join(*target_path)
+    ensure_dir(os.path.dirname(dest))
+    f = open(dest, &quot;w&quot;)
+    f.write(source_string % substitutions)
+    f.close()
+
 
+class InstallRecorder(object):
+    def __init__(self, file_to_record_in):
+        ensure_dir(os.path.dirname(file_to_record_in))
+        self._file = open(file_to_record_in, &quot;w&quot;)
+    def __call__(self, path):
+        self._file.write(&quot;%s\n&quot; % path)
+
+
+def main(fullname, args):
+
+    name = os.path.basename(fullname)
     options, args = optparser.parse_args(args)
     if len(args) != 4:
         optparser.error(&quot;Wrong number of arguments&quot;)
@@ -80,41 +107,46 @@
         sys.exit(2)
 
     v3src = j(srcdir, &quot;libstdc++-v3&quot;)
-    ensure_dir(targetdir)
 
     # Open a file to record which directories exist (and thus need
     # installing).
-    content_files = open(j(targetdir, &quot;contents&quot;), &quot;w&quot;)
+    install = InstallRecorder(j(targetdir, &quot;share-contents&quot;))
 
-    # Mark that this will be a standalone installation, for later use by
-    # the QMTest scripts.
-    f = open(j(targetdir, &quot;THIS-IS-STANDALONE-V3&quot;), &quot;w&quot;)
-    # In case we need to version stuff later:
-    f.write(&quot;1\n&quot;)
-    f.close()
-    content_files.write(&quot;THIS-IS-STANDALONE-V3\n&quot;)
+    # Put 'config.guess' in.
+    if options.config_guess is None:
+        config_guesses = glob.glob(&quot;/usr/share/*/config.guess&quot;)
+        if not config_guesses:
+            optparser.error(&quot;Cannot find config.guess, use &quot;
+                            &quot;--config-guess&quot;) 
+        config_guess = config_guesses[0]
+    else:
+        config_guess = options.config_guess
+    add(config_guess, targetdir, &quot;config.guess&quot;)
+
+    # Mark that this will be a standalone installation, for later
+    # detection by the QMTest harness.  We write the numeral '1' in case
+    # we need versioning information later.
+    generate(&quot;1\n&quot;, {}, targetdir, &quot;THIS-IS-STANDALONE-V3&quot;)
+    install(&quot;THIS-IS-STANDALONE-V3&quot;)
 
     # Copy gcc stuff over:
-    shutil.copytree(j(v3src, &quot;testsuite&quot;), j(targetdir, &quot;testsuite&quot;))
-    content_files.write(&quot;testsuite\n&quot;)
-    shutil.copytree(j(v3src, &quot;po&quot;), j(targetdir, &quot;po&quot;))
-    content_files.write(&quot;po\n&quot;)
+    add(j(v3src, &quot;testsuite&quot;), targetdir, &quot;testsuite&quot;)
+    install(&quot;testsuite&quot;)
+    add(j(v3src, &quot;po&quot;), targetdir, &quot;po&quot;)
+    install(&quot;po&quot;)
     ensure_dir(j(targetdir, &quot;config&quot;))
-    shutil.copytree(j(v3src, &quot;config&quot;, &quot;abi&quot;),
-                    j(targetdir, &quot;config&quot;, &quot;abi&quot;))
-    content_files.write(&quot;config\n&quot;)
+    add(j(v3src, &quot;config&quot;, &quot;abi&quot;), targetdir, &quot;config&quot;, &quot;abi&quot;)
+    install(&quot;config&quot;)
     
     # gcc 3.4 has a scripts dir that we need.
     if os.path.exists(j(v3src, &quot;scripts&quot;)):
-        shutil.copytree(j(v3src, &quot;scripts&quot;), j(targetdir, &quot;scripts&quot;))
-        content_files.write(&quot;scripts\n&quot;)
+        add(j(v3src, &quot;scripts&quot;), targetdir, &quot;scripts&quot;)
+        install(&quot;scripts&quot;)
 
     # Copy in QMTest extension classes.
-    ensure_dir(j(targetdir, &quot;qm-classes&quot;))
-    content_files.write(&quot;qm-classes\n&quot;)
-    shutil.copytree(qmtcdir, j(targetdir, &quot;qm-classes&quot;, &quot;qmtc&quot;))
-    shutil.copytree(qmtest_gccdir,
-                    j(targetdir, &quot;qm-classes&quot;, &quot;qmtest_gcc&quot;))
+    add(qmtcdir, targetdir, &quot;qm-classes&quot;, &quot;qmtc&quot;)
+    add(qmtest_gccdir, targetdir, &quot;qm-classes&quot;, &quot;qmtest_gcc&quot;)
+    install(&quot;qm-classes&quot;)
     # And then clean them up a bit (remove backup files, compiled files,
     # and CVS/ directories).
     for g in &quot;*~&quot;, &quot;*.pyc&quot;, &quot;*.pyo&quot;:
@@ -125,49 +157,51 @@
 
     # Copy over any supplied baselines.
     ensure_dir(j(targetdir, &quot;qm-baselines&quot;))
-    content_files.write(&quot;qm-baselines\n&quot;)
+    install(&quot;qm-baselines&quot;)
     for b in options.baselines:
-        shutil.copyfile(b, j(targetdir, &quot;qm-baselines&quot;,
-                             os.path.basename(b)))
+        add(b, targetdir, &quot;qm-baselines&quot;, os.path.basename(b))
 
-    # Now create the misc. files.
-    miscdir = j(targetdir, &quot;qm-misc&quot;)
-    ensure_dir(miscdir)
-    content_files.write(&quot;qm-misc\n&quot;)
+    # Copy this script into the package.
+    add(__file__, targetdir, &quot;build_v3_dist&quot;)
 
+    # Set up the substitutions dict used by all our templates.
     substitutions = {&quot;prog_name&quot;: name,
+                     &quot;prog_fullname&quot;: fullname,
                      &quot;gcc_version&quot;: gcc_version,
                      &quot;pkg_version&quot;: pkg_version,
                      &quot;prog_args&quot;: &quot; &quot;.join(args),
                      &quot;user&quot;: getpass.getuser(),
-                     &quot;time&quot;: time.strftime(&quot;%Y-%m-%d %H:%M:%S &quot;),
+                     &quot;time&quot;: time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;),
                      }
 
-    f = open(j(miscdir, &quot;locale-Makefile&quot;), &quot;w&quot;)
-    f.write(locale_Makefile % substitutions)
-    f.close()
-
-    f = open(j(miscdir, &quot;util-Makefile&quot;), &quot;w&quot;)
-    f.write(util_Makefile % substitutions)
+    # Munge testsuite_hooks.h to make testsuite executables
+    # relocatable.
+    f = open(j(targetdir, &quot;testsuite&quot;, &quot;testsuite_hooks.h&quot;), &quot;a&quot;)
+    f.write(testsuite_hooks_addendum % substitutions)
     f.close()
+    
+    # Now create the misc. files.
+    miscdir = j(targetdir, &quot;qm-misc&quot;)
+    ensure_dir(miscdir)
+    install(&quot;qm-misc&quot;)
 
-    # And the distribution-level files.
-    f = open(j(targetdir, &quot;README&quot;), &quot;w&quot;)
-    f.write(README_file % substitutions)
-    f.close()
+    generate(locale_Makefile, substitutions, miscdir, &quot;locale-Makefile&quot;)
 
-    f = open(j(targetdir, &quot;PKGINFO&quot;), &quot;w&quot;)
-    f.write(PKGINFO_file % substitutions)
-    f.close()
+    generate(util_Makefile, substitutions, miscdir, &quot;util-Makefile&quot;)
 
-    f = open(j(targetdir,
-               &quot;qmtest_libstdcpp_%(gcc_version)s.spec&quot;
-               % substitutions),
-             &quot;w&quot;)
-    f.write(spec_file % substitutions)
-    f.close()
+    # And the distribution-level files.
+    generate(README_file, substitutions, targetdir, &quot;README&quot;)
+    generate(PKGINFO_file, substitutions, targetdir, &quot;PKGINFO&quot;)
+    generate(spec_file, substitutions,
+             targetdir, &quot;qmtest_libstdcpp_%(gcc_version)s.spec&quot;
+                        % substitutions)
+    generate(build_binary_testsuite_file, substitutions,
+             targetdir, &quot;build_binary_testsuite&quot;)
+    os.chmod(j(targetdir, &quot;build_binary_testsuite&quot;), 0755)
     
 
+## All the templates for generated files:
+
 locale_Makefile = &quot;&quot;&quot;\
 # Do not edit -- this file automatically generated by %(prog_name)s.
 # Makefile to build locale files needed by libstdc++-v3 testsuite.
@@ -348,7 +382,7 @@
      CompilerTable.cplusplus_path=g++
      CompilerTable.cplusplus_options=
      DejaGNUTest.target=i686-pc-linux-gnu
-     V3Init.scratch_dir=scratch
+     V3Test.scratch_dir=scratch
 
   You should adjust the &quot;DejaGNUTest.target&quot; line to indicate the GNU
   triplet for your operating system.
@@ -386,12 +420,23 @@
     <A HREF="http://www.codesourcery.com/qm/qmtest_manual">http://www.codesourcery.com/qm/qmtest_manual</A>
 &quot;&quot;&quot;
 
+testsuite_hooks_addendum = &quot;&quot;&quot;
+
+// Following added automatically by %(prog_name)s:
+#ifdef LOCALEDIR
+#error &quot;LOCALEDIR should not be defined for standalone testing; \
+set environment variable V3_LOCALEDIR instead&quot;
+#endif
+#include &lt;cstdlib&gt;
+#define LOCALEDIR (std::getenv(&quot;V3_LOCALEDIR&quot;))
+&quot;&quot;&quot;
+
 PKGINFO_file = &quot;&quot;&quot;\
 This package generated automatically by %(prog_name)s.
 
 Invoked by %(user)s at %(time)s.
 Call was:
-  $ %(prog_name)s %(prog_args)s
+  $ %(prog_fullname)s %(prog_args)s
 
 &quot;&quot;&quot;
 
@@ -407,7 +452,10 @@
 BuildRoot:   %%{_tmppath}/%%{name}-buildroot
 Source:      qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s.tar.gz
 Vendor:      CodeSourcery LLC
-BuildArchitectures: noarch
+# If we let RPM detect dependencies, it will get the idea that this
+# package requires a specific version of libstdc++.so, and that is
+# unhelpful:
+AutoReqProv: no
 
 %%description
 This package includes the libstdc++-v3 testsuite from gcc version
@@ -421,16 +469,26 @@
 
 %%install
 rm -rf $RPM_BUILD_ROOT
-DIR=$RPM_BUILD_ROOT/usr/share/qmtest_libstdcpp_%(gcc_version)s
-mkdir -p $DIR
-for thing in `cat contents`; do
+
+# We do the building first, because some of the files generated will be
+# installed later.
+LIBDIR=$RPM_BUILD_ROOT/usr/lib/qmtest_libstdcpp_%(gcc_version)s
+mkdir -p `dirname $LIBDIR`
+./build_binary_testsuite $LIBDIR 2&gt;&amp;1 | tee BUILD-DETAILS
+
+SHAREDIR=$RPM_BUILD_ROOT/usr/share/qmtest_libstdcpp_%(gcc_version)s
+mkdir -p $SHAREDIR
+for thing in `cat share-contents`; do
     if [ -d &quot;$thing&quot; ]; then
-        cp -r &quot;$thing&quot; &quot;$DIR/$thing&quot;
+        cp -r &quot;$thing&quot; &quot;$SHAREDIR/$thing&quot;
     else
-        cp &quot;$thing&quot; &quot;$DIR/$thing&quot;
+        cp &quot;$thing&quot; &quot;$SHAREDIR/$thing&quot;
     fi
 done
 
+find $LIBDIR -name '*.pyc' -o -name '*.pyo' -print0 | xargs -0 rm -f
+find $SHAREDIR -name '*.pyc' -o -name '*.pyo' -print0 | xargs -0 rm -f
+
 %%clean
 rm -rf $RPM_BUILD_ROOT
 
@@ -438,13 +496,239 @@
 # Install all files as root:
 %%defattr(-,root,root)
 /usr/share/qmtest_libstdcpp_%(gcc_version)s/
+/usr/lib/qmtest_libstdcpp_%(gcc_version)s/
 %%doc README
+%%doc PKGINFO
+%%doc BUILD-DETAILS
+%%doc executable-gen.qmr
+%%doc build_v3_dist
+%%doc build_binary_testsuite
 
 %%changelog
+* Mon Mar 29 2004 Nathaniel Smith &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">njs at codesourcery.com</A>&gt; 
+- Rework for no-compiler version of testsuite.
+
 * Tue Mar 16 2004 Nathaniel Smith &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">njs at codesourcery.com</A>&gt; 
 - Initial release.
 
 &quot;&quot;&quot;
 
+
+build_binary_testsuite_file = &quot;&quot;&quot;\
+#!/usr/bin/env python
+
+# This script builds the executables needed for testing libstdc++
+# without a compiler, and then runs the tests to generate a baseline.
+# You should ensure that a canonical version of g++ is in your PATH, and
+# a canonical version of libstdc++ in your LD_LIBRARY_PATH, before
+# running this script; they will be taken as the gold standard against
+# which tested versions will be compared.
+#
+# It must be run from the directory that contains the standalone V3
+# distribution.
+
+usage = \&quot;\&quot;\&quot;\\
+Usage:
+    %%(progname)s [executable-output-directory] [g++ to use] \\\\
+       [directory containing libstdc++ to use]
+If the first argument is not given, it defaults to &quot;qm-executables&quot;.  If
+the last two arguments are not given, defaults will be found in
+PATH/LD_LIBRARY_PATH.
+\&quot;\&quot;\&quot;
+
+import sys
+import os
+import os.path
+import tempfile
+import shutil
+import atexit
+import glob
+
+def error(*msgs):
+    sys.stderr.write(&quot;ERROR: &quot; + &quot;&quot;.join(msgs) + &quot;\\n&quot;)
+    sys.stderr.flush()
+
+def log(*msgs):
+    prefix = &quot;%%s: &quot; %% progname
+    sys.stdout.write(prefix  + &quot;&quot;.join(msgs) + &quot;\\n&quot;)
+    sys.stdout.flush()
+
+def run_and_log(cmdline, failure_ok=False):
+    log(&quot;Running command: %%s&quot; %% cmdline)
+    log(&quot;Output:&quot;)
+    status = os.system(cmdline)
+    if status != 0 and not failure_ok:
+        error(&quot;Command did not complete successfully.&quot;)
+        error(&quot;Exit status: %%i&quot; %% status)
+        sys.exit(1)
+    log(&quot;Execution complete, status = %%i.&quot; %% status)
+    return status
+
+def resolve_executable(name):
+    if os.path.isabs(name):
+        return name
+    if os.sep in name:
+        return os.path.abspath(name)
+    log(&quot;Searching PATH for %%s.&quot; %% name)
+    path = os.environ.get(&quot;PATH&quot;, &quot;&quot;).split(os.pathsep)
+    for dir in path:
+        candidate = os.path.join(dir, name)
+        if os.path.exists(candidate):
+            return os.path.abspath(candidate)
+    error(&quot;Cannot find executable %%s.&quot; %% name)
+    sys.exit(1)
+
+if not os.path.exists(&quot;THIS-IS-STANDALONE-V3&quot;):
+    error(&quot;must run from root of standalone libstdc++ test &quot;
+          &quot;distribution.&quot;)
+    sys.exit(2)
+
+# This global variable is used directly by log().
+full_progname = sys.argv[0]
+progname = os.path.basename(full_progname)
+args = sys.argv[1:]
+
+log(&quot;Called as: %%s %%s&quot; %% (full_progname, &quot; &quot;.join(args)))
+
+## Process arguments.
+if not 0 &lt;= len(args) &lt;= 3:
+    error(&quot;bad command line.&quot;)
+    sys.stderr.write(usage %% {&quot;progname&quot;: progname})
+    sys.exit(2)
+
+## Find compiler output directory.
+if args:
+    compiler_output_dir = args.pop(0)
+else:
+    compiler_output_dir = &quot;qm-executables&quot;
+
+## Find g++.
+if args:
+    gpp_path = args.pop(0)
+else:
+    gpp_path = &quot;g++&quot;
+gpp_path = resolve_executable(gpp_path)
+
+log(&quot;Using g++: %%s&quot; %% gpp_path)
+run_and_log(&quot;%%s --version&quot; %% gpp_path)
+log()
+
+## Find libstdc++.
+if args:
+    libstdcpp_path = args.pop(0)
+    curr = os.environ.get(&quot;LD_LIBRARY_PATH&quot;, &quot;&quot;)
+    new = &quot;%%s:%%s&quot; %% (libstdcpp_path, curr)
+    os.environ[&quot;LD_LIBRARY_PATH&quot;] = new
+
+log('Using LD_LIBRARY_PATH=&quot;%%s&quot;.'
+    %% os.environ.get(&quot;LD_LIBRARY_PATH&quot;, &quot;&quot;))
+log()
+
+## Find qmtest.
+qmtest_path = resolve_executable(&quot;qmtest&quot;)
+log(&quot;Using qmtest: %%s&quot; %% qmtest_path)
+run_and_log(&quot;%%s --version&quot; %% qmtest_path)
+log()
+
+## Set up the compiler output directory.
+if os.path.exists(compiler_output_dir):
+    error(&quot;output directory %%s already exists.&quot; %% compiler_output_dir)
+    sys.exit(1)
+
+os.mkdir(compiler_output_dir)
+
+## Create the temporary scratch directory.
+if hasattr(tempfile, &quot;mkdtemp&quot;):
+    tmpdir = tempfile.mkdtemp()
+else:
+    tmpdir = tempfile.mktemp()
+    os.mkdir(tmpdir)
+atexit.register(shutil.rmtree, tmpdir)
+
+## Find the target triplet.
+(config_guess_in, config_guess_out) = os.popen4(&quot;./config.guess&quot;)
+config_guess_in.close()
+target_triplet = config_guess_out.read()
+target_triplet = target_triplet.strip()
+assert &quot;-&quot; in target_triplet, &quot;Bad target triplet&quot;
+log(&quot;Using target triplet: %%s&quot; %% target_triplet)
+log()
+
+## Create the basic context to use.
+log(&quot;Creating V3 context file.&quot;)
+context_path = os.path.join(tmpdir, &quot;__v3_context__&quot;)
+f = open(context_path, &quot;w&quot;)
+f.write(\&quot;\&quot;\&quot;\\
+CompilerTable.languages=cplusplus
+CompilerTable.cplusplus_kind=GCC
+CompilerTable.cplusplus_options=
+CompilerTable.cplusplus_path=%%(gpp_path)s
+DejaGNUTest.target=%%(target_triplet)s
+V3Test.scratch_dir=%%(tmpdir)s
+V3Test.compiler_output_dir=%%(compiler_output_dir)s
+\&quot;\&quot;\&quot; %% locals())
+f.close()
+
+## Set up QMTest environment variables.
+class_paths = [os.path.abspath(os.path.join(&quot;qm-classes&quot;, pkg))
+               for pkg in &quot;qmtc&quot;, &quot;qmtest_gcc&quot;]
+qmtest_class_path = os.pathsep.join(class_paths)
+os.environ[&quot;QMTEST_CLASS_PATH&quot;] = qmtest_class_path
+log('Using QMTEST_CLASS_PATH=&quot;%%s&quot;' %% qmtest_class_path)
+log()
+
+## Create the test database we use.
+log(&quot;Creating V3 test database.&quot;)
+dbpath = os.path.join(tmpdir, &quot;__v3_db__&quot;)
+srcdir = os.path.abspath(&quot;testsuite&quot;)
+run_and_log(&quot;qmtest -D %%(dbpath)s create-tdb &quot;
+                     &quot;-c v3_database.V3Database &quot;
+                     &quot;-a srcdir=%%(srcdir)s&quot; %% locals())
+log()
+
+## Okay, we're ready to run the tests for the first time.
+log(&quot;Running QMTest to generate executables.&quot;)
+log(&quot;Results stored in executable-gen.qmr&quot;)
+status = run_and_log(&quot;qmtest -D %%(dbpath)s run &quot;
+                     &quot;-C %%(context_path)s --format=brief &quot;
+                     &quot;-o executable-gen.qmr&quot;
+                     %% locals(),
+                     failure_ok=True)
+if status == 0 or (os.WIFEXITED(status) and os.WEXITSTATUS(status) == 1):
+    log(&quot;Acceptable output status.&quot;)
+else:
+    error(&quot;qmtest exited unsuccessfully.&quot;)
+    sys.exit(1)
+
+## Clean the irrelevant non-executable output files; they take up a lot of
+## space.
+log(&quot;Cleaning up executable directory.&quot;)
+for junk in glob.glob(os.path.join(compiler_output_dir, &quot;*.[sio]&quot;)):
+    os.unlink(junk)
+    log(&quot;    Deleted: %%s&quot; %% junk)
+
+## We have the executables; all is well.  Now we'll run it again to
+## generate the baseline result file.
+log(&quot;Running QMTest again to generate baseline results.&quot;)
+baseline_basename = &quot;%%s.qmr&quot; %% target_triplet
+baseline = os.path.abspath(os.path.join(&quot;qm-baselines&quot;,
+                                        baseline_basename))
+log(&quot;Results stored in %%s&quot; %% baseline)
+run_and_log(&quot;qmtest -D %%(dbpath)s run &quot;
+            &quot;-C %%(context_path)s --format=brief &quot;
+            &quot;-c V3Test.have_compiler=no &quot;
+            &quot;-o %%(baseline)s&quot;
+            %% locals(),
+            failure_ok=True)
+if status == 0 or (os.WIFEXITED(status) and os.WEXITSTATUS(status) == 1):
+    log(&quot;Acceptable output status.&quot;)
+else:
+    error(&quot;qmtest exited unsuccessfully.&quot;)
+    sys.exit(1)
+
+## All done.
+log(&quot;All done.&quot;)
+&quot;&quot;&quot;
+        
 if __name__ == &quot;__main__&quot;:
     main(sys.argv[0], sys.argv[1:])
Index: gpp_init.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gpp_init.py,v
retrieving revision 1.8
diff -u -r1.8 gpp_init.py
--- gpp_init.py	18 Mar 2004 18:42:17 -0000	1.8
+++ gpp_init.py	30 Mar 2004 18:09:13 -0000
@@ -82,7 +82,7 @@
                                 &quot;testsuite_flags&quot;),
                    &quot;--build-includes&quot;]
         result[&quot;GPPInit.testsuite_flags_command&quot;] \
-            = &quot;&lt;pre&gt;&quot; + &quot; &quot;.join(command) + &quot;&lt;/pre&gt;&quot;
+            = result.Quote(&quot; &quot;.join(command))
         try:
             executable = RedirectedExecutable()
             executable.Run(command)
Index: v3_test.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/v3_test.py,v
retrieving revision 1.2
diff -u -r1.2 v3_test.py
--- v3_test.py	18 Mar 2004 22:26:11 -0000	1.2
+++ v3_test.py	30 Mar 2004 18:09:13 -0000
@@ -41,7 +41,22 @@
                           &quot;LD_LIBRARY_PATH_64&quot;, &quot;DYLD_LIBRARY_PATH&quot;]
 &quot;&quot;&quot;All the different envvars that might mean LD_LIBRARY_PATH.&quot;&quot;&quot;
 
-class V3Init(Resource):
+class V3Base(object):
+    &quot;&quot;&quot;Methods required by all V3 classes.&quot;&quot;&quot;
+
+    def _HaveCompiler(self, context):
+        &quot;&quot;&quot;Returns true if we have a compiler.&quot;&quot;&quot;
+
+        if not context.has_key(&quot;V3Test.have_compiler&quot;):
+            # By default we assume there is a compiler.
+            return True
+        
+        # But if there is a context key, we trust it.
+        return qm.parse_boolean(context[&quot;V3Test.have_compiler&quot;])
+
+
+
+class V3Init(Resource, V3Base):
     &quot;&quot;&quot;All V3 tests depend on one of these for setup.&quot;&quot;&quot;
 
     def SetUp(self, context, result):
@@ -51,6 +66,24 @@
         srcdir = self.GetDatabase().GetRoot()
         target = context[&quot;DejaGNUTest.target&quot;]
 
+        # If there is a compiler output directory given, ensure the path
+        # is absolute, and ensure it exists.
+        if context.has_key(&quot;V3Test.compiler_output_dir&quot;):
+            compiler_outdir = context[&quot;V3Test.compiler_output_dir&quot;]
+            compiler_outdir = os.path.abspath(compiler_outdir)
+            context[&quot;V3Test.compiler_output_dir&quot;] = compiler_outdir
+            if not os.path.exists(compiler_outdir):
+                os.mkdir(compiler_outdir)
+        else:
+            compiler_outdir = None
+                
+        if not self._HaveCompiler(context) and compiler_outdir is None:
+            result.SetOutcome(result.ERROR,
+                              &quot;If have_compiler is false, then &quot;
+                              &quot;V3Test.compiler_output_dir must be &quot;
+                              &quot;provided&quot;)
+            return
+
         # Are we using the standalone testsuite to test an installed
         # libstdc++/g++, or the integrated testsuite to test a
         # just-built libstdc++/g++?  Check for the magic file that the
@@ -60,11 +93,12 @@
         standalone = os.path.exists(standalone_marker)
         if standalone:
             standalone_root = os.path.join(srcdir, &quot;..&quot;)
-        context[&quot;V3Init.is_standalone&quot;] = standalone
+        context[&quot;V3Test.is_standalone&quot;] = standalone
 
         # Find the compiler.
-        compilers = context[&quot;CompilerTable.compiler_table&quot;]
-        compiler = compilers[&quot;cplusplus&quot;]
+        if self._HaveCompiler(context):
+            compilers = context[&quot;CompilerTable.compiler_table&quot;]
+            compiler = compilers[&quot;cplusplus&quot;]
 
 
         if not standalone:
@@ -100,16 +134,16 @@
             # Our code always refers to this directory as 'outdir' for
             # parallelism with the DejaGNU code we emulate, but we call
             # it &quot;scratch_dir&quot; for UI purposes.
-            if context.has_key(&quot;V3Init.outdir&quot;):
+            if context.has_key(&quot;V3Test.outdir&quot;):
                 result.SetOutcome(result.ERROR,
-                                  &quot;Set V3Init.scratch_dir, not outdir&quot;)
+                                  &quot;Set V3Test.scratch_dir, not outdir&quot;)
                 return
-            outdir = context[&quot;V3Init.scratch_dir&quot;]
+            outdir = context[&quot;V3Test.scratch_dir&quot;]
             outdir = os.path.abspath(outdir)
             if not os.path.exists(outdir):
                 os.mkdir(outdir)
             
-        context[&quot;V3Init.outdir&quot;] = outdir
+        context[&quot;V3Test.outdir&quot;] = outdir
 
         # Ensure that the message format files are available.
         # This requires different commands depending on whether we're
@@ -118,40 +152,55 @@
             locale_dir = os.path.join(blddir, &quot;po&quot;)
             make_command = [&quot;make&quot;, &quot;-j1&quot;, &quot;check&quot;]
         else:
-            # Standalone build needs to set up the locale stuff in its
-            # own directory.
-            locale_dir = os.path.join(outdir, &quot;qm_locale&quot;)
-            try:
-                os.mkdir(locale_dir)
-            except OSError:
-                pass
-            makefile_in = open(os.path.join(standalone_root,
-                                                  &quot;qm-misc&quot;,
-                                                  &quot;locale-Makefile&quot;))
-            makefile_str = makefile_in.read()
-            makefile_str = makefile_str.replace(&quot;@ROOT@&quot;,
-                                                standalone_root)
-            makefile_out = open(os.path.join(locale_dir, &quot;Makefile&quot;),
-                                &quot;w&quot;)
-            makefile_out.write(makefile_str)
-            makefile_out.close()
-            make_command = [&quot;make&quot;, &quot;-j1&quot;, &quot;locales&quot;]
+            if self._HaveCompiler(context):
+                # Standalone build needs to set up the locale stuff in its
+                # own directory.
+                locale_dir = os.path.join(outdir, &quot;qm_locale&quot;)
+                try:
+                    os.mkdir(locale_dir)
+                except OSError:
+                    pass
+                makefile_in = open(os.path.join(standalone_root,
+                                                &quot;qm-misc&quot;,
+                                                &quot;locale-Makefile&quot;))
+                makefile_str = makefile_in.read()
+                makefile_str = makefile_str.replace(&quot;@ROOT@&quot;,
+                                                    standalone_root)
+                makefile_out = open(os.path.join(locale_dir,
+                                                 &quot;Makefile&quot;),
+                                    &quot;w&quot;)
+                makefile_out.write(makefile_str)
+                makefile_out.close()
+                make_command = [&quot;make&quot;, &quot;-j1&quot;, &quot;locales&quot;]
+            else:
+                # We're standalone without a compiler; we'll use the
+                # locale dir in the compiler output directory directly.
+                locale_dir = os.path.join(compiler_outdir, &quot;qm_locale&quot;)
+            # Either way, we need to provide the locale directory as an
+            # environment variable, _not_ as a #define.
+            context[&quot;V3Init.env_V3_LOCALEDIR&quot;] = locale_dir
 
-        make_executable = RedirectedExecutable()
-        status = make_executable.Run(make_command, dir=locale_dir)
-        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
-            result.SetOutcome(result.ERROR,
-                              &quot;Error building locale information&quot;,
-                              {&quot;status&quot;: str(status),
-                               &quot;stdout&quot;: &quot;&lt;pre&gt;&quot;
-                                         + make_executable.stdout
-                                         + &quot;&lt;/pre&gt;&quot;,
-                               &quot;stderr&quot;: &quot;&lt;pre&gt;&quot;
-                                         + make_executable.stderr
-                                         + &quot;&lt;/pre&gt;&quot;,
-                               &quot;command&quot;: &quot; &quot;.join(make_command),
-                               })
-            return
+        # Now do the actual compiling, if possible.
+        if self._HaveCompiler(context):
+            make_executable = RedirectedExecutable()
+            status = make_executable.Run(make_command, dir=locale_dir)
+            if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
+                q_stdout = result.Quote(make_executable.stdout)
+                q_stderr = result.Quote(make_executable.stderr)
+                result.SetOutcome(result.ERROR,
+                                  &quot;Error building locale information&quot;,
+                                  {&quot;status&quot;: str(status),
+                                   &quot;stdout&quot;: q_stdout,
+                                   &quot;stderr&quot;: q_stderr,
+                                   &quot;command&quot;: &quot; &quot;.join(make_command),
+                                   })
+                return
+
+            if compiler_outdir is not None:
+                co_ld = os.path.join(compiler_outdir, &quot;qm_locale&quot;)
+                if os.path.exists(co_ld):
+                    shutil.rmtree(co_ld, ignore_errors=True)
+                shutil.copytree(locale_dir, co_ld)
             
 
         # Copy data files.
@@ -197,9 +246,9 @@
             ld_library_path = &quot;:&quot;.join(original_ld_library_path)
 
         libpaths.append(outdir)
-        context[&quot;V3Init.libpaths&quot;] = libpaths
-        context[&quot;V3Init.ld_library_path&quot;] = ld_library_path
-        result[&quot;V3Init.ld_library_path&quot;] = ld_library_path
+        context[&quot;V3Test.libpaths&quot;] = libpaths
+        context[&quot;V3Test.ld_library_path&quot;] = ld_library_path
+        result[&quot;V3Test.ld_library_path&quot;] = ld_library_path
 
         # Calculate default g++ flags.  Both branches create basic_flags
         # and default_flags.
@@ -215,7 +264,11 @@
             basic_flags, default_flags = all_flags
         else:
             # We take the union of the 3.3 and the 3.4 defines; it
-            # doesn't seem to hurt.
+            # doesn't seem to hurt.  Only exception is that we
+            # purposefully leave out -DLOCALEDIR when doing standalone
+            # testing, so that it will be picked up from the environment
+            # instead.  This ensures that binary-only tests can be moved
+            # after being compiled.
             basic_flags = [# v3.4 only:
                            &quot;-D_GLIBCXX_ASSERT&quot;,
                            # v3.3 only:
@@ -224,50 +277,65 @@
                            &quot;-g&quot;, &quot;-O2&quot;,
                            &quot;-ffunction-sections&quot;, &quot;-fdata-sections&quot;,
                            &quot;-fmessage-length=0&quot;,
-                           &quot;-DLOCALEDIR=\&quot;%s\&quot;&quot; % locale_dir,
                            &quot;-I%s&quot; % srcdir]
             default_flags = []
+            
 
         default_flags.append(&quot;-D_GLIBCXX_ASSERT&quot;)
         if fnmatch.fnmatch(context[&quot;DejaGNUTest.target&quot;],
                            &quot;powerpc-*-darwin*&quot;):
             default_flags += [&quot;-multiply_defined&quot;, &quot;suppress&quot;]
-        context[&quot;V3Init.basic_cxx_flags&quot;] = basic_flags
-        context[&quot;V3Init.default_cxx_flags&quot;] = default_flags
+        context[&quot;V3Test.basic_cxx_flags&quot;] = basic_flags
+        context[&quot;V3Test.default_cxx_flags&quot;] = default_flags
         
         if standalone:
-            # Build libv3test.a.
-            makefile_in = open(os.path.join(standalone_root,
-                                            &quot;qm-misc&quot;,
-                                            &quot;util-Makefile&quot;))
-            makefile_str = makefile_in.read()
-            makefile_str = makefile_str.replace(&quot;@ROOT@&quot;,
-                                                standalone_root)
-            makefile_str = makefile_str.replace(&quot;@CXX@&quot;,
-                                                compiler.GetPath())
-            flags = compiler.GetOptions() + basic_flags
-            makefile_str = makefile_str.replace(&quot;@CXXFLAGS@&quot;,
-                                                &quot; &quot;.join(flags))
-            makefile_out = open(os.path.join(outdir, &quot;Makefile&quot;), &quot;w&quot;)
-            makefile_out.write(makefile_str)
-            makefile_out.close()
-            
-            make_executable = RedirectedExecutable()
-            make_command = [&quot;make&quot;, &quot;libv3test.a&quot;]
-            status = make_executable.Run(make_command, dir=outdir)
-            if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
-                result.SetOutcome(result.ERROR,
-                                  &quot;Error building libv3test.a&quot;,
-                                  {&quot;status&quot;: str(status),
-                                   &quot;stdout&quot;: &quot;&lt;pre&gt;&quot;
-                                             + make_executable.stdout
-                                             + &quot;&lt;/pre&gt;&quot;,
-                                   &quot;stderr&quot;: &quot;&lt;pre&gt;&quot;
-                                             + make_executable.stderr
-                                             + &quot;&lt;/pre&gt;&quot;,
-                                   &quot;command&quot;: &quot; &quot;.join(make_command),
-                                   })
-                return
+            # Ensure libv3test.a exists in 'outdir'.
+            if self._HaveCompiler(context):
+                # Build libv3test.a.
+                makefile_in = open(os.path.join(standalone_root,
+                                                &quot;qm-misc&quot;,
+                                                &quot;util-Makefile&quot;))
+                makefile_str = makefile_in.read()
+                makefile_str = makefile_str.replace(&quot;@ROOT@&quot;,
+                                                    standalone_root)
+                makefile_str = makefile_str.replace(&quot;@CXX@&quot;,
+                                                    compiler.GetPath())
+                flags = compiler.GetOptions() + basic_flags
+                makefile_str = makefile_str.replace(&quot;@CXXFLAGS@&quot;,
+                                                    &quot; &quot;.join(flags))
+                makefile_out = open(os.path.join(outdir, &quot;Makefile&quot;),
+                                    &quot;w&quot;)
+                makefile_out.write(makefile_str)
+                makefile_out.close()
+
+                make_executable = RedirectedExecutable()
+                make_command = [&quot;make&quot;, &quot;libv3test.a&quot;]
+                status = make_executable.Run(make_command, dir=outdir)
+                if (not os.WIFEXITED(status)
+                    or os.WEXITSTATUS(status) != 0):
+                    q_stdout = result.Quote(make_executable.stdout)
+                    q_stderr = result.Quote(make_executable.stderr)
+                    command_str = &quot; &quot;.join(make_command),
+                    result.SetOutcome(result.ERROR,
+                                      &quot;Error building libv3test.a&quot;,
+                                      {&quot;status&quot;: str(status),
+                                       &quot;stdout&quot;: q_stdout,
+                                       &quot;stderr&quot;: q_stderr,
+                                       &quot;command&quot;: command_str,
+                                       })
+                    return
+
+                # If we have an compiler output dir, use it.
+                if compiler_outdir is not None:
+                    shutil.copy(os.path.join(outdir, &quot;libv3test.a&quot;),
+                                os.path.join(compiler_outdir,
+                                             &quot;libv3test.a&quot;))
+            else:
+                # No compiler, so we just copy it out of the compiler
+                # output dir.
+                shutil.copy(os.path.join(compiler_outdir,
+                                         &quot;libv3test.a&quot;),
+                            os.path.join(outdir, &quot;libv3test.a&quot;))
 
         
     def _CalcBuildTreeFlags(self, result, context, blddir, compiler):
@@ -283,8 +351,7 @@
             if os.path.isfile(command):
                 break
 
-        result[&quot;V3Init.testsuite_flags_command&quot;] = \
-            &quot;&lt;pre&gt;&quot; + command + &quot;&lt;/pre&gt;&quot;
+        result[&quot;V3Test.testsuite_flags_command&quot;] = result.Quote(command)
 
         executable = RedirectedExecutable()
         executable.Run([command, &quot;--cxxflags&quot;])
@@ -304,6 +371,8 @@
 
         return (basic_flags, default_flags)
 
+# How DejaGNU does this, for reference:
+#
 # dg-runtest calls dg-test calls &quot;libstdc++-dg-test prog do_what
 # DEFAULT_CXXFLAGS&quot; (DEFAULT_CXXFLAGS as in normal.exp)
 # Which calls
@@ -313,7 +382,7 @@
 #   target_compile $prog $output_file $compile_type additional_flags=$DEFAULT_CXXFLAGS,compiler=$cxx_final,ldflags=-L$blddir/testsuite,libs=-lv3test
 # for us, libgloss doesn't exist, which simplifies things.
 
-class V3DGTest(DGTest, GCCTestBase):
+class V3DGTest(DGTest, GCCTestBase, V3Base):
     &quot;&quot;&quot;A 'V3DGTest' is a libstdc++-v3 test using the 'dg' driver.
 
     This test class emulates the 'lib/libstdc++.exp' and 'lib/prune.exp
@@ -324,15 +393,23 @@
 
     _language = &quot;cplusplus&quot;
 
-    _libdir_context_property = &quot;V3Init.libpaths&quot;
+    _libdir_context_property = &quot;V3Test.libpaths&quot;
 
     def Run(self, context, result):
 
         self._SetUp(context)
-        self._RunDGTest(context[&quot;V3Init.basic_cxx_flags&quot;],
-                        context[&quot;V3Init.default_cxx_flags&quot;],
+
+        if context.has_key(&quot;V3Test.compiler_output_dir&quot;):
+            # When using a special output directory, we always save the
+            # executables.
+            keep_output = 1
+        else:
+            keep_output = 0
+        self._RunDGTest(context[&quot;V3Test.basic_cxx_flags&quot;],
+                        context[&quot;V3Test.default_cxx_flags&quot;],
                         context,
-                        result)
+                        result,
+                        keep_output=keep_output)
         
 
     def _PruneOutput(self, output):
@@ -351,14 +428,16 @@
 
         env = {}
         for name in _ld_library_path_names:
-            env[name] = context[&quot;V3Init.ld_library_path&quot;]
+            env[name] = context[&quot;V3Test.ld_library_path&quot;]
+        if context.has_key(&quot;V3Init.env_V3_LOCALEDIR&quot;):
+            env[&quot;V3_LOCALEDIR&quot;] = context[&quot;V3Init.env_V3_LOCALEDIR&quot;]
         return env
 
 
     def _RunTargetExecutable(self, context, result, file, dir = None):
 
         if dir is None:
-            dir = context[&quot;V3Init.outdir&quot;]
+            dir = context[&quot;V3Test.outdir&quot;]
 
         sup = super(V3DGTest, self)
         return sup._RunTargetExecutable(context, result, file, dir)
@@ -380,9 +459,52 @@
         return (output, file)
 
 
+    def _RunDGToolPortion(self, path, tool_flags, context, result):
+        &quot;&quot;&quot;Don't run the compiler if in pre-compiled mode.&quot;&quot;&quot;
+
+        if not self._HaveCompiler(context):
+            # Don't run the compiler, just pretend we did.
+            return self._GetOutputFile(context, self._kind, path)
+            
+        return super(V3DGTest, self)._RunDGToolPortion(path, tool_flags,
+                                                       context, result)
+            
+
+    def _RunDGExecutePortion(self, file, context, result):
+        &quot;&quot;&quot;Emit an UNTESTED result if not compiling and not running.&quot;&quot;&quot;
+
+        if (not self._HaveCompiler(context)
+            and self._kind != DGTest.KIND_RUN):
+            # We didn't run the compiler, and we're not going to run the
+            # executable; we'd better emit something here because we're
+            # not doing it anywhere else.
+            result[&quot;V3DGTest.explanation_1&quot;] = (
+                &quot;This is a compiler test, and we are running in no &quot;
+                &quot;compiler mode.  Skipped.&quot;)
+            # Magic marker for the TET output stream to pick up on:
+            result[&quot;test_not_relevant_to_testing_mode&quot;] = &quot;true&quot;
+            self._RecordDejaGNUOutcome(result,
+                                       self.UNTESTED, self._name)
+            return
+                
+        super(V3DGTest, self)._RunDGExecutePortion(file,
+                                                   context, result)
+
+
     def _GetOutputFile(self, context, kind, path):
 
-        base = os.path.basename(path)
+        if context.has_key(&quot;V3Test.compiler_output_dir&quot;):
+            dir = context[&quot;V3Test.compiler_output_dir&quot;]
+            srcdir = self.GetDatabase().GetRoot()
+            path = os.path.normpath(path)
+            srcdir = os.path.normpath(srcdir)
+            assert path.startswith(srcdir)
+            base = path[len(srcdir):]
+            base = base.replace(&quot;/&quot;, &quot;_&quot;)
+        else:
+            dir = context.GetTemporaryDirectory()
+            base = os.path.basename(path)
+
         if kind != self.KIND_PRECOMPILE:
             base = os.path.splitext(base)[0]
         base += { DGTest.KIND_PREPROCESS : &quot;.i&quot;,
@@ -393,7 +515,7 @@
                   GCCTestBase.KIND_PRECOMPILE : &quot;.gch&quot;,
                   }[kind]
 
-        return os.path.join(context.GetTemporaryDirectory(), base)
+        return os.path.join(dir, base)
 
 
     def _DGrequire_iconv(self, line_num, args, context):
@@ -416,6 +538,16 @@
 
         charset = args[0]
 
+        # First check to see if we have a compiler.  We can't do
+        # anything useful without one.
+        if not self._HaveCompiler(context):
+            # No compiler; we'll go ahead and hope for the best.
+            # Better would be to save the test programs to the output
+            # directory, but this is difficult; on the other hand, not
+            # doing so may cause spurious failures if a character set is
+            # not in fact supported by our local libiconv...
+            return
+
         # Check to see if iconv does exist and work.
         # First by creating and compiling a test program...
         tmpdir = context.GetTemporaryDirectory()
@@ -439,9 +571,9 @@
         compiler = context[&quot;CompilerTable.compiler_table&quot;][self._language]
         options = []
 
-        options += context[&quot;V3Init.basic_cxx_flags&quot;]
-        options += context[&quot;V3Init.default_cxx_flags&quot;]
-        libpaths = context[&quot;V3Init.libpaths&quot;]
+        options += context[&quot;V3Test.basic_cxx_flags&quot;]
+        options += context[&quot;V3Test.default_cxx_flags&quot;]
+        libpaths = context[&quot;V3Test.libpaths&quot;]
         options += [&quot;-L&quot; + p for p in libpaths]
 
         if context.has_key(&quot;GCCTest.libiconv&quot;):
@@ -471,6 +603,7 @@
 
 
 
+# How the real GCC tree does things:
 # check-abi first builds
 #    abi_check
 #    baseline_symbols
@@ -484,12 +617,12 @@
 #
 #
 # new-abi-baseline is what actually generates a new baseline.
-# it does it with ${extract_symvers} ../src/.libs/libstdc++.so ${baseline_file}
+# It does it with ${extract_symvers} ../src/.libs/libstdc++.so ${baseline_file}
 # baseline_file = ${baseline_dir}/baseline_symbols.txt
 # baseline_dir is set by autoconf to some mad thing...
 #    $glibcxx_srcdir/config/abi/${abi_baseline_pair}\$(MULTISUBDIR)&quot;
 # abi_baseline_pair is set by autoconf to host_cpu-host_os by default.
-# but there are some special cases, in particular:
+# But there are some special cases, in particular:
 #    x86_64-*-linux*     -&gt; x86_64-linux-gnu
 #    alpha*-*-freebsd5*  -&gt; alpha-freebsd5
 #    i*86-*-freebsd4*    -&gt; i386-freebsd4
@@ -497,9 +630,10 @@
 #    sparc*-*-freebsd5*  -&gt; sparc-freebsd5
 #
 # extract_symvers = $(glibcxx_srcdir)/scripts/extract_symvers
-# extract_symvers is actually just a shell script
+# extract_symvers is actually just a shell script; we don't need to
+# compile it.
         
-class V3ABITest(Test):
+class V3ABITest(Test, V3Base):
     &quot;&quot;&quot;A 'V3ABITest' checks the ABI of libstdc++ against a baseline.
 
     Depends on context variable 'V3Test.abi_baseline_file'.&quot;&quot;&quot;
@@ -509,25 +643,48 @@
         # Some variables we'll need throughout.
         executable = RedirectedExecutable()
         tmpdir = context.GetTemporaryDirectory()
-        outdir = context[&quot;V3Init.outdir&quot;]
+        outdir = context[&quot;V3Test.outdir&quot;]
         srcdir = self.GetDatabase().GetRoot()
+        if context.has_key(&quot;V3Test.compiler_output_dir&quot;):
+            compiler_outdir = context[&quot;V3Test.compiler_output_dir&quot;]
+        else:
+            compiler_outdir = None
 
         # First we make sure that the abi_check program exists.
-        abi_check = os.path.join(outdir, &quot;abi_check&quot;)
-        status = executable.Run([&quot;make&quot;, &quot;abi_check&quot;], dir=outdir)
-        result[&quot;make_abi_check_stdout&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stdout
-                                           + &quot;&lt;/pre&gt;&quot;)
-        result[&quot;make_abi_check_stderr&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stderr
-                                           + &quot;&lt;/pre&gt;&quot;)
-        result[&quot;make_abi_check_status&quot;] = str(status)
-        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
-            result.SetOutcome(result.ERROR, &quot;Error building abi_check&quot;)
-            return
+        if not self._HaveCompiler(context):
+            # If we have no compiler, we must find it in the compiler
+            # output dir.
+            if compiler_outdir is None:
+                result.SetOutcome(result.ERROR,
+                                  &quot;No compiler output dir, &quot;
+                                  &quot;but no compiler either.&quot;)
+                return
+            abi_check = os.path.join(compiler_outdir, &quot;abi_check&quot;)
+        else:
+            # Otherwise, we have to try building it.
+            abi_check = os.path.join(outdir, &quot;abi_check&quot;)
+            status = executable.Run([&quot;make&quot;, &quot;abi_check&quot;], dir=outdir)
+            quote = result.Quote
+            result[&quot;make_abi_check_stdout&quot;] = quote(executable.stdout)
+            result[&quot;make_abi_check_stderr&quot;] = quote(executable.stderr)
+            result[&quot;make_abi_check_status&quot;] = str(status)
+            if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
+                result.SetOutcome(result.ERROR,
+                                  &quot;Error building abi_check&quot;)
+                return
+            # Ensure that the abi_check program does end up in the
+            # compiler output dir, if necessary.
+            if compiler_outdir is not None:
+                shutil.copy(abi_check,
+                            os.path.join(compiler_outdir, &quot;abi_check&quot;))
+        
         if not os.path.isfile(abi_check):
             result.SetOutcome(result.ERROR,
-                              &quot;No abi_check program '%s'&quot; % abi_check)
+                              &quot;No abi_check program '%s'&quot;
+                              % abi_check)
             return
 
+
         # Now make sure the baseline file exists.
         baseline_type = self._GetAbiName(context[&quot;DejaGNUTest.target&quot;])
         baseline_file = os.path.join(srcdir, &quot;..&quot;, &quot;config&quot;, &quot;abi&quot;,
@@ -554,12 +711,12 @@
             return
 
         # Extract the current symbols.
-        # First use ldd to find the libstdc++ in use.
-        status = executable.Run([&quot;ldd&quot;, &quot;abi_check&quot;], dir=outdir)
-        result[&quot;ldd_stdout&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stdout
-                                            + &quot;&lt;/pre&gt;&quot;)
-        result[&quot;ldd_stderr&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stderr
-                                            + &quot;&lt;/pre&gt;&quot;)
+        # First use ldd to find the libstdc++ in use.  'abi_check' is a
+        # handy C++ program; we'll check which library it's linked
+        # against.
+        status = executable.Run([&quot;ldd&quot;, abi_check], dir=outdir)
+        result[&quot;ldd_stdout&quot;] = result.Quote(executable.stdout)
+        result[&quot;ldd_stderr&quot;] = result.Quote(executable.stderr)
         result[&quot;ldd_status&quot;] = str(status)
         if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
             result.SetOutcome(result.ERROR,
@@ -580,10 +737,9 @@
         status = executable.Run([extract_symvers,
                                  libstdcpp,
                                  curr_symbols])
-        result[&quot;extract_symvers_stdout&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stdout
-                                            + &quot;&lt;/pre&gt;&quot;)
-        result[&quot;extract_symvers_stderr&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stderr
-                                            + &quot;&lt;/pre&gt;&quot;)
+        quote = result.Quote
+        result[&quot;extract_symvers_stdout&quot;] = quote(executable.stdout)
+        result[&quot;extract_symvers_stderr&quot;] = quote(executable.stderr)
         result[&quot;extract_symvers_status&quot;] = str(status)
         if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
             result.SetOutcome(result.ERROR, &quot;Error extracting symbols&quot;)
@@ -597,10 +753,9 @@
         # latter.
         status = executable.Run([abi_check, &quot;--check-verbose&quot;,
                                  curr_symbols, baseline_file])
-        result[&quot;comparison_stdout&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stdout
-                                            + &quot;&lt;/pre&gt;&quot;)
-        result[&quot;comparison_stderr&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stderr
-                                            + &quot;&lt;/pre&gt;&quot;)
+        quote = result.Quote
+        result[&quot;comparison_stdout&quot;] = quote(executable.stdout)
+        result[&quot;comparison_stderr&quot;] = quote(executable.stderr)
         result[&quot;comparison_status&quot;] = str(status)
         if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
             result.SetOutcome(result.ERROR,
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000822.html">[qmtest] [PATCH] Small bug introduced by previous change
</A></li>
	<LI>Next message: <A HREF="000825.html">[PATCH] qmtest updates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#824">[ date ]</a>
              <a href="thread.html#824">[ thread ]</a>
              <a href="subject.html#824">[ subject ]</a>
              <a href="author.html#824">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">More information about the qmtest
mailing list</a><br>
</body></html>
