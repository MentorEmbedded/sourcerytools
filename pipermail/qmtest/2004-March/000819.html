<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] qmtest_gcc: Support libstdc++ testing under QMTest
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:qmtest%40codesourcery.com?Subject=Re%3A%20%5BPATCH%5D%20qmtest_gcc%3A%20Support%20libstdc%2B%2B%20testing%20under%20QMTest&In-Reply-To=%3C20040318183915.GA18853%40njs.ddts.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000818.html">
   <LINK REL="Next"  HREF="000821.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] qmtest_gcc: Support libstdc++ testing under QMTest</H1>
    <B>Nathaniel Smith</B> 
    <A HREF="mailto:qmtest%40codesourcery.com?Subject=Re%3A%20%5BPATCH%5D%20qmtest_gcc%3A%20Support%20libstdc%2B%2B%20testing%20under%20QMTest&In-Reply-To=%3C20040318183915.GA18853%40njs.ddts.net%3E"
       TITLE="[PATCH] qmtest_gcc: Support libstdc++ testing under QMTest">njs at pobox.com
       </A><BR>
    <I>Thu Mar 18 18:39:15 UTC 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000818.html">[qmtest] SPAM from this list.
</A></li>
        <LI>Next message: <A HREF="000821.html">[qmtest] [PATCH] qmtest_gcc: Support libstdc++ testing under QMTest
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#819">[ date ]</a>
              <a href="thread.html#819">[ thread ]</a>
              <a href="subject.html#819">[ subject ]</a>
              <a href="author.html#819">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-- Nathaniel

-- 
So let us espouse a less contested notion of truth and falsehood, even
if it is philosophically debatable (if we listen to philosophers, we
must debate everything, and there would be no end to the discussion).
  -- Serendipities, Umberto Eco
-------------- next part --------------
Index: classes.qmc
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/classes.qmc,v
retrieving revision 1.11
diff -u -r1.11 classes.qmc
--- classes.qmc	23 Jun 2003 06:34:04 -0000	1.11
+++ classes.qmc	18 Mar 2004 18:33:55 -0000
@@ -1,2 +1,36 @@
 &lt;?xml version=&quot;1.0&quot; ?&gt;
-&lt;class-directory&gt;&lt;class kind=&quot;database&quot;&gt;gcc_database.GCCDatabase&lt;/class&gt;&lt;class kind=&quot;resource&quot;&gt;gpp_init.GPPInit&lt;/class&gt;&lt;class kind=&quot;resource&quot;&gt;dg_tls_test.GPPTLSInit&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;dg_tls_test.GPPDGTLSTest&lt;/class&gt;&lt;class kind=&quot;resource&quot;&gt;debug_test.GPPDebugInit&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gpp_dg_test.GPPDGTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gpp_profile_test.GPPProfileTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gpp_gcov_test.GPPGCOVTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gpp_old_deja_test.GPPOldDejaTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gcc_dg_test.GCCDGTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gcc_dg_test.GCCDGNoncompileTest&lt;/class&gt;&lt;class kind=&quot;resource&quot;&gt;debug_test.GCCDebugInit&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;debug_test.GPPDGDebugTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;debug_test.GCCDGDebugTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gcc_dg_test.GCCDGCPPTradTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;dg_pch_test.GPPDGPCHTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;dg_pch_test.GCCDGPCHTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gcc_dg_test.GCCDGCPPTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gcc_dg_test.GCCDGFormatTest&lt;/class&gt;&lt;class kind=&quot;resource&quot;&gt;dg_tls_test.GCCTLSInit&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;dg_tls_test.GCCDGTLSTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gcc_dg_test.GCCDGTortureTest&lt;/class&gt;&lt;class kind=&quot;resource&quot;&gt;gcc_init.GCCInit&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;compat_test.GCCCompatTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;compat_test.GPPCompatTest&lt;/class&gt;&lt;class kind=&quot;test&quot;&gt;gcc_dg_test.GCCCTortureCompileTest&lt;/class&gt;&lt;/class-directory&gt;
+&lt;!DOCTYPE class-directory
+  PUBLIC '-//QM/2.2/Class-Directory//EN'
+  '<A HREF="http://www.codesourcery.com/qm/dtds/2.2/-//qm/2.2/class-directory//en.dtd">http://www.codesourcery.com/qm/dtds/2.2/-//qm/2.2/class-directory//en.dtd</A>'&gt;
+&lt;class-directory&gt;
+ &lt;class kind=&quot;resource&quot; name=&quot;gpp_init.GPPInit&quot;/&gt;
+ &lt;class kind=&quot;resource&quot; name=&quot;dg_tls_test.GPPTLSInit&quot;/&gt;
+ &lt;class kind=&quot;resource&quot; name=&quot;debug_test.GPPDebugInit&quot;/&gt;
+ &lt;class kind=&quot;resource&quot; name=&quot;debug_test.GCCDebugInit&quot;/&gt;
+ &lt;class kind=&quot;resource&quot; name=&quot;dg_tls_test.GCCTLSInit&quot;/&gt;
+ &lt;class kind=&quot;resource&quot; name=&quot;gcc_init.GCCInit&quot;/&gt;
+ &lt;class kind=&quot;database&quot; name=&quot;gcc_database.GCCDatabase&quot;/&gt;
+ &lt;class kind=&quot;database&quot; name=&quot;v3_database.V3Database&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;dg_tls_test.GPPDGTLSTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gpp_dg_test.GPPDGTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gpp_profile_test.GPPProfileTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gpp_gcov_test.GPPGCOVTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gpp_old_deja_test.GPPOldDejaTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gcc_dg_test.GCCDGTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gcc_dg_test.GCCDGNoncompileTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;debug_test.GPPDGDebugTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;debug_test.GCCDGDebugTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gcc_dg_test.GCCDGCPPTradTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;dg_pch_test.GPPDGPCHTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;dg_pch_test.GCCDGPCHTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gcc_dg_test.GCCDGCPPTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gcc_dg_test.GCCDGFormatTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;dg_tls_test.GCCDGTLSTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gcc_dg_test.GCCDGTortureTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;compat_test.GCCCompatTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;compat_test.GPPCompatTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;gcc_dg_test.GCCCTortureCompileTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;v3_test.V3DGTest&quot;/&gt;
+ &lt;class kind=&quot;test&quot; name=&quot;v3_test.V3ABITest&quot;/&gt;
+ &lt;class kind=&quot;resource&quot; name=&quot;v3_test.V3Init&quot;/&gt;
+&lt;/class-directory&gt;
Index: debug_test.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/debug_test.py,v
retrieving revision 1.2
diff -u -r1.2 debug_test.py
--- debug_test.py	24 Feb 2004 08:23:12 -0000	1.2
+++ debug_test.py	18 Mar 2004 18:33:55 -0000
@@ -103,18 +103,23 @@
 
         basename = os.path.basename(self._GetSourcePath())
             
+        def isanywhere(string, list):
+            for s in list:
+                if s.find(string) != -1:
+                    return True
+            return False
+
         self._SetUp(context)
         for opts in context[GCCDebugInit.OPTIONS_TAG]:
-            optstring = &quot; &quot;.join(opts)
             if (basename in [&quot;debug-1.c&quot;, &quot;debug-2.c&quot;, &quot;debug-6.c&quot;]
                 and opts[0].endswith(&quot;1&quot;)):
                 continue
             elif (basename in [&quot;debug-1.c&quot;, &quot;debug-2.c&quot;]
-                  and optstring.find(&quot;03&quot;) != -1
-                  and (optstring.find(&quot;coff&quot;) != -1
-                       or optstring.find(&quot;stabs&quot;) != -1)):
+                  and isanywhere(&quot;03&quot;, opts) != -1
+                  and (isanywhere(&quot;coff&quot;, opts) != -1
+                       or isanywhere(&quot;stabs&quot;, opts) != -1)):
                 continue
-            self._RunDGTest(optstring, &quot;&quot;, context, result)
+            self._RunDGTest(opts, [], context, result)
 
 
 
Index: dg_pch_test.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/dg_pch_test.py,v
retrieving revision 1.3
diff -u -r1.3 dg_pch_test.py
--- dg_pch_test.py	24 Feb 2004 08:23:12 -0000	1.3
+++ dg_pch_test.py	18 Mar 2004 18:33:55 -0000
@@ -65,7 +65,7 @@
                 pass
             shutil.copyfile(os.path.splitext(source)[0] + suffix + &quot;s&quot;,
                             basename + suffix)
-            self._RunDGTest(o, &quot;&quot;, context, result,
+            self._RunDGTest(o, [], context, result,
                             basename + suffix,
                             self.KIND_PRECOMPILE,
                             keep_output = 1)
@@ -73,15 +73,15 @@
             assembly_outcome = self.UNTESTED
             if os.path.exists(basename + suffix + &quot;.gch&quot;):
                 os.remove(basename + suffix)
-                options = o + &quot; -I&quot; + context.GetTemporaryDirectory()
-                self._RunDGTest(options, &quot;&quot;, context, result, keep_output = 1)
+                options = o + [&quot;-I&quot; + context.GetTemporaryDirectory()]
+                self._RunDGTest(options, [], context, result, keep_output = 1)
                 os.remove(basename + suffix + &quot;.gch&quot;)
                 if os.path.exists(basename + &quot;.s&quot;):
                     os.rename(basename + &quot;.s&quot;, basename + &quot;.s-gch&quot;)
                     shutil.copyfile((os.path.splitext(source)[0]
                                      + suffix + &quot;s&quot;),
                                     basename + suffix)
-                    self._RunDGTest(options, &quot;&quot;, context, result,
+                    self._RunDGTest(options, [], context, result,
                                     keep_output = 1)
                     if filecmp.cmp(basename + &quot;.s&quot;, basename + &quot;.s-gch&quot;):
                         assembly_outcome = self.PASS
@@ -104,7 +104,7 @@
 
     _suffix = &quot;.h&quot;
 
-    _pch_options = [&quot;-O0 -g&quot;] + GCCDGTortureTest._torture_without_loops
+    _pch_options = [[&quot;-O0&quot;, &quot;-g&quot;]] + GCCDGTortureTest._torture_without_loops
 
 
 
@@ -113,5 +113,5 @@
 
     _suffix = &quot;.H&quot;
 
-    _pch_options = (&quot;-g&quot;, &quot;-O2 -g&quot;, &quot;-O2&quot;)
+    _pch_options = ([&quot;-g&quot;], [&quot;-O2&quot;, &quot;-g&quot;], [&quot;-O2&quot;])
     
Index: gcc_dg_test.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gcc_dg_test.py,v
retrieving revision 1.5
diff -u -r1.5 gcc_dg_test.py
--- gcc_dg_test.py	23 Jun 2003 06:34:04 -0000	1.5
+++ gcc_dg_test.py	18 Mar 2004 18:33:55 -0000
@@ -30,7 +30,7 @@
     This test class emulates the 'gcc-dg.exp' source file in the GCC
     testsuite.&quot;&quot;&quot;
 
-    _default_options = &quot;-ansi -pedantic-errors&quot;
+    _default_options = [&quot;-ansi&quot;, &quot;-pedantic-errors&quot;]
 
     def _DGrequire_weak(self, line_num, args, context):
         &quot;&quot;&quot;Emulate the 'dg-require-weak' command.
@@ -99,7 +99,7 @@
     This test class emulates the 'noncompile.exp' source file in the
     GCC testsuite.&quot;&quot;&quot;
 
-    _default_options = &quot;&quot;
+    _default_options = []
     
 
 
@@ -109,7 +109,7 @@
     This test class emulates the 'cpp.exp' source file in the GCC
     testsuite.&quot;&quot;&quot;
 
-    _default_options = &quot;-ansi -pedantic-errors&quot;
+    _default_options = [&quot;-ansi&quot;, &quot;-pedantic-errors&quot;]
 
 
 
@@ -119,24 +119,25 @@
     This test class emulates the 'trad.exp' source file in the GCC
     testsuite.&quot;&quot;&quot;
 
-    _default_options = &quot;-traditional-cpp&quot;
+    _default_options = [&quot;-traditional-cpp&quot;]
 
 
 
 class GCCDGTortureTest(GCCDGTest):
     &quot;&quot;&quot;A 'GCCDGTortureTest' emulates 'gcc.dg/torture/dg-torture.exp'.&quot;&quot;&quot;
 
-    _default_options = &quot;&quot;
+    _default_options = []
 
     _torture_with_loops = [
-        &quot;-O0&quot;,
-        &quot;-O1&quot;,
-        &quot;-O2&quot;,
-        &quot;-O3 -fomit-frame-pointer&quot;,
-        &quot;-O3 -fomit-frame-pointer -funroll-loops&quot;,
-        &quot;-O3 -fomit-frame-pointer -funroll-all-loops -finline-functions&quot;,
-        &quot;-O3 -g&quot;,
-        &quot;-Os&quot;
+        [&quot;-O0&quot;],
+        [&quot;-O1&quot;],
+        [&quot;-O2&quot;],
+        [&quot;-O3&quot;, &quot;-fomit-frame-pointer&quot;],
+        [&quot;-O3&quot;, &quot;-fomit-frame-pointer&quot;, &quot;-funroll-loops&quot;],
+        [&quot;-O3&quot;, &quot;-fomit-frame-pointer&quot;,
+         &quot;-funroll-all-loops&quot;, &quot;-finline-functions&quot;],
+        [&quot;-O3&quot;, &quot;-g&quot;],
+        [&quot;-Os&quot;],
         ]
     &quot;&quot;&quot;A list of command-line options to use for &quot;torture&quot; tests.
 
@@ -207,7 +208,7 @@
 class GCCDGFormatTest(GCCDGTortureTest):
     &quot;&quot;&quot;A 'GCCDGFormatTest' emulates 'gcc.dg/format/format.exp'.&quot;&quot;&quot;
 
-    _default_options = &quot;&quot;
+    _default_options = []
     
     _torture_with_loops = [ &quot;&quot;, &quot;-DWIDE&quot; ]
 
@@ -220,4 +221,4 @@
 
     _default_kind = GCCDGTortureTest.KIND_ASSEMBLE
     
-    _default_options = &quot;-w&quot;
+    _default_options = [&quot;-w&quot;]
Index: gcc_dg_test_base.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gcc_dg_test_base.py,v
retrieving revision 1.4
diff -u -r1.4 gcc_dg_test_base.py
--- gcc_dg_test_base.py	12 Jun 2003 23:43:00 -0000	1.4
+++ gcc_dg_test_base.py	18 Mar 2004 18:33:55 -0000
@@ -63,7 +63,7 @@
     def Run(self, context, result):
 
         self._SetUp(context)
-        self._RunDGTest(&quot;&quot;, self._default_options, context, result)
+        self._RunDGTest([], self._default_options, context, result)
                         
 
     def _ExecuteFinalCommand(self, command, args, context, result):
@@ -160,7 +160,6 @@
             dirname = os.path.dirname(path)
             source_files += map(lambda f: os.path.join(dirname, f),
                                 self.__additional_source_files)
-        options = self._ParseTclWords(options)
         if &quot;-frepo&quot; in options:
             is_repo_test = 1
             kind = DGTest.KIND_ASSEMBLE
@@ -220,6 +219,9 @@
 
         This method emulates 'dg-scan' in the GCC testsuite.&quot;&quot;&quot;
 
+        print &quot;__ScanFile: %s, %s, %s&quot; % tuple(map(repr, [command,
+                                                    output_file, args]))
+
         # See if there is a target selector applied to this test.
         expectation = self.PASS
         if len(args) &gt; 1:
@@ -247,7 +249,13 @@
             outcome = self.PASS
         else:
             outcome = self.FAIL
-        message = self._name + &quot; &quot; + command + &quot; &quot; + pattern
+        print &quot;Pattern is %s&quot; % repr(pattern)
+        printable_pattern = pattern
+        for old, new in [(&quot;\\&quot;, &quot;\\\\&quot;), (&quot;\n&quot;, &quot;\\n&quot;),
+                         (&quot;\r&quot;, &quot;\\r&quot;),  (&quot;\t&quot;, &quot;\\t&quot;)]:
+            printable_pattern = printable_pattern.replace(old, new)
+        print &quot;Printable pattern is %s&quot; % repr(printable_pattern)
+        message = self._name + &quot; &quot; + command + &quot; &quot; + printable_pattern
         self._RecordDejaGNUOutcome(result, outcome, message, expectation)
         
 
Index: gcc_test_base.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gcc_test_base.py,v
retrieving revision 1.2
diff -u -r1.2 gcc_test_base.py
--- gcc_test_base.py	2 Jun 2003 23:50:18 -0000	1.2
+++ gcc_test_base.py	18 Mar 2004 18:33:56 -0000
@@ -85,39 +85,39 @@
     &quot;&quot;&quot;A map from DejaGNU compilation modes to 'Compiler' modes.&quot;&quot;&quot;
 
     def _RecordPass(self, result, testcase, cflags):
-	&quot;&quot;&quot;Emulate '${tool}_pass'.
+        &quot;&quot;&quot;Emulate '${tool}_pass'.
 
-	'result' -- The 'Result'.
-	
-	'testcase' -- The name of the test.
-
-	'cflags' -- The options provided to the test.&quot;&quot;&quot;
-
-	if cflags:
-	    message = &quot;%s, %s&quot; % (testcase, cflags)
-	else:
-	    message = testcase
-	self._RecordDejaGNUOutcome(result, DejaGNUTest.PASS, message)
+        'result' -- The 'Result'.
+        
+        'testcase' -- The name of the test.
+
+        'cflags' -- The options provided to the test.&quot;&quot;&quot;
+
+        if cflags:
+            message = &quot;%s, %s&quot; % (testcase, cflags)
+        else:
+            message = testcase
+        self._RecordDejaGNUOutcome(result, DejaGNUTest.PASS, message)
 
 
     def _RecordFail(self, result, testcase, cflags):
-	&quot;&quot;&quot;Emulate '${tool}_fail'.
+        &quot;&quot;&quot;Emulate '${tool}_fail'.
 
-	'result' -- The 'Result'.
-	
-	'testcase' -- The name of the test.
-
-	'cflags' -- The options provided to the test.&quot;&quot;&quot;
-
-	if cflags:
-	    message = &quot;%s, %s&quot; % (testcase, cflags)
-	else:
-	    message = testcase
-	self._RecordDejaGNUOutcome(result, DejaGNUTest.FAIL, message)
+        'result' -- The 'Result'.
+        
+        'testcase' -- The name of the test.
+
+        'cflags' -- The options provided to the test.&quot;&quot;&quot;
+
+        if cflags:
+            message = &quot;%s, %s&quot; % (testcase, cflags)
+        else:
+            message = testcase
+        self._RecordDejaGNUOutcome(result, DejaGNUTest.FAIL, message)
 
 
     def _Compile(self, context, result, source_files, output_file, mode,
-                 options = []):
+                 options = [], post_options = []):
         &quot;&quot;&quot;Compile the 'source_files'.
 
         'context' -- The 'Context' in which the test is running.
@@ -175,7 +175,7 @@
         # Run the compiler.
         index = self._RecordCommand(result, command)
         status, output \
-	   = compiler.ExecuteCommand(context.GetTemporaryDirectory(), command)
+           = compiler.ExecuteCommand(context.GetTemporaryDirectory(), command)
         self._RecordCommandOutput(result, index, status, output)
                     
         # If there was no output, DejaGNU uses the exit status.
@@ -186,43 +186,43 @@
         
         
     def _CheckCompile(self, result, testcase, option, objname, gcc_output):
-	&quot;&quot;&quot;Check the result of a compilation.
+        &quot;&quot;&quot;Check the result of a compilation.
+
+        'result' -- The QMTest 'Result' object.
+        
+        'testcase' -- The name of the test.
+
+        'option' -- The options used when performing the test.
+
+        'objname' -- The name of the output file.
+
+        'gcc_output' -- The output generated by the compiler.
+
+        returns -- '1' if the compilation suceeded, '0' otherwise.  If
+        '0' is returned, the 'result' has been updated to indicate the
+        problem.
+        
+        This function emulates 'g++_check_compile' in
+        'gcc-defs.exp'.&quot;&quot;&quot;
 
-	'result' -- The QMTest 'Result' object.
-	
-	'testcase' -- The name of the test.
-
-	'option' -- The options used when performing the test.
-
-	'objname' -- The name of the output file.
-
-	'gcc_output' -- The output generated by the compiler.
-
-	returns -- '1' if the compilation suceeded, '0' otherwise.  If
-	'0' is returned, the 'result' has been updated to indicate the
-	problem.
-	
-	This function emulates 'g++_check_compile' in
-	'gcc-defs.exp'.&quot;&quot;&quot;
-
-	match = GCCTestBase.__signal_regexp.match(gcc_output)
-	if match:
-	    self._RecordFail(result, testcase,
-			     &quot;Got Signal %s, %s&quot; % (match.group(1), option))
-	    return 0
+        match = GCCTestBase.__signal_regexp.match(gcc_output)
+        if match:
+            self._RecordFail(result, testcase,
+                             &quot;Got Signal %s, %s&quot; % (match.group(1), option))
+            return 0
 
         gcc_output = GCCTestBase.__newline_regexp.sub(gcc_output, &quot;&quot;)
-		
+                
         if gcc_output != &quot;&quot;:
-	    self._RecordFail(result, testcase, option)
-	    return 0
-	    
-	if objname and not os.path.exists(objname):
-	    self._RecordFail(result, testcase, option)
-	    return 0
+            self._RecordFail(result, testcase, option)
+            return 0
+            
+        if objname and not os.path.exists(objname):
+            self._RecordFail(result, testcase, option)
+            return 0
         
         self._RecordPass(result, testcase, option)
-	return 1
+        return 1
 
         
     
Index: gpp_dg_test.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gpp_dg_test.py,v
retrieving revision 1.6
diff -u -r1.6 gpp_dg_test.py
--- gpp_dg_test.py	2 Jun 2003 21:08:50 -0000	1.6
+++ gpp_dg_test.py	18 Mar 2004 18:33:56 -0000
@@ -29,7 +29,7 @@
     This test class emulates the 'g++-dg.exp' source file in the GCC
     testsuite.&quot;&quot;&quot;
 
-    _default_options = &quot;-ansi -pedantic-errors -Wno-long-long&quot;
+    _default_options = [&quot;-ansi&quot;, &quot;-pedantic-errors&quot;, &quot;-Wno-long-long&quot;]
 
     def _GetTargetEnvironment(self, context):
 
Index: gpp_init.py
===================================================================
RCS file: /home/qm/Repository/qmtest_gcc/gpp_init.py,v
retrieving revision 1.6
diff -u -r1.6 gpp_init.py
--- gpp_init.py	24 Feb 2004 08:23:12 -0000	1.6
+++ gpp_init.py	18 Mar 2004 18:33:56 -0000
@@ -20,6 +20,7 @@
 from   dejagnu_base import DejaGNUBase
 from   qm.executable import RedirectedExecutable
 from   qm.test.resource import Resource
+from   qm.test.result import Result
 import os
 import sys
 
@@ -87,8 +88,8 @@
             executable.Run(command)
             options += executable.stdout.split()
         except:
-            result.Fail(&quot;Could not run testsuite_flags&quot;)
-            result[result.EXCEPTION] = &quot;%s: %s&quot; % sys.exc_info()[:2]
+            result.NoteException(&quot;Could not run testsuite_flags&quot;,
+                                 Result.FAIL)
             return
 
         # Avoid splitting diagnostic message lines.
-------------- next part --------------
#!/usr/bin/python 

import sys
import os
import os.path
import shutil
import glob
import getpass
import time
from optparse import OptionParser

j = os.path.join

optparser = OptionParser(&quot;usage: %prog [options] &lt;gcc-version&gt; &quot;
                         &quot;&lt;source-directory&gt; &lt;qmtc-directory&gt; &quot;
                         &quot;&lt;qmtest_gcc-directory&gt;&quot;)
optparser.add_option(&quot;-v&quot;, &quot;--version&quot;, action=&quot;store&quot;,
                     dest=&quot;pkg_version&quot;, default=&quot;1.0&quot;,
                     metavar=&quot;VERSION&quot;,
                     help=&quot;Package version (default 1.0)&quot;)
optparser.add_option(&quot;-o&quot;, &quot;--output&quot;, action=&quot;store&quot;,
                     dest=&quot;targetdir&quot;, metavar=&quot;DIR&quot;,
                     help=&quot;Output directory&quot;
                     &quot;(default qmtest_libstdcpp_GCCVER-PKGVER)&quot;)
optparser.add_option(&quot;-f&quot;, &quot;--force&quot;, action=&quot;store_true&quot;,
                     dest=&quot;force&quot;, default=False,
                     help=&quot;If output directory already exists, delete it&quot;)
optparser.add_option(&quot;-a&quot;, &quot;--add-results&quot;, action=&quot;append&quot;,
                     dest=&quot;baselines&quot;, default=[],
                     help=&quot;Additional result file to distribute (may be &quot;
                     &quot;used multiple times)&quot;)


def usage(name):
    print &quot;Usage: %s &lt;full-gcc-version&gt; &lt;source-directory&gt; &quot; \
          &quot;&lt;destination-directory&gt;&quot; % name
    print &quot;E.g., %s 3.3.3 gcc-3.3.3 my-gcc-3.3.3-package&quot; % name
    sys.exit(2)


def ensure_dir(dir):
    # Assume we're given foo/bar/baz/quux, and foo/bar already exists.
    fragments = []
    while dir:
        if os.path.exists(dir):
            break
        dir, tail = os.path.split(dir)
        fragments.insert(0, tail)
    # Now dir == &quot;foo/bar&quot; and fragments == [&quot;baz&quot;, &quot;quux&quot;]
    # Iterate through the fragments, building up dir and creating
    # directories.
    for frag in fragments:
        dir = j(dir, frag)
        os.mkdir(dir)
        

def main(name, args):

    options, args = optparser.parse_args(args)
    if len(args) != 4:
        optparser.error(&quot;Wrong number of arguments&quot;)

    gcc_version, srcdir, qmtcdir, qmtest_gccdir = args
    pkg_version = options.pkg_version
    targetdir = options.targetdir
    if targetdir is None:
        targetdir = &quot;./qmtest_libstdcpp_%s-%s&quot; % (gcc_version,
                                                  pkg_version)

    if os.path.exists(targetdir):
        if options.force:
            shutil.rmtree(targetdir)
        else:
            print &quot;Error: Target directory '%s' already exists and &quot; \
                  &quot;deletion not requested&quot; % targetdir
            sys.exit(2)

    if not gcc_version.startswith(&quot;3.3&quot;):
        print &quot;Error: Unsupported gcc version %s&quot; % gcc_version
        sys.exit(2)

    v3src = j(srcdir, &quot;libstdc++-v3&quot;)
    ensure_dir(targetdir)

    # Open a file to record which directories exist (and thus need
    # installing).
    content_files = open(j(targetdir, &quot;contents&quot;), &quot;w&quot;)

    # Mark that this will be a standalone installation, for later use by
    # the QMTest scripts.
    f = open(j(targetdir, &quot;THIS-IS-STANDALONE-V3&quot;), &quot;w&quot;)
    # In case we need to version stuff later:
    f.write(&quot;1\n&quot;)
    f.close()
    content_files.write(&quot;THIS-IS-STANDALONE-V3\n&quot;)

    # Copy gcc stuff over:
    shutil.copytree(j(v3src, &quot;testsuite&quot;), j(targetdir, &quot;testsuite&quot;))
    content_files.write(&quot;testsuite\n&quot;)
    shutil.copytree(j(v3src, &quot;po&quot;), j(targetdir, &quot;po&quot;))
    content_files.write(&quot;po\n&quot;)
    ensure_dir(j(targetdir, &quot;config&quot;))
    shutil.copytree(j(v3src, &quot;config&quot;, &quot;abi&quot;),
                    j(targetdir, &quot;config&quot;, &quot;abi&quot;))
    content_files.write(&quot;config\n&quot;)
    
    # gcc 3.4 has a scripts dir that we need.
    if os.path.exists(j(v3src, &quot;scripts&quot;)):
        shutil.copytree(j(v3src, &quot;scripts&quot;), j(targetdir, &quot;scripts&quot;))
        content_files.write(&quot;scripts\n&quot;)

    # Copy in QMTest extension classes.
    ensure_dir(j(targetdir, &quot;qm-classes&quot;))
    content_files.write(&quot;qm-classes\n&quot;)
    shutil.copytree(qmtcdir, j(targetdir, &quot;qm-classes&quot;, &quot;qmtc&quot;))
    shutil.copytree(qmtest_gccdir,
                    j(targetdir, &quot;qm-classes&quot;, &quot;qmtest_gcc&quot;))
    # And then clean them up a bit (remove backup files, compiled files,
    # and CVS/ directories).
    for g in &quot;*~&quot;, &quot;*.pyc&quot;, &quot;*.pyo&quot;:
        for file in glob.glob(j(targetdir, &quot;qm-classes&quot;, &quot;*&quot;, g)):
            os.unlink(file)
    for dir in glob.glob(j(targetdir, &quot;qm-classes&quot;, &quot;*&quot;, &quot;CVS&quot;)):
        shutil.rmtree(dir)

    # Copy over any supplied baselines.
    ensure_dir(j(targetdir, &quot;qm-baselines&quot;))
    content_files.write(&quot;qm-baselines\n&quot;)
    for b in options.baselines:
        shutil.copyfile(b, j(targetdir, &quot;qm-baselines&quot;,
                             os.path.basename(b)))

    # Now create the misc. files.
    miscdir = j(targetdir, &quot;qm-misc&quot;)
    ensure_dir(miscdir)
    content_files.write(&quot;qm-misc\n&quot;)

    substitutions = {&quot;prog_name&quot;: name,
                     &quot;gcc_version&quot;: gcc_version,
                     &quot;pkg_version&quot;: pkg_version,
                     &quot;prog_args&quot;: &quot; &quot;.join(args),
                     &quot;user&quot;: getpass.getuser(),
                     &quot;time&quot;: time.strftime(&quot;%Y-%m-%d %H:%M:%S &quot;),
                     }

    f = open(j(miscdir, &quot;locale-Makefile&quot;), &quot;w&quot;)
    f.write(locale_Makefile % substitutions)
    f.close()

    f = open(j(miscdir, &quot;util-Makefile&quot;), &quot;w&quot;)
    f.write(util_Makefile % substitutions)
    f.close()

    # And the distribution-level files.
    f = open(j(targetdir, &quot;README&quot;), &quot;w&quot;)
    f.write(README_file % substitutions)
    f.close()

    f = open(j(targetdir, &quot;PKGINFO&quot;), &quot;w&quot;)
    f.write(PKGINFO_file % substitutions)
    f.close()

    f = open(j(targetdir,
               &quot;qmtest_libstdcpp_%(gcc_version)s.spec&quot;
               % substitutions),
             &quot;w&quot;)
    f.write(spec_file % substitutions)
    f.close()
    

locale_Makefile = &quot;&quot;&quot;\
# Do not edit -- this file automatically generated by %(prog_name)s.
# Makefile to build locale files needed by libstdc++-v3 testsuite.

root := @ROOT@

podir := $(root)/po

POS := $(wildcard $(podir)/*.po)
LANGS := $(basename $(notdir $(POS)))
MOS := $(addsuffix /LC_MESSAGES/libstdc++.mo,$(LANGS))
DIRS := $(addsuffix /LC_MESSAGES,$(LANGS))

# Allow the user to set MSGFMT in their environment
MSGFMT ?= msgfmt

.PHONY: locales

locales: $(POS)
\tmkdir -p $(DIRS)
\tfor lang in $(LANGS); \\
\t    do $(MSGFMT) $(podir)/$$lang.po -o $$lang/LC_MESSAGES/libstdc++.mo; \\
\tdone

&quot;&quot;&quot;

util_Makefile = &quot;&quot;&quot;\
# Do not edit -- this file automatically generated by %(prog_name)s.
# Makefile to build utility files needed by libstdc++-v3 testsuite.

root := @ROOT@
CXX := @CXX@
CXXFLAGS := @CXXFLAGS@

VPATH := $(root)/testsuite

v3test_SOURCES := testsuite_hooks.cc testsuite_allocator.cc
abi_check_SOURCES := abi_check.cc

v3test_OBJECTS := $(v3test_SOURCES:.cc=.o)

libv3test.a: $(v3test_OBJECTS)
\t$(AR) r $@ $^

abi_check: $(abi_check_SOURCES)
\t$(CXX) $(CXXFLAGS) $^ -o $@
&quot;&quot;&quot;

README_file = &quot;&quot;&quot;\
GNU C++ RUNTIME LIBRARY TESTSUITE
=================================

This package contains the GNU C++ Runtime Library Testsuite for
version %(gcc_version)s of the GNU Compiler Collection.  The tests contained in
this package are the same tests distributed with the GNU Compiler
Collection.  The QMTest extension modules included in this package was
developed by CodeSourcery, LLC under contract from the Free Standards
Group.

For assistance with this software, please contact:

  <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">support at codesourcery.com</A>

For general information about QMTest, the software used to run these
tests, please visit:

  <A HREF="http://www.qmtest.com">http://www.qmtest.com</A>

You can also send mail to the QMTest mailing list:

  <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">qmtest at codesourcery.com</A>

if you have questions about QMTest.

PREREQUISITES
=============

- Python 2.2 (or later)

  Python binary packages are available for all popular GNU/Linux
  distributions and for many other operating systems.  If you do not
  already have Python, visit <A HREF="http://www.python.org.">http://www.python.org.</A>

- QMTest 2.2 (or later)

  As of this writing QMTest 2.2 has not yet been released.  

  A Red Hat Package Manager (RPM) distribution of a QMTest snapshot
  that works with this testsuite is available at:

    <A HREF="http://www.codesourcery.com/qm/qmtest_downloads/qm-20040317/qm-20040317.noarch.rpm">http://www.codesourcery.com/qm/qmtest_downloads/qm-20040317/qm-20040317.noarch.rpm</A>

  The RPM is architecture-independent; it can be installed on any
  GNU/Linux system that supports the RPM format.

  You can also obtain the source for QMTest from CVS by following the
  directions at:

    <A HREF="http://www.codesourcery.com/qm/qmtest_development">http://www.codesourcery.com/qm/qmtest_development</A>

- GNU Compiler Collection

  In order to test the GNU C++ Runtime Library, you must install
  the GNU C++ Compiler (G++) and its associated Runtime Library.

INSTALLATION
============

There are two installation methods for the Testsuite, depending on
which package format you select.  Both package formats contain
identical files; which package format you select is purely a matter of
preference.

GNU Zip Tape Archive
--------------------

Download the file:

  qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s.tar.gz

Then, unpack the file with the following command:

  tar xzf qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s.tar.gz

Red Hat Package Manager
-----------------------

Download the file:

  qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s-1.noarch.rpm

Then, install the file with the following command, which must be run
as &quot;root&quot;:

  rpm -i qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s-1.noarch.rpm

The package will be installed in:

  /usr/share/qmtest_libstdcpp_%(gcc_version)s

USAGE
=====

The following examples all assume that you are using the Bourne shell.
If you are using an alternative shell, you may have to make minor
changes to the commands.  Furthermore, these commands assume that the
environment variable &quot;PKGROOT&quot; is the path to the directory in which
you installed the Testsuite.  For example, if you used the RPM
installation, &quot;PKGROOT&quot; should be set to
&quot;/usr/share/qmtest_libstdcpp_%(gcc_version)s&quot;.  These examples assume that both
&quot;qmtest&quot; and &quot;g++&quot; are in your &quot;PATH&quot; and that &quot;g++&quot; is the compiler
that you wish to test.  You must also ensure that the
&quot;LD_LIBRARY_PATH&quot; environment variable includes the directory in which
the GNU C++ Runtime Library has been installed.  If your &quot;g++&quot; is in
&quot;/path/to/bin/g++&quot;, then your &quot;LD_LIBRARY_PATH&quot; should include
&quot;/path/to/lib&quot;.

There are four steps required to run the testsuite:

1. Tell QMTest where to find the extension classes required for the
   Testsuite:

     $ QMTEST_CLASS_PATH=$PKGROOT/qm-classes/qmtc:$PKGROOT/qm-classes/qmtest_gcc
     $ export QMTEST_CLASS_PATH

2. Create a test database.

     $ qmtest -D v3db create-tdb -c v3_database.V3Database \\
                                 -a srcdir=$PKGROOT/testsuite

3. Create a context file.
 
   The file should be named &quot;v3db/context&quot; and should contain contents
   similar to:

     CompilerTable.languages=cplusplus
     CompilerTable.cplusplus_kind=GCC
     CompilerTable.cplusplus_path=g++
     CompilerTable.cplusplus_options=
     DejaGNUTest.target=i686-pc-linux-gnu
     V3Init.scratch_dir=scratch

  You should adjust the &quot;DejaGNUTest.target&quot; line to indicate the GNU
  triplet for your operating system.

4. Run the tests:

     $ cd v3db
     $ qmtest run

   QMTest will display the results on the standard error stream.

   All released versions of G++ fail some of these tests.  Therefore,
   you should not be surprised to see some failures.

   If you would like the results in the TET output format, use the
   following command:

     $ qmtest run \\
         --result-stream=&quot;tet_stream.TETStream(filename='results.tet')&quot;

   This command will write the results into the file &quot;results.tet&quot;
   using TET output format.

   If you would like to compare the results with the benchmark results
   available obtained with version %(gcc_version)s of the GNU Compiler
   Collection on an i686-pc-linux-gnu machine, use the
   following command:

     $ qmtest run \\
         -O $PKGROOT/qm-baselines/%(gcc_version)s_i686-pc-linux-gnu.qmr

  QMTest supports a variety of more complex usage scenarios.  For more
  information see the QMTest manual, available at:

    <A HREF="http://www.codesourcery.com/qm/qmtest_manual">http://www.codesourcery.com/qm/qmtest_manual</A>
&quot;&quot;&quot;

PKGINFO_file = &quot;&quot;&quot;\
This package generated automatically by %(prog_name)s.

Invoked by %(user)s at %(time)s.
Call was:
  $ %(prog_name)s %(prog_args)s

&quot;&quot;&quot;

spec_file = &quot;&quot;&quot;\
# Do not edit -- this file automatically generated by %(prog_name)s.
Summary:     libstdc++-v3 testsuite packaged to be run under QMTest.
Name:        qmtest_libstdcpp_%(gcc_version)s
Packager:    Nathaniel Smith &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">njs at codesourcery.com</A>&gt;
Copyright:   Various
Version:     %(pkg_version)s
Release:     1
Group:       Development/Tools
BuildRoot:   %%{_tmppath}/%%{name}-buildroot
Source:      qmtest_libstdcpp_%(gcc_version)s-%(pkg_version)s.tar.gz
Vendor:      CodeSourcery LLC
BuildArchitectures: noarch

%%description
This package includes the libstdc++-v3 testsuite from gcc version
%(gcc_version)s, together with QMTest extensions allowing one to run the
testsuite against an installed version of libstdc++.

%%prep
%%setup -q

%%build

%%install
rm -rf $RPM_BUILD_ROOT
DIR=$RPM_BUILD_ROOT/usr/share/qmtest_libstdcpp_%(gcc_version)s
mkdir -p $DIR
for thing in `cat contents`; do
    if [ -d &quot;$thing&quot; ]; then
        cp -r &quot;$thing&quot; &quot;$DIR/$thing&quot;
    else
        cp &quot;$thing&quot; &quot;$DIR/$thing&quot;
    fi
done

%%clean
rm -rf $RPM_BUILD_ROOT

%%files
# Install all files as root:
%%defattr(-,root,root)
/usr/share/qmtest_libstdcpp_%(gcc_version)s/
%%doc README

%%changelog
* Tue Mar 16 2004 Nathaniel Smith &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">njs at codesourcery.com</A>&gt; 
- Initial release.

&quot;&quot;&quot;

if __name__ == &quot;__main__&quot;:
    main(sys.argv[0], sys.argv[1:])
-------------- next part --------------
########################################################################
#
# File:   v3_test.py
# Author: Nathaniel Smith
# Date:   03/08/2004
#
# Contents:
#   V3Init, V3DGTest, V3ABICheck
#
# Copyright (c) 2004 by CodeSourcery, LLC.  All rights reserved. 
#
########################################################################

########################################################################
# Imports
########################################################################

import shutil
import fnmatch
import glob
import os
import os.path
import re
import qm
from qm.executable import RedirectedExecutable
from qm.test.test import Test
from qm.test.resource import Resource
from dg_test import DGTest
from dejagnu_base import DejaGNUBase
from qm.test.result import Result
from gcc_test_base import GCCTestBase
from compiler import CompilerExecutable

########################################################################
# Classes
########################################################################

_ld_library_path_names = [&quot;LD_LIBRARY_PATH&quot;, &quot;SHLIB_PATH&quot;,
                          &quot;LD_LIBRARYN32_PATH&quot;, &quot;LD_LIBRARY64_PATH&quot;,
                          &quot;LD_RUN_PATH&quot;, &quot;LD_LIBRARY_PATH_32&quot;,
                          &quot;LD_LIBRARY_PATH_64&quot;, &quot;DYLD_LIBRARY_PATH&quot;]
&quot;&quot;&quot;All the different envvars that might mean LD_LIBRARY_PATH.&quot;&quot;&quot;

class V3Init(Resource):
    &quot;&quot;&quot;All V3 tests depend on one of these for setup.&quot;&quot;&quot;

    def SetUp(self, context, result):

        # Get general information that will be used through the rest of
        # the setup.
        srcdir = self.GetDatabase().GetRoot()
        target = context[&quot;DejaGNUTest.target&quot;]

        # Are we using the standalone testsuite to test an installed
        # libstdc++/g++, or the integrated testsuite to test a
        # just-built libstdc++/g++?  Check for the magic file that the
        # standalone package contains.
        standalone_marker = os.path.join(srcdir, &quot;..&quot;,
                                         &quot;THIS-IS-STANDALONE-V3&quot;)
        standalone = os.path.exists(standalone_marker)
        if standalone:
            standalone_root = os.path.join(srcdir, &quot;..&quot;)
        context[&quot;V3Init.is_standalone&quot;] = standalone

        # Find the compiler.
        compilers = context[&quot;CompilerTable.compiler_table&quot;]
        compiler = compilers[&quot;cplusplus&quot;]


        if not standalone:
            # Find blddir and outdir, and make outdir available to later
            # tests.
            options = compiler.GetOptions()
            compiler_executable = CompilerExecutable()
            compiler_executable.Run([compiler.GetPath()]
                                    + options
                                    + ['--print-multi-dir'])
            directory = compiler_executable.stdout[:-1]
            
            for o in options:
                if o.startswith(&quot;-B&quot;):
                    # Calling 'normpath' is necessary to remove any possible
                    # trailing /.
                    objdir = os.path.dirname(os.path.normpath(o[2:]))
                    break
                else:
                    result.SetOutcome(result.ERROR,
                                      &quot;Cannot find build directory; no -B in &quot;
                                      &quot;compiler options&quot;)
                    return

            objdir = os.path.abspath(objdir)
            blddir = os.path.normpath(os.path.join(objdir,
                                                   target,
                                                   directory,
                                                   &quot;libstdc++-v3&quot;))
            outdir = os.path.join(blddir, &quot;testsuite&quot;)
        else:
            # User must provide build directory.
            # Our code always refers to this directory as 'outdir' for
            # parallelism with the DejaGNU code we emulate, but we call
            # it &quot;scratch_dir&quot; for UI purposes.
            if context.has_key(&quot;V3Init.outdir&quot;):
                result.SetOutcome(result.ERROR,
                                  &quot;Set V3Init.scratch_dir, not outdir&quot;)
                return
            outdir = context[&quot;V3Init.scratch_dir&quot;]
            outdir = os.path.abspath(outdir)
            if not os.path.exists(outdir):
                os.mkdir(outdir)
            
        context[&quot;V3Init.outdir&quot;] = outdir

#         print &quot;options = %s&quot; % repr(options)
#         print &quot;directory = '%s'&quot; % directory
#         print &quot;objdir = '%s'&quot; % objdir
#         print &quot;target = '%s'&quot; % target
#         print &quot;blddir = '%s'&quot; % blddir
#         print &quot;outdir = '%s'&quot; % outdir
#         print &quot;srcdir = '%s'&quot; % srcdir

        # Ensure that the message format files are available.
        # This requires different commands depending on whether we're
        # using the gcc build system or not.
        if not standalone:
            locale_dir = os.path.join(blddir, &quot;po&quot;)
            make_command = [&quot;make&quot;, &quot;-j1&quot;, &quot;check&quot;]
        else:
            # Standalone build needs to set up the locale stuff in its
            # own directory.
            locale_dir = os.path.join(outdir, &quot;qm_locale&quot;)
            try:
                os.mkdir(locale_dir)
            except OSError:
                pass
            makefile_in = open(os.path.join(standalone_root,
                                                  &quot;qm-misc&quot;,
                                                  &quot;locale-Makefile&quot;))
            makefile_str = makefile_in.read()
            makefile_str = makefile_str.replace(&quot;@ROOT@&quot;,
                                                standalone_root)
            makefile_out = open(os.path.join(locale_dir, &quot;Makefile&quot;),
                                &quot;w&quot;)
            makefile_out.write(makefile_str)
            makefile_out.close()
            make_command = [&quot;make&quot;, &quot;-j1&quot;, &quot;locales&quot;]

        make_executable = RedirectedExecutable()
        status = make_executable.Run(make_command, dir=locale_dir)
        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            result.SetOutcome(result.ERROR,
                              &quot;Error building locale information&quot;,
                              {&quot;status&quot;: str(status),
                               &quot;stdout&quot;: &quot;&lt;pre&gt;&quot;
                                         + make_executable.stdout
                                         + &quot;&lt;/pre&gt;&quot;,
                               &quot;stderr&quot;: &quot;&lt;pre&gt;&quot;
                                         + make_executable.stderr
                                         + &quot;&lt;/pre&gt;&quot;,
                               &quot;command&quot;: &quot; &quot;.join(make_command),
                               })
            return
            

        # Copy data files.
        for file in &quot;*.tst&quot;, &quot;*.txt&quot;:
            if os.path.isdir(os.path.join(srcdir, &quot;data&quot;)):
                # 3.4+ store these files in a special data/ directory.
                subdirs = [&quot;data&quot;]
            else:
                # But earlier versions store them scattered through the
                # tree.
                subdirs = [&quot;*&quot;, os.path.join(&quot;*&quot;, &quot;*&quot;)]
            for subdir in subdirs:
                for f in glob.glob(os.path.join(srcdir, subdir, file)):
                    shutil.copy(f, outdir)
        
        # Set up environment and -L switches.
        for name in _ld_library_path_names:
            if os.environ.has_key(name):
                original_ld_library_path = os.environ[name].split(&quot;:&quot;)
                break
        else:
            original_ld_library_path = []
        libpaths = []
        # Each branch sets ld_library_path and modifies libpaths.
        if not standalone:
            gccdir = os.path.join(objdir, &quot;gcc&quot;)
            libpaths.append(gccdir)
            command = compiler.GetPath()
            compiler_executable.Run([compiler.GetPath()]
                                    + options
                                    + [&quot;--print-multi-lib&quot;])
            for line in compiler_executable.stdout.split():
                dir, args = line.split(&quot;;&quot;, 1)
                if dir == &quot;.&quot;:
                    continue
                if glob.glob(os.path.join(gccdir, dir, &quot;libgcc_s*.so.*&quot;)):
                    libpaths.append(dir)

            libpaths.append(os.path.join(blddir, &quot;src&quot;, &quot;.libs&quot;))
            ld_library_path = &quot;:&quot;.join(libpaths + original_ld_library_path)
        else:

            ld_library_path = &quot;:&quot;.join(original_ld_library_path)

        libpaths.append(outdir)
        context[&quot;V3Init.libpaths&quot;] = libpaths
        context[&quot;V3Init.ld_library_path&quot;] = ld_library_path
        result[&quot;V3Init.ld_library_path&quot;] = ld_library_path

        # Calculate default g++ flags.  Both branches create basic_flags
        # and default_flags.
        if not standalone:
            # Use the build tree mechanisms.
            try:
                all_flags = self._CalcBuildTreeFlags(result, context,
                                                     blddir, compiler)
            except:
                result.NoteException(cause=&quot;Error calculating default flags&quot;,
                                     outcome=Result.FAIL)
                return
            basic_flags, default_flags = all_flags
        else:
            # We take the union of the 3.3 and the 3.4 defines; it
            # doesn't seem to hurt.
            basic_flags = [# v3.4 only:
                           &quot;-D_GLIBCXX_ASSERT&quot;,
                           # v3.3 only:
                           &quot;-DDEBUG_ASSERT&quot;,
                           # Common:
                           &quot;-g&quot;, &quot;-O2&quot;,
                           &quot;-ffunction-sections&quot;, &quot;-fdata-sections&quot;,
                           &quot;-fmessage-length=0&quot;,
                           &quot;-DLOCALEDIR=\&quot;%s\&quot;&quot; % locale_dir,
                           &quot;-I%s&quot; % srcdir]
            default_flags = []

        default_flags.append(&quot;-D_GLIBCXX_ASSERT&quot;)
        if fnmatch.fnmatch(context[&quot;DejaGNUTest.target&quot;],
                           &quot;powerpc-*-darwin*&quot;):
            default_flags += [&quot;-multiply_defined&quot;, &quot;suppress&quot;]
        context[&quot;V3Init.basic_cxx_flags&quot;] = basic_flags
        context[&quot;V3Init.default_cxx_flags&quot;] = default_flags
        
        if standalone:
            # Build libv3test.a.
            makefile_in = open(os.path.join(standalone_root,
                                            &quot;qm-misc&quot;,
                                            &quot;util-Makefile&quot;))
            makefile_str = makefile_in.read()
            makefile_str = makefile_str.replace(&quot;@ROOT@&quot;,
                                                standalone_root)
            makefile_str = makefile_str.replace(&quot;@CXX@&quot;,
                                                compiler.GetPath())
            flags = compiler.GetOptions() + basic_flags
            makefile_str = makefile_str.replace(&quot;@CXXFLAGS@&quot;,
                                                &quot; &quot;.join(flags))
            makefile_out = open(os.path.join(outdir, &quot;Makefile&quot;), &quot;w&quot;)
            makefile_out.write(makefile_str)
            makefile_out.close()
            
            make_executable = RedirectedExecutable()
            make_command = [&quot;make&quot;, &quot;libv3test.a&quot;]
            status = make_executable.Run(make_command, dir=outdir)
            if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
                result.SetOutcome(result.ERROR,
                                  &quot;Error building libv3test.a&quot;,
                                  {&quot;status&quot;: str(status),
                                   &quot;stdout&quot;: &quot;&lt;pre&gt;&quot;
                                             + make_executable.stdout
                                             + &quot;&lt;/pre&gt;&quot;,
                                   &quot;stderr&quot;: &quot;&lt;pre&gt;&quot;
                                             + make_executable.stderr
                                             + &quot;&lt;/pre&gt;&quot;,
                                   &quot;command&quot;: &quot; &quot;.join(make_command),
                                   })
                return

        
    def _CalcBuildTreeFlags(self, result, context, blddir, compiler):
        &quot;&quot;&quot;This function emulates a bit of normal.exp and a bit of
        v3-init.&quot;&quot;&quot;

        basic_flags = []
        default_flags = []

        # Find the command to use.
        for subdir in &quot;&quot;, &quot;scripts&quot;:
            command = os.path.join(blddir, subdir, &quot;testsuite_flags&quot;)
            if os.path.isfile(command):
                break

        result[&quot;V3Init.testsuite_flags_command&quot;] = \
            &quot;&lt;pre&gt;&quot; + command + &quot;&lt;/pre&gt;&quot;

        executable = RedirectedExecutable()
        executable.Run([command, &quot;--cxxflags&quot;])
        basic_flags += executable.stdout.split()
        executable.Run([command, &quot;--build-includes&quot;])
        basic_flags += executable.stdout.split()

        # 'normal.exp' checks for the existence of 'testsuite_flags' and
        # pretends the output is &quot;&quot; if it doesn't exist; we simply
        # assume it always exists.
        executable.Run([command, &quot;--cxxpchflags&quot;])
        if executable.stdout.find(&quot;sage:&quot;) != -1:
            # This 'testsuite_flags' does not support --cxxpchflags.
            pass
        else:
            default_flags += executable.stdout.split()

        return (basic_flags, default_flags)

# dg-runtest calls dg-test calls &quot;libstdc++-dg-test prog do_what
# DEFAULT_CXXFLAGS&quot; (DEFAULT_CXXFLAGS as in normal.exp)
# Which calls
#   v3_target_compile $prog $output_file $compile_type additional_flags=$DEFAULT_CXXFLAGS
# Which sets cxx_final to &quot;$cxx [libgloss_link_flags] $cxxflags $includes&quot;
# then calls
#   target_compile $prog $output_file $compile_type additional_flags=$DEFAULT_CXXFLAGS,compiler=$cxx_final,ldflags=-L$blddir/testsuite,libs=-lv3test
# for us, libgloss doesn't exist, which simplifies things.

class V3DGTest(DGTest, GCCTestBase):
    &quot;&quot;&quot;A 'V3DGTest' is a libstdc++-v3 test using the 'dg' driver.

    This test class emulates the 'lib/libstdc++.exp' and 'lib/prune.exp
    and 'libstdc++-dg/normal.exp' source files in the libstdc++-v3
    testsuite.&quot;&quot;&quot;

    _default_kind = DGTest.KIND_RUN

    _language = &quot;cplusplus&quot;

    _libdir_context_property = &quot;V3Init.libpaths&quot;

    def Run(self, context, result):

        self._SetUp(context)
        self._RunDGTest(context[&quot;V3Init.basic_cxx_flags&quot;],
                        context[&quot;V3Init.default_cxx_flags&quot;],
                        context,
                        result)
        

    def _PruneOutput(self, output):
        &quot;&quot;&quot;This method emulates 'prune.exp'.&quot;&quot;&quot;

        # Prune out Cygwin warnings and parts of warnings that refer to
        # location of previous definitions etc.
        output = re.sub(r&quot;(^|\n)[^\n]*: -ffunction-sections may affect &quot;
                        r&quot;debugging on some targets[^\n]&quot;,
                        &quot;&quot;, output)
        output = re.sub(r&quot;(^|\n)[^\n]*: In function [^\n]*&quot;, &quot;&quot;, output)
        return output


    def _GetTargetEnvironment(self, context):

        env = {}
        for name in _ld_library_path_names:
            env[name] = context[&quot;V3Init.ld_library_path&quot;]
        return env


    def _RunTargetExecutable(self, context, result, file, dir = None):

        if dir is None:
            dir = context[&quot;V3Init.outdir&quot;]

        sup = super(V3DGTest, self)
        return sup._RunTargetExecutable(context, result, file, dir)


    def _RunTool(self, path, kind, options, context, result):
        &quot;&quot;&quot;This method emulates libstdc++-dg-test.&quot;&quot;&quot;

        source_files = [path]
        
        file = self._GetOutputFile(context, kind, path)
        kind = self._test_kind_map[kind]

        if kind == GCCTestBase.KIND_EXECUTABLE:
            source_files += [&quot;-lv3test&quot;]

        output = self._Compile(context, result, source_files, file,
                               kind, options)
        return (output, file)


    def _GetOutputFile(self, context, kind, path):

        base = os.path.basename(path)
        if kind != self.KIND_PRECOMPILE:
            base = os.path.splitext(base)[0]
        base += { DGTest.KIND_PREPROCESS : &quot;.i&quot;,
                  DGTest.KIND_COMPILE : &quot;.s&quot;,
                  DGTest.KIND_ASSEMBLE : &quot;.o&quot;,
                  DGTest.KIND_LINK: &quot;.exe&quot;,
                  DGTest.KIND_RUN : &quot;.exe&quot;,
                  GCCTestBase.KIND_PRECOMPILE : &quot;.gch&quot;,
                  }[kind]

        return os.path.join(context.GetTemporaryDirectory(), base)


    def _DGrequire_iconv(self, line_num, args, context):
        &quot;&quot;&quot;Emulate the 'dg-require-iconv' command.

        Emulates code from 'libstdc++-v3/testsuite/lib/dg-options.exp'
        and 'gcc/testsuite/lib/target-supports.exp'.
        
        'line_num' -- The number at which the command was found.

        'args' -- The arguments to the command, as a list of
        strings.

        'context' -- The 'Context' in which the test is running.&quot;&quot;&quot;

        # Parse arguments.
        if len(args) != 1:
            self._Error(&quot;dg-require-iconv: wrong number of arguments&quot;)
            return

        charset = args[0]

        # Check to see if iconv does exist and work.
        # First by creating and compiling a test program...
        tmpdir = context.GetTemporaryDirectory()
        tmpc = os.path.join(tmpdir, &quot;tmp.c&quot;)
        tmpx = os.path.join(tmpdir, &quot;tmp.x&quot;)
        f = open(tmpc, &quot;w&quot;)
        f.write(&quot;&quot;&quot;\
#include &lt;iconv.h&gt;
int main (void)
{
    iconv_t cd;
    cd = iconv_open(&quot;%(charset)s&quot;, &quot;UTF-8&quot;);
    if (cd == (iconv_t) -1)
        return 1;
    return 0;
}
&quot;&quot;&quot;
                % {&quot;charset&quot;: charset})
        f.close()

        compiler = context[&quot;CompilerTable.compiler_table&quot;][self._language]
        options = []

        options += context[&quot;V3Init.basic_cxx_flags&quot;]
        options += context[&quot;V3Init.default_cxx_flags&quot;]
        libpaths = context[&quot;V3Init.libpaths&quot;]
        options += [&quot;-L&quot; + p for p in libpaths]

        if context.has_key(&quot;GCCTest.libiconv&quot;):
            libiconv_opts = context[&quot;GCCTest.libiconv&quot;].split()
        else:
            libiconv_opts = []
        
        (status, output) = compiler.Compile(compiler.MODE_LINK,
                                            [tmpc] + libiconv_opts,
                                            tmpdir, options, tmpx)
        if output == &quot;&quot;:
            # ...and then running it, if there are no errors.
            executable = self.TargetExecutable(self.executable_timeout)
            command = [tmpx]
            environment = self._GetTargetEnvironment(context)
            status = executable.Run(command, environment, tmpdir)
            if os.WIFEXITED(status) and os.WEXITSTATUS(status) == 0:
                # We have working libiconv.  Continue as normal.
                return

        # Something went wrong somewhere -- libiconv is not available.
        # Turn off the test.
        self._selected = 0
        # Not clear that setting the expectation here serves any
        # purpose, but it's what 'dg-options.exp' does, so we do too.
        self._expectation = Result.PASS



# check-abi first builds
#    abi_check
#    baseline_symbols
#    current_symbols.txt
# then does
#    ./abi_check --check(-verbose) ./current_symbols.txt ${baseline_file}
#
# abi_check is built by automake as a program.
# baseline_symbols just checks to see if a baseline file exists
# current_symbols.txt depends on ${extract_symvers} ../src/.libs/libstdc++.so
#
#
# new-abi-baseline is what actually generates a new baseline.
# it does it with ${extract_symvers} ../src/.libs/libstdc++.so ${baseline_file}
# baseline_file = ${baseline_dir}/baseline_symbols.txt
# baseline_dir is set by autoconf to some mad thing...
#    $glibcxx_srcdir/config/abi/${abi_baseline_pair}\$(MULTISUBDIR)&quot;
# abi_baseline_pair is set by autoconf to host_cpu-host_os by default.
# but there are some special cases, in particular:
#    x86_64-*-linux*     -&gt; x86_64-linux-gnu
#    alpha*-*-freebsd5*  -&gt; alpha-freebsd5
#    i*86-*-freebsd4*    -&gt; i386-freebsd4
#    i*86-*-freebsd5*    -&gt; i386-freebsd5
#    sparc*-*-freebsd5*  -&gt; sparc-freebsd5
#
# extract_symvers = $(glibcxx_srcdir)/scripts/extract_symvers
# extract_symvers is actually just a shell script
        
class V3ABITest(Test):
    &quot;&quot;&quot;A 'V3ABITest' checks the ABI of libstdc++ against a baseline.

    Depends on context variable 'V3Test.abi_baseline_file'.&quot;&quot;&quot;

    def Run(self, context, result):

        # Some variables we'll need throughout.
        executable = RedirectedExecutable()
        tmpdir = context.GetTemporaryDirectory()
        outdir = context[&quot;V3Init.outdir&quot;]
        srcdir = self.GetDatabase().GetRoot()

        # First we make sure that the abi_check program exists.
        abi_check = os.path.join(outdir, &quot;abi_check&quot;)
        status = executable.Run([&quot;make&quot;, &quot;abi_check&quot;], dir=outdir)
        result[&quot;make_abi_check_stdout&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stdout
                                           + &quot;&lt;/pre&gt;&quot;)
        result[&quot;make_abi_check_stderr&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stderr
                                           + &quot;&lt;/pre&gt;&quot;)
        result[&quot;make_abi_check_status&quot;] = str(status)
        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            result.SetOutcome(result.ERROR, &quot;Error building abi_check&quot;)
            return
        if not os.path.isfile(abi_check):
            result.SetOutcome(result.ERROR,
                              &quot;No abi_check program '%s'&quot; % abi_check)
            return

        # Now make sure the baseline file exists.
        baseline_type = self._GetAbiName(context[&quot;DejaGNUTest.target&quot;])
        baseline_file = os.path.join(srcdir, &quot;..&quot;, &quot;config&quot;, &quot;abi&quot;,
                                     baseline_type,
                                     &quot;baseline_symbols.txt&quot;)
        result[&quot;baseline_file&quot;] = baseline_file
        if not os.path.isfile(baseline_file):
            result.SetOutcome(result.ERROR,
                              &quot;No baseline file '%s'&quot; % baseline_file)
            return

        # Check that we have the 'extract_symvers' script.
        # 3.4+ stores it in scripts; 3.3 stores it in config/abi.
        subdirs = [&quot;scripts&quot;, os.path.join(&quot;config&quot;, &quot;abi&quot;)]
        for subdir in subdirs:
            extract_symvers = os.path.join(srcdir, &quot;..&quot;,
                                           subdir,
                                           &quot;extract_symvers&quot;)
            if os.path.isfile(extract_symvers):
                break
        else:
            result.SetOutcome(result.ERROR,
                              &quot;Can't find extract_symvers&quot;)
            return

        # Extract the current symbols.
        # First use ldd to find the libstdc++ in use.
        status = executable.Run([&quot;ldd&quot;, &quot;abi_check&quot;], dir=outdir)
        result[&quot;ldd_stdout&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stdout
                                            + &quot;&lt;/pre&gt;&quot;)
        result[&quot;ldd_stderr&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stderr
                                            + &quot;&lt;/pre&gt;&quot;)
        result[&quot;ldd_status&quot;] = str(status)
        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            result.SetOutcome(result.ERROR,
                              &quot;Error running ldd to find libstdc++&quot;)
            return
        for token in executable.stdout.split():
            if os.sep in token and token.find(&quot;libstdc++&quot;) != -1:
                libstdcpp = token
                break
        else:
            result.SetOutcome(result.ERROR,
                              &quot;Could not find path to libstdc++ in &quot;
                              &quot;ldd output&quot;)
            return
#         libstdcpp = os.path.join(outdir, &quot;..&quot;, &quot;src&quot;, &quot;.libs&quot;,
#                                  &quot;libstdc++.so&quot;)
        result[&quot;libstdcpp_path&quot;] = libstdcpp

        curr_symbols = os.path.join(tmpdir, &quot;current_symbols.txt&quot;)
        status = executable.Run([extract_symvers,
                                 libstdcpp,
                                 curr_symbols])
        result[&quot;extract_symvers_stdout&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stdout
                                            + &quot;&lt;/pre&gt;&quot;)
        result[&quot;extract_symvers_stderr&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stderr
                                            + &quot;&lt;/pre&gt;&quot;)
        result[&quot;extract_symvers_status&quot;] = str(status)
        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            result.SetOutcome(result.ERROR, &quot;Error extracting symbols&quot;)
            return
        if not os.path.isfile(curr_symbols):
            result.SetOutcome(result.ERROR, &quot;No symbols extracted&quot;)
            return

        # We have the checker program, we have the baseline, we have the
        # current symbols.  Now we use the former to compare the
        # latter.
        status = executable.Run([abi_check, &quot;--check-verbose&quot;,
                                 curr_symbols, baseline_file])
        result[&quot;comparison_stdout&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stdout
                                            + &quot;&lt;/pre&gt;&quot;)
        result[&quot;comparison_stderr&quot;] = (&quot;&lt;pre&gt;&quot; + executable.stderr
                                            + &quot;&lt;/pre&gt;&quot;)
        result[&quot;comparison_status&quot;] = str(status)
        if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            result.SetOutcome(result.ERROR,
                              &quot;Error comparing symbols to baseline&quot;)
            return

        # Parse the output.
        for line in executable.stdout.split(&quot;\n&quot;):
            if line.startswith(&quot;# of &quot;):
                num_changes_str = line.split(&quot;:&quot;, 1)[1].strip()
                num_changes = int(num_changes_str)
                if num_changes != 0:
                    result.Fail(&quot;Changes against ABI baseline detected&quot;)
                    result[&quot;failing_line&quot;] = line.strip()
                    return


    def _GetAbiName(self, host):
        &quot;&quot;&quot;Map a target triple to a abi directory name.

        Emulates 'configure.host'.&quot;&quot;&quot;

        cpu, vendor, os = host.split(&quot;-&quot;, 2)
        m = fnmatch.fnmatch
        if m(cpu, &quot;alpha*&quot;):
            cpu = &quot;alpha&quot;
        elif m(cpu, &quot;i[567]86&quot;) or m(cpu, &quot;x86_64&quot;):
            cpu = &quot;i486&quot;
        elif m(cpu, &quot;hppa*&quot;):
            cpu = &quot;hppa&quot;
        elif m(cpu, &quot;powerpc*&quot;) or m(cpu, &quot;rs6000&quot;):
            cpu = &quot;powerpc&quot;
        elif m(cpu, &quot;s390x&quot;):
            cpu = &quot;s390&quot;
        elif m(cpu, &quot;sparc*&quot;) or m(cpu, &quot;ultrasparc&quot;):
            cpu = &quot;sparc&quot;

        return &quot;%s-%s&quot; % (cpu, os)
            
-------------- next part --------------
########################################################################
#
# File:   v3_database.py
# Author: Nathaniel Smith
# Date:   03/01/2004
#
# Contents:
#   V3Database
#
# Copyright (c) 2004 by CodeSourcery, LLC.  All rights reserved. 
#
########################################################################

########################################################################
# Imports
########################################################################

import fnmatch
import os
import qm
import qm.test.base
from   qm.attachment import Attachment, FileAttachmentStore
from   qm.test.database import ResourceDescriptor, TestDescriptor
from   qm.test.file_database import FileDatabase
from   qm.test.runnable import Runnable

########################################################################
# Classes
########################################################################

class V3Database(FileDatabase):
    &quot;&quot;&quot;A 'V3Database' stores the libstc++-v3 regression tests.&quot;&quot;&quot;

    arguments = [
        qm.fields.TextField(
            name = &quot;srcdir&quot;,
            title = &quot;Source Directory&quot;,
            description =&quot;&quot;&quot;The root of the libstdc++-v3 test source directory.

            This directory is the one named 'testsuite'.&quot;&quot;&quot;),
        # The libstdc++ database uses filenames as labels.
        qm.fields.TextField(
            name = &quot;label_class&quot;,
            default_value = &quot;file_label.FileLabel&quot;,
            computed = &quot;true&quot;
            ),
        # The libstdc++ database cannot be modified programmatically.
        qm.fields.BooleanField(
            name = &quot;modifiable&quot;,
            default_value = &quot;false&quot;,
            computed = &quot;true&quot;,
            ),
        ]
    
    def __init__(self, path, arguments):

        # Initialize the base class.
        super(V3Database, self).__init__(path, arguments)
        # Create an attachment store.
        self.__store = FileAttachmentStore()

        
    def GetResource(self, resource_id):

        if resource_id == &quot;compiler_table&quot;:
            return ResourceDescriptor(self, resource_id,
                                      &quot;compiler_table.CompilerTable&quot;,
                                      {})
        elif resource_id == &quot;v3_init&quot;:
            return ResourceDescriptor(self, resource_id,
                                      &quot;v3_test.V3Init&quot;,
                                      { Runnable.RESOURCE_FIELD_ID :
                                        [&quot;compiler_table&quot;] })

        raise self.NoSuchResourceError, resource_id
        
        
    def GetRoot(self):

        return self.srcdir


    def GetAttachmentStore(self):

        return self.__store


    def GetTestIds(self, directory=&quot;&quot;, scan_subdirs=1):

        result = super(V3Database, self).GetTestIds(directory,
                                                    scan_subdirs)
        if directory == &quot;&quot;:
            return result + [&quot;v3_abi_test&quot;]
        else:
            return result


    def GetTest(self, test_id):

        if test_id == &quot;v3_abi_test&quot;:
            return TestDescriptor(self, test_id,
                                  &quot;v3_test.V3ABITest&quot;,
                                  { Runnable.RESOURCE_FIELD_ID:
                                    [&quot;v3_init&quot;]})
        else:
            return super(V3Database, self).GetTest(test_id)
        

    def _GetTestFromPath(self, test_id, path):

        # Construct the attachment representing the primary source
        # file.
        basename = os.path.basename(path)
        attachment = Attachment(&quot;text/plain&quot;, basename,
                                basename, path,
                                self.GetAttachmentStore())

        # Create the test descriptor.
        resources = [&quot;v3_init&quot;]
        descriptor = TestDescriptor(self, test_id,
                                    &quot;v3_test.V3DGTest&quot;,
                                    { 'source_file' : attachment,
                                      Runnable.RESOURCE_FIELD_ID :
                                        resources })

        return descriptor
        
                

    def _IsResourceFile(self, path):

        # No resources are stored in files.
        return False

        
    def _IsSuiteFile(self, path):

        # All directories are suites.
        return os.path.isdir(path)

        
    def _IsTestFile(self, path):
        &quot;&quot;&quot;This function emulates scripts/create_testsuite_files.&quot;&quot;&quot;

        assert path.startswith(self.GetRoot() + os.sep)

        rel_path = path[len(self.GetRoot()) + 1:]
        if os.sep not in rel_path:
            return False

        if not rel_path.endswith(&quot;.cc&quot;):
            return False

        forbidden_substrings = [&quot;_xin&quot;, &quot;performance&quot;]
        # FIXME: create_testsuite_files checks to see if wchar_t support
        # is enabled (by checking for the existence of
        # $outdir/testsuite_wchar_t), and if it isn't, then &quot;wchar_t&quot; is
        # added to the forbidden list.  The right way to handle this in
        # QMTest is not obvious, so for now we ignore this.
        for f in forbidden_substrings:
            if rel_path.find(f) != -1:
                return False

        return True
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000818.html">[qmtest] SPAM from this list.
</A></li>
	<LI>Next message: <A HREF="000821.html">[qmtest] [PATCH] qmtest_gcc: Support libstdc++ testing under QMTest
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#819">[ date ]</a>
              <a href="thread.html#819">[ thread ]</a>
              <a href="subject.html#819">[ subject ]</a>
              <a href="author.html#819">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/qmtest">More information about the qmtest
mailing list</a><br>
</body></html>
